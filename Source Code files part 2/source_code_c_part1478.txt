\n",
                         cb ));
        }
    }

    Win4Assert( 0 != _hMap );

    if ( 0 == offHigh && 0 == _sizeHigh )
    {
        Win4Assert( offLow < _sizeLow );
        Win4Assert( offLow + cb <= _sizeLow );
    }

    void* buf = MapViewOfFile( _hMap,
                               _fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                               offHigh,
                               offLow,
                               cb );

    if ( 0 == buf )
    {
        ciDebugOut(( DEB_ERROR,
                     "CMmStream::Map -- MapViewOfFile returned %d\n",
                     GetLastError() ));
        THROW( CException() );
    }

    sbuf.SetBuf( buf );
    sbuf.SetSize ( cb );
    sbuf.SetStream ( this );

    _cMap++;
} //Map

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Unmap, public
//
//  Synopsis:   Unmap the view of file
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------
void CMmStream::Unmap( CMmStreamBuf& sbuf )
{
    //
    // Note that UnmapViewOfFile doesn't take a _hMap, and the _hMap used
    // to map the view may already have been closed (but is kept open by
    // the refcount due to the view).  The current _hMap may be different
    // than the one used to create the view.
    //

    if ( _cMap > 0 )
    {
    
        if ( !UnmapViewOfFile( sbuf.Get() ) )
        {
            ciDebugOut(( DEB_ERROR, "UnmapViewOfFile returned %d\n",
                         GetLastError() ));

            //
            // don't throw! -- unmap is called from destructors and can fail
            // if the system is really busy
            //
        }

        _cMap--;
    }

    sbuf.SetBuf( 0 );
} //Unmap

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Flush, public
//
//  Synopsis:   Flush the view back to disk
//
//  History:    10-Mar-93 BartoszM  Created
//              04-Mar-98 KitmanH   Only flush if CMmStream is writable
//
//--------------------------------------------------------------------------

void CMmStream::Flush( CMmStreamBuf& sbuf, ULONG cb, BOOL fThrowOnFailure )
{
    if ( _fWrite )
    {
        BOOL fOk = FlushViewOfFile( sbuf.Get(), cb );

        if ( !fOk )
        {
            ciDebugOut(( DEB_WARN,
                         "FlushViewOfFile failed, error %d, throwing: %d\n",
                         GetLastError(), fThrowOnFailure ));

            if ( fThrowOnFailure )
            {
                //Win4Assert( !"FlushViewOfFile failed!" );
                THROW( CException() );
            }
        }

        Win4Assert( INVALID_HANDLE_VALUE != _hFile );
    }
} //Flush

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::FlushMetaData, public
//
//  Synopsis:   Flush any and all metadata for a file to disk
//
//  History:    5-Mar-01 dlee  Created
//
//--------------------------------------------------------------------------

void CMmStream::FlushMetaData( BOOL fThrowOnFailure )
{
    if ( _fWrite )
    {
        //
        // FlushViewOfFile writes the contents of the file to disk.
        // FlushFileBuffers writes the metadata to disk.
        //

        if ( INVALID_HANDLE_VALUE != _hFile )
        {
            BOOL fOk = FlushFileBuffers( _hFile );

            if ( !fOk && fThrowOnFailure )
            {
                THROW( CException() );
            }
        }
    }
} //FlushMetaData

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::ShrinkFromFront, public
//
//  Synopsis:   Decommits the front part of a file
//
//  Arguments:  [iFirstPage] -- the first 4k page to decommit
//              [cPages]     -- # of 4k pages to decommit
//
//  Returns:    # of 4k pages actually shrunk
//
//  History:    4-Nov-97 dlee  Created
//
//--------------------------------------------------------------------------

ULONG CMmStream::ShrinkFromFront( ULONG iFirstPage, ULONG cPages )
{
    ciDebugOut(( DEB_ITRACE, "SFF attempt start 4k page 0x%x, 0x%x pages\n",
                 iFirstPage, cPages ));
    Win4Assert( INVALID_HANDLE_VALUE != _hFile );

    Win4Assert( !_fIsReadOnly );
    Win4Assert( _fWrite );

    if ( !_fSparse )
        return 0;

    if ( 0 == cPages )
        return 0;

    //
    // When NTFS/MM check in support for zeroing part of a file
    // while another part of the file has a mapped view open, change this
    // code to not check _cMap and to not close/repoen _hMap.

    //
    // If there are open views on the mapping, we can't shrink since NTFS
    // doesn't support this.  Views will be open if there are active queries
    // using the current master index.
    //

    if ( 0 != _cMap )
    {
        ciDebugOut(( DEB_ITRACE, "can't SFF, %d mappings are open\n", _cMap ));
        return 0;
    }

    //
    // Close the mapping; NTFS doesn't allow shrinking with an open map
    //

    if ( 0 != _hMap )
    {
        CloseHandle( _hMap );
        _hMap = 0;
    }

    //
    // Send the fsctl to do the truncation on 64k boundaries.
    //

    cPages = ( cPages * 16 ) / 16;

    if ( 0 == cPages )
        return 0;

    FILE_ZERO_DATA_INFORMATION zeroInfo;
    zeroInfo.FileOffset.QuadPart = ( (LONGLONG) iFirstPage ) * 4096;
    zeroInfo.BeyondFinalZero.QuadPart = ( (LONGLONG) iFirstPage + cPages ) * 4096;

    IO_STATUS_BLOCK ioStatusBlock;
    CEventSem evt;
    evt.Reset();

    NTSTATUS s = NtFsControlFile( _hFile,
                                  evt.GetHandle(),
                                  0, 0,
                                  &ioStatusBlock,
                                  FSCTL_SET_ZERO_DATA,
                                  &zeroInfo,
                                  sizeof zeroInfo,
                                  0, 0 );

    //
    // NOTE: If this fails, do we really care?  Sure, we'll be wasting disk
    // space, but why abort the master merge because of this?  Let's wait
    // and see when/if it can fail.
    //

    if ( NT_ERROR( s ) )
    {
        ciDebugOut(( DEB_WARN, "set zero data failed 0x%x\n", s ));
        THROW( CException( s ) );
    }

    if ( STATUS_PENDING == s )
    {
        // wait for the io to complete

        ciDebugOut(( DEB_ITRACE, "SFF pending\n" ));
        evt.Wait();
        s = STATUS_SUCCESS;
    }

    ciDebugOut(( DEB_ITRACE, "SFF succeeded\n" ));

    //
    // Re-open the mapping
    //

    _hMap = CreateFileMapping( _hFile,
                               0, // security
                               PAGE_READWRITE,
                               _sizeHigh,
                               _sizeLow,
                               0 );
    if ( 0 == _hMap )
    {
        DWORD dw= GetLastError();
        ciDebugOut(( DEB_WARN, "can't re-establish the map in SFF %d\n", dw ));
        Close();
        THROW( CException( HRESULT_FROM_WIN32( dw ) ) );
    }

    return cPages;
} //ShrinkFromFront

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Read, public
//
//  Synopsis:   Reads from the stream
//
//  Arguments:  [pvBuffer]  -- Where the read data will go.  This buffer
//                             must be 0-filled for the full cbToRead.
//              [oStart]    -- Offset in the file where the read starts
//              [cbToRead]  -- # of bytes to read
//              [cbRead]    -- Returns the # of bytes actually read
//
//  History:    30-Oct-98 dlee  Created
//
//  Notes:      Win32 does not guarantee coherence if you mix read/write and
//              mapped IO in the same part of the file.
//
//--------------------------------------------------------------------------

void CMmStream::Read(
    void *    pvBuffer,
    ULONGLONG oStart,
    DWORD     cbToRead,
    DWORD &   cbRead )
{
    ciDebugOut(( DEB_ITRACE,
                 "ReadFile %#x, into %#p, offset %#I64x cb, %d\n",
                 _hFile, pvBuffer, oStart, cbToRead ));

    //
    // This function takes a zero-filled buffer.  If the buffer isn't zero-
    // filled, the caller has a bug.  Assume 8-byte alignment.
    //

    #if CIDBG == 1

        Win4Assert( 0 == ( ( (ULONG_PTR) pvBuffer ) & 7 ) );
        Win4Assert( 0 == ( cbToRead & 7 ) );

        LONGLONG *pll = (LONGLONG *) pvBuffer;
        unsigned cll = cbToRead / sizeof LONGLONG;

        for ( unsigned i = 0; i < cll; i++, pll++ )
            Win4Assert( 0 == *pll );
    
    #endif // CIDBG == 1

    _sizeLow = GetFileSize( _hFile, &_sizeHigh );

    if ( 0xffffffff == _sizeLow &&
         NO_ERROR != GetLastError() )
        THROW( CException() );

    //
    // Always read the amount requested, even if it doesn't exist on disk
    //

    cbRead = cbToRead;

    LARGE_INTEGER liSize;
    liSize.LowPart = _sizeLow;
    liSize.HighPart = _sizeHigh;

    //
    // Master merge asks for buffers after the end of the file.  The file
    // will be extended at when the buffer is written.
    //

    if ( liSize.QuadPart <= (LONGLONG) oStart )
        return;

    //
    // Truncate the read if the file isn't as large as requested
    //

    if ( liSize.QuadPart < (LONGLONG) ( oStart + cbToRead ) )
        cbToRead = (DWORD) ( liSize.QuadPart - oStart );

    //
    // The file is opened async, so the IO can be pending
    //

    LARGE_INTEGER li;
    li.QuadPart = oStart;

    CEventSem evt;

    OVERLAPPED o;
    o.Offset = li.LowPart;
    o.OffsetHigh = li.HighPart;
    o.hEvent = evt.GetHandle();

    DWORD cbFromFile;

    if ( !ReadFile( _hFile,
                    pvBuffer,
                    cbToRead,
                    &cbFromFile,
                    &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( ! GetOverlappedResult( _hFile, &o, &cbFromFile, TRUE ) )
                THROW( CException() );
        }
        else
            THROW( CException() );
    }

    Win4Assert( cbFromFile == cbToRead );
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Write, public
//
//  Synopsis:   Writes to the stream
//
//  Arguments:  [pvBuffer]  -- The data to write
//              [oStart]    -- Offset in the file where the write starts
//              [cbToWrite] -- # of bytes to write
//
//  History:    30-Oct-98 dlee  Created
//              23-Nov-98 KLam  Check for enough disk space
//              03-Dec-98 KLam  Don't close the stream if there isn't
//                              enough disk space
//
//  Notes:      Win32 does not guarantee coherence if you mix read/write and
//              mapped IO in the same part of the file.
//
//--------------------------------------------------------------------------

void CMmStream::Write(
    void *    pvBuffer,
    ULONGLONG oStart,
    DWORD     cbToWrite )
{
    ciDebugOut(( DEB_ITRACE,
                 "WriteFile %#x, from %#p, offset %#I64x cb, %d\n",
                 _hFile, pvBuffer, oStart, cbToWrite ));

    //
    // Make sure there is enough disk space
    //
    __int64 cbNewSize = oStart + (__int64) cbToWrite;
    LARGE_INTEGER sizeCurrent = { _sizeLow, _sizeHigh };
    
    if ( cbNewSize > sizeCurrent.QuadPart )
    {
        __int64 cbTotal, cbRemaining;
        Win4Assert ( !_xDriveInfo.IsNull() );
        _xDriveInfo->GetDiskSpace ( cbTotal, cbRemaining );
        if ( (cbNewSize - sizeCurrent.QuadPart) > cbRemaining )
        {
            ciDebugOut(( DEB_ERROR,
                         "CMmStream::Write -- Not enogh disk space, need %I64d have %I64d\n",
                         cbNewSize - sizeCurrent.QuadPart, cbRemaining ));
            THROW( CException( CI_E_CONFIG_DISK_FULL ) );
        }
    }
    
    //
    // The file is opened async, so the IO can be pending
    //

    LARGE_INTEGER li;
    li.QuadPart = oStart;

    CEventSem evt;

    OVERLAPPED o;
    o.Offset = li.LowPart;
    o.OffsetHigh = li.HighPart;
    o.hEvent = evt.GetHandle();

    DWORD cbWritten;

    if ( !WriteFile( _hFile,
                     pvBuffer,
                     cbToWrite,
                     &cbWritten,
                     &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( ! GetOverlappedResult( _hFile, &o, &cbWritten, TRUE ) )
                THROW( CException() );
        }
        else
            THROW( CException() );
    }

    _sizeLow = GetFileSize( _hFile, &_sizeHigh );

    if ( 0xffffffff == _sizeLow &&
         NO_ERROR != GetLastError() )
        THROW( CException() );
} //Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\isreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       isreg.cxx
//
//  Contents:   'Simple' registry access
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <isreg.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::CWin32RegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.  See ntrtl.h for constants.
//              [pwcsRegPath] -- Path to node.
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWin32RegAccess::CWin32RegAccess( HKEY keyRelative, WCHAR const * pwcsRegPath )
        : _hKey( (HKEY)INVALID_HANDLE_VALUE ),
          _wcsPath( 0 ),
          _iSubKey( 0 ),
          _dwLastError( ERROR_SUCCESS )
{
    _dwLastError = RegOpenKey( keyRelative, pwcsRegPath, &_hKey );

    if ( ERROR_SUCCESS != _dwLastError || (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        //
        // Try the ACSII version.  It may work on Win95.
        //

        int cc = wcslen( pwcsRegPath ) + 1;

        char * pszPath = new char [cc];

        if ( 0 != pszPath )
        {
            wcstombs( pszPath, pwcsRegPath, cc );

            RegOpenKeyA( keyRelative, pszPath, &_hKey );
        }

        delete [] pszPath;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::~CWin32RegAccess, public
//
//  Synopsis:   Destructor
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWin32RegAccess::~CWin32RegAccess()
{
    RegCloseKey( _hKey );
    delete [] _wcsPath;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Get( WCHAR const * pwcsKey,
                           WCHAR * wcsVal,
                           unsigned cc,
                           BOOL fExpandEnvironmentStrings )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwType;
    DWORD cb = cc * sizeof(WCHAR);
    wcsVal[0] = 0;

    _dwLastError = RegQueryValueEx( _hKey,
                                    pwcsKey,
                                    0,
                                    &dwType,
                                    (BYTE *)wcsVal,
                                    &cb );

    if ( ( ERROR_SUCCESS == _dwLastError ) &&
         ( ( wcsVal[0] == 0 ) || ( REG_SZ != dwType && REG_MULTI_SZ != dwType && REG_EXPAND_SZ != dwType ) ) )
        _dwLastError = ERROR_INVALID_PARAMETER;

    if ( fExpandEnvironmentStrings && ERROR_SUCCESS == _dwLastError && REG_EXPAND_SZ == dwType ) 
    {
        WCHAR wszFile[MAX_PATH + 1];
        wcscpy(wszFile, wcsVal);

        if ( 0 == ExpandEnvironmentStrings(wszFile, wcsVal, cc) )
            _dwLastError = GetLastError();
    }

    BOOL fOk = ( ERROR_SUCCESS == _dwLastError );

    #if 0
    //
    // Try the ASCII version.  It may work on Win95.
    //

    if ( !fOk )
    {
        int cc2 = wcslen( pwcsKey ) + 1;

        char * pszKey = new char [cc2];
        char * pszVal = new char [cc];
        cb = cc;

        if ( 0 != pszKey && 0 != pszVal )
        {
            wcstombs( pszKey, pwcsKey, cc );

            _dwLastError = RegQueryValueExA( _hKey, pszKey, 0, &dwType, (BYTE *)pszVal, &cb );

            if ( ( ERROR_SUCCESS == _dwLastError ) &&
                 ( ( wcsVal[0] == 0 ) || ( REG_SZ != dwType && REG_MULTI_SZ != dwType && REG_EXPAND_SZ != dwType ) ) )
                _dwLastError = ERROR_INVALID_PARAMETER;

            fOk = (ERROR_SUCCESS == _dwLastError );

            mbstowcs( wcsVal, pszVal, cb );

            delete [] pszVal;
            delete [] pszKey;
        }
    }
    #endif

    return fOk;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsName] -- Name of value to retrieve
//              [dwVal]    -- Returns the value
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//  Notes:      Value must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Get( WCHAR const * pwcsName,
                           DWORD &       dwVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwType;
    DWORD cb = sizeof DWORD;

    _dwLastError = RegQueryValueEx( _hKey,
                                    pwcsName,
                                    0,
                                    &dwType,
                                    (BYTE *)&dwVal,
                                    &cb );

    if ( ERROR_SUCCESS == _dwLastError && REG_DWORD != dwType )
        _dwLastError = ERROR_INVALID_PARAMETER;

    return ( ERROR_SUCCESS == _dwLastError );
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Set, public
//
//  Synopsis:   Sets the DWORD value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [dwVal]   --  Value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Set( WCHAR const * pwcsKey,
                           DWORD         dwVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsKey,
                                  0,
                                  REG_DWORD,
                                  (BYTE *)&dwVal,
                                  sizeof DWORD );

    return ( ERROR_SUCCESS == _dwLastError );
} //Set


//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Enum, public
//
//  Synopsis:   enums subkeys
//
//  Arguments:  [pwcsName] -- pointer to buffer of subkey name
//              [cwcName]  -- buffer size in WCHARs
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    4/24/98 mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Enum( WCHAR * pwszName, DWORD cwcName )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegEnumKey( _hKey,
                               _iSubKey,
                               pwszName,
                               cwcName );

    _iSubKey++;

    return ( ERROR_SUCCESS == _dwLastError );

} // Enum

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Set, public
//
//  Synopsis:   Sets the REG_SZ value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [wcsVal]   -- value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Set( WCHAR const * pwcsName,
                           WCHAR const * wcsVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD cb = sizeof WCHAR * ( 1 + wcslen( wcsVal ) );

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsName,
                                  0,
                                  REG_SZ,
                                  (BYTE *)wcsVal,
                                  cb );

    return (ERROR_SUCCESS == _dwLastError);
} //Set

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::SetMultiSZ, public
//
//  Synopsis:   Sets the REG_MULTI_SZ value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [wcsVal]   -- value to set
//              [cb]       -- count of bytes in the value
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::SetMultiSZ( WCHAR const * pwcsName,
                                  WCHAR const * wcsVal,
                                  DWORD         cb )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsName,
                                  0,
                                  REG_MULTI_SZ,
                                  (BYTE *)wcsVal,
                                  cb );

    return (ERROR_SUCCESS == _dwLastError);
} //SetMultiSZ

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Remove, public
//
//  Synopsis:   Removes a value name and its value
//
//  Arguments:  [pwcsName] -- Name of value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Remove( WCHAR const * pwcsName )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }
    else
        _dwLastError = ERROR_SUCCESS;  // Maintain existing behavior (ignore RegDelete result)

    RegDeleteValue( _hKey, pwcsName );

    return TRUE;
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::CreateKey, public
//
//  Synopsis:   Adds a key to the registry
//
//  Arguments:  [pwcsKey]  -- Key name
//              [fExisted] -- Returns TRUE the key already existed
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::CreateKey( WCHAR const * pwcsKey,
                                 BOOL &        fExisted )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwDisp;
    HKEY hKey;

    _dwLastError = RegCreateKeyEx( _hKey,
                                   pwcsKey,
                                   0,
                                   0,
                                   0,
                                   KEY_ALL_ACCESS,
                                   0,
                                   &hKey,
                                   &dwDisp );

    if ( ERROR_SUCCESS != _dwLastError )
    {
        SetLastError( _dwLastError );

        return FALSE;
    }

    RegCloseKey( hKey );
    fExisted = ( dwDisp == REG_OPENED_EXISTING_KEY );

    return TRUE;
} //CreateKey

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::RemoveKey, public
//
//  Synopsis:   Removes a key from the registry
//
//  Arguments:  [pwcsKey]  -- Key name
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    7-Apr-99 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::RemoveKey( WCHAR const * pwcsKey )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegDeleteKey( _hKey, pwcsKey );

    if ( ERROR_SUCCESS != _dwLastError )
    {
        SetLastError( _dwLastError );
        return FALSE;
    }

    return TRUE;
} //RemoveKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\vkrep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   QKREP.CXX
//
//  Contents:   Query Key Repository
//
//  Classes:    CQueryKeyRepository
//
//  History:    04-Jun-91    t-WadeR    Created.
//              23-Sep-91    BartosM    Rewrote to use phrase expr.
//              31-Jan-93    KyleP      Use restrictions, not expressions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vkrep.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::CRangeKeyRepository
//
//  Synopsis:   Creates Range Key repository
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeKeyRepository::CRangeKeyRepository ()
        : _count(0)
{
    _pRangeRst = new CRangeRestriction;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::~CRangeKeyRepository
//
//  Synopsis:   Destroys
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeKeyRepository::~CRangeKeyRepository()
{
    delete _pRangeRst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::AcqXpr
//
//  Synopsis:   Acquire Phrase Expression
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeRestriction* CRangeKeyRepository::AcqRst()
{
    CRangeRestriction* tmp = 0;

    if ( _count == 2 )
    {
        if( _pRangeRst->GetStartKey()->
            CompareStr( *_pRangeRst->GetEndKey() ) > 0 )
        {
            //
            // absolute false restriction
            //
            vqDebugOut(( DEB_ERROR, "Absolute false restriction" ));
            delete _pRangeRst;
        }
        else
        {
            tmp = _pRangeRst;
        }
        _pRangeRst = 0;
    }

    return tmp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::PutKey
//
//  Synopsis:   Puts a key into the key list and occurrence list
//
//  Arguments:  cNoiseWordsSkipped -- ignored (used by CQueryKeyRepository::PutKey )
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void  CRangeKeyRepository::PutKey ( ULONG cNoiseWordsSkipped )
{
    vqDebugOut (( DEB_ITRACE, "RangeKeyRepository::PutKey \"%.*ws\", pid=%d\n",
                  _key.StrLen(), _key.GetStr(), _key.Pid() ));
    Win4Assert ( _count < 2 );

    if (_count == 0)
        _pRangeRst->SetStartKey ( _key );
    else
        _pRangeRst->SetEndKey ( _key );
    _count++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Effects:
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    24-Sep-92   BartoszM    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRangeKeyRepository::GetBuffers( unsigned** ppcbWordBuf,
                                      BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::GetFlags
//
//  Synopsis:   Returns address of rank and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeKeyRepository::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    *ppRange = 0;
    *ppRank  = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\xact.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   XACT.CXX
//
//  Contents:   Transaction support
//
//  Classes:    CTransaction
//
//  History:    29-Mar-91   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xact.hxx>
#include <pstore.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CTransaction::CTransaction, public
//
//  Synopsis:   Begins a new transaction.
//
//  Requires:   Transactions are not nested too deep.
//
//  History:    23-Apr-91       KyleP       Replaces sesid with CSession
//              01-Apr-91       KyleP       Created.
//              13-Jan-92       BartoszM    Changed status to Abort
//
//----------------------------------------------------------------------------

CTransaction::CTransaction()
{
    _status = XActAbort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\keyarray.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       keyarray.cxx
//
//  Contents:   Key Array Class
//
//  Classes:    CKeyArray
//
//  History:    30-Jan-92       AmyA            Created
//              16-Apr-92       BartoszM        Reimplemented
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::CKeyArray, public
//
//  Synopsis:   Constructor of key array
//
//  Arguments:  [size] -- initial size
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
CKeyArray::CKeyArray(
    int  size,
    BOOL fThrow ) :
    _size(size),
    _count(0),
    _aKey(0),
    _fThrow( fThrow )
{
    // We don't want to use a vector constructor, since
    // this array may possibly be reallocated
    // (see CKeyArray::Grow)

    TRY
    {
        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];
    }
    CATCH( CException, e )
    {
        if ( fThrow )
            RETHROW();
    }
    END_CATCH;

    for ( int n = 0; n < _size; n++)
        _aKey[n].Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::CKeyArray, public
//
//  Synopsis:   Copy constructor of key array
//
//  Arguments:  [keyArray] -- key array to be copied
//
//  History:    29-Nov-94   SitaramR       Created.
//
//----------------------------------------------------------------------------

CKeyArray::CKeyArray(
    const CKeyArray& keyArray,
    BOOL             fThrow ) :
    _count( keyArray.Count() ),
    _size( _count ),
    _aKey( 0 ),
    _fThrow( fThrow )
{
    int i = 0;

    TRY
    {
        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];

        for ( i=0; i<_size; i++)
            _aKey[i].CKey::CKey( keyArray.Get(i) );
    }
    CATCH( CException, e )
    {
        for ( int j = 0; j < i; j++ )
            _aKey[ j ].Free();

        delete (BYTE *) _aKey;
        _aKey = 0;

        if ( fThrow )
            RETHROW();
    }
    END_CATCH;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::~CKeyArray, public
//
//  Synopsis:   Destroy all keys
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
CKeyArray::~CKeyArray()
{
    Win4Assert(_aKey || _count==0);

    if (_aKey)
    {
        for ( int i=0; i < _size; i++)
            _aKey[i].Free();
    }
    delete (BYTE *) _aKey;
}

void CKeyArray::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _count );

    for ( int i = 0; i < _count; i++ )
    {
        _aKey[i].Marshall( stm );
    }
}

CKeyArray::CKeyArray(
    PDeSerStream & stm,
    BOOL           fThrow ) :
    _count( stm.GetULong() ),
    _fThrow( fThrow ),
    _aKey( 0 )
{
    _size = _count;

    int i = 0;

    TRY
    {
        // guard against attack

        if ( _count > 10000 )
            THROW( CException( E_INVALIDARG ) );

        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];

        for ( i = 0; i < _size; i++)
            _aKey[i].CKey::CKey( stm );
    }
    CATCH( CException, e )
    {
        for ( int j = 0; j < i; j++ )
            _aKey[ j ].Free();

        delete (BYTE *) _aKey;
        _aKey = 0;

        if ( fThrow )
            RETHROW();
    }
    END_CATCH;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::TotalKeySize, public
//
//  Synopsis:   Calculate space needed to store all the keys
//
//  History:    30-Jun-93   BartoszM       Created.
//
//----------------------------------------------------------------------------
int CKeyArray::TotalKeySize() const
{
    int cb = 0;

    // calculate total byte count of key buffers
    for ( int i = 0; i < _count; i++)
    {
        cb += _aKey[i].Count();
    }
    // add space for pid and cb
    cb += _count * ( sizeof(ULONG) + sizeof(PROPID));
    return(cb);
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Grow, private
//
//  Synopsis:   Reallocate the array
//
//  Arguments:  [pos] -- position that mast fit into new array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Grow ( int pos )
{
    // cuDebugOut (( DEB_ITRACE, "Grow KeyArray form %d to %d\n", _size, pos ));
#if CIDBG == 1
    Display();
#endif // CIDBG == 1

    int sizeNew = 2 * _size;
    while ( sizeNew <= pos)
    {
        sizeNew *= 2;
    }

    XPtr<CKey> xKeyNew((CKey *)new BYTE [ sizeNew * sizeof(CKey) ]);

    memcpy ( xKeyNew.GetPointer(), _aKey, _size * sizeof(CKey) );

    for ( int n = _size; n < sizeNew; n++ )
        (xKeyNew.GetPointer())[n].Init();

    delete (BYTE *) _aKey;
    _aKey = xKeyNew.Acquire();
    _size = sizeNew;
#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add(const CKey& Key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( Key );
    else
    {
        TRY
        {
            _Add( Key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add(const CKeyBuf& Key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( Key );
    else
    {
        TRY
        {
            _Add( Key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add key at position by copying it from key buffer
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add( int pos, const CKeyBuf& key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( pos, key );
    else
    {
        TRY
        {
            _Add( pos, key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add key at posistion by copying it
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add( int pos, const CKey& key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( pos, key );
    else
    {
        TRY
        {
            _Add( pos, key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::FillMax, public
//
//  Synopsis:   Create a sentinel key at given position
//
//  Arguments:  [pos] -- position in array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::FillMax ( int pos )
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _FillMax( pos );
    else
    {
        TRY
        {
            _FillMax( pos );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add(const CKey& Key)
{
    if (_count == _size)
        _Grow(_count);

    _aKey[_count] = Key;
    _count++;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add(const CKeyBuf& Key)
{
    if (_count == _size)
        _Grow(_count);

    _aKey[_count] = Key;
    _count++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add key at position by copying it from key buffer
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add( int pos, const CKeyBuf& key)
{
    if ( pos >= _size)
        _Grow(pos);

    _aKey[pos] = key;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add key at posistion by copying it
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add( int pos, const CKey& key)
{
    if ( pos >= _size)
       _Grow(pos);

    _aKey[pos] = key;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_FillMax, private
//
//  Synopsis:   Create a sentinel key at given position
//
//  Arguments:  [pos] -- position in array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_FillMax ( int pos )
{
    if (pos >= _size)
        _Grow(pos);

    _aKey[pos].FillMax();
}

#if 0
void CKeyArray::Display()
{
    cuDebugOut (( DEB_ITRACE, "KeyArray: size %d\n", _size ));
    for (int i = 0; i < _size; i++)
    {
        cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%2d ", i ));
        int count = _aKey[i].Count();
        if ( count != 0 )
        {
            BYTE* buf = _aKey[i].GetBuf();
            for (int k = 0; k < count; k++)
            {
                cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%c", buf[k] ));
            }
            cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));
        }
        else
            cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "<NULL>\n" ));
    }
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\regacc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       RegAcc.cxx
//
//  Contents:   'Simple' registry access
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <regacc.hxx>
#include <regevent.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotifyKey::CRegNotifyKey, public
//
//  Purpose:    A smart pointer to a registry key
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

inline CRegNotifyKey::CRegNotifyKey( const WCHAR * wcsRegKey )
{
    wcscpy( _wcsKey, wcsRegKey );

    RtlInitUnicodeString( &_KeyName, _wcsKey );

    InitializeObjectAttributes( &_ObjectAttr,           // Structure
                                &_KeyName,              // Name
                                OBJ_CASE_INSENSITIVE,   // Attributes
                                NULL,                   // Root
                                NULL );                 // Security
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::CRegChangeEvent, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

CRegChangeEvent::CRegChangeEvent( const WCHAR * wcsRegKey,
                                  BOOL fDeferInit ) :
                         CRegNotifyKey( wcsRegKey ),
                         _regEvent(TRUE),
                         _hKey(INVALID_HANDLE_VALUE),
                         _fDeferInit( fDeferInit ),
                         _fNotifyEnabled( FALSE )
{
    if (!fDeferInit)
        Reset();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::~CRegChangeEvent, public
//
//  Purpose:    Destructs a registry change event
//
//  History:    17-Jul-98   dlee    Created
//
//--------------------------------------------------------------------------

CRegChangeEvent::~CRegChangeEvent()
{
    if ( INVALID_HANDLE_VALUE != _hKey )
    {
        NtClose( _hKey );

        // Wait for the notification to complete if it is enabled.
        // It'll write into the IO_STATUS_BLOCK when it aborts due to the
        // key close above.

        if ( _fNotifyEnabled )
            _regEvent.Wait();
    }
} //~CRegChangeEvent

//+---------------------------------------------------------------------------
//
//  Member:     CRegChangeEvent::Register
//
//  Synopsis:   Closes an existing key handle (if open) and reopens it.
//
//  History:    10-08-96   srikants   Created
//
//----------------------------------------------------------------------------

void CRegChangeEvent::Register()
{
    Win4Assert( !_fNotifyEnabled );

    //
    // Close previous handle.
    //
    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        NtClose( _hKey );
        _hKey = INVALID_HANDLE_VALUE;
    }

    //
    // Try to re-open.  This sub-optimal behavior works around peculiarities
    // in Gibraltar.
    //
    NTSTATUS Status = NtOpenKey( &_hKey,                // Resulting handle
                                  KEY_NOTIFY,           // Access requested
                                 &_ObjectAttr);

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut((DEB_ERROR, "NtOpenKey(%ws) failed, rc=0x%x\n",
                                       _wcsKey,           Status ));
        _hKey = INVALID_HANDLE_VALUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::Reset, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

void CRegChangeEvent::Reset()
{
    _fNotifyEnabled = FALSE;
    _regEvent.Reset();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // There seems to be some peculiarities with the event based notifies.
    // After the first notify, NtNotifyChangeKey returns STATUS_KEY_DELETED
    // if we use the same key handle. So, close it and reopen it.
    //

    Register();

    if ( INVALID_HANDLE_VALUE != _hKey )
    {
        Status = NtNotifyChangeKey( _hKey,            // Handle to watch
                                    _regEvent.GetHandle(), // Event to set
                                    NULL,             // Optional APC
                                    NULL,             // Optional context
                                    &_IoStatus,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                        REG_NOTIFY_CHANGE_NAME   |
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                    TRUE,             // Watch tree
                                    NULL,             // Buffer
                                    0,                // buffer size
                                    TRUE );           // Asynchronous
    }

    if ( NT_SUCCESS( Status ) )
    {
        _fNotifyEnabled = TRUE;
    }
    else
    {
        ciDebugOut ((DEB_ERROR, "NtNotifyChangeKey failed, rc=0x%x\n", Status ));
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::Init, public
//
//  Purpose:    Deferred initialization.
//
//  History:    27-Apr-97   KrishnaN    Created
//
//--------------------------------------------------------------------------

void CRegChangeEvent::Init()
{
    Win4Assert(_fDeferInit);

    Reset();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotify::CRegNotify, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

CRegNotify::CRegNotify( const WCHAR * wcsRegKey ) :
          _fShutdown(FALSE),
          _hKey( INVALID_HANDLE_VALUE ),
          _refCount( 1 ),
          _mtx(),
          CRegNotifyKey( wcsRegKey )
{
    Register();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotify::DisableNotification, public
//
//  Purpose:    Close registry notifcation.  Leads to destruction after
//              APC completes.
//
//  History:    26-Feb-96   KyleP       Created
//
//--------------------------------------------------------------------------

void CRegNotify::DisableNotification()
{
    {
        CLock lck(_mtx);
        HANDLE hKey=_hKey;

        Win4Assert ( INVALID_HANDLE_VALUE != _hKey );
        _fShutdown=TRUE;
        if ( INVALID_HANDLE_VALUE != _hKey )
        {
            _hKey = INVALID_HANDLE_VALUE;
            NtClose( hKey );
        }
    }
    Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::~CRegNotify, protected
//
//  Synopsis:   Destructor
//
//  History:    2-26-96   KyleP      Added header
//
//----------------------------------------------------------------------------

CRegNotify::~CRegNotify()
{
    Win4Assert( 0 == _refCount );
    Win4Assert( _hKey == INVALID_HANDLE_VALUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::AddRef
//
//  History:    2-26-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::AddRef()
{
    InterlockedIncrement(&_refCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::Release
//
//  Synopsis:   If the refcount goes to 0, the object will be deleted.
//
//  History:    2-26-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::Release()
{
    Win4Assert( _refCount > 0 );
    if ( InterlockedDecrement(&_refCount) <= 0 )
        delete this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::Register
//
//  Synopsis:   Re-registers APC
//
//  History:    2-26-96   KyleP      Added header
//
//----------------------------------------------------------------------------

void CRegNotify::Register()
{
    CLock lck(_mtx);

    if ( _fShutdown )
        return;

    //
    // Close previous handle.
    //

    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        NtClose( _hKey );
        _hKey = INVALID_HANDLE_VALUE;
    }

    //
    // Try to re-open.  This sub-optimal behavior works around peculiarities
    // in Gibraltar.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtOpenKey( &_hKey,                 // Resulting handle
                        KEY_NOTIFY,             // Access requested
                        &_ObjectAttr);

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut((DEB_ERROR, "NtOpenKey(%ws) failed, rc=0x%x\n", _wcsKey, Status ));
    }

    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        Status = NtNotifyChangeKey( _hKey,             // Handle to watch
                                    0,                 // Event to set
                                    APC,               // Optional APC
                                    this,              // Optional context
                                    &_IoStatus,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                        REG_NOTIFY_CHANGE_NAME   |
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                    TRUE,              // Watch tree
                                    NULL,              // Buffer
                                    0,                 // buffer size
                                    TRUE );            // Asynchronous
    }

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut ((DEB_ERROR, "NtNotifyChangeKey failed, rc=0x%x\n", Status ));
    }
    else
        AddRef();
}
//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::APC
//
//  Synopsis:   Asynchronous Procedure Call invoked by the system when there
//              is a change notification (or related error).
//
//  Arguments:  [ApcContext]    -  Pointer to "this"
//              [IoStatusBlock] -
//              [Reserved]      -
//
//  History:    2-20-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::APC( void * ApcContext,
                      IO_STATUS_BLOCK * IoStatusBlock,
                      ULONG Reserved )
{
    Win4Assert( 0 != ApcContext );

    CRegNotify * pthis = (CRegNotify *)ApcContext;

    TRY
    {
        //
        // NTRAID#DB-NTBUG9-84531-2000/07/31-dlee Indexing Service registry notifications don't re-register after errors.
        //

        if ( NT_ERROR(IoStatusBlock->Status) )
        {
            ciDebugOut(( DEB_ERROR,
                         "Error 0x%x during Registry APC processing.\n",
                         IoStatusBlock->Status ));
        }

        if ( IoStatusBlock->Status != STATUS_NOTIFY_CLEANUP)
        {
            if( !NT_ERROR(IoStatusBlock->Status) )
            {
                pthis->DoIt();
                pthis->Register();
            }
            else
            {
                ciDebugOut(( DEB_ERROR, "Status 0x%x during Registry APC processing.\n",
                             IoStatusBlock->Status));
            }
        }
        else
        {
            Win4Assert(pthis->_fShutdown);
            //
            // Key closed
            //
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x during Registry APC processing.\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    pthis->Release();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CRegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.  See ntrtl.h for constants.
//              [pwcsRegPath] -- Path to node.
//
//  History:    21-Dec-93 KyleP     Created
//              19-Aug-98 KLam          Removed END_CONSTRUCTION
//
//--------------------------------------------------------------------------

CRegAccess::CRegAccess( ULONG ulRelative, WCHAR const * pwcsRegPath )
        : _ulRelative( ulRelative ),
          _wcsPath( 0 )
{
    //
    // Setup unchanged regtable entries.
    //

    _regtab[0].DefaultType = REG_NONE;
    _regtab[0].DefaultData = 0;
    _regtab[0].DefaultLength = 0;
    _regtab[0].QueryRoutine = 0;

    _regtab[1].QueryRoutine = 0;
    _regtab[1].Flags = 0;

    int cch = wcslen( pwcsRegPath ) + 1;
    WCHAR * wcsPath = _wcsPathBuf;

    if( cch > sizeof(_wcsPathBuf)/sizeof(_wcsPathBuf[0]) )
    {
        _wcsPath = new WCHAR[ cch ];
        wcsPath = _wcsPath;
    }

    memcpy( wcsPath, pwcsRegPath, cch * sizeof(WCHAR) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

void CRegAccess::Get( WCHAR const * pwcsKey, WCHAR * wcsVal, unsigned cc )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    UNICODE_STRING usVal;
    usVal.Buffer = wcsVal;
    usVal.MaximumLength = (USHORT)(cc*sizeof(WCHAR));

    SetName( pwcsKey );
    SetEntryContext( &usVal );

    NTSTATUS Status = RtlQueryRegistryValues( _ulRelative,
                                              wcsPath,
                                              &_regtab[0],
                                              0,
                                              0 );

    if ( NT_ERROR(Status) )
    {
        ciDebugOut(( DEB_IERROR,
                     "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                     wcsPath, pwcsKey, Status ));

        QUIETTHROW( CException( Status ) );
    }
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CallBackDWORD, public
//
//  Synopsis:   CallBack function that retrieves a DWORD value
//
//  Arguments:  [pValueName]   -- name of value
//              [uValueType]   -- type such as REG_MULTI_SZ
//              [pValueData]   -- data associated with value
//              [uValueLength] -- length of valueData
//              [context]      -- ptr to RTL_QUERY_REGISTRY_TABLE
//              [entryContext] -- where the DWORD goes
//
//  Returns:    NTSTATUS
//
//  History:    21-Sep-1998     dlee     Created
//
//--------------------------------------------------------------------------

NTSTATUS CRegAccess::CallBackDWORD(
    WCHAR * pValueName,
    ULONG   uValueType,
    VOID *  pValueData,
    ULONG   uValueLength,
    VOID *  pContext,
    VOID *  pEntryContext )
{
    Win4Assert( 0 != pContext );
    RTL_QUERY_REGISTRY_TABLE *p = (RTL_QUERY_REGISTRY_TABLE *) pContext;

    ciDebugOut(( DEB_ITRACE,
                 "callback for %ws, type %d, pValueData %#x, defaultData %#x\n",
                 pValueName, uValueType, pValueData, p->DefaultData ));

    if ( REG_DWORD == uValueType )
    {
        // If there is no value in the registry, return an error
        // Note: if there is a default value, NT passes the default value
        //       in pValueData.  pValueData will only be 0 if there is no
        //       default.

        if ( 0 == pValueData )
            return STATUS_OBJECT_NAME_NOT_FOUND;

        Win4Assert( sizeof DWORD == uValueLength );

        // The value is a DWORD and it exists

        RtlCopyMemory( pEntryContext, pValueData, sizeof DWORD );
    }
    else
    {
        // The type isn't DWORD as expected, so try to use the default.

        // If there is no default, return an error

        if ( 0 == p->DefaultData )
            return STATUS_OBJECT_TYPE_MISMATCH;

        // Copy the default value

        Win4Assert( sizeof DWORD == p->DefaultLength );
        RtlCopyMemory( pEntryContext, p->DefaultData, sizeof DWORD );
    }

    return STATUS_SUCCESS;
} //CallBackDWORD

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::ReadDWORD, private
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present or was of type other than DWORD
//
//  Arguments:  [pwcsKey]       -- Value name
//              [pDefaultValue] -- The default value if none exists or
//                                 if the type isn't DWORD.  If this is 0,
//                                 an exception is thrown if a DWORD isn't
//                                 found.
//
//  Returns:    Value of [pwcsKey].
//
//  History:    22-Sep-98  dlee    created
//
//--------------------------------------------------------------------------

ULONG CRegAccess::ReadDWORD( WCHAR const * pwcsKey, ULONG * pDefaultValue )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    DWORD dwVal;

    RTL_QUERY_REGISTRY_TABLE rtab[2];
    rtab[0].DefaultType = REG_DWORD;
    rtab[0].DefaultLength = sizeof DWORD;
    rtab[0].QueryRoutine = CallBackDWORD;
    rtab[0].Name = (WCHAR *) pwcsKey;
    rtab[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    rtab[0].EntryContext = &dwVal;
    rtab[0].DefaultData = pDefaultValue;

    rtab[1].QueryRoutine = 0;
    rtab[1].Flags = 0;

    NTSTATUS Status = RtlQueryRegistryValues( _ulRelative,
                                              wcsPath,
                                              &rtab[0],
                                              &rtab[0],
                                              0 );
    if ( NT_ERROR(Status) )
    {
        if ( STATUS_OBJECT_NAME_NOT_FOUND == Status &&
             0 != pDefaultValue )
             dwVal = *pDefaultValue;
        else
        {
            ciDebugOut(( DEB_IERROR,
                         "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                         wcsPath, pwcsKey, Status ));

            THROW( CException( Status ) );
        }
    }

    return dwVal;
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.  Throws if the
//              value doesn't exist or is of type other than DWORD.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//
//  Returns:    Value of [pwcsKey].
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

ULONG CRegAccess::Get( WCHAR const * pwcsKey )
{
    return ReadDWORD( pwcsKey, 0 );
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Read, public
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present or was of type other than DWORD
//
//  Arguments:  [pwcsKey]   -- Key to retrieve value of.
//              [ulDefaultValue] -- Default value if not found
//
//  Returns:    Value of [pwcsKey].
//
//  History:    13-Jun-94 DwightKr  Created
//
//  Notes:      Key must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

ULONG CRegAccess::Read( WCHAR const * pwcsKey, ULONG ulDefaultValue )
{
    return ReadDWORD( pwcsKey, &ulDefaultValue );
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CallBack, public
//
//  Synopsis:   CallBack function that casts Context to CRegCallBack and
//              then calls CRegCallBack::CallBack
//
//  Arguments:  [pValueName] -- name of value
//              [uValueType] -- type such as REG_MULTI_SZ
//              [pValueData] -- data associated with value
//              [uVvalueLength] -- length of valueData
//              [pContext] -- ptr to CRegCallBack
//              [pEntryContext] -- ignored
//
//  Returns:    status
//
//  History:    29-Aug-1994     SitaramR      Created
//
//--------------------------------------------------------------------------

NTSTATUS CRegAccess::CallBack(WCHAR *pValueName, ULONG uValueType,
                              VOID *pValueData, ULONG uValueLength,
                              VOID *pContext, VOID *pEntryContext )
{
    NTSTATUS status = ( (CRegCallBack *) pContext)->CallBack( pValueName,
                                                              uValueType,
                                                              pValueData,
                                                              uValueLength );
    return status;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::EnumerateValues, public
//
//  Synopsis:   Enumerate (REG_MULTI_SZ) values of a given key. Call the
//              callback routine passing each such enumerated value.
//
//  Arguments:  [wszValue] -- value to be enumerated
//              [regCallBack] -- callback class
//
//  History:    15-Aug-1994     SitaramR      Created
//
//--------------------------------------------------------------------------


void CRegAccess::EnumerateValues( WCHAR *wszValue,
                                  CRegCallBack& regCallBack )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    NTSTATUS status;

    SetName( wszValue );
    SetEntryContext( 0 );
    _regtab[0].QueryRoutine = CRegAccess::CallBack;

    status = RtlQueryRegistryValues( _ulRelative,
                                     wcsPath,
                                     &_regtab[0],
                                     &regCallBack,
                                     0 );
    if ( NT_ERROR(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        ciDebugOut(( DEB_ITRACE,
                     "RtlQueryRegistryValues(..%ws) returned 0x%x\n",
                     wcsPath, status ));
        QUIETTHROW( CException( status ) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Read, public
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present
//
//  Arguments:  [pwcsKey]           -- Key to retrieve value of.
//              [pwcsDefaultValue]  -- Default value if not found
//
//  Returns:    Value of [pwcsKey].
//
//  History:    18-Aug-98   KLam    Created header
//
//  Notes:      Key must be a string for successful retrieval.
//
//--------------------------------------------------------------------------

WCHAR * CRegAccess::Read( WCHAR const * pwcsKey, WCHAR const * pwcsDefaultValue )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    UNICODE_STRING usVal;

    SetName( pwcsKey );
    SetEntryContext( &usVal );

    usVal.Length = 50 * sizeof(WCHAR);
    usVal.Buffer = 0;

    NTSTATUS Status = STATUS_BUFFER_TOO_SMALL;

    while ( Status == STATUS_BUFFER_TOO_SMALL )
    {
        // could cause a delete before any call to new

        if ( 0 != usVal.Buffer )
            delete [] usVal.Buffer;

        usVal.Length *= 2;
        usVal.MaximumLength = usVal.Length;
        usVal.Buffer = new WCHAR[ usVal.Length/sizeof(WCHAR) ];

        Status = RtlQueryRegistryValues( _ulRelative,
                                         wcsPath,
                                         &_regtab[0],
                                         0,
                                         0 );
    }

    WCHAR * pwcs = 0;

    if ( NT_ERROR(Status) )
    {
        if ( 0 != usVal.Buffer )
            delete [] usVal.Buffer;

        usVal.Buffer = 0;

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            unsigned cc = wcslen(pwcsDefaultValue) + 1;
            pwcs = new WCHAR[cc];
            memcpy( pwcs, pwcsDefaultValue, cc*sizeof(WCHAR) );
        }
        else
        {
            ciDebugOut(( DEB_IERROR,
                         "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                         wcsPath, pwcsKey, Status ));

            THROW( CException( Status ) );
        }
    }
    else
    {
        //
        // Copy string to new heap
        //

        pwcs = usVal.Buffer;
        usVal.Buffer = 0;
    }

    return pwcs;
} //Read
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\shtole.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000.
//
// File:        ShtOle.cxx
//
// Contents:    Minimal implementation of OLE persistent handlers
//
// Classes:     CShtOle
//
// History:     30-Jan-96       KyleP       Added header
//              30-Jan-96       KyleP       Add support for embeddings.
//              18-Dec-97       KLam        Added ability to flush idle filters
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <regacc.hxx>
#include <shtole.hxx>
#include <eventlog.hxx>
#include <ciregkey.hxx>
#include <cievtmsg.h>

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Shutdown, public
//
//  Synopsis:   Clean up.  Close any open dlls.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::Shutdown()
{
    if (! _fInit)
    {
        Win4Assert( 0 == _pserverList && 0 == _pclassList );
        return;
    }

    //
    // Global object unload.  Sometimes this object will be
    // destroyed after the heap manager.  The workaround is to call
    // CIShutdown from the .exe before falling out of main.
    //

    try
    {
        CLock lock( _mutex );

        while ( _pserverList )
        {
            CServerNode * ptmp = _pserverList;
            _pserverList = ptmp->Next();
            delete ptmp;
        }
        while ( _pclassList )
        {
            CClassNode * ptmp = _pclassList;
            _pclassList = ptmp->Next();
            delete ptmp;
        }
    }
    catch( ... )
    {
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::GetFilterIdleTimeout, private
//
//  Synopsis:   Returns the idle timeout period from the registery.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

ULONG CShtOle::GetFilterIdleTimeout ()
{
    ULONG ulTimeout;

    TRY
    {
        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
        ulTimeout = reg.Read( wcsFilterIdleTimeout,
                              CI_FILTER_IDLE_TIMEOUT_DEFAULT,
                              CI_FILTER_IDLE_TIMEOUT_MIN,
                              CI_FILTER_IDLE_TIMEOUT_MAX);
    }
    CATCH( CException, e )
    {
        ulTimeout = CI_FILTER_IDLE_TIMEOUT_DEFAULT;
    }
    END_CATCH;

    return ulTimeout;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FlushIdle, public
//
//  Synopsis:   Asks idle classes and servers to unload
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

void CShtOle::FlushIdle ()
{
    Win4Assert( _fInit );
    CLock lock ( _mutex );

    // Classes should be flushed first since they reference servers
    _pclassList = FlushList ( _pclassList );
    _pserverList = FlushList ( _pserverList );

    // lock falling out of scope automatically releases it
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::CServerNode::SetModule, public
//
//  Synopsis:   Sets the module handle for this server and gets the pointer
//              to the DllCanUnload now function from the module.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

void CShtOle::CServerNode::SetModule( HMODULE hmod )
{
    Win4Assert( 0 == _hModule );
    _hModule = hmod;

    if ( _hModule )
        // COM DLLs should export DllCanUnloadNow.
        _pfnCanUnloadNow = (LPFNCANUNLOADNOW)GetProcAddress( _hModule, "DllCanUnloadNow" );
}

SCODE CShtOle::CServerNode::CreateInstance( IUnknown * pUnkOuter,
                                            REFIID     riid,
                                            void **    ppv )
{
    SCODE sc = E_FAIL;

    //
    // Touch the node so that we know when it was last used
    //

    Touch();

    //
    // A class factory is only held for single-threaded factories.
    //

    if ( 0 != _pCF )
        sc = _pCF->CreateInstance( pUnkOuter, riid, ppv );
    else
        sc = CoCreateInstance( _guid, pUnkOuter, CLSCTX_INPROC_SERVER, riid, ppv );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::CServerNode::CanUnloadNow, public
//
//  Synopsis:   Determines whether the server can be unloaded.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

BOOL CShtOle::CServerNode::CanUnloadNow (DWORD cMaxIdle)
{
    BOOL fCanUnload = FALSE;

    if ( _pfnCanUnloadNow && (GetTickCount() - _cLastUsed > cMaxIdle) )
    {
        // If there is a class factory then it has a lock on the server.
        if ( _pCF )
            _pCF->LockServer ( FALSE );

        fCanUnload = (S_OK == (_pfnCanUnloadNow) ());

        if ( _pCF )
            _pCF->LockServer ( TRUE );
    }

    return fCanUnload;
}


//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    SCODE sc = S_OK;

    //
    // Get the extension
    //

    WCHAR const * pExt = wcsrchr( pwszPath, '.' );

    //
    // Allow filter decisions on the null extension.
    //

    if ( 0 == pExt )
    {
        static const WCHAR pSmallExt[] = L".";

        pExt = pSmallExt;
    }

    if ( wcslen(pExt) > CClassNode::ccExtLen )
        return( E_FAIL );

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( pExt );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( pExt, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            WCHAR wcsKey[200];
            WCHAR wcsValue[150];
            BOOL  fPersHandler;
            GUID  classid;

            {
                //
                // Look up class of file by extension
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\%ws",
                          pExt );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );

                //
                // First, look for a persistent handler entry on the extension.
                // This overrides a generic class-level handler.
                //

                TRY
                {
                    swprintf( wcsKey,
                              L"\\Registry\\Machine\\Software\\Classes\\%ws\\PersistentHandler",
                              pExt );

                    CRegAccess regPH( RTL_REGISTRY_ABSOLUTE, wcsKey );
                    regPH.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                    StringToGuid( wcsValue, classid );
                    fPersHandler = TRUE;
                }
                CATCH( CException, e )
                {
                    fPersHandler = FALSE;
                }
                END_CATCH

                if ( !fPersHandler )
                    regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
            }

            CServerNode * pserver;

            if ( fPersHandler )
                pserver = FindServerFromPHandler( classid, riid );
            else
            {
                //
                // Look up classid of file class
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\%ws\\CLSID",
                          wcsValue );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                StringToGuid( wcsValue, classid );
                pnode->SetClassId( classid );

                pserver = FindServer( classid, riid );
            }

            pnode->SetServer( pserver );

            //
            // Link new node to front of list.
            //

        }
        CATCH( CException, e )
        {
            sc = E_FAIL;
        }
        END_CATCH;

        // ======================= lock ======================
        {
            CLock lock( _mutex );

            for ( CClassNode * pnode2 = _pclassList;
                  pnode2 != 0 && !pnode2->IsMatch( pExt );
                  pnode2 = pnode2->Next() )
                continue;       // NULL body

            //
            // Duplicate addition?
            //

            if ( 0 == pnode2 )
            {
                pnode->Link( _pclassList );
                _pclassList = pnode;
            }
            else
            {
                delete pnode;
                pnode = pnode2;
            }
        }
        // ======================= unlock ====================
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistFile * pf;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistFile, (void **)&pf );

            if ( SUCCEEDED(sc) )
            {
                sc = pf->Load( pwszPath, 0 );

                if ( SUCCEEDED(sc) )
                    sc = pf->QueryInterface( riid, ppvObject );

                pf->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.  Assumes class
//              of object has been pre-determined in some way (e.g. the
//              docfile was already opened for property enumeration)
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [classid]           -- Pre-determined class id of object
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     GUID const & classid,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    SCODE sc = E_FAIL;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( classid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( classid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( classid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( classid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistFile * pf;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistFile, (void **)&pf );

            if ( SUCCEEDED(sc) )
            {
                sc = pf->Load( pwszPath, 0 );

                if ( SUCCEEDED(sc) )
                    sc = pf->QueryInterface( riid, ppvObject );

                pf->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Bind embedding to specific interface.
//
//  Arguments:  [pStg]              -- IStorage of embedding.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( IStorage * pStg,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    //
    // Get the class id.
    //

    STATSTG statstg;

    SCODE sc = pStg->Stat( &statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
        return sc;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( statstg.clsid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( statstg.clsid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( statstg.clsid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( statstg.clsid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistStorage * pPersStore;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistStorage, (void **)&pPersStore );

            if ( SUCCEEDED(sc) )
            {
                sc = pPersStore->Load( pStg );

                if ( SUCCEEDED(sc) )
                    sc = pPersStore->QueryInterface( riid, ppvObject );

                pPersStore->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Bind embedding to specific interface.
//
//  Arguments:  [pStm]              -- IStream of embedding.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    28-Jun-96   KyleP       Added header.
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( IStream * pStm,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    //
    // Get the class id.
    //

    STATSTG statstg;

    SCODE sc = pStm->Stat( &statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
        return sc;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( statstg.clsid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( statstg.clsid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( statstg.clsid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( statstg.clsid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistStream * pPersStream;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistStream, (void **)&pPersStream );

            if ( SUCCEEDED(sc) )
            {
                sc = pPersStream->Load( pStm );

                if ( SUCCEEDED(sc) )
                    sc = pPersStream->QueryInterface( riid, ppvObject );

                pPersStream->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::NewInstance, public
//
//  Synopsis:   Create a new instance of specified class.
//
//  Arguments:  [classid]   -- Class of object to create.
//              [riid]      -- Interface to bind to.
//              [ppvObject] -- Object returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

SCODE CShtOle::NewInstance( GUID const & classid,
                            REFIID riid,
                            void  ** ppvObject )
{
    return CoCreateInstance( classid, 0, CLSCTX_INPROC_SERVER, riid, ppvObject );

#if 0
    Win4Assert( _fInit );
    SCODE sc = E_FAIL;

    //
    // Look for a class factory in cache
    //

    CServerNode * pserver = 0;
    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( classid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( classid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            WCHAR wcsKey[200];
            WCHAR wcsValue[150];

            //
            // See if the server is already in the list
            //

            // ======================= lock ======================
            {
                CLock lock( _mutex );

                for ( pserver = _pserverList;
                      pserver != 0 && !pserver->IsMatch( classid );
                      pserver = pserver->Next() )
                    continue;       // NULL body
            }
            // ======================= unlock ====================


            if( 0 == pserver )
            {
                pserver = new CServerNode( classid, 0 );

                {
                    GuidToString( classid, &wcsValue[0] );

                    //
                    // Look up name of server
                    //

                    swprintf( wcsKey,
                              L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\"
                              L"InprocServer32",
                              wcsValue );

                    CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                    regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
                }

                //
                // Load the server and cache the IClassFactory *
                //

                HMODULE hmod = LoadLibrary( wcsValue );

                if ( 0 != hmod )
                {
                    pserver->SetModule( hmod );

                    LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)GetProcAddress( hmod, "DllGetClassObject" );

                    if (pfn)
                    {
                        IClassFactory * pCF;

                        sc = (pfn)( classid, IID_IClassFactory, (void **)&pCF );

                        if ( SUCCEEDED(sc) )
                            pserver->SetCF( pCF );
                    }
                }

                pserver = InsertByClass( classid, pserver );
            }

            pnode->SetServer( pserver );

            pnode = InsertByClass( classid, pnode );
        }
        CATCH( CException, e )
        {
            delete pserver;
            pserver = 0;

            delete pnode;
            pnode = 0;

            sc = E_FAIL;
        }
        END_CATCH;
    }
#if 0 // can't do this, no lock is held!
    else
    {
        //
        // Move found node to front of list.
        //

        if ( 0 != pprev )
        {
            pprev->Link( pnode->Next() );
            pnode->Link( _pclassList );
            _pclassList = pnode;
        }
    }
#endif

    if ( pnode && pnode->GetCF() )
    {
        //
        // Touch the node so that we know when it was last used
        //
        pnode->Touch();

        //
        // Bind to the requested interface
        //

        sc = pnode->GetCF()->CreateInstance( 0, riid, ppvObject );
    }
    else
        sc = E_FAIL;

    return( sc );
#endif // 0
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FindServer, private
//
//  Synopsis:   Look up server in cache (or registry)
//
//  Arguments:  [classid] -- Guid of object class.
//              [riid]    -- Interface to bind to.
//
//  Returns:    Persistent server node for class/interface combination, or
//              zero if none can be found or loaded.
//
//  History:    30-Jan-96   KyleP       Broke out of ::Bind.
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::FindServer( GUID const & classid, REFIID riid )
{
    CServerNode * pserver = 0;

    TRY
    {
        WCHAR wcsKey[200];
        WCHAR wcsValue[150];

        GuidToString( classid, wcsValue );

        {
            //
            // Look up classid of persistent handler
            //

            swprintf( wcsKey,
                      L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\PersistentHandler",
                      wcsValue );

            CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
            regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
        }

        GUID clsPH;
        StringToGuid( wcsValue, clsPH );

        pserver = FindServerFromPHandler( clsPH, riid );
    }
    CATCH( CException, e )
    {
        delete pserver;
        pserver = 0;
    }
    END_CATCH

    return pserver;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FindServerFromPHandler, private
//
//  Synopsis:   Look up server in cache (or registry) starting with
//              persistent handler.
//
//  Arguments:  [classid] -- Guid of object persistent handler.
//              [riid]    -- Interface to bind to.
//
//  Returns:    Persistent server node for class/interface combination, or
//              zero if none can be found or loaded.
//
//  History:    30-Jan-96   KyleP       Broke out of ::Bind.
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::FindServerFromPHandler( GUID const & clsPH, REFIID riid )
{
    CServerNode * pserver = 0;

    TRY
    {
        WCHAR wcsKey[200];
        WCHAR wcsValue[150];
        GUID  guidServer;

        GuidToString( clsPH, wcsValue );

        //
        // Look up classid of IFilter server
        //
        {
            swprintf( wcsKey,
                      L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\"
                      L"PersistentAddinsRegistered\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                      wcsValue,
                      riid.Data1,
                      riid.Data2,
                      riid.Data3,
                      riid.Data4[0], riid.Data4[1],
                      riid.Data4[2], riid.Data4[3],
                      riid.Data4[4], riid.Data4[5],
                      riid.Data4[6], riid.Data4[7] );

            CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
            regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

            StringToGuid( wcsValue, guidServer );

        }

        //
        // See if the server is already in the list
        //

        // ======================= lock ======================
        {
            CLock lock( _mutex );

            for ( pserver = _pserverList;
                  pserver != 0 && !pserver->IsMatch( guidServer );
                  pserver = pserver->Next() )
                continue;       // NULL body
        }
        // ======================= unlock ====================

        if( 0 == pserver )
        {
            pserver = new CServerNode( guidServer, 0 );

            {
                //
                // Look up name of IFilter server
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\CLSID\\%ws\\"
                          L"InprocServer32",
                          wcsValue );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                //
                // Since we have the key open, get the threading model now too.
                //

                TRY
                {
                    WCHAR wcsThreading[35];

                    regFilter.Get( L"ThreadingModel", wcsThreading, sizeof(wcsThreading)/sizeof(WCHAR) );

                    if ( 0 == _wcsicmp( wcsThreading, L"Both" ) ||
                         0 == _wcsicmp( wcsThreading, L"Free" ) ||
                         0 == _wcsicmp( wcsThreading, L"Apartment" ) )
                        pserver->SetSingleThreaded( FALSE );
                    else
                        pserver->SetSingleThreaded( TRUE );
                }
                CATCH( CException, e )
                {
                    //
                    // No news is bad news...
                    //

                    pserver->SetSingleThreaded( TRUE );
                }
                END_CATCH
            }

            //
            // Use COM to handle all the work for non-single threaded DLLs.
            //

            if ( pserver->IsSingleThreaded() )
            {
                //
                // Load the server and cache the IClassFactory *
                //

                HMODULE hmod = LoadLibrary( wcsValue );

                if ( 0 != hmod )
                {
                    pserver->SetModule( hmod );

                    LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)GetProcAddress( hmod, "DllGetClassObject" );

                    if (pfn)
                    {
                        IClassFactory * pCF;

                        SCODE sc = (pfn)( guidServer, IID_IClassFactory, (void **)&pCF );

                        if ( FAILED(sc) )
                            THROW( CException( sc ) );

                        pserver->SetCF( pCF );
                    }
                }
            }

            pserver = InsertByClass( guidServer, pserver );
        }
    }
    CATCH( CException, e )
    {
        delete pserver;
        pserver = 0;
    }
    END_CATCH

    return pserver;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::InsertByClass, private
//
//  Synopsis:   Insert new class node. Only handles nodes named by clsid
//
//  Arguments:  [classid] -- Class id
//
//  Returns:    Pointer to node with [classid]
//
//  History:    18-Oct-96   KyleP       Created
//
//----------------------------------------------------------------------------

CShtOle::CClassNode * CShtOle::InsertByClass( GUID const & classid,
                                              CShtOle::CClassNode * pnode )
{
    CLock lock( _mutex );

    //
    // Link new node to front of list.
    //

    for ( CClassNode * pnode2 = _pclassList;
          pnode2 != 0 && !pnode2->IsMatch( classid );
          pnode2 = pnode2->Next() )
        continue;       // NULL body

    //
    // Duplicate addition?
    //

    if ( 0 == pnode2 )
    {
        pnode->Link( _pclassList );
        _pclassList = pnode;
    }
    else
    {
        delete pnode;
        pnode = pnode2;
    }

    return pnode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::InsertByClass, private
//
//  Synopsis:   Insert new server node. Only handles nodes named by clsid
//
//  Arguments:  [classid] -- Class id
//
//  Returns:    Pointer to node with [classid]
//
//  History:    18-Oct-96   KyleP       Created
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::InsertByClass( GUID const & classid,
                                               CShtOle::CServerNode * pnode )
{
    CLock lock( _mutex );

    //
    // Link new node to front of list.
    //

    for ( CServerNode * pnode2 = _pserverList;
          pnode2 != 0 && !pnode2->IsMatch( classid );
          pnode2 = pnode2->Next() )
        continue;       // NULL body

    //
    // Duplicate addition?
    //

    if ( 0 == pnode2 )
    {
        pnode->Link( _pserverList );
        _pserverList = pnode;
    }
    else
    {
        delete pnode;
        pnode = pnode2;
    }

    return pnode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::StringToGuid, private static
//
//  Synopsis:   Helper function to convert string-ized guid to guid.
//
//  Arguments:  [wcsValue] -- String-ized guid.
//              [guid]     -- Guid returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::StringToGuid( WCHAR * wcsValue, GUID & guid )
{
    //
    // If the first character is a '{', skip it.
    //
    if ( wcsValue[0] == L'{' )
        wcsValue++;

    //
    // Convert classid string to guid
    // (since wcsValue may be used again below, no permanent modification to
    //  it may be made)
    //

    WCHAR wc = wcsValue[8];
    wcsValue[8] = 0;
    guid.Data1 = wcstoul( &wcsValue[0], 0, 16 );
    wcsValue[8] = wc;
    wc = wcsValue[13];
    wcsValue[13] = 0;
    guid.Data2 = (USHORT)wcstoul( &wcsValue[9], 0, 16 );
    wcsValue[13] = wc;
    wc = wcsValue[18];
    wcsValue[18] = 0;
    guid.Data3 = (USHORT)wcstoul( &wcsValue[14], 0, 16 );
    wcsValue[18] = wc;

    wc = wcsValue[21];
    wcsValue[21] = 0;
    guid.Data4[0] = (unsigned char)wcstoul( &wcsValue[19], 0, 16 );
    wcsValue[21] = wc;
    wc = wcsValue[23];
    wcsValue[23] = 0;
    guid.Data4[1] = (unsigned char)wcstoul( &wcsValue[21], 0, 16 );
    wcsValue[23] = wc;

    for ( int i = 0; i < 6; i++ )
    {
        wc = wcsValue[26+i*2];
        wcsValue[26+i*2] = 0;
        guid.Data4[2+i] = (unsigned char)wcstoul( &wcsValue[24+i*2], 0, 16 );
        wcsValue[26+i*2] = wc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::GuidToString, private static
//
//  Synopsis:   Helper function to convert guid to string-ized guid.
//
//  Arguments:  [guid]     -- Guid to convert.
//              [wcsValue] -- String-ized guid.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::GuidToString( GUID const & guid, WCHAR * wcsValue )
{
    swprintf( wcsValue,
              L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1],
              guid.Data4[2], guid.Data4[3],
              guid.Data4[4], guid.Data4[5],
              guid.Data4[6], guid.Data4[7] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\lib\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\querymsg.mc: $(PROJECT_ROOT)\published\query\cierror.mc \
             $(PROJECT_ROOT)\published\query\filterr.mc \
             ..\..\h\cievtmsg.mc \
             ..\..\sqltext\parserr.mc
    copy $(PROJECT_ROOT)\published\query\cierror.mc+$(PROJECT_ROOT)\published\query\filterr.mc+..\..\h\cievtmsg.mc+..\..\sqltext\parserr.mc $@
    echo Build_Status querymsg.mc was rebuilt...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\olympus\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF


$(_OBJ_DIR)\$(TARGET_DIRECTORY)\oquery.def: oquery.def ..\query.org
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\ci\isacl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       isacl.cxx
//
//+-------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//
// Maximum number of ACE descriptions used in one ACL.
//
#define ACE_COUNT 3

// NOTE:  Portions of the code below were borrowed from
//        \nt\private\windows\setup\syssetup\applyacl.c.

typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    SID_IDENTIFIER_AUTHORITY SidIdAuth;
    DWORD       dwSubAuth0, dwSubAuth1;
    BYTE        cSubAuthorities;
    UCHAR       AceType;
    UCHAR       AceFlags;
} ACE_DATA, *PACE_DATA;

BOOL
ApplyAcl(
    WCHAR const *pwcDir,
    unsigned cAces,
    ACE_DATA *pAceData
    );

DWORD
ApplyAclToDirOrFile(
    IN WCHAR const * FullPath,
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    );

DWORD
InitializeSids(
    unsigned cAces,
    ACE_DATA *pAceData,
    PSID apSid[]
    );

VOID
TearDownSids(
    unsigned cAces,
    PSID apSid[]
    );

DWORD
InitializeAces(
    unsigned cAces,
    ACE_DATA const *pAceData,
    PACCESS_ALLOWED_ACE Aces[],
    PSID apSid[]
    );

VOID
TearDownAces(
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    );

//
// This structure is valid for access allowed, access denied, audit,
// and alarm ACEs.
//
typedef struct _ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    //
    // The SID follows in the buffer
    //
} ACE, *PACE;


//
// Table describing the data to put into each ACE.
//
// NOTE:  The order of the table is significant because it is used to
//        create two different ACLs.  ACE 0 is used by itself for one ACL,
//        and all three ACEs are used for the other ACL.
//
ACE_DATA AceDataTable[ACE_COUNT] = {

    //
    // ACE 0 - Full access, System account
    //
    {
        GENERIC_ALL,
                SECURITY_NT_AUTHORITY,
                SECURITY_LOCAL_SYSTEM_RID, 0,
                1,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 1 - Full access, Administrators group
    //
    {
        GENERIC_ALL,
                SECURITY_NT_AUTHORITY,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                2,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 2 - Full access, Creator/owner
    //
    {
        GENERIC_ALL,
                SECURITY_CREATOR_SID_AUTHORITY,
                SECURITY_CREATOR_OWNER_RID, 0,
                1,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

};


//
// arg0 = Filename

BOOL ApplySystemAcl( WCHAR const *pwcDir )
{
    return ApplyAcl( pwcDir, ACE_COUNT, AceDataTable );
}

BOOL ApplySystemOnlyAcl( WCHAR const *pwcDir )
{
    return ApplyAcl( pwcDir, 1, AceDataTable );
}

BOOL ApplyAcl( WCHAR const *pwcDir, unsigned cAces, ACE_DATA *pAceData )
{
    WCHAR achDrive[4];
    for (unsigned i = 0; i < 3; i++)
        achDrive[i] = pwcDir[i];
    achDrive[3] = 0;

    DWORD dwFsFlags;
    BOOL b = GetVolumeInformation( achDrive, NULL, 0, NULL, NULL, &dwFsFlags, NULL, 0);
    if (!b || ! (dwFsFlags & FS_PERSISTENT_ACLS))
    {
        // NOTE: We could return a different result here and warn about
        //       the lack of ACLs, but it isn't worth the trouble of
        //       explaining to (and worrying) the user.
        return TRUE;
    }

    //
    // Array of SID pointers used in the ACL.  They are
    // initialized based on the data in the AceDataTable.
    //
    PSID apSids[ACE_COUNT];

    if (InitializeSids(cAces, pAceData, apSids) != NO_ERROR)
        return FALSE;

    //
    // Array of ACEs to be applied to the objects.  They are
    // initialized based on the data in the AceDataTable.
    //
    PACCESS_ALLOWED_ACE aAces[ACE_COUNT];

    if (InitializeAces(cAces, pAceData, aAces, apSids) != NO_ERROR)
    {
        TearDownSids(cAces, apSids);
        return FALSE;
    }

    BOOL fOK = ( ApplyAclToDirOrFile( pwcDir, cAces, aAces ) == NO_ERROR );

    TearDownAces(cAces, aAces);
    TearDownSids(cAces, apSids);
    return fOK;
} //ApplySystemAcl


DWORD
ApplyAclToDirOrFile(
    IN WCHAR const * FullPath,
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    )

/*++

Routine Description:

    Applies an ACL to a specified file or directory.

Arguments:

    FullPath - supplies full win32 path to the file or directory
        to receive the ACL

Return Value:

--*/

{
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    UCHAR AclBuffer[2048];
    BOOL b;

    //
    // Initialize a security descriptor and an ACL.
    // We use a large buffer on the stack to contain the ACL.
    //
    Acl = (PACL)AclBuffer;
    if (!InitializeAcl(Acl,sizeof(AclBuffer),ACL_REVISION2) ||
        !InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION))
    {
        return GetLastError();
    }

    //
    // Build up the DACL from the indices on the list.
    //

    DWORD rc = NO_ERROR;
    for ( unsigned AceIndex = 0;
          (rc == NO_ERROR) && (AceIndex < cAces);
          AceIndex++ )
    {
        b = AddAce( Acl,
                    ACL_REVISION2,
                    0xFFFFFFFF,
                    Aces[AceIndex],
                    Aces[AceIndex]->Header.AceSize
                  );

        //
        // Track first error we encounter.
        //
        if (!b && (rc == NO_ERROR)) {
            rc = GetLastError();
        }
    }

    if (rc != NO_ERROR)
        return rc;

    //
    // Add the ACL to the security descriptor as the DACL
    //
    rc = SetSecurityDescriptorDacl(&SecurityDescriptor,TRUE,Acl,FALSE)
                                ? NO_ERROR
                                : GetLastError();

    if (rc != NO_ERROR)
        return rc;

    //
    // Finally, apply the security descriptor.
    //
    rc = SetFileSecurity(FullPath,DACL_SECURITY_INFORMATION,&SecurityDescriptor)
       ? NO_ERROR
       : GetLastError();

    return(rc);
}


DWORD
InitializeSids(
    unsigned cAces,
    ACE_DATA *pAceData,
    PSID apSids[]
    )

/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    Win32 error indicating outcome.

--*/

{
    //
    // Ensure the SIDs are in a well-known state
    //

    for (unsigned i=0; i<cAces; i++)
    {
        apSids[i] = 0;
    }

    //
    // Allocate and initialize the universal SIDs
    //
    for (i=0; i<cAces; i++)
    {
        BOOL b = AllocateAndInitializeSid( &pAceData[i].SidIdAuth,
                                           pAceData[i].cSubAuthorities,
                                           pAceData[i].dwSubAuth0,
                                           pAceData[i].dwSubAuth1,
                                           0,0,0,0,0,0,
                                           &apSids[i] );
        if (!b)
        {
            DWORD rc = GetLastError();
            TearDownSids(cAces, apSids);
            return rc;
        }
    }

    return NO_ERROR;
}


VOID
TearDownSids(
    unsigned cAces,
    PSID apSids[]
    )
{
    for (unsigned i=0; i<cAces; i++)
        if (apSids[i])
            FreeSid(apSids[i]);
}

#define MyMalloc(cb)    GlobalAlloc( 0, cb )
#define MyFree(pv)      GlobalFree( pv )

DWORD
InitializeAces(
    unsigned cAces,
    ACE_DATA const *pAceData,
    PACCESS_ALLOWED_ACE Aces[],
    PSID apSids[]
    )

/*++

Routine Description:

    Initializes the array of ACEs as described in the pAceData table

Arguments:

    None

Return Value:

    Win32 error code indicating outcome.

--*/

{
    //
    // Initialize to a known state.
    //
    ZeroMemory(Aces, cAces*sizeof Aces[0]);

    //
    // Create ACEs for each item in the data table.
    // This involves merging the ace data with the SID data, which
    // are initialized in an earlier step.
    //
    for (unsigned u=0; u<cAces; u++) {

        ULONG cbSid = GetLengthSid( apSids[u] );
        DWORD Length = cbSid + sizeof(ACCESS_ALLOWED_ACE) - sizeof DWORD;

        Aces[u] = (PACCESS_ALLOWED_ACE) MyMalloc(Length);
        if (!Aces[u]) {
            TearDownAces(cAces, Aces);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        Aces[u]->Header.AceType  = pAceData[u].AceType;
        Aces[u]->Header.AceFlags = pAceData[u].AceFlags;
        Aces[u]->Header.AceSize  = (WORD)Length;

        Aces[u]->Mask = pAceData[u].AccessMask;

        BOOL b = CopySid( cbSid,
                          (PUCHAR) &(Aces[u]->SidStart),
                          apSids[u] );

        if (!b) {
            DWORD rc = GetLastError();
            TearDownAces(cAces, Aces);
            return(rc);
        }
    }

    return NO_ERROR;
}


VOID
TearDownAces(
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    )

/*++

Routine Description:

    Destroys the array of ACEs as described in the AceDataTable

Arguments:

    None

Return Value:

    None

--*/

{
    for (unsigned u=0; u<cAces; u++) {

        if (Aces[u]) {
            MyFree(Aces[u]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\ci\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

$(_OBJ_DIR)\$(TARGET_DIRECTORY)\query.def: query.def ..\query.org
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\h\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

qutilerr.h msb00001.bin qutilerr.rc: qutilerr.mc

.SUFFIXES:  .mc

.mc.h:
    @ech Build_Status Compiling - $(<F) for all platforms ;
    mc -v $(@B).mc -h . -r .


.mc.rc:
    @ech Build_Status Compiling - $(<F) for all platforms ;
    mc -v $(@B).mc -h . -r .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\ci\cisecret.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       cisecret.cxx
//
//  Functions:  CiGetPassword, GetSecret SetSecret
//
//  History:    10-18-96   dlee   Created, mostly from w3svc sources
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>
}

#include <cisecret.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   CiGetPassword
//
//  Synopsis:   Looks up a password from the lsa database
//
//  Arguments:  [pcsCatalogName] - friendly name of the catalog
//              [pwcUserName]    - domain\user
//              [pwcPassword]    - returns the password
//
//  Returns:    TRUE if a password was found, FALSE otherwise
//
//  History:    29-Oct-96 dlee      created
//
//--------------------------------------------------------------------------

BOOL CiGetPassword(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcUsername,
    WCHAR *       pwcPassword )
{
    Win4Assert( 0 != pwcCatalog );
    Win4Assert( 0 != pwcUsername );

    // look for a match of catalog name and domain\user

    CCiSecretRead secret;
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        if ( ( !_wcsicmp( pwcCatalog, pItem->getCatalog() ) ) &&
             ( !_wcsicmp( pwcUsername, pItem->getUser() ) ) )
        {
            wcscpy( pwcPassword, pItem->getPassword() );
            return TRUE;
        }

        pItem = secret.NextItem();
    }

    return FALSE;
} //CiGetPassword

//+-------------------------------------------------------------------------
//
//  Function:   SetSecret
//
//  Synopsis:   Creates or resets a secret value
//
//  Arguments:  [Server]       - Server secret lives on, 0 for local machine
//              [SecretName]   - name of the secret
//              [pSecret]      - secret to set
//              [cbSecret]     - # of bytes in pSecret
//
//  History:    18-Oct-96 dlee   copied from w3svc code and ci-ized
//
//--------------------------------------------------------------------------

void SetSecret(
    WCHAR const *  Server,
    WCHAR const *  SecretName,
    WCHAR const *  pSecret,
    DWORD          cbSecret )
{
    UNICODE_STRING unicodeServer;
    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    UNICODE_STRING unicodePassword;
    unicodePassword.Buffer        = (WCHAR *) pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    LSA_HANDLE hPolicy;
    NTSTATUS ntStatus = LsaOpenPolicy( &unicodeServer,
                                       &ObjectAttributes,
                                       POLICY_ALL_ACCESS,
                                       &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( ntStatus ) );

    //
    //  Create or open the LSA secret
    //

    UNICODE_STRING unicodeSecret;
    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    LSA_HANDLE        hSecret;
    ntStatus = LsaCreateSecret( hPolicy,
                                &unicodeSecret,
                                SECRET_ALL_ACCESS,
                                &hSecret );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        // If the secret already exists, then we just need to open it

        if ( STATUS_OBJECT_NAME_COLLISION == ntStatus )
            ntStatus = LsaOpenSecret( hPolicy,
                                      &unicodeSecret,
                                      SECRET_ALL_ACCESS,
                                      &hSecret );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            LsaClose( hPolicy );
            THROW( CException( ntStatus ) );
        }
    }

    //
    //  Set the secret value
    //

    ntStatus = LsaSetSecret( hSecret,
                             &unicodePassword,
                             &unicodePassword );

    LsaClose( hSecret );
    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( ntStatus ) );
} //SetSecret

//+-------------------------------------------------------------------------
//
//  Function:   GetSecret
//
//  Synopsis:   Retrieves a secret value
//
//  Arguments:  [Server]      - Server secret lives on, 0 for local machine
//              [SecretName]  - name of the secret
//              [ppSecret]    - returns the secret value that must be deleted
//                              with LocalFree
//
//  Returns:    TRUE if secret was found, FALSE if secret didn't exist
//              throws on all other errors.
//
//  History:    18-Oct-96 dlee   added header and and ci-ized
//
//--------------------------------------------------------------------------

// These defines are used in the GetSecret function call.

WCHAR  g_wchUnicodeNull[] = L"";

#define _InitUnicodeString( pUnicode, pwch )                       \
   {                                                               \
        (pUnicode)->Buffer    = pwch;                              \
        (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
        (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR); \
   }

#define InitUnicodeString( pUnicode, pwch)  \
   if (pwch == NULL) { _InitUnicodeString( pUnicode, g_wchUnicodeNull); } \
   else              { _InitUnicodeString( pUnicode, pwch);             } \


BOOL GetSecret(
    WCHAR const * Server,
    WCHAR const * SecretName,
    WCHAR **      ppSecret )
{
    
    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    UNICODE_STRING unicodeServer;
    InitUnicodeString( &unicodeServer,
                       (WCHAR *) Server );

    //
    //  Open a policy to the remote LSA
    //

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    LSA_HANDLE hPolicy;
    NTSTATUS ntStatus = LsaOpenPolicy( &unicodeServer,
                                       &ObjectAttributes,
                                       POLICY_ALL_ACCESS,
                                       &hPolicy );

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( LsaNtStatusToWinError( ntStatus ) ) );

    UNICODE_STRING unicodeSecret;
    InitUnicodeString( &unicodeSecret,
                       (WCHAR *) SecretName );

    //
    //  Query the secret value
    //

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    UNICODE_STRING * punicodePassword;
    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    LsaClose( hPolicy );

    // Don't throw if the secret didn't exist -- just return FALSE

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus )
        return FALSE;

    if ( STATUS_LOCAL_USER_SESSION_KEY == ntStatus )
        return FALSE;

    if ( !NT_SUCCESS( ntStatus ))
        THROW( CException( ntStatus ) );


    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    *ppSecret = (WCHAR *) LocalAlloc( LPTR,
                                      punicodePassword->Length + sizeof(WCHAR) );

    if ( 0 == *ppSecret )
    {
        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );

        LsaFreeMemory( (PVOID) punicodePassword );
        THROW( CException( E_OUTOFMEMORY ) );
    }

    //
    //  Copy it into the buffer, Length is count of bytes
    //

    RtlCopyMemory( *ppSecret,
                   punicodePassword->Buffer,
                   punicodePassword->Length );

    (*ppSecret)[punicodePassword->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( punicodePassword->Buffer,
                   punicodePassword->MaximumLength );

    LsaFreeMemory( (PVOID) punicodePassword );

    return TRUE;
} //GetSecret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\ci\catadmin.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 2002.
//
// File:        CatAdmin.cxx
//
// Contents:    Catalog administration API
//
// Classes:     CMachineAdmin, CCatalogAdmin, CCatalogEnum, CScopeEnum, ...
//
// History:     04-Feb-97       KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntquery.h>

#include <CatAdmin.hxx>
#include <regprop.hxx>
#include <CiRegKey.hxx>
#include <RegScp.hxx>
#include <SMatch.hxx>
#include <shlwapi.h>
#include <shlwapip.h>
#include <winnetwk.h>
#include <dynload.hxx>
#include <dynmpr.hxx>

extern BOOL ApplySystemAcl( WCHAR const *pwcDir );
extern BOOL ApplySystemOnlyAcl( WCHAR const *pwcDir );

//
// Constants
//

const unsigned MAX_CAT_PATH = MAX_PATH - 13*2;
const unsigned MAX_CAT_NAME = 40;

HKEY const hkeyInvalid = 0;
WCHAR const wcsCatalogDotWCI[] = L"\\catalog.wci";

//
// Local prototypes.
//

ULONG Delnode( WCHAR const * wcsDir, BOOL fDelTopDir = TRUE );
BOOL IsSUBST( WCHAR wcDrive );
BOOL IsMsNetwork( LPCWSTR  pwszMachine );

BOOL WaitForSvcPause( CServiceHandle &x )
{
    SERVICE_STATUS svcStatus;
    if ( QueryServiceStatus( x.Get(), &svcStatus ) )
        return SERVICE_PAUSE_PENDING == svcStatus.dwCurrentState ||
               SERVICE_RUNNING == svcStatus.dwCurrentState;

    return FALSE;
} //WaitForSvcPause

//+---------------------------------------------------------------------------
//
//  Method:     IsShortPath, private
//
//  Arguments:  Path in question
//
//  Returns:    TRUE if the path name potentially contains a short (8.3) name
//              for a file with a long name.
//
//  History:    15-Sep-1998   AlanW       Created
//              11-May-1998   KrishnaN    Borrowed from CFunnyPath
//
//----------------------------------------------------------------------------

BOOL IsShortPath( LPCTSTR lpszPath )
{
    Win4Assert( 0 != lpszPath);

    //
    // Check to see if the input path name contains an 8.3 short name
    //
    WCHAR * pwszTilde = wcschr( lpszPath, L'~' );

    if (pwszTilde)
    {
        WCHAR * pwszComponent;
        for ( pwszComponent = wcschr( lpszPath, L'\\' );
              pwszComponent;
              pwszComponent = wcschr( pwszComponent, L'\\' ) )
        {
            pwszComponent++;
            pwszTilde = wcschr( pwszComponent, L'~' );
            if ( 0 == pwszTilde || pwszTilde - pwszComponent > 13)
                continue;
            if (CFunnyPath::IsShortName( pwszComponent ))
                return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::CMachineAdmin, public
//
//  Synopsis:   Creates admin object for machine
//
//  Arguments:  [pwszMachine] -- Machine name.  Null for local machine
//              [fWrite]      -- If TRUE, open the registry for write
//
//  History:    02-Feb-19   KyleP       Created
//
//----------------------------------------------------------------------------

CMachineAdmin::CMachineAdmin( WCHAR const * pwszMachine, BOOL fWrite )
        : _hkeyLM( hkeyInvalid ),
          _hkeyContentIndex( hkeyInvalid ),
          _fWrite( fWrite )
{
    DWORD dwError;

    if ( 0 == pwszMachine )
    {
        _hkeyLM = HKEY_LOCAL_MACHINE;
        _xwcsMachName[0] = 0;
    }
    else
    {
        unsigned cc = wcslen( pwszMachine );

        _xwcsMachName.SetSize( cc + 1 );

        RtlCopyMemory( _xwcsMachName.Get(), pwszMachine, (cc+1) * sizeof(WCHAR) );

        if ( 1 == cc && pwszMachine[0] == L'.' )
        {
            _hkeyLM = HKEY_LOCAL_MACHINE;
        }
        else
        {
            //
            // The first thing about connecting to a remote registry is it must be
            // a MS network or else the RegConnectRegistry time out will
            // take at least 20 seconds.

            if ( !IsMsNetwork( pwszMachine ) )
            {
                THROW( CException( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) ) );;
            }

            dwError = RegConnectRegistry( pwszMachine,
                                          HKEY_LOCAL_MACHINE,
                                          &_hkeyLM );

            if ( ERROR_SUCCESS != dwError )
                THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }

    //
    // Open key to ContentIndex level
    //

    dwError = RegOpenKeyEx( _hkeyLM,
                            wcsRegAdminSubKey,
                            0,
                            fWrite ? KEY_ALL_ACCESS : KEY_READ,
                            &_hkeyContentIndex );

    if ( ERROR_SUCCESS != dwError )
    {
        if (!IsLocal())
        {
           RegCloseKey(_hkeyLM);
           _hkeyLM = hkeyInvalid;
        }
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::~CMachineAdmin, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CMachineAdmin::~CMachineAdmin()
{
    if ( hkeyInvalid != _hkeyContentIndex )
        RegCloseKey( _hkeyContentIndex );

    if ( hkeyInvalid != _hkeyLM && !IsLocal() )
        RegCloseKey( _hkeyLM );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::WaitForSvcStateChange, public
//
//  Synopsis:   Waits for svc state change
//
//  History:    20-Jan-99   KrishnaN       Created
//
//  Returns TRUE if state change is not pending. FALSE if time out.
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::WaitForSvcStateChange( SERVICE_STATUS *pss, int iSecs )
{
    BOOL fTransition = TRUE;
    int iSecsWaited = 0;
    do
    {
        QueryServiceStatus( _xSCCI.Get(), pss );
        fTransition = !(SERVICE_STOPPED == pss->dwCurrentState ||
                        SERVICE_RUNNING == pss->dwCurrentState ||
                        SERVICE_PAUSED  == pss->dwCurrentState);
        
        if (fTransition)
        {
            Sleep (1000);   // one second
            iSecsWaited++;
        }
    }
    while ( fTransition && iSecsWaited < iSecs );

    return !fTransition;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::AddCatalog, public
//
//  Synopsis:   Add a new catalog to the registry
//
//  Arguments:  [pwszCatalog]      -- Name of catalog
//              [pwszDataLocation] -- Location of catalog (catalog.wci directory)
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------


void CMachineAdmin::AddCatalog( WCHAR const * pwszCatalog,
                                WCHAR const * pwszDataLocation )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    //
    // Parameter validation.
    //

    if ( 0 == pwszCatalog ||
         0 == pwszDataLocation )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- Null catalog name or location.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }

    ULONG cchCatalog = wcslen(pwszCatalog);
    ULONG cchDataLocation = wcslen(pwszDataLocation);

    if ( cchCatalog < 1 || cchCatalog > MAX_CAT_NAME ||
         cchDataLocation < 3 || cchDataLocation > MAX_CAT_PATH )
    {
        ciDebugOut(( DEB_ERROR,
                     "CMachineAdmin::AddCatalog -- Invalid catalog name or location length.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }


    //
    // Order may be important here, because as soon as a key has
    // been written, notification of the change may be received
    // by the content index.  So, first create the directory then
    // create the registry keys.
    //
    // I'd really like to add the keys in a transaction, but there
    // doesn't appear to be any registry support for transactions.
    //

    //
    // Step 1. Attempt to create the directory.
    //

    //
    // Make sure directory is on a local disk.
    //

    if ( L':' != pwszDataLocation[1] )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- remote path specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }

    if ( IsSUBST( pwszDataLocation[0] ) )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- SUBST drive specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_IS_SUBST_PATH ) ) );
    }

    WCHAR wcsRoot[] = L"?:\\";
    wcsRoot[0] = pwszDataLocation[0];

    if ( IsLocal() &&
         GetDriveType( wcsRoot ) != DRIVE_FIXED &&
         GetDriveType( wcsRoot ) != DRIVE_REMOVABLE )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- non-fixed drive specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_DRIVE) ) );
    }

    TRY
    {
        CreateSubdirs( pwszDataLocation );

        //
        // Step 2. Create catalog key
        //

        HKEY hkeyCatalogs = hkeyInvalid;

        DWORD dwError = RegOpenKey( _hkeyLM,
                                    wcsRegCatalogsSubKey,
                                    &hkeyCatalogs );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening catalogs.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyCatalogs( hkeyCatalogs );

        HKEY hkeyNewCatalog;
        DWORD dwDisposition;

        dwError = RegCreateKeyEx( hkeyCatalogs,         // Root
                                  pwszCatalog,          // Sub key
                                  0,                    // Reserved
                                  0,                    // Class
                                  0,                    // Flags
                                  KEY_ALL_ACCESS,       // Access
                                  0,                    // Security
                                  &hkeyNewCatalog,      // Handle
                                  &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyNewCatalog( hkeyNewCatalog );

        if ( REG_CREATED_NEW_KEY != dwDisposition )
        {
            ciDebugOut(( DEB_ERROR, "Catalog being created already exists in registry.\n" ));
            THROW( CException( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) );
        }

        HKEY hkeyScopes;

        dwError = RegCreateKeyEx( hkeyNewCatalog,    // Root
                                  wcsCatalogScopes,  // Sub key
                                  0,                 // Reserved
                                  0,                 // Class
                                  0,                 // Flags
                                  KEY_ALL_ACCESS,    // Access
                                  0,                 // Security
                                  &hkeyScopes,       // Handle
                                  &dwDisposition );  // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog scope in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        RegCloseKey( hkeyScopes );

        //
        // Step 3. Set data location and default catalog attributes.
        //

        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsCatalogLocation,       // Name
                                 0,                        // Reserved
                                 REG_SZ,                   // Type
                                 (BYTE *)pwszDataLocation, // Value
                                 (1 + wcslen(pwszDataLocation) ) * sizeof(WCHAR) );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog location in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        DWORD dwDefaultValue = 0;

        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsIsIndexingW3Roots,     // Name
                                 0,                        // Reserved
                                 REG_DWORD,                // Type
                                 (BYTE *)&dwDefaultValue,  // Value
                                 sizeof DWORD );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating IsIndexingW3Roots in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }


        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsIsIndexingNNTPRoots,   // Name
                                 0,                        // Reserved
                                 REG_DWORD,                // Type
                                 (BYTE *)&dwDefaultValue,  // Value
                                 sizeof DWORD );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating IsIndexingNNTPRoots in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Caught exception 0x%x in CMachineAdmin::AddCatalog.\n", e.GetErrorCode() ));

        //
        // Remove subdirectory, but only if empty.
        //

        RemoveDirectory( pwszDataLocation );

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::RemoveCatalog, public
//
//  Synopsis:   Removes a catalog from the registry (and maybe the data)
//
//  Arguments:  [pwszCatalog] -- Catalog to remove
//              [fRemoveData] -- TRUE --> remove data (catalog.wci directory)
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::RemoveCatalog( WCHAR const * pwszCatalog,
                                   BOOL fRemoveData )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( fRemoveData && !IsCIStopped() )
    {
        ciDebugOut(( DEB_ERROR, "RemoveCatalog() Failed, CiSvc must be stopped\n" ));

        THROW( CException(E_ABORT) );
    }

    //
    // Before we delete, be sure to get the path to the metadata.
    //

    XGrowable<WCHAR> xwcsLocation;
    CCatalogAdmin * pCatAdmin = QueryCatalogAdmin( pwszCatalog );

    if ( IsLocal() )
    {
        xwcsLocation.SetSize( wcslen(pCatAdmin->GetLocation()) + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 1 );

        wcscpy( xwcsLocation.Get(), pCatAdmin->GetLocation() );
        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }
    else
    {
        unsigned ccMachName = wcslen( _xwcsMachName.Get() );
        unsigned ccCat = wcslen( pCatAdmin->GetLocation() );

        xwcsLocation.SetSize( ccMachName + ccCat + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 6 );

        xwcsLocation[0] = L'\\';
        xwcsLocation[1] = L'\\';
        RtlCopyMemory( xwcsLocation.Get() + 2, _xwcsMachName.Get(), ccMachName * sizeof(WCHAR) );
        xwcsLocation[2 + ccMachName] = L'\\';

        wcscpy( xwcsLocation.Get() + 3 + ccMachName, pCatAdmin->GetLocation() );

        Win4Assert( xwcsLocation[4 + ccMachName] == L':' );
        xwcsLocation[4 + ccMachName] = L'$';

        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }

    delete pCatAdmin;

    //
    // Now, delete the keys.
    //

    HKEY hkeyCatalogs = hkeyInvalid;

    DWORD dwError = RegOpenKey( _hkeyLM,
                                wcsRegCatalogsSubKey,
                                &hkeyCatalogs );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening catalogs.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyCatalogs( hkeyCatalogs );

    {
        HKEY hkeyCatalog;

        DWORD dwError = RegOpenKey( hkeyCatalogs,
                                    pwszCatalog,
                                    &hkeyCatalog );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening catalog.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyCatalog( hkeyCatalog );

        dwError = RegDeleteKey( hkeyCatalog, wcsCatalogScopes );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting scopes.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        dwError = RegDeleteKey( hkeyCatalog, wcsCatalogProperties );

        if ( ERROR_SUCCESS != dwError && ERROR_FILE_NOT_FOUND != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting properties.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }

    dwError = RegDeleteKey( hkeyCatalogs, pwszCatalog );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting catalog.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // And delete the metadata, if requested.
    //

    if ( fRemoveData )
    {
        dwError = Delnode( xwcsLocation.Get() );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting catalog data.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::RemoveCatalogFiles, public
//
//  Synopsis:   Removes a catalog from the registry (and maybe the data)
//
//  Arguments:  [pwszCatalog] -- Catalog where to remove the files
//
//  History:    16-Sep-98   KrishnaN       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::RemoveCatalogFiles( WCHAR const * pwszCatalog )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( !IsCIStopped() )
    {
        ciDebugOut(( DEB_ERROR, "RemoveCatalogFiles() Failed, CiSvc must be stopped\n" ));

        THROW( CException(E_ABORT) );
    }

    //
    // Before we delete, be sure to get the path to the metadata.
    //

    XGrowable<WCHAR> xwcsLocation;

    XPtr<CCatalogAdmin> xCatAdmin( QueryCatalogAdmin( pwszCatalog ) );

    if ( IsLocal() )
    {
        xwcsLocation.SetSize( wcslen(xCatAdmin->GetLocation()) + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 1 );

        wcscpy( xwcsLocation.Get(), xCatAdmin->GetLocation() );
        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }
    else
    {
        unsigned ccMachName = wcslen( _xwcsMachName.Get() );
        unsigned ccCat = wcslen( xCatAdmin->GetLocation() );

        xwcsLocation.SetSize( ccMachName + ccCat + sizeof wcsCatalogDotWCI/sizeof(WCHAR) + 6 );

        xwcsLocation[0] = L'\\';
        xwcsLocation[1] = L'\\';
        RtlCopyMemory( xwcsLocation.Get() + 2,
                       _xwcsMachName.Get(),
                       ccMachName * sizeof(WCHAR) );
        xwcsLocation[2 + ccMachName] = L'\\';

        RtlCopyMemory( xwcsLocation.Get() + 3 + ccMachName,
                       xCatAdmin->GetLocation(),
                       ccCat * sizeof(WCHAR) );

        Win4Assert( xwcsLocation[4 + ccMachName] == L':' );
        xwcsLocation[4 + ccMachName] = L'$';

        RtlCopyMemory( xwcsLocation.Get() + 3 + ccMachName + ccCat,
                       wcsCatalogDotWCI,
                       sizeof wcsCatalogDotWCI );
    }

    // Preserve the directory. Delete only the files.
    DWORD dwError = Delnode( xwcsLocation.Get(), FALSE );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting catalog files.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::QueryCatalogEnum, public
//
//  Returns:    Catalog enumerator
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogEnum * CMachineAdmin::QueryCatalogEnum()
{
    return new CCatalogEnum( _hkeyLM, _xwcsMachName.Get(), _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::QueryCatalogAdmin, public
//
//  Arguments:  [pwszCatalog] -- Catalog name
//
//  Returns:    Catalog admin object for [pwszCatalog]
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogAdmin * CMachineAdmin::QueryCatalogAdmin( WCHAR const * pwszCatalog )
{
    return new CCatalogAdmin( _hkeyLM, _xwcsMachName.Get(), pwszCatalog, _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::GetDWORDParam, public
//
//  Synopsis:   Retrieves global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [dwValue]   -- Value returned here
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::GetDWORDParam( WCHAR const * pwszParam, DWORD & dwValue )
{
    DWORD dwType;
    DWORD dwSize = sizeof(dwValue);

    DWORD dwError = RegQueryValueEx( _hkeyContentIndex,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)&dwValue,   // Data returned here
                                     &dwSize );          // Size of data

    return ( ERROR_SUCCESS == dwError && REG_DWORD == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::SetDWORDParam, public
//
//  Synopsis:   Sets global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [dwValue]   -- New value
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::SetDWORDParam( WCHAR const * pwszParam, DWORD dwValue )
{

    DWORD dwError = RegSetValueEx( _hkeyContentIndex,  // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_DWORD,          // Type
                                   (BYTE *)&dwValue,    // Value
                                   sizeof(dwValue) );  // Size of value

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::GetSZParam, public
//
//  Synopsis:   Retrieves global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [pwszValue] -- Value returned here
//              [cbLen    ] -- length in bytes of passed in buffer
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    3-30-98 mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::GetSZParam( WCHAR const * pwszParam, WCHAR * pwszValue, DWORD cbLen )
{
    DWORD dwType;

    DWORD dwError = RegQueryValueEx( _hkeyContentIndex,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)pwszValue,   // Data returned here
                                     &cbLen );           // Size of data

    return ( ERROR_SUCCESS == dwError && REG_SZ == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::SetSZParam, public
//
//  Synopsis:   Sets global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [pwszValue] -- New value
//              [cbLen]     -- length in bytes of passed in buffer
//
//  History:    03-30-98    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdmin::SetSZParam( WCHAR const * pwszParam, WCHAR const * pwszValue, DWORD cbLen )
{
    DWORD dwError = RegSetValueEx( _hkeyContentIndex,  // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_SZ,             // Type
                                   (BYTE *)pwszValue,  // Value
                                   cbLen );            // Size of value in bytes

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

BOOL CMachineAdmin::RegisterForNotification( HANDLE hEvent )
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::CreateSubdirs, private
//
//  Synopsis:   Helper to create nested subdirectories and catalog.wci
//
//  Arguments:  [pwszPath] -- Path up to but not including catalog.wci
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

WCHAR const * pwszSysVolInfo = L"System Volume Information";

void CMachineAdmin::CreateSubdirs( WCHAR const * pwszPath )
{
    XGrowable<WCHAR> xwcsTemp;

    //
    // Just don't accept paths to a catalog longer than MAX_PATH.  Take
    // into account that we will append two 8.3 filenames onto the path.
    //

    unsigned cc = wcslen( pwszPath );
    unsigned ccBegin = 3;

    if ( cc > MAX_CAT_PATH )
    {
        ciDebugOut(( DEB_ERROR, "CreateSubdirs: Path too deep\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME) ) );
    }

    if ( IsLocal() )
    {
        xwcsTemp.SetSize( cc + wcslen(wcsCatalogDotWCI) + 4 );
        RtlCopyMemory( xwcsTemp.Get(), pwszPath, (cc + 1) * sizeof(WCHAR) );

        //
        // More error checking.
        //

        Win4Assert( xwcsTemp[1] == L':' );

        if ( 0 == xwcsTemp[2] )
        {
            xwcsTemp[2] = L'\\';
            xwcsTemp[3] = 0;
        }
    }
    else
    {
        //
        // For the non-local case, the best we can do is try to use the $ admin
        // shares to create directories.
        //

        unsigned ccMachName = wcslen( _xwcsMachName.Get() );

        xwcsTemp.SetSize( cc + ccMachName + wcslen(wcsCatalogDotWCI) + 4 );

        xwcsTemp[0] = L'\\';
        xwcsTemp[1] = L'\\';

        RtlCopyMemory( xwcsTemp.Get() + 2, _xwcsMachName.Get(), ccMachName * sizeof(WCHAR) );

        xwcsTemp[ccMachName + 2] = L'\\';

        RtlCopyMemory( xwcsTemp.Get() + 2 + ccMachName + 1, pwszPath, (cc + 1) * sizeof(WCHAR) );

        //
        // More error checking.
        //

        Win4Assert( xwcsTemp[2 + ccMachName + 2] == L':' );

        xwcsTemp[2 + ccMachName + 2] = L'$';

        if ( 0 == xwcsTemp[2 + ccMachName + 3] )
        {
            xwcsTemp[2 + ccMachName + 3] = L'\\';
            xwcsTemp[2 + ccMachName + 4] = 0;
        }

        ccBegin = 2 + ccMachName + 3 + 1;   // "\\<machname>\c$\" --> 2 + ccMachName + 3
                                            //   + 1 to skip trying to create share itself.
    }

    //
    // Loop through and try to create every level of directory.
    // ERROR_ALREADY_EXISTS is a legal error.
    //

    WCHAR * pwcsEnd = xwcsTemp.Get() + ccBegin;

    while ( *pwcsEnd )
    {
        //
        // Find next backslash
        //

        for ( ; *pwcsEnd && *pwcsEnd != L'\\'; pwcsEnd++ )
            continue;

        //
        // Ensure that the slash appended below is followed by a null.
        //

        if ( *pwcsEnd == 0 )
            *(pwcsEnd + 1) = 0;

        *pwcsEnd = 0;

        if ( !CreateDirectory( xwcsTemp.Get(), 0 ) )
        {
            if ( GetLastError() != ERROR_ALREADY_EXISTS )
            {
                ciDebugOut(( DEB_ERROR, "CreateSubdirs: Error %d from CreateDirectory.\n",
                              GetLastError() ));
                THROW( CException() );
            }
        }
        else
        {
            //
            // If this directory was the "System Volume Information" folder,
            // we need to set its ACL and make it Hidden+System.
            //
            if ( _wcsicmp( xwcsTemp.Get() + ccBegin, pwszSysVolInfo ) == 0 )
            {
                SetFileAttributes( xwcsTemp.Get(),
                               FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );

                if ( !ApplySystemOnlyAcl( xwcsTemp.Get() ) )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "Can't apply system-only ACL to directory '%ws'\n",
                                 xwcsTemp.Get() ));
                    THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
                }
            }
        }

        *pwcsEnd = L'\\';
        pwcsEnd++;
    }

    //
    // Create the final level: catalog.wci
    //

    Win4Assert( xwcsTemp[ wcslen(xwcsTemp.Get()) - 1 ] == L'\\' );

    wcscat( xwcsTemp.Get(), &wcsCatalogDotWCI[1] );

    if ( !CreateDirectory( xwcsTemp.Get(), 0 ) )
    {
        if ( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            ciDebugOut(( DEB_ERROR, "CreateSubdirs: Error %d from CreateDirectory.\n",
                          GetLastError() ));
            THROW( CException() );
        }
    }

    // Make the directory hidden and not indexed
    // Setting the not content indexed bit on a FAT directory has no effect.
    // The bit is silently ignored by FAT.

    SetFileAttributes( xwcsTemp.Get(),
                       GetFileAttributes( xwcsTemp.Get() ) |
                       FILE_ATTRIBUTE_HIDDEN |
                       FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );

    // Apply system/admin ACL to the directory

    if ( !ApplySystemAcl( xwcsTemp.Get() ) )
    {
        ciDebugOut(( DEB_ERROR,
                     "Can't apply admin ACL to catalog in '%ws'\n",
                     xwcsTemp.Get() ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
    }
} //CreateSubdirs

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::CCatalogEnum, public
//
//  Synopsis:   Creates catalog enumeration object
//
//  Arguments:  [hkeyLM]      -- HKEY_LOCAL_MACHINE (or remote equivalent)
//              [pwcsMachine] -- Machine name
//              [fWrite]      -- TRUE for writable access
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogEnum::CCatalogEnum( HKEY hkeyLM, WCHAR const * pwcsMachine, BOOL fWrite )
        : _hkeyLM( hkeyLM ),
          _hkeyCatalogs( hkeyInvalid ),
          _dwIndex( 0 ),
          _fWrite( fWrite )
{
    //
    // Don't have to error check length because we trust the caller.
    //

    if ( 0 == pwcsMachine )
        _xawcCurrentMachine[0] = 0;
    else
    {
        unsigned cc = wcslen(pwcsMachine) + 1;

        _xawcCurrentMachine.SetSize( cc );

        RtlCopyMemory( _xawcCurrentMachine.Get(), pwcsMachine, cc * sizeof(WCHAR) );
    }

    //
    // Open catalog section of registry
    //

    DWORD dwError = RegOpenKeyEx( hkeyLM,
                                  wcsRegCatalogsSubKey,
                                  0,
                                  fWrite ? KEY_ALL_ACCESS : KEY_READ,
                                  &_hkeyCatalogs );

    if ( ERROR_SUCCESS != dwError )
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::~CCatalogEnum, public
//
//  Synopsis:   Destructs a catalog enumerator object
//
//  History:    3-Aug-98   dlee       Created
//
//----------------------------------------------------------------------------

CCatalogEnum::~CCatalogEnum()
{
    if ( hkeyInvalid != _hkeyCatalogs )
        RegCloseKey( _hkeyCatalogs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::QueryCatalogAdmin, public
//
//  Synopsis:   Creates catalog admin object for current catalog
//
//  Returns:    Catalog admin object
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin * CCatalogEnum::QueryCatalogAdmin()
{
    return new CCatalogAdmin( _hkeyLM,
                              (0 == _xawcCurrentMachine[0]) ? 0 : _xawcCurrentMachine.Get(),
                              _awcCurrentCatalog,
                              _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::Next, public
//
//  Synopsis:   Moves to next catalog
//
//  Returns:    FALSE for end-of-catalogs
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogEnum::Next( )
{
    DWORD cwcName = sizeof( _awcCurrentCatalog ) / sizeof( _awcCurrentCatalog[0] );
    FILETIME ftUnused;

    DWORD dwError = RegEnumKeyEx( _hkeyCatalogs,      // handle of key to enumerate
                                  _dwIndex,           // index of subkey to enumerate
                                  _awcCurrentCatalog, // address of buffer for subkey name
                                  &cwcName,           // address for size of subkey buffer
                                  0,                  // reserved
                                  0,                  // address of buffer for class string
                                  0,                  // address for size of class buffer
                                  &ftUnused );        // address for time key last written to

    _dwIndex++;

    if ( ERROR_SUCCESS == dwError )
        return TRUE;
    else if ( ERROR_NO_MORE_ITEMS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::CCatalogAdmin, public
//
//  Synopsis:   Constructor for catalog admin object
//
//  Arguments:  [hkeyLM]      -- HKEY_LOCAL_MACHINE (or remote equivalent)
//              [pwszMachine] -- Name of machine
//              [pwszCatalog] -- Name of catalog
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin::CCatalogAdmin( HKEY hkeyLM,
                              WCHAR const * pwszMachine,
                              WCHAR const * pwszCatalog,
                              BOOL fWrite )
        : _hkeyCatalog( hkeyInvalid ),
          _fWrite( fWrite ),
#pragma warning( disable : 4355 )               // this used in base initialization
          _catStateInfo(*this)
#pragma warning( default : 4355 )               // this used in base initialization

{
    if ( 0 == pwszMachine )
    {
        _xwcsMachName[0] = 0;
    }
    else
    {
        unsigned cc = wcslen( pwszMachine ) + 1;

        _xwcsMachName.SetSize( cc );

        RtlCopyMemory( _xwcsMachName.Get(), pwszMachine, cc * sizeof(WCHAR) );
    }

    unsigned cc = wcslen( pwszCatalog );

    if ( cc >= sizeof(_wcsCatName)/sizeof(_wcsCatName[0]) )
    {
        ciDebugOut(( DEB_ERROR, "Catalog name too big: %ws.\n", pwszCatalog ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
    }

    wcscpy( _wcsCatName, pwszCatalog );

    XArray<WCHAR> xBuf( wcslen(wcsRegCatalogsSubKey) + MAX_PATH + 1 );
    
    RtlCopyMemory( xBuf.GetPointer(), wcsRegCatalogsSubKey, sizeof(wcsRegCatalogsSubKey) );
    xBuf[ sizeof(wcsRegCatalogsSubKey) / sizeof(WCHAR) - 1] = L'\\';
    wcscpy( xBuf.GetPointer() + sizeof(wcsRegCatalogsSubKey) / sizeof(WCHAR), pwszCatalog );
    
    DWORD dwError = RegOpenKeyEx( hkeyLM,
                                  xBuf.GetPointer(),
                                  0,
                                  fWrite ? KEY_ALL_ACCESS : KEY_READ,
                                  &_hkeyCatalog );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, xBuf.GetPointer() ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    // Retrieve and remember the drive hosting the catalog
    WCHAR const *pwcsLocation = GetLocation();
    if (0 == pwcsLocation)
    {
        ciDebugOut(( DEB_ERROR, "No location available for catalog %ws on machine %ws\n",
                     pwszCatalog, pwszMachine ));
        THROW( CException( E_UNEXPECTED ) );
    }
    _wsplitpath(pwcsLocation, _wcsDriveOfLocation, 0, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::~CCatalogAdmin, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin::~CCatalogAdmin()
{
    if ( hkeyInvalid != _hkeyCatalog )
        RegCloseKey( _hkeyCatalog );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddScope, public
//
//  Synopsis:   Adds scope to catalog
//
//  Arguments:  [pwszScope]    -- Path
//              [pwszAlias]    -- Alias (for remote UNC access). Null allowed.
//              [fExclude]     -- TRUE for exclude scope
//              [pwszLogon]    -- Logon name (for UNC paths). Null allowed.
//              [pwszPassword] -- Password (for UNC paths). Null allowed.
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddScope( WCHAR const * pwszScope,
                              WCHAR const * pwszAlias,
                              BOOL          fExclude,
                              WCHAR const * pwszLogon,
                              WCHAR const * pwszPassword )
{
    if ( 0 == pwszScope )
        THROW( CException( QUERY_E_INVALID_DIRECTORY ) );

    SCODE sc = IsScopeValid(pwszScope, wcslen(pwszScope), IsLocal() );
    if (FAILED(sc))
        THROW( CException( sc ) );

    // Only check if the scope is on a remover device for local catalogs
    if ( IsLocal() )
    {
        WCHAR wszScopeDrive[_MAX_DRIVE];
        _wsplitpath(pwszScope, wszScopeDrive, NULL, NULL, NULL);
        UINT uiDriveType = GetDriveType(wszScopeDrive);

        if (DRIVE_CDROM == uiDriveType ||
            ( DRIVE_REMOVABLE == uiDriveType &&
              _wcsicmp(wszScopeDrive, _wcsDriveOfLocation) ))
            THROW( CException( QUERY_E_DIR_ON_REMOVABLE_DRIVE ) );
    }

    DWORD dwDisposition;
    HKEY  hkeyScopes;

    DWORD dwError = RegCreateKeyEx( _hkeyCatalog,      // Root
                                    wcsCatalogScopes,  // Sub key
                                    0,                 // Reserved
                                    0,                 // Class
                                    0,                 // Flags
                                    KEY_ALL_ACCESS,    // Access
                                    0,                 // Security
                                    &hkeyScopes,       // Handle
                                    &dwDisposition );  // Disposition

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyScopes( hkeyScopes );

    XGrowable<WCHAR>    xLine;

    AssembleScopeValueString( pwszAlias, fExclude, pwszLogon, xLine );

    WCHAR const * pwszTemp = xLine.Get();

    //
    // Set the new scope.
    //

    dwError = RegSetValueEx( hkeyScopes,           // Key
                             pwszScope,            // Value name
                             0,                    // Reserved
                             REG_SZ,               // Type
                             (BYTE *)pwszTemp,     // Data
                             ( (1 + wcslen(pwszTemp)) * sizeof WCHAR ) ); // Size (in bytes)

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d adding scope %ws.\n",
                     dwError, pwszScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // If we need to store a password, do so.  The password can be
    // an empty string (L"")!
    //

    if ( 0 != pwszLogon && 0 != pwszPassword)
    {
        AddOrReplaceSecret( pwszLogon, pwszPassword );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddCachedProperty, public
//
//  Synopsis:   Adds a cached property to catalog
//
//  Arguments:  [fps]           -- Property
//              [vt]            -- Data type
//              [cb]            -- Size of data in cache
//              [dwStoreLevel]  -- Property storage level
//              [fModifiable]   -- Can property metadata be modified once set?
//
//  History:    08-Dec-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddCachedProperty( CFullPropSpec const & fps,
                                       ULONG vt,
                                       ULONG cb,
                                       DWORD dwStoreLevel,
                                       BOOL fModifiable)
{
    DWORD dwDisposition;
    HKEY  hkeyProperties;

    DWORD dwError = RegCreateKeyEx( _hkeyCatalog,      // Root
                                    wcsCatalogProperties,  // Sub key
                                    0,                 // Reserved
                                    0,                 // Class
                                    0,                 // Flags
                                    KEY_ALL_ACCESS,    // Access
                                    0,                 // Security
                                    &hkeyProperties,       // Handle
                                    &dwDisposition );  // Disposition

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening properties registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyProperties( hkeyProperties );

    // build up the property value/data
    CBuildRegistryProperty PropBuild( fps, vt, cb, dwStoreLevel, fModifiable);

    // Make an entry for the property as a value.
    dwError = RegSetValueEx( hkeyProperties,                  // Key
                             PropBuild.GetValue(),      // Name
                             0,                         // Reserved
                             REG_SZ,                    // Type
                             (BYTE *)PropBuild.GetData(), // Value
                             (1 + wcslen(PropBuild.GetData()) ) * sizeof(WCHAR) );
    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d adding property %ws.\n",
                     dwError, PropBuild.GetValue() ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::RemoveScope, public
//
//  Synopsis:   Remove scope from catalog
//
//  Arguments:  [pwcsPath] -- Directory to remove
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::RemoveScope( WCHAR const * pwcsPath )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    HKEY hkeyScopes;

    DWORD dwError = RegOpenKey( _hkeyCatalog,
                                wcsCatalogScopes,
                                &hkeyScopes );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyScopes( hkeyScopes );

    //
    // Error check.  Can't remove virtual or shadow scopes.
    //


    {
        WCHAR awcScopeData[MAX_PATH];

        DWORD dwType;
        DWORD dwSize = sizeof(_wcsLocation);

        dwError = RegQueryValueEx( hkeyScopes,           // Key handle
                                   pwcsPath,             // Name
                                   0,                    // Reserved
                                   &dwType,              // Datatype
                                   (BYTE *)awcScopeData, // Data returned here
                                   &dwSize );            // Size of data

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d reading scope\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        CParseRegistryScope Parse( pwcsPath,
                                   dwType,
                                   awcScopeData,
                                   dwSize );

        if ( Parse.IsVirtualPlaceholder() || Parse.IsShadowAlias() )
        {
            ciDebugOut(( DEB_ERROR, "Attempt to delete virtual/shadow alias %ws\n", pwcsPath ));
            THROW( CException( E_INVALIDARG ) );
        }
    }

    dwError = RegDeleteValue( hkeyScopes, pwcsPath );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting scope\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::GetLocation, public
//
//  Returns:    Location of catalog.wci directory
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatalogAdmin::GetLocation()
{
    DWORD dwType;
    DWORD dwSize = sizeof(_wcsLocation);

    DWORD dwError = RegQueryValueEx( _hkeyCatalog,          // Key handle
                                      wcsCatalogLocation,   // Name
                                      0,                    // Reserved
                                      &dwType,              // Datatype
                                      (BYTE *)_wcsLocation, // Data returned here
                                      &dwSize );            // Size of data

    if ( ERROR_SUCCESS != dwError || REG_SZ != dwType )
    {
        ciDebugOut(( DEB_ERROR, "Missing location (err = %d, type = %d)\n", dwError, dwType ));
        return 0;
    }

    return _wcsLocation;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStarted, public
//
//  Returns:    TRUE if catalog is active
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsStarted()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n",
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_WRITABLE) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStopped, public
//
//  Returns:    TRUE if catalog is not active
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsStopped()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_STOPPED) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStopped, public
//
//  Returns:    TRUE if catalog is read-only
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsPaused()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_READONLY) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Start, public
//
//  Synopsis:   Starts catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Start()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_WRITABLE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n",
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Stop, public
//
//  Synopsis:   Stops catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Stop()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_STOPPED,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Pause, public
//
//  Synopsis:   Pauses catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Pause()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_READONLY,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsCatalogInactive, public
//
//  Returns:    Is the catalog inactive?
//
//  History:    29-Jan-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsCatalogInactive()
{
    DWORD dwIsInactive;

    if ( GetDWORDParam( wcsCatalogInactive, dwIsInactive ) )
        return dwIsInactive;
    else
        return CI_CATALOG_INACTIVE_DEFAULT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::GetDWORDParam, public
//
//  Synopsis:   Retrieves catalog-specific value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [dwValue]   -- Value returned here
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::GetDWORDParam( WCHAR const * pwszParam, DWORD & dwValue )
{
    DWORD dwType;
    DWORD dwSize = sizeof(dwValue);

    DWORD dwError = RegQueryValueEx( _hkeyCatalog,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)&dwValue,   // Data returned here
                                     &dwSize );          // Size of data

    return ( ERROR_SUCCESS == dwError && REG_DWORD == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::SetDWORDParam, public
//
//  Synopsis:   Sets catalog-specific value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [dwValue]   -- New value
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::SetDWORDParam( WCHAR const * pwszParam, DWORD dwValue )
{

    DWORD dwError = RegSetValueEx( _hkeyCatalog,       // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_DWORD,          // Type
                                   (BYTE *)&dwValue,   // Value
                                   sizeof(dwValue) );  // Size of value

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::DeleteRegistryParamNoThrow, public
//
//  Synopsis:   Deletes catalog-specific named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to delete
//
//  History:    08-Dec-98   KrishnaN       Created
//
//----------------------------------------------------------------------------

void  CCatalogAdmin::DeleteRegistryParamNoThrow( WCHAR const * pwszParam )
{
    RegDeleteValue( _hkeyCatalog, pwszParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsTrackingIIS, public
//
//  Returns:    TRUE if catalog is tracking virtual roots
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsTrackingIIS()
{
    DWORD dwIsTracking;

    if ( GetDWORDParam( wcsIsIndexingW3Roots, dwIsTracking ) )
        return (0 != dwIsTracking);
    else
        return TRUE;   // Default.
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::QueryScopeEnum, public
//
//  Returns:    New scope enumerator
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CScopeEnum * CCatalogAdmin::QueryScopeEnum()
{
    return new CScopeEnum( _hkeyCatalog, IsLocal(), _fWrite );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::QueryScopeEnum, public
//
//  Arguments:  [pwszPath]  -- scope path
//
//  Returns:    Scope admin object for [pwszPath]
//
//  History:    12/10/97    mohamedn    created
//
//----------------------------------------------------------------------------

CScopeAdmin * CCatalogAdmin::QueryScopeAdmin(WCHAR const * pwszPath)
{

    CScopeEnum  ScopeEnum( _hkeyCatalog, IsLocal(), _fWrite );

    while ( ScopeEnum.Next() )
    {
        if ( !_wcsicmp(ScopeEnum.Path(), pwszPath) )
            return ScopeEnum.QueryScopeAdmin();
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddOrReplaceSecret, public
//
//  Synopsis:   Adds/replaces user password
//
//  Arguments:  [pwcUser] -- User
//              [pwcPW]   -- Password
//
//  History:    1-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddOrReplaceSecret( WCHAR const * pwcUser, WCHAR const * pwcPW )
{
    //
    // write objects start blank -- the old entries must be copied
    // into the write object, along with the new entry.
    //

    CCiSecretWrite secretWrite( _xwcsMachName.Get() );
    CCiSecretRead secret( _xwcsMachName.Get() );
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        if ( ( 0 == _wcsicmp( _wcsCatName, pItem->getCatalog() ) ) &&
             ( 0 == _wcsicmp( pwcUser, pItem->getUser() ) ) )
        {
            // don't add this -- replace it below
        }
        else
        {
            // just copy the item

            secretWrite.Add( pItem->getCatalog(),
                             pItem->getUser(),
                             pItem->getPassword() );
        }

        pItem = secret.NextItem();
    }

    // add the new item

    secretWrite.Add( _wcsCatName, pwcUser, pwcPW );

    // write it to the sam database

    secretWrite.Flush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatStateInfo::Update, public
//
//  Synopsis:   updates catalog state information
//
//  Arguments:  none.
//
//  Returns:    TRUE upon sucess, FALSE upon failure to update.
//
//  History:    4-1-98  mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CCatStateInfo::LokUpdate(void)
{

    RtlFillMemory( &_state, sizeof(CI_STATE), 0xFF );

    _state.cbStruct = sizeof(CI_STATE);

    SCODE sc = CIState( _catAdmin.GetName(),
                        _catAdmin.GetMachName(),
                        &_state );
    if ( FAILED(sc) )
    {
        _sc = sc;

        RtlFillMemory( &_state, sizeof(CI_STATE), 0xFF );
    }

    return ( S_OK == _sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::CScopeEnum, public
//
//  Synopsis:   Constructor for scope enumerator
//
//  Arguments:  [hkeyCatalog] -- Registry key for catalog (e.g. ...\catalogs\web)
//
//  History:    02-Feb-97   KyleP   Created
//
//  Notes:      Initially positioned *before* first scope.
//
//----------------------------------------------------------------------------

CScopeEnum::CScopeEnum( HKEY hkeyCatalog,
                        BOOL fIsLocal,
                        BOOL fWrite )
        : _pwcsAlias( 0 ),
          _pwcsLogon( 0 ),
          _dwIndex( 0 ),
          _fIsLocal( fIsLocal ),
          _fWrite( fWrite )
{
    DWORD dwError = RegOpenKeyEx( hkeyCatalog,
                                  wcsCatalogScopes,
                                  0,
                                  KEY_READ,
                                  _xkeyScopes.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyScopes.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // get another handle to the catalog using RegOpenKeyEx, DuplicateHandle doesn't work for handle of remore reg.
    //
    dwError = RegOpenKeyEx( hkeyCatalog,
                            NULL,
                            0,
                            fWrite ? KEY_ALL_ACCESS : KEY_READ,
                            _xkeyCatalog.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyCatalog.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening Catalogs registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::~CScopeEnum, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CScopeEnum::~CScopeEnum()
{
    delete [] _pwcsAlias;
    delete [] _pwcsLogon;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::QueryScopeAdmin, public
//
//  Synopsis:   Creates scope admin object for current scope
//
//  Returns:    scope admin object for current scope
//
//  History:    12-05-97  mohamedn   Created
//
//----------------------------------------------------------------------------

CScopeAdmin * CScopeEnum::QueryScopeAdmin()
{
    return new CScopeAdmin( _xkeyCatalog.Get(),
                            _awcCurrentScope,
                            _pwcsAlias,
                            _pwcsLogon,
                            _fExclude,
                            _fVirtual,
                            _fShadowAlias,
                            _fIsLocal,
                            _fWrite,
                            FALSE ); // don't do validity check
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::Next, public
//
//  Synopsis:   Advances to next scope.
//
//  Returns:    FALSE at end-of-scopes.
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CScopeEnum::Next()
{
    //
    // Clean up from last scope.
    //

    delete [] _pwcsAlias;
    _pwcsAlias = 0;
    delete [] _pwcsLogon;
    _pwcsLogon = 0;

    //
    // Look for next entry.
    //

    DWORD cwcName = sizeof( _awcCurrentScope ) / sizeof( _awcCurrentScope[0] );
    WCHAR awcCurrentScopeData[MAX_PATH];
    DWORD cbData = sizeof( awcCurrentScopeData );
    DWORD dwType;
    FILETIME ftUnused;

    DWORD dwError = RegEnumValue( _xkeyScopes.Get(),  // handle of key to query
                                  _dwIndex,           // index of value to query
                                  _awcCurrentScope,   // address of buffer for value string
                                  &cwcName,           // address for size of value buffer
                                  0,                  // reserved
                                  &dwType,            // address of buffer for type code
                                  (BYTE *)awcCurrentScopeData, // address of buffer for value data
                                  &cbData );          // address for size of data buffer

    _dwIndex++;

    if ( ERROR_SUCCESS == dwError )
    {
        CParseRegistryScope Parse( _awcCurrentScope,
                                   dwType,
                                   awcCurrentScopeData,
                                   cbData );

        Parse.GetScope( _awcCurrentScope );
        _pwcsAlias    = Parse.AcqFixup();
        _pwcsLogon    = Parse.AcqUsername();
        _fExclude     = !Parse.IsIndexed();
        _fVirtual     = Parse.IsVirtualPlaceholder();
        _fShadowAlias = Parse.IsShadowAlias();

        return TRUE;
    }
    else if ( ERROR_NO_MORE_ITEMS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::CScopeAdmin, public
//
//  Synopsis:   Constructor for scope admin
//
//  Arguments:  [hkeyCatalog]  -- Registry key for catalog (e.g. ...\catalogs\web)
//              [pwszScope]    -- scope path
//              [pwszAlias]    -- alias
//              [pwszLogon]    -- logon name
//              [fExclude]     -- exclude scope flag
//              [fVirtual]     -- isVirtual flag
//              [fShadowAlias] -- TRUE for shadow alias place-holder
//              [fWrite]       -- Open for write access
//              [fValidityCheck] -- TRUE to check of scope is valid
//
//  Returns:    none- throws in case of failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

CScopeAdmin::CScopeAdmin( HKEY    hkeyCatalog,
                          WCHAR const * pwszScope,
                          WCHAR const * pwszAlias,
                          WCHAR const * pwszLogon,
                          BOOL    fExclude,
                          BOOL    fVirtual,
                          BOOL    fShadowAlias,
                          BOOL    fIsLocal,
                          BOOL    fWrite,
                          BOOL    fValidityCheck )
        :_fExclude(fExclude),
         _fVirtual(fVirtual),
         _fShadowAlias(fShadowAlias),
         _fWrite( fWrite ),
         _fIsLocal( fIsLocal )
{

    _awcScope[0] = L'';
    _awcAlias[0] = L'';
    _awcLogon[0] = L'';

    unsigned len = wcslen(pwszScope);

    // The caller doesn't need to know what kind of error it is.
    if ( len >= (sizeof _awcScope/sizeof WCHAR ) ||
         len == 0 ||
         ( fValidityCheck && fIsLocal && FAILED(IsScopeValid(pwszScope, len, fIsLocal)) ) )
    {
        ciDebugOut(( DEB_ERROR, "invalid scope: %ws, len: %d\n", pwszScope, len ));
        THROW(CException(E_INVALIDARG));
    }
    else
    {
        wcscpy( _awcScope, pwszScope );
    }

    len = (pwszAlias == 0) ? 0 : wcslen( pwszAlias );

    if ( len >= (sizeof _awcAlias/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "invalid Alias: %ws, len: %d\n", pwszAlias, len ));
        THROW(CException(E_INVALIDARG));
    }
    else if ( len > 0 )
    {
        wcscpy( _awcAlias, pwszAlias );
    }

    len = (pwszLogon == 0) ? 0 : wcslen( pwszLogon );
    if ( len >= (sizeof _awcAlias / sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "invalid logon: %ws, len: %d\n", pwszLogon, len ));
        THROW(CException(E_INVALIDARG));
    }
    else if ( len > 0 )
    {
        wcscpy( _awcLogon, pwszLogon );
    }

    DWORD dwError = RegOpenKey( hkeyCatalog,
                                wcsCatalogScopes,
                                _xkeyScopes.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyScopes.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
} //CScopeAdmin

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetPath, public
//
//  Synopsis:   Sets a new path value
//
//  Arguments:  [pwszScope] -- path value to set
//
//  Returns:    none - throws upon failure.
//
//  History:    12-10-97 mohamedn   created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetPath( WCHAR const * pwszScope )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    Win4Assert( pwszScope );

    unsigned len = ( 0 == pwszScope ) ? 0 : wcslen(pwszScope);

    if ( 0 >= len ||
         len >= (sizeof _awcScope/sizeof WCHAR) ||
         FAILED(IsScopeValid(pwszScope, len, IsLocal())) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid pwszScopes(%ws)\n", (0 != len) ? pwszScope: L"" ));
        THROW(CException( E_INVALIDARG ) );
    }

    DWORD dwError = RegDeleteValue( _xkeyScopes.Get(), _awcScope );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting scopes registry value:%ws\n", dwError, _awcScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // set the value of the new scope path.
    //
    wcscpy( _awcScope, pwszScope );

    //
    // clear logon info if path is local drive
    //
    if ( _awcScope[1] == L':' )
    {
        wcscpy(_awcLogon,L"");
    }

    SetScopeValueString();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetAlias, public
//
//  Synopsis:   Sets a new Alias
//
//  Arguments:  [pwszAlias] -- Alias to set
//
//  History:    10-12-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetAlias( WCHAR const * pwszAlias )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    // OK to have 0 == pwszalias
    //Win4Assert( pwszAlias );

    unsigned len = ( 0 == pwszAlias ) ? 0 : wcslen(pwszAlias);

    if ( len >= (sizeof _awcAlias/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid pwszAlias(%ws)\n", (0 == len) ? L"" : pwszAlias ));
        THROW(CException( E_INVALIDARG ) );
    }

    //
    // set the value of the new Alias.
    //
    _awcAlias[0] = L'';
    if (pwszAlias)
       wcscpy( _awcAlias, pwszAlias );

    SetScopeValueString();
}


//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetExclude, public
//
//  Synopsis:   Sets the ExcludeScope flag.
//
//  Arguments:  [fExclude] -- Exclude scope flag to set
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetExclude( BOOL fExclude )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( _fVirtual )
         THROW( CException( HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ) ) );

    _fExclude = fExclude;

    SetScopeValueString();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetLogonInfo, public
//
//  Synopsis:   Sets logon/password info
//
//  Arguments:  [pwszLogon]    -- Logon name
//              [pwszPassword] -- logon password
//              [CatAdmin]     -- reference to parent catalog
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetLogonInfo(WCHAR  const  * pwszLogon,
                               WCHAR  const  * pwszPassword,
                               CCatalogAdmin & CatAdmin)
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    // ok to have 0 == pwszPassword
    //Win4Assert( pwszPassword );

    unsigned len = pwszLogon ? wcslen(pwszLogon) : 0;

    if ( len >= (sizeof _awcLogon/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid LogonInfo(%ws)\n", (0 != len) ? pwszLogon: L"" ));
        THROW(CException( E_INVALIDARG ) );
    }

    //
    // set the value of the new logon
    //
    _awcLogon[0] = L'';
    if (pwszLogon)
        wcscpy( _awcLogon, pwszLogon );

    SetScopeValueString();

    if ( 0 != pwszLogon && 0 != pwszPassword)
        CatAdmin.AddOrReplaceSecret( pwszLogon, pwszPassword );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetScopeValueString, private
//
//  Synopsis:   updates scope value string
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetScopeValueString()
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    XGrowable<WCHAR>    xLine;

    AssembleScopeValueString( _awcAlias, _fExclude, _awcLogon, xLine );

    WCHAR const * pwszTemp = xLine.Get();

    //
    // Set the new value.
    //

    DWORD dwError;

    dwError = RegSetValueEx( _xkeyScopes.Get(),    // Key
                             _awcScope,            // Value name
                             0,                    // Reserved
                             REG_SZ,               // Type
                             (BYTE *)pwszTemp,     // Data
                             ( ( 1 + wcslen(pwszTemp) ) * sizeof WCHAR ) ); // Size (in bytes)

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d setting value for scope %ws.\n", dwError, _awcScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LocateCatalog, private
//
//  Synopsis:   Locates a catalog containing [pwszScope]
//
//  Arguments:  [Machine]   -- MachineAdmin object to search
//              [pwszScope] -- Scope to locate
//              [iBmk]      -- Input: catalog instance to find (0, 1, etc)
//                             Output: number found
//              [pwszCat]   -- Catalog returned here
//              [pcc]       -- Input: Size of [pwszCat]
//                             Output: Size needed to store catalog.  If > *pcc
//                             then catalog name was not stored.
//
//  Returns:    S_OK --> Found match, S_FALSE --> No matches.
//
//  History:    08-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE LocateCatalog( CMachineAdmin & Machine,
                     WCHAR const * pwszScope,
                     ULONG & iBmk,
                     WCHAR * pwszCat,
                     ULONG * pcc )
{
    SCODE sc = S_FALSE;
    XGrowable<WCHAR, 4*MAX_PATH> aCatNames;

    unsigned iMatch = 0;
    ULONG cCats = 0; // Tracks the number of catalogs.

    CLowcaseBuf lcScope( pwszScope );
    CScopeMatch Match( lcScope.Get(), lcScope.Length() );

    //
    // Interate over catalogs.
    //

    XPtr<CCatalogEnum> xCatEnum( Machine.QueryCatalogEnum() );

    while ( S_FALSE == sc && xCatEnum->Next() )
    {
        XPtr<CCatalogAdmin> xCatAdmin( xCatEnum->QueryCatalogAdmin() );

        // Inactive catalogs can't match

        if ( xCatAdmin->IsCatalogInactive() )
            continue;

        //
        // Iterate over scopes within a catalog.
        //

        XPtr<CScopeEnum> xScopeEnum( xCatAdmin->QueryScopeEnum() );

        while ( S_FALSE == sc && xScopeEnum->Next() )
        {
            BOOL fFound = FALSE;

            XPtr<CScopeAdmin> xScopeAdmin( xScopeEnum->QueryScopeAdmin() );

            //
            // Don't really want to match exclude scopes.
            //

            if ( xScopeAdmin->IsExclude() )
                continue;

            //
            // Root scopes (virtual or physical) match any catalog
            //

            if ( ( 0 == *(pwszScope+1) ) && ( L'\\' == *pwszScope ) )
                 fFound = TRUE;
            else
            {
                //
                // Local access?
                //

                if ( Machine.IsLocal() )
                {
                    CLowcaseBuf lcCatalogScope( xScopeAdmin->GetPath() );
                    fFound = Match.IsPrefix( lcCatalogScope.Get(), lcCatalogScope.Length() );
                }

                //
                // Remote access
                //
                else
                {
                    if ( 0 == xScopeAdmin->GetAlias() || 0 == *(xScopeAdmin->GetAlias()) )
                        continue;

                    CLowcaseBuf lcCatalogAlias( xScopeAdmin->GetAlias() );
                    fFound = Match.IsPrefix( lcCatalogAlias.Get(), lcCatalogAlias.Length() );
                }
            }

            if ( fFound )
            {
                //
                // We don't want to enumerate the same catalog multiple times.
                // Use an array to store names of catalogs found so far.
                // Optimization: Since the most common case is to retrieve the
                // first catalog (iBmk == 0), avoid usage of the array in that case.
                //

                if ( iBmk > 0 )
                {
                   // Check if the entry already exists in the array. If it does,
                   // continue iterating, else make a new entry and proceed down.
                   for (ULONG i = 0;
                        i < cCats && wcscmp(xCatEnum->Name(), &aCatNames[i*MAX_PATH]);
                        i++);

                   if (i < cCats)   // For loop terminated because a match was found
                   {
                      ciDebugOut((DEB_TRACE, "Entry %ws already exists in table.\n", xCatEnum->Name()));
                      continue;
                   }
                   else
                   {
                      // Do we have enough space?
                      if (aCatNames.Count() < (cCats + 1)*MAX_PATH)
                      {
                          aCatNames.SetSize((cCats+4) * MAX_PATH);
                          ciDebugOut((DEB_TRACE, "Expanded space to %d chars",
                                      aCatNames.Count()));
                      }

                      wcscpy(&aCatNames[cCats*MAX_PATH], xCatEnum->Name());
                      ciDebugOut((DEB_TRACE, "Adding %ws to the array.\n", xCatEnum->Name()));
                      cCats++;
                   }
                }

                //
                // Looking for additional matches?
                //

                if ( iBmk != iMatch )
                {
                    iMatch++;
                    continue;
                }

                //
                // Found match.  Return catalog to user.
                //

                unsigned ccCatalog = wcslen( xCatEnum->Name() ) + 1;

                if ( ccCatalog <= *pcc )
                    RtlCopyMemory( pwszCat, xCatEnum->Name(), ccCatalog * sizeof(WCHAR) );

                *pcc = ccCatalog;

                sc = S_OK;
            }
        }
    }

    iBmk = iMatch;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocateCatalogs, public
//
//  Synopsis:   Locates a catalog containing [pwszScope]
//
//  Arguments:  [pwszScope]   -- Scope to locate
//              [iBmk]        -- Catalog instance to find (0, 1, etc)
//              [pwszMachine] -- Name of machine returned here.
//              [pccMachine]  -- Input: Size of [pwszMachine]
//                               Output: Size needed to store Machine.  If
//                               needed size > *pccMachine then machine name
//                               was not stored.
//              [pwszCat]     -- Catalog returned here
//              [pccCat]      -- Input: Size of [pwszCat]
//                               Output: Size needed to store catalog.  If
//                               needed size > *pccCat then catalog name
//                               was not stored.
//
//  Returns:    S_OK --> Found match, S_FALSE --> No matches.
//
//  History:    08-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE LocateCatalogsW( WCHAR const * pwszScope,
                       ULONG iBmk,
                       WCHAR * pwszMachine,
                       ULONG * pccMachine,
                       WCHAR * pwszCat,
                       ULONG * pccCat )
{
    //
    // Parameter checks
    //

    if ( 0 == pwszScope ||
         0 == pccMachine ||
         0 == pccCat )
    {
        return E_INVALIDARG;
    }

    // null ptrs for pszMachine and pszCat are tolerated if the corresponding length
    // indicators are 0.
    if ( (0 == pwszMachine && *pccMachine > 0) ||
         (0 == pwszCat && *pccCat > 0) )
    {
        return E_INVALIDARG;
    }

    //
    // If we have a short path, we should expand it to its long form
    //
        
    XPtrST<WCHAR> xwszScopeLocal;

    if ( IsShortPath( pwszScope ) )
    {
        //
        // An expanded long path name could be longer than MAX_PATH, so it's best
        // to allocate space after a call to GetLongPathName
        //

        DWORD cBufSizeInChars = GetLongPathName(pwszScope, 0, 0);
        if (0 == cBufSizeInChars)
           return HRESULT_FROM_WIN32(GetLastError());

        xwszScopeLocal.Set(new WCHAR[cBufSizeInChars + 1]);

        DWORD dwRet2 = GetLongPathName(pwszScope, xwszScopeLocal.GetPointer(), cBufSizeInChars);
        if (0 == dwRet2)
           return HRESULT_FROM_WIN32(GetLastError());

        //
        // We are passing in the right sized buffer, so the following should hold.
        //

        Win4Assert( cBufSizeInChars == (dwRet2 + 1) );

        ciDebugOut(( DEB_ITRACE, "Short path %ws is converted to\n %ws\n", 
                     pwszScope, xwszScopeLocal.GetPointer() ));

        pwszScope = xwszScopeLocal.GetPointer();
    }

    //
    // Validate the path. One sure way of validating all path combinations is to attempt 
    // getting file attributes on the path. If the attempt fails, so will we.
    // Don't validate for the special cases of "\" and "\\machine"
    //

    if ( wcscmp( pwszScope, L"\\" ) &&
         ! ( pwszScope[0] == L'\\' && pwszScope[1] == L'\\' &&
             0 == wcschr( pwszScope + 2, L'\\' ) ) )
    {
        DWORD dwRet = GetFileAttributes(pwszScope);
        if (0xFFFFFFFF == dwRet)
           return HRESULT_FROM_WIN32(GetLastError());
    }

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        // Handle funny paths
        CFunnyPath::FunnyUNC funnyUNC = CFunnyPath::IsFunnyUNCPath( pwszScope );
        XGrowable<WCHAR> xScope;
        switch ( funnyUNC )
        {
        case CFunnyPath::FUNNY_ONLY:
            pwszScope += _FUNNY_PATH_LENGTH;
            break;

        case CFunnyPath::FUNNY_UNC:
        {
            unsigned ccActualLen = wcslen( pwszScope ) - _UNC_FUNNY_PATH_LENGTH;
            xScope.SetSize( ccActualLen + 1 );
            xScope[0] = L'\\';
            xScope[1] = L'\\';
            RtlCopyMemory( xScope.Get() + 2,
                           pwszScope + _UNC_FUNNY_PATH_LENGTH + 2,
                           (ccActualLen - 2 + 1) * sizeof( WCHAR ) );
            pwszScope = xScope.Get();
            break;
        }

        default:
            break;
        }

        //
        // Any catalog on the remote machine will do for a scope of the form
        // \\machine
        //

        sc = S_FALSE;

        if ( pwszScope[0] == L'\\' &&
             pwszScope[1] == L'\\' &&
             0 != pwszScope[2] &&
             0 == wcschr( pwszScope + 2, L'\\' ) )
        {
            WCHAR const *pwcM = pwszScope + 2;
            CMachineAdmin RemoteMachine( pwcM, FALSE );

            ULONG iBmkTemp = iBmk;
            sc = LocateCatalog( RemoteMachine, L"\\", iBmkTemp, pwszCat, pccCat );

            if ( S_OK == sc )
            {
                unsigned cc = wcslen( pwcM ) + 1;
                if ( *pccMachine >= cc )
                    wcscpy( pwszMachine, pwcM );

                *pccMachine = cc + 1;
            }
            else
                iBmk -= iBmkTemp;
        }    
        else 
        {
            //
            // Next try local machine.
            //

            CMachineAdmin LocalMachine( 0, FALSE );

            ULONG iBmkTemp = iBmk;
            sc = LocateCatalog( LocalMachine, pwszScope, iBmkTemp, pwszCat, pccCat );

            if ( S_OK == sc )
            {
                if ( *pccMachine >= 2 )
                {
                    pwszMachine[0] = L'.';
                    pwszMachine[1] = 0;
                }

                *pccMachine = 2;
            }
            else
                iBmk -= iBmkTemp;
        }

        //
        // If the path is a UNC path, then also try the remote machine.
        //

        if ( S_OK != sc && pwszScope[0] == L'\\' && pwszScope[1] == L'\\' )
        {
            WCHAR wcsMachine[MAX_PATH];

            WCHAR * pwcsSlash = wcschr( pwszScope + 2, L'\\' );

            if (  0 != pwcsSlash )
            {
                if ( (pwcsSlash - pwszScope - 2) > sizeof(wcsMachine)/sizeof(WCHAR) )
                {
                    ciDebugOut(( DEB_WARN, "Too long or ill-formed UNC path %ws\n", pwszScope ));
                    sc = QUERY_E_INVALID_DIRECTORY;
                }
                else
                {
                    unsigned cc = (unsigned)(pwcsSlash - pwszScope - 2);
                    RtlCopyMemory( wcsMachine, pwszScope + 2, cc * sizeof(WCHAR) );
                    wcsMachine[cc] = 0;
    
                    CMachineAdmin RemoteMachine( wcsMachine, FALSE );
    
                    sc = LocateCatalog( RemoteMachine, pwszScope, iBmk, pwszCat, pccCat );
    
                    if ( S_OK == sc )
                    {
                        if ( *pccMachine >= cc + 1 )
                        {
                            RtlCopyMemory( pwszMachine, wcsMachine, (cc + 1) * sizeof(WCHAR) );
                        }
    
                        *pccMachine = cc + 1;
                    }
                }
            }
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in LocateCatalogs\n", e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

STDAPI LocateCatalogsA( char const * pszScope,
                        ULONG        iBmk,
                        char  *      pszMachine,
                        ULONG *      pccMachine,
                        char *       pszCat,
                        ULONG *      pccCat )
{
    //
    // Parameter checks
    //

    if ( 0 == pszScope ||
         0 == pccMachine ||
         0 == pccCat )
    {
        return E_INVALIDARG;
    }

    // null ptrs for pszMachine and pszCat are tolerated if the corresponding length
    // indicators are 0.
    if ( (0 == pszMachine && *pccMachine > 0) ||
         (0 == pszCat && *pccCat > 0) )
    {
        return E_INVALIDARG;
    }


    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        USHORT ccScope = (USHORT)strlen(pszScope);

        // RtlOemStringToUnicodeString is expecting
        // maxlength to be greater than actual length, so throwing
        // in an extra character.

        XPtrST<WCHAR> xwszScope( new WCHAR[ccScope + 1] );
        XPtrST<WCHAR> xwszMachine( new WCHAR[*pccMachine] );
        XPtrST<WCHAR> xwszCat( new WCHAR[*pccCat] );

        //
        // Convert to Unicode
        //

        OEM_STRING uStrOem;
        uStrOem.Buffer = (char *)pszScope;
        uStrOem.Length = ccScope;
        uStrOem.MaximumLength = ccScope + 1;

        UNICODE_STRING uStr;
        uStr.Buffer = xwszScope.GetPointer();
        uStr.Length = 0;
        uStr.MaximumLength = (ccScope + 1) * sizeof(WCHAR);

        NTSTATUS Status = RtlOemStringToUnicodeString( &uStr,
                                                       &uStrOem,
                                                       FALSE );

        if ( !NT_SUCCESS(Status) )
        {
           DWORD dwError = RtlNtStatusToDosError( sc );

           return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        ULONG ccMachine = *pccMachine;
        ULONG ccCat = *pccCat;

        sc = LocateCatalogsW( xwszScope.GetPointer(),
                              iBmk,
                              xwszMachine.GetPointer(),
                              &ccMachine,
                              xwszCat.GetPointer(),
                              &ccCat );

        if ( S_OK != sc )
            return sc;

        // We need to go through this conversion attempt even when we know it
        // is going to fail (i.e. when *pccMachine <= ccMachine). That is the
        // only way to know the right size to be returned through pccMachine.
        uStrOem.Buffer = pszMachine;
        uStrOem.Length = 0;
        uStrOem.MaximumLength = (USHORT)*pccMachine;

        uStr.Buffer = xwszMachine.GetPointer();
        uStr.Length = (USHORT)(ccMachine-1) * sizeof(WCHAR);
        uStr.MaximumLength = uStr.Length + sizeof(WCHAR);

        Status = RtlUnicodeStringToOemString( &uStrOem,
                                              &uStr,
                                              FALSE );

        // We don't return an error if we get back the STATUS_BUFFER_OVERFLOW
        // error. We merely won't copy the string but will have the right length
        // in *pccMachine. That is how LocateCatalogs works.
        if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW)
        {
           DWORD dwError = RtlNtStatusToDosError( sc );

           return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        *pccMachine = uStrOem.Length + sizeof(WCHAR);

        // We need to go through this conversion attempt even when we know it
        // is going to fail (i.e. when *pccCat <= ccCat). That is the
        // only way to know the right size to be returned through pccCat.
        uStrOem.Buffer = pszCat;
        uStrOem.Length = 0;
        uStrOem.MaximumLength = (USHORT)*pccCat;

        uStr.Buffer = xwszCat.GetPointer();
        uStr.Length = (USHORT)(ccCat-1) * sizeof(WCHAR);
        uStr.MaximumLength = uStr.Length + sizeof(WCHAR);

        Status = RtlUnicodeStringToOemString( &uStrOem,
                                              &uStr,
                                              FALSE );

        // We don't return an error if we get back the STATUS_BUFFER_OVERFLOW
        // error. We merely won't copy the string but will have the right length
        // in *pccMachine. That is how LocateCatalogs works.
        if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW)
        {
            DWORD dwError = RtlNtStatusToDosError( sc );

            return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        *pccCat = uStrOem.Length + sizeof(WCHAR);
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in LocateCatalogs\n", e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   Delnode, private
//
//  Synopsis:   Deletes a directory recursively.
//
//  Arguments:  [wcsDir]     -- Directory to kill
//              [fDelTopDir] -- if TRUE, delete directory structure also
//
//
//  Returns:    ULONG - error code if failure
//
//  History:    22-Jul-92 KyleP     Created
//              06 May 1995 AlanW   Made recursive, and more tolerant of
//                                  errors in case of interactions with
//                                  CI filtering.
//              08-Jan-97 dlee      Copied from tdbv1
//              28-Jul-97 KyleP     Copied from setup (indexsrv.dll)
//
//--------------------------------------------------------------------------

ULONG Delnode( WCHAR const * wcsDir, BOOL fDelTopDir )
{
    ciDebugOut(( DEB_ITRACE, "Delnoding '%ws'\n", wcsDir ));

    WIN32_FIND_DATA finddata;
    WCHAR wcsBuffer[MAX_PATH];

    unsigned cwc = wcslen( wcsDir ) + wcslen( L"\\*.*" );

    if ( cwc >= MAX_PATH )
        return 0;

    wcscpy( wcsBuffer, wcsDir );
    wcscat( wcsBuffer, L"\\*.*" );

    HANDLE hFindFirst = FindFirstFile( wcsBuffer, &finddata );

    while( INVALID_HANDLE_VALUE != hFindFirst )
    {
        // Look for . and ..

        if ( wcscmp( finddata.cFileName, L"." ) &&
             wcscmp( finddata.cFileName, L".." ) )
        {
            cwc = wcslen( wcsDir ) + 1 + wcslen( finddata.cFileName );

            if ( cwc >= MAX_PATH )
                return 0;

            wcscpy( wcsBuffer, wcsDir );
            wcscat( wcsBuffer, L"\\" );
            wcscat( wcsBuffer, finddata.cFileName );

            if ( finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                Delnode( wcsBuffer, fDelTopDir );
            else
                DeleteFile( wcsBuffer );
        }

        if ( !FindNextFile( hFindFirst, &finddata ) )
        {
            FindClose( hFindFirst );
            break;
        }
    }

    if (fDelTopDir)
      RemoveDirectory( (WCHAR *)wcsDir );

    return 0;
} //Delnode

#undef LocateCatalogs

STDAPI LocateCatalogs( WCHAR const * pwszScope,
                       ULONG         iBmk,
                       WCHAR *       pwszMachine,
                       ULONG *       pccMachine,
                       WCHAR *       pwszCat,
                       ULONG *       pccCat )
{
    return LocateCatalogsW( pwszScope,
                            iBmk,
                            pwszMachine,
                            pccMachine,
                            pwszCat,
                            pccCat );
} //LocateCatalogs


//+---------------------------------------------------------------------------
//
//  Function:   AssembleScopeValueString
//
//  Synopsis:   assembels a buffer out of the passed in params.
//
//  Arguments:  [ pwszAlias ]  -- Alias
//              [ fExclude  ]  -- Exclude scope flag.
//              [ pwszLogon ]  -- Logon name
//              [ xLine     ]  -- returns concatinated string.
//
//  Returns:    none
//
//  History:    12-10-97    mohamedn    cut from AddScope
//
//----------------------------------------------------------------------------

void AssembleScopeValueString( WCHAR const      * pwszAlias,
                               BOOL               fExclude,
                               WCHAR const      * pwszLogon,
                               XGrowable<WCHAR> & xLine )
{
    //
    // initialize output buffer
    //
    RtlZeroMemory( xLine.Get(), sizeof WCHAR );

    //
    // Build up the value string.
    //

    unsigned cc = 4;  // Null, 2 commas, one digit flag

    if ( 0 != pwszAlias )
        cc += wcslen( pwszAlias );

    if ( 0 != pwszLogon )
        cc += wcslen( pwszLogon );

    xLine.SetSize(cc);

    if ( 0 != pwszAlias )
        wcscat( xLine.Get(), pwszAlias );

    wcscat( xLine.Get(), L"," );

    if ( 0 != pwszLogon )
        wcscat( xLine.Get(), pwszLogon );

    wcscat( xLine.Get(), L"," );

    if ( fExclude )
        wcscat( xLine.Get(), L"4" );
    else
        wcscat( xLine.Get(), L"5" );

}

//+---------------------------------------------------------------------------
//
//  Function:   IsSUBST, private
//
//  Synopsis:   Determines if a drive is a SUBST path or a SIS volume
//
//  Arguments:  [wcDrive] -- Drive
//
//  Returns:    TRUE if the drive is SUBST.
//
//  History:    13-Nov-1998   KyleP  Created
//
//----------------------------------------------------------------------------

BOOL IsSUBST( WCHAR wcDrive )
{
    //
    // If substitutions can be > MAX_PATH this won't work, but since
    // SUBST came from DOS I doubt it's a problem.
    //

    WCHAR wszTargetDevice[MAX_PATH+5];  // "\??\" + null
    WCHAR wszVolume[] = L"C:";
    wszVolume[0] = wcDrive;

    DWORD cc = QueryDosDevice( wszVolume,             // Drive
                               wszTargetDevice,       // Target
                               sizeof(wszTargetDevice)/sizeof(WCHAR) );

    if ( 0 == cc )
    {
        ciDebugOut(( DEB_ERROR, "Error %u from QueryDosDevice(%ws)\n", GetLastError(), wszVolume ));
        THROW( CException() );
    }

    //
    // SUBSTs always start with L"\\??\\"
    //

    if ( cc > 4 &&
         wszTargetDevice[0] == L'\\' &&
         wszTargetDevice[1] == L'?' &&
         wszTargetDevice[2] == L'?' &&
         wszTargetDevice[3] == L'\\' )
    {
        ciDebugOut(( DEB_ERROR, "QueryDosDevice(%ws) reported redirected drive.\n", wszVolume ));
        return TRUE;
    }

    //
    // Checking for SIS
    //
    // -----Original Message-----
    // From: Bill Bolosky
    // Sent: Monday, February 14, 2000 1:09 PM
    // To: Drew McDaniel; Mihai Popescu-Stanesti
    // Cc: Neal Christiansen
    // Subject: RE: SIS and NTFS
    // [...]
    // We have not published external APIs for any of the things that you want to do, although I can explain
    // how to do them. Basically, all SIS has for an external API is the FSCTL_SIS_COPYFILE fscontrol. It's
    // possible to use this to determine if SIS is installed on a volume (just send it down with zero length
    // strings and see if it fails with ERROR_INVALID_FUNCTION; if it does, then it's not a SIS volume; if it
    // fails with some other error, then it is).
    // [...]
    //

    wszTargetDevice[ 0 ] = wszTargetDevice[ 1 ] = wszTargetDevice[ 3 ] = L'\\';
    wszTargetDevice[ 2 ] = L'.';
    wszTargetDevice[ 4 ] = wcDrive;
    wszTargetDevice[ 5 ] = L':';
    wszTargetDevice[ 6 ] = 0;
    HANDLE hVol = CreateFileW( wszTargetDevice, 
                               0, 
                               FILE_SHARE_READ | FILE_SHARE_WRITE, 
                               NULL, 
                               OPEN_EXISTING, 
                               0, 
                               NULL );

    if( INVALID_HANDLE_VALUE == hVol )
    {
        ciDebugOut(( DEB_ERROR, "Error %u from CreateFileW(%ws)\n", GetLastError(), wszTargetDevice ));
        THROW( CException() );
    }
    SHandle sh( hVol );

    BOOL fSuccess = DeviceIoControl( hVol, FSCTL_SIS_COPYFILE, 0, 0, 0, 0, 0, 0 );
    if( !fSuccess && ERROR_INVALID_FUNCTION == GetLastError() )
    {
        //
        // Not a SIS volume
        //
        return FALSE;
    }

    ciDebugOut(( DEB_ERROR, "FSCTL_SIS_COPYFILE(%ws) reported SIS drive.\n", wszTargetDevice ));
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsScopeValid, public
//
//  Synopsis:   Validates a scope referring to local path or UNC name
//
//  Arguments:  [pwszScope]   -- scope path
//              [len]         -- string len of pwszScope
//
//  Returns:    S_OK if scope is valid; error code otherwise.
//
//  History:    12-10-1997    mohamedn    created
//              08-25-2000    KitmanH     Added fLocal. Only validate scope
//                                        format for non local machine. Don't
//                                        check drive exitence nor drive type
//                                        for remote catalogs
//
//----------------------------------------------------------------------------

SCODE IsScopeValid( WCHAR const * pwszScope, unsigned len, BOOL fLocal )
{
    if (len < 3)
        return QUERY_E_INVALID_DIRECTORY;

    // is it UNC path?
    if ( len >= 5 && pwszScope[0] == L'\\' && pwszScope[1] == L'\\' )
    {
        WCHAR * ptr = wcschr( pwszScope + 2, L'\\' );
        
        // TRUE if we find a backslash. FALSE otherwise.
        BOOL fBackslashFound = 0 != ptr && ptr < &(pwszScope[len-1]) && ptr[1] != L'\\';
 
        if ( fBackslashFound ) 
        {
            for ( unsigned i = 2; i < len; i++ )
            {
                if (!PathIsValidChar( pwszScope[i], ( PIVC_LFN_NAME | PIVC_ALLOW_SLASH ) ))    
                    return QUERY_E_INVALID_DIRECTORY;
            }
          
            return S_OK;
        }
        else
            return QUERY_E_INVALID_DIRECTORY;
    }

    // Check if we have a scope on a valid local drive.
    // Verify that if the scope is on a removable drive, then the catalog is
    // also located on the same drive.

    if ( pwszScope[1] != L':' || pwszScope[2] != L'\\' )
        return QUERY_E_INVALID_DIRECTORY;

    for ( unsigned i = 3; i < len; i++ )
    {
        if (!PathIsValidChar( pwszScope[i], ( PIVC_LFN_NAME | PIVC_ALLOW_SLASH ) ))
            return QUERY_E_INVALID_DIRECTORY;
    }

    if ( !fLocal )
        return S_OK;

    WCHAR wszScopeDrive[_MAX_DRIVE];

    _wsplitpath(pwszScope, wszScopeDrive, 0, 0, 0);
    UINT uiDriveType = GetDriveType(wszScopeDrive);

    //
    // Check for cdrom and removable media doesn't need to happen here.
    //

    switch(uiDriveType)
    {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        case DRIVE_REMOTE:
            return QUERY_E_INVALID_DIRECTORY;

        default:
            break;
    }

    //
    // Make sure this isn't a substituted drive.
    //

    if ( IsSUBST( pwszScope[0] ) )
        return HRESULT_FROM_WIN32( ERROR_IS_SUBST_PATH );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIStopped, public
//
//  Synopsis:   tests if cisvc is not active
//
//  Returns:    TRUE if cisvc is not active
//
//  History:    2/16/98 mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIStopped()
{
    if ( !OpenSCM() )
        return TRUE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_STOPPED );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIStarted, public
//
//  Synopsis:   tests if cisvc is running
//
//  Returns:    TRUE if cisvc is running
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIStarted()
{
    if ( !OpenSCM() )
        return FALSE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_RUNNING);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIPaused, public
//
//  Synopsis:   tests if cisvc is paused
//
//  Returns:    TRUE if cisvc is running
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIPaused()
{
    if ( !OpenSCM() )
        return FALSE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_PAUSED);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::StartCI, public
//
//  Synopsis:   starts cisvc
//
//  Returns:    TRUE if cisvc was started successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::StartCI()
{
    BOOL fStarted = FALSE;

    if ( OpenSCM() )
    {
        if ( IsCIPaused() )
        {
            SERVICE_STATUS svcStatus;

            fStarted = ControlService( _xSCCI.Get(),
                                       SERVICE_CONTROL_CONTINUE,
                                       &svcStatus );

#if CIDBG == 1
            if ( !fStarted )
                ciDebugOut(( DEB_ERROR, "Failed to resume: %d\n", GetLastError() ));
#endif
        }
        else
        {
            fStarted = StartService( _xSCCI.Get(), 0, 0 );

#if CIDBG == 1
            if ( !fStarted )
                ciDebugOut(( DEB_ERROR, "Failed to start CI: %d\n", GetLastError() ));
#endif

            // Check the status until the service is no longer start pending.

            SERVICE_STATUS ssStatus;
            BOOL fOK = QueryServiceStatus( _xSCCI.Get(), &ssStatus);

#if CIDBG == 1
            if ( !fOK )
                ciDebugOut(( DEB_ERROR, "Failed to query service status: %d\n", GetLastError() ));
#endif

            DWORD dwOldCheckPoint;

            int i = 0;
            DWORD dwSleepTime = 3000;  // 3 seconds
            int iTimes = ssStatus.dwWaitHint/dwSleepTime + 1;

            while (ssStatus.dwCurrentState == SERVICE_START_PENDING)
            {
                // Save the current checkpoint.
               dwOldCheckPoint = ssStatus.dwCheckPoint;

               // Wait for a fraction of the specified interval. The waithint is a conservatively
               // large number and we don't have to wait that long
               Sleep(dwSleepTime);
               i++;

               // Check the status again.
               if (!QueryServiceStatus( _xSCCI.Get(), &ssStatus) )
               {
                   ciDebugOut(( DEB_ERROR, "Failed to query service status: %d\n", GetLastError() ));
                   break;
               }

               // Break if the checkpoint has not been incremented. We should only check the break point
               // after having slept at least dwWaitHint milliseconds.
               if (i = iTimes)
               {
                  i = 0;
                  if (dwOldCheckPoint >= ssStatus.dwCheckPoint)
                      break;
               }
            }

            unsigned uSecsWaited = 0;
            unsigned uTotalSecs = 0;
            DWORD dwState = 0;

            // Wait till all catalogs (including the removable ones) are up or timeout in 5 seconds 
            do
            {
                SCODE sc = SetCatalogState ( NULL,
                                             (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                             CICAT_ALL_OPENED,
                                             &dwState );

                if ( 0 == dwState )
                {
                    Sleep (1000);   // one second

                    if ( SUCCEEDED(sc) )
                        uSecsWaited++;

                    uTotalSecs++;
                }

            } while ( ( 0 == dwState ) && ( uSecsWaited < 5 ) && ( uTotalSecs < 8 ) );
        }
    }

    return fStarted;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::StopCI, public
//
//  Synopsis:   stop cisvc
//
//  Returns:    TRUE if cisvc was stopped successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::StopCI()
{
    BOOL fStopped = FALSE;
    BOOL fOK = TRUE;

    if ( OpenSCM() )
    {
        SERVICE_STATUS svcStatus;

        if ( WaitForSvc( _xSCCI ) )
        {
            if ( ControlService( _xSCCI.Get(),
                                 SERVICE_CONTROL_STOP,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && WaitForSvc( _xSCCI ) ; i++ )
                {
                    ciDebugOut(( DEB_ITRACE, "Sleeping waiting for CI to stop\n" ));
                    Sleep( 1000 );
                }

                if ( !WaitForSvc( _xSCCI ) )
                {
                    ciDebugOut(( DEB_ITRACE, "Stopped CI\n" ));
                    fStopped = TRUE;
                }
            }
            else
            {
                DWORD dw = GetLastError();
                ciDebugOut(( DEB_ERROR, "Can't stop CI, error %d\n", dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::PauseCI, public
//
//  Synopsis:   Pause cisvc
//
//  Returns:    TRUE if cisvc was paused successfully
//
//  History:    06-Jul-1997   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::PauseCI()
{
    BOOL fStopped = FALSE;
    BOOL fOK = TRUE;

    if ( OpenSCM() )
    {
        SERVICE_STATUS svcStatus;

        if ( WaitForSvcPause( _xSCCI ) )
        {
            if ( ControlService( _xSCCI.Get(),
                                 SERVICE_CONTROL_PAUSE,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && WaitForSvcPause( _xSCCI ) ; i++ )
                {
                    ciDebugOut(( DEB_ITRACE, "Sleeping waiting for CI to pause\n" ));
                    Sleep( 1000 );
                }

                if ( !WaitForSvcPause( _xSCCI ) )
                {
                    ciDebugOut(( DEB_ITRACE, "Paused CI\n" ));
                    fStopped = TRUE;
                }
            }
            else
            {
                DWORD dw = GetLastError();
                ciDebugOut(( DEB_ERROR, "Can't pause CI, error %d\n", dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIEnabled, public
//
//  Returns:    TRUE if the Indexing Service is enabled (automatic start)
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIEnabled()
{
    if ( !OpenSCM() )
        return FALSE;

    XGrowable<QUERY_SERVICE_CONFIG, 10> xQSC;  // Extra space is for strings.

    DWORD cbNeeded;

    BOOL fOk = QueryServiceConfig( _xSCCI.Get(),
                                   xQSC.Get(),
                                   xQSC.SizeOf(),
                                   &cbNeeded );

    if ( !fOk && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        Win4Assert( xQSC.Count() < (cbNeeded + sizeof(QUERY_SERVICE_CONFIG) - 1) / sizeof(QUERY_SERVICE_CONFIG) );
        xQSC.SetSize( (cbNeeded + sizeof(QUERY_SERVICE_CONFIG) - 1) / sizeof(QUERY_SERVICE_CONFIG) );

        BOOL fOk = QueryServiceConfig( _xSCCI.Get(),
                                       xQSC.Get(),
                                       xQSC.SizeOf(),
                                       &cbNeeded );
    }

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceConfig Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    return ( xQSC[0].dwStartType == SERVICE_AUTO_START );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::EnableCI, public
//
//  Synopsis:   Set the Indexing Service to automatic start.
//
//  Returns:    TRUE if operation succeeded
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::EnableCI()
{
    if ( !OpenSCM() )
        return FALSE;


    BOOL fOk = ChangeServiceConfig( _xSCCI.Get(),             // Handle
                                    SERVICE_NO_CHANGE,        // Type of service (no change)
                                    SERVICE_AUTO_START,       // Auto-start
                                    SERVICE_NO_CHANGE,        // Severity if service fails to start (no change)
                                    0,                        // Service binary file name (no change)
                                    0,                        // Load ordering group name (no change)
                                    0,                        // Tag identifier (no change)
                                    0,                        // Dependency names (no change)
                                    0,                        // Name of service account (no change)
                                    0,                        // Password for service account (no change)
                                    0 );                      // Display name (no change)

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "ChangeServiceConfig Failed: %d\n",GetLastError() ));
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::DisableCI, public
//
//  Synopsis:   Set the Indexing Service to manual start.
//
//  Returns:    TRUE if operation succeeded
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::DisableCI()
{
    if ( !OpenSCM() )
        return FALSE;


    BOOL fOk = ChangeServiceConfig( _xSCCI.Get(),             // Handle
                                    SERVICE_NO_CHANGE,        // Type of service (no change)
                                    SERVICE_DEMAND_START,     // Auto-start
                                    SERVICE_NO_CHANGE,        // Severity if service fails to start (no change)
                                    0,                        // Service binary file name (no change)
                                    0,                        // Load ordering group name (no change)
                                    0,                        // Tag identifier (no change)
                                    0,                        // Dependency names (no change)
                                    0,                        // Name of service account (no change)
                                    0,                        // Password for service account (no change)
                                    0 );                      // Display name (no change)

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "ChangeServiceConfig Failed: %d\n",GetLastError() ));
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::OpenSCM, private
//
//  Synopsis:   Open service controller
//
//  Returns:    TRUE if SCM was opened successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::OpenSCM()
{
    if ( _xSCCI.IsOk() )
        return TRUE;

    _xSCRoot.Set( OpenSCManager( IsLocal() ? 0 : _xwcsMachName.Get(),
                                 0,
                                 GENERIC_READ |
                                 GENERIC_WRITE |
                                 GENERIC_EXECUTE |
                                 SC_MANAGER_ALL_ACCESS ) );

    Win4Assert( _xSCRoot.IsOk() );

    if ( _xSCRoot.IsOk() )
    {
        _xSCCI.Set( OpenService( _xSCRoot.Get(),
                                 L"cisvc",
                                 SERVICE_ALL_ACCESS ) );
    }

    return _xSCCI.IsOk();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TunePerformance, public
//
//  Synopsis:   Tune Indexing Service parameters for Indexing.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::TunePerformance(BOOL fServer, WORD wIndexingPerf,
                                    WORD wQueryingPerf)
{
   TuneFilteringParameters(fServer, wIndexingPerf, wQueryingPerf);
   TuneMergeParameters(fServer, wIndexingPerf, wQueryingPerf);
   TunePropCacheParameters(fServer, wIndexingPerf, wQueryingPerf);
   TuneMiscellaneousParameters(fServer, wIndexingPerf, wQueryingPerf);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneFilteringParameters, private
//
//  Synopsis:   Tune filtering parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TuneFilteringParameters(BOOL fServer, WORD wIndexingPerf,
                                            WORD wQueryingPerf)
{
    // FilterRetryInterval - Controls how often the filter daemon will attempt to
    // refilter a document currently open elsewhere. Decrease interval for aggressive indexing
    // behavior. Leave it at default for moderate behavior. Leave it near max for
    // low key indexing.

    // MaxFileSizeFiltered - No need to change this to tweak aggressiveness.

    // FilterRetries - Controls the max number of times refiltering will be
    // attempted. Approach max for aggressive indexing behavior so we can index
    // as many docs as we can. Leave it at default for moderate behavior. Approach
    // the min value for low key indexing.

    // MaxDaemonVmUse - Maximum amount of pagefile space consumed by out-of-process filter
    // daemon. No need to change this to tweak aggressiveness.


    Win4Assert(wIndexingPerf <= wHighPos && wIndexingPerf >= wLowPos);

    DWORD dwFilterRetryInterval, dwFilterRetries, dwFilterDelayInterval,
          dwFilterRemainingThreshold, dwSecQFilterRetries;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwFilterRetryInterval = 5;
            dwFilterRetries = 2;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_MIN + 1;   // try max number of times before giving up
            dwFilterDelayInterval = 5; // 5 second wait in the daemon...
            dwFilterRemainingThreshold = 5; // when there are this many docs left
            break;

        case wMidPos:
            dwFilterRetryInterval = CI_FILTER_RETRY_INTERVAL_DEFAULT / 2;
            dwFilterRetries = CI_FILTER_RETRIES_DEFAULT;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_DEFAULT;
            dwFilterDelayInterval = CI_FILTER_DELAY_INTERVAL_DEFAULT;
            dwFilterRemainingThreshold = CI_FILTER_REMAINING_THRESHOLD_DEFAULT;
            break;

        case wLowPos:
            dwFilterRetryInterval = CI_FILTER_RETRY_INTERVAL_DEFAULT * 2;
            dwFilterRetries = CI_FILTER_RETRIES_MIN;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_DEFAULT;
            dwFilterDelayInterval = CI_FILTER_DELAY_INTERVAL_DEFAULT;
            dwFilterRemainingThreshold = CI_FILTER_REMAINING_THRESHOLD_DEFAULT;
            break;

        default:
            Win4Assert(!"How did we get here?");
            break;
    }

    Win4Assert(dwFilterRetryInterval <= CI_FILTER_RETRY_INTERVAL_MAX &&
               dwFilterRetryInterval >= CI_FILTER_RETRY_INTERVAL_MIN);
    Win4Assert(dwFilterDelayInterval <= CI_FILTER_DELAY_INTERVAL_MAX &&
               dwFilterDelayInterval >= CI_FILTER_DELAY_INTERVAL_MIN);
    Win4Assert(dwFilterRemainingThreshold <= CI_FILTER_REMAINING_THRESHOLD_MAX &&
               dwFilterRemainingThreshold >= CI_FILTER_REMAINING_THRESHOLD_MIN);
    Win4Assert(dwSecQFilterRetries <= CI_SECQ_FILTER_RETRIES_MAX &&
               dwSecQFilterRetries >= CI_SECQ_FILTER_RETRIES_MIN);
    Win4Assert(dwFilterRetries <= CI_FILTER_RETRIES_MAX &&
               dwFilterRetries >= CI_FILTER_RETRIES_MIN);

    // Set registry parameters

    SetDWORDParam( wcsFilterRetryInterval, dwFilterRetryInterval );
    SetDWORDParam( wcsFilterDelayInterval, dwFilterDelayInterval );
    SetDWORDParam( wcsFilterRetries, dwFilterRetries );
    SetDWORDParam( wcsSecQFilterRetries, dwSecQFilterRetries );
    SetDWORDParam( wcsFilterRemainingThreshold, dwFilterRemainingThreshold );
} //TuneFilteringParameters

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneMergeParameters, private
//
//  Synopsis:   Tune merging parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::TuneMergeParameters(BOOL fServer, WORD wIndexingPerf,
                                        WORD wQueryingPerf)
{
    // MasterMergeCheckPointInterval - Determines how much work (data written to the
    // new master index) to redo in case a master merge is paused and restarted. Ignore
    // this because it should be an uncommon occurrence.

    // MaxFreshCount - Max # of files whose latest indexed data is not in the master
    // index. When this limit is reached, a master merge will be started. For aggressive
    // indexing we want to set this param to a high value to minimize the disk intensive
    // master merges. For other situations, let this be the default value.

    // MaxIdealIndexes - Maximum number of indices considered acceptable in a
    // well-tuned system. When the number of indices climbs above this number and the
    // system is idle then an annealing merge will take place to bring the total
    // count of indices to this number. I think this should be left alone.

    // MaxMergeInterval - Sleep time between merges. Index Server activates this often
    // to determine if a merge is necessary. Usually an annealing merge, but may be a
    // shadow or master merge. I think this should be left alone.

    // MaxWordlistSize - Maximum amount of memory consumed by an individual word list.
    // When this limit is reached, only the document being filtered will be added.
    // Additional documents will be refiled and later placed in another word list. I think
    // this should be left alone because we will be in a classic space-time tradeoff
    // irrespective of how it is tuned.

    // MaxWordLists - Max number of word lists that can exist at one time. The more there'
    // are, the less often you need to merge. For aggressive indexing behavior, use more
    // word lists. Use default value for the other cases.

    // MaxWordlistIo - More than this amount of I/O results in a delay before creating
    // a word list. For aggressive indexing, let this value be higher. Lower it for less
    // aggressive indexing.

    // MinMergeIdleTime - If average system idle time for the last merge check period
    // is greater than this value, then an annealing merge can be performed. I think
    // this can be ignored.

    // MinSizeMergeWordlist - Minimum combined size of word lists that will force a
    // shadow merge. For aggressive indexing behavior increase the minimum size to
    // prevent frequent shadow merges. Leave this at default for other cases.

    // MinWordlistMemory - Minimum free memory for word list creation. Leave it alone.
    // Tweaking this will introduce you to a time-space tradeoff.

    Win4Assert(wIndexingPerf <= wHighPos && wIndexingPerf >= wLowPos);

    DWORD dwMaxFreshCount, dwMaxWordlists, dwMinSizeMergeWordlist, dwMaxWordlistIo;
    DWORD dwMaxWordlistIoDiskPerf, dwMaxIndexes, dwMaxFreshDeletes;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwMaxFreshCount = 100000;
            dwMaxWordlists = (CI_MAX_WORDLISTS_MAX + CI_MAX_WORDLISTS_DEFAULT) / 2;
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_MAX;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT * 4;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_MAX;
            dwMaxIndexes = 50;
            dwMaxFreshDeletes = 10000;
            break;

        case wMidPos:
            dwMaxFreshCount = CI_MAX_FRESHCOUNT_DEFAULT;
            dwMaxWordlists = CI_MAX_WORDLISTS_DEFAULT;
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_DEFAULT * 2;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT;
            dwMaxIndexes = 25;
            dwMaxFreshDeletes = CI_MAX_FRESH_DELETES_DEFAULT;
            break;

        case wLowPos:
            dwMaxFreshCount = CI_MAX_FRESHCOUNT_DEFAULT;
            dwMaxWordlists = CI_MAX_WORDLISTS_MIN; 
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_DEFAULT;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT - 50;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT; // MIN may be too low
            dwMaxIndexes = 20;
            dwMaxFreshDeletes = CI_MAX_FRESH_DELETES_DEFAULT;
            break;

        default:
            Win4Assert(!"How did we get here?");
            break;
    }
 
    Win4Assert(dwMaxFreshCount <= CI_MAX_FRESHCOUNT_MAX &&
               dwMaxFreshCount >= CI_MAX_FRESHCOUNT_MIN);
    Win4Assert(dwMaxWordlists <= CI_MAX_WORDLISTS_MAX &&
               dwMaxWordlists >= CI_MAX_WORDLISTS_MIN);
    Win4Assert(dwMaxWordlistIo <= CI_MAX_WORDLIST_IO_MAX &&
               dwMaxWordlistIo >= CI_MAX_WORDLIST_IO_MIN);
    Win4Assert(dwMinSizeMergeWordlist <= CI_MIN_SIZE_MERGE_WORDLISTS_MAX &&
               dwMinSizeMergeWordlist >= CI_MIN_SIZE_MERGE_WORDLISTS_MIN);
    Win4Assert(dwMaxWordlistIoDiskPerf <= CI_MAX_WORDLIST_IO_DISKPERF_MAX &&
               dwMaxWordlistIoDiskPerf >= CI_MAX_WORDLIST_IO_DISKPERF_MIN);
    Win4Assert(dwMaxIndexes <= CI_MAX_INDEXES_MAX &&
               dwMaxIndexes >= CI_MAX_INDEXES_MIN);
    Win4Assert(dwMaxFreshDeletes <= CI_MAX_FRESH_DELETES_MAX &&
               dwMaxFreshDeletes >= CI_MAX_FRESH_DELETES_MIN);
 
    SetDWORDParam( wcsMaxFreshCount, dwMaxFreshCount );
    SetDWORDParam( wcsMaxWordLists, dwMaxWordlists );
    SetDWORDParam( wcsMaxWordlistIo, dwMaxWordlistIo );
    SetDWORDParam( wcsMinSizeMergeWordlists, dwMinSizeMergeWordlist );
    SetDWORDParam( wcsMaxWordlistIoDiskPerf, dwMaxWordlistIoDiskPerf );
    SetDWORDParam( wcsMaxIndexes, dwMaxIndexes );
    SetDWORDParam( wcsMaxFreshDeletes, dwMaxFreshDeletes );
} //TuneMergeParameters

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TunePropCacheParameters, private
//
//  Synopsis:   Tune prop cache parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance. Try to
//                                 tune for this desired level within the
//                                 constraints imposed by resource usage.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TunePropCacheParameters(BOOL fServer, WORD wIndexingPerf,
                                            WORD wQueryingPerf)
{
    // PrimaryStoreMappedCache and SecondaryStoreMappedCache control how much
    // of the property cache is in memory. The higher, the greater is indexing
    // and search performance. Since it affects both, use wIndexingPerf and
    // wQueryingPerf to control the params.

    WORD wAvgPerf = (wIndexingPerf + wQueryingPerf + 1)/2;  // roundup

    DWORD dwPSMappedCache, dwSSMappedCache;

    Win4Assert(wAvgPerf <= wHighPos && wAvgPerf >= wLowPos);

    // 0 is minimum; 16 is default; 0xFFFFFFFF is maximum
    switch (wAvgPerf)
    {
        case wHighPos:
           // NTRAID#DB-NTBUG9-84518-2000/07/31-dlee Setting Indexing Service to the highest performance level doesn't keep the property store in RAM
           // The best thing to get max query perf is to have the entire store
           // in memory. It would be nice to have a special param (like 0xFFFFFFFF) to tell
           // propstore to do the right thing and use just the right data structure to map
           // the entire propstore in memory.
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT * 8;
           break;

        case wMidPos:
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT * 2;
           break;

        case wLowPos:
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT;
           break;

        default:
           Win4Assert(!"How did we get here?");
           break;
    }

    // PrimaryStoreBackupSize and SecondaryStoreBackupSize control (partially)
    // how often the prop cache has to be flushed to disk. The less often, the
    // faster Indexing can proceed. This has little impact on querying, so use
    // only wIndexingPerf to set the params.

    DWORD dwPSBackupSize, dwSSBackupSize;

    // 32 is minimum; 1024 is default; 500000 is maximum.
    switch (wIndexingPerf)
    {
        case wHighPos:
        case wMidPos:
           dwPSBackupSize = dwSSBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT;
           break;

        case wLowPos:
           dwPSBackupSize = dwSSBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT / 2;
           break;

        default:
           Win4Assert(!"How did we get here?");
           break;
    }

    Win4Assert(dwPSMappedCache >= CI_PROPERTY_STORE_MAPPED_CACHE_MIN &&
               dwPSMappedCache <= CI_PROPERTY_STORE_MAPPED_CACHE_MAX);
    Win4Assert(dwSSMappedCache >= CI_PROPERTY_STORE_MAPPED_CACHE_MIN &&
               dwSSMappedCache <= CI_PROPERTY_STORE_MAPPED_CACHE_MAX);
    Win4Assert(dwPSBackupSize >= CI_PROPERTY_STORE_BACKUP_SIZE_MIN &&
               dwPSBackupSize <= CI_PROPERTY_STORE_BACKUP_SIZE_MAX);
    Win4Assert(dwSSBackupSize >= CI_PROPERTY_STORE_BACKUP_SIZE_MIN &&
               dwSSBackupSize <= CI_PROPERTY_STORE_BACKUP_SIZE_MAX);

    SetDWORDParam( wcsPrimaryStoreMappedCache, dwPSMappedCache );
    SetDWORDParam( wcsSecondaryStoreMappedCache, dwSSMappedCache );
    SetDWORDParam( wcsPrimaryStoreBackupSize, dwPSBackupSize );
    SetDWORDParam( wcsSecondaryStoreBackupSize, dwSSBackupSize );
}

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneMiscellaneousParameters, private
//
//  Synopsis:   Tune filtering parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance. Try to
//                                 tune for this desired level within the
//                                 constraints imposed by resource usage.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TuneMiscellaneousParameters(BOOL fServer, WORD wIndexingPerf,
                                                WORD wQueryingPerf)
{
    // MinWordlistBattery - This controls when battery operated machines should have indexing turned off
    // to prevent rapid power erosion triggered by incessant disk activity. For aggressive indexing, ignore
    // battery power and keep on chugging. For cautious indexing, turn off indexing when running on battery.

    // WordlistUserIdle - User idle time required to keep filtering running. For aggressive indexing, always
    // keep running. For moderate indexing, use the default value. To keep a low profile, use a value closer
    // to the max, which indicates that the user has to be idle for quite a while bofore indexing can resume.

    // LowResourceSleep - How long to wait after a low resource condition before trying again.

    // ScanBackoff - Backoff from scanning based on some conditions. For aggressive indexing, back off a bit.
    // For low key indexing, use a value closer to the max value.

    // MaxUsnLogSize - Irrelevant for performance.

    // UsnLogAllocationDelta - Irrelevant for performance.

    // UsnReadTimeOut - This is the maximum amount of time the system waits before sending out
    // a USN notification (it works in conjuction with the UsnReadMinSize. When one of these two
    // conditions trigger, we get a USN notification). For aggressive indexing behavior, we want
    // this parameter to be as small as possible so we can receive notifications of file changes
    // almost instantaneously.

    // UsnReadMinSize - The minimum size of the changes beyond which a USN notification will
    // be sent. For aggressive indexing behavior we want this to be set at 1 so that any change
    // will be communicated instananeously.

    // DelayUsnReadOnLowResource  - Determines whether USN read should be delayed when machine is busy.
    // Set this to FALSE for aggressive indexing and TRUE for the other cases.

    DWORD dwMinWordlistBattery, dwWordlistUserIdle, dwScanBackoff, dwLowResourceSleep;
    DWORD dwUsnReadTimeout, dwUsnReadMinSize, dwDelayUsnReadOnLowResource;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_MIN;   // always filter, irrespective of battery power
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_MIN; // always run
            dwScanBackoff = CI_SCAN_BACKOFF_MIN;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_MIN;

            // USN parameters
            dwUsnReadTimeout = CI_USN_READ_TIMEOUT_MIN;  // Don't wait to notify!
            dwUsnReadMinSize = CI_USN_READ_MIN_SIZE_MIN; // Notify even if one byte changes!
            dwDelayUsnReadOnLowResource = 0x0;           // Don't delay!

            break;

        case wMidPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_DEFAULT;
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_DEFAULT / 2; // index if user is idle for a minute
            dwScanBackoff = CI_SCAN_BACKOFF_DEFAULT;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_DEFAULT / 2;

            // USN parameters
            dwUsnReadTimeout = CI_USN_READ_TIMEOUT_DEFAULT;
            dwUsnReadMinSize = CI_USN_READ_MIN_SIZE_DEFAULT;
            dwDelayUsnReadOnLowResource = 0x1;           // Delay!
            break;

        case wLowPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_MAX;   // Don't filter when on battery
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_DEFAULT;
            dwScanBackoff = CI_SCAN_BACKOFF_DEFAULT;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_DEFAULT;

            // USN parameters
            dwUsnReadTimeout = 2 * CI_USN_READ_TIMEOUT_DEFAULT;
            dwUsnReadMinSize = 2 * CI_USN_READ_MIN_SIZE_DEFAULT;
            dwDelayUsnReadOnLowResource = 0x1;           // Delay!
            break;

        default:
            Win4Assert(!"How did we get here?");
            break;
    }

    Win4Assert(dwMinWordlistBattery <= CI_MIN_WORDLIST_BATTERY_MAX &&
               dwMinWordlistBattery >= CI_MIN_WORDLIST_BATTERY_MIN);
    Win4Assert(dwWordlistUserIdle <= CI_WORDLIST_USER_IDLE_MAX &&
               dwWordlistUserIdle >= CI_WORDLIST_USER_IDLE_MIN);
    Win4Assert(dwScanBackoff <= CI_SCAN_BACKOFF_MAX &&
               dwScanBackoff >= CI_SCAN_BACKOFF_MIN);
    Win4Assert(dwLowResourceSleep <= CI_LOW_RESOURCE_SLEEP_MAX &&
               dwLowResourceSleep >= CI_LOW_RESOURCE_SLEEP_MIN);
    Win4Assert(dwUsnReadTimeout <= CI_USN_READ_TIMEOUT_MAX &&
               dwUsnReadTimeout >= CI_USN_READ_TIMEOUT_MIN);
    Win4Assert(dwUsnReadMinSize <= CI_USN_READ_MIN_SIZE_MAX &&
               dwUsnReadMinSize >= CI_USN_READ_MIN_SIZE_MIN);

    SetDWORDParam( wcsMinWordlistBattery, dwMinWordlistBattery );
    SetDWORDParam( wcsWordlistUserIdle, dwWordlistUserIdle );
    SetDWORDParam( wcsScanBackoff, dwScanBackoff );
    SetDWORDParam( wcsLowResourceSleep, dwLowResourceSleep );
    SetDWORDParam( wcsUsnReadTimeout, dwUsnReadTimeout );
    SetDWORDParam( wcsUsnReadMinSize, dwUsnReadMinSize );
    SetDWORDParam( wcsDelayUsnReadOnLowResource, dwDelayUsnReadOnLowResource );
}

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//      Function:   IsMsNetwork
//
//      Synopsis:   Resolves whether or not we're attempting to connect to
//                  a MS network
//
//      Arguments:  [pwszMachine] -- Name of the machine to check
//
//      Returns:    TRUE if it's a Microsoft server or FALSE otherwise
//
//      History:    11/12/00        DGrube  Created in a different codebase
//                  2/1/02          dlee    Modified for Indexing Service
//
//----------------------------------------------------------------------------

BOOL IsMsNetwork( LPCWSTR pwszMachine )
{
    // Reserve extra space for prepending \\ and for a null-terminator

    unsigned cwc = wcslen( pwszMachine ) + 3;

    XArray<WCHAR> xMachine( cwc );

    // Check name -- it needs to have \\ at the start for better performance.
    // It works otherwise, but takes forever.

    if ( *pwszMachine != L'\\' )
        wcscpy( xMachine.Get(), L"\\\\" );
    else
        xMachine[0] = 0;

    wcscat( xMachine.Get(), pwszMachine );

    //
    // Fill a block of memory with zeroes; then initialize the NETRESOURCE
    // structure.
    //

    NETRESOURCE nr;
    ZeroMemory( &nr, sizeof nr );

    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwType = RESOURCETYPE_ANY;
    nr.lpRemoteName = xMachine.Get();

    //
    // First call the WNetGetResourceInformation function with
    //  memory allocated to hold only a NETRESOURCE structure. This
    //  method can succeed if all the NETRESOURCE pointers are NULL.
    //

    NETRESOURCE nrOut;
    LPTSTR pszSystem = 0;              // pointer to variable-length strings
    NETRESOURCE * lpBuffer = &nrOut;   // buffer
    DWORD cbResult = sizeof( nrOut ); // buffer size

    CDynLoadMpr dlMpr;

    DWORD dwError = dlMpr.WNetGetResourceInformationW( &nr, lpBuffer, &cbResult, &pszSystem );

    //
    // If the call fails because the buffer is too small,
    // call the LocalAlloc function to allocate a larger buffer.
    //

    XArray<BYTE> xBuffer;

    if ( ERROR_MORE_DATA == dwError )
    {
        xBuffer.Init( cbResult );
        lpBuffer = (NETRESOURCE *) xBuffer.Get();

        // Call WNetGetResourceInformation again with the larger buffer.

        dwError = dlMpr.WNetGetResourceInformationW( &nr, lpBuffer, &cbResult, &pszSystem );
    }

    if ( NO_ERROR != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    BOOL bReturn = TRUE;

    // If the call succeeds, process the contents of the
    //  returned NETRESOURCE structure and the variable-length
    //  strings in lpBuffer. 
    //

    if ( 0 != lpBuffer->lpProvider )
    {
        NETINFOSTRUCT NetInfo;

        NetInfo.cbStructure = sizeof( NetInfo );
        dwError = dlMpr.WNetGetNetworkInformationW( lpBuffer->lpProvider, &NetInfo );

        if ( NO_ERROR != dwError )
        {
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        //
        // Need to shift 16 bits for masks below because their a DWORD starting at the
        // 16th bit and wNetType is a word starting at 0
        //

        if ( !( ( NetInfo.wNetType == ( WNNC_NET_MSNET  >> 16 ) ) ||
                ( NetInfo.wNetType == ( WNNC_NET_LANMAN >> 16 ) ) ) )
        {
            bReturn = FALSE;
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
} //IsMsNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\query\olympus\stub.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1997, Microsoft Corporation.
//
// File:        Stub.cxx
//
// Contents:    Catalog administration API (stub) for LocateCatalogs
//
// History:     03-Sep-97       KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntquery.h>
#include <fsci.hxx>


SCODE LocateCatalogsW( WCHAR const * pwszScope,
                       ULONG iBmk,
                       WCHAR * pwszMachine,
                       ULONG * pccMachine,
                       WCHAR * pwszCat,
                       ULONG * pccCat )
{
    return E_NOTIMPL;
}

#undef LocateCatalogs

SCODE LocateCatalogs( WCHAR const * pwszScope,
                      ULONG iBmk,
                      WCHAR * pwszMachine,
                      ULONG * pccMachine,
                      WCHAR * pwszCat,
                      ULONG * pccCat )
{
    return E_NOTIMPL;
}

STDAPI LocateCatalogsA( char const * pszScope,
                        ULONG        iBmk,
                        char  *      pszMachine,
                        ULONG *      pccMachine,
                        char *       pszCat,
                        ULONG *      pccCat )
{
    return E_NOTIMPL;
}

SCODE FsCiShutdown( )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\qresult\dbqrslt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dbqrslt.cxx
//
//  Contents:   Storage/picklers for results of a query
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sstream.hxx>
#include <sizeser.hxx>
#include <dbqrslt.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::CDbQueryResults
//
//  Synopsis:   simple constructor
//
//----------------------------------------------------------------------------


CDbQueryResults::CDbQueryResults()
        : _size(0), _cHits(0), _aRank(0), _aPath(0), _pDbRst(0),
        _fNotOwnPRst( FALSE )
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::~CDbQueryResults
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CDbQueryResults::~CDbQueryResults()
{
    if( !_fNotOwnPRst )
        delete _pDbRst;

    delete _aRank;

    for( unsigned i = 0; i < _cHits; i++ )
        delete _aPath[i];
    delete _aPath;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::CDbQueryResults
//
//  Synopsis:   Constructor that unmarshalls stream
//
//  Arguments:  [stream] -- stream to unmarshall from
//
//----------------------------------------------------------------------------

CDbQueryResults::CDbQueryResults ( PDeSerStream& stream )
        : _fNotOwnPRst( FALSE )
{
    _cHits = stream.GetULong();
    _size = _cHits;
    _aRank = new ULONG [_size];
    _aPath = new WCHAR * [_size];
    for (unsigned i = 0; i < _cHits; i++ )
    {
        _aRank[i] = stream.GetULong();
        _aPath[i] = stream.GetWString();
    }

    BYTE fRst = stream.GetByte();

    if ( fRst )
        _pDbRst = (CDbRestriction *) CDbCmdTreeNode::UnMarshallTree( stream );
    else
        _pDbRst = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Size
//
//  Returns:   return size of marshalled CDbQueryResults
//
//  History:    26-Sep-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

ULONG CDbQueryResults::Size()
{
    CSizeSerStream stream;

    stream.PutULong( _cHits );

    for ( unsigned i=0; i<_cHits; i++ )
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( _pDbRst == 0 )
        stream.PutByte( FALSE );
    else
    {
       stream.PutByte( TRUE );
       _pDbRst->Marshall( stream );
    }

    return ( stream.Size() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Serialize
//
//  Synopsis:   Marshalls CDbQueryResults
//
//  Arguments:  [stream] -- marshalled into stream
//
//  History:    26-Sep-94   SitaramR    Created by modifying exisiting code
//
//----------------------------------------------------------------------------

void CDbQueryResults::Serialize( PSerStream & stream ) const
{
    stream.PutULong( _cHits );

    for (unsigned i = 0; i < _cHits; i++)
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( _pDbRst == 0 )
        stream.PutByte( FALSE );
    else
    {

        stream.PutByte( TRUE );
        _pDbRst->Marshall( stream );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Add
//
//  Synopsis:   Adds file path and rank
//
//  Arguments:  [wszPath] -- file path to be added
//              [uRank] -- rank to be added
//
//  History:    26-Sep-94   SitaramR    Created by modifying existing code.
//
//----------------------------------------------------------------------------

void CDbQueryResults::Add ( WCHAR *wszPath, ULONG uRank )
{
    if (_cHits == _size)
    {
        _size = (_size == 0)? 4: (2 * _size);
        WCHAR** aPathNew = new WCHAR *[_size];

        XArray<WCHAR *> xPath;
        xPath.Set( _size, aPathNew );

        ULONG*  aRankNew = new ULONG [_size];
        for (unsigned i = 0; i < _cHits; i++)
        {
            aPathNew[i] = _aPath[i];
            aRankNew[i] = _aRank[i];
        }
        delete []_aPath;
        delete []_aRank;

        _aPath = xPath.Acquire();
        _aRank = aRankNew;
    }
    ULONG len = wcslen( wszPath );
    _aPath[_cHits] = new WCHAR[ len+1 ];
    memcpy( _aPath[_cHits], wszPath, (len+1) * sizeof (WCHAR) );
    _aRank [_cHits] = uRank;
    _cHits++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\qresult\qmemdes.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemDeSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qmemdes.hxx>

BYTE CQMemDeSerStream::GetByte()
{
    BYTE b = *_pbCurrent;
    _pbCurrent += 1;

    return(b);
}

void CQMemDeSerStream::SkipByte()
{
    _pbCurrent += 1;
}

void CQMemDeSerStream::GetChar( char * pc, ULONG cc )
{
    memcpy( pc, _pbCurrent, cc );
    _pbCurrent += cc;
}

void CQMemDeSerStream::SkipChar( ULONG cc )
{
    _pbCurrent += cc;
}

void CQMemDeSerStream::GetWChar( WCHAR * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    memcpy( pwc, pwcTemp, cc * sizeof(WCHAR) );

    _pbCurrent = (BYTE *)(pwcTemp + cc);
}

void CQMemDeSerStream::SkipWChar( ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
}

USHORT CQMemDeSerStream::GetUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);

    return( *pus );
}

void CQMemDeSerStream::SkipUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
}

ULONG CQMemDeSerStream::GetULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);

    return( *pul );
}

void CQMemDeSerStream::SkipULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
}

long CQMemDeSerStream::GetLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);

    return( *pl );
}

void CQMemDeSerStream::SkipLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
}

float CQMemDeSerStream::GetFloat()
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);

    return( *pf );
}

void CQMemDeSerStream::SkipFloat()
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);
}

double CQMemDeSerStream::GetDouble()
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);

    return( *pd );
}

void CQMemDeSerStream::SkipDouble()
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);
}

ULONG CQMemDeSerStream::PeekULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    return( *pul );
}

char * CQMemDeSerStream::GetString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    ULONG len = *pul;
    _pbCurrent = (BYTE *)(pul + 1);
    char * psz = new char[len+1];
    memcpy(psz, _pbCurrent, len);
    _pbCurrent += len;
    psz[len] = 0;

    return(psz);
}

WCHAR * CQMemDeSerStream::GetWString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    ULONG len = *pul;
    WCHAR * pwsz = new WCHAR[len + 1];
    _pbCurrent = (BYTE *)(pul + 1);
    memcpy(pwsz, _pbCurrent, len * sizeof(WCHAR) );
    _pbCurrent += len * sizeof(WCHAR);
    pwsz[len] = 0;

    return(pwsz);
}

void CQMemDeSerStream::GetBlob( BYTE * pb, ULONG cb )
{
    memcpy( pb, _pbCurrent, cb );
    _pbCurrent += cb;
}

void CQMemDeSerStream::SkipBlob( ULONG cb )
{
    _pbCurrent += cb;
}

void CQMemDeSerStream::GetGUID( GUID & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    memcpy( &guid, pguid, sizeof(guid) );
    _pbCurrent = (BYTE *)(pguid + 1);
}

void CQMemDeSerStream::SkipGUID()
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\qresult\qmemser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qmemser.hxx>

CQMemSerStream::CQMemSerStream( unsigned cb )
        : _cb( cb )
{
    _pb = (BYTE *) GlobalAlloc( GPTR | GMEM_DDESHARE, cb );

    if ( _pb == 0 )
        THROW ( CException( E_OUTOFMEMORY ) );

    _pbCurrent = _pb;
}

CQMemSerStream::CQMemSerStream( BYTE * pb )
        : _cb( 0 ),
          _pb( pb ),
          _pbCurrent( _pb )
{
}

CQMemSerStream::~CQMemSerStream()
{
    if ( _cb > 0 )
        GlobalFree( _pb );
}


BYTE *CQMemSerStream::AcqBuf()
{
    BYTE *pTmp = _pb;
    _pb = 0;
    _cb = 0;
    return (pTmp) ;
}


void CQMemSerStream::PutByte( BYTE b )
{
    *_pbCurrent = b;
    _pbCurrent += 1;
}

void CQMemSerStream::PutChar( char const * pc, ULONG cc )
{
    memcpy( _pbCurrent, pc, cc );
    _pbCurrent += cc;
}

void CQMemSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    memcpy( pwcTemp, pwc, cc * sizeof(WCHAR) );

    _pbCurrent = (BYTE *)(pwcTemp + cc);
}

void CQMemSerStream::PutUShort( USHORT us )
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    *pus = us;
    _pbCurrent = (BYTE *)(pus + 1);
}

void CQMemSerStream::PutULong( ULONG ul )
{
    ULONG * pul = AlignULONG(_pbCurrent);
    *pul = ul;
    _pbCurrent = (BYTE *)(pul + 1);
}

void CQMemSerStream::PutLong( long l )
{
    long * pl = AlignLong(_pbCurrent);
    *pl = l;
    _pbCurrent = (BYTE *)(pl + 1);
}

void CQMemSerStream::PutFloat( float f )
{
    float * pf = AlignFloat(_pbCurrent);
    *pf = f;
    _pbCurrent = (BYTE *)(pf + 1);
}

void CQMemSerStream::PutDouble( double d )
{
    double * pd = AlignDouble(_pbCurrent);
    *pd = d;
    _pbCurrent = (BYTE *)(pd + 1);
}

void CQMemSerStream::PutString( char const * psz )
{
    ULONG len = strlen(psz);
    ULONG * pul = AlignULONG(_pbCurrent);
    *pul = len;
    _pbCurrent = (BYTE *)(pul + 1);
    memcpy(_pbCurrent, psz, len);
    _pbCurrent += len;
}

void CQMemSerStream::PutWString( WCHAR const * pwsz )
{
    ULONG len = wcslen(pwsz);
    ULONG * pul = AlignULONG(_pbCurrent);
    *pul = len;
    len *= sizeof(WCHAR);
    _pbCurrent = (BYTE *)(pul + 1);
    memcpy(_pbCurrent, pwsz, len );
    _pbCurrent += len;
}

void CQMemSerStream::PutBlob( BYTE const * pb, ULONG cb )
{
    memcpy( _pbCurrent, pb, cb );
    _pbCurrent += cb;
}

void CQMemSerStream::PutGUID( GUID const & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    memcpy( pguid, &guid, sizeof(guid) );
    _pbCurrent = (BYTE *)(pguid + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\qresult\sizeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       SizeSer.cxx
//
//  Contents:   Class to compute size of serialized structure.
//
//  History:    28-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sizeser.hxx>

CSizeSerStream::CSizeSerStream()
        : _cb( 0 )
{
}

CSizeSerStream::~CSizeSerStream()
{
}

void CSizeSerStream::PutByte( BYTE b )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += 1;
}

void CSizeSerStream::PutChar( char const * pc, ULONG cc )
{
    Win4Assert( sizeof(char) == 1 );
    _cb += cc;
}

void CSizeSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignWCHAR((BYTE *) UIntToPtr( _cb ) )) + sizeof(WCHAR) * cc;
}

void CSizeSerStream::PutUShort( USHORT us )
{
    Win4Assert( sizeof(USHORT) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignUSHORT((BYTE *) UIntToPtr( _cb ) )) + sizeof(USHORT);
}

void CSizeSerStream::PutULong( ULONG ul )
{
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG);
}

void CSizeSerStream::PutLong( long l )
{
    Win4Assert( sizeof(long) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignLong((BYTE *) UIntToPtr( _cb ) )) + sizeof(long);
}

void CSizeSerStream::PutFloat( float f )
{
    Win4Assert( sizeof(float) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignFloat((BYTE *) UIntToPtr( _cb ) )) + sizeof(float);
}

void CSizeSerStream::PutDouble( double d )
{
    Win4Assert( sizeof(double) == 8 );
    _cb = (unsigned)((ULONG_PTR)AlignDouble((BYTE *) UIntToPtr( _cb ) )) + sizeof(double);
}

void CSizeSerStream::PutString( char const * psz )
{
    Win4Assert( sizeof(char) == 1 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) + strlen(psz);
}

void CSizeSerStream::PutWString( WCHAR const * pwsz )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) +
        wcslen(pwsz) * sizeof(WCHAR);
}

void CSizeSerStream::PutBlob( BYTE const * pb, ULONG cb )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += cb;
}

void CSizeSerStream::PutGUID( GUID const & guid )
{
    Win4Assert( sizeof(GUID) == 16 );
    _cb = (unsigned)((ULONG_PTR)AlignGUID((BYTE *) UIntToPtr( _cb ) )) + sizeof(GUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\qresult\qresult.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       qresult.cxx
//
//  Contents:   Storage/picklers for results of a query
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sstream.hxx>
#include <sizeser.hxx>

#include "qresult.hxx"

// Smart pointer for aPathNew (see Add() below )
class XPath 
{
public:
    XPath( WCHAR** p = 0 )
    {
        _p = p;
    }

    ~XPath()
    {
        delete _p;
    }

    WCHAR** Acquire()
    {
        WCHAR** ptmp = _p;
        _p = 0;
        return( ptmp );
    }

private:
    WCHAR** _p;

};

//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::CQueryResults
//
//  Synopsis:   simple constructor
//
//----------------------------------------------------------------------------


CQueryResults::CQueryResults()
        : _size(0), _cWid(0), _aRank(0), _aPath(0), pRst(0),
        _fNotOwnPRst( FALSE )
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::~CQueryResults
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CQueryResults::~CQueryResults()
{
    if( !_fNotOwnPRst )
        delete pRst;

    delete _aRank;

    for( unsigned i = 0; i < _cWid; i++ )
        delete _aPath[i];
    delete _aPath;
}




//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::CQueryResults
//
//  Synopsis:   Constructor that unmarshalls stream
//
//  Arguments:  [stream] -- stream to unmarshall from
//
//----------------------------------------------------------------------------

CQueryResults::CQueryResults ( PDeSerStream& stream )
        : _fNotOwnPRst( FALSE )
{
    _cWid = stream.GetULong();
    _size = _cWid;
    _aRank = new ULONG [_size];
    _aPath = new WCHAR * [_size];
    for (unsigned i = 0; i < _cWid; i++ )
    {
        _aRank[i] = stream.GetULong();
        _aPath[i] = stream.GetWString();
    }

    BYTE fRst = stream.GetByte();
    if ( fRst )
        pRst = CRestriction::UnMarshall( stream );
    else
        pRst = 0;

    END_CONSTRUCTION ( CQueryResults );
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Size
//
//  Returns:   return size of marshalled CQueryResults
//
//  History:    26-Sep-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

ULONG CQueryResults::Size()
{
    CSizeSerStream stream;

    stream.PutULong( _cWid );

    for ( unsigned i=0; i<_cWid; i++ )
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( pRst == 0 )
        stream.PutByte( FALSE );
    else
    {
        stream.PutByte( TRUE );
        pRst->Marshall( stream );
    }

    return ( stream.Size() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Serialize
//
//  Synopsis:   Marshalls CQueryResults
//
//  Arguments:  [stream] -- marshalled into stream
//
//  History:    26-Sep-94   SitaramR    Created by modifying exisiting code
//
//----------------------------------------------------------------------------

void CQueryResults::Serialize( PSerStream & stream ) const
{
    stream.PutULong( _cWid );

    for (unsigned i = 0; i < _cWid; i++)
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( pRst == 0 )
        stream.PutByte( FALSE );
    else
    {
        stream.PutByte( TRUE );
        pRst->Marshall( stream );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Add
//
//  Synopsis:   Adds file path and rank
//
//  Arguments:  [wszPath] -- file path to be added
//              [uRank] -- rank to be added
//
//  History:    26-Sep-94   SitaramR    Created by modifying existing code.
//
//----------------------------------------------------------------------------

void CQueryResults::Add ( WCHAR *wszPath, ULONG uRank )
{
    if (_cWid == _size)
    {
        _size = (_size == 0)? 4: (2 * _size);
        WCHAR** aPathNew = new WCHAR *[_size];

        XPath xPath( aPathNew );

        ULONG*  aRankNew = new ULONG [_size];
        for (unsigned i = 0; i < _cWid; i++)
        {
            aPathNew[i] = _aPath[i];
            aRankNew[i] = _aRank[i];
        }
        delete []_aPath;
        delete []_aRank;

        _aPath = xPath.Acquire();
        _aRank = aRankNew;
    }
    ULONG len = wcslen( wszPath );
    _aPath[_cWid] = new WCHAR[ len+1 ];
    memcpy( _aPath[_cWid], wszPath, (len+1) * sizeof (WCHAR) );
    _aRank [_cWid] = uRank;
    _cWid++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\h\monquery.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       monquery.h
//
//  Contents:   Index Server <==> Monarch interface functions
//
//  History:    24 Jan 1997    AlanW    Created
//
//----------------------------------------------------------------------------

#ifndef _MONQUERY_H_
#define _MONQUERY_H_

#if defined(__cplusplus)
extern "C"
{
#endif


typedef struct tagCIPROPERTYDEF
{
    LPWSTR      wcsFriendlyName;
    DWORD       dbType;
    DBID        dbCol;
} CIPROPERTYDEF;

// Create an ICommand, specifying scopes and a catalog.
STDAPI CIMakeICommand( ICommand **           ppQuery,
                       ULONG                 cScope,
                       DWORD const *         aDepths,
                       WCHAR const * const * awcsScope,
                       WCHAR const * const * awcsCat,
                       WCHAR const * const * awcsMachine );

// Convert pwszRestriction in Triplish to a command tree.
STDAPI CITextToSelectTree( WCHAR const * pwszRestriction,
                     DBCOMMANDTREE * * ppTree,
                     ULONG cProperties,
       /*optional*/  CIPROPERTYDEF * pReserved );

// Convert pwszRestriction in Triplish to a command tree.
STDAPI CITextToFullTree( WCHAR const * pwszRestriction,
                         WCHAR const * pwszColumns,
                         WCHAR const * pwszSortColumns,
                         DBCOMMANDTREE * * ppTree,
                         ULONG cProperties,
           /*optional*/  CIPROPERTYDEF * pReserved );

#if defined(__cplusplus)
}
#endif

#endif // _MONQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\catstate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:   catstate.CXX
//
//  Contents:   CCatState implementation
//
//  History:    19-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catstate.hxx>
#include <doquery.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::CCatState, public
//
//  Synopsis:   Initializes global state info.
//
//  History:    06-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

CCatState::CCatState()
        : _wcsProperty( 0 ), _propType( CONTENTS ),
          _prstLast( 0 ),
          _ulMethod( VECTOR_RANK_JACCARD ),
          _isDeep( FALSE ),
          _isVirtual( FALSE ),
          _eType( CiNormal ),
          _pwcsColumns( 0 ), _nColumns( 0 ),
          _nSort( 0 ), _psi( 0 ),
          _lcid( GetSystemDefaultLCID() ),
          _fIsSC( FALSE ),
          _fUseCI( FALSE ),
          _cCategories( 0 ),
          _aCategories( 0 ),
          _iCategorizationRow( 0 ),
          _cMaxResults( 0 ),
          _cFirstRows( 0 ),
          _wcsCDOld (MAX_PATH ),
          _wcsCD (MAX_PATH)
{
    // set default output format
    SetColumn( L"path", 0 );
    SetColumn( L"filename", 1 );
    SetNumberOfColumns( 2 );
    SetDefaultProperty ( L"contents" );
    SetDeep (TRUE);

    _cCatSets = 0;

    DWORD rc = GetCurrentDirectory( _wcsCDOld.Count(), _wcsCDOld.Get() );

    if( 0 == rc )
    {
        THROW( CQueryException( QUERY_GET_CD_FAILED ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::~CCatState, public
//
//  Synopsis:   Frees memory used by CCatState
//
//  History:    25-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

CCatState::~CCatState()
{
    // free current propery name
    delete [] _wcsProperty;

    // free output column names
    if( _pwcsColumns )
    {
        unsigned int cColumns;

        for( cColumns = 0; cColumns < _nColumns; cColumns++ )
        {
            delete [] _pwcsColumns[ cColumns ];
        }

        delete [] _pwcsColumns;
    }

    // free sort info
    if( _psi )
    {
        unsigned int cProp;

        for( cProp = 0; cProp < _nSort; cProp++ )
        {
            delete [] _psi[ cProp ].wcsProp;
        }

        delete [] _psi;
    }

    // restore current directory
    if( _wcsCDOld.Get() )
        SetCurrentDirectory( _wcsCDOld.Get() );

    delete _prstLast;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddCatSetWithDefaults, public
//
//  Synopsis:   Adds a row with default <machine, catalog, scope, depth> values
//
//  Arguments:
//
//  Notes:
//
//  History:    21-Jan-97   krishnaN     Created
//
//----------------------------------------------------------------------------

SCODE CCatState::AddCatSetWithDefaults()
{
   CString *pStr = new CString( L"\\" );
   _aCatalogs.Add (pStr, _cCatSets);
   pStr = new CString( L"." );
   _aMachines.Add (pStr, _cCatSets);
   pStr =  new CString( L"\\" );
   _aCatScopes.Add (pStr, _cCatSets);
   _afIsDeep.Add (TRUE, _cCatSets);
   _cCatSets++;
   return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetDefaultProperty, public
//
//  Synopsis:   Changes the property passed to the parser on initialization
//              (the 'global default' property)
//
//  Arguments:  [wcsProperty] -- friendly name of property
//                               (can be 0)
//
//  Notes:      Makes its own copy of the property name
//              (unlike GetDefaultProperty, which just returns a pointer)
//
//  History:    18-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetDefaultProperty( WCHAR const * wcsProperty )
{
    delete [] _wcsProperty;

    if( wcsProperty == 0 )
    {
        _wcsProperty = 0;
    }
    else
    {
        int iLength = wcslen( wcsProperty ) + 1;

        _wcsProperty = new WCHAR[ iLength ];
        memcpy( _wcsProperty, wcsProperty, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCD, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCD( WCHAR const * wcsCD )
{
    if ( _isVirtual )
    {
        unsigned cc = wcslen( wcsCD ) + 1;

        if ( _wcsCD.Count() < cc )
        {
            delete [] _wcsCD.Acquire();
            _wcsCD.Init( cc );
        }

        RtlCopyMemory( _wcsCD.Get(), wcsCD, cc * sizeof(WCHAR) );
    }
    else
    {
        if( !SetCurrentDirectory( wcsCD ) )
        {
            THROW( CQueryException( QUERY_GET_CD_FAILED ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetCD, public
//
//  Synopsis:   Returns the current directory.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatState::GetCD()
{
    if ( _isVirtual )
        return _wcsCD.Get();

    DWORD rc = GetCurrentDirectory( _wcsCD.Count(), _wcsCD.Get() );

    if( rc == 0 )
    {
        THROW( CQueryException( QUERY_GET_CD_FAILED ) );
    }

    return _wcsCD.Get();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddDir, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::AddDir( XPtrST<WCHAR> & wcsScope )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
    {
       // Use previous set's machine and catalog, if available.
       ChangeCurrentScope(wcsScope.GetPointer());
       if (_cCatSets > 1)
       {
          ChangeCurrentMachine(_aMachines[_cCatSets-2]->GetString());
          ChangeCurrentCatalog(_aCatalogs[_cCatSets-2]->GetString());
       }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddCatalog, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCatalog] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddCatalog( XPtrST<WCHAR> & wcsCatalog )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
    {
       // Use previous set's machine, if available, and a default scope
       ChangeCurrentCatalog(wcsCatalog.GetPointer());
       if (_cCatSets > 1)
       {
          ChangeCurrentMachine(_aMachines[_cCatSets-2]->GetString());
       }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddMachine, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsMachine] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddMachine( XPtrST<WCHAR> & wcsMachine )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
       ChangeCurrentMachine(wcsMachine.GetPointer());
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentCatalog, public
//
//  Synopsis:   Changes the current catalog.
//
//  Arguments:  [wcsCatalog] -- new catalog
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentCatalog (WCHAR const * wcsCatalog)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
       AddCatSetWithDefaults();

   // replace the current row's catalog value
   _aCatalogs[_cCatSets-1]->Replace(wcsCatalog);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentDepth, public
//
//  Synopsis:   Changes the current catalog.
//
//  Arguments:  [wcsCatalog] -- new catalog
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentDepth (BOOL fDepth)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();
   // replace the current row's catalog value
   _afIsDeep[_cCatSets-1] = fDepth;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentMachine, public
//
//  Synopsis:   Changes the current Machine.
//
//  Arguments:  [wcsMachine] -- new Machine
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentMachine (WCHAR const * wcsMachine)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();

   // replace the current row's Machine value
   _aMachines[_cCatSets-1]->Replace(wcsMachine);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentScope, public
//
//  Synopsis:   Changes the current scope.
//
//  Arguments:  [wcsScope] -- new scope
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentScope (WCHAR const * wcsScope)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();
   // replace the current row's scope value
   _aCatScopes[_cCatSets-1]->Replace(wcsScope);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddDepthFlag, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddDepthFlag( BOOL fIsDeep )
{
    if (_cCatSets == 0)       // if we don't have a row to change, add one
       AddCatSetWithDefaults();

    _afIsDeep[_cCatSets-1] = fIsDeep;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCatalog, public
//
//  Synopsis:   Changes the current catalog directory.
//
//  Arguments:  [wcsCatalog] -- new catalog location
//                              (0 indicates the catalog is at or above _wcsCD)
//
//  Notes:      Makes & owns a copy of the path.
//
//  History:    21-Jul-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCatalog( WCHAR const * wcsCatalog )
{
    delete [] _wcsCatalog.Acquire();

    if( wcsCatalog != 0 )
    {
        int iLength = wcslen( wcsCatalog ) + 1;

        _wcsCatalog.Init( iLength );
        memcpy( _wcsCatalog.Get(), wcsCatalog, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetColumn, public
//
//  Synopsis:   Sets the property for the specified output column.
//
//  Arguments:  [wcsColumn] -- friendly property name
//              [uPos] -- 0-based column number
//
//  Notes:      Makes its own copy of the property name.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetColumn( WCHAR const * wcsColumn, unsigned int uPos )
{
    // does _pwcsColumns need to be extended?
    if( uPos >= _nColumns )
    {
        WCHAR ** pwcsTemp = new WCHAR *[ uPos + 1 ];

        unsigned int cCol;

        // copy the old pointers and 0 any new ones
        for( cCol = 0; cCol < uPos + 1; cCol++ )
        {
            if( cCol < _nColumns )
                pwcsTemp[ cCol ] = _pwcsColumns[ cCol ];
            else
                pwcsTemp[ cCol ] = 0;
        }

        delete [] _pwcsColumns;

        _nColumns = uPos + 1;
        _pwcsColumns = pwcsTemp;
    }

    // free any previous column string
    delete [] _pwcsColumns[ uPos ];

    // copy & set the column
    if( wcsColumn == 0 )
    {
        _pwcsColumns[ uPos ] = 0;
    }
    else
    {
        int iLength = wcslen( wcsColumn ) + 1;

        _pwcsColumns[ uPos ] = new WCHAR[ iLength ];
        memcpy( _pwcsColumns[ uPos ], wcsColumn, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetColumn, public
//
//  Synopsis:   Gets the property for the specified output column.
//
//  Arguments:  [uPos] -- 0-based column number
//
//  Notes:      Returns 0 if the column number is out of range.
//              Only returns a pointer the string; does not copy it.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatState::GetColumn( unsigned int uPos ) const
{
    if( uPos >= _nColumns )
        return 0;

    return _pwcsColumns[ uPos ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetNumberOfColumns, public
//
//  Synopsis:   sets the number of columns in the output
//
//  Arguments:  [cCol] -- number of output columns
//
//  Notes:      Used after all columns have been set with
//              SetColumn().
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetNumberOfColumns( unsigned int cCol )
{
    if( cCol < _nColumns )
    {
        for( ; cCol < _nColumns; cCol++ )
        {
            delete [] _pwcsColumns[ cCol ];
            _pwcsColumns[ cCol ] = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::NumberOfColumns, public
//
//  Synopsis:   Returns the number of output columns
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

unsigned int CCatState::NumberOfColumns() const
{
    unsigned int cCol;

    for( cCol = 0; cCol < _nColumns; cCol++ )
    {
        if( _pwcsColumns[ cCol ] == 0 )
            break;
    }

    return cCol;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetSortProp, public
//
//  Synopsis:   Sets a property for sorting
//
//  Arguments:  [wcsProp] -- friendly property name
//              [sd] -- sort direction
//              [uPos] -- 0-based sort order
//
//  Notes:      Makes its own copy of the property name.
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetSortProp( WCHAR const * wcsProp, SORTDIR sd, unsigned int uPos )
{
    // does _psi need to be extended?
    if( uPos >= _nSort )
    {
        SSortInfo * psiTemp = new SSortInfo[ uPos + 1 ];

        unsigned int cProp;

        // copy the old entries and 0 any new ones
        for( cProp = 0; cProp < uPos + 1; cProp++ )
        {
            if( cProp < _nSort )
                psiTemp[ cProp ] = _psi[ cProp ];
            else
                psiTemp[ cProp ].wcsProp = 0;
        }

        delete [] _psi;

        _nSort = uPos + 1;
        _psi = psiTemp;
    }

    // free any previous property string
    delete [] _psi[ uPos ].wcsProp;

    // copy & set the column
    if( wcsProp == 0 )
    {
        _psi[ uPos ].wcsProp = 0;
    }
    else
    {
        int iLength = wcslen( wcsProp ) + 1;

        _psi[ uPos ].wcsProp = new WCHAR[ iLength ];
        memcpy( _psi[ uPos ].wcsProp, wcsProp, iLength * sizeof(WCHAR) );
    }

    _psi[ uPos ].sd = sd;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetNumberOfSortProps, public
//
//  Synopsis:   sets the number of sort keys
//
//  Arguments:  [cProp] -- number of sort keys
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetNumberOfSortProps( unsigned int cProp )
{
    if( cProp < _nSort )
    {
        for( ; cProp < _nSort; cProp++ )
        {
            delete [] _psi[ cProp ].wcsProp;
            _psi[ cProp ].wcsProp = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetSortProp, public
//
//  Synopsis:   Returns sort information about a specific key
//
//  Arguments:  [uPos] -- 0-based sort ordinal (ie uPos=0 gives the primary sort key)
//              [*pwcsName] -- friendly name of the property
//              [*psd] -- sort order for this property
//
//  Notes:      Only returns a pointer the string; does not copy it.
//              Returns 0 in *pwcsName if uPos is out of range.
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::GetSortProp( unsigned int uPos,
                             WCHAR const ** pwcsName,
                             SORTDIR * psd ) const
{
    if( uPos >= _nColumns )
    {
        if( pwcsName )
            *pwcsName = 0;
    }
    else
    {
        if( pwcsName )
            *pwcsName = _psi[ uPos ].wcsProp;
        if( psd )
            *psd = _psi[ uPos ].sd;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::NumberOfSortProps, public
//
//  Synopsis:   Returns the number of sort keys
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

unsigned int CCatState::NumberOfSortProps() const
{
    unsigned int cProp;

    for( cProp = 0; cProp < _nSort; cProp++ )
    {
        if( _psi[ cProp ].wcsProp == 0 )
            break;
    }

    return cProp;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetLocale, public
//
//  Synopsis:   Sets the new locale
//
//  Arguments:  [wcsLocale] -- Three letter abbreviation of locale
//
//  History:    29-Nov-94   SitaramR     Created
//
//----------------------------------------------------------------------------

void CCatState::SetLocale(WCHAR const *wcsLocale )
{
    WCHAR wszAbbrev[6];
    LCID lcid;

    // check for neutral langauge and neutral sub language
    if ( _wcsicmp( wcsLocale, L"neutral" ) == 0 )
    {
        _lcid = 0;
        return;
    }

    // decreasing for-loops, because we want to match  LANG_NEUTRAL and
    //    SUBLANG_NEUTRAL, which are 0, last
    for ( INT lang=0x20; lang>-1; lang-- )
        for ( INT subLang=7; subLang>-1; subLang-- )
            for ( unsigned sort=0; sort<2; sort++ )
            {
                lcid = MAKELCID( MAKELANGID( lang, subLang), sort );
                if ( GetLocaleInfoW( lcid, LOCALE_SABBREVLANGNAME, wszAbbrev, 6) )
                {
                    if ( _wcsicmp( wcsLocale, wszAbbrev ) == 0 )
                    {
                        _lcid = lcid;
                        return;
                    }
                }
            }
    THROW( CException( STATUS_INVALID_PARAMETER ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCategory, public
//
//  Synopsis:   Sets the new category
//
//  Arguments:  [wcsCategory] -- friendly category name
//              [uPos]        -- position of category
//
//  History:    21-Aug-95   SitaramR     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCategory( WCHAR const *pwcsCategory, unsigned uPos )
{
    Win4Assert( pwcsCategory );

    CString *pString = new CString( pwcsCategory );
    _aCategories.Add( pString, uPos );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetCategory, public
//
//  Synopsis:   Returns the required category
//
//  Arguments:  [uPos] -- position of category
//
//  History:    21-Aug-95   SitaramR     Created
//
//----------------------------------------------------------------------------

WCHAR const *CCatState::GetCategory( unsigned uPos ) const
{
    Win4Assert( uPos < _cCategories );

    CString *pString = _aCategories.Get( uPos );
    if ( pString )
        return pString->GetString();
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\cgiesc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       cgiesc.cxx
//
//  Contents:   WEB CGI escape & unescape classes
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cgiesc.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   DecodeURLEscapes - Decode URL escapes
//
//  Synopsis:   Removes the escape characters from a string, converting to
//              Unicode along the way.
//
//  Arguments:  [pIn]        - string to convert
//              [l]          - length of string in chars, updated on return
//              [pOut]       - converted string
//              [ulCodePage] - code page for translation
//
//----------------------------------------------------------------------------

void DecodeURLEscapes( BYTE * pIn, ULONG & l, WCHAR * pOut, ULONG ulCodePage )
{
    WCHAR * p2 = pOut;
    WCHAR c1;
    WCHAR c2;

    XArray<BYTE> xDeferBuf;
    BYTE * pDefer = 0;

    ULONG l2 = l;

    for( ; l2; l2-- )
    {
        BOOL fSaveAsUnicode = FALSE;

        //  Convert ASCII to corresponding character
        //  If Latin-1 character, save for MB translation, accumulate char
        //  If Unicode escape, flush accumulated chars and save converted char

        c1 = *pIn;

        //
        //  Spaces are escaped by converting them into plus signs.
        //  Convert them back.
        //
        if ( c1 == '+' )
        {
            c1 = ' ';
            pIn++;
        }
        else if (c1 == '%')
        {
            //
            //  Special characters are converted to values of the format %XY
            //  where XY is the HEX code for the ASCII character.
            //
            //  A percent sign is transmitted as %%.
            //
            if (*(pIn+1) == '%')
            {
               c1 = '%';
               pIn += 2;
               l2--;
            }
            else if (l2 >= 3)
            {
                pIn++;
                c1 = (WCHAR) toupper(*pIn);
                c2 = (WCHAR) toupper(*(pIn+1));

                if ( c1 == 'U' && l2 >= 6 )
                {
                    // Unicode escape, %uxxxx
                    c1 = c2;
                    c2 = (WCHAR) toupper(*(pIn+2));
                    WCHAR c3 = (WCHAR) toupper(*(pIn+3));
                    WCHAR c4 = (WCHAR) toupper(*(pIn+4));
                    if ( isxdigit( c1 ) && isxdigit( c2 ) &&
                         isxdigit( c3 ) && isxdigit( c4 ) )
                    {
                        c1  = ((c1 >= 'A') ? (c1-'A')+10 : c1-'0') << 12;
                        c1 += ((c2 >= 'A') ? (c2-'A')+10 : c2-'0') << 8;
                        c1 += ((c3 >= 'A') ? (c3-'A')+10 : c3-'0') << 4;
                        c1 += ((c4 >= 'A') ? (c4-'A')+10 : c4-'0');

                        if ( pDefer )
                        {
                            unsigned cchDefer = CiPtrToUint( pDefer - xDeferBuf.GetPointer() );

                            cchDefer = MultiByteToWideChar( ulCodePage,
                                                            0,
                                                   (char *) xDeferBuf.GetPointer(),
                                                            cchDefer,
                                                            p2,
                                                            cchDefer );

                            Win4Assert( cchDefer != 0 );
                            pDefer = 0;
                            p2 += cchDefer;
                        }
                        pIn += 5;
                        l2 -= 5;
                        fSaveAsUnicode = TRUE;
                    }
                    else
                    {
                        c1 = '%';
                    }
                }
                else if ( isxdigit( c1 ) && isxdigit( c2 ) )
                {
                    c1 = ( ((c1 >= 'A') ? (c1-'A')+10 : c1-'0')*16 +
                           ((c2 >= 'A') ? (c2-'A')+10 : c2-'0') );
                    pIn += 2;
                    l2 -= 2;
                    if ( c1 >= 0x80 && 0 == pDefer )
                    {
                        // The character needs to be deferred for MBCS
                        // translation.
                        if (xDeferBuf.GetPointer() == 0)
                        {
                            xDeferBuf.Init( l2+1 );
                        }
                        pDefer = xDeferBuf.GetPointer();
                    }
                }
                else
                    c1 = '%';
            }
            else
            {
                pIn++;
                if ( c1 >= 0x80 && 0 == pDefer )
                {
                    // The character needs to be deferred for MBCS
                    // translation.
                    if (xDeferBuf.GetPointer() == 0)
                    {
                        xDeferBuf.Init( l2+1 );
                    }
                    pDefer = xDeferBuf.GetPointer();
                }
            }
        }
        else
        {
            pIn++;
        }

        if (! fSaveAsUnicode)
        {
            if ( c1 >= 0x80 && 0 == pDefer )
            {
                // The character needs to be deferred for MBCS
                // translation.
                if (xDeferBuf.GetPointer() == 0)
                {
                    xDeferBuf.Init( l2+1 );
                }
                pDefer = xDeferBuf.GetPointer();
            }
        }
        else
        {
            Win4Assert( pDefer == 0 );
        }

        if (pDefer)
        {
            Win4Assert( c1 < 0x100 );
            *pDefer++ = (BYTE) c1;
        }
        else
        {
            *p2++ = c1;
        }
    }

    if ( pDefer )
    {
        unsigned cchDefer = CiPtrToUint( pDefer - xDeferBuf.GetPointer() );

        cchDefer = MultiByteToWideChar( ulCodePage,
                                        0,
                               (char *) xDeferBuf.GetPointer(),
                                        cchDefer,
                                        p2,
                                        cchDefer );

        Win4Assert( cchDefer != 0 );
        pDefer = 0;
        p2 += cchDefer;
    }
    *p2 = 0;
    l = CiPtrToUlong( p2 - pOut );
}


void DecodeEscapes( WCHAR * p, ULONG & l )
{
    DecodeEscapes( p, l, p );
}

void DecodeEscapes( WCHAR * pIn, ULONG & l, WCHAR * pOut )
{
    WCHAR * p2;
    int c1;
    int c2;
    ULONG l2 = l;

    for( p2=pOut; l2; l2-- )
    {
        //
        //  Spaces are escaped by converting them into plus signs.
        //  Convert them back.
        //
        if ( *pIn == L'+' )
        {
            *p2++ = L' ';
            pIn++;
        }
        else if (*pIn == L'%')
        {
            //
            //  Special characters are converted to values of the format %XY
            //  where XY is the HEX code for the ASCII character.
            //
            //  A percent sign is transmitted as %%.
            //
            if (*(pIn+1) == L'%')
            {
               *p2++ = L'%';
               pIn += 2;
               l2--;
            }
            else if (l2 > 2)
            {
                pIn++;

                c1=towupper(*pIn);
                c2=towupper(*(pIn+1));

                if ( isxdigit( c1 ) && isxdigit( c2 ) )
                {
                    *p2++ = ( ((c1 >= L'A') ? (c1-L'A')+10 : c1-L'0')*16 +
                              ((c2 >= L'A') ? (c2-L'A')+10 : c2-L'0')
                            );
                    pIn += 2;
                    l2 -= 2;
                }
                else
                    *p2++ = L'%';
            }
            else
            {
                *p2++ = *pIn++;
            }
        }
        else
        {
            *p2++ = *pIn++;
        }
    }

    *p2 = 0;
    l = CiPtrToUlong( p2 - pOut );
}

//+---------------------------------------------------------------------------
//
//  Function:   DecodeHtmlNumeric - decode HTML numeric entity
//
//  Synopsis:   Looks for sequences like "&#12345;" and converts in-place
//              to a single unicode character.
//
//  Arguments:  [pIn] - string to convert
//
//----------------------------------------------------------------------------

void DecodeHtmlNumeric( WCHAR * pIn )
{
    pIn = wcschr( pIn, L'&' );
    WCHAR * p2 = pIn;

    while (pIn && *pIn)
    {
        if (*pIn == L'&' && pIn[1] == L'#')
        {
            pIn += 2;
            USHORT ch = 0;
            while (*pIn && *pIn != L';')
            {
                if (*pIn >= L'0' && *pIn <= L'9')
                    ch = ch*10 + (*pIn - L'0');
                pIn++;
            }
            if (*pIn)
                pIn++;
            *p2++ = ch;
        }
        else
        {
            *p2++ = *pIn++;
        }
    }

    if (p2)
        *p2 = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\caturl.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       caturl.cxx
//
//  Contents:   Functions dealing with catalog URLs
//
//  History:    12 Mar 1997    AlanW    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <caturl.hxx>

const WCHAR achQueryProtocol[] = L"query:";
const unsigned cchQueryProtocol = (sizeof achQueryProtocol /
                                     sizeof achQueryProtocol[0]) - 1;

//+---------------------------------------------------------------------------
//
//  Function:   ParseCatalogURL - public
//
//  Synopsis:   Parse a catalog URL into its machine and catalog components
//
//  Arguments:  [pwszInput] - the string containing the catalog URL
//              [xpCatalog] - pointer where catalog is returned if any
//              [xpMachine] - pointer where machine is returned if any
//
//  Notes:      If there is no machine name specified, the default machine
//              name ( "." ) is used.
//
//  History:    12 Mar 1997    AlanW    Created
//
//----------------------------------------------------------------------------

SCODE ParseCatalogURL( const WCHAR * pwszInput,
                       XPtrST<WCHAR> & xpCatalog,
                       XPtrST<WCHAR> & xpMachine )
{
    Win4Assert( 0 != pwszInput );

    if (_wcsnicmp( pwszInput, achQueryProtocol, cchQueryProtocol ) == 0 )
    {
        //
        //  It's in the URL format.  Find the machine and catalog.
        //
        pwszInput += cchQueryProtocol;

        if (pwszInput[0] == L'/' && pwszInput[1] == L'/')
        {
            // Get the machine string and save a copy

            pwszInput += 2;
            const WCHAR * pwszMachEnd = wcschr( pwszInput, L'/' );
            if ( 0 == pwszMachEnd )
                pwszMachEnd = pwszInput + wcslen( pwszInput );

            WCHAR * pwszTmp = new WCHAR[ (size_t)(pwszMachEnd - pwszInput) + 1 ];

            xpMachine.Free();
            xpMachine.Set(pwszTmp);
            RtlCopyMemory( pwszTmp, pwszInput, (pwszMachEnd-pwszInput) * sizeof (WCHAR) );
            pwszTmp[ pwszMachEnd-pwszInput ] = L'\0';
            pwszInput = pwszMachEnd;
        }
        else
        {
            xpMachine.Free();
        }

        if (pwszInput[0] == L'/')
            pwszInput++;
    }
    else
    {
        xpMachine.Free();
    }

    //
    //  The rest of the string is just the catalog name.
    //

    if (pwszInput[0] != L'\0')
    {
        // Get the catalog string and save a copy

        unsigned cch = wcslen( pwszInput );

        WCHAR * pwszTmp = new WCHAR[ cch + 1 ];

        xpCatalog.Free();
        xpCatalog.Set(pwszTmp);
        RtlCopyMemory( pwszTmp, pwszInput, cch * sizeof (WCHAR) );
        pwszTmp[ cch ] = L'\0';
    }
    else
    {
        xpCatalog.Free();
    }

    //
    //  If no machine was specified, use the local machine
    //
    if ( 0 == xpMachine.GetPointer() )
    {
        ULONG cwc = 1 + wcslen( CATURL_LOCAL_MACHINE );
        xpMachine.Set( new WCHAR[ cwc ] );
        wcscpy( xpMachine.GetPointer(), CATURL_LOCAL_MACHINE );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\fmapio.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:   fmapio.cxx
//
//  Contents:   A class to read lines from a unicode or an ascii file.
//
//  History:    96/Jan/3    DwightKr    Created
//              Aug 20 1996 SrikantS    Moved from web
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::CFileMapView - public
//
//  Synopsis:   Maps a file in its entirety
//
//  Arguments:  [wcsFileName] - full path of file to map
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CFileMapView::CFileMapView( WCHAR const * wcsFileName ) :
                           _hFile(INVALID_HANDLE_VALUE),
                           _hMap(0),
                           _pbBuffer(0),
                           _cbBuffer(0),
                           _IsUnicode(FALSE)
{
    //
    //  Open the file
    //

    _hFile = CreateFile( wcsFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         0,
                         OPEN_EXISTING,
                         0,
                         0 );


    if ( INVALID_HANDLE_VALUE == _hFile )
    {
        qutilDebugOut(( DEB_IWARN, "Unable to open %ws for mapping\n", wcsFileName ));
        THROW( CException() );
    }

    _cbBuffer = GetFileSize( _hFile, 0 );

    END_CONSTRUCTION(CFileMapView);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::~CFileMapView - public
//
//  Synopsis:   Release handles & unmap file
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CFileMapView::~CFileMapView()
{
    if ( 0 != _pbBuffer )
    {
        UnmapViewOfFile( _pbBuffer );
    }

    if ( 0 != _hMap )
    {
        CloseHandle( _hMap );
    }

    if ( INVALID_HANDLE_VALUE != _hFile )
    {
        CloseHandle( _hFile );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::Init - public
//
//  Synopsis:   Maps the file
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CFileMapView::Init()
{
    //
    //  Create a map of the file
    //
    _hMap = CreateFileMapping( _hFile,
                               0,
                               PAGE_READONLY,
                               0,
                               _cbBuffer,
                               0 );

    if ( 0 == _hMap )
    {
        qutilDebugOut(( DEB_IWARN, "CreateFileMapping failed\n" ));
        THROW( CException() );
    }

    _pbBuffer = (BYTE *) MapViewOfFile( _hMap,
                                        FILE_MAP_READ,
                                        0,
                                        0,
                                        _cbBuffer );

    if ( 0 == _pbBuffer )
    {
        qutilDebugOut(( DEB_IWARN, "MapViewOfFile failed\n" ));
        THROW( CException() );
    }

    _IsUnicode = (GetBufferSize() > 3) &&    // At least one unicode character
                 (_pbBuffer[0] == 0xFF) &&   // Begins with OxFF 0xFE
                 (_pbBuffer[1] == 0xFE) &&
                 ((GetBufferSize() & 1) == 0); // Must be an even # of bytes

}

//+---------------------------------------------------------------------------
//
//  Member:     CFileBuffer::CFileBuffer - public
//
//  Synopsis:   Constructor
//
//  Arguments:  [fileMap]  - a mapped file
//
//  History:    96/May/06   DwightKr    created
//
//----------------------------------------------------------------------------
CFileBuffer::CFileBuffer( CFileMapView & fileMap,
                          UINT codePage )
{
    //
    //  We need to return unicode data from methods of this class.  If the file
    //  contains ASCII data, convert it to unicode here.
    //

    if ( !fileMap.IsUnicode() )
    {
        _cwcFileBuffer = MultiByteToXArrayWideChar( fileMap.GetBuffer(),
                                                    fileMap.GetBufferSize(),
                                                   codePage,
                                                   _pwBuffer );

        _wcsNextLine   = _pwBuffer.Get();
    }
    else
    {
        //
        //  We have a unicode file.  Skip past the leading 0xFF - 0xFE bytes
        //
        _wcsNextLine   = (WCHAR *) (fileMap.GetBuffer() + 2);
        _cwcFileBuffer = (fileMap.GetBufferSize() - 2) / sizeof(WCHAR);
    }

    END_CONSTRUCTION(CFileBuffer);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileBuffer::fgetsw - public
//
//  Synopsis:   Gets the next line from the file
//
//  Arguments:  [wcsLine]  - buffer to return next line into
//              [cwcLine]  - size of the buffer in characters
//
//  History:    96/May/06   DwightKr    created
//
//----------------------------------------------------------------------------
ULONG CFileBuffer::fgetsw( XGrowable<WCHAR> & xLine )
{
    ULONG cwcCopied = 0;

    //
    //  Copy characters upto either cwcLine, a CR, or the end of
    //  the string.
    //

    while ( (_cwcFileBuffer > 0) )
    {
        xLine.SetSize( cwcCopied + 1 );
        xLine[ cwcCopied] = *_wcsNextLine;
        cwcCopied++;

        _wcsNextLine++;
        _cwcFileBuffer--;

        //
        //  If we just copied over a CR, then break out of the
        //  loop; we've found the end of a line.
        //

        if ( L'\n' == xLine[ cwcCopied - 1] )
        {
            break;
        }
    }

    xLine.SetSize( cwcCopied + 1 );
    xLine[ cwcCopied ] = 0;               // Null terminate

    return cwcCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\cphash.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1997 Microsoft Corporation.
//
//  File:       cphash.cxx
//
//  Contents:   Table that maps strings to codepages
//
//  Classes:    CCodePageTable
//
//  Note:       Derived from SitaramR's hash table
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cphash.hxx>

const ULONG CODE_JPN_JIS = 1;
const ULONG CODE_JPN_EUC = 2;

//
// Note: These must be all lowercase and kept in alphabetical order
//

const CCodePageEntry CCodePageTable::_aEntries[] =
{
    { L"ansi_x3.4-1968", 1252 },
    { L"ansi_x3.4-1986", 1252 },
    { L"ascii", 1252 },
    { L"big5", 950 },
    { L"chinese", 936 },
    { L"cp367", 1252 },
    { L"cp819", 1252 },
    { L"csascii", 1252 },
    { L"csbig5", 950 },
    { L"cseuckr", 949 },
    { L"cseucpkdfmtjapanese", CODE_JPN_EUC },
    { L"csgb2312", 936 },
    { L"csiso2022jp", CODE_JPN_JIS },
    { L"csiso2022kr", 50225 },
    { L"csiso58gb231280", 936 },
    { L"csisolatin2", 28592 },
    { L"csisolatinhebrew", 1255 },
    { L"cskoi8r", 20866 },
    { L"csksc56011987",  949 },
    { L"csshiftjis", 932 },
    { L"euc-kr", 949 },
    { L"extended_unix_code_packed_format_for_japanese", CODE_JPN_EUC },
    { L"gb2312", 936 },
    { L"gb_2312-80", 936 },
    { L"hebrew", 1255 },
    { L"hz-gb-2312", 936 },
    { L"ibm367", 1252 },
    { L"ibm819", 1252 },
    { L"ibm852", 852 },
    { L"ibm866", 866 },
    { L"iso-2022-jp", CODE_JPN_JIS },
    { L"iso-2022-kr", 50225 },
    { L"iso-8859-1", 1252 },
    { L"iso-8859-2", 28592 },
    { L"iso-8859-8", 1255 },
    { L"iso-ir-100", 1252 },
    { L"iso-ir-101", 28592 },
    { L"iso-ir-138", 1255 },
    { L"iso-ir-149", 949 },
    { L"iso-ir-58", 936 },
    { L"iso-ir-6", 1252 },
    { L"iso646-us", 1252 },
    { L"iso8859-1", 1252 },
    { L"iso8859-2", 28592 },
    { L"iso_646.irv:1991", 1252 },
    { L"iso_8859-1", 1252 },
    { L"iso_8859-1:1987", 1252 },
    { L"iso_8859-2", 28592 },
    { L"iso_8859-2:1987", 28592 },
    { L"iso_8859-8", 1255 },
    { L"iso_8859-8:1988", 1255 },
    { L"koi8-r", 20866 },
    { L"korean", 949 },
    { L"ks-c-5601", 949 },
    { L"ks-c-5601-1987", 949 },
    { L"ks_c_5601", 949 },
    { L"ks_c_5601-1987", 949 },
    { L"ks_c_5601-1989", 949 },
    { L"ksc-5601", 949 },
    { L"ksc5601", 949 },
    { L"ksc_5601", 949 },
    { L"l2", 28592 },
    { L"latin1", 1252 },
    { L"latin2", 28592 },
    { L"ms_kanji", 932 },
    { L"shift-jis", 932 },
    { L"shift_jis", 932 },
    { L"us", 1252 },
    { L"us-ascii", 1252 },
    { L"windows-1250", 1250 },
    { L"windows-1251", 1251 },
    { L"windows-1252", 1252 },
    { L"windows-1253", 1253 },
    { L"windows-1254", 1254 },
    { L"windows-1255", 1255 },
    { L"windows-1256", 1256 },
    { L"windows-1257", 1257 },
    { L"windows-1258", 1258 },
    { L"windows-874", 874 },
    { L"x-cp1250", 1250 },
    { L"x-cp1251", 1251 },
    { L"x-euc", CODE_JPN_EUC },
    { L"x-euc-jp", CODE_JPN_EUC },
    { L"x-sjis", 932 },
    { L"x-x-big5", 950 },
};

const unsigned CCodePageTable::_cEntries = sizeof CCodePageTable::_aEntries /
                                           sizeof CCodePageTable::_aEntries[0];

//+---------------------------------------------------------------------------
//
//  Method:     EntryCompare, private, static
//
//  Synposis:   Compares a string with a string in a CCodePageEntry.
//              Called by bsearch.
//
//  Arguments:  [pwcKey]    -- key for comparison
//              [pEntry]    -- entry for comparison
//
//  Returns:    < 0 if pwcKey < pEntry
//              0 if identical
//              > 0 if pwcKey > pEntry
//
//  History:    27-Aug-97   dlee Created
//
//----------------------------------------------------------------------------

int __cdecl CCodePageTable::EntryCompare(
    WCHAR const *          pwcKey,
    CCodePageEntry const * pEntry )
{
    return wcscmp( pwcKey, pEntry->pwcName );
} //EntryCompare

//+---------------------------------------------------------------------------
//
//  Method:     Lookup, public, static
//
//  Synposis:   Finds a codepage based on string and returns the codepage
//              The lookup is case-insensitive.
//
//  Arguments:  [pwcName]    -- not-necessarily null terminated string
//              [cwcName]    -- # of wide characters in pwcName
//              [ulCodePage] -- returns the corresponding codepage
//
//  Returns:    TRUE if the codepage name was found, FALSE otherwise
//
//  History:    27-Aug-97   dlee Created
//
//----------------------------------------------------------------------------

BOOL CCodePageTable::Lookup(
    WCHAR const * pwcName,
    unsigned      cwcName,
    ULONG &       ulCodePage )
{
    //
    // Limit the length of codepage strings
    //

    WCHAR awcLowcase[ 100 ];

    if ( cwcName >= ( sizeof awcLowcase / sizeof WCHAR ) )
        return FALSE;

    //
    // Convert the string to lowercase.
    //

    RtlCopyMemory( awcLowcase, pwcName, cwcName * sizeof WCHAR );
    awcLowcase[ cwcName ] = 0;
    _wcslwr( awcLowcase );

    //
    // Try to find the codepage using the C runtime binary search function
    //

    CCodePageEntry * pEntry = (CCodePageEntry *)
                              bsearch( awcLowcase,
                                       _aEntries,
                                       _cEntries,
                                       sizeof CCodePageEntry,
                                       (int (__cdecl *)(const void *, const void *) )
                                       EntryCompare );

    if ( 0 == pEntry )
        return FALSE;

    ulCodePage = pEntry->ulCodePage;
    return TRUE;
} //Lookup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\cpid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       cpid.cxx
//
//  Contents:   codepage functions
//
//  History:    97-Jun-09   t-elainc    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <gibralt.hxx>
#include <codepage.hxx>
#include <cphash.hxx>
#include <cpid.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   GetBrowserCodepage - public
//
//  Synposis:   returns the ULONG value of the codepage determined by the
//      query string
//
//  Arguments:  CWebServer & webServer, LCID locale
//
//  History:    97-Jun-09   t-elainc    Created
//
//----------------------------------------------------------------------------

ULONG GetBrowserCodepage( CWebServer & webServer, LCID locale )
{
    ULONG cpval=0;

    //first get value of CICodepage specified in the query string
    CHAR acCPString[20];

    //if a codepage string is specified
    if ( GetCodepageValue( webServer, acCPString, sizeof(acCPString) ) )
    {
        WCHAR awcCPString[100];
        unsigned int ccString = strlen( acCPString ) + 1;
        unsigned int numconverted = MultiByteToWideChar(CP_ACP, 0, acCPString, ccString, awcCPString, 100);

        //make sure everything was converted properly. Otherwise throw an exception
        if (ccString != numconverted)
        {
            THROW ( CException () );
        }

        //Check to see if the string is one of the values in the code page hash table
        BOOL valid = CCodePageTable::Lookup(awcCPString, wcslen(awcCPString), cpval);

        //code page string is not in the hash table
        if (!valid)
        {
            CHAR* pctmp;
            cpval = strtoul(acCPString, &pctmp, 10);

            //if the codepage value is not a number
            if (!cpval)
            {
                LCID lcid = GetLCIDFromString(awcCPString);

                //if the codepage value is not a legitimate lcid
                if (InvalidLCID == lcid)
                {
                    THROW ( CException (QUTIL_E_INVALID_CODEPAGE) );
                }

                //use the locale to determine the proper codepage
                cpval = LocaleToCodepage(lcid);
            }
        }
    }

    else //no codepage string specified, use locale to determine proper codepage
    {
        //ciGibDebugOut((DEB_ITRACE, "No codepage specified.  Using default codepage by locale."));
        cpval = LocaleToCodepage(locale);
    }

    return cpval;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCodePageValue
//
//  Synposis:   Returns the string contained withing the Query String that
//              specifies the codepage.  If no string is there, returns 0.
//
//  Arguments:  [webServer]  -- Web server
//              [pcCPString] -- String containing CiCodepage returned here
//              [ccCPString] -- Size (in chars) of [pcCPString]
//
//  Returns:    TRUE if a codepage parameter was found and fits in buffer.
//
//  History:    97-Jun-11   t-elainc    Created
//
//----------------------------------------------------------------------------

BOOL GetCodepageValue( CWebServer & webServer,
                       char * pcCPString,
                       unsigned ccCPString )
{
    unsigned ccValue = 0xFFFFFFFF;
    char* ISAPI_CI_CODEPAGE_A = "CICODEPAGE";

        char const * pcStart = webServer.GetQueryString();

    while ( 0 != pcStart && 0 != pcStart[0] )
    {
        if ( 0 == _strnicmp( pcStart,
                             ISAPI_CI_CODEPAGE_A,
                             strlen(ISAPI_CI_CODEPAGE_A) ) &&
             '=' == pcStart[strlen(ISAPI_CI_CODEPAGE_A)] )
            break;

        pcStart = strchr( pcStart, '&' );

        if ( 0 != pcStart )
            pcStart++;
    }

    if ( 0 != pcStart && 0 != pcStart[0] )
    {
        pcStart += strlen(ISAPI_CI_CODEPAGE_A)+1;  // sizeof includes null

        char* pcEnd = strchr(pcStart, '&');

        if (pcEnd)
            ccValue = CiPtrToUint( pcEnd - pcStart );
        else
            ccValue = strlen( pcStart );

        if ( ccValue < ccCPString )
        {
            strncpy( pcCPString, pcStart, ccValue );
            pcCPString[ccValue] = 0;
        }
    }

    return (ccValue < ccCPString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\gibralt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:   gibralt.cxx
//
//  Contents:   Abstraction of the interface to gibraltar
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <gibralt.hxx>
#include <cgiesc.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetPhysicalPath - public
//
//  Synopsis:   Converts a virtual path to a physical path
//
//  Arguments:  [wcsVirtualPath]  - virtual path to convert
//              [wcsPhysicalPath] - resulting physical path
//              [cwcPhysicalPath] - length of string
//              [dwAccessMask]    - HSE_URL_FLAGS_* required,
//                                  or 0 for any access
//
//  Returns:    Flags for the virtual path (HSE_URL_FLAGS_*)
//
//  History:    96/Feb/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
DWORD CWebServer::GetPhysicalPath(
    WCHAR const * wcsVirtualPath,
    WCHAR *       wcsPhysicalPath,
    ULONG         cwcPhysicalPath,
    DWORD         dwAccessMask )
{
    Win4Assert( 0 != wcsVirtualPath );

    ULONG cwcVirtualPath = wcslen( wcsVirtualPath ) + 1;

    //
    // We only support paths up to MAX_PATH for now
    //

    if ( cwcVirtualPath >= ( MAX_PATH - 1 ) )
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );

    CHAR  pszVirtualPath[_MAX_PATH];
    ULONG cbVirtualPath = _MAX_PATH;

    ULONG cbConverted = ::WideCharToMultiByte( _codePage,
                                               WC_COMPOSITECHECK,
                                               wcsVirtualPath,
                                               cwcVirtualPath,
                                     (CHAR *)  pszVirtualPath,
                                               cbVirtualPath,
                                               NULL,
                                               NULL );

    HSE_URL_MAPEX_INFO MapInfo;
    DWORD cbMappedPath = sizeof pszVirtualPath;

    //
    // Note: if the mapped path is >= MAX_PATH the function succeeds and
    // truncates the physical path without null-terminating it.  But
    // the mapped size is > MAX_PATH, so key off that to check for overflow.
    //

    if ( (0 == cbConverted) ||
         ( !_pEcb->ServerSupportFunction( _pEcb->ConnID,
                                          HSE_REQ_MAP_URL_TO_PATH_EX,
                                          pszVirtualPath,
                                          &cbMappedPath,
                                          (PDWORD) &MapInfo ) ) ||
         ( cbMappedPath >= ( _MAX_PATH - 1 ) ) ||
         ( ( 0 != dwAccessMask ) &&
           (  0 == ( dwAccessMask & MapInfo.dwFlags ) ) )
       )
    {
        //
        // We could not translate the virtual path to a real path,
        // or the access permissions didn't match, so this must be a
        // bogus virtual path.
        //

        qutilDebugOut(( DEB_ERROR,
                        "Could not translate vpath=>ppath, mask 0x%x, flags 0x%x, '%ws'\n",
                        dwAccessMask, MapInfo.dwFlags, wcsVirtualPath ));
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );
    }

    if ( 0 == MultiByteToWideChar( _codePage,
                                   0,
                                   MapInfo.lpszPath,
                                   strlen( MapInfo.lpszPath) + 1,
                                   wcsPhysicalPath,
                                   cwcPhysicalPath) )
    {
        //
        //  We could not translate the ASCII string to WCHAR
        //

        qutilDebugOut(( DEB_ERROR,
                        "Gibraltar could not convert ppath to unicode '%ws'\n",
                        wcsVirtualPath ));
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );
    }

    return MapInfo.dwFlags;
} //GetPhysicalPath

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetCGIVariable - public
//
//  Synopsis:   Gets the CHAR version of a CGI variable
//
//  Arguments:  [pszVariableName] - name of variable to lookup
//              [wcsValue]        - resulting variable
//              [cwcValue]        - length of variable
//
//  History:    96/Feb/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CWebServer::GetCGIVariable( CHAR const * pszVariableName,
                                 XArray<WCHAR> & wcsValue,
                                 ULONG & cwcValue )
{
    Win4Assert ( IsValid() );

    BYTE pbBuffer[512];
    ULONG cbBuffer = sizeof( pbBuffer );

    if ( !_pEcb->GetServerVariable( _pEcb->ConnID,
                          (char *)  pszVariableName,
                                    pbBuffer,
                                   &cbBuffer ) )
    {
        return FALSE;
    }

    cwcValue = MultiByteToXArrayWideChar(
                          (BYTE * const) pbBuffer,
                                         cbBuffer,
                                         _codePage,
                                         wcsValue );

    return cwcValue > 0;
} //GetCGIVariable

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetCGIVariable - public
//
//  Synopsis:   Gets the WCHAR version of a CGI variable
//
//  Arguments:  [wcsVariableName] - name of variable to lookup
//              [wcsValue]        - resulting variable
//              [cwcValue]        - length of variable (out only)
//
//  History:    96/Mar/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CWebServer::GetCGIVariableW( WCHAR const * wcsVariableName,
                                  XArray<WCHAR> & wcsValue,
                                  ULONG & cwcBuffer )
{
    ULONG cwcVariableName = wcslen( wcsVariableName ) + 1;
    XArray<BYTE> pszVariableName( cwcVariableName*2 );

    if ( 0 == WideCharToXArrayMultiByte( wcsVariableName,
                                         cwcVariableName,
                                         _codePage,
                                         pszVariableName )
       )
    {
        //
        //  We could not translate the WCHAR string to ASCII
        //

        return FALSE;
    }

    return GetCGIVariable( (const char *) pszVariableName.GetPointer(),
                           wcsValue,
                           cwcBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\doquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       DOQUERY.CXX
//
//  Contents:   Functions to make query nodes and trees, and to execute
//              queries.
//
//  History:    02 Nov 94   alanw     Created from main.cxx and screen.cxx.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doquery.hxx>
#include <catstate.hxx>

static const GUID guidBmk =       DBBMKGUID;

static const GUID psGuidStorage = PSGUID_STORAGE;

static const GUID psGuidQuery = DBQUERYGUID;

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowset = DBPROPSET_ROWSET;

static CDbColId psRank( psGuidQuery, DISPID_QUERY_RANK );
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );
static CDbColId psPath( psGuidStorage, PID_STG_PATH );

//+---------------------------------------------------------------------------
//
//  Function:   FormTableNode
//
//  Synopsis:   Forms a selection node and if needed a sort node
//
//  Arguments:  [rst]    - Restriction tree describing the query
//              [states] - global state info
//              [plist]  - friendly property name list
//
//  Returns:    A pointer to a commandtree node
//
//  History:    9-4-95   SitaramR   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode *FormTableNode(
    CDbCmdTreeNode & rst,
    CCatState &      states,
    IColumnMapper *  plist )
{
    //
    // First create a selection node and append the restriction tree to it
    //
    XPtr<CDbSelectNode> xSelect( new CDbSelectNode() );

    if ( xSelect.IsNull() || !xSelect->IsValid() )
        THROW( CException( STATUS_NO_MEMORY ) );

    //
    // Clone the restriction and use it.
    //
    CDbCmdTreeNode * pExpr = rst.Clone();
    if ( 0 == pExpr )
    {
        THROW( CException( STATUS_NO_MEMORY ) );
    }

    //
    // Now make the restriction a child of the selection node.
    //
    xSelect->SetRestriction( pExpr );

    XPtr<CDbCmdTreeNode> xTable;

    unsigned int cSortProp = states.NumberOfSortProps();
    if ( cSortProp > 0 )
    {
        CDbSortNode * pSort = new CDbSortNode();
        if ( 0 == pSort )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        XPtr<CDbCmdTreeNode> xSort( pSort );

        for( unsigned i = 0; i < cSortProp; i++ )
        {
            WCHAR const * wcsName;
            SORTDIR sd;

            states.GetSortProp( i,
                                &wcsName,
                                &sd );

            DBID *pdbid = 0;
            if( FAILED(plist->GetPropInfoFromName( wcsName,
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_SORT ) );

            //
            // Add the sort column.
            //
            CDbColId *pprop = (CDbColId *)pdbid;
            if ( !pSort->AddSortColumn( *pprop,
                                        (sd == SORT_DOWN) ? TRUE : FALSE,
                                        states.GetLocale()))
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( pSort->AddTable( xSelect.GetPointer() ) )
            xSelect.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        xTable.Set( xSort.Acquire() );
    }
    else
        xTable.Set( xSelect.Acquire() );

    return xTable.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              selection node, sort node(s) and the restriction tree.
//
//  Arguments:  [rst]    - Restriction tree describing the query
//              [states] - global state info
//              [plist]  - friendly property name list
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    6-20-95   srikants   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode & rst,
                                CCatState & states,
                                IColumnMapper * plist,
                                BOOL fAddBmkCol,
                                BOOL fAddRankForBrowse )
{
    CDbCmdTreeNode *pTable = FormTableNode( rst, states, plist );
    XPtr<CDbCmdTreeNode> xTable( pTable );

    XPtr<CDbCmdTreeNode> xQuery;

    unsigned cCategories = states.NumberOfCategories();
    if ( cCategories > 0 )
    {
        //
        // First create nesting node for the base table
        //
        CDbNestingNode *pNestNodeBase = new CDbNestingNode;
        if ( pNestNodeBase == 0 )
            THROW ( CException( STATUS_NO_MEMORY ) );

        XPtr<CDbCmdTreeNode> xNestNodeBase( pNestNodeBase );

        BOOL fNeedPath = TRUE;
        BOOL fNeedRank = fAddRankForBrowse;

        //
        // Next add all the columns in the state.
        //
        CDbColId * pprop = 0;
        DBID *pdbid = 0;

        unsigned int cCol = states.NumberOfColumns();
        for ( unsigned int i = 0; i < cCol; i++ )
        {
            if( FAILED(plist->GetPropInfoFromName( states.GetColumn( i ),
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

            pprop = (CDbColId *)pdbid;
            if ( *pprop == psPath )
            {
                fNeedPath = FALSE;
            }
            else if ( *pprop == psRank )
            {
                fNeedRank = FALSE;
            }

            if ( !pNestNodeBase->AddChildColumn( *pprop ) )
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( fNeedPath && !pNestNodeBase->AddChildColumn( psPath ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( fNeedRank && !pNestNodeBase->AddChildColumn( psRank ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        //
        // Add categories to the output column
        //
        for ( i = 0; i < cCategories; i++ )
        {
            //
            // We need to ensure that we don't add categories that have already been
            // added above. The following test can be speeded up from O( i*j ) to O( i+j ),
            // but the the number of categories and the number of columns are usually very small.
            //
            BOOL fFound = FALSE;
            for ( unsigned j=0; j<states.NumberOfColumns(); j++ )
            {
                if ( _wcsicmp( states.GetCategory(i), states.GetColumn( j ) ) == 0 )
                {
                    fFound = TRUE;
                    break;
                }
            }

            if ( !fFound )
            {
                if( FAILED(plist->GetPropInfoFromName( states.GetCategory( i ),
                                        &pdbid,
                                        0,
                                        0 )) )
                    THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_CATEGORIZATION ) );

                pprop = (CDbColId *)pdbid;
                if ( !pNestNodeBase->AddChildColumn( *pprop ) )
                    THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( pNestNodeBase->AddTable( xTable.GetPointer() ) )
            xTable.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( FAILED(plist->GetPropInfoFromName( states.GetCategory( cCategories - 1 ),
                                 &pdbid,
                                 0,
                                 0 )) )
            THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

        pprop = (CDbColId *)pdbid;
        if ( !pNestNodeBase->AddGroupingColumn( *pprop ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        if ( !pNestNodeBase->AddParentColumn( *pprop ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        if ( !pNestNodeBase->AddParentColumn( psBookmark ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        //
        // Now create the nesting nodes for remaining categories, if any
        //
        XPtr<CDbCmdTreeNode> xCategChild( xNestNodeBase.Acquire() );

        for ( int j=cCategories-2; j>=0; j-- )
        {
            if ( FAILED(plist->GetPropInfoFromName( states.GetCategory( j ),
                                     &pdbid,
                                     0,
                                     0 )) )
            {
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );
            }

            pprop = (CDbColId *)pdbid;
            CDbNestingNode *pCategParent = new CDbNestingNode;
            if ( pCategParent == 0 )
                THROW( CException( STATUS_NO_MEMORY ) );

            XPtr<CDbCmdTreeNode> xCategParent( pCategParent );

            if ( pCategParent->AddTable( xCategChild.GetPointer() ) )
                xCategChild.Acquire();
            else
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }

            if ( !pCategParent->AddGroupingColumn( *pprop ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            if ( !pCategParent->AddParentColumn( *pprop ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            if ( !pCategParent->AddParentColumn( psBookmark ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            xCategChild.Set( xCategParent.Acquire() );
        }

        xQuery.Set( xCategChild.Acquire() );
    }
    else
    {
        //
        // Create the projection node
        //
        CDbProjectNode * pProject = new CDbProjectNode();
        if ( 0 == pProject )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        XPtr<CDbCmdTreeNode> xProject( pProject );

        //
        // Add the selection/sort node
        //
        if ( pProject->AddTable( xTable.GetPointer() ) )
            xTable.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        //
        // We query with two additional, but hidden, columns: path and rank,
        // because this information is needed by the browser (via Clipboard).
        // Care is taken in CRows::DisplayHeader and CRows::DisplayRows so that
        // the hidden columns are not displayed to the user
        //

        BOOL fNeedPath = TRUE;
        BOOL fNeedRank = fAddRankForBrowse;

        //
        // Next add all the columns in the state.
        //
        unsigned int cCol = states.NumberOfColumns();

        for ( unsigned int i = 0; i < cCol; i++ )
        {
            CDbColId * pprop = 0;
            DBID *pdbid = 0;

            if( FAILED(plist->GetPropInfoFromName( states.GetColumn( i ),
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

            pprop = (CDbColId *)pdbid;
            if ( *pprop == psPath )
            {
                fNeedPath = FALSE;
            }
            else if ( *pprop == psRank )
            {
                fNeedRank = FALSE;
            }

            if ( !pProject->AddProjectColumn( *pprop ) )
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }


        if ( fNeedPath && !pProject->AddProjectColumn( psPath ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( fNeedRank && !pProject->AddProjectColumn( psRank ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if (fAddBmkCol &&  !pProject->AddProjectColumn( psBookmark ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        xQuery.Set( xProject.Acquire() );
    }

    CDbTopNode *pTop = 0;

    if ( states.IsMaxResultsSpecified() )
    {
        //
        // Use the top node to set a cap on the number of query results
        //
        pTop = new CDbTopNode();
        if ( pTop == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        pTop->SetChild( xQuery.Acquire() );
        pTop->SetValue( states.GetMaxResults() );
    }

    //
    //  Set FirstRows here
    //
    if ( states.IsFirstRowsSpecified() )
    {
        CDbFirstRowsNode *pFR = new CDbFirstRowsNode();
        if ( pFR == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        CDbCmdTreeNode *pChild = pTop ? pTop : xQuery.Acquire();
        pFR->SetChild( pChild );
        pFR->SetValue( states.GetFirstRows() );

        return pFR;
    }  

    if ( 0 != pTop )
        return pTop;
        
    return xQuery.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetScopePropertiesNoThrow
//
//  Synopsis:   Sets rowset properties pertaining to scope on command object.
//
//  Arguments:  [pCmd]       -- Command object
//              [cDirs]      -- Number of elements in following arrays
//              [apDirs]     -- Array of scopes
//              [aulFlags]   -- Array of flags (depths)
//              [apCats]     -- Array of catalogs
//              [apMachines] -- Array of machines
//
//  Notes:      Either apDirs and aulFlags, or apCats and apMachines may be
//              NULL.
//
//  History:    03-Mar-1997    KyleP     Created
//              14-May-1997    mohamedn  use real BSTRs
//              19-May-1997    KrishnaN  Not throwing exceptions.
//
//----------------------------------------------------------------------------

SCODE SetScopePropertiesNoThrow( ICommand * pCmd,
                                unsigned cDirs,
                                WCHAR const * const * apDirs,
                                ULONG const *  aulFlags,
                                WCHAR const * const * apCats,
                                WCHAR const * const * apMachines )
{
    SCODE sc = S_OK;

    TRY
    {
        XInterface<ICommandProperties> xCmdProp;

        sc = pCmd->QueryInterface( IID_ICommandProperties, xCmdProp.GetQIPointer() );

        if ( FAILED( sc ) )
            return sc;

        //
        // It's expensive to convert all of these to BSTRs, but we have
        // to since our public API just takes regular strings.
        //

        CDynArrayInPlace<XBStr> aMachines(cDirs);
        CDynArrayInPlace<XBStr> aCatalogs(cDirs);
        CDynArrayInPlace<XBStr> aScopes(cDirs);
        unsigned i;

        //
        // init array of BSTRs of machines
        //

        if ( 0 != apMachines)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apMachines[i]);
                aMachines.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        //
        // init array of BSTRs of catalogs
        //
        if ( 0 != apCats)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apCats[i]);
                aCatalogs.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        //
        // init array of BSTRs of scopes
        //
        if ( 0 != apDirs)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apDirs[i]);
                aScopes.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        SAFEARRAY saScope = { 1,                            // Dimension
                              FADF_AUTO | FADF_BSTR,        // Flags: on stack, contains BSTRs
                              sizeof(BSTR),                 // Size of an element
                              1,                            // Lock count.  1 for safety.
                              (void *) aScopes.GetPointer(),// The data
                              { cDirs, 0 } };               // Bounds (element count, low bound)

        SAFEARRAY saDepth = { 1,                            // Dimension
                              FADF_AUTO,                    // Flags: on stack
                              sizeof(LONG),                 // Size of an element
                              1,                            // Lock count.  1 for safety.
                              (void *)aulFlags,             // The data
                              { cDirs, 0 } };               // Bounds (element count, low bound)

        SAFEARRAY saCatalog = { 1,                          // Dimension
                                FADF_AUTO | FADF_BSTR,      // Flags: on stack, contains BSTRs
                                sizeof(BSTR),               // Size of an element
                                1,                          // Lock count.  1 for safety.
                                (void *) aCatalogs.GetPointer(), // The data
                                { cDirs, 0 } };             // Bounds (element count, low bound)

        SAFEARRAY saMachine = { 1,                          // Dimension
                                FADF_AUTO | FADF_BSTR,      // Flags: on stack, contains BSTRs
                                sizeof(BSTR),               // Size of an element
                                1,                          // Lock count.  1 for safety.
                                (void *) aMachines.GetPointer(), // The data
                                { cDirs, 0 } };             // Bounds (element count, low bound)


        DBPROP    aScopeProps[2] = {
                        { DBPROP_CI_INCLUDE_SCOPES ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saScope } },
                        { DBPROP_CI_DEPTHS         ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saDepth } } };

        DBPROP    aCatalogProps[1]  = {
                        { DBPROP_CI_CATALOG_NAME   ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saCatalog } } };


        DBPROP    aMachineProps[1]  = {
                        { DBPROP_MACHINE           ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saMachine } } };

        DBPROPSET aAllPropsets[3] = {
                      { aScopeProps,   2, DBPROPSET_FSCIFRMWRK_EXT   } ,
                      { aCatalogProps, 1, DBPROPSET_FSCIFRMWRK_EXT   } ,
                      { aMachineProps, 1, DBPROPSET_CIFRMWRKCORE_EXT } };

        DBPROPSET * pPropsets = 0;
        ULONG cPropsets = 0;

        if ( 0 != apDirs )
        {
            pPropsets = &aAllPropsets[0];
            cPropsets = 1;
        }
        else
        {
            pPropsets = &aAllPropsets[1];
        }


        if ( 0 != apCats && 0 != apMachines )
        {
            cPropsets += 2;
        }

        sc = xCmdProp->SetProperties( cPropsets, pPropsets );
    }
    CATCH(CException, e)
    {
        sc = GetOleError(e);
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetScopeProperties
//
//  Synopsis:   Sets rowset properties pertaining to scope on command object.
//
//  Arguments:  [pCmd]       -- Command object
//              [cDirs]      -- Number of elements in following arrays
//              [apDirs]     -- Array of scopes
//              [aulFlags]   -- Array of flags (depths)
//              [apCats]     -- Array of catalogs
//              [apMachines] -- Array of machines
//
//  History:    03-Mar-1997    KyleP     Created
//
//----------------------------------------------------------------------------

void SetScopeProperties( ICommand * pCmd,
                         unsigned cDirs,
                         WCHAR const * const * apDirs,
                         ULONG const *  aulFlags,
                         WCHAR const * const * apCats,
                         WCHAR const * const * apMachines )
{
    SCODE sc = SetScopePropertiesNoThrow(pCmd, cDirs, apDirs,
                                         aulFlags, apCats, apMachines);

    if (FAILED(sc))
        THROW( CException(sc) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\htmlchar.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       htmlchar.cxx
//
//  Contents:   Contains a translate table from WCHAR to HTML WCHAR
//              Translates an WCHAR string to its HTML equivalent
//
//  History:    96/Jan/3    DwightKr    Created
//              19 Nov 1997 AlanW       Added missing named entities.  Allow
//                                      for outputing numeric entities if
//                                      codepage translation fails.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlchar.hxx>

struct WCHAR_TO_HTML
{
    WCHAR * wszTranslated;
    ULONG   cchTranslated;
};

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
static const struct WCHAR_TO_HTML WCHAR_TO_HTML[] =
{
   L"never",           0xffffffff,        //   0  end-of-string
    0,                          0,        //   1
    0,                          0,        //   2
    0,                          0,        //   3
    0,                          0,        //   4
    0,                          0,        //   5
    0,                          0,        //   6
    0,                          0,        //   7
    0,                          0,        //   8
   L"\t",                       1,        //   9  tab
   L"\n",                       1,        //  10  newline
    0,                          0,        //  11
    0,                          0,        //  12
   L"\r",                       1,        //  13  carriage return
    0,                          0,        //  14
    0,                          0,        //  15
    0,                          0,        //  16
    0,                          0,        //  17
    0,                          0,        //  18
    0,                          0,        //  19
    0,                          0,        //  20
    0,                          0,        //  21
    0,                          0,        //  22
    0,                          0,        //  23
    0,                          0,        //  24
    0,                          0,        //  25
    0,                          0,        //  26
    0,                          0,        //  27
    0,                          0,        //  28
    0,                          0,        //  29
    0,                          0,        //  30
    0,                          0,        //  31
   L" ",                        1,        //  32
   L"!",                        1,        //  33
   L"&quot;",                   6,        //  34
   L"#",                        1,        //  35
   L"$",                        1,        //  36
   L"%",                        1,        //  37
   L"&amp;",                    5,        //  38
   L"'",                        1,        //  39
   L"(",                        1,        //  40
   L")",                        1,        //  41
   L"*",                        1,        //  42
   L"+",                        1,        //  43
   L",",                        1,        //  44
   L"-",                        1,        //  45
   L".",                        1,        //  46
   L"/",                        1,        //  47
   L"0",                        1,        //  48
   L"1",                        1,        //  49
   L"2",                        1,        //  50
   L"3",                        1,        //  51
   L"4",                        1,        //  52
   L"5",                        1,        //  53
   L"6",                        1,        //  54
   L"7",                        1,        //  55
   L"8",                        1,        //  56
   L"9",                        1,        //  57
   L":",                        1,        //  58
   L";",                        1,        //  59
   L"&lt;",                     4,        //  60
   L"=",                        1,        //  61
   L"&gt;",                     4,        //  62
   L"?",                        1,        //  63
   L"@",                        1,        //  64
   L"A",                        1,        //  65
   L"B",                        1,        //  66
   L"C",                        1,        //  67
   L"D",                        1,        //  68
   L"E",                        1,        //  69
   L"F",                        1,        //  70
   L"G",                        1,        //  71
   L"H",                        1,        //  72
   L"I",                        1,        //  73
   L"J",                        1,        //  74
   L"K",                        1,        //  75
   L"L",                        1,        //  76
   L"M",                        1,        //  77
   L"N",                        1,        //  78
   L"O",                        1,        //  79
   L"P",                        1,        //  80
   L"Q",                        1,        //  81
   L"R",                        1,        //  82
   L"S",                        1,        //  83
   L"T",                        1,        //  84
   L"U",                        1,        //  85
   L"V",                        1,        //  86
   L"W",                        1,        //  87
   L"X",                        1,        //  88
   L"Y",                        1,        //  89
   L"Z",                        1,        //  90
   L"[",                        1,        //  91
   L"\\",                       1,        //  92
   L"]",                        1,        //  93
   L"^",                        1,        //  94
   L"_",                        1,        //  95
   L"`",                        1,        //  96
   L"a",                        1,        //  97
   L"b",                        1,        //  98
   L"c",                        1,        //  99
   L"d",                        1,        // 100
   L"e",                        1,        // 101
   L"f",                        1,        // 102
   L"g",                        1,        // 103
   L"h",                        1,        // 104
   L"i",                        1,        // 105
   L"j",                        1,        // 106
   L"k",                        1,        // 107
   L"l",                        1,        // 108
   L"m",                        1,        // 109
   L"n",                        1,        // 110
   L"o",                        1,        // 111
   L"p",                        1,        // 112
   L"q",                        1,        // 113
   L"r",                        1,        // 114
   L"s",                        1,        // 115
   L"t",                        1,        // 116
   L"u",                        1,        // 117
   L"v",                        1,        // 118
   L"w",                        1,        // 119
   L"x",                        1,        // 120
   L"y",                        1,        // 121
   L"z",                        1,        // 122
   L"{",                        1,        // 123
   L"|",                        1,        // 124
   L"}",                        1,        // 125
   L"~",                        1,        // 126
     0,                         0,        // 127
     0,                         0,        // 128
     0,                         0,        // 129
     0,                         0,        // 130
     0,                         0,        // 131
     0,                         0,        // 132
     0,                         0,        // 133
     0,                         0,        // 134
     0,                         0,        // 135
     0,                         0,        // 136
     0,                         0,        // 137
     0,                         0,        // 138
     0,                         0,        // 139
     0,                         0,        // 140
     0,                         0,        // 141
     0,                         0,        // 142
     0,                         0,        // 143
     0,                         0,        // 144
     0,                         0,        // 145
     0,                         0,        // 146
     0,                         0,        // 147
     0,                         0,        // 148
     0,                         0,        // 149
     0,                         0,        // 150
     0,                         0,        // 151
     0,                         0,        // 152
     0,                         0,        // 153
     0,                         0,        // 154
     0,                         0,        // 155
     0,                         0,        // 156
     0,                         0,        // 157
     0,                         0,        // 158
     0,                         0,        // 159
   L"&nbsp;",                   6,        // 160
   L"&iexcl;",                  7,        // 161
   L"&cent;",                   6,        // 162
   L"&pound;",                  7,        // 163
   L"&curren;",                 8,        // 164
   L"&yen;",                    5,        // 165
   L"&brvbar;",                 8,        // 166
   L"&sect;",                   6,        // 167
   L"&uml;",                    5,        // 168
   L"&copy;",                   6,        // 169
   L"&ordf;",                   6,        // 170 - feminine ordinal indicator
   L"&laquo;",                  7,        // 171
   L"&not;",                    5,        // 172 - not sign
   L"&shy;",                    5,        // 173 - soft hyphen
   L"&reg;",                    5,        // 174
   L"&macr;",                   6,        // 175
   L"&deg;",                    5,        // 176
   L"&plusmn;",                 8,        // 177
   L"&sup2;",                   6,        // 178
   L"&sup3;",                   6,        // 179
   L"&acute;",                  7,        // 180
   L"&micro;",                  7,        // 181
   L"&para;",                   6,        // 182
   L"&middot;",                 8,        // 183
   L"&cedil;",                  7,        // 184
   L"&sup1;",                   6,        // 185
   L"&ordm;",                   6,        // 186 - masculine ordinal indicator
   L"&raquo;",                  7,        // 187
   L"&frac14;",                 8,        // 188
   L"&frac12;",                 8,        // 189
   L"&frac34;",                 8,        // 190
   L"&iquest;",                 8,        // 191
   L"&Agrave;",                 8,        // 192
   L"&Aacute;",                 8,        // 193
   L"&Acirc;",                  7,        // 194
   L"&Atilde;",                 8,        // 195
   L"&Auml;",                   6,        // 196
   L"&Aring;",                  7,        // 197
   L"&AElig;",                  7,        // 198
   L"&Ccedil;",                 8,        // 199
   L"&Egrave;",                 8,        // 200
   L"&Eacute;",                 8,        // 201
   L"&Ecirc;",                  7,        // 202
   L"&Euml;",                   6,        // 203
   L"&Igrave;",                 8,        // 204
   L"&Iacute;",                 8,        // 205
   L"&Icirc;",                  7,        // 206
   L"&Iuml;",                   6,        // 207
   L"&ETH;",                    5,        // 208
   L"&Ntilde;",                 8,        // 209
   L"&Ograve;",                 8,        // 210
   L"&Oacute;",                 8,        // 211
   L"&Ocirc;",                  7,        // 212
   L"&Otilde;",                 8,        // 213
   L"&Ouml;",                   6,        // 214
   L"&times;",                  7,        // 215
   L"&Oslash;",                 8,        // 216
   L"&Ugrave;",                 8,        // 217
   L"&Uacute;",                 8,        // 218
   L"&Ucirc;",                  7,        // 219
   L"&Uuml;",                   6,        // 220
   L"&Yacute;",                 8,        // 221
   L"&THORN;",                  7,        // 222
   L"&szlig;",                  7,        // 223
   L"&agrave;",                 8,        // 224
   L"&aacute;",                 8,        // 225
   L"&acirc;",                  7,        // 226
   L"&atilde;",                 8,        // 227
   L"&auml;",                   6,        // 228
   L"&aring;",                  7,        // 229
   L"&aelig;",                  7,        // 230
   L"&ccedil;",                 8,        // 231
   L"&egrave;",                 8,        // 232
   L"&eacute;",                 8,        // 233
   L"&ecirc;",                  7,        // 234
   L"&euml;",                   6,        // 235
   L"&igrave;",                 8,        // 236
   L"&iacute;",                 8,        // 237
   L"&icirc;",                  7,        // 238
   L"&iuml;",                   6,        // 239
   L"&eth;",                    5,        // 240
   L"&ntilde;",                 8,        // 241
   L"&ograve;",                 8,        // 242
   L"&oacute;",                 8,        // 243
   L"&ocirc;",                  7,        // 244
   L"&otilde;",                 8,        // 245
   L"&ouml;",                   6,        // 246
   L"&divide;",                 8,        // 247
   L"&oslash;",                 8,        // 248
   L"&ugrave;",                 8,        // 249
   L"&uacute;",                 8,        // 250
   L"&ucirc;",                  7,        // 251
   L"&uuml;",                   6,        // 252
   L"&yacute;",                 8,        // 253
   L"&thorn;",                  7,        // 254
   L"&yuml;",                   6,        // 255
};

//+---------------------------------------------------------------------------
//
//  Function:   HTMLEscapeW, public
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//
//  Arguments:  [wcsString] - string to be translated
//              [StrResult] - CVirtualString to which result will be appended
//              [ulCodePage] - output codepage
//
//  History:    96/Apr/03   dlee    Created.
//
//----------------------------------------------------------------------------

void HTMLEscapeW( WCHAR const * wcsString,
                  CVirtualString & StrResult,
                  ULONG ulCodePage )
{
    unsigned iUnicodeOutputMethod = 0;

    do
    {
        if ( *wcsString < 256 )
        {
            const struct WCHAR_TO_HTML &Entry = WCHAR_TO_HTML[*wcsString];

            if ( 1 == Entry.cchTranslated )
            {
                StrResult.CharCat( *Entry.wszTranslated );
                wcsString++;
                continue;
            }

            // Do the check for end-of-string here, as this is an
            // unusual code-path.  This saves a compare per loop.

            if ( 0 == *wcsString )
                break;

            // it's ok to pass 0 to StrCat

            StrResult.StrCat( Entry.wszTranslated,
                              Entry.cchTranslated );
        }
        else
        {
            //
            //  A unicode character >= 256 has been found.  Either leave it
            //  as-is in the output string, or convert to the numeric HTML
            //  entity, depending on whether all unicode characters in the
            //  string can be translated using the codepage.
            //
            if ( 0 == iUnicodeOutputMethod )
            {
                iUnicodeOutputMethod++;
                
                BOOL fUsedDefaultChar = FALSE;
                int cchOut = WideCharToMultiByte( ulCodePage,
#if (WINVER >= 0x0500)
                                                  WC_NO_BEST_FIT_CHARS |
#endif // (WINVER >= 0x0500)
                                                    WC_COMPOSITECHECK |
                                                    WC_DEFAULTCHAR,
                                                  wcsString,
                                                  -1,
                                                  0,
                                                  0,
                                                  0,
                                                  &fUsedDefaultChar );
                Win4Assert( cchOut != 0 ||
                            ERROR_INVALID_PARAMETER == GetLastError() );

                if ( fUsedDefaultChar ||
                     cchOut == 0 && ERROR_INVALID_PARAMETER == GetLastError() )
                    iUnicodeOutputMethod++;
            }

            if ( 1 == iUnicodeOutputMethod )
            {
                StrResult.CharCat( *wcsString );
            }
            else
            {
                Win4Assert( 2 == iUnicodeOutputMethod );

                // Output the numeric html entity
                USHORT wch = *wcsString;
                WCHAR achNum[6];
                _itow( wch, achNum, 10 );
                StrResult.CharCat( L'&' );
                StrResult.CharCat( L'#' );
                StrResult.StrCat( achNum );
                StrResult.CharCat( L';' );
            }
        }

        wcsString++;
    } while( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\mbutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       mbutil.cxx
//
//  Contents:   MultiByte To Unicode and ViceVersa utility functions and
//              classes.
//
//  History:    96/Jan/3    DwightKr    Created
//              Aug 20 1996 Srikants    Moved from escurl.hxx to this file
//
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   MultiByteToXArrayWideChar
//
//  Arguments:  [pbBuffer]  - ASCII buffer to convert to WCHAR
//              [cbBuffer]  - length of the buffer, not including the null
//              [codePage]  - codePage for conversion
//              [wcsBuffer] - resulting WCHAR buffer
//
//  Synopsis:   Converts a multibyte string to a wide character string
//
//----------------------------------------------------------------------------
ULONG MultiByteToXArrayWideChar( BYTE const * pbBuffer,
                                 ULONG cbBuffer,
                                 UINT codePage,
                                 XArray<WCHAR> & wcsBuffer )
{
    Win4Assert( 0 != pbBuffer );

    //
    // MultiByteToWideChar expects a length of at least 1 char.
    //

    int cwcBuffer = cbBuffer + (cbBuffer/2) + 2;

    if ( wcsBuffer.Get() == 0 || (ULONG) cwcBuffer > wcsBuffer.Count() )
    {
        delete [] wcsBuffer.Acquire();
        wcsBuffer.Init(cwcBuffer);
    }

    if ( 0 == cbBuffer )
    {
        wcsBuffer[0] = 0;
        return 0;
    }

    int cwcConvert;

    do
    {
        cwcConvert = MultiByteToWideChar( codePage,
                                          0,
                           (const char *) pbBuffer,
                                          cbBuffer,        // Size of input buf
                                          wcsBuffer.Get(), // Ptr to output buf
                                          cwcBuffer - 1 ); // Size of output buf

        if ( 0 == cwcConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwcBuffer += (cwcBuffer/2);
                delete wcsBuffer.Acquire();
                wcsBuffer.Init(cwcBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            wcsBuffer[cwcConvert] = 0;      // Null terminate the buffer
        }
    } while ( 0 == cwcConvert );

    if ( 0 == pbBuffer[cbBuffer-1] )
        return cwcConvert - 1;

    return cwcConvert;
} //MultiByteToXArrayWideChar

//+---------------------------------------------------------------------------
//
//  Function:   WideCharToXArrayMultiByte
//
//  Arguments:  [wcsMesage]  - WCHAR buffer to convert to ASCII
//              [cwcMessage] - length of the buffer, not including the null
//              [codePage]   - code page for conversion
//              [pszBuffer]  - resulting CHAR buffer
//
//  Synopsis:   Converts a wide character string to ASCII
//
//----------------------------------------------------------------------------
DWORD WideCharToXArrayMultiByte( WCHAR const * wcsMessage,
                                 ULONG cwcMessage,
                                 UINT codePage,
                                 XArray<BYTE> & pszMessage )
{
    Win4Assert( 0 != cwcMessage );
    
    DWORD cbConvert;
    ULONG cbMessage = pszMessage.Count();

    do
    {
        cbConvert = ::WideCharToMultiByte( codePage,
                                           WC_COMPOSITECHECK,
                                           wcsMessage,
                                           cwcMessage,
                                 (CHAR *)  pszMessage.Get(),
                                           cbMessage,
                                           NULL,
                                           NULL );

        if ( (0 == cbConvert) || (0 == cbMessage) )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                 cbMessage += ++cbMessage;
                 delete pszMessage.Acquire();
                 pszMessage.Init(cbMessage);
            }
            else
            {
                THROW( CException() );
            }
       }
    } while ( 0 == cbConvert );

    if ( cwcMessage > 0  && 0 == wcsMessage[cwcMessage-1] )
        return cbConvert - 1;
    else
        return cbConvert;
}

//+---------------------------------------------------------------------------
//
//  Function:   wcsipattern
//
//  Synopsis:   A case-insensitive, WCHAR implemtation of strstr.
//
//  Arguments:  [wcsString]  - string to search
//              [wcsPattern] - pattern to look for
//
//  Returns:    pointer to pattern, 0 if no match found.
//
//  History:    96/Jan/03   DwightKr    created
//
//  NOTE:       Warning the first character of wcsPattern must be a case
//              insensitive letter.  This results in a significant performance
//              improvement.
//
//----------------------------------------------------------------------------
WCHAR * wcsipattern( WCHAR * wcsString, WCHAR const * wcsPattern )
{
    Win4Assert ( (wcsPattern != 0) && (*wcsPattern != 0) );

    ULONG cwcPattern = wcslen(wcsPattern);
    Win4Assert( *wcsPattern == towupper(*wcsPattern) );

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (*wcsString != *wcsPattern) )
        {
            wcsString++;
        }

        if ( 0 == *wcsString )
        {
            return 0;
        }

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
        {
            return wcsString;
        }

        wcsString++;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\monarch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       monarch.cxx
//
//  Contents:   Public interfaces to Index Server
//
//  History:    24 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <pvarset.hxx>
#include <strsort.hxx>
#include <ciplist.hxx>
#include <doquery.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   AddToPropertyList, private
//
//  Synopsis:   Adds an array of properties to a property list
//
//  Arguments:  [PropertyList] -- destination for the props
//              [cProperties]  -- # of properties to add
//              [pProperties]  -- source of props
//              [lcid]         -- Locale (used for uppercasing)
//
//  History:    21 Jul 1997      dlee    Created
//
//----------------------------------------------------------------------------

void AddToPropertyList( CLocalGlobalPropertyList & PropertyList,
                        ULONG                      cProperties,
                        CIPROPERTYDEF *            pProperties,
                        LCID                       lcid )
{
    if ( ( 0 != cProperties ) && ( 0 == pProperties ) )
        THROW( CException( E_INVALIDARG ) );

    XGrowable<WCHAR> xTemp;

    for ( unsigned i = 0; i < cProperties; i++ )
    {
        //
        // Uppercase the friendly name.  Done at this level of code to
        // optimize other property lookup paths.
        //

        int cc = wcslen( pProperties[i].wcsFriendlyName ) + 1;

        xTemp.SetSize( cc + cc/2 );

        int ccOut = LCMapString( lcid,
                                 LCMAP_UPPERCASE,
                                 pProperties[i].wcsFriendlyName,
                                 cc,
                                 xTemp.Get(),
                                 xTemp.Count() );

        Win4Assert( 0 != ccOut );
        Win4Assert( 0 == xTemp[ccOut-1] );

        if ( 0 == ccOut )
            THROW( CException() );

        XPtr<CPropEntry> xEntry;

        //
        // Did the string change?
        //

        if ( ccOut == cc &&
             RtlEqualMemory( pProperties[i].wcsFriendlyName, xTemp.Get(), cc*sizeof(WCHAR) ) )
        {
            xEntry.Set( new CPropEntry( pProperties[i].wcsFriendlyName,
                                        0,
                                        (DBTYPE) pProperties[i].dbType,
                                        pProperties[i].dbCol ) );
        }
        else
        {
            XPtrST<WCHAR> xFName( new WCHAR[ccOut] );
            RtlCopyMemory( xFName.GetPointer(), xTemp.Get(), ccOut * sizeof(WCHAR) );

            xEntry.Set( new CPropEntry( xFName,
                                        (DBTYPE) pProperties[i].dbType,
                                        pProperties[i].dbCol ) );
        }

        //
        // Add new property to list.
        //

        PropertyList.AddEntry( xEntry.GetPointer(), 0 );
        xEntry.Acquire();
    }
} //AddToPropertyList

//+---------------------------------------------------------------------------
//
//  Function:   CITextToSelectTree, public
//
//  Synopsis:   Converts a Tripoli query string into a DBCOMMANDTREE
//
//  Arguments:  [pwszRestriction] - input query string
//              [ppTree] - output command tree
//              [cProperties] - number of extension properties
//              [pProperties] - pointer to extension property array
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CITextToSelectTree(
    WCHAR const *     pwszRestriction,
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID )
{
    return CITextToSelectTreeEx( pwszRestriction,
                                 ISQLANG_V1,
                                 ppTree,
                                 cProperties,
                                 pProperties,
                                 LocaleID );
} //CITextToSelectTree

//+---------------------------------------------------------------------------
//
//  Function:   CITextToFullTree
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pwszRestriction] - Input query string in "Triplish"
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CITextToFullTree( WCHAR const *     pwszRestriction,
                        WCHAR const *     pwszColumns,
                        WCHAR const *     pwszSortColumns,
                        WCHAR const *     pwszGrouping,
                        DBCOMMANDTREE * * ppTree,
                        ULONG             cProperties,
                        CIPROPERTYDEF *   pProperties,
                        LCID              LocaleID )
{
    return CITextToFullTreeEx( pwszRestriction,
                               ISQLANG_V1,
                               pwszColumns,
                               pwszSortColumns,
                               pwszGrouping,
                               ppTree,
                               cProperties,
                               pProperties,
                               LocaleID );
} //CITextToFullTree

//+---------------------------------------------------------------------------
//
//  Function:   CITextToSelectTreeEx, public
//
//  Synopsis:   Converts a Tripoli query string into a DBCOMMANDTREE
//
//  Arguments:  [pwszRestriction] - input query string
//              [ulDialect]       - dialect of triplish
//              [ppTree] - output command tree
//              [cProperties] - number of extension properties
//              [pProperties] - pointer to extension property array
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CITextToSelectTreeEx(
    WCHAR const *     pwszRestriction,
    ULONG             ulDialect,
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID )
{
    if ( 0 == pwszRestriction || 0 == *pwszRestriction || 0 == ppTree )
        return E_INVALIDARG;

    if ( ISQLANG_V1 != ulDialect &&
         ISQLANG_V2 != ulDialect )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(lcid));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        //
        //  Setup the variables needed to execute this query; including:
        //
        //      CiRestriction
        //      CiMaxRecordsInResultSet
        //      CiSort
        //

        // ixssoDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
        // ixssoDebugOut(( DEB_TRACE, "\tCiRestriction = '%ws'\n", pwszRestriction ));

        *ppTree = GetStringDbRestriction( pwszRestriction,
                                          ulDialect,
                                          xPropertyList.GetPointer(),
                                          lcid )->CastToStruct();

    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CITextToSelectTreeEx

//+---------------------------------------------------------------------------
//
//  Function:   CITextToFullTreeEx
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pwszRestriction] - Input query string in "Triplish"
//              [ulDialect]       - Dialect of Triplish
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CITextToFullTreeEx( WCHAR const * pwszRestriction,
                          ULONG         ulDialect,
                          WCHAR const * pwszColumns,
                          WCHAR const * pwszSortColumns,
                          WCHAR const * pwszGrouping,
                          DBCOMMANDTREE * * ppTree,
                          ULONG cProperties,
                          CIPROPERTYDEF * pProperties,
                          LCID           LocaleID )
{
    if ( 0 == ppTree ||
         0 == pwszRestriction ||
         0 == *pwszRestriction ||
         0 == pwszColumns ||
         0 == *pwszColumns )
        return E_INVALIDARG;

    if ( ISQLANG_V1 != ulDialect &&
         ISQLANG_V2 != ulDialect )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(lcid));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        CTextToTree textToTree( pwszRestriction,
                                ulDialect,
                                pwszColumns,
                                xPropertyList.GetPointer(),
                                lcid,
                                pwszSortColumns,
                                pwszGrouping );

        *ppTree = textToTree.FormFullTree();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CITextToFullTreeEx

//+---------------------------------------------------------------------------
//
//  Function:   CIBuildQueryNode
//
//  Synopsis:   Build a simple restriction node.
//
//  Arguments:  [wcsProperty]       - Target property
//              [dwOperator]        - Enumerated operator
//              [pvarPropertyValue] - property value
//              [ppTree]            - [out] The DBCOMMANDTREE representing the
//                                    simple restriction.
//              [cProperties]       - # of props in the pProperties array
//              [pProperties]       - Array of properties
//              [LocaleId]          - Locale to use.
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    July 22 1997   KrishnaN   Created
//
//----------------------------------------------------------------------------

SCODE CIBuildQueryNode(WCHAR const *wcsProperty,
                       DBCOMMANDOP dbOperator,
                       PROPVARIANT const *pvarPropertyValue,
                       DBCOMMANDTREE ** ppTree,
                       ULONG cProperties,
                       CIPROPERTYDEF const * pProperties, // Can be 0.
                       LCID LocaleID)
{
    if (0 == pvarPropertyValue || 0 == ppTree ||
        (cProperties > 0 && 0 == pProperties))
        return E_INVALIDARG;

    XInterface<CLocalGlobalPropertyList> xPropertyList;

    SCODE sc = S_OK;
    *ppTree = 0;

    CTranslateSystemExceptions translate;
    TRY
    {
        xPropertyList.Set( new CLocalGlobalPropertyList( LocaleID ) );

        //
        // No need to add to prop list if this is dbop_content.
        // CITextToSelectTree does that.
        //

        if (pProperties && dbOperator != DBOP_content)
        {
            AddToPropertyList( xPropertyList.GetReference(),
                               cProperties,
                               (CIPROPERTYDEF *)pProperties,
                               LocaleID );
        }

        DBID *pdbid = 0;
        CDbColId *pcdbCol = 0;
        DBTYPE ptype;

        // dbop_content prop info is taken care in citexttoselecttree call
        if (dbOperator != DBOP_content)
        {
            if( FAILED(xPropertyList->GetPropInfoFromName( wcsProperty,
                                     &pdbid,
                                     &ptype,
                                     0 )) )
                THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );
        }

        pcdbCol = (CDbColId *)pdbid;

        switch (dbOperator)
        {
            //
            // The caller passes a chunk of text. Pass it
            // to the parser and have it build a restriction
            // for us.
            //

            case DBOP_content:
            {
                if (pvarPropertyValue->vt != VT_LPWSTR &&
                    pvarPropertyValue->vt != (DBTYPE_WSTR|DBTYPE_BYREF))
                    THROW( CException( E_INVALIDARG ) );

                sc = CITextToSelectTree(pvarPropertyValue->pwszVal,
                                        ppTree,
                                        cProperties,
                                        (CIPROPERTYDEF *)pProperties,
                                        LocaleID );
                break;
            }

            //
            // The caller passes a chunk of text which should be
            // interpreted as free text. Build a natlang restriction.
            //

            case DBOP_content_freetext:
            {
                if (pvarPropertyValue->vt != VT_LPWSTR &&
                    pvarPropertyValue->vt != (DBTYPE_WSTR|DBTYPE_BYREF))
                    THROW( CException( E_INVALIDARG ) );

                XPtr<CDbNatLangRestriction> xNatLangRst( new CDbNatLangRestriction( pvarPropertyValue->pwszVal,
                                                                                    *pcdbCol,
                                                                                    LocaleID ) );
                if ( xNatLangRst.IsNull() || !xNatLangRst->IsValid() )
                    THROW( CException( E_OUTOFMEMORY ) );

                *ppTree = xNatLangRst->CastToStruct();
                xNatLangRst.Acquire();

                break;
            }

            //
            // Regular expressions and  property value queries
            //

            case DBOP_like:
            case DBOP_equal:
            case DBOP_not_equal:
            case DBOP_less:
            case DBOP_less_equal:
            case DBOP_greater:
            case DBOP_greater_equal:
            case DBOP_allbits:
            case DBOP_anybits:

            case DBOP_equal_all:
            case DBOP_not_equal_all:
            case DBOP_greater_all:
            case DBOP_greater_equal_all:
            case DBOP_less_all:
            case DBOP_less_equal_all:
            case DBOP_allbits_all:
            case DBOP_anybits_all:

            case DBOP_equal_any:
            case DBOP_not_equal_any:
            case DBOP_greater_any:
            case DBOP_greater_equal_any:
            case DBOP_less_any:
            case DBOP_less_equal_any:
            case DBOP_allbits_any:
            case DBOP_anybits_any:
            {
                XPtr<CDbPropertyRestriction> xPrpRst( new CDbPropertyRestriction
                                                       (dbOperator,
                                                        *(pcdbCol->CastToStruct()),
                                                        *(CStorageVariant const *)(void *)pvarPropertyValue) );
                if ( xPrpRst.IsNull() || !xPrpRst->IsValid() )
                    THROW( CException( E_OUTOFMEMORY ) );

                *ppTree = xPrpRst->CastToStruct();
                xPrpRst.Acquire();

                break;
            }

            default:
                sc = E_INVALIDARG;
                break;
        }
    }
    CATCH(CException, e)
    {
        sc = GetScodeError( e );
        Win4Assert(0 == *ppTree);
    }
    END_CATCH

    return sc;
} //CIBuildQueryNode

//+---------------------------------------------------------------------------
//
//  Function:   CIBuildQueryTree
//
//  Synopsis:   Build a restriction tree from an existing tree (could be empty)
//              and a newly added node/tree.
//
//  Arguments:  [pExistingTree]  - Ptr to existing command tree
//              [dwBoolOp]       - Enumerated boolean operator
//              [cSiblings]      - Number of trees to combine at the same level.
//              [ppSibsToCombine]- Array of sibling tree to combine.
//              [ppTree]         - [out] The DBCOMMANDTREE representing the
//                                 combined restriction.
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    July 22 1997   KrishnaN   Created
//
//----------------------------------------------------------------------------

SCODE CIBuildQueryTree(DBCOMMANDTREE const *pExistingTree,
                       DBCOMMANDOP dbBoolOp,
                       ULONG cSiblings,
                       DBCOMMANDTREE const * const *ppSibsToCombine,
                       DBCOMMANDTREE ** ppTree)
{
    if (0 == cSiblings || 0 == ppTree ||
        0 == ppSibsToCombine || 0 == *ppSibsToCombine)
        return E_INVALIDARG;

    // AND and OR should have at least two operands
    if ((dbBoolOp == DBOP_and || dbBoolOp == DBOP_or) &&
        0 == pExistingTree && cSiblings < 2)
        return E_INVALIDARG;

    // NOT should have only one operand
    if (dbBoolOp == DBOP_not && (pExistingTree || cSiblings > 1))
        return E_INVALIDARG;

    *ppTree = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        switch(dbBoolOp)
        {
            case DBOP_and:
            case DBOP_or:
            {
                CDbBooleanNodeRestriction *pAndOrCombiner = new CDbBooleanNodeRestriction( dbBoolOp );
                if (0 == pAndOrCombiner)
                    THROW( CException( E_OUTOFMEMORY ) );

                if (pExistingTree)
                    pAndOrCombiner->AppendChild((CDbRestriction *)CDbCmdTreeNode::CastFromStruct(pExistingTree));

                for (ULONG i = 0; i < cSiblings; i++)
                    pAndOrCombiner->AppendChild((CDbRestriction *)CDbCmdTreeNode::CastFromStruct(ppSibsToCombine[i]));

                *ppTree = pAndOrCombiner->CastToStruct();

                break;
            }

        case DBOP_not:
            {
                CDbNotRestriction *pNotCombiner = new CDbNotRestriction((CDbRestriction *)
                                                      CDbCmdTreeNode::CastFromStruct(ppSibsToCombine[0]));
                if (0 == pNotCombiner)
                    THROW( CException( E_OUTOFMEMORY ) );
                *ppTree = pNotCombiner->CastToStruct();

                break;
            }

            default:
                sc = E_INVALIDARG;
                break;
        }
    }
    CATCH(CException, e)
    {
        sc = GetScodeError( e );
        Win4Assert(0 == *ppTree);
    }
    END_CATCH

    return sc;
} //CIBuildQueryTree

//+---------------------------------------------------------------------------
//
//  Function:   CIRestrictionToFullTree
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pTree]           - Input query tree
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CIRestrictionToFullTree( DBCOMMANDTREE const *pTree,
                               WCHAR const * pwszColumns,
                               WCHAR const * pwszSortColumns,
                               WCHAR const * pwszGrouping,
                               DBCOMMANDTREE * * ppTree,
                               ULONG cProperties,
                               CIPROPERTYDEF * pProperties,
                               LCID           LocaleID )
{
    if ( 0 == ppTree ||
         0 == pTree ||
         0 == pwszColumns ||
         0 == *pwszColumns )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(LocaleID));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        CTextToTree RestrictionToTree( pTree,
                                       pwszColumns,
                                       xPropertyList.GetPointer(),
                                       lcid,
                                       pwszSortColumns,
                                       pwszGrouping );

        *ppTree = RestrictionToTree.FormFullTree();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIRestrictionToFullTree

//+---------------------------------------------------------------------------
//
//  Function:   CIMakeICommand
//
//  Synopsis:   Creates an ICommand
//
//  Arguments:  [ppCommand]   -- where the ICommand is returned
//              [cScope]      -- # of items in below arrays
//              [aDepths]     -- array of depths
//              [awcsScope]   -- array of scopes
//              [awcsCat]     -- array of catalogs
//              [awcsMachine] -- array of machines
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    6-11-97   dlee      Fixed and added header
//
//----------------------------------------------------------------------------

SCODE CIMakeICommand( ICommand **           ppCommand,
                      ULONG                 cScope,
                      DWORD const *         aDepths,
                      WCHAR const * const * awcsScope,
                      WCHAR const * const * awcsCat,
                      WCHAR const * const * awcsMachine )
{
    if ( 0 == ppCommand ||
         0 == aDepths ||
         0 == awcsScope ||
         0 == awcsCat ||
         0 == awcsMachine ||
         0 == cScope )
        return E_INVALIDARG;

    *ppCommand = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        // First get an ICommand object as an IUnknown

        XInterface<IUnknown> xUnk;
        sc = MakeICommand( xUnk.GetIUPointer(), 0, 0, 0 );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        // QI to ICommand

        XInterface<ICommand> xCommand;
        sc = xUnk->QueryInterface( IID_ICommand,
                                   xCommand.GetQIPointer() );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        // SetScopeProperties throws

        SetScopeProperties( xCommand.GetPointer(),
                            cScope,
                            awcsScope,
                            aDepths,
                            awcsCat,
                            awcsMachine );

        *ppCommand = xCommand.Acquire();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIMakeICommand

//+---------------------------------------------------------------------------
//
//  Function:   CICreateCommand
//
//  Synopsis:   Creates an ICommand
//
//  Arguments:  [ppResult]    -- where the resulting interface is returned
//              [pUnkOuter]   -- outer unknown
//              [riid]        -- iid of interface to return.  Must be
//                               IID_IUnknown unless pUnkOuter == 0
//              [pwcsCatalog] -- catalog
//              [pwcsMachine] -- machine
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    6-11-97   dlee      Fixed and added header
//
//----------------------------------------------------------------------------

SCODE CICreateCommand( IUnknown **   ppResult,
                       IUnknown *    pUnkOuter,
                       REFIID        riid,
                       WCHAR const * pwcsCatalog,
                       WCHAR const * pwcsMachine )
{
    if ( 0 != pUnkOuter && IID_IUnknown != riid )
        return CLASS_E_NOAGGREGATION;

    if ( 0 == ppResult ||
         0 == pwcsCatalog ||
         0 == pwcsMachine )
        return E_INVALIDARG;

    // try to AV

    *ppResult = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        //
        // First get an ICommand object as an IUnknown
        //

        XInterface<IUnknown> xUnk;
        sc = MakeICommand( xUnk.GetIUPointer(),
                           0,
                           0,
                           pUnkOuter );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        //
        // QI to the interface requested
        //

        if ( IID_IUnknown != riid )
        {
            IUnknown *pUnk;
            sc = xUnk->QueryInterface( riid,
                                       (void **) & pUnk );

            if ( FAILED( sc ) )
                THROW( CException( sc ) );

            xUnk.Free();
            xUnk.Set( pUnk );
        }

        //
        // Set the scope, catalogs, and machines
        //

        {
            // SetScopeProperties throws

            DWORD dwFlags = QUERY_DEEP;
            WCHAR const * pwcScope = L"\\";

            //
            // cheezy hack cast, since I can't QI for the ICommand yet
            // if the outer unknown is specified.  Assume MakeICommand
            // returns an ICommand under the IUnknown.
            //

            SetScopeProperties( (ICommand *) xUnk.GetPointer(),
                                1,
                                &pwcScope,
                                &dwFlags,
                                &pwcsCatalog,
                                &pwcsMachine );
        }

        *ppResult = xUnk.Acquire();
    }
    CATCH ( CException, e )
    {
        //
        // This is Index Server's function, not OLE-DB's, so don't mask
        // errors as E_FAIL with GetOleError
        //

        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CICreateCommand

//+---------------------------------------------------------------------------
//
//  Class:      CIPropertyList
//
//  Synopsis:   allow access to the default property list used by CITextTo*Tree
//
//  History:    08-Aug-97   alanw     Created
//
//----------------------------------------------------------------------------

class CIPropertyList : public ICiPropertyList
{
public:

    CIPropertyList() : _cRef( 1 )
    {
        _xproplist.Set( new CLocalGlobalPropertyList() );
    }

    ~CIPropertyList()
    {
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( )
    {
        return InterlockedIncrement(&_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( )
    {
        ULONG uTmp = InterlockedDecrement(&_cRef);
        if (uTmp == 0)
        {
            delete this;
            return 0;
        }
        return uTmp;
    }

    virtual BOOL GetPropInfo( WCHAR const * wcsPropName,
                              DBID ** ppPropid,
                              DBTYPE * pPropType,
                              unsigned int * puWidth )
    {
        return (S_OK == _xproplist->GetPropInfoFromName(
                                               wcsPropName,
                                               ppPropid,
                                               pPropType,
                                               puWidth ));
    }

    virtual BOOL GetPropInfo( DBID  const & prop,
                              WCHAR const ** pwcsName,
                              DBTYPE * pPropType,
                              unsigned int * puWidth )
    {
        return (S_OK == _xproplist->GetPropInfoFromId(
                                         &prop,
                                         (WCHAR **)pwcsName,
                                         pPropType,
                                         puWidth ));
    }

    virtual BOOL EnumPropInfo( ULONG const & iEntry,
                               WCHAR const ** pwcsName,
                               DBID  ** ppProp,
                               DBTYPE * pPropType,
                               unsigned int * puWidth )
    {
        return FALSE; // Not implemented because no one needs it.
    }

private:
    XInterface<CLocalGlobalPropertyList> _xproplist;
    LONG _cRef;

};

//+---------------------------------------------------------------------------
//
//  Function:   CIGetGlobalPropertyList, public
//
//  Synopsis:   Gets a reference to the property list used by CITextToSelectTree
//
//  Arguments:  [ppPropList]  -- where the ICiPropertyList is returned
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    08-Aug-97   alanw     Created
//
//----------------------------------------------------------------------------

SCODE CIGetGlobalPropertyList( ICiPropertyList ** ppPropList )
{
    if ( 0 == ppPropList )
        return E_INVALIDARG;

    *ppPropList = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        XPtr<CIPropertyList> xProplist( new CIPropertyList() );

        *ppPropList = xProplist.Acquire();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIGetGlobalPropertyList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\plist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-2000.
//
//  File:       PLIST.CXX
//
//  Contents:   CPropertyList methods
//              Responsible for parsing and managing the friendly name file.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <shlguid.h>

#include <ciguid.hxx>
#include <nntpprop.hxx>

// regulates access to the global file prop list.
extern CStaticMutexSem g_mtxFilePropList;

// regulates access to prop list iterators.
CStaticMutexSem g_mtxPropListIter;

// The 'friendly name file' is parsed on a line by line basis.  The property
// specification are in the [Names] section of the file.
//
// Each line must have the following form:
//
// FriendlyName [ "(" [ TypeWidthSpec ] ")" ] ["="] PropertySetGuid PropertySpec
//
// where:
//      FriendlyName    - a whitespace delimited 'friendly' name for the property
//      TypeWidthSpec   - one of:
//                          DBTYPE_Type
//                          Width
//                          Type "," Width
//                        where Type is a string specifying the property type
//                        for comparison purposes, and Width is an integer
//                        specifying the display field width
//      PropertySetGuid - a guid in the standard form
//      PropertySpec    - either a property name or PropID
//
// Blank lines are allowed, and comments are recognized as any line with "#"
// as the first non-whitespace character.
//
// (also note that the "=" above is optional, but I think it looks nice...)

#ifndef PIDISI_FILETYPE

    #define PIDISI_FILETYPE                 0x00000002L  // VT_LPWSTR
    #define PIDISI_CX                       0x00000003L  // VT_UI4
    #define PIDISI_CY                       0x00000004L  // VT_UI4
    #define PIDISI_RESOLUTIONX              0x00000005L  // VT_UI4
    #define PIDISI_RESOLUTIONY              0x00000006L  // VT_UI4
    #define PIDISI_BITDEPTH                 0x00000007L  // VT_UI4
    #define PIDISI_COLORSPACE               0x00000008L  // VT_LPWSTR
    #define PIDISI_COMPRESSION              0x00000009L  // VT_LPWSTR
    #define PIDISI_TRANSPARENCY             0x0000000AL  // VT_UI4
    #define PIDISI_GAMMAVALUE               0x0000000BL  // VT_UI4
    #define PIDISI_FRAMECOUNT               0x0000000CL  // VT_UI4
    #define PIDISI_DIMENSIONS               0x0000000DL  // VT_LPWSTR

#endif

#ifndef PSGUID_FlashPix

    #define PSGUID_FlashPix { 0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B }

    #define PID_File_source                         0x21000000 // VT_UI4: File source
    #define PID_Scene_type                          0x21000001 // VT_UI4: Scene type
    #define PID_Creation_path_vector                0x21000002 // VT_UI4 | VT_VECTOR: Creation path vector
    #define PID_Software_Name_Manufacturer_Release  0x21000003 // VT_LPWSTR: Software Name/Manufacturer/Release
    #define PID_User_defined_ID                     0x21000004 // VT_LPWSTR: User defined ID
    #define PID_Sharpness_approximation             0x21000005 // VT_R4: Sharpness approximation
    
    #define PID_Copyright_message                   0x22000000 // VT_LPWSTR: Copyright message
    #define PID_Legal_broker_for_the_original_image 0x22000001 // VT_LPWSTR: Legal broker for the original image
    #define PID_Legal_broker_for_the_digital_image  0x22000002 // VT_LPWSTR: Legal broker for the digital image
    #define PID_Authorship                          0x22000003 // VT_LPWSTR: Authorship
    #define PID_Intellectual_property_notes         0x22000004 // VT_LPWSTR: Intellectual property notes
    
    #define PID_Test_target_in_the_image            0x23000000 // VT_UI4: Test target in the image
    #define PID_Group_caption                       0x23000002 // VT_LPWSTR: Group caption
    #define PID_Caption_text                        0x23000003 // VT_LPWSTR: Caption text
    #define PID_People_in_the_image                 0x23000004 // VT_LPWSTR | VT_VECTOR
    #define PID_Things_in_the_image                 0x23000007 // VT_LPWSTR | VT_VECTOR
    #define PID_Date_of_the_original_image          0x2300000A // VT_FILETIME
    #define PID_Events_in_the_image                 0x2300000B // VT_LPWSTR | VT_VECTOR
    #define PID_Places_in_the_image                 0x2300000C // VT_LPWSTR | VT_VECTOR
    #define PID_Content_description_notes           0x2300000F // VT_LPWSTR: Content description notes
    
    #define PID_Camera_manufacturer_name            0x24000000 // VT_LPWSTR: Camera manufacturer name
    #define PID_Camera_model_name                   0x24000001 // VT_LPWSTR: Camera model name
    #define PID_Camera_serial_number                0x24000002 // VT_LPWSTR: Camera serial number
    
    #define PID_Capture_date                        0x25000000  // VT_FILETIME: Capture date
    #define PID_Exposure_time                       0x25000001  // VT_R4: Exposure time
    #define PID_F_number                            0x25000002  // VT_R4: F-number
    #define PID_Exposure_program                    0x25000003  // VT_UI4: Exposure program
    #define PID_Brightness_value                    0x25000004  // VT_R4 | VT_VECTOR
    #define PID_Exposure_bias_value                 0x25000005  // VT_R4: Exposure bias value
    #define PID_Subject_distance                    0x25000006  // VT_R4 | VT_VECTOR
    #define PID_Metering_mode                       0x25000007  // VT_UI4: Metering mode
    #define PID_Scene_illuminant                    0x25000008  // VT_UI4: Scene illuminant
    #define PID_Focal_length                        0x25000009  // VT_R4: Focal length
    #define PID_Maximum_aperture_value              0x2500000A  // VT_R4: Maximum aperture value
    #define PID_Flash                               0x2500000B  // VT_UI4: Flash
    #define PID_Flash_energy                        0x2500000C  // VT_R4: Flash energy
    #define PID_Flash_return                        0x2500000D  // VT_UI4: Flash return
    #define PID_Back_light                          0x2500000E  // VT_UI4: Back light
    #define PID_Subject_location                    0x2500000F  // VT_R4 | VT_VECTOR
    #define PID_Exposure_index                      0x25000010  // VT_R4: Exposure index
    #define PID_Special_effects_optical_filter      0x25000011  // VT_UI4 | VT_VECTOR
    #define PID_Per_picture_notes                   0x25000012  // VT_LPWSTR: Per picture notes
    
    #define PID_Sensing_method                      0x26000000 // VT_UI4: Sensing method
    #define PID_Focal_plane_X_resolution            0x26000001 // VT_R4: Focal plane X resolution
    #define PID_Focal_plane_Y_resolution            0x26000002 // VT_R4: Focal plane Y resolution
    #define PID_Focal_plane_resolution_unit         0x26000003 // VT_UI4: Focal plane resolution unit
    #define PID_Spatial_frequency_response          0x26000004 // VT_VARIANT | VT_VECTOR
    #define PID_CFA_pattern                         0x26000005 // VT_VARIANT | VT_VECTOR
    #define PID_Spectral_sensitivity                0x26000006 // VT_LPWSTR: Spectral sensitivity
    #define PID_ISO_speed_ratings                   0x26000007 // VT_UI2 | VT_VECTOR
    #define PID_OECF                                0x26000008 // VT_VARIANT | VT_VECTOR: OECF
    
    #define PID_Film_brand                          0x27000000 // VT_LPWSTR: Film brand
    #define PID_Film_category                       0x27000001 // VT_UI4: Film category
    #define PID_Film_size                           0x27000002 // VT_VARIANT | VT_VECTOR: Film size
    #define PID_Film_roll_number                    0x27000003 // VT_UI4: Film roll number
    #define PID_Film_frame_number                   0x27000004 // VT_UI4: Film frame number
    
    #define PID_Original_scanned_image_size         0x29000000 // VT_VARIANT | VT_VECTOR: Original scanned image size
    #define PID_Original_document_size              0x29000001 // VT_VARIANT | VT_VECTOR: Original document size
    #define PID_Original_medium                     0x29000002 // VT_UI4: Original medium
    #define PID_Type_of_original                    0x29000003 // VT_UI4: Type of original
    
    #define PID_Scanner_manufacturer_name           0x28000000 // VT_LPWSTR: Scanner manufacturer name
    #define PID_Scanner_model_name                  0x28000001 // VT_LPWSTR: Scanner model name
    #define PID_Scanner_serial_number               0x28000002 // VT_LPWSTR: Scanner serial number
    #define PID_Scan_software                       0x28000003 // VT_LPWSTR: Scan software
    #define PID_Scan_software_revision_date         0x28000004 // VT_DATE: Scan software revision date
    #define PID_Service_bureau_organization_name    0x28000005 // VT_LPWSTR: Service bureau/organization name
    #define PID_Scan_operator_ID                    0x28000006 // VT_LPWSTR: Scan operator ID
    #define PID_Scan_date                           0x28000008 // VT_FILETIME: Scan date
    #define PID_Last_modified_date                  0x28000009 // VT_FILETIME: Last modified date
    #define PID_Scanner_pixel_size                  0x2800000A // VT_R4: Scanner pixel size

#endif // PIDISI_FILETYPE


//+-------------------------------------------------------------------------
//
//  Function:   HashFun
//
//  Arguments:  [pwcName]  -- string to hash
//
//  History:    26-Aug-97   KrishnaN     Added this nifty comment block.
//
//  Notes:      Hash function #1 from tplist.cxx
//
//--------------------------------------------------------------------------

ULONG HashFun( WCHAR const * pwcName )
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += CiPtrToUlong( pwcName - pwcStart );

    return ulHash;
} //HashFun

// strings corresponding to the property type enum in plist.hxx
struct PropertyTypeArrayEntry
{
    WCHAR  * wcsTypeName;
    DBTYPE dbType;
};

// Ordered by expected frequency

static const PropertyTypeArrayEntry parseTypes[] =
{
    { L"DBTYPE_WSTR",     DBTYPE_WSTR     },     //  wide null terminated string
    { L"DBTYPE_BYREF",    DBTYPE_BYREF    },     //  a pointer
    { L"VT_FILETIME",     VT_FILETIME     },     //  I8 filetime
    { L"DBTYPE_FILETIME", DBTYPE_FILETIME },     //  I8 filetime
    { L"DBTYPE_BSTR",     DBTYPE_BSTR     },     //  a BSTR
    { L"DBTYPE_STR",      DBTYPE_STR      },     //  null terminated string
    { L"DBTYPE_I4",       DBTYPE_I4       },     //  4 byte signed int
    { L"DBTYPE_UI4",      DBTYPE_UI4      },     //  4 byte unsigned int
    { L"DBTYPE_I8",       DBTYPE_I8       },     //  8 byte signed int
    { L"DBTYPE_UI8",      DBTYPE_UI8      },     //  8 byte unsigned int
    { L"DBTYPE_I1",       DBTYPE_I1       },     //  signed char
    { L"DBTYPE_UI1",      DBTYPE_UI1      },     //  unsigned char
    { L"DBTYPE_I2",       DBTYPE_I2       },     //  2 byte signed int
    { L"DBTYPE_UI2",      DBTYPE_UI2      },     //  2 byte unsigned int
    { L"DBTYPE_R4",       DBTYPE_R4       },     //  4 byte float
    { L"DBTYPE_R8",       DBTYPE_R8       },     //  8 byte float
    { L"DBTYPE_CY",       DBTYPE_CY       },     //  currency (LONG_LONG)
    { L"DBTYPE_DATE",     DBTYPE_DATE     },     //  date (double)
    { L"DBTYPE_BOOL",     DBTYPE_BOOL     },     //  BOOL (true=-1, false=0)
    { L"DBTYPE_GUID",     DBTYPE_GUID     },     //  a guid
    { L"DBTYPE_VECTOR",   DBTYPE_VECTOR   },     //  a vector
    { L"DBTYPE_ERROR",    DBTYPE_ERROR    },     //  an error
    { L"DBTYPE_DECIMAL",  DBTYPE_DECIMAL  },     //  decimal
//    { L"DBTYPE_ARRAY" ,   DBTYPE_ARRAY    },     //  an array
};

unsigned cParseTypes = sizeof parseTypes / sizeof parseTypes[0];

WCHAR const * CEmptyPropertyList::GetPropTypeName( unsigned i )
{
    Win4Assert( i < GetPropTypeCount() );
    return parseTypes[i].wcsTypeName;
}

DBTYPE CEmptyPropertyList::GetPropType( unsigned i )
{
    Win4Assert( i < GetPropTypeCount() );
    return parseTypes[i].dbType;
}

unsigned CEmptyPropertyList::GetPropTypeCount()
{
    return cParseTypes;
}

//+-------------------------------------------------------------------------
//
//  Function:   FindPropType
//
//  Arguments:  [wcsType]  -- string name to lookup.
//
//  Returns:    Index into the parseTypes array or ULONG_MAX if not found.
//
//  History:    26-Aug-97   KrishnaN     Added this nifty comment block.
//
//--------------------------------------------------------------------------

unsigned FindPropType( WCHAR const * wcsType )
{
    for ( unsigned i = 0; i < cParseTypes; i++ )
        if ( !wcscmp( parseTypes[i].wcsTypeName, wcsType ) )
            return i;

    return ULONG_MAX;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmptyPropertyList::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if (0 == ppiuk)
        return E_INVALIDARG;

    if (IID_IColumnMapper == ifid )
    {
        *ppiuk = (void *)((IColumnMapper *)this);
    }
    else if ( IID_IUnknown == ifid )
    {
        *ppiuk = (void *)((IUnknown *)this);
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmptyPropertyList::AddRef(void)
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmptyPropertyList::Release(void)
{
    unsigned long uTmp;

    //
    // We need to manage the global prop list file ptr to ensure that
    // concurrently running queries use the same instance, but the
    // ptr gets deleted when the last of the concurrent queries releases
    // the global ptr.
    //

    {
        CLock lock(g_mtxFilePropList);

        uTmp = InterlockedDecrement( &_cRefs );

        // At this point, no one else should be mucking with _cRefs. The AddRef
        // we do happens under g_mtxFilePropList, so we are fine!

        if (0 == uTmp && CLocalGlobalPropertyList::_pGlobalPropListFile == this)
        {
            //
            // If this is the last instance of the global prop list, set the
            // global pointer to 0 before deleting it.
            //
            CLocalGlobalPropertyList::_pGlobalPropListFile = 0;
        }
    }

    if (0 == uTmp)
    {
        Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile != this);
        delete this;
    }

    return(uTmp);
}

//
// IColumnMapper methods
//

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfoFromName, public
//
//  Synopsis:   Get property info. from name.
//
//  Parameters: [wcsPropName] -- Property name to look up.
//              [ppPropId]    -- Ptr to return Id of the property.
//              [pPropType]   -- Ptr to return type of the property.
//              [puiWidth]    -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::GetPropInfoFromName(const WCHAR  *wcsPropName,
                                         DBID  * *ppPropId,
                                         DBTYPE  *pPropType,
                                         unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == wcsPropName || 0 == ppPropId)
        return E_INVALIDARG;

    BOOL fSuccess = GetPropInfo(wcsPropName, (CDbColId **)ppPropId, pPropType, puiWidth);

    return fSuccess ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfoFromId, public
//
//  Synopsis:   Get property info. from dbid.
//
//  Parameters: [pPropId]    -- Ptr to prop to look up.
//              [pwcsName]   -- Ptr to return property name.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::GetPropInfoFromId(const DBID  *pPropId,
                                           WCHAR  * *pwcsName,
                                           DBTYPE  *pPropType,
                                           unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //
    if (0 == pwcsName || 0 == pPropId)
        return E_INVALIDARG;

    BOOL fSuccess = GetPropInfo((CDbColId const &)*pPropId,
                                (WCHAR const **)pwcsName,
                                pPropType,
                                puiWidth);

    return fSuccess ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::EnumPropInfo, public
//
//  Synopsis:   Gets the i-th entry from the list of properties.
//
//  Parameters: [iEntry]    -- i-th entry to retrieve (0-based).
//              [pwcsName]  -- Ptr to return property name.
//              [ppPropId]  -- Ptr to return Id of the property.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  Notes:      A single global mutex is used for interlocking.  It's just not
//              worth it to have a CRITICAL_SECTION in each CEmptyPropertyList.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::EnumPropInfo(ULONG iEntry,
                                  const WCHAR  * *pwcsName,
                                  DBID  * *ppPropId,
                                  DBTYPE  *pPropType,
                                  unsigned int  *puiWidth)
{
    CLock lock(g_mtxPropListIter);

    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == pwcsName || 0 == ppPropId)
        return E_INVALIDARG;

    // iEntry is 0-based.

    CPropEntry const *pPropEntry = 0;

    //
    // If iEntry is > what was last retrieved, walk to that item in the
    // iterator. If iEntry is <= what we have, we need to start from the
    // beginning, because we can only walk forward.
    //

    if (iEntry <= _iLastEntryPos)
    {
        delete _pPropIterator;
        _pPropIterator = new CPropEntryIter(*this);
        _iLastEntryPos = 0;
        pPropEntry = _pPropIterator->Next();
    }

    // Now move (iEntry - _iLastEntryPos) times to get to the desired entry.
    for (ULONG ulCurrentEntry = _iLastEntryPos;
         ulCurrentEntry < iEntry;
         ulCurrentEntry++)
    {
        pPropEntry = _pPropIterator->Next();
        if (0 != pPropEntry)
            _iLastEntryPos++;
        else    // Reached the end of the list!
            break;
    }

    if (0 == pPropEntry)
        return E_INVALIDARG;

    *pwcsName = pPropEntry->GetName();
    *ppPropId = (DBID *) (pPropEntry->PropSpec().CastToStruct());

    if (pPropType)
        *pPropType = pPropEntry->GetPropType();

    if (puiWidth)
        *puiWidth = pPropEntry->GetWidth();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfo, public
//
//  Synopsis:   Given a friendly property name, return information about
//              that property (including a CDbColId).
//
//  Arguments:  wcsPropName -- friendly property name
//              *ppprop -- if ppprop != 0, returns a pointer to the CDbColId
//              *pproptype -- if proptype != 0, returns the DBTYPE
//              *puWidth -- if pulWidth != 0, returns the output field width
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

BOOL CEmptyPropertyList::GetPropInfo(WCHAR const * wcsPropName,
                                     CDbColId ** ppprop,
                                     DBTYPE * pproptype,
                                     unsigned int * puWidth )
{
    WCHAR awc[MAX_PROPNAME_LENGTH + 1];

    unsigned cc = wcslen( wcsPropName );

    if ( cc > MAX_PROPNAME_LENGTH )
        cc = MAX_PROPNAME_LENGTH;

    RtlCopyMemory( awc, wcsPropName, cc * sizeof(WCHAR) );
    awc[cc] = 0;

    _wcsupr( awc );

    CPropEntry const * ppentry = Find( awc );

    if( 0 == ppentry )
        return FALSE;

    if( ppprop )
        *ppprop = &((CDbColId &) ppentry->PropSpec());

    if( pproptype )
        *pproptype = ppentry->GetPropType();

    if( puWidth )
        *puWidth = ppentry->GetWidth();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfo, public
//
//  Synopsis:   Given a CDbColId, return information about
//              that property.
//
//  Arguments:  prop -- property specifier
//              *ppprop -- if ppprop != 0, returns a pointer to the CDbColId
//              *pproptype -- if proptype != 0, returns the DBTYPE
//              *puWidth -- if pulWidth != 0, returns the output field width
//
//  Notes:      Overloaded the other GetPropInfo to help the column display
//              routines.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

BOOL CEmptyPropertyList::GetPropInfo(CDbColId const & prop,
                                     WCHAR const ** pwcsName,
                                     DBTYPE * pproptype,
                                     unsigned int * puWidth )
{
    CPropEntry const * ppentry = Find( prop );

    if( ppentry == 0 )
        return FALSE;

    if( pwcsName )
        *pwcsName = ppentry->GetName();

    if( pproptype )
        *pproptype = ppentry->GetPropType();

    if( puWidth )
        *puWidth = ppentry->GetWidth();

    return TRUE;
} //GetPropInfo


// StaticPropertyList methods

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//              28-Aug-97   KrishnaN    Static prop lookup only.
//
//----------------------------------------------------------------------------

CPropEntry const * CStaticPropertyList::Find( WCHAR const * wcsName )
{
    Win4Assert ( sizeof SPropEntry == sizeof CPropEntry );

    if( 0 == wcsName )
        return 0;

    CPropEntry const * ppentry = 0;
    unsigned iHash = HashFun( wcsName ) % cStaticPropHash;

    for( ppentry = _aStaticEntries[ iHash ];
         0 != ppentry;
         ppentry = ppentry->Next() )
    {
        if ( ppentry->NameMatch( wcsName ) )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  prop -- CDbColId of property to find
//
//  Notes:      Overloaded Find( WCHAR const * ) to help the column display
//              routines.
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

CPropEntry const * CEmptyPropertyList::Find( CDbColId const & prop )
{
    CPropEntryIter iter( *this );

    CPropEntry const * ppentry;

    while ( ppentry = iter.Next() )
    {
        CDbColId const & ps = ppentry->PropSpec();
        if ( ps == prop )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    21-Jul-97   dlee  Moved from .hxx and added header
//
//----------------------------------------------------------------------------

CPropEntry const * CStaticPropertyList::Next()
{
    ULONG cLimit = cStaticPropHash;

    if ( _icur < cLimit )
    {
        if ( 0 == _pcur )
        {
            do
            {
                _icur++;
                if ( _icur == cLimit )
                    break;

                _pcur = _aStaticEntries[ _icur ];
            } while ( 0 == _pcur );
        }

        if ( 0 != _pcur )
        {
            CPropEntry const *p = _pcur;
            _pcur = _pcur->Next();
            return p;
        }
    }

    return 0;
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CStaticPropertyList::InitIterator()
{
    _icur = 0;
    _pcur = _aStaticEntries[0];
}

CPropertyList::~CPropertyList()
{
    ClearList();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::FindDynamic, private
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

CPropEntry const * CPropertyList::Find( WCHAR const * wcsName )
{
    Win4Assert( sizeof SPropEntry == sizeof CPropEntry );

    if( wcsName == 0 )
        return 0;

    unsigned iHash = HashFun( wcsName ) % cPropHash;

    for( CPropEntry * ppentry = _aEntries[ iHash ];
         0 != ppentry;
         ppentry = ppentry->Next() )
    {
        if( ppentry->NameMatch( wcsName ) )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the list.  Verifies that the name
//              isn't already in the list.
//
//  Arguments:  ppentryNew -- pointer to the CPropEntry to add
//              iLine      -- line number we're parsing
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::AddEntry( CPropEntry * ppentryNew, int iLine )
{
    if( Find( ppentryNew->GetName() ) )
        THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );

    CLock lock(_mtxList);

    unsigned iHash = HashFun( ppentryNew->GetName() ) % cPropHash;

    ppentryNew->SetNext( _aEntries[ iHash ] );
    _aEntries[ iHash ] = ppentryNew;
    InterlockedIncrement((LONG *)&_ulCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::ClearList, public
//
//  Synopsis:   Frees the memory used by the list.  Used in the destructor
//              and if the friendly name file is to be reparsed.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::ClearList()
{
    CLock lock(_mtxList);

    for ( unsigned i = 0; i < cPropHash; i++ )
    {
        CPropEntry * ppentryNext;

        for( CPropEntry *ppentryCurr = _aEntries[i];
             0 != ppentryCurr;
             ppentryCurr = ppentryNext )
        {
            ppentryNext = ppentryCurr->Next();
            delete ppentryCurr;
            InterlockedDecrement((LONG *)&_ulCount);
        }
    }

    RtlZeroMemory( _aEntries, sizeof _aEntries );
    Win4Assert(0 == _ulCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

CPropEntry const * CPropertyList::Next()
{
    ULONG cLimit = cPropHash;

    if ( _icur < cLimit )
    {
        if ( 0 == _pcur )
        {
            do
            {
                _icur++;
                if ( _icur == cLimit )
                    break;

                _pcur = _aEntries[ _icur ];
            } while ( 0 == _pcur );
        }

        if ( 0 != _pcur )
        {
            CPropEntry const *p = _pcur;
            _pcur = _pcur->Next();
            return p;
        }
    }

    return 0;
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CPropertyList::InitIterator()
{
    _icur = 0;
    _pcur = _aEntries[0];
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::ParseOneLine, public
//
//  Synopsis:   Parses one line of the friendly name file, creating a
//              CPropEntry node if necessary
//
//  Arguments:  scan   -- scanner initialized with the current line
//              line   -- The line to scan
//              pentry -- The cpropentry ptr.
//
//  Returns:    A pointer to the created prop entry. It could return 0 if no
//              property was created.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::ParseOneLine( CQueryScanner & scan, int iLine, XPtr<CPropEntry> & pentry )
{
    Win4Assert(0 == pentry.GetPointer());
    Token token = scan.LookAhead();

    // 1) is this a comment line (does it start with #)
    //    or an empty line?
    if( token == PROP_REGEX_TOKEN
     || token == EOS_TOKEN )
        return;

    // 2) get friendly property name & stuff it in smart pointer
    XPtrST<WCHAR> wcsName( scan.AcqColumn() );

    if( wcsName.GetPointer() == 0 )
        THROW( CPListException( QPLIST_E_EXPECTING_NAME, iLine ) );

    unsigned ccName = wcslen( wcsName.GetPointer() ) + 1;
    WCHAR *pwcDisplayName = new WCHAR[ ccName ];
    RtlCopyMemory( pwcDisplayName, wcsName.GetPointer(), ccName * sizeof WCHAR );
    XPtrST<WCHAR> wcsDisplayName( pwcDisplayName );

    // initialize a new CPropEntry
    // (name is _not_ copied, so we must relinquish the smart pointer)
    _wcsupr( wcsName.GetPointer() );
    pentry.Set( new CPropEntry( wcsDisplayName, wcsName ) );

    scan.AcceptColumn();

    token = scan.LookAhead();

    // 3) check for type & width spec
    if( token == OPEN_TOKEN )
    {
        scan.Accept();

        if( scan.LookAhead() == TEXT_TOKEN )
        {
            unsigned long ulWidth;
            BOOL fAtEnd;

            if( !scan.GetNumber( ulWidth, fAtEnd ) )
            {
                // 4) if it's not a number, try to recognize it as
                //    a type specifier
                //

                //  Scan for DB_TYPE | DB_TYPE | DBTYPE combinations
                //
                while ( scan.LookAhead() == TEXT_TOKEN )
                {
                    XPtrST<WCHAR> wcsType( scan.AcqWord() );

                    if( wcsType.GetPointer() == 0 )
                        THROW( CPListException( QPLIST_E_EXPECTING_TYPE, iLine ) );

                    _wcsupr( wcsType.GetPointer() );
                    unsigned cType = FindPropType( wcsType.GetPointer() );

                    if( cType >= GetPropTypeCount() )
                        THROW( CPListException( QPLIST_E_UNRECOGNIZED_TYPE, iLine ) );

                    scan.AcceptWord();
                    pentry->SetPropType( pentry->GetPropType() |
                                         parseTypes[cType].dbType );


                    if ( OR_TOKEN == scan.LookAhead()  )
                    {
                        scan.Accept();
                    }
                }

                //
                //  Verfy that we have some DBTYPE specified in addition
                //  to DBTYPE_VECTOR & DBTYPE_BYREF
                //
                DBTYPE dbBase = pentry->GetPropType() & ~(DBTYPE_VECTOR|DBTYPE_BYREF);
                if ( 0 == dbBase )
                {
                    THROW( CPListException( QPLIST_E_VECTORBYREF_USED_ALONE, iLine ) );
                }

                //
                // In NT 5, you can't mix and match types from VARIANT
                // and PROPVARIANT in VT_ARRAY and VT_VECTOR.  Certain
                // permutations like this one aren't supported
                //

                if ( pentry->GetPropType() == (DBTYPE_DECIMAL|DBTYPE_VECTOR) )
                    THROW( CPListException( QPLIST_E_UNRECOGNIZED_TYPE, iLine ) );

                //
                //  If they specified a DBTYPE_BYREF, it must be with a pointer
                //  type: WSTR or STR or UI1.
                //
                if ( (( pentry->GetPropType() & DBTYPE_BYREF ) != 0) &&
                     ( DBTYPE_WSTR != dbBase &&
                       DBTYPE_STR  != dbBase &&
                       DBTYPE_UI1  != dbBase &&
                       DBTYPE_GUID != dbBase) )
                {
                    THROW( CPListException( QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE, iLine ) );
                }

                if( scan.LookAhead() == COMMA_TOKEN )
                {
                    // 5) get the comma and width specifier
                    scan.Accept();

                    BOOL fAtEnd;

                    if( !scan.GetNumber( ulWidth, fAtEnd ) )
                        THROW( CPListException( QPLIST_E_EXPECTING_INTEGER, iLine ) );

                    scan.Accept();
                    pentry->SetWidth( ulWidth );
                }
            }
            else
            {
                scan.Accept();
                pentry->SetWidth( ulWidth );
            }
        }

        // 6) get the closing parenthesis
        if( scan.LookAhead() != CLOSE_TOKEN )
            THROW( CPListException( QPLIST_E_EXPECTING_CLOSE_PAREN, iLine ) );

        scan.Accept();

        token = scan.LookAhead();
    }

    //
    //  If a type was not specified, assume it is a WIDE string, BYREF
    //
    if ( pentry->GetPropType() == 0 )
    {
        pentry->SetPropType( DBTYPE_WSTR | DBTYPE_BYREF );
    }

    // 7) check for =
    if( token == EQUAL_TOKEN )
    {
        scan.Accept();
    }

    // 7.1) assign a default width if one wasn't specified
    if( pentry->GetWidth() == 0 )
    {
        pentry->SetWidth( PLIST_DEFAULT_WIDTH );
        pentry->SetDisplayed( FALSE );
    }

    // 8) get property set guid & stuff in smart pointer
    XPtrST<WCHAR> wcsUgly( scan.AcqWord() );

    if( wcsUgly.GetPointer() == 0 )
        THROW( CPListException( QPLIST_E_EXPECTING_GUID, iLine ) );

    GUID guid;
    WCHAR *pUgly = wcsUgly.GetPointer();

    if ( !ParseGuid( pUgly, guid ) )
        THROW( CPListException( QPLIST_E_BAD_GUID, iLine ) );

    pentry->PropSpec().SetPropSet( guid );

    scan.AcceptWord();
    token  = scan.LookAhead();

    ULONG ulDispId;
    // 9) get property name or dispid
    BOOL fAtEnd;
    if( !scan.GetNumber( ulDispId, fAtEnd ) )
    {
        XPtrST<WCHAR> wcsPropName;
        if ( QUOTES_TOKEN == token )
        {
            scan.Accept();
            wcsPropName.Set( scan.AcqPhraseInQuotes()  );
        }
        else
        {
            wcsPropName.Set( scan.AcqPhrase()  );
        }

        if( wcsPropName.GetPointer() == 0 )
            THROW( CPListException( QPLIST_E_EXPECTING_PROP_SPEC, iLine ) );

        if( !pentry->PropSpec().SetProperty( wcsPropName.GetPointer() ) )
            THROW( CPListException( QPLIST_E_CANT_SET_PROPERTY, iLine ) );

        scan.Accept();
    }
    else
    {
        pentry->PropSpec().SetProperty( ulDispId );
        scan.Accept();
    }
} //ParseOneLine

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                   ULONG ulMaxCount)
{
    if (0 == ppPropEntries)
    {
        return E_INVALIDARG;
    }

    CLock lock(_mtxList);

    ULONG ulSize = min (ulMaxCount, GetCount());
    ULONG u = 0;

    for ( unsigned i = 0; i < cPropHash && u < ulSize; i++ )
    {
        CPropEntry * ppentryNext;

        for( CPropEntry *ppentryCurr = _aEntries[i];
             0 != ppentryCurr && u < ulSize;
             ppentryCurr = ppentryNext )
        {
            ppentryNext = ppentryCurr->Next();
            ppPropEntries[u++] = ppentryCurr;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Note:   all of the following names MUST BE IN UPPERCASE
//
//----------------------------------------------------------------------------

const SPropEntry aStaticList[] =
{
  // Storage Propset

  { 0, L"DIRECTORY",       L"Directory",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)2 },  50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"CLASSID",         L"ClassId",         {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  36, TRUE,  TRUE, DBTYPE_GUID              },
  { 0, L"FILEINDEX",       L"FileIndex",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)8 },   8, TRUE,  TRUE, DBTYPE_UI8               },
  { 0, L"USN",             L"USN",             {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)9 },   8, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"FILENAME",        L"Filename",        {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)10 }, 15, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"PATH",            L"Path",            {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)11 }, 50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"SIZE",            L"Size",            {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)12 }, 12, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"ATTRIB",          L"Attrib",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)13 },  7, TRUE,  TRUE, DBTYPE_UI4               },
  { 0, L"WRITE",           L"Write",           {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)14 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"CREATE",          L"Create",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)15 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"ACCESS",          L"Access",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)16 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"ALLOCSIZE",       L"AllocSize",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)18 }, 11, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"CONTENTS",        L"Contents",        {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)19 },  0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"SHORTFILENAME",   L"ShortFilename",   {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)20 }, 12, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Query Propset

  { 0, L"RANKVECTOR",      L"RankVector",      {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)2 }, 20, TRUE, TRUE, DBTYPE_UI4|DBTYPE_VECTOR },
  { 0, L"RANK",            L"Rank",            {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  7, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"HITCOUNT",        L"HitCount",        {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)4 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"WORKID",          L"WorkId",          {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)5 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"ALL",             L"All",             {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)6 },  0, FALSE,TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  // Don't export! { L"UNFILTERED", L"Unfiltered", {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)7 },  1, TRUE, TRUE, DBTYPE_BOOL            },
  { 0, L"VPATH",           L"VPath",           {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)9 }, 50, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Property Sets for Documents

  { 0, L"DOCTITLE",        L"DocTitle",        {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_TITLE },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCSUBJECT",      L"DocSubject",      {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_SUBJECT },  10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCAUTHOR",       L"DocAuthor",       {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_AUTHOR },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCKEYWORDS",     L"DocKeywords",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_KEYWORDS }, 25, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCCOMMENTS",     L"DocComments",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_COMMENTS }, 25, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCTEMPLATE",     L"DocTemplate",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_TEMPLATE },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCLASTAUTHOR",   L"DocLastAuthor",   {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTAUTHOR },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCREVNUMBER",    L"DocRevNumber",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_REVNUMBER },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCEDITTIME",     L"DocEditTime",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_EDITTIME },     10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCLASTPRINTED",  L"DocLastPrinted",  {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTPRINTED },  10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCCREATEDTM",    L"DocCreatedTm",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_CREATE_DTM },   10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCLASTSAVEDTM",  L"DocLastSavedTm",  {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTSAVE_DTM},  10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCPAGECOUNT",    L"DocPageCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_PAGECOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCWORDCOUNT",    L"DocWordCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_WORDCOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCCHARCOUNT",    L"DocCharCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_CHARCOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCTHUMBNAIL",    L"DocThumbnail",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_THUMBNAIL },    10, TRUE, TRUE, VT_CF                    },
  { 0, L"DOCAPPNAME",      L"DocAppName",      {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_APPNAME },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCSECURITY",     L"DocSecurity",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_DOC_SECURITY }, 10, TRUE, TRUE, DBTYPE_I4                },

  { 0, L"DOCCATEGORY",     L"DocCategory",     {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)2 },  10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCPRESENTATIONTARGET", L"DocPresentationTarget",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)3 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCBYTECOUNT",    L"DocByteCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)4 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCLINECOUNT",    L"DocLineCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)5 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCPARACOUNT",    L"DocParaCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)6 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCSLIDECOUNT",   L"DocSlideCount",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)7 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCNOTECOUNT",    L"DocNoteCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)8 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCHIDDENCOUNT",  L"DocHiddenCount",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)9 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCPARTTITLES",   L"DocPartTitles",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)13 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_VECTOR },
  { 0, L"DOCMANAGER",      L"DocManager",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)14 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCCOMPANY",      L"DocCompany",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)15 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },

  // HTML properities

  { 0, L"HTMLHREF",        L"HtmlHref",        {HTMLUrl, DBKIND_GUID_NAME, L"A.HREF" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"A_HREF",          L"A_Href",          {HTMLUrl, DBKIND_GUID_NAME, L"A.HREF" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"IMG_ALT",         L"Img_Alt",         {HTMLGuid, DBKIND_GUID_NAME, L"IMG.ALT" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING1",    L"HtmlHeading1",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x3 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING2",    L"HtmlHeading2",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x4 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING3",    L"HtmlHeading3",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x5 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING4",    L"HtmlHeading4",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x6 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING5",    L"HtmlHeading5",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x7 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING6",    L"HtmlHeading6",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x8 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Document characterization

  { 0, L"CHARACTERIZATION",L"Characterization",  {DocCharacterGuid, DBKIND_GUID_PROPID, (LPWSTR)2}, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // NNTP Properties (obsolete now)

  { 0, L"NEWSGROUP",       L"NewsGroup",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroup) },         0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSGROUPS",      L"NewsGroups",       {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroups) },        0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSREFERENCES",  L"NewsReferences",   {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReferences) },    0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSSUBJECT",     L"NewsSubject",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsSubject) },       0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSFROM",        L"NewsFrom",         {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsFrom) },          0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSMSGID",       L"NewsMsgId",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsMsgid) },         0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSDATE",        L"NewsDate",         {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsDate) },          0, FALSE, TRUE, VT_FILETIME              },
  { 0, L"NEWSRECEIVEDDATE",L"NewsReceivedDate", {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReceivedDate) },  0, FALSE, TRUE, VT_FILETIME              },
  { 0, L"NEWSARTICLEID",   L"NewsArticleId",    {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsArticleid) },     0, FALSE, TRUE, DBTYPE_UI4               },

  // Mime properties (duplicates of NNTP properties).

  { 0, L"MSGNEWSGROUP",   L"MsgNewsgroup",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroup) },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGNEWSGROUPS",  L"MsgNewsgroups",     {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroups) },       10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGREFERENCES",  L"MsgReferences",     {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReferences) },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGSUBJECT",     L"MsgSubject",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsSubject) },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGFROM",        L"MsgFrom",           {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsFrom) },         10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGMESSAGEID",   L"MsgMessageID",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsMsgid) },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGDATE",        L"MsgDate",           {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsDate) },         10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"MSGRECEIVEDDATE",L"MsgReceivedDate",   {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReceivedDate) }, 10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"MSGARTICLEID",   L"MsgArticleID",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsArticleid) },    10, TRUE, TRUE, DBTYPE_UI4               },

  // Media Summary Information property set

  { 0, L"MEDIAEDITOR",      L"MediaEditor",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_EDITOR },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASUPPLIER",    L"MediaSupplier",    {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SUPPLIER },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASOURCE",      L"MediaSource",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SOURCE },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASEQUENCE_NO", L"MediaSequence_No", {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SEQUENCE_NO }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIAPROJECT",     L"MediaProject",     {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_PROJECT },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASTATUS",      L"MediaStatus",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_STATUS },       6, TRUE, TRUE, DBTYPE_UI4                 },
  { 0, L"MEDIAOWNER",       L"MediaOwner",       {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_OWNER },       10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIARATING",      L"MediaRating",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_RATING },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIAPRODUCTION",  L"MediaProduction",  {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_PRODUCTION },  19, TRUE, TRUE, VT_FILETIME                },

  // Music property set

  { 0, L"MUSICARTIST",    L"MusicArtist",    {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_ARTIST },      20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICSONGTITLE", L"MusicSongTitle", {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_SONGTITLE },   20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICALBUM",     L"MusicAlbum",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_ALBUM },       20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICYEAR",      L"MusicYear",      {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_YEAR },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICCOMMENT",   L"MusicComment",   {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_COMMENT },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICTRACK",     L"MusicTrack",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_TRACK },       15, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"MUSICGENRE",     L"MusicGenre",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_GENRE }, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Digital Rights Management

  { 0, L"DRMLICENSE",     L"DrmLicense",     {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PROTECTED },   20, TRUE, TRUE, DBTYPE_BOOL },
  { 0, L"DRMDESCRIPTION", L"DrmDescription", {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_DESCRIPTION }, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"DRMPLAYCOUNT",   L"DrmPlayCount",   {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYCOUNT },   20, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"DRMPLAYSTARTS",  L"DrmPlayStarts",  {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYSTARTS },  20, TRUE, TRUE, VT_FILETIME },
  { 0, L"DRMPLAYEXPIRES", L"DrmPlayExpires", {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYEXPIRES }, 20, TRUE, TRUE, VT_FILETIME },

  // Image property set

  { 0, L"IMAGEFILETYPE",     L"ImageFileType",     {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_FILETYPE },     10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"IMAGECX",           L"ImageCx",           {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_CX },           10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGECY",           L"ImageCy",           {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_CY },           10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGERESOLUTIONX",  L"ImageResolutionX",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_RESOLUTIONX },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGERESOLUTIONY",  L"ImageResolutionY",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_RESOLUTIONY },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEBITDEPTH",     L"ImageBitDepth",     {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_BITDEPTH },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGECOLORSPACE",   L"ImageColorSpace",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_COLORSPACE },   10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },  
  { 0, L"IMAGECOMPRESSION",  L"ImageCompression",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_COMPRESSION },  10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },   
  { 0, L"IMAGETRANSPARENCY", L"ImageTransparency", {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_TRANSPARENCY }, 10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEGAMMAVALUE",   L"ImageGammaValue",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_GAMMAVALUE },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEFRAMECOUNT",   L"ImageFrameCount",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_FRAMECOUNT },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEDIMENSIONS",   L"ImageDimensions",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_DIMENSIONS },   10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },

  // Audio property set

  { 0, L"AUDIOFORMAT",       L"AudioFormat",       {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_FORMAT },        10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"AUDIOTIMELENGTH",   L"AudioTimeLength",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_TIMELENGTH },    10, TRUE, TRUE, DBTYPE_UI8 },
  { 0, L"AUDIOAVGDATARATE",  L"AudioAvgDataRate",  {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_AVG_DATA_RATE }, 10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOSAMPLERATE",   L"AudioSampleRate",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_SAMPLE_RATE },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOSAMPLESIZE",   L"AudioSampleSize",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_SAMPLE_SIZE },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOCHANNELCOUNT", L"AudioChannelCount", {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_CHANNEL_COUNT }, 10, TRUE, TRUE, DBTYPE_UI4 },

  // Video property set

  { 0, L"VIDEOSTREAMNAME",   L"VideoStreamName",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_STREAM_NAME },    10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"VIDEOFRAMEWIDTH",   L"VideoFrameWidth",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_WIDTH },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMEHEIGHT",  L"VideoFrameHeight", {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_HEIGHT },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOTIMELENGTH",   L"VideoTimeLength",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_TIMELENGTH },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMECOUNT",   L"VideoFrameCount",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_COUNT },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMERATE",    L"VideoFrameRate",   {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_RATE },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEODATARATE",     L"VideoDataRate",    {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_DATA_RATE },      10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOSAMPLESIZE",   L"VideoSampleSize",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_SAMPLE_SIZE },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOCOMPRESSION",  L"VideoCompression", {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_COMPRESSION },    10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
};

const unsigned cCiGlobalTypes = sizeof(aStaticList) /
                                sizeof(aStaticList[0]);

const unsigned CStaticPropertyList::cStaticPropEntries = cCiGlobalTypes;

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
SCODE CStaticPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                         ULONG ulMaxCount)
{
    if (0 == ppPropEntries)
        return E_INVALIDARG;

    ULONG ulSize = min (ulMaxCount, GetCount());

    for ( unsigned i = 0; i < ulSize; i++ )
        ppPropEntries[i] = (CPropEntry *) & aStaticList[i];

    return S_OK;
} //GetAllEntries

//
// NOTE: Use tplist.cxx (build tplist) to generate the table below,
//       and be sure to update cStaticPropHash and the hash function
//       (if it changed)
//

const CPropEntry * CStaticPropertyList::_aStaticEntries[] =
{
    0,    // 0
    0,    // 1
    0,    // 2
    0,    // 3
    0,    // 4
    0,    // 5
    0,    // 6
    0,    // 7
    0,    // 8
    0,    // 9
    0,    // 10
    0,    // 11
    0,    // 12
    0,    // 13
    0,    // 14
    0,    // 15
    0,    // 16
    0,    // 17
    0,    // 18
    0,    // 19
    0,    // 20
    0,    // 21
    0,    // 22
    0,    // 23
    0,    // 24
    0,    // 25
    0,    // 26
    0,    // 27
    (CPropEntry *) &aStaticList[72],    // 28 'MSGFROM'
    0,    // 29
    0,    // 30
    0,    // 31
    0,    // 32
    0,    // 33
    0,    // 34
    0,    // 35
    0,    // 36
    0,    // 37
    0,    // 38
    0,    // 39
    0,    // 40
    0,    // 41
    0,    // 42
    0,    // 43
    0,    // 44
    0,    // 45
    0,    // 46
    0,    // 47
    0,    // 48
    0,    // 49
    0,    // 50
    0,    // 51
    0,    // 52
    0,    // 53
    0,    // 54
    0,    // 55
    0,    // 56
    0,    // 57
    0,    // 58
    0,    // 59
    0,    // 60
    0,    // 61
    0,    // 62
    0,    // 63
    0,    // 64
    0,    // 65
    0,    // 66
    (CPropEntry *) &aStaticList[123],    // 67 'VIDEOSAMPLESIZE'
    0,    // 68
    0,    // 69
    0,    // 70
    0,    // 71
    0,    // 72
    0,    // 73
    (CPropEntry *) &aStaticList[38],    // 74 'DOCCATEGORY'
    0,    // 75
    0,    // 76
    0,    // 77
    (CPropEntry *) &aStaticList[20],    // 78 'DOCTITLE'
    0,    // 79
    0,    // 80
    0,    // 81
    0,    // 82
    0,    // 83
    0,    // 84
    0,    // 85
    0,    // 86
    (CPropEntry *) &aStaticList[75],    // 87 'MSGRECEIVEDDATE'
    0,    // 88
    0,    // 89
    0,    // 90
    0,    // 91
    0,    // 92
    0,    // 93
    0,    // 94
    0,    // 95
    0,    // 96
    0,    // 97
    0,    // 98
    0,    // 99
    0,    // 100
    (CPropEntry *) &aStaticList[7],    // 101 'ATTRIB'
    0,    // 102
    0,    // 103
    0,    // 104
    0,    // 105
    0,    // 106
    (CPropEntry *) &aStaticList[48],    // 107 'DOCCOMPANY'
    0,    // 108
    0,    // 109
    0,    // 110
    0,    // 111
    0,    // 112
    (CPropEntry *) &aStaticList[59],    // 113 'NEWSGROUP'
    (CPropEntry *) &aStaticList[81],    // 114 'MEDIAPROJECT'
    0,    // 115
    0,    // 116
    0,    // 117
    0,    // 118
    0,    // 119
    0,    // 120
    0,    // 121
    0,    // 122
    0,    // 123
    0,    // 124
    0,    // 125
    0,    // 126
    0,    // 127
    0,    // 128
    0,    // 129
    0,    // 130
    0,    // 131
    0,    // 132
    0,    // 133
    0,    // 134
    0,    // 135
    0,    // 136
    (CPropEntry *) &aStaticList[99],    // 137 'IMAGECX'
    0,    // 138
    (CPropEntry *) &aStaticList[100],    // 139 'IMAGECY'
    0,    // 140
    0,    // 141
    0,    // 142
    0,    // 143
    0,    // 144
    0,    // 145
    0,    // 146
    0,    // 147
    0,    // 148
    0,    // 149
    0,    // 150
    0,    // 151
    0,    // 152
    0,    // 153
    0,    // 154
    0,    // 155
    0,    // 156
    0,    // 157
    0,    // 158
    0,    // 159
    0,    // 160
    0,    // 161
    (CPropEntry *) &aStaticList[31],    // 162 'DOCLASTSAVEDTM'
    0,    // 163
    0,    // 164
    0,    // 165
    0,    // 166
    0,    // 167
    0,    // 168
    0,    // 169
    0,    // 170
    0,    // 171
    0,    // 172
    0,    // 173
    0,    // 174
    0,    // 175
    0,    // 176
    0,    // 177
    0,    // 178
    0,    // 179
    0,    // 180
    0,    // 181
    0,    // 182
    0,    // 183
    0,    // 184
    (CPropEntry *) &aStaticList[64],    // 185 'NEWSMSGID'
    (CPropEntry *) &aStaticList[82],    // 186 'MEDIASTATUS'
    0,    // 187
    0,    // 188
    0,    // 189
    0,    // 190
    (CPropEntry *) &aStaticList[77],    // 191 'MEDIAEDITOR'
    0,    // 192
    (CPropEntry *) &aStaticList[104],    // 193 'IMAGECOLORSPACE'
    0,    // 194
    0,    // 195
    0,    // 196
    (CPropEntry *) &aStaticList[44],    // 197 'DOCNOTECOUNT'
    0,    // 198
    0,    // 199
    0,    // 200
    (CPropEntry *) &aStaticList[103],    // 201 'IMAGEBITDEPTH'
    0,    // 202
    0,    // 203
    0,    // 204
    0,    // 205
    0,    // 206
    0,    // 207
    0,    // 208
    0,    // 209
    0,    // 210
    0,    // 211
    0,    // 212
    0,    // 213
    (CPropEntry *) &aStaticList[45],    // 214 'DOCHIDDENCOUNT'
    0,    // 215
    0,    // 216
    0,    // 217
    0,    // 218
    0,    // 219
    0,    // 220
    0,    // 221
    0,    // 222
    0,    // 223
    (CPropEntry *) &aStaticList[112],    // 224 'AUDIOAVGDATARATE'
    0,    // 225
    (CPropEntry *) &aStaticList[76],    // 226 'MSGARTICLEID'
    0,    // 227
    0,    // 228
    0,    // 229
    (CPropEntry *) &aStaticList[79],    // 230 'MEDIASOURCE'
    0,    // 231
    0,    // 232
    (CPropEntry *) &aStaticList[70],    // 233 'MSGREFERENCES'
    0,    // 234
    0,    // 235
    0,    // 236
    0,    // 237
    0,    // 238
    0,    // 239
    0,    // 240
    0,    // 241
    0,    // 242
    0,    // 243
    0,    // 244
    0,    // 245
    0,    // 246
    0,    // 247
    0,    // 248
    0,    // 249
    0,    // 250
    0,    // 251
    0,    // 252
    (CPropEntry *) &aStaticList[50],    // 253 'A_HREF'
    0,    // 254
    0,    // 255
    0,    // 256
    (CPropEntry *) &aStaticList[67],    // 257 'NEWSARTICLEID'
    0,    // 258
    0,    // 259
    0,    // 260
    0,    // 261
    0,    // 262
    (CPropEntry *) &aStaticList[46],    // 263 'DOCPARTTITLES'
    0,    // 264
    0,    // 265
    0,    // 266
    0,    // 267
    0,    // 268
    0,    // 269
    0,    // 270
    0,    // 271
    0,    // 272
    0,    // 273
    0,    // 274
    0,    // 275
    0,    // 276
    0,    // 277
    0,    // 278
    0,    // 279
    0,    // 280
    (CPropEntry *) &aStaticList[47],    // 281 'DOCMANAGER'
    0,    // 282
    0,    // 283
    0,    // 284
    0,    // 285
    0,    // 286
    0,    // 287
    0,    // 288
    0,    // 289
    0,    // 290
    0,    // 291
    0,    // 292
    0,    // 293
    (CPropEntry *) &aStaticList[61],    // 294 'NEWSREFERENCES'
    0,    // 295
    0,    // 296
    0,    // 297
    0,    // 298
    0,    // 299
    0,    // 300
    0,    // 301
    0,    // 302
    0,    // 303
    0,    // 304
    0,    // 305
    0,    // 306
    0,    // 307
    0,    // 308
    (CPropEntry *) &aStaticList[37],    // 309 'DOCSECURITY'
    0,    // 310
    0,    // 311
    0,    // 312
    0,    // 313
    0,    // 314
    0,    // 315
    0,    // 316
    0,    // 317
    0,    // 318
    (CPropEntry *) &aStaticList[24],    // 319 'DOCCOMMENTS'
    0,    // 320
    0,    // 321
    0,    // 322
    (CPropEntry *) &aStaticList[88],    // 323 'MUSICALBUM'
    0,    // 324
    0,    // 325
    0,    // 326
    0,    // 327
    (CPropEntry *) &aStaticList[66],    // 328 'NEWSRECEIVEDDATE'
    0,    // 329
    0,    // 330
    0,    // 331
    0,    // 332
    0,    // 333
    0,    // 334
    0,    // 335
    0,    // 336
    0,    // 337
    0,    // 338
    0,    // 339
    0,    // 340
    0,    // 341
    0,    // 342
    0,    // 343
    0,    // 344
    0,    // 345
    0,    // 346
    0,    // 347
    0,    // 348
    0,    // 349
    (CPropEntry *) &aStaticList[34],    // 350 'DOCCHARCOUNT'
    0,    // 351
    0,    // 352
    0,    // 353
    0,    // 354
    0,    // 355
    0,    // 356
    0,    // 357
    0,    // 358
    0,    // 359
    0,    // 360
    0,    // 361
    0,    // 362
    0,    // 363
    0,    // 364
    0,    // 365
    0,    // 366
    0,    // 367
    0,    // 368
    0,    // 369
    0,    // 370
    0,    // 371
    0,    // 372
    0,    // 373
    0,    // 374
    0,    // 375
    0,    // 376
    0,    // 377
    0,    // 378
    0,    // 379
    0,    // 380
    0,    // 381
    0,    // 382
    0,    // 383
    (CPropEntry *) &aStaticList[60],    // 384 'NEWSGROUPS'
    0,    // 385
    0,    // 386
    (CPropEntry *) &aStaticList[52],    // 387 'HTMLHEADING1'
    0,    // 388
    (CPropEntry *) &aStaticList[53],    // 389 'HTMLHEADING2'
    0,    // 390
    (CPropEntry *) &aStaticList[54],    // 391 'HTMLHEADING3'
    0,    // 392
    (CPropEntry *) &aStaticList[55],    // 393 'HTMLHEADING4'
    0,    // 394
    (CPropEntry *) &aStaticList[56],    // 395 'HTMLHEADING5'
    0,    // 396
    (CPropEntry *) &aStaticList[57],    // 397 'HTMLHEADING6'
    0,    // 398
    0,    // 399
    0,    // 400
    0,    // 401
    0,    // 402
    0,    // 403
    0,    // 404
    0,    // 405
    0,    // 406
    0,    // 407
    0,    // 408
    0,    // 409
    0,    // 410
    0,    // 411
    0,    // 412
    0,    // 413
    0,    // 414
    0,    // 415
    0,    // 416
    0,    // 417
    0,    // 418
    0,    // 419
    0,    // 420
    0,    // 421
    0,    // 422
    0,    // 423
    0,    // 424
    0,    // 425
    0,    // 426
    0,    // 427
    0,    // 428
    0,    // 429
    0,    // 430
    0,    // 431
    0,    // 432
    0,    // 433
    0,    // 434
    0,    // 435
    0,    // 436
    0,    // 437
    0,    // 438
    0,    // 439
    0,    // 440
    0,    // 441
    0,    // 442
    0,    // 443
    0,    // 444
    0,    // 445
    0,    // 446
    0,    // 447
    0,    // 448
    0,    // 449
    0,    // 450
    0,    // 451
    0,    // 452
    0,    // 453
    0,    // 454
    0,    // 455
    0,    // 456
    0,    // 457
    0,    // 458
    0,    // 459
    0,    // 460
    0,    // 461
    0,    // 462
    0,    // 463
    0,    // 464
    0,    // 465
    0,    // 466
    0,    // 467
    0,    // 468
    0,    // 469
    0,    // 470
    (CPropEntry *) &aStaticList[92],    // 471 'MUSICGENRE'
    0,    // 472
    0,    // 473
    (CPropEntry *) &aStaticList[12],    // 474 'CONTENTS'
    0,    // 475
    0,    // 476
    0,    // 477
    0,    // 478
    0,    // 479
    0,    // 480
    0,    // 481
    0,    // 482
    0,    // 483
    0,    // 484
    0,    // 485
    0,    // 486
    0,    // 487
    0,    // 488
    (CPropEntry *) &aStaticList[111],    // 489 'AUDIOTIMELENGTH'
    0,    // 490
    0,    // 491
    0,    // 492
    0,    // 493
    0,    // 494
    0,    // 495
    (CPropEntry *) &aStaticList[106],    // 496 'IMAGETRANSPARENCY'
    0,    // 497
    0,    // 498
    0,    // 499
    0,    // 500
    0,    // 501
    0,    // 502
    0,    // 503
    0,    // 504
    0,    // 505
    0,    // 506
    0,    // 507
    0,    // 508
    0,    // 509
    0,    // 510
    0,    // 511
    0,    // 512
    0,    // 513
    0,    // 514
    0,    // 515
    0,    // 516
    0,    // 517
    0,    // 518
    0,    // 519
    0,    // 520
    0,    // 521
    0,    // 522
    0,    // 523
    0,    // 524
    0,    // 525
    0,    // 526
    0,    // 527
    0,    // 528
    0,    // 529
    0,    // 530
    0,    // 531
    0,    // 532
    0,    // 533
    0,    // 534
    0,    // 535
    0,    // 536
    0,    // 537
    0,    // 538
    0,    // 539
    0,    // 540
    0,    // 541
    0,    // 542
    0,    // 543
    0,    // 544
    0,    // 545
    (CPropEntry *) &aStaticList[40],    // 546 'DOCBYTECOUNT'
    0,    // 547
    0,    // 548
    0,    // 549
    0,    // 550
    0,    // 551
    (CPropEntry *) &aStaticList[33],    // 552 'DOCWORDCOUNT'
    0,    // 553
    0,    // 554
    0,    // 555
    0,    // 556
    0,    // 557
    0,    // 558
    0,    // 559
    0,    // 560
    0,    // 561
    (CPropEntry *) &aStaticList[35],    // 562 'DOCTHUMBNAIL'
    0,    // 563
    0,    // 564
    0,    // 565
    (CPropEntry *) &aStaticList[10],    // 566 'ACCESS'
    0,    // 567
    0,    // 568
    0,    // 569
    0,    // 570
    0,    // 571
    0,    // 572
    0,    // 573
    0,    // 574
    0,    // 575
    0,    // 576
    0,    // 577
    (CPropEntry *) &aStaticList[78],    // 578 'MEDIASUPPLIER'
    0,    // 579
    0,    // 580
    0,    // 581
    0,    // 582
    0,    // 583
    0,    // 584
    0,    // 585
    0,    // 586
    0,    // 587
    0,    // 588
    0,    // 589
    0,    // 590
    0,    // 591
    0,    // 592
    0,    // 593
    0,    // 594
    0,    // 595
    0,    // 596
    0,    // 597
    0,    // 598
    0,    // 599
    (CPropEntry *) &aStaticList[62],    // 600 'NEWSSUBJECT'
    0,    // 601
    0,    // 602
    (CPropEntry *) &aStaticList[108],    // 603 'IMAGEFRAMECOUNT'
    0,    // 604
    0,    // 605
    0,    // 606
    0,    // 607
    0,    // 608
    0,    // 609
    0,    // 610
    0,    // 611
    0,    // 612
    0,    // 613
    0,    // 614
    0,    // 615
    0,    // 616
    0,    // 617
    0,    // 618
    0,    // 619
    0,    // 620
    0,    // 621
    0,    // 622
    0,    // 623
    0,    // 624
    0,    // 625
    (CPropEntry *) &aStaticList[93],    // 626 'DRMLICENSE'
    0,    // 627
    (CPropEntry *) &aStaticList[83],    // 628 'MEDIAOWNER'
    0,    // 629
    0,    // 630
    0,    // 631
    0,    // 632
    0,    // 633
    0,    // 634
    0,    // 635
    0,    // 636
    0,    // 637
    0,    // 638
    0,    // 639
    0,    // 640
    0,    // 641
    0,    // 642
    0,    // 643
    (CPropEntry *) &aStaticList[29],    // 644 'DOCLASTPRINTED'
    0,    // 645
    0,    // 646
    0,    // 647
    0,    // 648
    0,    // 649
    0,    // 650
    0,    // 651
    0,    // 652
    0,    // 653
    0,    // 654
    0,    // 655
    0,    // 656
    0,    // 657
    0,    // 658
    0,    // 659
    0,    // 660
    0,    // 661
    (CPropEntry *) &aStaticList[115],    // 662 'AUDIOCHANNELCOUNT'
    0,    // 663
    0,    // 664
    0,    // 665
    0,    // 666
    0,    // 667
    0,    // 668
    0,    // 669
    0,    // 670
    0,    // 671
    0,    // 672
    0,    // 673
    0,    // 674
    0,    // 675
    0,    // 676
    0,    // 677
    (CPropEntry *) &aStaticList[122],    // 678 'VIDEODATARATE'
    0,    // 679
    0,    // 680
    0,    // 681
    (CPropEntry *) &aStaticList[120],    // 682 'VIDEOFRAMECOUNT'
    0,    // 683
    0,    // 684
    0,    // 685
    0,    // 686
    0,    // 687
    0,    // 688
    0,    // 689
    0,    // 690
    (CPropEntry *) &aStaticList[39],    // 691 'DOCPRESENTATIONTARGET'
    0,    // 692
    0,    // 693
    0,    // 694
    0,    // 695
    0,    // 696
    0,    // 697
    0,    // 698
    0,    // 699
    0,    // 700
    0,    // 701
    0,    // 702
    0,    // 703
    0,    // 704
    0,    // 705
    0,    // 706
    0,    // 707
    0,    // 708
    (CPropEntry *) &aStaticList[51],    // 709 'IMG_ALT'
    0,    // 710
    0,    // 711
    0,    // 712
    0,    // 713
    0,    // 714
    0,    // 715
    0,    // 716
    0,    // 717
    0,    // 718
    0,    // 719
    (CPropEntry *) &aStaticList[113],    // 720 'AUDIOSAMPLERATE'
    0,    // 721
    0,    // 722
    0,    // 723
    0,    // 724
    0,    // 725
    0,    // 726
    0,    // 727
    0,    // 728
    0,    // 729
    0,    // 730
    0,    // 731
    0,    // 732
    0,    // 733
    0,    // 734
    0,    // 735
    0,    // 736
    0,    // 737
    0,    // 738
    0,    // 739
    0,    // 740
    0,    // 741
    0,    // 742
    0,    // 743
    0,    // 744
    0,    // 745
    0,    // 746
    0,    // 747
    0,    // 748
    0,    // 749
    0,    // 750
    0,    // 751
    0,    // 752
    (CPropEntry *) &aStaticList[14],    // 753 'RANKVECTOR'
    0,    // 754
    0,    // 755
    0,    // 756
    (CPropEntry *) &aStaticList[49],    // 757 'HTMLHREF'
    (CPropEntry *) &aStaticList[21],    // 758 'DOCSUBJECT'
    0,    // 759
    0,    // 760
    0,    // 761
    (CPropEntry *) &aStaticList[101],    // 762 'IMAGERESOLUTIONX'
    0,    // 763
    (CPropEntry *) &aStaticList[102],    // 764 'IMAGERESOLUTIONY'
    0,    // 765
    0,    // 766
    0,    // 767
    0,    // 768
    0,    // 769
    0,    // 770
    0,    // 771
    0,    // 772
    0,    // 773
    0,    // 774
    0,    // 775
    0,    // 776
    0,    // 777
    0,    // 778
    0,    // 779
    0,    // 780
    0,    // 781
    0,    // 782
    0,    // 783
    0,    // 784
    0,    // 785
    0,    // 786
    0,    // 787
    (CPropEntry *) &aStaticList[73],    // 788 'MSGMESSAGEID'
    0,    // 789
    0,    // 790
    0,    // 791
    0,    // 792
    0,    // 793
    0,    // 794
    0,    // 795
    (CPropEntry *) &aStaticList[97],    // 796 'DRMPLAYEXPIRES'
    0,    // 797
    (CPropEntry *) &aStaticList[110],    // 798 'AUDIOFORMAT'
    0,    // 799
    (CPropEntry *) &aStaticList[22],    // 800 'DOCAUTHOR'
    0,    // 801
    (CPropEntry *) &aStaticList[41],    // 802 'DOCLINECOUNT'
    0,    // 803
    0,    // 804
    0,    // 805
    0,    // 806
    0,    // 807
    0,    // 808
    0,    // 809
    0,    // 810
    0,    // 811
    0,    // 812
    0,    // 813
    (CPropEntry *) &aStaticList[80],    // 814 'MEDIASEQUENCE_NO'
    0,    // 815
    0,    // 816
    0,    // 817
    0,    // 818
    0,    // 819
    0,    // 820
    0,    // 821
    0,    // 822
    0,    // 823
    (CPropEntry *) &aStaticList[114],    // 824 'AUDIOSAMPLESIZE'
    0,    // 825
    0,    // 826
    0,    // 827
    0,    // 828
    0,    // 829
    0,    // 830
    0,    // 831
    (CPropEntry *) &aStaticList[85],    // 832 'MEDIAPRODUCTION'
    0,    // 833
    0,    // 834
    0,    // 835
    0,    // 836
    0,    // 837
    0,    // 838
    0,    // 839
    0,    // 840
    (CPropEntry *) &aStaticList[26],    // 841 'DOCLASTAUTHOR'
    0,    // 842
    0,    // 843
    0,    // 844
    (CPropEntry *) &aStaticList[25],    // 845 'DOCTEMPLATE'
    (CPropEntry *) &aStaticList[28],    // 846 'DOCEDITTIME'
    0,    // 847
    0,    // 848
    0,    // 849
    0,    // 850
    0,    // 851
    0,    // 852
    0,    // 853
    0,    // 854
    0,    // 855
    0,    // 856
    0,    // 857
    0,    // 858
    0,    // 859
    0,    // 860
    0,    // 861
    0,    // 862
    0,    // 863
    0,    // 864
    0,    // 865
    0,    // 866
    0,    // 867
    0,    // 868
    (CPropEntry *) &aStaticList[27],    // 869 'DOCREVNUMBER'
    (CPropEntry *) &aStaticList[109],    // 870 'IMAGEDIMENSIONS'
    (CPropEntry *) &aStaticList[43],    // 871 'DOCSLIDECOUNT'
    (CPropEntry *) &aStaticList[105],    // 872 'IMAGECOMPRESSION'
    0,    // 873
    0,    // 874
    0,    // 875
    0,    // 876
    0,    // 877
    0,    // 878
    0,    // 879
    0,    // 880
    0,    // 881
    0,    // 882
    0,    // 883
    0,    // 884
    0,    // 885
    (CPropEntry *) &aStaticList[69],    // 886 'MSGNEWSGROUPS'
    0,    // 887
    0,    // 888
    0,    // 889
    0,    // 890
    0,    // 891
    0,    // 892
    0,    // 893
    0,    // 894
    0,    // 895
    0,    // 896
    0,    // 897
    0,    // 898
    0,    // 899
    0,    // 900
    0,    // 901
    0,    // 902
    0,    // 903
    (CPropEntry *) &aStaticList[1],    // 904 'CLASSID'
    0,    // 905
    0,    // 906
    0,    // 907
    0,    // 908
    0,    // 909
    0,    // 910
    0,    // 911
    0,    // 912
    0,    // 913
    0,    // 914
    0,    // 915
    0,    // 916
    0,    // 917
    0,    // 918
    0,    // 919
    0,    // 920
    0,    // 921
    0,    // 922
    0,    // 923
    0,    // 924
    0,    // 925
    0,    // 926
    0,    // 927
    0,    // 928
    0,    // 929
    0,    // 930
    0,    // 931
    0,    // 932
    0,    // 933
    0,    // 934
    0,    // 935
    0,    // 936
    0,    // 937
    0,    // 938
    0,    // 939
    0,    // 940
    0,    // 941
    0,    // 942
    (CPropEntry *) &aStaticList[91],    // 943 'MUSICTRACK'
    0,    // 944
    0,    // 945
    (CPropEntry *) &aStaticList[0],    // 946 'DIRECTORY'
    0,    // 947
    0,    // 948
    0,    // 949
    0,    // 950
    0,    // 951
    0,    // 952
    0,    // 953
    0,    // 954
    0,    // 955
    0,    // 956
    (CPropEntry *) &aStaticList[96],    // 957 'DRMPLAYSTARTS'
    0,    // 958
    0,    // 959
    0,    // 960
    0,    // 961
    0,    // 962
    0,    // 963
    0,    // 964
    0,    // 965
    0,    // 966
    0,    // 967
    0,    // 968
    0,    // 969
    0,    // 970
    0,    // 971
    0,    // 972
    (CPropEntry *) &aStaticList[5],    // 973 'PATH'
    0,    // 974
    0,    // 975
    0,    // 976
    0,    // 977
    (CPropEntry *) &aStaticList[13],    // 978 'SHORTFILENAME'
    (CPropEntry *) &aStaticList[18],    // 979 'ALL'
    0,    // 980
    0,    // 981
    0,    // 982
    0,    // 983
    0,    // 984
    0,    // 985
    0,    // 986
    (CPropEntry *) &aStaticList[15],    // 987 'RANK'
    0,    // 988
    (CPropEntry *) &aStaticList[84],    // 989 'MEDIARATING'
    0,    // 990
    0,    // 991
    (CPropEntry *) &aStaticList[23],    // 992 'DOCKEYWORDS'
    0,    // 993
    0,    // 994
    0,    // 995
    0,    // 996
    0,    // 997
    0,    // 998
    0,    // 999
    0,    // 1000
    0,    // 1001
    0,    // 1002
    0,    // 1003
    0,    // 1004
    (CPropEntry *) &aStaticList[94],    // 1005 'DRMDESCRIPTION'
    0,    // 1006
    0,    // 1007
    0,    // 1008
    0,    // 1009
    0,    // 1010
    0,    // 1011
    0,    // 1012
    0,    // 1013
    0,    // 1014
    0,    // 1015
    0,    // 1016
    0,    // 1017
    0,    // 1018
    0,    // 1019
    (CPropEntry *) &aStaticList[16],    // 1020 'HITCOUNT'
    (CPropEntry *) &aStaticList[68],    // 1021 'MSGNEWSGROUP'
    0,    // 1022
    0,    // 1023
    0,    // 1024
    (CPropEntry *) &aStaticList[121],    // 1025 'VIDEOFRAMERATE'
    0,    // 1026
    0,    // 1027
    0,    // 1028
    0,    // 1029
    (CPropEntry *) &aStaticList[124],    // 1030 'VIDEOCOMPRESSION'
    0,    // 1031
    0,    // 1032
    0,    // 1033
    0,    // 1034
    (CPropEntry *) &aStaticList[98],    // 1035 'IMAGEFILETYPE'
    0,    // 1036
    0,    // 1037
    0,    // 1038
    0,    // 1039
    0,    // 1040
    (CPropEntry *) &aStaticList[90],    // 1041 'MUSICCOMMENT'
    0,    // 1042
    (CPropEntry *) &aStaticList[119],    // 1043 'VIDEOTIMELENGTH'
    0,    // 1044
    0,    // 1045
    0,    // 1046
    0,    // 1047
    0,    // 1048
    0,    // 1049
    0,    // 1050
    0,    // 1051
    0,    // 1052
    0,    // 1053
    0,    // 1054
    0,    // 1055
    0,    // 1056
    0,    // 1057
    (CPropEntry *) &aStaticList[42],    // 1058 'DOCPARACOUNT'
    0,    // 1059
    0,    // 1060
    0,    // 1061
    (CPropEntry *) &aStaticList[89],    // 1062 'MUSICYEAR'
    0,    // 1063
    0,    // 1064
    0,    // 1065
    0,    // 1066
    0,    // 1067
    0,    // 1068
    0,    // 1069
    0,    // 1070
    0,    // 1071
    0,    // 1072
    0,    // 1073
    0,    // 1074
    0,    // 1075
    0,    // 1076
    0,    // 1077
    0,    // 1078
    0,    // 1079
    0,    // 1080
    0,    // 1081
    0,    // 1082
    0,    // 1083
    0,    // 1084
    0,    // 1085
    0,    // 1086
    0,    // 1087
    0,    // 1088
    0,    // 1089
    (CPropEntry *) &aStaticList[117],    // 1090 'VIDEOFRAMEWIDTH'
    0,    // 1091
    0,    // 1092
    0,    // 1093
    0,    // 1094
    (CPropEntry *) &aStaticList[65],    // 1095 'NEWSDATE'
    0,    // 1096
    0,    // 1097
    0,    // 1098
    0,    // 1099
    0,    // 1100
    0,    // 1101
    0,    // 1102
    (CPropEntry *) &aStaticList[6],    // 1103 'SIZE'
    (CPropEntry *) &aStaticList[19],    // 1104 'VPATH'
    0,    // 1105
    0,    // 1106
    0,    // 1107
    0,    // 1108
    (CPropEntry *) &aStaticList[87],    // 1109 'MUSICSONGTITLE'
    0,    // 1110
    0,    // 1111
    0,    // 1112
    0,    // 1113
    0,    // 1114
    0,    // 1115
    0,    // 1116
    0,    // 1117
    0,    // 1118
    0,    // 1119
    0,    // 1120
    0,    // 1121
    0,    // 1122
    0,    // 1123
    0,    // 1124
    0,    // 1125
    0,    // 1126
    0,    // 1127
    0,    // 1128
    0,    // 1129
    0,    // 1130
    0,    // 1131
    0,    // 1132
    0,    // 1133
    0,    // 1134
    0,    // 1135
    0,    // 1136
    0,    // 1137
    0,    // 1138
    0,    // 1139
    0,    // 1140
    0,    // 1141
    0,    // 1142
    0,    // 1143
    0,    // 1144
    0,    // 1145
    0,    // 1146
    0,    // 1147
    0,    // 1148
    0,    // 1149
    (CPropEntry *) &aStaticList[9],    // 1150 'CREATE'
    0,    // 1151
    0,    // 1152
    0,    // 1153
    0,    // 1154
    0,    // 1155
    (CPropEntry *) &aStaticList[2],    // 1156 'FILEINDEX'
    (CPropEntry *) &aStaticList[116],    // 1157 'VIDEOSTREAMNAME'
    0,    // 1158
    0,    // 1159
    (CPropEntry *) &aStaticList[58],    // 1160 'CHARACTERIZATION'
    (CPropEntry *) &aStaticList[4],    // 1161 'FILENAME'
    0,    // 1162
    0,    // 1163
    0,    // 1164
    0,    // 1165
    0,    // 1166
    0,    // 1167
    0,    // 1168
    0,    // 1169
    0,    // 1170
    (CPropEntry *) &aStaticList[3],    // 1171 'USN'
    0,    // 1172
    0,    // 1173
    0,    // 1174
    (CPropEntry *) &aStaticList[74],    // 1175 'MSGDATE'
    0,    // 1176
    0,    // 1177
    0,    // 1178
    0,    // 1179
    0,    // 1180
    0,    // 1181
    0,    // 1182
    0,    // 1183
    0,    // 1184
    0,    // 1185
    0,    // 1186
    0,    // 1187
    0,    // 1188
    0,    // 1189
    0,    // 1190
    0,    // 1191
    0,    // 1192
    0,    // 1193
    0,    // 1194
    0,    // 1195
    0,    // 1196
    0,    // 1197
    0,    // 1198
    0,    // 1199
    0,    // 1200
    0,    // 1201
    0,    // 1202
    0,    // 1203
    0,    // 1204
    0,    // 1205
    0,    // 1206
    0,    // 1207
    0,    // 1208
    0,    // 1209
    0,    // 1210
    0,    // 1211
    0,    // 1212
    (CPropEntry *) &aStaticList[86],    // 1213 'MUSICARTIST'
    0,    // 1214
    0,    // 1215
    0,    // 1216
    (CPropEntry *) &aStaticList[32],    // 1217 'DOCPAGECOUNT'
    0,    // 1218
    0,    // 1219
    0,    // 1220
    0,    // 1221
    (CPropEntry *) &aStaticList[118],    // 1222 'VIDEOFRAMEHEIGHT'
    0,    // 1223
    0,    // 1224
    0,    // 1225
    (CPropEntry *) &aStaticList[8],    // 1226 'WRITE'
    0,    // 1227
    0,    // 1228
    0,    // 1229
    0,    // 1230
    0,    // 1231
    0,    // 1232
    0,    // 1233
    0,    // 1234
    0,    // 1235
    0,    // 1236
    0,    // 1237
    0,    // 1238
    0,    // 1239
    0,    // 1240
    0,    // 1241
    0,    // 1242
    0,    // 1243
    0,    // 1244
    0,    // 1245
    (CPropEntry *) &aStaticList[36],    // 1246 'DOCAPPNAME'
    (CPropEntry *) &aStaticList[71],    // 1247 'MSGSUBJECT'
    0,    // 1248
    0,    // 1249
    0,    // 1250
    0,    // 1251
    0,    // 1252
    0,    // 1253
    0,    // 1254
    0,    // 1255
    0,    // 1256
    0,    // 1257
    0,    // 1258
    (CPropEntry *) &aStaticList[63],    // 1259 'NEWSFROM'
    0,    // 1260
    0,    // 1261
    0,    // 1262
    0,    // 1263
    (CPropEntry *) &aStaticList[95],    // 1264 'DRMPLAYCOUNT'
    (CPropEntry *) &aStaticList[17],    // 1265 'WORKID'
    0,    // 1266
    0,    // 1267
    0,    // 1268
    0,    // 1269
    0,    // 1270
    0,    // 1271
    0,    // 1272
    0,    // 1273
    0,    // 1274
    0,    // 1275
    0,    // 1276
    0,    // 1277
    0,    // 1278
    0,    // 1279
    0,    // 1280
    (CPropEntry *) &aStaticList[30],    // 1281 'DOCCREATEDTM'
    0,    // 1282
    0,    // 1283
    0,    // 1284
    0,    // 1285
    0,    // 1286
    0,    // 1287
    0,    // 1288
    (CPropEntry *) &aStaticList[11],    // 1289 'ALLOCSIZE'
    0,    // 1290
    0,    // 1291
    0,    // 1292
    (CPropEntry *) &aStaticList[107],    // 1293 'IMAGEGAMMAVALUE'
    0,    // 1294
    0,    // 1295
    0,    // 1296
    0,    // 1297
    0,    // 1298
    0,    // 1299
    0,    // 1300
    0,    // 1301
    0,    // 1302
    0,    // 1303
    0,    // 1304
    0,    // 1305
    0,    // 1306
    0,    // 1307
    0,    // 1308
    0,    // 1309
    0,    // 1310
};

BOOL ParseGuid( WCHAR * pUgly, GUID & guid )
{
    //
    // Convert classid string to guid.  Don't use wsscanf.  We're scanning
    // into *bytes*, but wsscanf assumes result locations are *dwords*.
    // Thus a write to the last few bytes of the guid writes over other
    // memory!
    //

    //
    // A GUID MUST be of the form:
    //     XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    //
    //  The guid MUST be 36 characters in length
    //  There MUST be a '-' in the 8th, 13th, & 18th position.
    //  The 1st number MUST be 8 digits long
    //  The 2nd, 3rd & 4th numbers MUST be 4 digits long
    //  The 5th number must be 12 digits long

    if ( (36 != wcslen(pUgly) ) ||
         (L'-' != pUgly[8]) ||
         (L'-' != pUgly[13]) ||
         (L'-' != pUgly[18]) )
    {
        return FALSE;
    }

    WCHAR wc = pUgly[8];
    pUgly[8] = 0;
    WCHAR * pwcStart = &pUgly[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[8] = wc;
    if ( (pwcEnd-pwcStart) != 8 )   // The 1st number MUST be 8 digits long
        return FALSE;

    wc = pUgly[13];
    pUgly[13] = 0;
    pwcStart = &pUgly[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[13] = wc;
    if ( (pwcEnd-pwcStart) != 4 ) //  The 2nd number MUST be 4 digits long
        return FALSE;

    wc = pUgly[18];
    pUgly[18] = 0;
    pwcStart = &pUgly[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[18] = wc;
    if ( (pwcEnd-pwcStart) != 4 ) //  The 3rd number MUST be 4 digits long
        return FALSE;

    wc = pUgly[21];
    pUgly[21] = 0;
    pwcStart = &pUgly[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[21] = wc;
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    wc  = pUgly[23];
    pUgly[23] = 0;
    pwcStart = &pUgly[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[23] = wc;
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = pUgly[26+i*2];
        pUgly[26+i*2] = 0;
        pwcStart = &pUgly[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        pUgly[26+i*2] = wc;
        if ( pwcStart == pwcEnd )
            return FALSE;
    }

    return TRUE;
} //ParseGuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\lgplist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       lgplist.cxx
//
//  Contents:   Index server wide local/global property list class.
//
//  History:    05 May 1997      Alanw    Created
//              27 Aug 1997      KrishnaN Moved from ixsso to querylib
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------

#include <cidebug.hxx>
#include <dynstack.hxx>
#include <funypath.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>

// class declaration

CStaticPropertyList GlobalStaticList;
CPropListFile * CLocalGlobalPropertyList::_pGlobalPropListFile = 0;
CStaticMutexSem g_mtxFilePropList;  // regulates access to the global file prop list.

CRegChangeEvent     CGlobalPropFileRefresher::_regChangeEvent( wcsRegCommonAdminTree, TRUE );
WCHAR               CGlobalPropFileRefresher::_wcsFileName[];
FILETIME            CGlobalPropFileRefresher::_ftFile;
DWORD               CGlobalPropFileRefresher::_dwLastCheckMoment;
BOOL                CGlobalPropFileRefresher::_fInited = FALSE;
HKEY                CGlobalPropFileRefresher::_hKey;
LONG                CGlobalPropFileRefresher::_lRegReturn;

CGlobalPropFileRefresher gRefresher;

//+-------------------------------------------------------------------------
//
//  Member:     CDefColumnRegEntry::CDefColumnRegEntry, public
//
//  Synopsis:   Constructor for registry param object
//
//  Arguments:  [pwcName]    - 0 or name of the catalog from the registry
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

CDefColumnRegEntry::CDefColumnRegEntry()
{
    // set default
    wcscpy( _awcDefaultColumnFile, L"" );

} //CDefColumnRegEntry

//+-------------------------------------------------------------------------
//
//  Member:     CDefColumnRegEntry::Refresh, public
//
//  Synopsis:   Reads the values from the registry
//
//  History:    12-Oct-96 dlee  Added header, reorganized
//
//--------------------------------------------------------------------------

void CDefColumnRegEntry::Refresh( BOOL fUseDefaultsOnFailure )
{
    TRY
    {
        //  Query the registry.

        CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegCommonAdmin );

        XPtrST<WCHAR> xRegValue(regAdmin.Read(wcsDefaultColumnFile, L""));

        wcsncpy( _awcDefaultColumnFile, xRegValue.GetPointer(), MAX_PATH );
    }
    CATCH (CException, e)
    {
        // Only store defaults when told to do so -- the params
        // are still in good shape at this point and are more
        // accurate than the default settings.

        if ( fUseDefaultsOnFailure )
            wcscpy( _awcDefaultColumnFile, L"" );           
    }
    END_CATCH
} //Refresh

//-----------------------------------------------------------------------------
//
//  Member:     CPropListFile::CPropListFile
//
//  Synopsis:   Constructor of a property list from a file
//
//  Arguments:  [pDefaultList]    -- The default property list
//              [fDynamicRefresh] -- True, if list should be dynamically
//                                   refreshed when file changes.
//              [pwcPropFile]     -- The property file.  If this is null,
//                                   use the registry.
//              [ulCodePage]      -- Codepage to interpret the property list.
//
//  Notes:      
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CPropListFile::CPropListFile( CEmptyPropertyList *pDefaultList,
                              BOOL fDynamicRefresh,
                              WCHAR const * pwcPropFile,
                              ULONG ulCodePage ) :
    CCombinedPropertyList(pDefaultList, ulCodePage),
    _scError( S_OK ),
    _iErrorLine( 0 ),
    _xErrorFile( 0 ),
    _ulCodePage( ulCodePage ),
    _fDynamicRefresh( fDynamicRefresh ),
    _dwLastCheckMoment( GetTickCount() )
{
    if (pwcPropFile)
        Load(pwcPropFile);
    else
    {
        WCHAR wszFile[MAX_PATH+1];
        _RegParams.GetDefaultColumnFile( wszFile, MAX_PATH );
        Load(wszFile);
    }
}

CPropListFile::~CPropListFile()
{
    ClearList();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListFile::Load - public
//
//  Synopsis:   Loads the file into the property list.
//
//  Arguments:  [pwszFile] -- File name for property definitions
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

void CPropListFile::Load(WCHAR const * const pwszFile )
{
    if (0 == pwszFile || 0 == *pwszFile)
        return;

    CImpersonateSystem impersonateSystem;

    // prevent multiple loads at the same time

    CLock lock(_mtx);

    // Erase any previous error settings.
    _scError = S_OK;
    _iErrorLine = 0;
    _xErrorFile.Free();

    SCODE sc = GetLastWriteTime(pwszFile, _ftFile);
    if (S_OK == sc)
    {
        // ParseNameFile should not throw exceptions.
        sc = ParseNameFile( pwszFile );
    }
    else
        sc = QPLIST_E_CANT_OPEN_FILE;

    if (FAILED(sc))
    {
        qutilDebugOut(( DEB_WARN, "Can't open column file named %ws\n", pwszFile ));
        _scError = sc;
        _iErrorLine = 0;

        if (0 == _xErrorFile.GetPointer())
        {
            WCHAR * pwcErrorFile = new WCHAR[wcslen(pwszFile)+1];
            wcscpy(pwcErrorFile, pwszFile);
            _xErrorFile.Set( pwcErrorFile );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListFile::IsMapUpToDate - public
//
//  Synopsis:   Determines if the file is still vaid, or if it has
//              changed since it was last read.
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CPropListFile::IsMapUpToDate()
{
    //
    // Has the file been modified since last loaded?
    //
    
    FILETIME ft;
    SCODE sc = GetLastWriteTime(_xFileName.GetPointer(), ft);


    if (FAILED(sc))
        return E_HANDLE;

    if ( (_ftFile.dwLowDateTime == ft.dwLowDateTime) &&
         (_ftFile.dwHighDateTime == ft.dwHighDateTime) )
        return S_OK;
    
    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPropListFile::GetLastWriteTime, static
//
//  Purpose:    Gets the last change time of the file specified
//
//  Arguments:  [wcsFileName] - name of file to get last write time of
//              [ftLastWrite] - on return, last mod. time of file
//
//  Returns:    SCODE - S_OK if successful.
//
//  History:    96/Jan/23   DwightKr    Created
//              96/Mar/13   DwightKr    Changed to use GetFileAttributesEx()
//
//----------------------------------------------------------------------------

SCODE CPropListFile::GetLastWriteTime( WCHAR const * wcsFileName,
                                       FILETIME & ftLastWrite )
{
    if ( 0 == wcsFileName )
        return E_INVALIDARG;

    WIN32_FIND_DATA ffData;

    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        qutilDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));
        return HRESULT_FROM_WIN32(error);
    }

    ftLastWrite = ffData.ftLastWriteTime;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::ParseNameFile, public
//
//  Synopsis:   Parses the given file name and creates a list of 'friendly
//              name' to CDbColId equivalences.
//
//  Arguments:  szFileName -- name of the file to parse
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

SCODE CPropListFile::ParseNameFile( WCHAR const * wcsFileName )
{
    int iLength;
    BOOL fRememberFileName = FALSE;
    
    if( wcsFileName == 0 )
    {
        // use the last specified property file
        if( !_xFileName.IsNull() )
        {
            wcsFileName = _xFileName.GetPointer();
            iLength = wcslen( wcsFileName ) + 1;
        }
        else
            return QPLIST_E_CANT_OPEN_FILE;
    }
    else
    {
        // make a copy of the file name
        _xFileName.Free();

        iLength = wcslen( wcsFileName ) + 1;

        _xFileName.Set( new WCHAR[ iLength ] );

        memcpy( _xFileName.GetPointer(), wcsFileName, iLength * sizeof WCHAR );
    }

    CSFile pfile( OpenFileFromPath( wcsFileName ) );

    if( pfile == 0 )
        return QPLIST_E_CANT_OPEN_FILE;
    
    //
    //  Process a line at a time, skip ahead until we find the [Names]
    //  or [Query] section and process lines within that section only.
    //
    BOOL fNameSection  = FALSE;
    SCODE sc = S_OK;

    int iLine = 0;

    for( ;; )
    {
        TRY
        {
            iLine++;
    
            // line buffers
            char szLine[ MAX_LINE_LENGTH ];
            WCHAR wcsLine[ MAX_LINE_LENGTH ];
    
            if( !fgets( szLine, MAX_LINE_LENGTH, pfile ) )
            {
                if( feof( pfile ) )
                    break;
    
                THROW( CPListException( QPLIST_E_READ_ERROR, iLine ) );
            }
    
            //
            //  Skip ahead until we find a [Names] section
            //
            if ( *szLine == '[' )
            {
                if ( _strnicmp(szLine, "[Names]", 7) == 0 )
                {
                    fNameSection = TRUE;
                    continue;
                }
                else
                {
                    fNameSection = FALSE;
                    continue;
                }
            }
            else if ( *szLine == '#' )
            {
                continue;
            }
    
            if ( fNameSection )
            {
                if( MultiByteToWideChar( _ulCodePage,
                                         MB_COMPOSITE,
                                         szLine,
                                         -1,
                                         wcsLine,
                                         MAX_LINE_LENGTH )
                    == 0 )
                {
                    THROW( CException() );
                }
    
                CQueryScanner scanner( wcsLine, FALSE );
                XPtr<CPropEntry> propentry;
                CPropertyList::ParseOneLine( scanner, iLine, propentry );
                if (propentry.GetPointer())
                {
                    AddEntry( propentry.GetPointer(), iLine );
                    propentry.Acquire();
                }
            }
        }
        CATCH( CPListException, e )
        {
            qutilDebugOut(( DEB_WARN,
                            "Plist exception %08x caught parsing default column file at line %d. Line ignored.\n",
                            e.GetErrorCode(), e.GetLine() ));
            
            sc = _scError = e.GetErrorCode();
            _iErrorLine = e.GetLine();
            fRememberFileName = TRUE;
        }
        AND_CATCH ( CException, e )
        {
            qutilDebugOut(( DEB_WARN,
                            "Exception caught parsing default column file %08x\n",
                            e.GetErrorCode() ));
            sc = _scError = e.GetErrorCode();
            fRememberFileName = TRUE;
        }
        END_CATCH

        if (fRememberFileName && 0 == _xErrorFile.GetPointer())
        {
            fRememberFileName = FALSE;
            WCHAR * pwcErrorFile = new WCHAR[wcslen(wcsFileName)+1];
            wcscpy(pwcErrorFile, wcsFileName);
            _xErrorFile.Set( pwcErrorFile );
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::CheckError, public
//
//  Synopsis:   Checks if there was an error in the parsing of the file.
//
//  Arguments:  iLine  -- error line number returned here.
//              ppFile -- file name returned here. can be 0 if not needed.
//
//  History:    17-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CPropListFile::CheckError( ULONG & iLine, WCHAR ** ppFile )
{
    iLine = _iErrorLine;
    if (ppFile)
        *ppFile = _xErrorFile.GetPointer();
    return _scError;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::Refresh, private
//
//  Synopsis:   Reloads the property list if prop. file has been modified.
//
//  History:    15-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CPropListFile::Refresh()
{
    if (!_fDynamicRefresh)
        return;
    
    // Don't check more than once in a few seconds
    if (abs(GetTickCount() - _dwLastCheckMoment) < REFRESH_INTERVAL)
        return;
    _dwLastCheckMoment = GetTickCount();

    if (S_OK != IsMapUpToDate())
    {
        //
        // Reload.
        //

        ClearList();
        Load(_xFileName.GetPointer());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//              28-Aug-97   KrishnaN    modified.
//
//----------------------------------------------------------------------------

CPropEntry const * CCombinedPropertyList::Find( WCHAR const * wcsName )
{
    if( 0 == wcsName )
        return 0;

    //
    // First look in the default list, and if not found, look
    // in the overrides.
    //

    CPropEntry const * ppentry = _xDefaultList->Find(wcsName);
    if (ppentry)
        return ppentry;

    return (_xOverrideList.GetPointer() ? _xOverrideList->Find(wcsName) : 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    21-Jul-97   dlee  Moved from .hxx and added header
//
//----------------------------------------------------------------------------

CPropEntry const * CCombinedPropertyList::Next()
{
    //
    // First look in the static list, and if not found, look in the overrides.
    //

    CPropEntry const *pEntry = 0;

    if (!_fOverrides)
        pEntry = _xDefaultList->Next();
    
    if (pEntry)
        return pEntry;

    _fOverrides = TRUE;
    return (_xOverrideList.GetPointer() ? _xOverrideList->Next() : 0);
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::InitIterator()
{
    // causes the default list to be iterated before the overrides

    _fOverrides = FALSE;

    // Initialize the iterators of the two lists

    _xDefaultList->InitIterator();

    if (_xOverrideList.GetPointer())
        _xOverrideList->InitIterator();
} //InitIterator

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the overriding list.  Verifies that the name
//              isn't already in the default list or the overriding list.
//
//  Arguments:  ppentryNew -- pointer to the CPropEntry to add
//              iLine      -- line number we're parsing
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::AddEntry( CPropEntry * ppentryNew, int iLine )
{
    // protect _xOverrideList
    CLock lock(_mtxAdd);

    if (0 == _xOverrideList.GetPointer())
    {
        _xOverrideList.Set(new CPropertyList(_ulCodePage));
    }

    //
    // We do not allow entries in the override list that have the same name
    // as the default list.
    //

    if( _xDefaultList->Find( ppentryNew->GetName() ) ||
        _xOverrideList->Find( ppentryNew->GetName() ) )
        THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );

    _xOverrideList->AddEntry(ppentryNew, iLine);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::ClearList, public
//
//  Synopsis:   Frees the memory used by the list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::ClearList()
{
    // protect _xOverrideList
    CLock lock(_mtxAdd);

    //
    // Just free it now. It will be created, if necessary,
    // on AddEntry().
    //

    _xOverrideList.Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::SetDefaultList, public
//
//  Synopsis:   Sets the default list.
//
//  Arguments:  pDefaultList -- The list to set as default list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::SetDefaultList(CEmptyPropertyList *pDefaultList)
{
    Win4Assert(pDefaultList);

    // Jettison any existing property list
    _xDefaultList.Free();

    _xDefaultList.Set(pDefaultList);
    pDefaultList->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::GetCount, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
ULONG CCombinedPropertyList::GetCount()
{
    ULONG ulTotal = _xDefaultList->GetCount();
    if (_xOverrideList.GetPointer())
    {
        ulTotal += _xOverrideList->GetCount();
    }

    return ulTotal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
SCODE CCombinedPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                           ULONG ulMaxCount)
{
    ULONG ulSize = _xDefaultList->GetCount();
    // get the first set of entries from the default list
    SCODE sc = _xDefaultList->GetAllEntries(ppPropEntries, min(ulSize, ulMaxCount));

    // get the remaining entries from the override list
    if (S_OK == sc && ulMaxCount > ulSize && _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetAllEntries(ppPropEntries+ulSize, ulMaxCount-ulSize);
    }

    return sc;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CLocalGlobalPropertyList
//
//  Synopsis:   Constructor of a overridable file based property list.
//              The file name will always be obtained through the registry.
//
//  Arguments:  [ulCodePage] -- Codepage to interpret the property list.
//
//  Notes:      
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CLocalGlobalPropertyList::CLocalGlobalPropertyList( ULONG ulCodePage ) :
    CCombinedPropertyList(ulCodePage),
    _ulCodePage( ulCodePage ),
    _dwLastCheckMoment( GetTickCount() ),
    _mtx()
{
    XInterface<CPropListFile> xPropListFile(GetGlobalPropListFile());
    SetDefaultList(xPropListFile.GetPointer());
}

//-----------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CLocalGlobalPropertyList
//
//  Synopsis:   Constructor of a overridable file based property list.
//              The file name will always be obtained through the registry.
//
//  Arguments:  [pDefaultList]    -- The default property list
//              [fDynamicRefresh] -- True, if list should be dynamically
//                                   refreshed when file changes.
//              [pwcPropFile]     -- The property file. If this is null,
//                                   use the registry.
//              [ulCodePage]      -- Codepage to interpret the property list.
//
//  Notes: This constructor is used by clients who use their own file based
//         list instead of using the registry based file.
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CLocalGlobalPropertyList::CLocalGlobalPropertyList
                             (CEmptyPropertyList *pDefaultList,
                              BOOL fDynamicRefresh,
                              WCHAR const * pwcsPropFile,
                              ULONG ulCodePage) :
    CCombinedPropertyList(ulCodePage),
    _ulCodePage( ulCodePage ),
    _dwLastCheckMoment( GetTickCount() ),
    _mtx()
{
    XInterface<CPropListFile> xPropListFile(
                                new CPropListFile(pDefaultList,
                                                  fDynamicRefresh,
                                                  pwcsPropFile,
                                                  ulCodePage));
    SetDefaultList(xPropListFile.GetPointer());
}


//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::IsMapUpToDate - public
//
//  Synopsis:   Determines if the file is still valid, or if it has
//              changed since it was last read.
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CLocalGlobalPropertyList::IsMapUpToDate()
{
    ULONG cchRequired = _RegParams.GetDefaultColumnFile( 0, 0 );
    WCHAR wszFile[MAX_PATH + 1];
    wszFile[0] = 0;
    
    if ( 0 != cchRequired )
    {
        _RegParams.GetDefaultColumnFile( wszFile, MAX_PATH );
    }

    //
    // If the current file and the one in the registry are not the same,
    // we are outdated.
    //

    if (0 != _wcsicmp(_xFileName.GetPointer(), wszFile))
        return S_FALSE;

    //
    // The filelist takes care of file modifications, so ask it
    // directly if it is up to date.
    //

    return GetDefaultList().IsMapUpToDate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CheckError, public
//
//  Synopsis:   Checks if there was an error in the parsing of the file.
//
//  Arguments:  iLine  -- error line number returned here.
//              ppFile -- file name returned here. can be 0 if not needed.
//
//  History:    17-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CLocalGlobalPropertyList::CheckError( ULONG & iLine, WCHAR ** ppFile )
{
    return ((CPropListFile &)GetDefaultList()).CheckError(iLine, ppFile);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::Load - public
//
//  Synopsis:   Loads the file into the property list.
//
//  Arguments:  [pwszFile] -- File name for property definitions
//
//  History:    19 Sep 1997     KrishnaN       Created
//
//----------------------------------------------------------------------------

void CLocalGlobalPropertyList::Load(WCHAR const * const pwszFile )
{
    ((CPropListFile &)GetDefaultList()).Load(pwszFile);
}

// Miscellaneous

CStaticPropertyList * GetGlobalStaticPropertyList()
{
    GlobalStaticList.AddRef();
    return &GlobalStaticList;
}

//
// Return an AddRef'd global prop file list. The caller will release
// when done using the global prop file list.
//

CPropListFile * GetGlobalPropListFile()
{
    CLock lock(g_mtxFilePropList);

    if (!CLocalGlobalPropertyList::_pGlobalPropListFile)
    {
        // The global property list will be controlled by CLocalGlobalPropertyList, so
        // we disable its ability to refresh dynamically.
        CLocalGlobalPropertyList::_pGlobalPropListFile =
                     new CPropListFile(GetGlobalStaticPropertyList(), FALSE);
    }
    else
    {
        //
        // If the refresher replaces the global property list, that would
        // AddRef the newly created global proplist, so we should not AddREf
        // again. If DoIt fails, no need to AddRef.
        //
        if (!gRefresher.DoIt())
            CLocalGlobalPropertyList::_pGlobalPropListFile->AddRef();
    }

    Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile);

    return CLocalGlobalPropertyList::_pGlobalPropListFile;
}

//+---------------------------------------------------------------------------
//
//  Member:     CreateNewGlobalPropFileList - public
//
//  Synopsis:   Creates a new global file based property list.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//  Notes: This function replaces the global property file list so that newer
//         clients asking for the list will get an updated list (if the file has
//         been modified or replaced.)
//
//----------------------------------------------------------------------------

void CreateNewGlobalPropFileList(WCHAR CONST *wcsFileName)
{
    CLock lock(g_mtxFilePropList);

    Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile);

    // The global property list will be controlled by CLocalGlobalPropertyList, so
    // we disable its ability to refresh dynamically.
    CLocalGlobalPropertyList::_pGlobalPropListFile =
                           new CPropListFile(GetGlobalStaticPropertyList(),
                                             FALSE,
                                             wcsFileName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlobalPropFileRefresher::DoIt - public
//
//  Synopsis:   Creates a new global file based property list if necessary.
//
//  Returns:    True if refresh happened. False otherwise.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//  Notes:      This function monitors the registry and the file so the list
//              can be updated if the underlying property file changes.
//
//----------------------------------------------------------------------------

BOOL CGlobalPropFileRefresher::DoIt()
{
    //
    // We don't need to lock this because currently it is only
    // being called after obtaining a lock elsewhere. If that
    // changes, then a lock may be needed here.
    //

    // Don't check more than once in a few seconds
    if (abs(GetTickCount() - _dwLastCheckMoment) < REFRESH_INTERVAL)
        return FALSE;
    
    CImpersonateSystem impersonateSystem;

    if (!_fInited)
        Init();
    
    BOOL fRefresh = FALSE;

    _dwLastCheckMoment = GetTickCount();

    // First check the registry, then check the file itself
    ULONG res = WaitForSingleObject( _regChangeEvent.GetEventHandle(), 0 );
    if (WAIT_OBJECT_0 == res)
    {
        _regChangeEvent.Reset();

        // the registry changed, but the value may not have. check that.

        WCHAR wszFile[MAX_PATH];

        GetDefaultColumnFile(wszFile);

        // Are the file names the same?
        if (0 != _wcsicmp(wszFile, _wcsFileName))
        {
            wcscpy(_wcsFileName, wszFile);
            fRefresh = TRUE;
            GetLastWriteTime(_ftFile);
        }
    }

    if (! fRefresh)
    {
        FILETIME ft;
        GetLastWriteTime(ft);
        if ((_ftFile.dwLowDateTime != ft.dwLowDateTime) ||
            (_ftFile.dwHighDateTime != ft.dwHighDateTime) )
        {
            _ftFile = ft;
            fRefresh = TRUE;
        }
    }

    if (fRefresh)
    {
        // refresh

        CreateNewGlobalPropFileList(_wcsFileName);
    }

    return fRefresh;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlobalPropFileRefresher::Init - public
//
//  Synopsis:   Initializes this class.
//
//  Returns:    Nothing. Can throw.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//----------------------------------------------------------------------------

void CGlobalPropFileRefresher::Init()
{
    _regChangeEvent.Init();

    _lRegReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // Root
                             wcsRegCommonAdminSubKey,
                             0,                    // Reserved
                             KEY_READ,             // Access
                             &_hKey);               // Handle

    GetDefaultColumnFile(_wcsFileName);
    GetLastWriteTime(_ftFile);
    
    _fInited = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define COTASKDECLSPEC extern

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <shellapi.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>

#define _CAIROSTG_
#define _DCOM_
// #define OLEDBVER 0x0250 // enable ICommandTree interface
// #define deprecated      // enable IRowsetExactScroll

#include <cidebnot.h>
#include <cierror.h>

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <dbcmdtre.hxx>
#include <query.h>

#include <filterr.h>            // used in webhits!

//
// Query-specific
//

#include <stgprop.h>

#include <restrict.hxx>
#include <stgvar.hxx>
#include <vquery.hxx>

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <cisem.hxx>
#include <dynarray.hxx>
#include <readwrit.hxx>
#include <ci.h>
#include <ci64.hxx>

#include <qutildbg.hxx>

#include <align.hxx>

#include <params.hxx>
#include <tgrow.hxx>
#include <propspec.hxx>
#include <qmemdes.hxx>

#include <dbqrslt.hxx>
#include <tfilt.hxx>

#include <qlibutil.hxx>
#include <parser.hxx>
#include <lgplist.hxx>
#include <scanner.hxx>
#include <plist.hxx>
#include <wcstoi64.hxx>
#include <strrest.hxx>

#include <string.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\parser.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       PARSER.CXX
//
//  Contents:   Implementation of the CQueryParser class
//
//  History:    30-Apr-92   AmyA        Created.
//              23-Jun-92   MikeHew     Added weight parsing.
//              11-May-94   t-jeffc     Rewrote to support new queries;
//                                      added exception handling
//              02-Mar-95   t-colinb    Added CPropertyValueParser and
//                                      augmented the parser to generate
//                                      a CPropertyRestriction with a
//                                      value
//              25-Sep-95   sundarA     Modified relative date calculation;
//                                      Replaced 'c' runtime dependant time
//                                      functions.  Modified 
//                                      CPropertyValueParser::CheckForRelativeDate
//
//  Notes:      See bnf.txt for a complete listing of the grammar.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parser.hxx>

DECLARE_INFOLEVEL(qutil);

static const GUID guidSystem = PSGUID_STORAGE;
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::ParseQueryPhrase, public
//
//  Synopsis:   Parses a query and returns it in the form of a tree.
//
//  Arguments:  - none -
//
//  History:    03 Feb 1998   AlanW       Added error checks
//
//----------------------------------------------------------------------------

CDbRestriction *  CQueryParser::ParseQueryPhrase()
{
    XDbRestriction prstQuery( Query( 0 ) );

    // extraneous input at the end of the query?
    if( !_scan.IsEmpty() )
    {
        SCODE sc = QPARSE_E_EXPECTING_EOS;
        if ( _scan.LookAhead() == NOT_TOKEN )
            sc = QPARSE_E_UNEXPECTED_NOT;
        THROW( CParserException( sc ) );
    }

    return prstQuery.Acquire();
} //ParseQueryPhrase

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::Query, private
//
//  Synopsis:   Recursive function that calls QExpr and creates a vector node
//              if necessary.
//
//  Arguments:  [prstVector] -- if non-null, a Vector node that can be added to.
//
//  Production: Query    : QExpr
//                       | QExpr COMMA_TOKEN Query
//
//  History:    01-May-92   AmyA        Created
//              23-Jun-92   MikeHew     Added weight parsing.
//              10-Feb-93   KyleP       Convert to restrictions
//              11-May-94   t-jeffc     Rewrote to support vectors
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::Query( CDbNodeRestriction * prstVector )
{
    XDbRestriction prstExpr( QExpr( 0 ) );
    unsigned pos;

    if( _scan.LookAhead() == COMMA_TOKEN )
    {
        _scan.Accept();

        if ( prstVector == 0 )
        {
            //
            // Special case: If the first value is a rank method specifier.
            //

            if ( prstExpr->GetCommandType() == DBOP_content )
            {
                CDbContentRestriction * pContent = (CDbContentRestriction *)prstExpr.GetPointer();

                WCHAR const * pPhrase = pContent->GetPhrase();

                if ( pPhrase[0] == L'-')
                {
                    if ( 0 == _wcsicmp( L"--Jaccard--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_JACCARD;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Dice--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_DICE;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Inner--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_INNER;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Max--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_MAX;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Min--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_MIN;
                        delete prstExpr.Acquire();
                    }
                }
            }

            qutilDebugOut(( DEB_TRACE,
                            "setting rank method to: %d\n",
                            _rankMethod ));

            // create smart Vector node

            XDbVectorRestriction prstNew( new CDbVectorRestriction( _rankMethod ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left expression & release its smart pointer
            if ( !prstExpr.IsNull() )
            {
                prstNew->AppendChild( prstExpr.GetPointer() );
                prstExpr.Acquire();
            }

            if ( !prstNew->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // parse right expression

            CDbRestriction * prst = Query( prstNew.GetPointer() );

            // release pointer to the vector node
            prstNew.Acquire();

            return prst;
        }
        else    // there already is a vector node
        {
            // add expression & release its smart pointer
            prstVector->AppendChild( prstExpr.GetPointer() );
            prstExpr.Acquire();

            // parse right expression
            return Query( prstVector );
        }
    }
    else    // no more COMMA_TOKENs
    {
        if( prstVector != 0 )   // add last child
        {
            // add expression & release its smart pointer
            prstVector->AppendChild( prstExpr.GetPointer() );
            prstExpr.Acquire();

            return prstVector;
        }
        else                    // no vector nodes
        {
            // release & return expression
            return prstExpr.Acquire();
        }
    }
} //Query

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QExpr, private
//
//  Synopsis:   Recursive function that calls QTerm and creates an Or
//              node if necessary.
//
//  Arguments:  [prstOr] -- if non-null, an Or node that can be added to.
//
//  Production: QExpr   :   QTerm
//                      |   QTerm OR_TOKEN QExpr
//
//  History:    05-May-94   t-jeffc         Created
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QExpr( CDbBooleanNodeRestriction * prstOr )
{
    XDbRestriction prstTerm( QTerm( 0 ) );

    if ( _scan.LookAhead() == OR_TOKEN )
    {
        _scan.Accept();

        if ( 0 == prstOr )
        {
            // create smart Or node
            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_or ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left term & release its smart pointer
            prstNew->AppendChild( prstTerm.GetPointer() );

            // release smart Or node pointer
            prstTerm.Acquire();

            // parse right expression
            CDbRestriction * prst = QExpr( prstNew.GetPointer() );

            // release smart Or node pointer
            prstNew.Acquire();

            return prst;
        }
        else    // there already is an Or node to add to
        {
            // add left term & release its smart pointer
            prstOr->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // add more children
            return QExpr( prstOr );
        }
    }
    else    // no more OR_TOKENs
    {
        if( prstOr != 0 )   // add last child
        {
            // add term & release its smart pointer
            prstOr->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            return prstOr;
        }
        else                // no OR_TOKENs at all
            // release & return term
            return prstTerm.Acquire();
    }
} //QExpr

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QTerm, private
//
//  Synopsis:   Recursive function that calls QFactor and creates an And
//              node if necessary.
//
//  Arguments:  [prstAnd] -- if non-null, an And node that can be added to.
//
//  Production: QTerm   :   (NOT_TOKEN) QProp (W_OPEN_TOKEN Weight W_CLOSE_TOKEN)
//                      |   (NOT_TOKEN) QProp (W_OPEN_TOKEN Weight W_CLOSE_TOKEN) AND_TOKEN QTerm
//
//  History:    01-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added NOTs; moved weights to this level
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QTerm( CDbBooleanNodeRestriction * prstAnd )
{
    XDbRestriction prstTerm;

    if ( _scan.LookAhead() == NOT_TOKEN )
    {
        _scan.Accept();

        // create smart Not node
        XDbNotRestriction prstNot( new CDbNotRestriction );
        if ( prstNot.IsNull() )
            THROW( CException( E_OUTOFMEMORY ) );

        // parse factor
        XDbRestriction prst( QProp() );

        // set child of Not node & release smart factor pointer
        prstNot->SetChild( prst.GetPointer() );
        prst.Acquire();

        // transfer ownership from prstNot to prstTerm
        prstTerm.Set( prstNot.Acquire() );
    }
    else
    {
        // wrap just the factor in the smart pointer
        prstTerm.Set( QProp() );
    }

    LONG lWeight;
    if( _scan.LookAhead() == W_OPEN_TOKEN )
    {
        _scan.Accept();

        BOOL fAtEnd;
        BOOL isNumber = _scan.GetNumber( lWeight, fAtEnd );

        if( !isNumber )
            THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

        _scan.Accept();

        if( _scan.LookAhead() != W_CLOSE_TOKEN )
            THROW( CParserException( QPARSE_E_EXPECTING_BRACE ) );

        _scan.Accept();

        if ( lWeight > MAX_QUERY_RANK )
            THROW( CParserException( QPARSE_E_WEIGHT_OUT_OF_RANGE ) );
    }
    else
    {
        lWeight = MAX_QUERY_RANK;
    }

    //
    // We should be able to set weights on all the nodes.
    //

    prstTerm->SetWeight( lWeight );

    if ( _scan.LookAhead() == AND_TOKEN )
    {
        _scan.Accept();

        if( 0 == prstAnd )
        {
            // create smart And node
            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_and ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left factor & release its smart pointer
            prstNew->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // parse right expression
            CDbRestriction * prst = QTerm( prstNew.GetPointer() );

            // release smart And node pointer
            prstNew.Acquire();

            return prst;
        }
        else    // there already is an And node to add to
        {
            // add left factor & release its smart pointer
            prstAnd->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // add more children
            return QTerm( prstAnd );
        }
    }
    else    // no more AND_TOKENs
    {
        if( prstAnd != 0 )   // add last child
        {
            // add factor & release its smart pointer
            prstAnd->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            return prstAnd;
        }
        else                // no AND_TOKENs at all
            // release & return factor
            return prstTerm.Acquire();
    }
} //QTerm

//
// array for converting token to relop - this relies on the order
// of the token enumeration in scanner.hxx
//
enum DBOPModifier
{
    DBOPModifyNone = 0,
    DBOPModifyAll  = 1,
    DBOPModifyAny  = 2
};

static const DBCOMMANDOP rgRelopToken[] =
{
    DBOP_equal,
    DBOP_not_equal,
    DBOP_greater,
    DBOP_greater_equal,
    DBOP_less,
    DBOP_less_equal,
    DBOP_allbits,
    DBOP_anybits,

    DBOP_equal_all,
    DBOP_not_equal_all,
    DBOP_greater_all,
    DBOP_greater_equal_all,
    DBOP_less_all,
    DBOP_less_equal_all,
    DBOP_allbits_all,
    DBOP_anybits_all,

    DBOP_equal_any,
    DBOP_not_equal_any,
    DBOP_greater_any,
    DBOP_greater_equal_any,
    DBOP_less_any,
    DBOP_less_equal_any,
    DBOP_allbits_any,
    DBOP_anybits_any,
};

const unsigned cRelopToken = sizeof rgRelopToken / sizeof rgRelopToken[0];

inline DBCOMMANDOP FormDBOP( ULONG op, ULONG opModifier )
{
    Win4Assert( cRelopToken == (SOMEOF_TOKEN+1) * (DBOPModifyAny+1) );
    Win4Assert( op <= SOMEOF_TOKEN );
    Win4Assert( opModifier <= DBOPModifyAny );

    return rgRelopToken[ opModifier*(SOMEOF_TOKEN+1) + op ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QProp, private
//
//  Synopsis:   Allows a prop specification or uses the current property
//              for the following factor.
//
//  Production: QProp : QFactor
//                    | PROP_TOKEN property QFactor
//                    | PROP_REGEX_TOKEN property (EQUAL_TOKEN) REGEX
//                    | PROP_NATLANG_TOKEN property QPhrase
//
//  History:    05-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added regex support and expanded
//                                      property restrictions
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QProp()
{
    XDbRestriction prstFactor;
    XPtrST<WCHAR> wcsProperty;

    switch( _scan.LookAhead() )
    {
    case PROP_TOKEN:
    {
        _scan.Accept();

        // parse property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        // make this property the current one
        SetCurrentProperty( wcsProperty.GetPointer(), CONTENTS );

        prstFactor.Set( QFactor() );
        break;
    }

    case PROP_REGEX_TOKEN:      // process 'PROP_REGEX_TOKEN property regex' rule
    {
        _scan.Accept();

        // get property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        SetCurrentProperty( wcsProperty.GetPointer(), REGEX );

        // allow optional equal token in regex queries

        if ( EQUAL_TOKEN == _scan.LookAhead() )
            _scan.Accept();

        prstFactor.Set( QPhrase() );
        break;
    }

    case PROP_NATLANG_TOKEN:    // process 'PROP_NATLANG_TOKEN property QGroup' rule
         _scan.Accept();

        // get property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        SetCurrentProperty( wcsProperty.GetPointer(), NATLANGUAGE );

        prstFactor.Set( QPhrase() );
        break;

    default:         // No property name
        prstFactor.Set( QFactor() );
        break;

    } // switch( _scan.LookAhead() )

    // release & return smart factor
    return prstFactor.Acquire();
} //QProp

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QFactor, private
//
//  Synopsis:   Calls Query if parentheses are detected.  Processes property
//              query if a PROP_TOKEN, PROP_REGEX_TOKEN or OP_TOKEN are found.
//              Otherwise calls QGroup.
//
//  Production: QFactor  : QGroup
//                       | OPEN_TOKEN Query CLOSE_TOKEN
//                       | OP_TOKEN phrase
//
//  History:    05-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added regex support and expanded
//                                      property restrictions
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QFactor()
{
    XDbRestriction prstFactor;
    XPtrST<WCHAR> wcsProperty;

    switch( _scan.LookAhead() )
    {
    case OPEN_TOKEN:        // process 'OPEN_TOKEN Query CLOSE_TOKEN' rule
    {
        _scan.Accept();

        // save-away the current property so it can be restored after
        // the expression in parenthesis is parsed.

        unsigned cwc = wcslen( GetCurrentProperty() );

        XGrowable<WCHAR, 20> xSaveProp( cwc + 1 );
        wcscpy( xSaveProp.Get(), GetCurrentProperty() );
        PropertyType ptSave = _propType;

        // parse expression
        prstFactor.Set( Query( 0 ) );

        if( _scan.LookAhead() != CLOSE_TOKEN )
        {
            SCODE sc = QPARSE_E_EXPECTING_PAREN;
            if ( _scan.LookAhead() == NOT_TOKEN )
                sc = QPARSE_E_UNEXPECTED_NOT;
            THROW( CParserException( sc ) );
        }

        _scan.Accept();

        SetCurrentProperty( xSaveProp.Get(), ptSave );

        break;
    }

    case EQUAL_TOKEN:           // process 'OP_TOKEN phrase' rule
    case NOT_EQUAL_TOKEN:       // (only if in non-regex mode)
    case GREATER_TOKEN:
    case GREATER_EQUAL_TOKEN:
    case LESS_TOKEN:
    case LESS_EQUAL_TOKEN:
    case ALLOF_TOKEN:
    case SOMEOF_TOKEN:
        if( !IsRegEx() )
        {
            prstFactor.Set( ParsePropertyRst() );
            break;
        }

        // FALL THROUGH

    default:                    // No parentheses or op token
        prstFactor.Set( QGroup( 0 ) );
        break;

    } // switch( _scan.LookAhead() )

    // release & return smart factor
    return prstFactor.Acquire();
} //QFactor

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::ParsePropertyRst, private
//
//  Synopsis:   Parses a relational property restriction and returns
//              a CPropertyRestriction
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Added the parsing of vector properties
//
//----------------------------------------------------------------------------

CDbRestriction * CQueryParser::ParsePropertyRst()
{
    // create smart Property node
    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
    if ( prstProp.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    DBID *pdbid = 0;
    DBTYPE ptype;

    if( FAILED(_xList->GetPropInfoFromName(
                             GetCurrentProperty(),
                             &pdbid,
                             &ptype,
                             0 )) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );

    CDbColId * pps = (CDbColId *)pdbid;
    Win4Assert( 0 != pps && pps->IsValid() );

    if (! prstProp->SetProperty( *pps ) )
        THROW( CException( E_OUTOFMEMORY ) );

    // don't allow @contents <relop> X -- it's too expensive and we'll
    // never find any hits anyway (until we implement this feature)

    if ( *pps == psContents )
        THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

    ULONG op = _scan.LookAhead();
    _scan.Accept();

    ULONG opModifier = DBOPModifyNone;

    //
    // look for a relop modifier like allof or anyof
    //
    switch( _scan.LookAhead() )
    {
        case ALLOF_TOKEN :
            opModifier = DBOPModifyAll;
            _scan.Accept();
            break;
        case SOMEOF_TOKEN :
            opModifier = DBOPModifyAny;
            _scan.Accept();
            break;
    }

    prstProp->SetRelation( FormDBOP( op, opModifier ) );

    switch( _scan.LookAhead() )
    {
    case PROP_TOKEN:
    case PROP_REGEX_TOKEN:  // process 'PROP_TOKEN property OP_TOKEN PROP_TOKEN property' rule
    #if 0
        {
            _scan.Accept();
            THROW( CParserException( QPARSE_E_NOT_YET_IMPLEMENTED ) );
        }
    #endif // 0

    default:                // process 'PROP_TOKEN property OP_TOKEN string' rule
    {

        CPropertyValueParser PropValueParser( _scan, ptype, _locale );

        XPtr<CStorageVariant> pStorageVar( PropValueParser.AcquireStgVariant() );

        if ( 0 != pStorageVar.GetPointer() )
        {
            // This should always be the case  - else PropValueParser would have thrown

            if ( ! ( ( prstProp->SetValue( pStorageVar.GetReference() ) ) &&
                     ( prstProp->IsValid() ) ) )
                THROW( CException( E_OUTOFMEMORY ) );
        }
    }

    } // switch

    // release & return property restriction
    return prstProp.Acquire();
} //ParsePropertyRst
 
//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QGroup, private
//
//  Synopsis:   Recursive function that calls QPhrase and creates a Proximity
//              node if necessary.
//
//  Arguments:  [prstProx] -- if non-null, a Proximity node that can be added to.
//
//  Production: QGroup  :   QPhrase
//                      |   QPhrase PROX_TOKEN QGroup
//
//  History:    04-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QGroup( CDbProximityNodeRestriction * prstProx )
{
    XDbRestriction prst;

    if ( 0 == prstProx )
        prst.Set( QPhrase() );
    else 
        prst.Set( QProp() );

    if( _scan.LookAhead() == PROX_TOKEN )
    {
        _scan.Accept();

        if ( 0 == prstProx )
        {
            // create smart Prox node
            XDbProximityNodeRestriction prstNew(new CDbProximityNodeRestriction());

            if( prstNew.IsNull() || !prstNew->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left phrase & release its smart pointer
            prstNew->AppendChild( prst.GetPointer() );
            prst.Acquire();

            // parse right expression
            CDbRestriction * prst = QGroup( prstNew.GetPointer() );

            // release smart Prox node pointer
            prstNew.Acquire();

            return prst;
        }
        else    // there already is a Prox node to add to
        {
            // add left phrase & release its smart pointer
            prstProx->AppendChild( prst.GetPointer() );
            prst.Acquire();

            // add more children
            return QGroup( prstProx );
        }
    }
    else    // no more PROX_TOKENs
    {
        if( prstProx != 0 )   // add last child
        {
            // add phrase & release its smart pointer
            prstProx->AppendChild( prst.GetPointer() );
            prst.Acquire();

            return prstProx;
        }
        else                // no PROX_TOKENs at all
            // release & return phrase
            return prst.Acquire();
    }
} //QGroup

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QPhrase, private
//
//  Synopsis:   If expecting a content query, acquires the phrase, determines
//              the fuzzy level and creates a ContentRestriction. If expecting
//              a natural language query, acquires the phrase and creates a
//              NatLanguageRestriction. If expecting a regular expression,
//              acquires that from the scanner and creates a new PropertyRestriction.
//
//  Production: QPhrase  : phrase(FUZZY_TOKEN | FUZ2_TOKEN)
//                       | REGEX
//                       | QUOTES_TOKEN extended_phrase(FUZZY_TOKEN | FUZ2_TOKEN)
//
//  History:    01-May-92   AmyA        Created
//              25-May-93   BartoszM    Changed fuzzy syntax
//              10-May-94   t-jeffc     Recognizes regex phrases
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QPhrase()
{
    CDbColId * pps = 0;
    DBID *pdbid = 0;
    DBTYPE dbType;

    if( FAILED(_xList->GetPropInfoFromName( GetCurrentProperty(),
                             &pdbid,
                             &dbType,
                             0 )) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );

    pps = (CDbColId *)pdbid;

    if( IsRegEx() )   // used PROP_REGEX_CHAR to specify property
    {
        if ( ( ( DBTYPE_WSTR|DBTYPE_BYREF ) != dbType ) &&
             ( ( DBTYPE_STR|DBTYPE_BYREF ) != dbType ) &&
             ( VT_BSTR != dbType ) &&
             ( VT_LPWSTR != dbType ) &&
             ( VT_LPSTR != dbType ) )
            THROW( CParserException( QPARSE_E_EXPECTING_REGEX_PROPERTY ) );

        XPtrST<WCHAR> phraseRegEx( _scan.AcqRegEx() );

        if( phraseRegEx.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_REGEX ) );

        _scan.Accept();

        // create smart Property node
        XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
        if ( prstProp.IsNull() )
            THROW( CException( E_OUTOFMEMORY ) );

        prstProp->SetRelation(DBOP_like);      // LIKE relation

        if ( ( ! prstProp->SetProperty( *pps ) ) ||
             ( ! prstProp->SetValue( phraseRegEx.GetPointer() ) ) ||
             ( ! prstProp->IsValid() ) )
            THROW( CException( E_OUTOFMEMORY ) );

        // release & return smart Property node
        return prstProp.Acquire();
    }
    else
    {
        XPtrST<WCHAR> phrase;
        if ( _scan.LookAhead() == QUOTES_TOKEN )
        {
            _scan.AcceptQuote();
            phrase.Set( _scan.AcqPhraseInQuotes() );
        }
        else
            phrase.Set( _scan.AcqPhrase() );

        if( phrase.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        _scan.Accept();

        int fuzzy = 0;
        Token tok = _scan.LookAhead();

        if ( tok == FUZZY_TOKEN )
        {
            _scan.Accept();
            fuzzy = 1;
        }
        else if ( tok == FUZ2_TOKEN )
        {
            _scan.Accept();
            fuzzy = 2;
        }

        if ( _propType == CONTENTS ) // used PROP_TOKEN to specify property
        {
            // create smart Content node

            XDbContentRestriction prstContent( new CDbContentRestriction( phrase.GetPointer(),
                                                                          *pps,
                                                                          fuzzy,
                                                                          _locale ));
            if ( prstContent.IsNull() || !prstContent->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // release & return smart Content node
            return prstContent.Acquire();
        }
        else   // used PROP_NATLANG_TOKEN to specify property
        {
            // create smart Natural Language node

            XDbNatLangRestriction pNatLangRst( new CDbNatLangRestriction( phrase.GetPointer(),
                                                                          *pps,
                                                                          _locale ));
            if ( pNatLangRst.IsNull() || !pNatLangRst->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // release & return smart Natural Language node
            return pNatLangRst.Acquire();
        }
    }
} //QPhrase

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::SetCurrentProperty, private
//
//  Synopsis:   Changes the property used in content and property restrictions
//              from this point on in the input line.
//
//  Arguments:  wcsProperty -- friendly name of property
//                             (can be 0)
//              propType -- specifies the property type
//
//  Notes:      Makes its own copy of the property name
//              (unlike GetCurrentProperty, which just returns a pointer)
//
//  History:    18-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CQueryParser::SetCurrentProperty( WCHAR const * wcsProperty,
                                       PropertyType propType )
{
    delete [] _wcsProperty;
    _wcsProperty = 0;

    if ( 0 != wcsProperty )
    {
        int cwc = wcslen( wcsProperty ) + 1;

        _wcsProperty = new WCHAR[ cwc ];
        RtlCopyMemory( _wcsProperty, wcsProperty, cwc * sizeof WCHAR );
    }

    _propType = propType;
} //SetCurrentProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::CPropertyValueParser, public
//
//  Synopsis:  This constructor reads token from scanner and
//             generates the corresponding CStorageVariant
//
//  History:   02-Mar-95   t-colinb     Created.
//             02-Sep-98   KLam         Added locale
//
//----------------------------------------------------------------------------

CPropertyValueParser::CPropertyValueParser(
    CQueryScanner &scanner,
    DBTYPE PropType,
    LCID locale ) :
        _pStgVariant( 0 ),
        _locale ( locale )
{
    unsigned cElements=0;
    BOOL fParsingVector = (C_OPEN_TOKEN == scanner.LookAhead());

    if ( fParsingVector )
    {
        // this is a vector
        if ( DBTYPE_VECTOR != ( PropType & DBTYPE_VECTOR ) )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        scanner.Accept();
        VARENUM ve = (VARENUM ) PropType;
        if ( PropType == ( DBTYPE_VECTOR | DBTYPE_WSTR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( PropType == ( DBTYPE_VECTOR | DBTYPE_STR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPSTR);

        _pStgVariant.Set( new CStorageVariant( ve, cElements ) );
    }
    else
    {
        // ok to look for singletons with a vector (sometimes)

        _pStgVariant.Set( new CStorageVariant() );
    }

    if ( 0 == _pStgVariant.GetPointer() )
        THROW( CException( E_OUTOFMEMORY ) );

    // first check for an empty vector -- these are legal

    if ( ( fParsingVector ) &&
         ( C_CLOSE_TOKEN == scanner.LookAhead() ) )
    {
        scanner.Accept();
        return;
    }

    BOOL fFinished = FALSE;
    do
    {
        XPtrST<WCHAR> wcsPhrase;

        if ( QUOTES_TOKEN == scanner.LookAhead() )
        {
            // this is a phrase in quotes
            scanner.AcceptQuote();
            wcsPhrase.Set( scanner.AcqPhraseInQuotes()  );
            if ( wcsPhrase.GetPointer() == 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
        }
        else
        {
            wcsPhrase.Set( scanner.AcqPhrase()  );
            if ( wcsPhrase.GetPointer() == 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        }
        scanner.Accept();

        switch ( PropType & ~DBTYPE_VECTOR  )
        {

            case DBTYPE_WSTR :
            case DBTYPE_WSTR | DBTYPE_BYREF :
            {
                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetLPWSTR( wcsPhrase.GetPointer(), cElements );
                else
                    _pStgVariant->SetLPWSTR( wcsPhrase.GetPointer() );

                break;
            }
            case DBTYPE_BSTR :
            {
                BSTR bstr = SysAllocString( wcsPhrase.GetPointer() );

                if ( 0 == bstr )
                    THROW( CException( E_OUTOFMEMORY ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetBSTR( bstr, cElements );
                else
                    _pStgVariant->SetBSTR( bstr );

                SysFreeString( bstr );
                break;
            }
            case DBTYPE_STR :
            case DBTYPE_STR | DBTYPE_BYREF :
            {
                // make sure there's enough room to translate

                unsigned cbBuffer = 1 + 3 * wcslen( wcsPhrase.GetPointer() );
                XArray<char> xBuf( cbBuffer );

                int cc = WideCharToMultiByte( CP_ACP,
                                              0,
                                              wcsPhrase.GetPointer(),
                                              -1,
                                              xBuf.Get(),
                                              cbBuffer,
                                              NULL,
                                              NULL );

                if ( 0 == cc )
                {
                    #if CIDBG
                    ULONG ul = GetLastError();
                    #endif
                    THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
                }

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetLPSTR( xBuf.Get(), cElements );
                else
                    _pStgVariant->SetLPSTR( xBuf.Get() );

                break;
            }

            case DBTYPE_I1 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ( l > SCHAR_MAX ) ||
                     ( l < SCHAR_MIN ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI1( (CHAR) l, cElements );
                else
                    _pStgVariant->SetI1( (CHAR) l );

                break;
            }
            case DBTYPE_UI1 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ul > UCHAR_MAX )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI1( (BYTE) ul, cElements );
                else
                    _pStgVariant->SetUI1( (BYTE) ul );

                break;
            }
            case DBTYPE_I2 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ( l > SHRT_MAX ) ||
                     ( l < SHRT_MIN ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI2( (short) l, cElements );
                else
                    _pStgVariant->SetI2( (short) l );

                break;
            }
            case DBTYPE_UI2 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ul > USHRT_MAX )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI2( (USHORT) ul, cElements );
                else
                    _pStgVariant->SetUI2( (USHORT) ul );

                break;
            }
            case DBTYPE_I4 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI4( l, cElements );
                else
                    _pStgVariant->SetI4( l );

                break;
            }
            case DBTYPE_UI4 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI4( ul, cElements );
                else
                    _pStgVariant->SetUI4( ul );

                break;
            }
            case DBTYPE_ERROR :
            {
                // SCODE/HRESULT are typedefed as long (signed)

                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                SCODE sc = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( sc, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetERROR( sc, cElements );
                else
                    _pStgVariant->SetERROR( sc );

                break;
            }
            case DBTYPE_I8 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                _int64 ll = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ll, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                LARGE_INTEGER LargeInt;
                LargeInt.QuadPart = ll;

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI8( LargeInt, cElements );
                else
                    _pStgVariant->SetI8( LargeInt );

                break;
            }
            case DBTYPE_UI8 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                unsigned _int64 ull = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ull, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                ULARGE_INTEGER LargeInt;
                LargeInt.QuadPart = ull;

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI8( LargeInt, cElements );
                else
                    _pStgVariant->SetUI8( LargeInt );

                break;
            }
            case DBTYPE_BOOL :
            {
                if( wcsPhrase.GetPointer()[0] == 'T' ||
                    wcsPhrase.GetPointer()[0] == 't' )
                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetBOOL( VARIANT_TRUE, cElements );
                    else
                        _pStgVariant->SetBOOL( VARIANT_TRUE );
                else
                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetBOOL( VARIANT_FALSE, cElements );
                    else
                        _pStgVariant->SetBOOL( VARIANT_FALSE );

                break;
            }
            case DBTYPE_R4 :
            {
                WCHAR *pwcEnd = 0;

                float Float = (float)( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetR4( Float, cElements );
                else
                    _pStgVariant->SetR4( Float );

                break;
            }
            case DBTYPE_R8 :
            {
                WCHAR *pwcEnd = 0;
                double Double = ( double )( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetR8( Double, cElements );
                else
                    _pStgVariant->SetR8( Double );

                break;
            }
            case DBTYPE_DECIMAL :
            {
                WCHAR *pwcEnd = 0;
                double Double = ( double )( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                // Vectors are not supported by OLE for VT_DECIMAL (yet)

                Win4Assert( 0 == ( PropType & DBTYPE_VECTOR ) );

                PROPVARIANT * pPropVar = (PROPVARIANT *) _pStgVariant.GetPointer();
                VarDecFromR8( Double, &(pPropVar->decVal) );
                pPropVar->vt = VT_DECIMAL;
                break;
            }
            case DBTYPE_DATE :
            {
                FILETIME ftValue;
                ParseDateTime( wcsPhrase.GetPointer(), ftValue );

                SYSTEMTIME stValue;
                BOOL fOK = FileTimeToSystemTime( &ftValue, &stValue );

                if ( !fOK )
                    THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

                DATE dosDate;
                fOK = SystemTimeToVariantTime( &stValue, &dosDate );

                if ( !fOK )
                    THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetDATE( dosDate, cElements );
                else
                    _pStgVariant->SetDATE( dosDate );

                break;
            }
            case VT_FILETIME :
            {
                FILETIME ftValue;
                ParseDateTime( wcsPhrase.GetPointer(), ftValue );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetFILETIME( ftValue, cElements );
                else
                    _pStgVariant->SetFILETIME( ftValue );

                break;
            }
            case DBTYPE_CY :
            {
                double dbl;

                if( swscanf( wcsPhrase.GetPointer(),
                             L"%lf",
                             &dbl ) < 1 )
                    THROW( CParserException( QPARSE_E_EXPECTING_CURRENCY ) );

                CY cyCurrency;
                VarCyFromR8( dbl, &cyCurrency );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetCY( cyCurrency,  cElements );
                else
                    _pStgVariant->SetCY( cyCurrency );

                break;
            }
            case DBTYPE_GUID :
            case DBTYPE_GUID | DBTYPE_BYREF:
            {
                CLSID clsid;

                if( swscanf( wcsPhrase.GetPointer(),
                             L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                             &clsid.Data1,
                             &clsid.Data2,
                             &clsid.Data3,
                             &clsid.Data4[0], &clsid.Data4[1],
                             &clsid.Data4[2], &clsid.Data4[3],
                             &clsid.Data4[4], &clsid.Data4[5],
                             &clsid.Data4[6], &clsid.Data4[7] ) < 11 )
                    THROW( CParserException( QPARSE_E_EXPECTING_GUID ) );

                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetCLSID( clsid, cElements );
                    else
                        _pStgVariant->SetCLSID( &clsid );
                break;
            }
            default:
            {
                THROW( CParserException( QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ) );
            }
        } // switch

        // make sure memory allocations succeeded

        if ( !_pStgVariant->IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );

        if ( fParsingVector )
        {
            cElements++;
            switch( scanner.LookAhead() )
            {
                case COMMA_TOKEN :
                    scanner.Accept();
                    break;
                case C_CLOSE_TOKEN :
                    scanner.Accept();
                    fFinished = TRUE;
                    break;
                default:
                    THROW( CParserException( QPARSE_E_EXPECTING_COMMA ) );
            }
        }
        else
        {
            fFinished = TRUE;
        }

    } while ( !fFinished );
} //CPropertyValueParser

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::ParseDateTime, private
//
//  Synopsis:   Attempts to parse a date expression.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft     -- reference to the FILETIME structure to fill in
//                        with the result
//
//  History:    31-May-96   dlee       Created
//              23-Jan-97   KyleP      Better Year 2000 support
//              02-Sep-98   KLam       Use user settings for Y2K support
//
//----------------------------------------------------------------------------

void CPropertyValueParser::ParseDateTime(
    WCHAR const * phrase,
    FILETIME & ft )
{
    if( !CheckForRelativeDate( phrase, ft ) )
    {
        SYSTEMTIME stValue = { 0, 0, 0, 0, 0, 0, 0, 0 };

        int cItems = swscanf( phrase,
                              L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if ( 1 == cItems )
            cItems = swscanf( phrase,
                              L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if( cItems != 3 && cItems != 6 && cItems != 7)
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

        //
        // Make a sensible split for Year 2000 using the user's system settings
        //

        if ( stValue.wYear < 100 )
        {
            DWORD dwYearHigh = 0;
            if ( 0 == GetCalendarInfo ( _locale,
                                       CAL_GREGORIAN,
                                       CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                       0,
                                       0,
                                       &dwYearHigh ) )
            {
                THROW ( CException ( ) );
            }

            if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                dwYearHigh = 2029;

            WORD wMaxDecade = (WORD) dwYearHigh % 100;
            WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
            if ( stValue.wYear <= wMaxDecade )
                stValue.wYear += wMaxCentury;
            else
                stValue.wYear += ( wMaxCentury - 100 );
        }

        if( !SystemTimeToFileTime( &stValue, &ft ) )
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
    }
} //ParseDateTime

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::CheckForRelativeDate, static
//
//  Synopsis:   Attempts to parse a relative date expression.  If successful,
//              it fills in the FILETIME structure with the calculated
//              absolute date.
//
//  Notes:      Returns TRUE if the phrase is recognized as a relative
//              date (i.e., it begins with a '-').  Otherwise, returns FALSE.
//              The format of a relative date is
//              "-"{INTEGER("h"|"n"|"s"|"y"|"q"|"m"|"d"|"w")}*
//              Case is not significant.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft -- reference to the FILETIME structure to fill in
//                      with the result
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Moved from CQueryParser to
//                                      be more accessible
//              22-Jan-97   KyleP       Fix local/UTC discrepancy
//              25-Sep-98   sundarA     Removed dependency on 'c' runtime 
//                                      functions for time.
//----------------------------------------------------------------------------

BOOL CPropertyValueParser::CheckForRelativeDate(
    WCHAR const * phrase,
    FILETIME & ft )
{
    if( *phrase++ == L'-' )
    {
        SYSTEMTIME st;
        LARGE_INTEGER liLocal;
        LONGLONG llTicksInADay = ((LONGLONG)10000000) * ((LONGLONG)3600)
                                 * ((LONGLONG) 24);
        LONGLONG llTicksInAHour = ((LONGLONG) 10000000) * ((LONGLONG)3600);
        int iMonthDays[12]  = {1,-1,1,0,1,0,1,1,0,1,0,1};
        int iLoopValue, iPrevMonth, iPrevQuarter, iQuarterOffset;
        WORD wYear, wDayOfMonth, wStartDate;
        
        //
        //Obtain system time and convert it to file time
        //Copy the filetime to largeint data struct
        //

        GetSystemTime(&st);
        if(!SystemTimeToFileTime(&st, &ft))
            THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        LONGLONG llRelDate = (LONGLONG)0;
        for( ;; )
        {
            // eat white space
            while( iswspace( *phrase ) )
                phrase++;

            if( *phrase == 0 ) break;

            // parse the number
            WCHAR * pwcEnd;
            LONG lValue = wcstol( phrase, &pwcEnd, 10 );

            if( lValue < 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            // eat white space
            phrase = pwcEnd;
            while( iswspace( *phrase ) )
                phrase++;

            // grab the unit char & subtract the appropriate amount
            WCHAR wcUnit = *phrase++;
            switch( wcUnit )
            {
            case L'y':
            case L'Y':
                lValue *= 4;
                // Fall through and handle year like 4 quarters 

            case L'q':
            case L'Q':
                lValue *= 3;
                // Fall through and handle quarters like 3 months
                
            case L'm':
            case L'M':
                 // Getting the System time to determine the day and month.

                if(!FileTimeToSystemTime(&ft, &st))
                {
                    THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                }
                wStartDate = st.wDay;
                wDayOfMonth = st.wDay;
                iLoopValue = lValue;
                while(iLoopValue)
                {
                    // Subtracting to the end of previous month 
                    llRelDate = llTicksInADay * ((LONGLONG)(wDayOfMonth));
                    liLocal.QuadPart -= llRelDate;
                    ft.dwLowDateTime = liLocal.LowPart;
                    ft.dwHighDateTime = liLocal.HighPart;
                    SYSTEMTIME stTemp;
                    if(!FileTimeToSystemTime(&ft, &stTemp))
                    {
                         THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                    }
                    //
                    // if the end of previous month is greated then start date then we subtract to back up to the 
                    // start date.  This will take care of 28/29 Feb(backing from 30/31 by 1 month).
                    //
                    if(stTemp.wDay > wStartDate)
                    {
                        llRelDate = llTicksInADay * ((LONGLONG)(stTemp.wDay - wStartDate));
                        liLocal.QuadPart -= llRelDate;
                        ft.dwLowDateTime = liLocal.LowPart;
                        ft.dwHighDateTime = liLocal.HighPart;
                        // Getting the date into stTemp for further iteration
                        if(!FileTimeToSystemTime(&ft, &stTemp))
                        {
                           THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
                        }
                    } 
                    wDayOfMonth = stTemp.wDay;
                    iLoopValue--;
                } //End While
               
                break;

            case L'w':
            case L'W':
                lValue *= 7;

            case L'd':
            case L'D':
                llRelDate = llTicksInADay * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'h':
            case L'H':
                llRelDate = llTicksInAHour * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'n':
            case L'N':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)60)
                            * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L's':
            case L'S':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)lValue);               
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;                 
                break;

            default:
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
            }

        } // for( ;; )
        FileTimeToSystemTime(&ft, &st);
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        qutilDebugOut(( DEB_ERROR,
                            "Low part : %d ; High part ; %d \n",
                            liLocal.LowPart, liLocal.HighPart ));
        qutilDebugOut(( DEB_ERROR,
                            "64 bit number %I64d \n",
                            liLocal.QuadPart ));
        qutilDebugOut(( DEB_ERROR,
                            "st.Year  %d ; month %d ; day %d ; hour %d ; min %d ; sec %d ; msec %d \n",
                            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
} //CheckForRelativeDate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\scanner.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1994-1998, Microsoft Corporation.
//
//  File:   SCANNER.CXX
//
//  Contents:   Implementation of CQueryScanner
//
//  History:    22-May-92   AmyA        Created.
//              23-Jun-92   MikeHew     Added weight token recognition.
//              17-May-94   t-jeffc     Added error info and reg ex support.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::CQueryScanner, public
//
//  Synopsis:   Create a scanner from a string.
//
//  Arguments:  [buffer] -- the string to be scanned.
//              [fLookForTextualKeywords] -- TRUE if the scanner should
//                                           look for "and/or/not/near" in
//                                           text form.
//              [lcid]   -- language for and/or/not/near detection
//              [fTreatPlusAsToken] -- TRUE if the scanner should treat the
//                                           '+' character as a token (used
//                                           in GroupBy parsing)
//
//  Notes:      This string is not copied, so the scanner does not own it.
//              If the string is changed outside of the scanner, it will
//              affect the information that is returned.
//
//  History:    30-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

CQueryScanner::CQueryScanner(
    WCHAR const * buffer,
    BOOL fLookForTextualKeywords,
    LCID lcid,
    BOOL fTreatPlusAsToken )
    : _text( buffer ),
      _pBuf( buffer ),
      _pLookAhead( buffer ),
      _fLookForTextualKeywords( fLookForTextualKeywords ),
      _fTreatPlusAsToken( fTreatPlusAsToken ),
      _lcid( lcid )
{
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptWord, public
//
//  Synopsis:   Consumes a single word out of a phrase
//
//  Requires:   Should be called after AcqWord
//
//  History:    15-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CQueryScanner::AcceptWord()
{
    _pLookAhead = _text;
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptColumn, public
//
//  Synopsis:   Consumes a column name out of a phrase
//
//  Requires:   Should be called after AcqColumn
//
//  History:    15-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CQueryScanner::AcceptColumn()
{
    AcceptWord();
}


struct SStringToken
{
    WCHAR *  pwcToken;
    unsigned cwc;
    Token    token;
};

static SStringToken s_EnglishStringTokens[] =
{
    { L"AND",    (sizeof L"AND" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"OR",     (sizeof L"OR" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"NOT",    (sizeof L"NOT" / sizeof WCHAR) - 1,    NOT_TOKEN },
    { L"NEAR",   (sizeof L"NEAR" / sizeof WCHAR) - 1,   PROX_TOKEN },
};

static SStringToken s_GermanStringTokens[] =
{
    { L"UND",    (sizeof L"UND" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"ODER",   (sizeof L"ODER" / sizeof WCHAR) - 1,   OR_TOKEN },
    { L"NICHT",  (sizeof L"NICHT" / sizeof WCHAR) - 1,  NOT_TOKEN },
    { L"NAH",    (sizeof L"NAH" / sizeof WCHAR) - 1,    PROX_TOKEN },
};

static SStringToken s_FrenchStringTokens[] =
{
    { L"ET",     (sizeof L"ET" / sizeof WCHAR) - 1,     AND_TOKEN },
    { L"OU",     (sizeof L"OU" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"SANS",   (sizeof L"SANS" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { L"PRES",   (sizeof L"PRES" / sizeof WCHAR) - 1,   PROX_TOKEN },
};

static SStringToken s_SpanishStringTokens[] =
{
    { L"Y",      (sizeof L"Y" / sizeof WCHAR) - 1,      AND_TOKEN },
    { L"O",      (sizeof L"O" / sizeof WCHAR) - 1,      OR_TOKEN },
    { L"NO",     (sizeof L"NO" / sizeof WCHAR) - 1,     NOT_TOKEN },
    { L"CERCA",  (sizeof L"CERCA" / sizeof WCHAR) - 1,  PROX_TOKEN },
};

static SStringToken s_DutchStringTokens[] =
{
    { L"EN",     (sizeof L"EN" / sizeof WCHAR) - 1,     AND_TOKEN },
    { L"OF",     (sizeof L"OF" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"NIET",   (sizeof L"NIET" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { L"NABIJ",  (sizeof L"NABIJ" / sizeof WCHAR) - 1,  PROX_TOKEN },
};

static WCHAR aSwedishNear[] = { L'N', 0xc4, L'R', L'A', 0 };

static SStringToken s_SwedishStringTokens[] =
{
    { L"OCH",    (sizeof L"OCH" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"ELLER",  (sizeof L"ELLER" / sizeof WCHAR) - 1,  OR_TOKEN },
    { L"INTE",   (sizeof L"INTE" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { aSwedishNear, 4,                                  PROX_TOKEN },
};

static SStringToken s_ItalianStringTokens[] =
{
    { L"E",      (sizeof L"E" / sizeof WCHAR) - 1,      AND_TOKEN },
    { L"O",      (sizeof L"O" / sizeof WCHAR) - 1,      OR_TOKEN },
    { L"NO",     (sizeof L"NO" / sizeof WCHAR) - 1,     NOT_TOKEN },
    { L"VICINO", (sizeof L"VICINO" / sizeof WCHAR) - 1, PROX_TOKEN },
};

const unsigned cStringTokens = sizeof(s_EnglishStringTokens) /
                               sizeof(s_EnglishStringTokens[0]);

#define WORD_STR  L"{}!&|~*@#()[],\t=<>\n\"^ "

//+---------------------------------------------------------------------------
//
//  Function:   InternalFindStringToken
//
//  Synopsis:   Looks for a textual token in plain text.
//
//  Arguments:  [pwcIn]   -- string to search
//              [token]   -- returns the token found
//              [cwc]     -- returns length of token found
//              [pTokens] -- token array to use
//
//  Returns:    Pointer to token or 0 if none was found
//
//  History:    08-Feb-96   dlee        created
//
//----------------------------------------------------------------------------

WCHAR * InternalFindStringToken(
    WCHAR *        pwcIn,
    Token &        token,
    unsigned &     cwc,
    SStringToken * pTokens )
{
    // for each of and/or/not/near

    WCHAR *pwcOut = 0;

    for ( unsigned i = 0; i < cStringTokens; i++ )
    {
        WCHAR *pwcStr = wcsstr( pwcIn, pTokens[i].pwcToken );

        while ( pwcStr )
        {
            // found a match -- does it have white space on either side?

            WCHAR wcBeyond = * (pwcStr + pTokens[i].cwc);
            if ( ( ( 0 == wcBeyond ) ||
                   ( wcschr( WORD_STR, wcBeyond ) ) ) &&
                 ( ( pwcStr == pwcIn ) ||
                   ( iswspace( * ( pwcStr - 1 ) ) ) ) )
            {
                // if the first match found or the match closest to the
                // beginning of the string, use it.

                if ( ( 0 == pwcOut ) ||
                     ( pwcStr < pwcOut ) )
                {
                    pwcOut = pwcStr;
                    token = pTokens[i].token;
                    cwc = pTokens[i].cwc;
                }

                break;
            }

            pwcStr = wcsstr( pwcStr + 1, pTokens[i].pwcToken );
        }
    }

    return pwcOut;
} //InternalFindStringToken

SStringToken * GetStringTokenArray(
    LCID lcid )
{
    SStringToken *pTokens;

    switch ( PRIMARYLANGID( LANGIDFROMLCID( lcid ) ) )
    {
        case LANG_GERMAN :
            pTokens = s_GermanStringTokens;
            break;
        case LANG_FRENCH :
            pTokens = s_FrenchStringTokens;
            break;
        case LANG_SPANISH :
            pTokens = s_SpanishStringTokens;
            break;
        case LANG_DUTCH :
            pTokens = s_DutchStringTokens;
            break;
        case LANG_SWEDISH :
            pTokens = s_SwedishStringTokens;
            break;
        case LANG_ITALIAN :
            pTokens = s_ItalianStringTokens;
            break;
        case LANG_NEUTRAL :
        case LANG_ENGLISH :
        default :
            pTokens = s_EnglishStringTokens;
            break;
    }

    Win4Assert( 0 != pTokens );

    return pTokens;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindStringToken
//
//  Synopsis:   Looks for a textual token in plain text.  Always tries
//              English, tries a different language depending on _lcid.
//
//  Arguments:  [pwcIn] -- string to search
//              [token] -- returns the token found
//              [cwc]   -- returns length of token found
//
//  Returns:    Pointer to token or 0 if none was found
//
//  History:    08-Feb-96   dlee        created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::FindStringToken(
    WCHAR *    pwcIn,
    Token &    token,
    unsigned & cwc )
{
    SStringToken * pTokens = GetStringTokenArray( _lcid );

    WCHAR * pwcToken = InternalFindStringToken( pwcIn, token, cwc, pTokens );

    // if the search above wasn't in English, try English too.

    if ( pTokens != s_EnglishStringTokens )
    {
        unsigned cwcEnglish;
        Token tokenEnglish;
        WCHAR * pwcEnglish = InternalFindStringToken( pwcIn,
                                                      tokenEnglish,
                                                      cwcEnglish,
                                                      s_EnglishStringTokens );

        // If there is no language-specific match or the English match
        // occurs before the language-specific match, use the English
        // match.

        if ( ( 0 != pwcEnglish ) &&
             ( ( 0 == pwcToken ) || ( pwcEnglish < pwcToken ) ) )
        {
            pwcToken = pwcEnglish;
            token = tokenEnglish;
            cwc = cwcEnglish;
        }
    }

    return pwcToken;
} //FindStringToken

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::Accept, public
//
//  Synopsis:   Determines what the next token is.  Will advance _pLookAhead
//              over the next token and white space.
//
//  Notes:      There are five different types of TEXT_TOKENS, Phrase, Path,
//              Number, Column and Command.  Since the length of the token
//              depends on which token it is, _pLookAhead is forwarded to the
//              end of the longest, and _text is used to parse the token in the
//              various Acq and Get methods.
//
//  History:    30-Apr-92   AmyA        Created
//              19-May-92   AmyA        Added Guid hack
//              23-Jun-92   MikeHew     Added weight token recognition.
//              26-May-94   t-jeffc     Added more tokens; rearranged to
//                                      support parsing errors
//
//----------------------------------------------------------------------------

void CQueryScanner::Accept()
{
    EatWhiteSpace();

    _text = _pLookAhead;

    switch ( *_pLookAhead )
    {
    case '&':
        _pLookAhead++;
        _token = AND_TOKEN;
        break;

    case '*':
        _pLookAhead++;

        if ( *_pLookAhead == '*' )
        {
            _token = FUZ2_TOKEN;
            _pLookAhead++;
        }
        else
            _token = FUZZY_TOKEN;
        break;

    case '=':
        _pLookAhead++;
        _token = EQUAL_TOKEN;
        break;

    case '<':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = LESS_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
            _token = LESS_TOKEN;
        break;

    case '>':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = GREATER_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
            _token = GREATER_TOKEN;
        break;

    case '!':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = NOT_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
        {
            _token = NOT_TOKEN;
        }
        break;

    case '|':
        _pLookAhead++;
        _token = OR_TOKEN;
        break;

    case '~':
        _pLookAhead++;
        _token = PROX_TOKEN;
        break;

    case '@':
        _pLookAhead++;
        _token = PROP_TOKEN;
        break;

    case '#':
        _pLookAhead++;
        _token = PROP_REGEX_TOKEN;
        break;

    case '(':
        _pLookAhead++;
        _token = OPEN_TOKEN;
        break;

    case ')':
        _pLookAhead++;
        _token = CLOSE_TOKEN;
        break;

    case '[':
        _pLookAhead++;
        _token = W_OPEN_TOKEN;
        break;

    case ']':
        _pLookAhead++;
        _token = W_CLOSE_TOKEN;
        break;

    case ',':
        _pLookAhead++;
        _token = COMMA_TOKEN;
        break;

    case '\0':
    case 0x1A:  // CTRL-Z
        _token = EOS_TOKEN;
        break;

    case '"':
        _pLookAhead++;
        _token = QUOTES_TOKEN;
        break;

    case '$':
        _pLookAhead++;
        _token = PROP_NATLANG_TOKEN;
        break;

    case '{':
       _pLookAhead++;
      _token = C_OPEN_TOKEN;
      break;

    case '}':
       _pLookAhead++;
      _token = C_CLOSE_TOKEN;
      break;

    case '^':
    {
        WCHAR wc = *(_pLookAhead + 1);

        BOOL fOk = TRUE;

        if (L'a' == wc) // all bits
            _token = ALLOF_TOKEN;
        else if (L's' == wc) // some bits
            _token = SOMEOF_TOKEN;
        else
            fOk = FALSE;

        if (fOk)
        {
            _pLookAhead += 2;
            break;
        }
    }
    // FALL THROUGH

    case '+':
        if (*_pLookAhead == L'+' && _fTreatPlusAsToken)
        {
            _pLookAhead++;
            _token = PLUS_TOKEN;
            break;
        }
    // FALL THROUGH

    default:
    {
        // forwards pwcEnd over anything that could be in a phrase,
        // which is the most inclusive of the TEXT_TOKENs.
        // (except, for regex's and phrases in quotes - but they're
        // handled separately)

        WCHAR const *pwcEnd = _text + wcscspn( _text, PHRASE_STR );

        if ( _fLookForTextualKeywords )
        {
            unsigned cwc = (unsigned) ( pwcEnd - _text );
            cwc = __min( cwc, MAX_PATH * 2 );

            // if a textual keyword is beyond 500 chars in the string,
            // blow it off -- the workaround is to use the '&|~' version.

            WCHAR awcBuf[ 1 + MAX_PATH * 2 ];
            RtlCopyMemory( awcBuf, _text, cwc * sizeof WCHAR );
            awcBuf[ cwc ] = 0;

            ULONG cwcOut = LCMapString( _lcid,
                                        LCMAP_UPPERCASE,
                                        awcBuf,
                                        cwc,
                                        awcBuf,
                                        cwc );
            if ( cwcOut != cwc )
                THROW( CException() );

            Token token;
            unsigned cwcToken;
            WCHAR *pwcTok = FindStringToken( awcBuf, token, cwcToken );

            if ( 0 != pwcTok )
            {
                // a textual token exists in the string

                if ( pwcTok == awcBuf )
                {
                    // textual token at the start of the string

                    _token = token;
                    _pLookAhead = _text + cwcToken;
                }
                else
                {
                    // textual token in the middle of the string, stop the
                    // current token at that point and get it next time
                    // Accept() is called.

                    _pLookAhead = _text + ( pwcTok - awcBuf );
                    _token = TEXT_TOKEN;
                }
            }
            else
            {
                _pLookAhead = pwcEnd;
                _token = TEXT_TOKEN;
            }
        }
        else
        {
            _pLookAhead = pwcEnd;
            _token = TEXT_TOKEN;
        }

        break;
    }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AllocReturnString, private inline
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.
//
//  History:    17 Apr 97   AlanW       Created
//
//----------------------------------------------------------------------------

inline WCHAR * CQueryScanner::AllocReturnString( int cch )
{
    WCHAR * newBuf = new WCHAR [ cch + 1 ];
    RtlCopyMemory ( newBuf, _text, cch * sizeof(WCHAR));
    newBuf[cch] = L'\0';

    _text += cch;
    while ( iswspace(*_text) )
        _text++;

    return newBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPath, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.  Will
//              return 0 if _text is at end of whole TEXT_TOKEN.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              This method can be called several times before calling
//              Accept(), so many paths can be acquired if they exist in the
//              scanner.
//
//  History:    30-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPath()
{
    if ( IsEndOfTextToken() )
        return 0;

    // how many characters follow _text that are not in CMND_STR?

    int count = wcscspn( _text, CMND_STR );

    return AllocReturnString( count );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqWord, public
//
//  Synopsis:   Copies the word that _text is pointing to and returns the
//              new string. Positions _text after the word and whitespace.
//              Returns 0 if at the end of a TEXT_TOKEN.
//
//  History:    29-Jun-92    MikeHew    Created.
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqWord()
{
    if ( IsEndOfTextToken() )
        return 0;

    WCHAR const * pEnd = _text;

    while ( !iswspace(*pEnd) && pEnd < _pLookAhead )
        pEnd++;

    unsigned count = CiPtrToUint( pEnd - _text );

    return AllocReturnString( count );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqColumn, public
//
//  Synopsis:   Copies a column name and returns the new string.  A column
//              name is either a single word, or a quoted string.
//              Positions _text after the word and whitespace.
//
//  Returns:    WCHAR* pointer to column name.  0 if no column name found.
//
//  History:    17 Apr 97    AlanW      Created.
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqColumn()
{
    if ( QUOTES_TOKEN == _token)
    {
        Accept();
        WCHAR * pwszOut = AcqPhraseInQuotes();
        _text = _pLookAhead;
        return pwszOut;
    }

    if ( IsEndOfTextToken() )
        return 0;

    int count = wcscspn( _text, COLUMN_STR );
    return AllocReturnString( count );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPhrase, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.
//              Returns 0 if at the end of a text token.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              The difference between this function and AcqPath is that this
//              should only be called once before calling Accept().
//
//  History:    30-Apr-92   AmyA        Created
//              09-May-96   DwightKr    Strip trailing white space
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPhrase()
{
    if( IsEndOfTextToken() )
        return 0;

    //
    //  Strip trailing white-space from the end of the phrase.  _pLookAhead
    //  points to the first character of the NEXT phrase.
    //
    WCHAR const * pEnd = _pLookAhead - 1;
    while ( (pEnd > _text) && iswspace(*pEnd) )
    {
        pEnd--;
    }

    unsigned count = CiPtrToUint( pEnd - _text ) + 1;

    WCHAR * newBuf = new WCHAR [ count + 1 ];
    RtlCopyMemory( newBuf, _text, count * sizeof( WCHAR ) );
    newBuf[count] = 0;

    return newBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqRegEx, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.  Matches
//              the longest string possible - the only restriction is that
//              the regex can not contain any of the characters in REGEX_STR
//              outside of <> braces (which may be nested).
//              Returns 0 if the regex is empty.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              Because some regex characters are duplicated in the query
//              language, _pLookAhead is ignored (and actually reset) in
//              this operation.  Like AcqPhrase(), this should be called only
//              once before Accept().
//
//  History:    10-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqRegEx()
{
    WCHAR const * pEnd = _text;
    BOOL fDone = FALSE;
    BOOL fQuoted = FALSE;

    if ( *pEnd == L'"' )
    {
        fQuoted = TRUE;
        pEnd++;
    }

    // scan the string - stop at \0 or if any REGEX_STR characters are
    // found outside of braces
    //
    for( ;; )
    {
        switch( *pEnd )
        {
        case '\0':
            if ( fQuoted )
                THROW( CException( QPARSE_E_UNEXPECTED_EOS ) );

            fDone = TRUE;
            break;

        case ' ':
            if ( !fQuoted )
                fDone = TRUE;
            break;

        case ')':
            if ( !fQuoted )
            {
                if ( ( pEnd != _text ) &&
                     ( '|' != (*(pEnd-1)) ) )
                    fDone = TRUE;
            }
            break;

        case '"':
            if ( fQuoted )
            {
                pEnd++;
                fDone = TRUE;
            }
            break;

        default:
            break;

        } // switch( *pEnd )

        if( fDone ) break;

        pEnd++;
    }

    if( _text == pEnd )
        return 0;

    // set _pLookAhead
    _pLookAhead = pEnd;

    // copy the string
    unsigned count = CiPtrToUint( _pLookAhead - _text );

    if ( fQuoted )
    {
        Win4Assert( count >= 2 );
        count -= 2;
    }
        
    WCHAR * newBuf = new WCHAR[ count + 1 ];

    RtlCopyMemory( newBuf, _text + (fQuoted ? 1 : 0), count * sizeof( WCHAR ) );
    newBuf[ count ] = 0;

    return newBuf;

}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPhraseInQuotes, public
//
//  Synopsis:   Copies all characters until a matching " is found, or until
//              the end of string.  Embedded quotes are escaped with a quote:
//              "Bill ""the man"" Gates"
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//
//  History:    18-Jan-95   SitaramR        Created
//               3-Jul-96   dlee            added embedded quotes
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPhraseInQuotes()
{
    WCHAR const * pEnd = _text;

    do
    {
        if ( 0 == *pEnd )
            break;

        if ( L'"' == *pEnd )
        {
            if ( L'"' == *(pEnd+1) )
                pEnd++;
            else
                break;
        }

        pEnd++;
    } while ( TRUE );

    unsigned count = CiPtrToUint( pEnd - _text );

    WCHAR * newBuf = new WCHAR [ count + 1 ];
    WCHAR * pwcNewBuf = newBuf;
    WCHAR const * pStart = _text;

    // copy the string, but remove the extra quote characters

    while ( pStart < pEnd )
    {
        *pwcNewBuf++ = *pStart++;
        if ( L'"' == *pStart )
            pStart++;
    }

    *pwcNewBuf = 0;

    if ( *pEnd == L'"' )
        _pLookAhead = pEnd + 1;
    else
        _pLookAhead = pEnd;

    return newBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the ULONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the ULONG which will be changed and passed back
//                          out as the ULONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    11-May-92   AmyA        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( ULONG & number, BOOL & fAtEnd )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) || (*_text == L'-') )
        return FALSE;

    // is this a hex number?

    ULONG base = 10;

    if (_text[0] == L'0' && (_text[1] == L'x' || _text[1] == L'X'))
    {
        _text += 2;
        base = 16;
    }

    const WCHAR * pwcStart = _text;

    number = wcstoul( _text, (WCHAR **)(&_text), base );

    // looks like a real number?

    if ( ( pwcStart == _text ) ||
         ( L'.' == *_text ) )
        return FALSE;

    while ( iswspace(*_text) )
        _text++;

    fAtEnd = ( 0 == *_text );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the LONG which will be changed and passed back
//                          out as the LONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Jan-15   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( LONG & number, BOOL & fAtEnd )
{
    WCHAR *text = (WCHAR *) _text;

    BOOL IsNegative = FALSE;

    ULONG ulMax = (ULONG) LONG_MAX;

    if ( L'-' == _text[0] )
    {
        IsNegative = TRUE;

        ulMax++; // can represent 1 more negative than positive.

        _text++;
    }

    ULONG ulNumber;
    if ( !GetNumber( ulNumber, fAtEnd ) )
    {
        _text = text;
        return FALSE;
    }

    //  Signed number overflow/underflow

    if ( ulNumber > ulMax )
    {
        _text = text;
        return FALSE;
    }

    if ( IsNegative )
    {
        if ( ulMax == ulNumber )
            number = LONG_MIN;
        else
            number = - (LONG) ulNumber;
    }
    else
    {
        number = (LONG) ulNumber;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the ULONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the ULONG which will be changed and passed back
//                          out as the ULONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    27-Feb-96   dlee        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( unsigned _int64 & number, BOOL & fAtEnd )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) || (*_text == L'-') )
        return FALSE;

    // is this a hex number?

    ULONG base = 10;

    if (_text[0] == L'0' && (_text[1] == L'x' || _text[1] == L'X'))
    {
        _text += 2;
        base = 16;
    }

    const WCHAR * pwcStart = _text;

    number = _wcstoui64( _text, (WCHAR **)(&_text), base );

    // looks like a real number?

    if ( ( pwcStart == _text ) ||
         ( L'.' == *_text ) )
        return FALSE;

    while ( iswspace(*_text) )
        _text++;

    fAtEnd = ( 0 == *_text );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the LONG which will be changed and passed back
//                          out as the LONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    27-Feb-96   dlee        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( _int64 & number, BOOL & fAtEnd )
{
    WCHAR *text = (WCHAR *) _text;

    BOOL IsNegative = FALSE;

    unsigned _int64 ullMax = (unsigned _int64) _I64_MAX;

    if ( L'-' == _text[0] )
    {
        IsNegative = TRUE;

        ullMax++; // can represent 1 more negative than positive.

        _text++;
    }

    unsigned _int64 ullNumber;
    if ( !GetNumber( ullNumber, fAtEnd ) )
    {
        _text = text;
        return FALSE;
    }

    //  Signed number overflow/underflow

    if ( ullNumber > ullMax )
    {
        _text = text;
        return FALSE;
    }

    if ( IsNegative )
    {
        if ( ullMax == ullNumber )
            number = _I64_MIN;
        else
            number = -((_int64) ullNumber);
    }
    else
    {
        number = (_int64) ullNumber;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the double which will be changed and passed back
//                          out as the double from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Jan-15   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( double & number )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) )
        return FALSE;

    if ( swscanf( _text, L"%lf", &number ) != 1 )
    {
        return FALSE;
    }

    while ( iswspace(*_text) != 0 )
        _text++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetCommandChar, public
//
//  Synopsis:   Returns the command character pointed to by _text and advances
//              _text.  If the command can't be uniquely determined by the
//              first character, each subsequent call will return the next
//              character in the word.  After the command has been determined,
//              AcceptCommand() should be called and then operand parsing may begin.
//
//  History:    14-May-92   AmyA        Created
//              16-May-94   t-jeffc     Returns one character at a time to
//                                      support more commands
//
//----------------------------------------------------------------------------

WCHAR CQueryScanner::GetCommandChar()
{
    if( IsEndOfTextToken() )
        return 0;

    WCHAR chCommand = _text[0];

    _text++;

    return towlower( chCommand );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptCommand, public
//
//  Synopsis:   Advances _text past any characters in the command.
//              Used when enough command characters have been
//              read to uniquely determine the command and begin parsing
//              the operands.
//
//  History:    16-May-94   t-jeffc         Created
//
//----------------------------------------------------------------------------

void  CQueryScanner::AcceptCommand()
{
    int cChars = wcscspn( _text, CMND_STR ); // how many characters follow
                                             // _text that are not in CMND_STR

    _text += cChars;

    _pLookAhead = _text;

    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::ResetBuffer, public
//
//  Synopsis:   Puts a new string into _pBuf and resets _pLookAhead
//              accordingly.
//
//  Arguments:  [buffer] -- the new string for _pBuf
//
//  History:    05-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

void CQueryScanner::ResetBuffer( WCHAR const * buffer )
{
    _pBuf = buffer;
    _pLookAhead = _pBuf;
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::EatWhiteSpace, private
//
//  Synopsis:   Advances _pLookAhead past any white space in the string.
//
//  History:    29-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

void CQueryScanner::EatWhiteSpace()
{
    while ( iswspace(*_pLookAhead) != 0 )
        _pLookAhead++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::IsEndOfTextToken, private
//
//  Synopsis:   Returns TRUE if the current token is not a TEXT_TOKEN or
//              if the string starting at _text to _pLookAhead contains
//              nothing but whitespace.
//
//  History:    27-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

BOOL CQueryScanner::IsEndOfTextToken()
{
    if( _token == TEXT_TOKEN && _text < _pLookAhead )
        return FALSE;
    else
        return TRUE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqLine, public
//
//  Synopsis:   Copies all of the remaining characters on the line;
//              return 0 if _text is at end of whole TEXT_TOKEN.
//
//  Arguments:  [fParseQuotes] -- if TRUE, initial and final quotes are removed
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              This method can be called several times before calling
//              Accept(), so many paths can be acquired if they exist in the
//              scanner.
//
//  History:    96-Jan-03   DwightKr    Created
//              96-Feb-26   DwightKr    Allow lines to be quoted
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqLine( BOOL fParseQuotes )
{
    if ( *_text == L'\0' )
        return 0;

    unsigned cwcBuffer = wcslen(_text);

    //
    // If there are \r, \n, or other white space at the end of the string,
    // strip it off
    //

    while ( cwcBuffer > 0 && _text[cwcBuffer-1] <= L' ' )
        cwcBuffer--;

    if ( fParseQuotes )
    {
        //
        //  If there is a pair of quotes delimiting this line, strip them off
        //
    
        if ( (L'"' == _text[0]) && (cwcBuffer > 1) )
        {
            if ( L'"' == _text[cwcBuffer-1] )
                cwcBuffer--;
    
            _text++;
            cwcBuffer--;
        }
    }

    WCHAR *pText = new WCHAR [ cwcBuffer + 1 ];
    RtlCopyMemory( pText, _text, cwcBuffer * sizeof(WCHAR) );
    pText[cwcBuffer] = 0;

    _pLookAhead = _text + cwcBuffer - 1;

    return pText;
} //AcqLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\string.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       string.cxx
//
//  Contents:   Yet another string class and support functions
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <locale.h>

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::CVirtualString - public constructor
//
//  Synopsis:   Initializes the string by virtually allocating a buffer.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------

CVirtualString::CVirtualString( unsigned cwcBuffer )
                                   : _wcsString(0),
                                     _wcsEnd(0),
                                     _cwcBuffer(cwcBuffer),
                                     _pwcLastCommitted(0)
{
    _wcsString = new WCHAR[ _cwcBuffer ];
    _pwcLastCommitted = _wcsString + _cwcBuffer - 1;
    _wcsEnd = _wcsString;
    *_wcsEnd = 0;
} //CVirtualString

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::~CVirtualString - public destructor
//
//  Synopsis:   Releases virtual memory assocated with this buffer
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVirtualString::~CVirtualString()
{
    delete [] _wcsString;
} //~CVirtualString

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::GrowBuffer, private
//
//  Synopsis:   Commits or re-allocates the string as needed
//
//  Arguments:  [cwcValue]  - # of WCHARs by which to grow the buffer
//
//  History:    96/Mar/25   dlee    Created from DwightKr's StrCat
//
//----------------------------------------------------------------------------

void CVirtualString::GrowBuffer( ULONG cwcValue )
{
    unsigned cwcNewString = cwcValue + 1;
    unsigned cwcOldString = CiPtrToUint( _wcsEnd - _wcsString );
    unsigned cwcRemaining = CiPtrToUint( _cwcBuffer - cwcOldString );

    Win4Assert( _cwcBuffer >= cwcOldString );

    if ( cwcRemaining < cwcNewString )
    {
        DWORD cwcOldBuffer = _cwcBuffer;
        DWORD cwcNewBuffer = _cwcBuffer;

        do
        {
            cwcNewBuffer *= 2;
            cwcRemaining = cwcNewBuffer - cwcOldString;
        }
        while ( cwcRemaining < cwcNewString );

        XArray<WCHAR> xTemp( cwcNewBuffer );

        RtlCopyMemory( xTemp.GetPointer(),
                       _wcsString,
                       _cwcBuffer * sizeof WCHAR );
        delete [] _wcsString;

        _wcsString = xTemp.Acquire();
        _cwcBuffer = cwcNewBuffer;
        _wcsEnd = _wcsString + cwcOldString;
        _pwcLastCommitted = _wcsString + _cwcBuffer - 1;
    }
} //GrowBuffer

// if TRUE, the character doesn't need to be URL escaped

static const BYTE g_afNoEscape[128] =
{
    FALSE,        // 00 (NUL) 
    FALSE,        // 01 (SOH) 
    FALSE,        // 02 (STX) 
    FALSE,        // 03 (ETX) 
    FALSE,        // 04 (EOT) 
    FALSE,        // 05 (ENQ) 
    FALSE,        // 06 (ACK) 
    FALSE,        // 07 (BEL) 
    FALSE,        // 08 (BS)  
    FALSE,        // 09 (HT)  
    FALSE,        // 0A (LF)  
    FALSE,        // 0B (VT)  
    FALSE,        // 0C (FF)  
    FALSE,        // 0D (CR)  
    FALSE,        // 0E (SI)  
    FALSE,        // 0F (SO)  
    FALSE,        // 10 (DLE) 
    FALSE,        // 11 (DC1) 
    FALSE,        // 12 (DC2) 
    FALSE,        // 13 (DC3) 
    FALSE,        // 14 (DC4) 
    FALSE,        // 15 (NAK) 
    FALSE,        // 16 (SYN) 
    FALSE,        // 17 (ETB) 
    FALSE,        // 18 (CAN) 
    FALSE,        // 19 (EM)  
    FALSE,        // 1A (SUB) 
    FALSE,        // 1B (ESC) 
    FALSE,        // 1C (FS)  
    FALSE,        // 1D (GS)  
    FALSE,        // 1E (RS)  
    FALSE,        // 1F (US)  
    FALSE,        // 20 SPACE 
    FALSE,        // 21 !     
    FALSE,        // 22 "     
    FALSE,        // 23 #     
    FALSE,        // 24 $     
    FALSE,        // 25 %     
    FALSE,        // 26 &     
    FALSE,        // 27 '     
    FALSE,        // 28 (     
    FALSE,        // 29 )     
    FALSE,        // 2A *     
    FALSE,        // 2B +     
    FALSE,        // 2C ,     
    FALSE,        // 2D -     
    TRUE,         // 2E .     
    TRUE,         // 2F /     
    TRUE,         // 30 0     
    TRUE,         // 31 1     
    TRUE,         // 32 2     
    TRUE,         // 33 3     
    TRUE,         // 34 4     
    TRUE,         // 35 5     
    TRUE,         // 36 6     
    TRUE,         // 37 7     
    TRUE,         // 38 8     
    TRUE,         // 39 9     
    TRUE,         // 3A :     
    FALSE,        // 3B ;     
    FALSE,        // 3C <     
    TRUE,         // 3D =     
    FALSE,        // 3E >     
    FALSE,        // 3F ?     
    FALSE,        // 40 @     
    TRUE,         // 41 A     
    TRUE,         // 42 B     
    TRUE,         // 43 C     
    TRUE,         // 44 D     
    TRUE,         // 45 E     
    TRUE,         // 46 F     
    TRUE,         // 47 G     
    TRUE,         // 48 H     
    TRUE,         // 49 I     
    TRUE,         // 4A J     
    TRUE,         // 4B K     
    TRUE,         // 4C L     
    TRUE,         // 4D M     
    TRUE,         // 4E N     
    TRUE,         // 4F O     
    TRUE,         // 50 P     
    TRUE,         // 51 Q     
    TRUE,         // 52 R     
    TRUE,         // 53 S     
    TRUE,         // 54 T     
    TRUE,         // 55 U     
    TRUE,         // 56 V     
    TRUE,         // 57 W     
    TRUE,         // 58 X     
    TRUE,         // 59 Y     
    TRUE,         // 5A Z     
    FALSE,        // 5B [     
    FALSE,        // 5C \     
    FALSE,        // 5D ]     
    FALSE,        // 5E ^     
    FALSE,        // 5F _     
    FALSE,        // 60 `     
    TRUE,         // 61 a     
    TRUE,         // 62 b     
    TRUE,         // 63 c     
    TRUE,         // 64 d     
    TRUE,         // 65 e     
    TRUE,         // 66 f     
    TRUE,         // 67 g     
    TRUE,         // 68 h     
    TRUE,         // 69 i     
    TRUE,         // 6A j     
    TRUE,         // 6B k     
    TRUE,         // 6C l     
    TRUE,         // 6D m     
    TRUE,         // 6E n     
    TRUE,         // 6F o     
    TRUE,         // 70 p     
    TRUE,         // 71 q     
    TRUE,         // 72 r     
    TRUE,         // 73 s     
    TRUE,         // 74 t     
    TRUE,         // 75 u     
    TRUE,         // 76 v     
    TRUE,         // 77 w     
    TRUE,         // 78 x     
    TRUE,         // 79 y     
    TRUE,         // 7A z     
    FALSE,        // 7B {     
    FALSE,        // 7C |     
    FALSE,        // 7D }     
    FALSE,        // 7E ~     
    FALSE,        // 7F (DEL) 
};

static const unsigned cNoEscape = sizeof g_afNoEscape / sizeof g_afNoEscape[0];

//+---------------------------------------------------------------------------
//
//  Function:   IsNoUrlEscape
//
//  Synopsis:   Determines if a character doesn't need URL escaping.
//
//  Arguments:  [c]  --  Character to test, T must be unsigned.
//
//  Returns:    TRUE if b doesn't need URL escaping.
//
//  History:    98/Apr/22   dlee    Created.
//
//----------------------------------------------------------------------------

template<class T> inline BOOL IsNoUrlEscape( T c )
{
    if ( c < cNoEscape )
        return g_afNoEscape[ c ];

    return FALSE;
} //IsNoUrlEscape

//+---------------------------------------------------------------------------
//
//  Function:   URLEscapeW
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//
//  History:    96/Apr/03   dlee        Created from DwightKr's code
//              96/May/21   DwightKr    Escape spaces
//              97/Nov/19   AlanW       Allow %ummmm escape codes
//
//----------------------------------------------------------------------------

void URLEscapeW( WCHAR const * wcsString,
                 CVirtualString & StrResult,
                 ULONG ulCodepage,
                 BOOL fConvertSpaceToPlus )
{
    BOOL fTryConvertMB = TRUE;

    //
    //  All spaces are converted to plus signs (+), percents are doubled,
    //  Non alphanumeric characters are represented by their
    //  hexadecimal ASCII equivalents.
    //
    Win4Assert( wcsString != 0 );

    while ( *wcsString != 0 )
    {
        //
        //  Spaces can be treated differently on either size of the ?.
        //  Spaces before the ? (the URI) needs to have spaces escaped;
        //  those AFTER the ? can be EITHER escaped, or changed to a +.
        //  Use either '+' or the % escape depending upon fConverSpaceToPlus
        //

        if ( IsNoUrlEscape( *wcsString ) )
        {
            StrResult.CharCat( *wcsString );
        }
        else if ( L' ' == *wcsString )
        {
            if ( fConvertSpaceToPlus )
                StrResult.CharCat( L'+' );
            else
                StrResult.StrCat( L"%20", 3 );
        }
        else if ( L'%' == *wcsString )
        {
            StrResult.StrCat( L"%%", 2 );
        }
        else if ( *wcsString < 0x80 )
        {
            StrResult.CharCat( L'%' );
            unsigned hiNibble = ((*wcsString) & 0xf0) >> 4;
            unsigned loNibble = (*wcsString) & 0x0f;
            StrResult.CharCat( hiNibble > 9 ? (hiNibble-10 + L'A') : (hiNibble + L'0') );
            StrResult.CharCat( loNibble > 9 ? (loNibble-10 + L'A') : (loNibble + L'0') );
        }
        else
        {
            Win4Assert( *wcsString >= 0x80 );
            
            //
            // We encountered a character outside the ASCII range.
            // Try counverting the Unicode string to multi-byte.  If the
            // conversion succeeds, continue by converting to 8 bit characters.
            // Otherwise, convert this and any other Unicode characters to the
            // %ummmm escape.
            //
            if ( fTryConvertMB )
            {
                ULONG cchString = wcslen(wcsString);
                XArray<BYTE> pszString( cchString*2 );
                BOOL fUsedDefaultChar = FALSE;
                DWORD cbConvert;
                ULONG cbString = pszString.Count();

                do
                {
                    cbConvert = WideCharToMultiByte( ulCodepage,
#if (WINVER >= 0x0500)
                                                     WC_NO_BEST_FIT_CHARS |
#endif // (WINVER >= 0x0500)
                                                        WC_COMPOSITECHECK | 
                                                        WC_DEFAULTCHAR,
                                                     wcsString,
                                                     cchString,
                                            (CHAR *) pszString.Get(),
                                                     cbString,
                                                     0,
                                                     &fUsedDefaultChar );

                    if ( 0 == cbConvert )
                    {
                        Win4Assert( cbString > 0 );
                        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                        {
                             cbString += cbString;
                             delete pszString.Acquire();
                             pszString.Init(cbString);
                        }
                        else if ( GetLastError() == ERROR_INVALID_PARAMETER )
                        {
                            // Presumably unknown code page.
                            fUsedDefaultChar = TRUE;
                            break;
                        }
                        else
                        {
                            THROW( CException() );
                        }
                   }
                } while ( 0 == cbConvert );

                if ( ! fUsedDefaultChar )
                {
                    URLEscapeMToW(pszString.Get(), cbConvert, StrResult, fConvertSpaceToPlus );
                    return;
                }
                
                fTryConvertMB = FALSE;
            }

            // Convert to an escaped Unicode character
            StrResult.StrCat( L"%u", 2 );
            USHORT wch = *wcsString;

            unsigned iNibble = (wch & 0xf000) >> 12;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = (wch & 0x0f00) >> 8;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = (wch & 0x00f0) >> 4;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = wch & 0x000f;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
        }

        wcsString++;
    }
} //URLEscapeW


//+---------------------------------------------------------------------------
//
//  Function:   URLEscapeMToW
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//              The string is 'pseudo-UniCode'.  A multi-byte input string
//              is converted to a UniCode URL, which is implicitly ASCII.
//
//  History:    96/Apr/03   dlee        Created from DwightKr's code
//              96/May/21   DwightKr    Escape spaces
//              96-Sep-17   KyleP       Modified URLEscapeW
//
//----------------------------------------------------------------------------

void URLEscapeMToW( BYTE const * psz,
                    unsigned cc,
                    CVirtualString & StrResult,
                    BOOL fConvertSpaceToPlus )
{
    //
    //  All spaces are converted to plus signs (+), percents are doubled,
    //  Non alphanumeric characters are represented by their
    //  hexadecimal ASCII equivalents.
    //

    Win4Assert( psz != 0 );

    for( unsigned i = 0; i < cc; i++ )
    {
        //
        //  Spaces can be treated differently on either size of the ?.
        //  Spaces before the ? (the URI) needs to have spaces escaped;
        //  those AFTER the ? can be EITHER escaped, or changed to a +.
        //  Use either '+' or the % escape depending upon fConverSpaceToPlus
        //

        if ( IsNoUrlEscape( psz[i] ) )
        {
            StrResult.CharCat( (WCHAR)psz[i] );
        }
        else if ( L' ' == psz[i] )
        {
            if ( fConvertSpaceToPlus )
                StrResult.CharCat( L'+' );
            else
                StrResult.StrCat( L"%20", 3 );
        }
        else if ( L'%' == psz[i] )
        {
            StrResult.StrCat( L"%%", 2 );
        }
        else
        {
            StrResult.CharCat( L'%' );
            unsigned hiNibble = ((psz[i]) & 0xf0) >> 4;
            unsigned loNibble = (psz[i]) & 0x0f;
            StrResult.CharCat( hiNibble > 9 ? (hiNibble-10 + L'A') : (hiNibble + L'0') );
            StrResult.CharCat( loNibble > 9 ? (loNibble-10 + L'A') : (loNibble + L'0') );
        }
    }
} //URLEscapeMToW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\qcanon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1998.
//
//  File:       qcanon.cxx
//
//  Contents:   CCiCanonicalOutput class
//
//  History:    6-06-95   srikants   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qcanon.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CastToStorageVariant
//
//  Synopsis:   To treat a variant as a CStorageVariant. Because CStorageVariant
//              derives from PROPVARIANT in a "protected" fashion, we cannot
//              directly typecast a PROPVARIANT * to a CStorageVariant *
//
//  Arguments:  [varnt] - The variant that must be type casted.
//
//  Returns:    A pointer to varnt as a CStorageVariant.
//
//  History:    6-06-95   srikants   Created
//
//  Notes:      There are two overloaded implementations, one to convert
//              a reference to const to a pointer to const.
//
//----------------------------------------------------------------------------

inline
CStorageVariant * CastToStorageVariant( PROPVARIANT & varnt )
{
    return (CStorageVariant *) ((void *) &varnt);
}

inline
CStorageVariant const * CastToStorageVariant( PROPVARIANT const & varnt )
{
    return (CStorageVariant *) ((void *) &varnt);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::PutWString, static public
//
//  Synopsis:
//
//  Arguments:  [stm]     -
//              [pwszStr] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiCanonicalOutput::PutWString( PSerStream & stm, WCHAR const * pwszStr )
{
    ULONG cwc = (0 != pwszStr) ? wcslen( pwszStr ) : 0;

    stm.PutULong( cwc );
    if (cwc)
        stm.PutWChar( pwszStr, cwc );
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::GetWString, static public
//
//  Synopsis:
//
//  Arguments:  [stm]      -
//              [fSuccess] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CCiCanonicalOutput::GetWString( PDeSerStream & stm, BOOL & fSuccess )
{
    ULONG cwc = stm.GetULong();
    fSuccess = TRUE;

    if ( 0 == cwc )
    {
        return 0;
    }

    ULONG cb = (cwc+1) * sizeof(WCHAR);
    WCHAR * pwszStr = (WCHAR *) CoTaskMemAlloc( cb  );
    if ( 0 == pwszStr )
    {
        fSuccess = FALSE;
        return 0;
    }

    stm.GetWChar( pwszStr, cwc );
    pwszStr[cwc] = L'\0';

    return pwszStr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::AllocAndCopyWString, static public
//
//  Synopsis:
//
//  Arguments:  [pSrc] -
//
//  Returns:
//
//  History:    6-22-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CCiCanonicalOutput::AllocAndCopyWString( const WCHAR * pSrc )
{
    WCHAR * pDst = 0;
    if ( 0 != pSrc )
    {
        const cb = ( wcslen( pSrc ) + 1 ) * sizeof(WCHAR);
        pDst = (WCHAR *) new WCHAR [ cb/sizeof(WCHAR) ];
        if ( 0 != pDst )
        {
            RtlCopyMemory( pDst, pSrc, cb );
        }
    }

    return pDst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCanonicalQueryRows::Init
//
//  Synopsis:   Initializes the query rows output structure for writing
//              results out.
//
//  History:    7-01-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiCanonicalQueryRows::Init()
{
    RtlZeroMemory( this, sizeof(CCiCanonicalQueryRows) );

    InitVersion();
    SetOutputType( CCiCanonicalOutput::eQueryRows );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQuadByteAlignedBuffer::CQuadByteAlignedBuffer
//
//  Synopsis:   Constructor for a quad aligned buffer class.
//
//  Arguments:  [cbBuffer] - Number of bytes in the buffer class.
//
//  History:    6-16-96   srikants   Created
//
//----------------------------------------------------------------------------

CQuadByteAlignedBuffer::CQuadByteAlignedBuffer( ULONG cbBuffer )
{
    // allocator guarantees 8-byte alignment

    _pbAlloc = new BYTE [ cbBuffer ];
    _cbAlloc = cbBuffer;

    Win4Assert( ( ((ULONG_PTR) _pbAlloc) & 0x7) == 0 );
    _pbAligned = _pbAlloc;
    _cbAligned = _cbAlloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\strrest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       strrest.cxx
//
//  Contents:   Builds a restriction object from a string
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parser.hxx>
#include <pvarset.hxx>
#include <strsort.hxx>
#include <cierror.h>

extern CDbContentRestriction * TreeFromText(
    WCHAR const *   wcsRestriction,
    IColumnMapper & ColumnMapper,
    LCID            lcid );

//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbRestriction - public constructor
//
//  Synopsis:   Builds a CDbRestriction from the string passed
//
//  Arguments:  [wcsRestriction] - the string containing the restriction
//              [ulDialect]      - triplish dialect
//              [pList]          - property list describing the proptypes
//              [lcid]           - the locale of the query
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CDbRestriction * GetStringDbRestriction(
    const WCHAR *   wcsRestriction,
    ULONG           ulDialect,
    IColumnMapper * pList,
    LCID            lcid )
{
    Win4Assert( 0 != wcsRestriction );
    Win4Assert( ISQLANG_V1 == ulDialect || ISQLANG_V2 == ulDialect );

    XPtr<CDbRestriction> xRest;

    if ( ISQLANG_V1 == ulDialect )
    {
        CQueryScanner scanner( wcsRestriction, TRUE, lcid );

        CQueryParser query( scanner,
                            VECTOR_RANK_JACCARD,
                            lcid,
                            L"contents",
                            CONTENTS,
                            pList );

        xRest.Set( query.ParseQueryPhrase() );
    }
    else
    {
        xRest.Set( TreeFromText( wcsRestriction, *pList, lcid ) );
    }

    return xRest.Acquire();
} //GetStringDbRestriction

//+---------------------------------------------------------------------------
//
//  Function:   FormDbQueryTree
//
//  Synopsis:   Builds a CDbCmdTreeNode from the restriction, sort
//              specification, grouping specification and output columns.
//
//  Arguments:  [xDbRestriction] - the restriction
//              [xDbSortNode]    - the sort specification (optional)
//              [xDbProjectList] - the output columns
//              [xDbGroupNode]   - the grouping specification (optional)
//              [ulMaxRecords]   - max records to return
//              [ulFirstRows]    - only sort and display the first ulFirstRows 
//                                 rows
//
//  History:    1996/Jan/03   DwightKr    Created.
//              2000/Jul/01   KitmanH     Added ulFirstRows
//
//----------------------------------------------------------------------------
CDbCmdTreeNode * FormDbQueryTree( XPtr<CDbCmdTreeNode> & xDbCmdTreeNode,
                                  XPtr<CDbSortNode> & xDbSortNode,
                                  XPtr<CDbProjectListAnchor> & xDbProjectList,
                                  XPtr<CDbNestingNode> & xDbGroupNode,
                                  ULONG ulMaxRecords,
                                  ULONG ulFirstRows )
{
    XPtr<CDbCmdTreeNode> xDbCmdTree = 0;

    //
    // First create a selection node and append the restriction tree to it
    //
    CDbSelectNode * pSelect = new CDbSelectNode();
    if ( 0 == pSelect )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    xDbCmdTree.Set( pSelect );
    if ( !pSelect->IsValid() )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    //
    // Now make the restriction a child of the selection node.
    //

    pSelect->AddRestriction( xDbCmdTreeNode.GetPointer() );
    xDbCmdTreeNode.Acquire();

    //
    // If there is a nesting node, add the project list and the selection
    // node below the lowest nesting node.  Otherwise, create a projection
    // node and make the selection a child of the projection node.
    //
    if ( 0 != xDbGroupNode.GetPointer() )
    {
        CDbNestingNode * pBottomNestingNode = xDbGroupNode.GetPointer();
        CDbCmdTreeNode * pTree = pBottomNestingNode;

        while (pTree->GetFirstChild() != 0 &&
               (pTree->GetFirstChild()->GetCommandType() == DBOP_nesting ||
                pTree->GetFirstChild()->GetCommandType() == DBOP_sort))
        {
            pTree = pTree->GetFirstChild();
            if (pTree->GetCommandType() == DBOP_nesting)
                pBottomNestingNode = (CDbNestingNode *)pTree;
        }

        // Add the input projection list to the nesting node
        if (! pBottomNestingNode->SetChildList( *xDbProjectList.GetPointer() ))
            THROW( CException(E_INVALIDARG) );

        //
        // Make the selection a child of the lowest node.
        //
        if (pBottomNestingNode == pTree)
        {
            pBottomNestingNode->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();
        }
        else
        {
            Win4Assert( pTree->IsSortNode() );
            ((CDbSortNode *)pTree)->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();
        }

        xDbCmdTree.Set( xDbGroupNode.Acquire() );
    }
    else
    {
        //
        // Create the projection nodes
        //
        CDbProjectNode * pProject = new CDbProjectNode();
        if ( 0 == pProject )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        //
        // Make the selection a child of the projection node.
        //
        pProject->AddTable( xDbCmdTree.GetPointer() );
        xDbCmdTree.Acquire();

        xDbCmdTree.Set( pProject );

        //
        // Next add the column list to the project node
        //

        pProject->AddList( xDbProjectList.GetPointer() );
        xDbProjectList.Acquire();

        //
        // Next make the project node a child of the sort node
        //

        if ( !xDbSortNode.IsNull() && 0 != xDbSortNode->GetFirstChild() )
        {
            xDbSortNode->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();

            xDbCmdTree.Set( xDbSortNode.Acquire() );
        }
    }

    CDbTopNode *pTop = 0;

    //
    //  If the user specified a max # of records to examine, then setup
    //  a node to reflect this.
    //
    if ( ulMaxRecords > 0 )
    {
        pTop = new CDbTopNode();
        if ( pTop == 0 )
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );

        pTop->SetChild( xDbCmdTree.Acquire() );
        pTop->SetValue(ulMaxRecords );
    }

    //
    //  Set FirstRows here
    //
    if ( ulFirstRows > 0 )
    {
        CDbFirstRowsNode *pFR = new CDbFirstRowsNode();
        if ( pFR == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        CDbCmdTreeNode *pChild = pTop ? pTop : xDbCmdTree.Acquire();
        pFR->SetChild( pChild );
        pFR->SetValue( ulFirstRows );

        return pFR;
    }  

    if ( 0 != pTop )
        return pTop;

    return xDbCmdTree.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseStringColumns
//
//  Synopsis:   Parses the textual columns separated by commas into CDbColumns.
//              Also, adds the columns to a set of named variables if the
//              optional parameter pVariableSet is passed.
//
//  Arguments:  [wcsColumns]   -- List of columns, separated by commas
//              [pList]        -- Column mapper.
//              [lcid]         -- locale
//              [pVarSet]      -- [optional] Variable Set.
//              [pawcsColumns] -- [optional] Parsed columns
//
//  History:    3-03-97   srikants   Created
//              7-23-97   KyleP      Return parsed columns
//
//----------------------------------------------------------------------------

CDbColumns * ParseStringColumns( WCHAR const * wcsColumns,
                                 IColumnMapper * pList,
                                 LCID lcid,
                                 PVariableSet * pVarSet,
                                 CDynArray<WCHAR> * pawcsColumns )
{
    CDbColumns * pDbCols = new CDbColumns(0);
    if ( 0 == pDbCols )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbColumns> xDbCols( pDbCols );

    CQueryScanner scan( wcsColumns, FALSE, lcid );

    for ( XPtrST<WCHAR> wcsColumn( scan.AcqColumn() );
          wcsColumn.GetPointer() != 0;
          wcsColumn.Set( scan.AcqColumn() )
        )
    {
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        _wcsupr( wcsColumn.GetPointer() );

        if ( FAILED(pList->GetPropInfoFromName( wcsColumn.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  This column was not defined.  Report an error.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws not found\n", wcsColumn.GetPointer() ));
            THROW( CException( QUERY_E_INVALID_OUTPUT_COLUMN ) );
        }

        pDbColId = (CDbColId *)pdbid;

        unsigned colNum = pDbCols->Count();
        for (unsigned i=0; i<colNum; i++)
        {
            if (pDbCols->Get(i) == *pDbColId)
                break;
        }

        if (i != colNum)
        {
            //
            //  This column is a duplicate of another, possibly an alias.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws is duplicated\n", wcsColumn.GetPointer() ));
            THROW( CException( QUERY_E_DUPLICATE_OUTPUT_COLUMN ) );
        }
        pDbCols->Add( *pDbColId, colNum );


        //
        //  Add the output column to the list of replaceable parameters if needed.
        //
        if ( pVarSet )
        {
            Win4Assert( 0 != pawcsColumns );

            pVarSet->SetVariable( wcsColumn.GetPointer(), 0, 0);
            pawcsColumns->Add( wcsColumn.GetPointer(), colNum );
            wcsColumn.Acquire();
        }

        wcsColumn.Free();
        scan.AcceptColumn();        // Remove the column name

        //
        //  Skip over commas seperating output columns
        //
        if ( scan.LookAhead() == COMMA_TOKEN )
        {
            scan.Accept();          // Remove the ','
        }
        else if ( scan.LookAhead() != EOS_TOKEN )
        {
            THROW( CException( QPARSE_E_EXPECTING_COMMA ) );
        }
    }

    qutilDebugOut(( DEB_ITRACE, "%d columns added to CDbColumns\n", pDbCols->Count() ));

    //
    //  We must have exhausted the CiColumns line.  If not, there was a syntax
    //  error we couldn't parse.
    //
    if ( scan.LookAhead() != EOS_TOKEN )
    {
        //
        //  Contains a syntax error.  Report an error.
        //
        qutilDebugOut(( DEB_IWARN, "Syntax error in CiColumns= line\n" ));
        THROW( CException( QUERY_E_INVALID_OUTPUT_COLUMN ) );
    }

    return xDbCols.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseColumnsWithFriendlyNames
//
//  Synopsis:   Parses the columns string and leaves the friendly names
//              in the project list.
//
//  Arguments:  [wcsColumns] -  Columns names
//              [pList]      -  Property List
//              [pVarSet]    -  (not used) Variable Set - Optional
//
//  Returns:    The project list anchor of the tree.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

CDbProjectListAnchor * ParseColumnsWithFriendlyNames(
                WCHAR const * wcsColumns,
                IColumnMapper * pList,
                PVariableSet * pVarSet )
{
    CDbColumns * pDbCols = new CDbColumns( 0 );
    XPtr<CDbColumns> xDbCols(  pDbCols );

    XPtr<CDbProjectListAnchor> xDbColList(  new CDbProjectListAnchor() );

    if ( 0 == xDbCols.GetPointer() ||
         0 == xDbColList.GetPointer() )
    {
        THROW( CException(E_OUTOFMEMORY) );
    }

    CQueryScanner scan( wcsColumns, FALSE );

    for ( XPtrST<WCHAR> wcsColumn( scan.AcqColumn() );
          wcsColumn.GetPointer() != 0;
          wcsColumn.Set( scan.AcqColumn() )
        )
    {
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;

        _wcsupr( wcsColumn.GetPointer() );

        if ( FAILED(pList->GetPropInfoFromName( wcsColumn.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  This column was not defined.  Report an error.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws not found\n",
                                         wcsColumn.GetPointer() ));
            THROW( CException(QUERY_E_INVALID_OUTPUT_COLUMN) );
        }

        pDbColId = (CDbColId *)pdbid;

        unsigned colNum = pDbCols->Count();
        for (unsigned i=0; i<colNum; i++)
        {
            if (pDbCols->Get(i) == *pDbColId)
                break;
        }

        if (i != colNum)
        {
            //
            //  This column is a duplicate of another, possibly an alias.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws is duplicated\n",
                                         wcsColumn.GetPointer() ));
            THROW( CException(QUERY_E_DUPLICATE_OUTPUT_COLUMN) );
        }
        pDbCols->Add( *pDbColId, colNum );
        if (! xDbColList->AppendListElement( *pDbColId,
                                             wcsColumn.GetPointer() ))
            THROW( CException(E_OUTOFMEMORY) );

        delete wcsColumn.Acquire();
        scan.AcceptColumn();              // Remove the column name

        //
        //  Skip over commas seperating output columns
        //
        if ( scan.LookAhead() == COMMA_TOKEN )
        {
            scan.Accept();          // Remove the ','
        }
        else if ( scan.LookAhead() != EOS_TOKEN )
        {
            THROW( CException(QPARSE_E_EXPECTING_COMMA ) );
        }
    }

    qutilDebugOut(( DEB_TRACE, "%d columns added to project list\n", pDbCols->Count() ));

    //
    //  We must have exhausted the CiColumns line.  If not, there was a syntax
    //  error we couldn't parse.
    //
    if ( scan.LookAhead() != EOS_TOKEN )
    {
        //
        //  Contains a syntax error.  Report an error.
        //
        qutilDebugOut(( DEB_IERROR, "Syntax error in CiColumns= line\n" ));
        THROW( CException(QUERY_E_INVALID_OUTPUT_COLUMN) );
    }

    return xDbColList.Acquire();
}
//+---------------------------------------------------------------------------
//
//  Member:     CTextToTree::FormFullTree
//
//  Synopsis:   Creates a full tree from the parameters given to the
//              construtor.
//
//  History:    3-04-97   srikants   Created
//
//----------------------------------------------------------------------------

DBCOMMANDTREE * CTextToTree::FormFullTree()
{
    XPtr<CDbProjectListAnchor> xDbProjectList;

    if ( _fKeepFriendlyNames )
    {
        //
        // Get the Project List Anchor for the string columns retaining the
        // friendly names.
        //
        xDbProjectList.Set(
            ParseColumnsWithFriendlyNames( _wcsColumns,
                                           _xPropList.GetPointer(),
                                           _pVariableSet ) );
    }
    else
    {
        //
        // Convert the textual form of the columns into DBColumns.
        //
        XPtr<CDbColumns>  xDbColumns;
        CDbColumns * pDbColumns = _pDbColumns;

        if ( 0 == pDbColumns )
        {
            xDbColumns.Set( ParseStringColumns( _wcsColumns,
                                                _xPropList.GetPointer(),
                                                _locale,
                                                _pVariableSet ) );
            pDbColumns = xDbColumns.GetPointer();
        }

        //
        //  Build the projection list from the column list.
        //
        xDbProjectList.Set( new CDbProjectListAnchor );
        if ( 0 == xDbProjectList.GetPointer() )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        for (unsigned i=0; i < pDbColumns->Count(); i++)
        {
            if (! xDbProjectList->AppendListElement( pDbColumns->Get(i) ))
            {
                THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
            }
        }
    }

    //
    // Convert the textual form of the sort columns into CDbSortNode.
    //
    XPtr<CDbSortNode>  xDbSortNode;
    if ( 0 != _wcsSort )
        xDbSortNode.Set( GetStringDbSortNode( _wcsSort, _xPropList.GetPointer(), _locale ) );

    XPtr<CDbNestingNode>  xDbNestingNode;
    if ( 0 != _wcsGroup )
    {
        CQueryScanner scanner( _wcsGroup, FALSE, _locale, TRUE );
        CParseGrouping ParseGrouping( scanner, _xPropList.GetPointer(), _fKeepFriendlyNames );
        ParseGrouping.Parse();

        if ( 0 != _wcsSort )
            ParseGrouping.AddSortList( xDbSortNode );

        xDbNestingNode.Set( ParseGrouping.AcquireNode() );
    }

    qutilDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
    qutilDebugOut(( DEB_TRACE, "\tCiRestriction = '%ws'\n", _wcsRestriction ));

    XPtr<CDbCmdTreeNode> xDbCmdTreeNode;

    // Use a restriction if one was already passed in
    if (0 != _pDbCmdTree)
    {
        Win4Assert(0 == _wcsRestriction);
        xDbCmdTreeNode.Set((CDbCmdTreeNode *)CDbCmdTreeNode::CastFromStruct(_pDbCmdTree));
    }
    else
    {
        Win4Assert(_wcsRestriction);

        xDbCmdTreeNode.Set( GetStringDbRestriction( _wcsRestriction,
                                                    _ulDialect,
                                                    _xPropList.GetPointer(),
                                                    _locale ) );
    }
    
    //
    //  Now form the query tree from the restriction, sort set, and
    //  projection list.
    //

    CDbCmdTreeNode *pDbCmdTree = FormDbQueryTree( xDbCmdTreeNode,
                                                  xDbSortNode,
                                                  xDbProjectList,
                                                  xDbNestingNode,
                                                  _maxRecs,
                                                  _cFirstRows );

    return pDbCmdTree->CastToStruct();
} //FormFullTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\strgroup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:   strgroup.cxx
//
//  Contents:   Builds a nesting node object from a GroupBy string
//
//  History:    10 Apr 1997    AlanW     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <strsort.hxx>

static GUID guidBmk = DBBMKGUID;
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );


//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbGroupNode - public
//
//  Synopsis:   Builds a CDbNestingNode from the string passed
//
//  Arguments:  [pwszGroup] - the string containing the grouping specification
//              [pList]     - the property list describing the column names
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CDbNestingNode * GetStringDbGroupNode( const WCHAR * pwszGroup,
                                       IColumnMapper * pList )
{
    Win4Assert( 0 != pwszGroup );
    CQueryScanner scanner( pwszGroup, FALSE, GetUserDefaultLCID(), TRUE );

    CParseGrouping ParseObj( scanner, pList, FALSE );
    ParseObj.Parse();

    return ParseObj.AcquireNode();
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::Parse, public
//
//  Synopsis:   Parse a GroupBy string, construct the nesting node
//
//  Arguments:  -NONE- uses previously set member variables
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

void CParseGrouping::Parse( )
{
    while (_Scanner.LookAhead() != EOS_TOKEN)
    {
        XPtr<CDbNestingNode> xNode( ParseGrouping() );
        if (_Scanner.LookAhead() == COMMA_TOKEN)
        {
            _Scanner.Accept();
        }
        else if (_Scanner.LookAhead() != EOS_TOKEN)
        {
            THROW( CPListException(QPARSE_E_EXPECTING_COMMA, 0) );
        }

        if (0 == _cNestings)
        {
            Win4Assert( _xNode.GetPointer() == 0 );
            _xNode.Set( xNode.Acquire() );
        }
        else
        {
            CDbNestingNode * pNode = _xNode.GetPointer();
            for (unsigned i=1; i < _cNestings; i++)
            {
                Win4Assert( pNode->GetCommandType() == DBOP_nesting );
                pNode = (CDbNestingNode *)pNode->GetFirstChild();
            }
  
            Win4Assert( pNode != 0 && pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor );
            pNode->AddTable( xNode.Acquire() );
        }
        _cNestings++;
    }
    if (_fNeedSortNode)
        AddSortList( _xSortNode );
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::ParseGrouping, private
//
//  Synopsis:   Parse an individual grouping specification
//
//  Arguments:  -NONE- uses previously set member variables
//
//  Notes:      The scanner is advanced past the parsed grouping spec.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CDbNestingNode * CParseGrouping::ParseGrouping( )
{
    CDbNestingNode * pDbNestingNode = new CDbNestingNode();
    if ( 0 == pDbNestingNode )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbNestingNode> xDbNestingNode(pDbNestingNode);

    //
    //  Parse any leading grouping type specification.
    //
    ULONG ulCatType = eUnique;    // Assume unique value categories

    if ( _Scanner.LookAhead() == W_OPEN_TOKEN )
        ulCatType = ParseGroupingType();

    //  NOTE:  only the unique categorization is implemented.
    if (ulCatType != eUnique)
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );

    if ( 0 == _xSortNode.GetPointer() )
    {
        CDbSortNode * pDbSortNode = new CDbSortNode();
        if ( 0 == pDbSortNode )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        _xSortNode.Set(pDbSortNode);
    }

    BOOL fFirstGroupingColumn = TRUE;
    for ( XPtrST<WCHAR> pwszColumnName( _Scanner.AcqColumn() );
          pwszColumnName.GetPointer() != 0;
          pwszColumnName.Set( _Scanner.AcqColumn() )
        )
    {
        _Scanner.AcceptColumn();                // Remove the column name

        //
        //  Parse for the [a] or [d] parameters.
        //
        unsigned order = QUERY_SORTASCEND;      // Assume ascending sort order

        if ( _Scanner.LookAhead() == W_OPEN_TOKEN )
        {
            _Scanner.Accept();                  // Remove the '['

            WCHAR wchOrder = _Scanner.GetCommandChar();

            if ( wchOrder == L'a' )
            {
                order = QUERY_SORTASCEND;
            }
            else if ( wchOrder == L'd' )
            {
                order = QUERY_SORTDESCEND;
                _fNeedSortNode = TRUE;
            }
            else
            {
                // Report an error
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );
            }

            WCHAR wchNext = _Scanner.GetCommandChar();
            if (wchNext != 0 && !iswspace(wchNext))
                // some alphabetic character followed the '[a' or '[d'.
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );

            _Scanner.AcceptCommand();   // Remove the command character

            if ( _Scanner.LookAhead() != W_CLOSE_TOKEN )
            {
                // Report an error
                THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
            }

            _Scanner.Accept();          // Remove the ']' character
        }

        //
        //  Add the new grouping column to the nesting node
        //
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        if ( FAILED(_xPropList->GetPropInfoFromName( pwszColumnName.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  Column name not found.
            //
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        pDbColId = (CDbColId *)pdbid;

        if ( fFirstGroupingColumn )
        {
            fFirstGroupingColumn = FALSE;
            if ( !pDbNestingNode->AddParentColumn(psBookmark) )
            {
                //  Report a failure.
                THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
            }
        }

        if ( !pDbNestingNode->AddParentColumn(*pDbColId) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        BOOL fFail = _fKeepFriendlyNames ? 
            !pDbNestingNode->AddGroupingColumn(*pDbColId, pwszColumnName.GetPointer()) :
            !pDbNestingNode->AddGroupingColumn(*pDbColId);

        if (fFail)
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        //
        //  Add the column to the sort node in case we will need it.
        //
        CDbSortKey sortKey( *pDbColId, order == QUERY_SORTDESCEND );

        if ( !_xSortNode->AddSortColumn(sortKey) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        pwszColumnName.Free();

        //
        //  Skip over +'s seperating grouping columns
        //

        if ( _Scanner.LookAhead() == PLUS_TOKEN )
        {
            // We don't support this syntax (or document it)

            //_Scanner.Accept();          // Remove the '+'

            THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );
        }

        //
        //  Find a new grouping specification if a comma is found
        if ( _Scanner.LookAhead() == COMMA_TOKEN )
        {
            break;
        }
    }

    return xDbNestingNode.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::ParseGroupingType, private
//
//  Synopsis:   Parses and returns the grouping type.
//
//  Arguments:  -NONE-
//
//  Returns:    ECategoryType - grouping type found if valid
//
//  Notes:      Upon return, the scanner is advanced past the grouping type.
//              Throws CPListException in case of syntax errors
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CParseGrouping::ECategoryType CParseGrouping::ParseGroupingType( )
{
    Win4Assert( _Scanner.LookAhead() == W_OPEN_TOKEN );
    _Scanner.Accept();                   // Remove the '['

    XPtrST<WCHAR> pwszCategoryName( _Scanner.AcqWord() );
    ECategoryType CatType = eInvalidCategory;

    if ( pwszCategoryName.IsNull() )
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );

    if ( _wcsicmp( pwszCategoryName.GetPointer(), L"unique" ) == 0 )
    {
        CatType = eUnique;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"quantile" ) == 0 )
    {
        CatType = eBuckets;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"cluster" ) == 0 )
    {
        CatType = eCluster;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"range" ) == 0 )
    {
        CatType = eRange;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"time" ) == 0 )
    {
        CatType = eTime;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"alpha" ) == 0 )
    {
        CatType = eAlpha;
    }
    else
    {
        // Report an error
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );
    }
    _Scanner.AcceptWord();      // Remove the grouping type name

    if ( _Scanner.LookAhead() != W_CLOSE_TOKEN )
    {
        // Report an error
        THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
    }
    _Scanner.Accept();          // Remove the ']' character

    return CatType;
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::AddSortList, private
//
//  Synopsis:   Add sort columns.
//
//  Arguments:  [SortNode] - a smart pointer to the sort node to be added
//
//  Notes:      A sort list is added below the lowermost nesting node.
//              If there already is a sort node there, the sort columns are
//              appended to the list.
//
//  History:    21 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

void CParseGrouping::AddSortList( XPtr<CDbSortNode> & SortNode )
{
    Win4Assert( _cNestings > 0 );

    CDbNestingNode * pNode = _xNode.GetPointer();
    for (unsigned i=1; i < _cNestings; i++)
    {
        Win4Assert( pNode->GetCommandType() == DBOP_nesting );
        pNode = (CDbNestingNode *)pNode->GetFirstChild();
    }

    Win4Assert( pNode != 0 &&
                (pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor ||
                 pNode->GetFirstChild()->GetCommandType() == DBOP_sort ));

    if (pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor)
    {
        // No sort node yet.  Add a node.
        if (_xSortNode.GetPointer())
        {
            pNode->AddTable( _xSortNode.Acquire() );
            if ( 0 == SortNode.GetPointer() )
            {
                //
                //  If called with _xSortNode, the Acquire above cleared the
                //  smart pointer.  We're done.
                //
                return;
            }
        }
        else
        {
            pNode->AddTable( SortNode.Acquire() );
            return;
        }
    }

    Win4Assert(pNode->GetFirstChild()->GetCommandType() == DBOP_sort);
    Win4Assert(pNode->GetFirstChild()->GetFirstChild()->GetCommandType() == DBOP_sort_list_anchor);
    Win4Assert(0 == _xSortNode.GetPointer());

    // The sort list elements from SortNode will be carved off and appended
    // to the list in pSLA.
    CDbSortListAnchor * pSLA = (CDbSortListAnchor *)pNode->GetFirstChild()->GetFirstChild();


    Win4Assert(SortNode.GetPointer() != 0);
    Win4Assert(SortNode->GetCommandType() == DBOP_sort);
    Win4Assert(SortNode->GetFirstChild()->GetCommandType() == DBOP_sort_list_anchor);
    XPtr<CDbSortListElement> xSLE ( (CDbSortListElement *) SortNode->GetFirstChild()->AcquireChildren() );
    

    if (xSLE.GetPointer())
    {
        pSLA->AppendList( xSLE.GetPointer() );
        xSLE.Acquire();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\strsort.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996-1997, Microsoft Corporation.
//
//  File:       strsort.cxx
//
//  Contents:   Builds a sort node from a string
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbSortNode - public
//
//  Synopsis:   Builds a CDbSortNode from the string passed
//
//  Arguments:  [wcsSort] - the string containing the sort specification
//              [pList]   - the property list describing the sort DBTYPES
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CDbSortNode * GetStringDbSortNode( const WCHAR * wcsSort,
                                   IColumnMapper * pList,
                                   LCID locale)
{
    Win4Assert( 0 != wcsSort );

    unsigned cSortCol = 0;
    CDbSortNode * pDbSortNode = new CDbSortNode();
    if ( 0 == pDbSortNode )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbSortNode> xDbSortNode(pDbSortNode);

    CQueryScanner scanner( wcsSort, FALSE, locale );

    for ( XPtrST<WCHAR> wcsColumnName( scanner.AcqColumn() );
          wcsColumnName.GetPointer() != 0;
          wcsColumnName.Set( scanner.AcqColumn() )
        )
    {
        scanner.AcceptColumn();                 // Remove the column name

        //
        //  Parse for the [a] or [d] parameters.
        //
        unsigned order = QUERY_SORTASCEND;      // Assume ascending sort order

        if ( scanner.LookAhead() == W_OPEN_TOKEN )
        {
            scanner.Accept();                   // Remove the '['

            WCHAR wchOrder = scanner.GetCommandChar();

            if ( wchOrder == L'a' )
            {
                order = QUERY_SORTASCEND;
            }
            else if ( wchOrder == L'd' )
            {
                order = QUERY_SORTDESCEND;
            }
            else
            {
                // Report an error
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );
            }

            WCHAR wchNext = scanner.GetCommandChar();
            if (wchNext != 0 && !iswspace(wchNext))
                // some alphabetic character followed the '[a' or '[d'.
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );

            scanner.AcceptCommand();   // Remove the command character

            if ( scanner.LookAhead() != W_CLOSE_TOKEN )
            {
                // Report an error
                THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
            }

            scanner.Accept();          // Remove the ']' character
        }

        //
        //  Build a CDbSortKey with the parameters obtained.
        //
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        if ( FAILED(pList->GetPropInfoFromName( wcsColumnName.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  Column name not found.
            //
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        pDbColId = (CDbColId *)pdbid;

        CDbSortKey sortKey( *pDbColId, order, locale);

        //
        //  Add the new sort key to the tree of sort nodes.
        //
        if ( !pDbSortNode->AddSortColumn(sortKey) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        delete wcsColumnName.Acquire();

        //
        //  Skip over commas seperating sort columns
        //
        if ( scanner.LookAhead() == COMMA_TOKEN )
        {
            scanner.Accept();          // Remove the ','
        }
        else if (scanner.LookAhead() != EOS_TOKEN)
        {
            THROW( CPListException(QPARSE_E_EXPECTING_COMMA, 0) );
        }

        cSortCol++;
    }

    if (scanner.LookAhead() != EOS_TOKEN)
    {
        if (cSortCol > 0)
        {
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        else
        {
            THROW( CPListException(QPARSE_E_EXPECTING_EOS, 0) );
        }
    }

    return xDbSortNode.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.
//
//  File:   util.cxx
//
//  Contents:   global utilities and data for Content Index Test 'Q'
//
//  History:    27-Dec-94   dlee       Created from pieces of Q
//              18-Jan-95   t-colinb   Added suppport for COMMAND_GETLASTQUERY_FAILED
//              02-Mar-95   t-colinb   Removed unnecessary IMPLEMENT_UNWIND
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dberror.hxx> // for IsCIError function
#include <vqdebug.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   OpenFileFromPath
//
//  Synopsis:   Searches the current path for the specified file and
//              opens it for reading.
//
//  Arguments:  [wcsFile] -- filename to open
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

FILE * OpenFileFromPath( WCHAR const * wcsFile )
{
    unsigned int cwcPath = 256;

    XArray<WCHAR> wcsPath( cwcPath );
    WCHAR * wcsFilePart;

    for( ;; )
    {
        DWORD rc = SearchPath( NULL,
                               wcsFile,
                               NULL,
                               cwcPath,
                               wcsPath.GetPointer(),
                               &wcsFilePart );

        if( rc == 0 )
            return NULL;
        else if( rc >= cwcPath )
        {
            delete [] wcsPath.Acquire();
            cwcPath = rc + 1;
            wcsPath.Init( cwcPath );
        }
        else
            break;
    }

    return _wfopen( wcsPath.GetPointer(), L"r" );
}

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from Ole DB error object
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller should
//                               release this.
//
//  Notes: The caller should use the contents of *ppIErrorInfo only if the return
//         is >= 0 (SUCCEEDED(return value)) AND *ppIErrorInfo is not NULL.
//
//  History:    05 May 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------


SCODE GetOleDBErrorInfo(IUnknown *pErrSrc,
                        REFIID riid,
                        LCID lcid,
                        unsigned eDesiredDetail,
                        ERRORINFO *pErrorInfo,
                        IErrorInfo **ppIErrorInfo)
{
    if (0 == pErrSrc || 0 == pErrorInfo || 0 == ppIErrorInfo)
        return E_INVALIDARG;
    *ppIErrorInfo = 0;

    SCODE sc = S_OK;
    XInterface<ISupportErrorInfo> xSupportErrorInfo;

    sc = pErrSrc->QueryInterface(IID_ISupportErrorInfo, xSupportErrorInfo.GetQIPointer());
    if (FAILED(sc))
        return sc;

    sc = xSupportErrorInfo->InterfaceSupportsErrorInfo(riid);
    if (FAILED(sc))
        return sc;

    //
    // Get the current error object. Return if none exists.
    //

    XInterface<IErrorInfo> xErrorInfo;

    sc = GetErrorInfo(0, (IErrorInfo **)xErrorInfo.GetQIPointer());
    if ( 0 == xErrorInfo.GetPointer() )
        return sc;

    //
    // Get the IErrorRecord interface and get the count of errors.
    //

    XInterface<IErrorRecords> xErrorRecords;

    sc = xErrorInfo->QueryInterface(IID_IErrorRecords, xErrorRecords.GetQIPointer());
    if (FAILED(sc))
        return sc;

    ULONG cErrRecords;
    sc = xErrorRecords->GetRecordCount(&cErrRecords);
    if (0 == cErrRecords)
        return sc;

    //
    // We will first look for what the user desires.
    // If we can't find what they desire, then we
    // return the closest we can.
    //

    ULONG ulRecord = 0;
    long i; // This has to be signed to keep the loop test simple

    switch (eDesiredDetail)
    {
        case eMostGeneric:
            ulRecord = 0;
            break;


        case eDontCare:
        case eMostDetailed:
            ulRecord = cErrRecords - 1;
            break;

        case eMostDetailedOleDBError:
            // Find the last (starting from 0) non-CI error
            ulRecord = cErrRecords - 1;
            for (i = (long) cErrRecords - 1; i >= 0  ; i--)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (!IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostDetailedCIError:
            // Find the last (starting from 0) non-CI error
            ulRecord = cErrRecords - 1;
            for (i = (long) cErrRecords - 1; i >= 0  ; i--)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                if (IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostGenericOleDBError:
            // Find the first (starting from 0) non-CI error
            ulRecord = 0;
            for (i = 0; i < (long)cErrRecords; i++)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (!IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostGenericCIError:
            // Find the first (starting from 0) non-CI error
            ulRecord = 0;
            for (i = 0; i < (long)cErrRecords; i++)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        default:
            Win4Assert(!"Unrecognized error detail option!");
            ulRecord = 0;
            break;
    }

    // Get basic error information
    Win4Assert( ulRecord < cErrRecords );
    sc = xErrorRecords->GetBasicErrorInfo(ulRecord, pErrorInfo);
    Win4Assert(sc != DB_E_BADRECORDNUM);
    sc = xErrorRecords->GetErrorInfo(ulRecord, lcid, ppIErrorInfo);
    Win4Assert(sc != DB_E_BADRECORDNUM);

#if CIDBG
    //
    // Get error description and source through the IErrorInfo
    // interface pointer on a particular record.
    //

    BSTR bstrErrorDescription = 0;
    BSTR bstrErrorSource = 0;

    (*ppIErrorInfo)->GetDescription(&bstrErrorDescription);
    (*ppIErrorInfo)->GetSource(&bstrErrorSource);

    //
    // At this point we could call GetCustomErrorObject and query for additional
    // interfaces to determine what else happened. Currently no custom errors are
    // supported, so nothing to do.
    //

    if (bstrErrorSource && bstrErrorDescription)
    {
        WCHAR wszBuff[1024];

        swprintf(wszBuff, L"HRESULT: %lx, Minor Code: %lu, Source: %ws\nDescription: %ws\n",
                 pErrorInfo->hrError, pErrorInfo->dwMinor, bstrErrorSource, bstrErrorDescription);
        vqDebugOut((DEB_IERROR, "%ws", wszBuff));
    }

    //
    // Free the resources
    //

    SysFreeString(bstrErrorDescription);
    SysFreeString(bstrErrorSource);
#endif // CIDBG

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\wcstoi64.cxx ===
/***
*wcstoi64.c - Contains C runtimes wcstoi64 and wcstoui64
*
*       Copyright (c) 1989-1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wcstol - convert wchar_t string to long signed integer
*       wcstoul - convert wchar_t string to long unsigned integer
*
*Revision History:
*
*******************************************************************************/

#include <pch.cxx>
#pragma hdrstop

#include <errno.h>

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 64-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               wcstol -- _I64_MAX or _I64_MIN
*               wcstoul -- _UI64_MAX
*               wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static
unsigned _int64
wcstoxi64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned _int64 number;
        unsigned digval;
        unsigned _int64 maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while (iswspace(c))
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = (wchar_t *) nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != L'0')
                        ibase = 10;
                else if (*p == L'x' || *p == L'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == L'0' && (*p == L'x' || *p == L'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = _UI64_MAX / ibase;

        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if (iswdigit(c))
                        digval = c - L'0';
                else if (iswalpha(c))
                        digval = towupper(c) - L'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned _int64)digval <= _UI64_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = _UI64_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned _int64)(-_I64_MIN);
                else
                        number = _I64_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = (wchar_t *) p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned _int64)(-(_int64)number);

        return number;                  /* done. */
}

_int64 __cdecl _wcstoi64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (_int64) wcstoxi64(nptr, endptr, ibase, 0);
}

unsigned _int64 __cdecl _wcstoui64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxi64(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\tplist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       tplist.cxx
//
//  Contents:   Builds the perfect hash table in plist.cxx
//
//  History:    05-Sep-97 KyleP   Added header
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

WCHAR * apwc[] =
{
  L"DIRECTORY",
  L"CLASSID",
  L"FILEINDEX",
  L"USN",
  L"FILENAME",
  L"PATH",
  L"SIZE",
  L"ATTRIB",
  L"WRITE",
  L"CREATE",
  L"ACCESS",
  L"ALLOCSIZE",
  L"CONTENTS",
  L"SHORTFILENAME",
  L"RANKVECTOR",
  L"RANK",
  L"HITCOUNT",
  L"WORKID",
  L"ALL",
  L"VPATH",
  L"DOCTITLE",
  L"DOCSUBJECT",
  L"DOCAUTHOR",
  L"DOCKEYWORDS",
  L"DOCCOMMENTS",
  L"DOCTEMPLATE",
  L"DOCLASTAUTHOR",
  L"DOCREVNUMBER",
  L"DOCEDITTIME",
  L"DOCLASTPRINTED",
  L"DOCCREATEDTM",
  L"DOCLASTSAVEDTM",
  L"DOCPAGECOUNT",
  L"DOCWORDCOUNT",
  L"DOCCHARCOUNT",
  L"DOCTHUMBNAIL",
  L"DOCAPPNAME",
  L"DOCSECURITY",
  L"DOCCATEGORY",
  L"DOCPRESENTATIONTARGET",
  L"DOCBYTECOUNT",
  L"DOCLINECOUNT",
  L"DOCPARACOUNT",
  L"DOCSLIDECOUNT",
  L"DOCNOTECOUNT",
  L"DOCHIDDENCOUNT",
  L"DOCPARTTITLES",
  L"DOCMANAGER",
  L"DOCCOMPANY",
  L"HTMLHREF",
  L"A_HREF",
  L"IMG_ALT",
  L"HTMLHEADING1",
  L"HTMLHEADING2",
  L"HTMLHEADING3",
  L"HTMLHEADING4",
  L"HTMLHEADING5",
  L"HTMLHEADING6",
  L"CHARACTERIZATION",
  L"NEWSGROUP",
  L"NEWSGROUPS",
  L"NEWSREFERENCES",
  L"NEWSSUBJECT",
  L"NEWSFROM",
  L"NEWSMSGID",
  L"NEWSDATE",
  L"NEWSRECEIVEDDATE",
  L"NEWSARTICLEID",
  L"MSGNEWSGROUP",
  L"MSGNEWSGROUPS",
  L"MSGREFERENCES",
  L"MSGSUBJECT",
  L"MSGFROM",
  L"MSGMESSAGEID",
  L"MSGDATE",
  L"MSGRECEIVEDDATE",
  L"MSGARTICLEID",
  L"MEDIAEDITOR",
  L"MEDIASUPPLIER",
  L"MEDIASOURCE",
  L"MEDIASEQUENCE_NO",
  L"MEDIAPROJECT",
  L"MEDIASTATUS",
  L"MEDIAOWNER",
  L"MEDIARATING",
  L"MEDIAPRODUCTION",
  L"MUSICARTIST",
  L"MUSICSONGTITLE",
  L"MUSICALBUM",
  L"MUSICYEAR",
  L"MUSICCOMMENT",
  L"MUSICTRACK",
  L"MUSICGENRE",
  L"DRMLICENSE",  
  L"DRMDESCRIPTION",
  L"DRMPLAYCOUNT",
  L"DRMPLAYSTARTS",
  L"DRMPLAYEXPIRES",
  L"IMAGEFILETYPE",
  L"IMAGECX",
  L"IMAGECY",
  L"IMAGERESOLUTIONX",
  L"IMAGERESOLUTIONY",
  L"IMAGEBITDEPTH",
  L"IMAGECOLORSPACE",
  L"IMAGECOMPRESSION",
  L"IMAGETRANSPARENCY",
  L"IMAGEGAMMAVALUE",
  L"IMAGEFRAMECOUNT",
  L"IMAGEDIMENSIONS",
  L"AUDIOFORMAT",
  L"AUDIOTIMELENGTH",
  L"AUDIOAVGDATARATE",
  L"AUDIOSAMPLERATE",
  L"AUDIOSAMPLESIZE",
  L"AUDIOCHANNELCOUNT",
  L"VIDEOSTREAMNAME",
  L"VIDEOFRAMEWIDTH",
  L"VIDEOFRAMEHEIGHT",
  L"VIDEOTIMELENGTH",
  L"VIDEOFRAMECOUNT",
  L"VIDEOFRAMERATE",
  L"VIDEODATARATE",
  L"VIDEOSAMPLESIZE",
  L"VIDEOCOMPRESSION",
};

BOOL IsPrime( ULONG ul )
{
    unsigned ulStop = (ul + 1)/2;

    for ( unsigned i = 2; i <= ulStop && 0 != (ul % i); i++ )
        continue;

    return (i > ulStop);
}


ULONG Hash0( WCHAR const * pc ) //846
{
    unsigned ulH,ulG;

    for (ulH=0; *pc; pc++)
    {
        ulH = (ulH << 4) + (*pc);
        if (ulG = (ulH & 0xf0000000))
            ulH ^= ulG >> 24;
        ulH &= ~ulG;
    }

    return ulH;
}

ULONG Hash1( WCHAR const * pwcName ) //541
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash2( WCHAR const * pwcName ) //443
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 6;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash3( WCHAR const * pwcName ) //664
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 7;

    if ( 0 != *pwcName )
    {
        ulHash += *pwcName++;
        ulHash <<= 7;
    }

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash4( WCHAR const * pwcName ) //345
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 5;

    while ( 0 != *pwcName )
    {
        ulHash <<= 2;
        ulHash += *pwcName++;
    }

    ulHash <<= 2;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash5( WCHAR const * pwcName ) //645 with '4',  558 with '6'
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 6;

    while ( 0 != *pwcName )
    {
        ulHash <<= 2;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 2;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

typedef ULONG (* HFun)( WCHAR const * );

HFun aHashFun[] = { Hash0, Hash1, Hash2, Hash3, Hash4, Hash5 };

void __cdecl main()
{
    const cStrings = sizeof apwc / sizeof apwc[0];
    ULONG a[2000];

    ULONG ulSmallest = 0xFFFFFFFF;
    ULONG iHFSmallest = 0;

    for ( unsigned iHFun = 0; iHFun < sizeof(aHashFun)/sizeof(aHashFun[0]); iHFun++ )
    {
        HFun hf = aHashFun[iHFun];

        for ( ULONG size = cStrings; size < sizeof a / sizeof a[0]; size++ )
        {
            //if ( !IsPrime(size) )
            //      continue;

            BOOL fOK = TRUE;
            RtlZeroMemory( a, sizeof a );

            for ( ULONG x = 0; x < cStrings; x++ )
            {
                unsigned h = (*hf)( apwc[x] ) % size;
                //printf( "%d '%ws'\n", h, apwc[x] );
                if ( 0 != a[h] )
                {
                    //printf( " %d fail\n", size );
                    fOK = FALSE;

                    break;
                }

                a[h] = 1 + x;
            }

            if ( fOK )
            {

#if 0
                printf( "Hash Function %d: %d worked for %d strings\n", iHFun, size, cStrings );

                //
                // Print out
                //

                for ( ULONG i = 0; i < size; i++ )
                {
                    unsigned index = a[i] - 1;
                    if ( 0 == a[i] )
                        printf( "    0,    // %d\n", i );
                    else
                        printf( "    (CPropEntry *) &aStaticList[%d],    // %d '%ws'\n",
                        index, i, apwc[index] );
                }
#endif

                if ( size < ulSmallest )
                {
                    ulSmallest = size;
                    iHFSmallest = iHFun;
                }

                break;
            }
        }
    }

    if ( ulSmallest != 0xFFFFFFFF )
    {
        printf( "Hash Function #%d: %d worked for %d strings\n", iHFSmallest, ulSmallest, cStrings );

        //
        // Recompute hash
        //

        RtlZeroMemory( a, sizeof a );

        for ( ULONG x = 0; x < cStrings; x++ )
        {
            unsigned h = (*aHashFun[iHFSmallest])( apwc[x] ) % ulSmallest;

            a[h] = 1 + x;
        }

        //
        // Print out
        //

        for ( ULONG i = 0; i < ulSmallest; i++ )
        {
            unsigned index = a[i] - 1;
            if ( 0 == a[i] )
                printf( "    0,    // %d\n", i );
            else
                printf( "    (CPropEntry *) &aStaticList[%d],    // %d '%ws'\n",
                index, i, apwc[index] );
        }
    }
    else
        printf( "no perfect hash!\n" );
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\flexcpp.h ===
//----------------------------------------------------------------------------
// Flexcpp.h -- define interfaces for lexical analyzer classes generated
//                by flex
// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

// This file defines FlexLexer, an abstract class which specifies the
// external interface provided to flex C++ lexer objects, and YYLEXER,
// which defines a particular lexer class.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each YYLEXER to some other xxFlexLexer.  You then
// include <FlexLexer.h> in your other sources once per lexer class:
//
//      #undef YYLEXER
//      #define YYLEXER xxFlexLexer
//      #include <FlexLexer.h>
//
//      #undef YYLEXER
//      #define YYLEXER zzFlexLexer
//      #include <FlexLexer.h>
//      ...
//
// History:    10-Oct-97   emilyb   ported from Monarch SQL code
//
//----------------------------------------------------------------------------

#ifndef __FLEX_LEXER_H
// Never included before - need to define base class.
#define __FLEX_LEXER_H

#ifndef YY_CHAR
#define YY_CHAR WCHAR
#endif

DECLARE_DEBUG(yacc)

#if CIDBG

#define yaccDebugOut(x) yaccInlineDebugOut x
#define yaccAssert(x)   Win4Assert x
#define yaccDebugStr(x) yaccInlineDebugOut x

#else // CIDBG

#define yaccDebugStr(x)
#define yaccDebugOut(x)
#define yaccAssert(x)

#endif // CIDBG

// extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

class FlexLexer {
public:
   // virtual ~FlexLexer() = 0;

        const YY_CHAR* YYText() { return yytext; }
        int YYLeng()            { return yyleng; }

        virtual void
                yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
        virtual struct yy_buffer_state*
                yy_create_buffer( int size ) = 0;
        virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
        virtual void yyrestart( ) = 0;

        virtual int yylex(YYSTYPE *yylval) = 0;

        int lineno() const              { return yylineno; }

        int debug() const               { return yy_flex_debug; }
        void set_debug( int flag )      { yy_flex_debug = flag; }

protected:
        YY_CHAR* yytext;
        int yyleng;
        int yylineno;           // only maintained if you use %option yylineno
        int yy_flex_debug;      // only has effect with -d or "%option debug"
};

// }
#endif

#if defined(YYLEXER) || ! defined(yyFlexLexerOnce)
// Either this is the first time through (yyFlexLexerOnce not defined),
// or this is a repeated include to define a different flavor of
// YYLEXER, as discussed in the flex man page.
#define yyFlexLexerOnce

class YYPARSER; // forward declaration

class YYLEXER : public FlexLexer {
public:
        // arg_yyin and arg_yyout default to the cin and cout, but we
        // only make that assignment when initializing in yylex().
        YYLEXER();
        virtual ~YYLEXER();

        void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
        struct yy_buffer_state* yy_create_buffer(  int size );
        void yy_delete_buffer( struct yy_buffer_state* b );
        void yyrestart( );

        int yylex(YYSTYPE *yylval);

        void yyprimebuffer(const YY_CHAR *pszBuffer);
        int yybufferinput(YY_CHAR *pszBuffer, int cMax);
        CCountedDynArray<WCHAR> _allocations;

protected:
        virtual int LexerInput( YY_CHAR* buf, int max_size );
        virtual void LexerOutput( const YY_CHAR* buf, int size );
        virtual void LexerError( const YY_CHAR* msg );
#ifdef DEBUG
        virtual void LexerTrace(const YY_CHAR* buf, int size, int tknNum);
#endif

        void yyunput( int c, YY_CHAR* buf_ptr );
        int yyinput();

        void ResetLexer();
        short CreateTknValue(YYSTYPE *ppStg, short tknNum, BOOL fLong, BOOL fQuote);
        short DetermineTokenType();
        BOOL  IsTokenEmpty();
        BOOL  IsNotOperator();
        void yy_load_buffer_state();
        void yy_init_buffer( struct yy_buffer_state* b );
        void yy_flush_buffer( struct yy_buffer_state* b );

        int yy_start_stack_ptr;
        int yy_start_stack_depth;
        int* yy_start_stack;

        void yy_push_state( int new_state );
        void yy_pop_state();
        int yy_top_state();

        yy_state_type yy_get_previous_state();
        yy_state_type yy_try_NUL_trans( yy_state_type current_state );
        int yy_get_next_buffer();

        //istream* yyin;  // input source for default LexerInput
        //ostream* yyout; // output sink for default LexerOutput

        struct yy_buffer_state* yy_current_buffer;

        // yy_hold_char holds the character lost when yytext is formed.
        YY_CHAR yy_hold_char;

        // Number of characters read into yy_ch_buf.
        int yy_n_chars;

        // Points to current character in buffer.
        YY_CHAR* yy_c_buf_p;
        YY_CHAR *pCurBuffer, *pszInputBuffer;
        int cInputBuffer;

        int yy_init;            // whether we need to initialize
        int yy_start;           // start state number
        int yyprimetoken;       // priming token

        // Flag which is used to allow yywrap()'s to do buffer switches
        // instead of setting up a fresh yyin.  A bit of a hack ...
        int yy_did_buffer_switch_on_eof;

        // The following are not always needed, but may be depending
        // on use of certain flex features (like REJECT or yymore()).

        yy_state_type yy_last_accepting_state;
        YY_CHAR* yy_last_accepting_cpos;

        yy_state_type* yy_state_buf;
        yy_state_type* yy_state_ptr;

        YY_CHAR* yy_full_match;
        int* yy_full_state;
        int yy_full_lp;

        int yy_lp;
        int yy_looking_for_trail_begin;

        int yy_more_flag;
        int yy_more_len;
        int yy_more_offset;
        int yy_prev_more_offset;

        BOOL fContinueImplicitPhrase;
        BOOL fContinueRegex;
        BOOL fContinueMaybeRegex;
        BOOL fTreatFreetextAsPhrase;
#ifdef DEBUG
        int tkndebug;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\querylib\weblcid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       weblcid.hxx
//
//  Contents:   WEB CGI escape & unescape classes
//
//  History:    96/Jan/3    DwightKr    Created
//              97/Jan/7    AlanW       Split from cgiesc.cxx,
//                                      made non-destructive
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mlang.h>
#include <weblcid.hxx>

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

struct tagHTTPLocale
{
    WCHAR * wcsHttpAcceptLanguage;
    DWORD   dwLocaleCode;                       // encoded form for searching
    LCID    lcid;
};

const struct tagHTTPLocale aHTTPLocale[] =
{
   L"EN",    'EN',   MAKELCID( MAKELANGID(LANG_ENGLISH,         // English
                                  SUBLANG_ENGLISH_US),
                       SORT_DEFAULT ),

   L"EN-US", 'ENUS', MAKELCID( MAKELANGID(LANG_ENGLISH,         // English-United States
                                  SUBLANG_ENGLISH_US),
                       SORT_DEFAULT ),

   L"ZH",    'ZH',   MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese
                                  SUBLANG_CHINESE_SIMPLIFIED),
                       SORT_CHINESE_UNICODE ),

   L"ZH-CN", 'ZHCN', MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese/china
                                  SUBLANG_CHINESE_SIMPLIFIED),
                       SORT_CHINESE_UNICODE ),

   L"ZH-TW", 'ZHTW', MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese/taiwan
                                  SUBLANG_CHINESE_TRADITIONAL),
                       SORT_CHINESE_UNICODE ),

   L"NL",    'NL',   MAKELCID( MAKELANGID(LANG_DUTCH,           // Dutch
                                  SUBLANG_DUTCH),
                       SORT_DEFAULT ),

//
//  Alphabetical from here
//

   L"BG",    'BG',   MAKELCID( MAKELANGID(LANG_BULGARIAN,       // Bulgarian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"HR",    'HR',   MAKELCID( MAKELANGID(LANG_CROATIAN,        // Croatian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"CS",    'CS',   MAKELCID( MAKELANGID(LANG_CZECH,           // Czech
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"DA",    'DA',   MAKELCID( MAKELANGID(LANG_DANISH,          // Danish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"FI",    'FI',   MAKELCID( MAKELANGID(LANG_FINNISH,         // Finnish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EL",    'EL',   MAKELCID( MAKELANGID(LANG_GREEK,           // Greek
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EN-GB", 'ENGB', MAKELCID( MAKELANGID(LANG_ENGLISH,         // English-United kingdom
                                  SUBLANG_ENGLISH_UK),
                       SORT_DEFAULT ),

   L"FR",    'FR',   MAKELCID( MAKELANGID(LANG_FRENCH,          // French
                                  SUBLANG_FRENCH),
                       SORT_DEFAULT ),

   L"FR-CA", 'FRCA', MAKELCID( MAKELANGID(LANG_FRENCH,          // French-Canadian
                                  SUBLANG_FRENCH_CANADIAN),
                       SORT_DEFAULT ),

   L"FR-FR", 'FRFR', MAKELCID( MAKELANGID(LANG_FRENCH,          // French-France
                                  SUBLANG_FRENCH),
                       SORT_DEFAULT ),

   L"DE",    'DE',   MAKELCID( MAKELANGID(LANG_GERMAN,          // German
                                  SUBLANG_GERMAN),
                       SORT_DEFAULT ),

   L"HU",    'HU',   MAKELCID( MAKELANGID(LANG_HUNGARIAN,       // Hungarian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IS",    'IS',   MAKELCID( MAKELANGID(LANG_ICELANDIC,       // Icelandic
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IT",    'IT',   MAKELCID( MAKELANGID(LANG_ITALIAN,         // Italian
                                  SUBLANG_ITALIAN),
                       SORT_DEFAULT ),

   L"JA",    'JA',   MAKELCID( MAKELANGID(LANG_JAPANESE,        // Japanese
                                  SUBLANG_DEFAULT),
                       SORT_JAPANESE_UNICODE ),

   L"KO",    'KO',   MAKELCID( MAKELANGID(LANG_KOREAN,          // Korean
                                  SUBLANG_DEFAULT),
                       SORT_KOREAN_UNICODE ),

   L"NO",    'NO',   MAKELCID( MAKELANGID(LANG_NORWEGIAN,       // Norwegian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PL",    'PL',   MAKELCID( MAKELANGID(LANG_POLISH,          // Polish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PT",    'PT',   MAKELCID( MAKELANGID(LANG_PORTUGUESE,      // Portuguese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PT-BR", 'PTBR', MAKELCID( MAKELANGID(LANG_PORTUGUESE,      // Portuguese-Brazil
                                  SUBLANG_PORTUGUESE_BRAZILIAN),
                       SORT_DEFAULT ),

   L"RO",    'RO',   MAKELCID( MAKELANGID(LANG_ROMANIAN,        // Romanian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"RU",    'RU',   MAKELCID( MAKELANGID(LANG_RUSSIAN,         // Russian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SK",    'SK',   MAKELCID( MAKELANGID(LANG_SLOVAK,          // Slovak
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SL",    'SL',   MAKELCID( MAKELANGID(LANG_SLOVENIAN,       // Slovenian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ES",    'ES',   MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish
                                  SUBLANG_SPANISH_MODERN),
                       SORT_DEFAULT ),

   L"ES-ES", 'ESES', MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish-Spain
                                  SUBLANG_SPANISH),
                       SORT_DEFAULT ),

   L"ES-MX", 'ESES', MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish-Mexican
                                  SUBLANG_SPANISH_MEXICAN),
                       SORT_DEFAULT ),

   L"SV",    'SV',   MAKELCID( MAKELANGID(LANG_SWEDISH,         // Swedish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"TR",    'TR',   MAKELCID( MAKELANGID(LANG_TURKISH,         // Turkish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   //  Less common languages

   L"AF",   'AF',    MAKELCID( MAKELANGID(LANG_AFRIKAANS,       // Afrikaans
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"AR",   'AR',    MAKELCID( MAKELANGID(LANG_ARABIC,          // Arabic
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EU",   'EU',    MAKELCID( MAKELANGID(LANG_BASQUE,          // Basque
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"BE",   'BE',    MAKELCID( MAKELANGID(LANG_BELARUSIAN,      // Byelorussian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"CA",   'CA',    MAKELCID( MAKELANGID(LANG_CATALAN,         // Catalan
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"HR",   'HR',    MAKELCID( MAKELANGID(LANG_CROATIAN,        // Croatian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ET",   'ET',    MAKELCID( MAKELANGID(LANG_ESTONIAN,        // Estonian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"FO",   'FO',    MAKELCID( MAKELANGID(LANG_FAEROESE,        // Faeroese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

// L"??",   '??',    MAKELCID( MAKELANGID(LANG_FARSI,           // Farsi
//                                SUBLANG_DEFAULT),
//                     SORT_DEFAULT ),

   L"HE",   'HE',    MAKELCID( MAKELANGID(LANG_HEBREW,         // Hebrew
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IW",   'IW',    MAKELCID( MAKELANGID(LANG_HEBREW,         // Hebrew (ISO 639:1988)
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ID",   'ID',    MAKELCID( MAKELANGID(LANG_INDONESIAN,     // Indonesian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IN",   'IN',    MAKELCID( MAKELANGID(LANG_INDONESIAN,     // Indonesian (ISO 639:1988)
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"LV",   'LV',    MAKELCID( MAKELANGID(LANG_LATVIAN,        // Latvian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"LT",   'LT',    MAKELCID( MAKELANGID(LANG_LITHUANIAN,     // Lithuanian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SR",   'SR',    MAKELCID( MAKELANGID(LANG_SERBIAN,        // Serbian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"TH",   'TH',    MAKELCID( MAKELANGID(LANG_THAI,           // Thai
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"UK",   'UK',    MAKELCID( MAKELANGID(LANG_UKRAINIAN,      // Ukrainian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"VI",   'VI',    MAKELCID( MAKELANGID(LANG_VIETNAMESE,     // Vietnamese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   // NOTE:  Neutral must be last!
   L"NEUTRAL", 'N',  MAKELCID( MAKELANGID(LANG_NEUTRAL,        // Neutral
                                  SUBLANG_NEUTRAL),
                       SORT_DEFAULT ),
};

const unsigned cHTTPLocale = sizeof(aHTTPLocale) / sizeof(aHTTPLocale[0]);

//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleString
//
//  Synopsis:   Looks up a locale string given an LCID
//
//  Arguments:  [lcid]     -- The LCID to lookup
//              [pwcLocale -- The resulting string
//
//--------------------------------------------------------------------------

void GetLocaleString( LCID lcid, WCHAR * pwcLocale )
{
    wcscpy( pwcLocale, L"Neutral" );

    XInterface<IMultiLanguage> xMultiLang;

    SCODE sc = CoCreateInstance( CLSID_CMultiLanguage,
                                 0,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IMultiLanguage,
                                 xMultiLang.GetQIPointer() );

    if ( SUCCEEDED( sc ) )
    {
        BSTR bstrLocale;

        sc = xMultiLang->GetRfc1766FromLcid( lcid, &bstrLocale );
        if ( SUCCEEDED( sc ) )
        {
            wcscpy( pwcLocale, bstrLocale );
            SysFreeString( bstrLocale );
        }
    }
} //GetLocaleString

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromLCID - public
//
//  Synposis:   Determines the string representation of an LCID
//
//  Arguments:  [lcid]     -- The LCID to lookup
//              [pwcLocale -- The resulting string
//
//  History:    96-Apr-24   DwightKr    Created
//
//----------------------------------------------------------------------------

void GetStringFromLCID( LCID lcid, WCHAR * pwcLocale )
{
    //
    // Be careful to compare only the language ID, and not the sort ID.
    //

    lcid = LANGIDFROMLCID(lcid);

    for (ULONG i=0; i<cHTTPLocale; i++)
    {
        if ( lcid == LANGIDFROMLCID( aHTTPLocale[i].lcid ) )
        {
            qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale is %ws; lcid=0x%x\n",
                            aHTTPLocale[i].wcsHttpAcceptLanguage,
                            lcid ));

            wcscpy( pwcLocale, aHTTPLocale[i].wcsHttpAcceptLanguage );
            return;
        }
    }

    // Give up and go for Neutral if the below call fails

    qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale not found, lcid=0x%x\n",
                    lcid ));

    wcscpy( pwcLocale, L"NEUTRAL" );

    //
    //  This LCID was not found in the table, look one up.
    //

    GetLocaleString( lcid, pwcLocale );
} //GetStringFromLCID

//+---------------------------------------------------------------------------
//
//  Function:   EncodeLocale - public
//
//  Synopsis:   Compact a locale string for easier lookup.
//
//  Arguments:  [pwszLocale] - locale string
//              [dwPrimaryLang] - set to the primary language encoding if
//                   there is a sublangage ID.
//
//  Returns:    DWORD - the significant characters in the locale or zero if
//                      ill-formed
//
//+---------------------------------------------------------------------------

inline DWORD EncodeLocale( WCHAR * pwszLocale, DWORD & dwPrimaryLang )
{
    DWORD dwResult = 0;
    dwPrimaryLang = 0;

    if ( isalpha( pwszLocale[0] ) && isalpha( pwszLocale[1] ) )
    {
        dwResult = towupper(pwszLocale[0]) << 8;
        dwResult |= towupper(pwszLocale[1]) << 0;
        pwszLocale += 2;
        if (*pwszLocale == L'-')
        {
            dwPrimaryLang = dwResult;
            dwResult <<= 16;
            pwszLocale++;
            if ( isalpha( pwszLocale[0] ) && isalpha( pwszLocale[1] ) )
            {
                dwResult |= towupper(pwszLocale[0]) << 8;
                dwResult |= towupper(pwszLocale[1]) << 0;
                pwszLocale += 2;
            }
        }
        else if (isalpha( *pwszLocale ))
        {
            // Treat the NEUTRAL locale as a special case
            if (_wcsnicmp( pwszLocale-2,
                           aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage,
                           wcslen(aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage) ) == 0)
            {
                pwszLocale += wcslen(aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage) - 2;
                dwResult = aHTTPLocale[cHTTPLocale-1].dwLocaleCode;
            }
        }
    }
    if ( *pwszLocale != L'\0' &&
         ! iswspace( *pwszLocale ) &&
         *pwszLocale != L',' && *pwszLocale != L';' )
        dwResult = 0;

    return dwResult;
} //EncodeLocale

//+---------------------------------------------------------------------------
//
//  Function:   LcidFromHttpAcceptLanguage
//
//  Synposis:   Determines the locale from the string passed in.
//
//  Arguments:  [pwc] the string representation of the locale
//
//  History:    00-Oct-04   dlee    Created
//
//----------------------------------------------------------------------------

LCID LcidFromHttpAcceptLanguage( WCHAR const * pwc )
{
    // Default to an invalid lcid

    LCID lcid = InvalidLCID;

    if ( 0 != pwc )
    {
        XInterface<IMultiLanguage> xMultiLang;

        SCODE sc = CoCreateInstance( CLSID_CMultiLanguage,
                                     0,
                                     CLSCTX_INPROC_SERVER,
                                     IID_IMultiLanguage,
                                     xMultiLang.GetQIPointer() );

        if ( SUCCEEDED( sc ) )
        {
            BSTR bstr = SysAllocString( pwc );

            if ( 0 != bstr )
            {
                sc = xMultiLang->GetLcidFromRfc1766( &lcid, bstr );

                SysFreeString( bstr );
            }
        }
    }

    return lcid;
} //LcidFromHttpAcceptLanguage

//+---------------------------------------------------------------------------
//
//  Function:   GetLCIDFromString - public
//
//  Synposis:   Determines the locale from the string passed in.
//
//  Arguments:  [wcsLocale] the string representation of the locale
//
//  History:    96-Apr-20   DwightKr    Created
//              97-Jan-07   AlanW       Made non-destructive
//
//  Notes:      The input string is assumed to be a language list as
//              formatted for the Accept-Language header.  This is a
//              command separated list of language codes.
//              The code here doesn't evaluate the quality parameter,
//              it returns the first available language found.
//
//----------------------------------------------------------------------------

LCID GetLCIDFromString( WCHAR * wcsLocale )
{
    unsigned iPrimaryLangEntry = 0xFFFFFFFF;
    const WCHAR * wcsDelim = L" \t,;=";
    WCHAR * wcsToken = wcsLocale;

    while ( 0 != wcsToken )
    {
        wcsToken += wcsspn( wcsToken, wcsDelim );
        DWORD dwPrimaryCode = 0;
        DWORD dwLocaleCode = EncodeLocale(wcsToken, dwPrimaryCode);

        if (dwLocaleCode != 0 || dwPrimaryCode != 0)
        {
            for (ULONG i=0; i<cHTTPLocale; i++)
            {
                if ( dwLocaleCode == aHTTPLocale[i].dwLocaleCode )
                {
                    qutilDebugOut(( DEB_ITRACE,
                                    "GetLCIDFromString is %ws; lcid=0x%x\n",
                                     wcsToken,
                                     aHTTPLocale[i].lcid ));

                    return LANGIDFROMLCID( aHTTPLocale[i].lcid );
                }
                if ( dwPrimaryCode == aHTTPLocale[i].dwLocaleCode &&
                     iPrimaryLangEntry == 0xFFFFFFFF )
                    iPrimaryLangEntry = i;
            }
        }

        wcsToken = wcschr( wcsToken, L',' );
    }

    if (iPrimaryLangEntry != 0xFFFFFFFF)
        return aHTTPLocale[iPrimaryLangEntry].lcid;

    // Fall back to the slow approach.

    return LcidFromHttpAcceptLanguage( wcsLocale );
} //GetLCIDFromString

WCHAR const * __stdcall GetStringFromLCID( LCID lcid );

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromLCID - public
//
//  Synposis:   Determines the string representation of an LCID
//
//  Arguments:  [lcid]  - the LCID to lookup
//
//  History:    96-Apr-24   DwightKr    Created
//
//  Note:       This must be exported since SQL 7 calls this undocumented API
//              It's otherwise unused by Indexing Service.
//
//----------------------------------------------------------------------------

WCHAR const * GetStringFromLCID( LCID lcid )
{
    //
    // Be careful to compare only the language ID, and not the sort ID.
    //

    lcid = LANGIDFROMLCID(lcid);

    for (ULONG i=0; i<cHTTPLocale; i++)
    {
        if ( lcid ==  LANGIDFROMLCID( aHTTPLocale[i].lcid ) )
        {
            qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale is %ws; lcid=0x%x\n",
                         aHTTPLocale[i].wcsHttpAcceptLanguage,
                         lcid ));

            return aHTTPLocale[i].wcsHttpAcceptLanguage;
        }
    }

    //
    //  This LCID was not found in the table, report an error.
    //

    qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale not found, lcid=0x%x\n",
                    lcid ));

    return L"NEUTRAL";
} //GetStringFromLCID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    makefile.inc.

!ENDIF

lex.cxx: parser.l parser.y flexcpp.h flexcpp.skl
    -attrib -r lex.cxx 2>nul
    -del lex.cxx 2>nul
    flex -Sflexcpp.skl -+ -B -L -olex.cxx parser.l

trparse.cxx parser.h: parser.y
    kbyacc -f triplish -d -l -b parser -p trip -c CTripYYBase "(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex)" parser.y
    attrib -r trparse.cxx 2>nul
    attrib -r parser.h 2>nul
    -del trparse.cxx
    -del parser.h
    -ren parser.tab.c trparse.cxx
    -ren parser.tab.h parser.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\lex.cxx ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#include <pch.cxx>
#pragma hdrstop

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5



/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifndef YY_CHAR
#define YY_CHAR WCHAR
#endif

#ifdef __cplusplus

#include <stdlib.h>
  //class istream;

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed YY_CHAR to an unsigned
 * integer for use as an array index.  If the signed YY_CHAR is negative,
 * we want to instead treat it as an 8-bit unsigned YY_CHAR, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (YY_CHAR) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 32767       // UNDONE:  Should really just take the input from the bstr passed in

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *      if ( condition_holds )
 *              yyless( 5 );
 *      else
 *              do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
        {
        YY_CHAR *yy_ch_buf;             /* input buffer */
        YY_CHAR *yy_buf_pos;            /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2
        };


/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer



static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

#define yytext_ptr yytext


/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yytext_ptr = yy_bp; \
	yytext_ptr -= yy_more_len; \
	yyleng = (int) (yy_cp - yytext_ptr); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 172
#define YY_END_OF_BUFFER 173
static yyconst short int yy_accept[804] =
    {   0,
        0,    0,    0,    0,    0,    0,  138,  138,  151,  151,
        0,    0,    0,    0,    0,    0,  173,   87,    1,    1,
       20,  172,  172,  172,   18,    2,    3,  172,   24,   28,
       25,  172,   87,   87,   87,   87,  172,  172,   19,   23,
       90,   91,  172,  172,   97,  123,  138,  124,  132,  138,
      133,  130,  134,  135,  125,  138,  138,  138,  136,  131,
      151,  148,  144,  151,  152,  142,  145,  146,  151,  151,
      151,  147,  143,  171,  154,  162,  171,  168,  160,  164,
      165,  169,  171,  171,  171,  171,  166,  163,  161,  121,
      104,  172,  113,  116,  117,  121,  121,  121,  118,  114,

      115,  172,   98,   98,  172,  103,   99,   87,   86,    1,
        1,    1,   29,    0,   81,   75,    0,    7,    0,    0,
        0,    0,    0,   26,    0,    0,    0,    0,   27,    0,
        5,    0,   87,   87,   87,   87,   87,    0,   30,   31,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   90,
        0,    0,  122,  138,  137,    0,  124,  138,  137,    0,
      126,    0,  138,  138,  138,  138,  138,  151,  150,    0,
      148,  151,  150,    0,  149,    0,  151,  151,  151,  151,
      151,  171,  170,  154,  171,  170,    0,  153,  171,  171,
      171,  171,  171,  121,  120,  104,    0,  121,  121,  121,

        0,    0,  102,  101,   98,   98,    0,  100,    0,    0,
       80,    0,    0,   89,    0,    0,    0,   89,    0,    0,
       32,   54,   40,    0,    0,   48,   34,    0,   87,   87,
       87,   87,   14,   15,    0,    0,    0,    0,   47,   55,
       49,    0,    0,    0,   33,   41,   35,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  126,  138,  138,  138,  138,  128,  138,  149,
      151,  151,  151,  151,  140,  151,  153,  171,  171,  171,
      171,  156,  119,  121,  121,  107,  108,    0,   56,   42,
       74,    6,    0,   88,    0,   50,   36,   52,   38,    4,

       12,   13,   87,   87,   16,   17,   14,   46,   57,   51,
       53,   58,   59,   43,   37,   39,   44,   45,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   62,
        0,    0,    0,  138,  127,  129,  151,  139,  141,  155,
      171,  171,  159,  105,  106,  121,    0,    0,   88,   12,
       87,   21,   22,   16,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      171,  157,  158,  109,  110,    0,   87,   21,    0,    0,
        0,    0,    0,    0,   64,   65,    0,    0,    0,    0,
        0,    0,   92,    0,    0,    0,    0,    0,  171,  111,

      112,   87,    0,   10,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,  171,   87,    0,
        0,   67,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   95,    0,    0,  171,   11,    0,
       63,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       96,   94,   93,  167,   11,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   70,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    9,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   72,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   72,    0,    0,   72,    0,    0,    0,
        0,    0,    0,    0,    0,   72,    0,    0,    0,    0,
        0,    0,   66,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,   79,   71,    0,    0,    0,    0,    0,
       72,    0,    0,    0,   73,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   79,   78,
       71,    0,   72,    0,    0,   73,    0,   72,   73,    0,
        0,    0,    0,    0,    0,    0,   77,    0,   78,   71,
       72,   71,   73,    0,    0,    0,    0,    0,    0,    0,
        0,   76,   77,    0,    0,    0,   61,    0,    0,    0,
       85,    0,    0,   76,    0,    0,   61,    0,    0,   85,
       84,    0,    0,    0,   60,    0,    0,   83,    0,   84,
        0,    0,    0,   60,   82,   83,    0,    0,   68,   82,

        0,   69,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    4,    5,    6,    7,    1,    8,    1,    9,
       10,   11,   12,   13,    1,   14,   15,   16,   17,   18,
       18,   18,   18,   18,   18,   18,   18,    1,   19,   20,
       21,   22,   12,   23,   24,    1,   25,   26,   27,   28,
       29,   30,   31,    1,   32,   33,   34,   35,   36,   37,
        1,   38,   39,   40,   41,   42,   43,   44,    1,    1,
       45,    1,   12,   46,    1,    1,   47,    1,   48,   49,

       50,   51,   29,   30,   52,    1,   32,   53,   34,   54,
       36,   55,    1,   56,   57,   58,   59,   42,   43,   60,
        1,    1,   61,   62,   63,   64,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[65] =
    {   0,
        1,    1,    2,    3,    4,    5,    5,    6,    7,    8,
        1,    1,    1,    1,    1,    1,    1,    1,    9,    3,
       10,    3,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    3,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       11,   12,   13,    6
    } ;

static yyconst short int yy_base[854] =
    {   0,
        0,   63,   30,   42, 2468, 2467,  125,  187,  249,  311,
      373,  435,  497,  559,  134,  149, 2477, 2473,   10,   12,
     2454, 2469, 2468, 2467, 2480,   13, 2480, 2480,   31,   14,
       35, 2466,   24,   27,  177,   38,   33,  609, 2480, 2480,
       26, 2480, 2418, 2415, 2480, 2457,   34, 2464, 2480,  663,
     2480, 2480, 2480, 2480, 2480,  103,   46,  120, 2480,  219,
       54, 2463, 2480,  725, 2480, 2480, 2480, 2480,  115,  104,
      164, 2480,  277, 2462, 2461, 2480,  787, 2480, 2480, 2480,
     2480, 2480,  170,   39,  211,  118, 2480, 2480, 2480, 2460,
     2459,    0, 2480, 2480, 2480,  181,   92,  161,    4, 2480,

     2480,   21,  260,   48, 2456, 2480, 2480, 2457, 2480,  100,
      110,  112,   97, 2454, 2447, 2452,    0, 2451,    0, 2436,
      241,  288,  117,  152, 2397,  172,  168,  175,  197,  218,
     2448,    0,  242,  271,  138,  236,  216,  237,  323,  346,
      299, 2416,   66,  156,  251,  299,  254,  273,  282,  234,
     2394, 2398, 2480,  289, 2480,  401, 2446,  849, 2443, 2135,
      299,  456,  423,  302,  327,  345,  353,  356, 2480,  464,
     2111,  911, 2096, 2057,  360,  525,  477,  450,  367,  368,
      385, 2053, 2480, 2052,  973, 2049, 2047, 2031,  336,  349,
      401,  483, 2030, 2029, 2480, 2028, 2024,  402,  507,  263,

      373,  193, 2480, 2480,  414,  384, 2007, 2480,  447,  344,
     2480, 2004, 2003, 2480,  537,  387, 2002, 2001,  449,  431,
     2480, 2480, 2480,  476,  437, 2480, 2480, 1999,  484,  508,
      515,  488, 1984, 2480,  511, 1939,  569, 1963, 1962, 2480,
     1961,  493,  581, 1960, 1958, 2480, 1954,  508,  465,  525,
      493,  502,  547,  542,  551,  544, 1937, 1940,  551,  556,
     1908, 1907, 2480,    0, 1913,  451,  577, 2480,  613, 2480,
        0, 1912,  614,  615, 2480,  616, 2480, 1954,  590,  602,
     1946, 2480, 2480,  575,  623, 2480, 2480,  585, 2480, 2480,
     2480, 2480,  609, 2480,  622, 2480, 2480, 2480, 2480, 2480,

     1944, 2480,  607,  589, 1940, 2480, 1937, 2480, 2480, 2480,
     2480, 2480, 2480, 2480, 2480, 2480, 2480, 2480,  608, 1903,
      608,  573,  632,  647,  597,  656,  644,  660,  648, 2480,
     1907,  686,  687,    0, 2480, 2480,    0, 2480, 2480, 2480,
      689,  639, 2480, 2480, 2480,  688,  655,  693, 2480, 1931,
      691, 1927, 2480, 1924,  668,  661,  661,  689,  662,  667,
      701,  682, 1923,  694, 1874, 1879,  737,  739,  738,  774,
      748, 2480, 2480, 2480, 2480,  712,  747, 1903,  708, 1841,
     1770,  717,  725,  729, 2480, 2480,  733,  767, 1742,  725,
      726,  802,  798,  836, 1772,  756,  777, 1765,  771, 2480,

     2480,  821,  788, 2480,  785, 1737,  725,  786, 1736,  816,
      825, 1791, 1790,  818,  808,  808,  829,  835, 1789,  836,
     1727, 2480,  840,  818,  829, 1755,  775,  878,  894, 1773,
     1035,  844,  863,  851, 2480,  849,  875, 1784, 1783,  875,
     2480, 1721, 1780,  874,  923,  924, 1767,  882,  900, 1766,
      938,  941,  905,  640, 1096,  866,  927,  944,  913,  918,
     2480, 2480, 2480, 2480, 1776, 1715,  946,  167,  893,  947,
      965,  950,  933,  908,  966,  948,  955, 1762, 1771,  961,
      985, 1007, 1010,  964,  968,  989, 1157,  994,  998, 1025,
     1760, 1218,  985,  471, 2480, 1006, 1028, 1049, 1758,  971,

     1015, 1757, 1766, 1021, 1037, 1740, 1037, 1059, 1016, 1019,
     1024, 1754, 1068, 1074, 1085, 1050, 1078, 1279, 1110, 1114,
     1062, 1117, 1079, 1340, 1739, 1067, 1088, 1124, 1076, 1101,
     1122, 1735, 1075, 1127, 1128, 1135, 1136, 1137, 1093, 1103,
     1127, 1142, 1751,  237, 1139, 1702, 1097, 1759, 1734, 1154,
     1142, 1182, 1145, 1747, 1185, 1151, 1211, 1188, 1746, 1205,
     1187, 1196, 1232, 1167, 1239, 1235, 1195, 1248, 1726, 1206,
     1237, 1744, 1753, 1241, 1234, 1196, 1725, 1724, 1199, 1265,
     1222, 1689, 2480, 1745, 1190, 1221, 1719, 1233, 1306, 1249,
     1307, 1310, 1261, 1303, 1309, 1317, 1215, 1320, 1327, 1641,

     1334, 1289, 1304, 1307, 1258, 1652, 1324, 1317, 1630, 1290,
     1632, 1363, 1335, 1202, 2480, 1316, 1336, 1571, 1364, 1348,
     1195, 1388, 1356, 1394, 1385, 1402, 1462, 1397, 1409, 1367,
     1406, 1364, 1410, 1416, 1378, 1390, 1415, 1396, 1399, 1404,
     1389, 1434, 1410, 1420, 1417, 1416, 1263, 1425, 1435, 1469,
     1418, 1473, 1452, 1477, 2480, 1486, 1433, 1437, 1496, 1381,
     1487, 1470, 1497, 1502, 1457, 1437, 1487, 1468, 1506, 1471,
     1494, 1516, 1268, 2480, 1264, 1480, 1313, 1492, 1507, 1547,
     1495, 1550, 1510, 1556, 1529, 1517, 1213, 1541, 1238, 1559,
     1275, 1577, 2480, 1553, 1522, 1536, 1524, 1554, 1584, 1593,

     1557, 1553, 1563, 1154, 2480, 1090, 1555, 1566, 1616, 1570,
     1620, 1583, 1628, 1624, 2480, 1631, 1594, 1621, 1633, 1592,
     1601, 1630, 1598, 1649, 1072, 1022,  998, 1614, 1204, 2480,
     2480,  986, 1027, 1650,  873,  918, 1656, 1641, 1644, 1653,
     1641, 1625, 1664, 1639,  747,  722,  757,  702,  756, 2480,
     1668, 2480, 1695, 1704, 1711, 1655, 1682, 1670,  654,  596,
      556, 2480,  593,  516, 1717, 1658, 2480, 1683, 1682, 1690,
      517,  466,  411, 2480, 1722, 1728,  427,  339, 1693, 1729,
     2480,  305,  248, 1732, 2480,  294, 1733,  170,   63,   92,
       34, 1734, 1735, 2480, 2480,    8, 1740, 1741, 2480, 2480,

     1744, 2480, 2480, 1807, 1820, 1833, 1846, 1859, 1872, 1885,
     1898, 1911, 1924, 1937, 1950, 1963, 1976, 1988, 2001, 2013,
     2026, 2035, 2048, 2058, 2071, 2084, 2097, 2110, 2123, 2136,
     2149, 2162, 2175, 2188, 2201, 2214, 2227, 2240, 2253, 2266,
     2279, 2292, 2305, 2318, 2331, 2344, 2357, 2369, 2382, 2395,
     2408, 2421, 2434
    } ;

static yyconst short int yy_def[854] =
    {   0,
      804,  804,  805,  805,  805,  805,  806,  806,  807,  807,
      808,  808,  809,  809,  810,  810,  803,  811,  811,  803,
      803,  812,  813,  814,  803,  815,  803,  803,  803,  803,
      803,  816,  811,  811,  811,  811,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  817,  803,  803,  818,
      803,  803,  803,  803,  803,  817,  817,  817,  803,  803,
      819,  803,  803,  820,  803,  803,  803,  803,  819,  819,
      819,  803,  803,  821,  803,  803,  822,  803,  803,  803,
      803,  803,  821,  821,  821,  821,  803,  803,  803,  823,
      803,  824,  803,  803,  803,  823,  823,  823,  803,  803,

      803,  825,  825,  803,  826,  803,  803,  811,  803,  811,
      803,  803,  803,  812,  803,  813,  827,  814,  828,  815,
      815,  829,  803,  803,  803,  803,  803,  803,  803,  803,
      816,  830,  811,  811,  811,  811,  811,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  817,  803,  803,  803,  818,  831,  831,
      817,  831,  817,  817,  817,  817,  817,  819,  803,  803,
      803,  820,  832,  832,  819,  832,  819,  819,  819,  819,
      819,  821,  803,  803,  822,  833,  833,  821,  821,  821,
      821,  821,  821,  823,  803,  803,  824,  823,  823,  823,

      803,  825,  803,  803,  825,  803,  826,  803,  803,  803,
      803,  827,  828,  803,  829,  815,  834,  834,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  830,  811,  811,
      811,  811,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  158,  158,  817,  817,  803,  817,  803,
      172,  172,  819,  819,  803,  819,  803,  821,  821,  821,
      821,  803,  803,  823,  823,  803,  803,  803,  803,  803,
      803,  803,  815,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  811,  811,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  158,  803,  803,  172,  803,  803,  803,
      821,  821,  803,  803,  803,  823,  803,  803,  803,  803,
      811,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      821,  803,  803,  803,  803,  803,  811,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  821,  803,

      803,  811,  803,  803,  803,  803,  803,  803,  803,  803,
      835,  803,  803,  803,  803,  803,  803,  821,  811,  803,
      803,  803,  803,  803,  836,  803,  835,  835,  837,  803,
      835,  803,  803,  803,  803,  803,  803,  821,  803,  803,
      803,  803,  803,  836,  836,  838,  803,  803,  835,  803,
      837,  837,  835,  839,  837,  803,  840,  841,  803,  803,
      803,  803,  803,  803,  803,  803,  842,  803,  836,  838,
      838,  836,  843,  803,  803,  803,  835,  803,  839,  803,
      839,  844,  845,  803,  840,  840,  840,  841,  841,  841,
      803,  841,  803,  803,  803,  842,  842,  846,  803,  803,

      836,  803,  843,  803,  843,  803,  803,  847,  803,  803,
      803,  803,  839,  844,  844,  840,  839,  844,  845,  845,
      841,  845,  839,  845,  803,  840,  841,  841,  803,  841,
      841,  803,  803,  842,  846,  846,  842,  848,  803,  803,
      803,  803,  803,  843,  803,  849,  847,  850,  803,  803,
      803,  839,  840,  803,  839,  844,  845,  841,  803,  845,
      839,  845,  845,  803,  841,  841,  803,  841,  803,  803,
      842,  803,  848,  803,  848,  803,  803,  803,  803,  843,
      803,  849,  803,  850,  803,  803,  803,  803,  839,  803,
      839,  845,  803,  845,  839,  845,  803,  841,  841,  803,

      841,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  803,  803,  839,  803,
      839,  845,  803,  845,  839,  845,  803,  841,  841,  803,
      841,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  839,  803,  839,  845,
      803,  845,  839,  845,  803,  841,  841,  803,  841,  803,
      803,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  839,  803,  839,  845,
      803,  845,  839,  845,  841,  841,  803,  841,  803,  803,
      803,  803,  803,  803,  803,  803,  848,  803,  803,  803,

      803,  803,  843,  803,  803,  803,  803,  839,  845,  803,
      845,  839,  845,  841,  803,  841,  803,  803,  803,  803,
      803,  848,  803,  803,  803,  803,  803,  803,  843,  803,
      803,  803,  839,  845,  803,  839,  845,  841,  841,  803,
      803,  803,  848,  803,  803,  803,  803,  803,  843,  803,
      845,  803,  845,  803,  851,  803,  803,  848,  803,  803,
      803,  803,  803,  851,  851,  852,  803,  803,  803,  848,
      803,  803,  803,  803,  852,  851,  853,  803,  803,  848,
      803,  803,  803,  851,  803,  853,  803,  803,  803,  848,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,    0,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803
    } ;

static yyconst short int yy_nxt[2545] =
    {   0,
      803,   19,   20,   21,   22,   23,   24,   25,   26,   27,
       28,  110,  111,  112,  112,  121,  126,  122,  800,   29,
       30,   31,   32,   33,   34,  803,  109,  150,  150,  109,
      203,   41,   41,  123,   35,   36,  155,  128,  201,  204,
      109,  183,   42,   41,   41,   37,   33,   34,  155,  206,
      206,  124,  138,   35,   42,  129,  169,  201,  133,  127,
       38,   39,  134,   40,   19,   20,   21,   22,   23,   24,
       25,   26,   27,   28,  190,  137,  125,  133,   43,  139,
      130,  164,   29,   30,   31,   32,   33,   34,   44,  140,
       43,  797,   45,  137,  195,  156,  574,   35,   36,  209,

       44,  110,  111,  253,   45,  155,  169,  156,   37,   33,
       34,  112,  112,  112,  112,  170,   35,  169,  199,  123,
      183,  253,  155,   38,   39,  796,   40,   48,   49,   50,
       51,   51,   52,   53,   54,  103,  104,  163,  105,  178,
      109,  199,  210,  106,   51,   55,   51,   51,   56,  177,
      103,  104,  107,  105,  219,  193,  163,  165,  106,   57,
       58,  231,  125,  195,  156,  170,  169,  107,  177,  468,
       51,   56,  183,  193,  126,  165,  170,  128,   57,  109,
      795,  156,  254,  195,  231,   59,   60,   28,   28,   48,
       49,   50,   51,   51,   52,   53,   54,  220,  200,  224,

      500,  179,  203,  135,  189,  254,   51,   55,   51,   51,
       56,  204,  136,  183,  222,  198,  200,  127,  233,  179,
      130,   57,   58,  189,  223,  170,  135,  166,  166,  166,
      166,  166,   51,   56,  198,  150,  150,  191,  109,  235,
       57,  504,  225,  121,  109,  122,  192,   59,   60,   28,
       28,   62,   63,   64,   65,   65,   66,   67,   68,  214,
      191,  205,  205,  167,  226,  286,  580,  229,   65,  203,
       65,   65,   69,  109,  227,  232,  234,  255,  204,  166,
      258,  166,  236,   70,   71,  180,  180,  180,  180,  180,
      229,  155,  216,  232,   65,   69,  217,  217,  787,  259,

      255,  155,   70,  258,  155,  230,  218,  792,  260,   72,
       73,   28,   28,   62,   63,   64,   65,   65,   66,   67,
       68,  181,  259,  287,  230,  237,  238,  249,  256,  268,
       65,  260,   65,   65,   69,  250,  257,  180,  183,  180,
      251,  267,  239,  240,  241,   70,   71,  155,  243,  244,
      156,  183,  791,  250,  257,  155,   65,   69,  169,  267,
      156,  278,  169,  156,   70,  245,  246,  247,  242,  275,
      169,   72,   73,   28,   28,   75,   76,   77,   78,   78,
       79,   80,   81,  279,  278,  206,  206,  169,  156,  293,
      289,  248,   78,   82,   78,   78,   83,   84,  269,  288,

      290,  788,  279,  183,  195,  294,  156,   85,   86,  166,
      166,  166,  166,  166,  156,  205,  205,  170,   78,   83,
       84,  170,  288,  203,  280,  155,   85,  284,  170,  170,
      276,  787,  204,   87,   88,   28,   89,   75,   76,   77,
       78,   78,   79,   80,   81,  167,  170,  280,  266,  209,
      284,  219,  169,  335,   78,   82,   78,   78,   83,   84,
      263,  166,  783,  166,  264,  264,  264,  264,  264,   85,
       86,  266,  180,  180,  180,  180,  180,  296,  224,  169,
       78,   83,   84,  298,  156,  183,  301,  297,   85,  274,
      305,  319,  210,  299,  220,   87,   88,   28,   89,   91,

      265,   92,  273,  533,   93,   94,   95,  274,  181,  195,
      109,  170,  156,  235,  319,  782,  264,  109,  264,  321,
       96,  225,  281,  533,  180,  273,  180,  781,  322,  270,
      285,   97,   98,  271,  271,  271,  271,  271,  170,  312,
      281,  216,  321,   96,  302,  217,  217,  303,  306,  313,
       97,  322,  304,  285,  317,  218,  236,   99,  100,   28,
      101,   91,  320,   92,  318,  303,   93,   94,   95,  272,
      304,  237,  238,  323,  325,  329,  324,  344,  767,  336,
      320,  326,   96,  243,  244,  271,  331,  271,  239,  240,
      241,  352,  183,   97,   98,  324,  323,  325,  329,  326,

      245,  246,  247,  774,  183,   96,  773,  331,  347,  109,
      358,  293,   97,  330,  242,  155,  338,  339,  169,   99,
      100,   28,  101,  141,  348,  195,  248,  294,  358,  341,
      351,  347,  357,  142,  361,  345,  143,  144,  156,  342,
      349,  372,  355,  145,  480,  146,  147,  341,  772,  353,
      148,  149,  361,  351,  481,  357,  142,  342,  359,  143,
      346,  355,  145,  146,  147,  159,  160,  161,  160,  160,
      160,  160,  160,  360,  156,  170,  170,  170,  346,  362,
      363,  359,  160,  160,  160,  160,  364,  365,  367,  369,
      374,  183,  376,  109,  379,  348,  360,  380,  363,  373,

      381,  383,  362,  385,  384,  365,  368,  370,  160,  364,
      376,  349,  371,  382,  400,  380,  771,  379,  381,  383,
      387,  377,  384,  160,  162,  160,  160,  173,  174,  175,
      174,  174,  174,  174,  174,  371,  382,  389,  387,  367,
      369,  392,  377,  406,  174,  403,  174,  174,  375,  109,
      183,  407,  408,  389,  393,  393,  393,  368,  370,  409,
      504,  386,  412,  403,  763,  413,  406,  762,  423,  388,
      174,  761,  401,  183,  407,  408,  394,  449,  399,  415,
      412,  402,  409,  413,  423,  174,  176,  174,  174,  186,
      187,  188,  187,  187,  187,  187,  187,  760,  395,  399,

      402,  410,  415,  416,  392,  418,  187,  187,  187,  187,
      396,  420,  397,  393,  393,  393,  398,  393,  393,  393,
      410,  395,  421,  109,  418,  424,  416,  428,  396,  429,
      397,  445,  187,  446,  420,  450,  431,  183,  394,  426,
      421,  434,  436,  424,  443,  435,  432,  187,  187,  187,
      187,  159,  160,  161,  160,  160,  160,  160,  160,  419,
      395,  436,  426,  435,  434,  433,  437,  443,  160,  160,
      160,  160,  396,  438,  397,  440,  469,  419,  398,  442,
      428,  459,  429,  395,  437,  430,  431,  461,  462,  447,
      396,  438,  397,  440,  160,  469,  452,  442,  453,  459,

      463,  466,  449,  484,  460,  461,  462,  477,  475,  160,
      162,  160,  160,  173,  174,  175,  174,  174,  174,  174,
      174,  484,  480,  463,  466,  445,  471,  446,  472,  486,
      174,  475,  174,  174,  447,  752,  493,  504,  430,  431,
      452,  494,  453,  452,  506,  453,  489,  505,  497,  471,
      498,  472,  501,  447,  454,  455,  174,  477,  490,  493,
      450,  431,  506,  511,  494,  478,  431,  471,  507,  472,
      486,  174,  176,  174,  174,  186,  187,  188,  187,  187,
      187,  187,  187,  447,  473,  509,  508,  430,  487,  480,
      525,  486,  187,  187,  187,  187,  489,  540,  454,  455,

      489,  454,  455,  509,  491,  492,  499,  473,  534,  515,
      502,  516,  520,  525,  521,  478,  431,  501,  187,  532,
      540,  512,  513,  542,  522,  473,  511,  489,  430,  487,
      497,  480,  498,  187,  187,  187,  187,  449,  532,  507,
      513,  504,  549,  457,  457,  457,  457,  457,  750,  430,
      487,  536,  553,  537,  491,  492,  550,  508,  491,  492,
      747,  547,  528,  548,  558,  549,  499,  517,  518,  486,
      523,  524,  480,  544,  550,  502,  515,  746,  516,  457,
      528,  543,  480,  480,  512,  491,  492,  515,  499,  516,
      489,  544,  555,  561,  552,  458,  431,  457,  452,  547,

      453,  548,  565,  489,  482,  482,  482,  482,  482,  538,
      554,  487,  520,  567,  521,  570,  520,  552,  521,  520,
      576,  521,  559,  492,  489,  745,  489,  430,  487,  534,
      536,  567,  537,  570,  517,  518,  568,  536,  571,  537,
      482,  574,  577,  576,  542,  517,  518,  553,  491,  492,
      566,  575,  731,  515,  560,  516,  483,  455,  482,  486,
      577,  491,  492,  578,  730,  526,  526,  526,  526,  526,
      523,  524,  560,  566,  523,  524,  581,  523,  524,  588,
      587,  578,  491,  492,  491,  492,  480,  499,  538,  480,
      558,  480,  614,  597,  581,  538,  572,  588,  520,  480,

      521,  526,  543,  587,  614,  554,  487,  520,  504,  521,
      589,  517,  518,  520,  749,  521,  597,  527,  487,  526,
      489,  600,  591,  649,  595,  592,  530,  530,  530,  530,
      530,  594,  603,  608,  520,  611,  521,  489,  574,  571,
      591,  489,  595,  605,  600,  613,  596,  616,  559,  492,
      489,  608,  615,  611,  594,  603,  523,  524,  627,  618,
      605,  607,  530,  599,  615,  523,  524,  480,  613,  504,
      616,  523,  524,  717,  627,  715,  598,  691,  531,  492,
      530,  515,  618,  516,  607,  601,  620,  556,  556,  556,
      556,  556,  523,  524,  598,  491,  492,  572,  623,  491,

      492,  606,  612,  601,  620,  520,  633,  521,  491,  492,
      480,  480,  520,  480,  521,  632,  623,  480,  606,  520,
      612,  521,  489,  556,  634,  677,  705,  640,  574,  489,
      704,  624,  619,  621,  635,  625,  489,  693,  632,  557,
      518,  556,  520,  638,  521,  640,  628,  622,  562,  562,
      562,  562,  562,  629,  626,  619,  621,  635,  625,  644,
      631,  637,  645,  523,  524,  622,  638,  504,  480,  628,
      523,  524,  626,  643,  648,  644,  629,  523,  524,  637,
      491,  492,  651,  631,  562,  645,  642,  491,  492,  480,
      520,  643,  521,  658,  491,  492,  520,  648,  521,  489,

      563,  524,  562,  660,  520,  651,  521,  647,  489,  642,
      689,  489,  633,  653,  650,  665,  658,  666,  661,  574,
      652,  660,  668,  647,  669,  656,  671,  670,  654,  662,
      634,  663,  664,  665,  659,  489,  673,  650,  504,  480,
      666,  667,  676,  652,  671,  668,  681,  669,  523,  524,
      670,  654,  657,  678,  523,  524,  480,  491,  492,  673,
      675,  679,  523,  524,  667,  676,  491,  492,  657,  491,
      492,  520,  672,  521,  696,  520,  675,  521,  683,  520,
      687,  521,  674,  695,  679,  690,  690,  690,  489,  661,
      672,  574,  696,  491,  492,  686,  687,  680,  489,  691,

      662,  683,  663,  664,  691,  684,  695,  698,  699,  701,
      692,  480,  685,  697,  480,  694,  682,  702,  707,  489,
      504,  710,  688,  706,  655,  698,  700,  701,  574,  523,
      524,  489,  682,  523,  524,  685,  697,  523,  524,  706,
      702,  707,  703,  489,  710,  688,  491,  492,  720,  520,
      708,  521,  520,  712,  521,  691,  491,  492,  520,  693,
      521,  691,  721,  722,  693,  703,  708,  504,  719,  712,
      480,  720,  714,  709,  690,  690,  690,  491,  492,  691,
      723,  722,  713,  727,  716,  721,  699,  480,  714,  491,
      492,  728,  718,  718,  718,  724,  709,  724,  732,  646,

      716,  491,  492,  723,  700,  713,  727,  523,  524,  728,
      523,  524,  711,  735,  732,  693,  523,  524,  520,  740,
      521,  693,  520,  691,  521,  729,  489,  742,  733,  735,
      520,  741,  521,  489,  574,  691,  718,  718,  718,  693,
      748,  744,  740,  489,  725,  736,  489,  726,  719,  741,
      742,  724,  520,  724,  521,  754,  743,  744,  520,  734,
      521,  641,  776,  748,  757,  639,  636,  756,  574,  630,
      520,  737,  521,  755,  574,  734,  523,  524,  759,  743,
      523,  524,  757,  693,  491,  492,  738,  737,  523,  524,
      756,  491,  492,  739,  574,  693,  759,  520,  768,  521,

      725,  491,  492,  726,  491,  492,  754,  758,  769,  770,
      523,  524,  751,  765,  768,  766,  523,  524,  753,  765,
      777,  766,  778,  758,  755,  779,  776,  770,  523,  524,
      784,  769,  789,  574,  784,  793,  798,  793,  798,  790,
      778,  779,  801,  798,  801,  798,  801,  617,  801,  585,
      789,  583,  780,  610,  609,  523,  524,  574,  604,  602,
      593,  590,  586,  585,  583,  579,  569,  564,  551,  545,
      504,  541,  539,  767,  529,  480,  510,  495,  465,  767,
      476,  474,  468,  467,  777,  465,  464,  456,  448,  441,
      785,  439,  433,  432,  785,  794,  799,  794,  425,  422,

      417,  414,  802,  799,  411,  405,  802,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
       28,   28,   28,   47,   47,   47,   47,   47,   47,   47,
       47,   47,   47,   47,   47,   47,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   90,   90,   90,   90,   90,   90,   90,   90,
       90,   90,   90,   90,   90,  102,  102,  102,  102,  102,
      102,  102,  102,  102,  102,  102,  102,  102,  108,  108,

      108,  108,  108,  404,  108,  378,  108,  108,  391,  390,
      108,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  116,  388,  354,  116,  116,  378,
      116,  116,  116,  350,  116,  366,  116,  118,  356,  307,
      118,  118,  354,  118,  118,  118,  350,  118,  343,  118,
      120,  120,  120,  120,  120,  120,  340,  337,  334,  120,
      120,  120,  120,  131,  333,  332,  131,  131,  328,  131,
      131,  131,  327,  131,  316,  131,  154,  154,  315,  154,
      314,  311,  310,  309,  154,  308,  307,  154,  158,  158,
      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,

      158,  168,  168,  300,  168,  295,  295,  292,  291,  168,
      168,  208,  168,  172,  172,  172,  172,  172,  172,  172,
      172,  172,  172,  172,  172,  172,  182,  182,  283,  182,
      196,  195,  282,  183,  182,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  194,  194,
      194,  277,  194,  277,  184,  183,  194,  194,  197,  197,
      197,  270,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  202,  202,  202,  202,  202,  202,  202,  202,  202,
      202,  202,  202,  202,  207,  207,  207,  207,  207,  207,
      207,  207,  207,  207,  207,  207,  207,  212,  212,  212,

      270,  212,  212,  212,  212,  212,  212,  212,  212,  212,
      213,  213,  213,  171,  213,  213,  213,  213,  213,  213,
      213,  213,  213,  215,  215,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  215,  228,  228,  228,  263,
      228,  228,  228,  228,  228,  228,  228,  228,  228,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  160,
      160,  160,  174,  174,  174,  174,  174,  174,  174,  174,
      174,  174,  174,  174,  174,  187,  187,  187,  187,  187,
      187,  187,  187,  187,  187,  187,  187,  187,  217,  217,
      217,  217,  217,  217,  217,  217,  217,  217,  217,  217,

      217,  427,  427,  427,  427,  427,  427,  427,  427,  427,
      427,  427,  427,  427,  444,  444,  444,  444,  444,  444,
      444,  444,  444,  444,  444,  444,  444,  451,  451,  451,
      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
      470,  470,  470,  470,  470,  470,  470,  470,  470,  470,
      470,  470,  470,  479,  479,  479,  479,  479,  479,  479,
      479,  479,  479,  479,  479,  479,  485,  485,  485,  485,
      485,  485,  485,  485,  485,  485,  485,  485,  485,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  496,  496,  496,  496,  496,  496,  496,  496,

      496,  496,  496,  496,  496,  503,  503,  503,  503,  503,
      503,  503,  503,  503,  503,  503,  503,  503,  514,  514,
      514,  514,  514,  514,  514,  514,  514,  514,  514,  514,
      514,  519,  519,  519,  519,  519,  519,  519,  519,  519,
      519,  519,  519,  519,  535,  535,  535,  535,  535,  535,
      535,  535,  535,  535,  535,  535,  535,  546,  546,  546,
      546,  546,  546,  546,  546,  546,  546,  546,  546,  573,
      573,  573,  573,  573,  573,  573,  573,  573,  573,  573,
      573,  573,  582,  582,  582,  582,  582,  582,  582,  582,
      582,  582,  582,  582,  582,  584,  584,  584,  584,  584,

      584,  584,  584,  584,  584,  584,  584,  584,  764,  764,
      764,  764,  764,  764,  764,  764,  764,  764,  764,  764,
      764,  775,  775,  775,  775,  775,  775,  775,  775,  775,
      775,  775,  775,  775,  786,  786,  786,  786,  786,  786,
      786,  786,  786,  786,  786,  786,  786,  263,  157,  262,
      261,  252,  803,  221,  214,  803,  803,  211,  115,  109,
      208,  196,  195,  184,  183,  171,  157,  153,  152,  151,
      132,  119,  117,  115,  113,  109,  803,   46,   46,   17,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803
    } ;

static yyconst short int yy_chk[2545] =
    {   0,
        0,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,   19,   19,   20,   20,   26,   30,   26,  796,    1,
        1,    1,    1,    1,    1,    0,   33,   41,   41,   34,
      102,    3,    3,   29,    1,    1,   47,   31,   99,  102,
       36,   84,    3,    4,    4,    1,    1,    1,   57,  104,
      104,   29,   37,    1,    4,   31,   61,   99,   33,   30,
        1,    1,   34,    1,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,   84,   36,   29,   33,    3,   37,
       31,   57,    2,    2,    2,    2,    2,    2,    3,   37,
        4,  791,    3,   36,   97,   47,  790,    2,    2,  113,

        4,  110,  110,  143,    4,   56,   70,   57,    2,    2,
        2,  111,  111,  112,  112,   61,    2,   69,   97,  123,
       86,  143,   58,    2,    2,  789,    2,    7,    7,    7,
        7,    7,    7,    7,    7,   15,   15,   56,   15,   70,
      135,   97,  113,   15,    7,    7,    7,    7,    7,   69,
       16,   16,   15,   16,  124,   86,   56,   58,   16,    7,
        7,  135,  123,   98,   56,   70,   71,   16,   69,  468,
        7,    7,   83,   86,  126,   58,   69,  128,    7,   35,
      788,   58,  144,   96,  135,    7,    7,    7,    7,    8,
        8,    8,    8,    8,    8,    8,    8,  124,   98,  129,

      468,   71,  202,   35,   83,  144,    8,    8,    8,    8,
        8,  202,   35,   85,  127,   96,   98,  126,  137,   71,
      128,    8,    8,   83,  127,   71,   35,   60,   60,   60,
       60,   60,    8,    8,   96,  150,  150,   85,  136,  138,
        8,  544,  129,  121,  133,  121,   85,    8,    8,    8,
        8,    9,    9,    9,    9,    9,    9,    9,    9,  121,
       85,  103,  103,   60,  130,  200,  544,  133,    9,  103,
        9,    9,    9,  134,  130,  136,  137,  145,  103,   60,
      147,   60,  138,    9,    9,   73,   73,   73,   73,   73,
      133,  154,  122,  136,    9,    9,  122,  122,  786,  148,

      145,  161,    9,  147,  164,  134,  122,  783,  149,    9,
        9,    9,    9,   10,   10,   10,   10,   10,   10,   10,
       10,   73,  148,  200,  134,  139,  139,  141,  146,  165,
       10,  149,   10,   10,   10,  141,  146,   73,  189,   73,
      141,  164,  139,  139,  139,   10,   10,  166,  140,  140,
      154,  190,  782,  141,  146,  167,   10,   10,  168,  164,
      161,  189,  175,  164,   10,  140,  140,  140,  139,  179,
      180,   10,   10,   10,   10,   11,   11,   11,   11,   11,
       11,   11,   11,  190,  189,  206,  206,  181,  165,  216,
      210,  140,   11,   11,   11,   11,   11,   11,  167,  201,

      210,  778,  190,  191,  198,  216,  166,   11,   11,  156,
      156,  156,  156,  156,  167,  205,  205,  168,   11,   11,
       11,  175,  201,  205,  191,  163,   11,  198,  179,  180,
      181,  777,  205,   11,   11,   11,   11,   12,   12,   12,
       12,   12,   12,   12,   12,  156,  181,  191,  163,  209,
      198,  219,  178,  266,   12,   12,   12,   12,   12,   12,
      162,  156,  773,  156,  162,  162,  162,  162,  162,   12,
       12,  163,  170,  170,  170,  170,  170,  220,  224,  177,
       12,   12,   12,  225,  163,  192,  229,  220,   12,  178,
      232,  249,  209,  225,  219,   12,   12,   12,   12,   13,

      162,   13,  177,  494,   13,   13,   13,  178,  170,  199,
      230,  178,  266,  235,  249,  772,  162,  231,  162,  251,
       13,  224,  192,  494,  170,  177,  170,  771,  252,  176,
      199,   13,   13,  176,  176,  176,  176,  176,  177,  242,
      192,  215,  251,   13,  229,  215,  215,  230,  232,  242,
       13,  252,  231,  199,  248,  215,  235,   13,   13,   13,
       13,   14,  250,   14,  248,  230,   14,   14,   14,  176,
      231,  237,  237,  253,  255,  259,  254,  284,  764,  267,
      250,  256,   14,  243,  243,  176,  260,  176,  237,  237,
      237,  304,  279,   14,   14,  254,  253,  255,  259,  256,

      243,  243,  243,  763,  280,   14,  761,  260,  288,  303,
      322,  293,   14,  259,  237,  269,  273,  274,  276,   14,
       14,   14,   14,   38,  295,  285,  243,  293,  322,  279,
      303,  288,  321,   38,  325,  284,   38,   38,  267,  280,
      295,  342,  319,   38,  454,   38,   38,  279,  760,  304,
       38,   38,  325,  303,  454,  321,   38,  280,  323,   38,
      285,  319,   38,   38,   38,   50,   50,   50,   50,   50,
       50,   50,   50,  324,  269,  273,  274,  276,  285,  326,
      327,  323,   50,   50,   50,   50,  328,  329,  332,  333,
      346,  341,  347,  351,  355,  348,  324,  356,  327,  342,

      357,  359,  326,  361,  360,  329,  332,  333,   50,  328,
      347,  348,  341,  358,  376,  356,  759,  355,  357,  359,
      362,  351,  360,   50,   50,   50,   50,   64,   64,   64,
       64,   64,   64,   64,   64,  341,  358,  364,  362,  367,
      369,  368,  351,  382,   64,  379,   64,   64,  346,  377,
      371,  383,  384,  364,  368,  368,  368,  367,  369,  387,
      749,  361,  390,  379,  748,  391,  382,  747,  407,  388,
       64,  746,  376,  399,  383,  384,  370,  427,  371,  396,
      390,  377,  387,  391,  407,   64,   64,   64,   64,   77,
       77,   77,   77,   77,   77,   77,   77,  745,  370,  371,

      377,  388,  396,  397,  392,  399,   77,   77,   77,   77,
      370,  403,  370,  393,  393,  393,  370,  392,  392,  392,
      388,  370,  405,  402,  399,  408,  397,  411,  370,  411,
      370,  425,   77,  425,  403,  427,  427,  418,  394,  410,
      405,  414,  416,  408,  424,  415,  432,   77,   77,   77,
       77,  158,  158,  158,  158,  158,  158,  158,  158,  402,
      394,  416,  410,  415,  414,  433,  417,  424,  158,  158,
      158,  158,  394,  418,  394,  420,  444,  402,  394,  423,
      428,  432,  428,  394,  417,  411,  411,  434,  436,  425,
      394,  418,  394,  420,  158,  469,  429,  423,  429,  432,

      437,  440,  449,  456,  433,  434,  436,  453,  448,  158,
      158,  158,  158,  172,  172,  172,  172,  172,  172,  172,
      172,  456,  736,  437,  440,  445,  446,  445,  446,  457,
      172,  448,  172,  172,  444,  735,  459,  473,  428,  428,
      451,  460,  451,  452,  474,  452,  458,  473,  467,  470,
      467,  470,  472,  469,  429,  429,  172,  477,  458,  459,
      449,  449,  474,  480,  460,  453,  453,  471,  475,  471,
      485,  172,  172,  172,  172,  185,  185,  185,  185,  185,
      185,  185,  185,  445,  446,  476,  475,  457,  457,  481,
      484,  486,  185,  185,  185,  185,  488,  500,  451,  451,

      489,  452,  452,  476,  458,  458,  467,  470,  496,  482,
      472,  482,  483,  484,  483,  477,  477,  501,  185,  493,
      500,  480,  481,  504,  483,  471,  511,  490,  485,  485,
      497,  733,  497,  185,  185,  185,  185,  431,  493,  507,
      481,  505,  509,  431,  431,  431,  431,  431,  732,  486,
      486,  498,  516,  498,  488,  488,  510,  507,  489,  489,
      727,  508,  490,  508,  521,  509,  496,  482,  482,  526,
      483,  483,  513,  505,  510,  501,  514,  726,  514,  431,
      490,  504,  517,  523,  511,  490,  490,  515,  497,  515,
      527,  505,  517,  523,  513,  431,  431,  431,  455,  547,

      455,  547,  527,  530,  455,  455,  455,  455,  455,  498,
      516,  516,  519,  529,  519,  533,  520,  513,  520,  522,
      539,  522,  521,  521,  531,  725,  528,  526,  526,  534,
      535,  529,  535,  533,  514,  514,  531,  536,  537,  536,
      455,  538,  540,  539,  542,  515,  515,  553,  527,  527,
      528,  538,  706,  556,  522,  556,  455,  455,  455,  487,
      540,  530,  530,  541,  704,  487,  487,  487,  487,  487,
      519,  519,  522,  528,  520,  520,  545,  522,  522,  551,
      550,  541,  531,  531,  528,  528,  552,  534,  535,  555,
      558,  561,  585,  564,  545,  536,  537,  551,  562,  621,

      562,  487,  542,  550,  614,  553,  553,  560,  729,  560,
      552,  556,  556,  557,  729,  557,  564,  487,  487,  487,
      492,  567,  555,  621,  561,  557,  492,  492,  492,  492,
      492,  560,  570,  576,  563,  579,  563,  566,  575,  571,
      555,  565,  561,  574,  567,  581,  563,  586,  558,  558,
      568,  576,  585,  579,  560,  570,  562,  562,  597,  588,
      605,  575,  492,  566,  614,  560,  560,  647,  581,  580,
      586,  557,  557,  689,  597,  687,  565,  691,  492,  492,
      492,  518,  588,  518,  575,  568,  590,  518,  518,  518,
      518,  518,  563,  563,  565,  566,  566,  571,  593,  565,

      565,  574,  580,  568,  590,  594,  603,  594,  568,  568,
      589,  591,  592,  595,  592,  602,  593,  677,  605,  596,
      580,  596,  598,  518,  603,  647,  675,  610,  607,  599,
      673,  594,  589,  591,  604,  595,  601,  691,  602,  518,
      518,  518,  524,  608,  524,  610,  598,  592,  524,  524,
      524,  524,  524,  599,  596,  589,  591,  604,  595,  616,
      601,  607,  617,  594,  594,  592,  608,  612,  619,  598,
      592,  592,  596,  613,  620,  616,  599,  596,  596,  607,
      598,  598,  623,  601,  524,  617,  612,  599,  599,  625,
      622,  613,  622,  630,  601,  601,  624,  620,  624,  628,

      524,  524,  524,  632,  626,  623,  626,  619,  631,  612,
      660,  629,  633,  625,  622,  635,  630,  636,  634,  637,
      624,  632,  638,  619,  639,  628,  641,  640,  626,  634,
      633,  634,  634,  635,  631,  657,  643,  622,  642,  649,
      636,  637,  646,  624,  641,  638,  651,  639,  622,  622,
      640,  626,  629,  648,  624,  624,  653,  628,  628,  643,
      645,  649,  626,  626,  637,  646,  631,  631,  629,  629,
      629,  650,  642,  650,  666,  652,  645,  652,  653,  654,
      658,  654,  644,  665,  649,  662,  662,  662,  656,  661,
      642,  667,  666,  657,  657,  657,  658,  650,  659,  663,

      661,  653,  661,  661,  664,  654,  665,  668,  669,  670,
      663,  679,  656,  667,  683,  664,  652,  671,  678,  686,
      672,  681,  659,  676,  627,  668,  669,  670,  697,  650,
      650,  685,  652,  652,  652,  656,  667,  654,  654,  676,
      671,  678,  672,  688,  681,  659,  656,  656,  695,  680,
      679,  680,  682,  683,  682,  694,  659,  659,  684,  663,
      684,  690,  696,  697,  664,  672,  679,  703,  694,  683,
      708,  695,  685,  680,  690,  690,  690,  686,  686,  692,
      698,  697,  684,  701,  688,  696,  699,  712,  685,  685,
      685,  702,  692,  692,  692,  700,  680,  700,  707,  618,

      688,  688,  688,  698,  699,  684,  701,  680,  680,  702,
      682,  682,  682,  710,  707,  694,  684,  684,  709,  717,
      709,  690,  711,  718,  711,  703,  714,  721,  708,  710,
      713,  720,  713,  716,  722,  719,  718,  718,  718,  692,
      728,  723,  717,  738,  700,  712,  739,  700,  719,  720,
      721,  724,  734,  724,  734,  740,  722,  723,  737,  709,
      737,  611,  766,  728,  742,  609,  606,  741,  743,  600,
      751,  713,  751,  740,  758,  709,  709,  709,  744,  722,
      711,  711,  742,  718,  714,  714,  714,  713,  713,  713,
      741,  716,  716,  716,  770,  719,  744,  753,  756,  753,

      724,  738,  738,  724,  739,  739,  754,  743,  757,  758,
      734,  734,  734,  755,  756,  755,  737,  737,  737,  765,
      766,  765,  768,  743,  754,  769,  775,  758,  751,  751,
      776,  757,  779,  780,  784,  787,  792,  793,  792,  780,
      768,  769,  797,  798,  797,  798,  801,  587,  801,  584,
      779,  582,  770,  578,  577,  753,  753,  573,  572,  569,
      559,  554,  549,  548,  546,  543,  532,  525,  512,  506,
      503,  502,  499,  755,  491,  479,  478,  466,  465,  765,
      450,  447,  443,  442,  775,  439,  438,  430,  426,  421,
      776,  419,  413,  412,  784,  787,  792,  793,  409,  406,

      398,  395,  797,  798,  389,  381,  801,  804,  804,  804,
      804,  804,  804,  804,  804,  804,  804,  804,  804,  804,
      805,  805,  805,  805,  805,  805,  805,  805,  805,  805,
      805,  805,  805,  806,  806,  806,  806,  806,  806,  806,
      806,  806,  806,  806,  806,  806,  807,  807,  807,  807,
      807,  807,  807,  807,  807,  807,  807,  807,  807,  808,
      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
      808,  808,  809,  809,  809,  809,  809,  809,  809,  809,
      809,  809,  809,  809,  809,  810,  810,  810,  810,  810,
      810,  810,  810,  810,  810,  810,  810,  810,  811,  811,

      811,  811,  811,  380,  811,  378,  811,  811,  366,  365,
      811,  812,  812,  812,  812,  812,  812,  812,  812,  812,
      812,  812,  812,  812,  813,  363,  354,  813,  813,  352,
      813,  813,  813,  350,  813,  331,  813,  814,  320,  307,
      814,  814,  305,  814,  814,  814,  301,  814,  281,  814,
      815,  815,  815,  815,  815,  815,  278,  272,  265,  815,
      815,  815,  815,  816,  262,  261,  816,  816,  258,  816,
      816,  816,  257,  816,  247,  816,  817,  817,  245,  817,
      244,  241,  239,  238,  817,  236,  233,  817,  818,  818,
      818,  818,  818,  818,  818,  818,  818,  818,  818,  818,

      818,  819,  819,  228,  819,  218,  217,  213,  212,  819,
      819,  207,  819,  820,  820,  820,  820,  820,  820,  820,
      820,  820,  820,  820,  820,  820,  821,  821,  197,  821,
      196,  194,  193,  188,  821,  822,  822,  822,  822,  822,
      822,  822,  822,  822,  822,  822,  822,  822,  823,  823,
      823,  187,  823,  186,  184,  182,  823,  823,  824,  824,
      824,  174,  824,  824,  824,  824,  824,  824,  824,  824,
      824,  825,  825,  825,  825,  825,  825,  825,  825,  825,
      825,  825,  825,  825,  826,  826,  826,  826,  826,  826,
      826,  826,  826,  826,  826,  826,  826,  827,  827,  827,

      173,  827,  827,  827,  827,  827,  827,  827,  827,  827,
      828,  828,  828,  171,  828,  828,  828,  828,  828,  828,
      828,  828,  828,  829,  829,  829,  829,  829,  829,  829,
      829,  829,  829,  829,  829,  829,  830,  830,  830,  160,
      830,  830,  830,  830,  830,  830,  830,  830,  830,  831,
      831,  831,  831,  831,  831,  831,  831,  831,  831,  831,
      831,  831,  832,  832,  832,  832,  832,  832,  832,  832,
      832,  832,  832,  832,  832,  833,  833,  833,  833,  833,
      833,  833,  833,  833,  833,  833,  833,  833,  834,  834,
      834,  834,  834,  834,  834,  834,  834,  834,  834,  834,

      834,  835,  835,  835,  835,  835,  835,  835,  835,  835,
      835,  835,  835,  835,  836,  836,  836,  836,  836,  836,
      836,  836,  836,  836,  836,  836,  836,  837,  837,  837,
      837,  837,  837,  837,  837,  837,  837,  837,  837,  837,
      838,  838,  838,  838,  838,  838,  838,  838,  838,  838,
      838,  838,  838,  839,  839,  839,  839,  839,  839,  839,
      839,  839,  839,  839,  839,  839,  840,  840,  840,  840,
      840,  840,  840,  840,  840,  840,  840,  840,  840,  841,
      841,  841,  841,  841,  841,  841,  841,  841,  841,  841,
      841,  841,  842,  842,  842,  842,  842,  842,  842,  842,

      842,  842,  842,  842,  842,  843,  843,  843,  843,  843,
      843,  843,  843,  843,  843,  843,  843,  843,  844,  844,
      844,  844,  844,  844,  844,  844,  844,  844,  844,  844,
      844,  845,  845,  845,  845,  845,  845,  845,  845,  845,
      845,  845,  845,  845,  846,  846,  846,  846,  846,  846,
      846,  846,  846,  846,  846,  846,  846,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  848,
      848,  848,  849,  849,  849,  849,  849,  849,  849,  849,
      849,  849,  849,  849,  849,  850,  850,  850,  850,  850,

      850,  850,  850,  850,  850,  850,  850,  850,  851,  851,
      851,  851,  851,  851,  851,  851,  851,  851,  851,  851,
      851,  852,  852,  852,  852,  852,  852,  852,  852,  852,
      852,  852,  852,  852,  853,  853,  853,  853,  853,  853,
      853,  853,  853,  853,  853,  853,  853,  159,  157,  152,
      151,  142,  131,  125,  120,  118,  116,  115,  114,  108,
      105,   91,   90,   75,   74,   62,   48,   46,   44,   43,
       32,   24,   23,   22,   21,   18,   17,    6,    5,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() (yy_more_flag = 1)
#define YY_MORE_ADJ yy_more_len
#define YY_RESTORE_YY_MORE_OFFSET
#define INITIAL 0
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       parser.l
//
//  Contents:   Lex rules for parser
//
//  Notes:      Written for flex version 2.5.4
//
//  History:    10-01-97        emilyb  created
//
//----------------------------------------------------------------------------

class CValueParser;

#include "yybase.hxx"
#include "parser.h" 
#include "parsepl.h"
#include "flexcpp.h"

#define TOKEN(tknNum)  return (tknNum);
#define STRING_VALUE(tknNum, fLong, fQuote)     \
        {       \
            if (!IsTokenEmpty())        \
                return CreateTknValue(yylval, tknNum, fLong, fQuote);   \
        }

/*
** Make Lex read from a block of data
**    buffer is the character buffer,
**    result is a variable to store the number of chars read
**    ms is the size of the buffer
*/
#undef YY_INPUT
#define YY_INPUT(b, r, ms) (r = yybufferinput(b, ms))

DECLARE_INFOLEVEL(yacc)

//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::IsTokenEmpty 
//
//  Synopsis:   Determines if a token is empty. An empty token only has 
//              whitespace or has nothing in it.
//
//  Arguments:  None.
//
//  Returns:    Boolean value.
//
//  History:    08-APR-98        KrishnaN  created
//
//----------------------------------------------------------------------------

BOOL YYLEXER::IsTokenEmpty()
{
    LPWSTR pwsz = yytext;
    
    Win4Assert(pwsz);
    
    while (*pwsz != 0)
    {
        if (*pwsz != L' ' && *pwsz != L'\t')
            return FALSE;
        pwsz++;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::IsNotOperator 
//
//  Synopsis:   Determines if we have a not operator.
//
//  Arguments:  None.
//
//  Returns:    Boolean value.
//
//  History:    08-DEC-98        KrishnaN  created
//
//----------------------------------------------------------------------------

BOOL YYLEXER::IsNotOperator()
{
    LPWSTR pwsz = yytext;
    
    Win4Assert(pwsz);
    
    // skip past leading spaces
    int i = 0;
    while (*pwsz != 0 && (*pwsz == L' ' || *pwsz == L'\t'))
    {
        pwsz++;
        i++;
    }
    
    // If we don't have at least four chars to consider, we don't have a 
    // not operator.
    if (yyleng < i+4)
        return FALSE;
    
    if ( (*pwsz == L'n' || *pwsz == L'N') &&
         (*(pwsz+1) == L'o' || *(pwsz+1) == L'O') &&
         (*(pwsz+2) == L't' || *(pwsz+2) == L'T') &&
         (*(pwsz+3) == L'@' || *(pwsz+3) == L'#' || *(pwsz+3) == L'$')
       )
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::CreateTknValue 
//
//  Synopsis:   Allocs a WCHAR string which is passed to the YACC value stack.  
//
//  Arguments:  [ppStg]  -- set to pointer to alloc'd memory
//              [tknNum] -- token id
//              [fLong]  -- true if token is in longhand version
//              [fQuote] -- true if token is quoted
//
//  Returns:    Updated token id
//
//  History:    10-01-97        emilyb  created
//
//----------------------------------------------------------------------------

short YYLEXER::CreateTknValue(YYSTYPE *ppStg, short tknNum, BOOL fLong, BOOL fQuote )
{
    HRESULT hr = S_OK;
    short retTkn = tknNum;
    LPWSTR pwsz = yytext;
    
    if (!fQuote)    
    {
        // If we see a double quote, consider the string quoted.
        while (L' ' == *pwsz)
            pwsz++;
        if (*pwsz == L'"')
        {
            // strip trailing blanks and check if we see a trailing "
            
            LPWSTR pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }
            
            if (*pLast == L'"' && pLast > pwsz )
                fQuote = TRUE;
        }
    }
    
    // start parsing from the beginning of the string
    pwsz = yytext;
    
    if (_PHRASEORREGEX == tknNum)
    {
        // A quoted string is always a phrase.
        if (fQuote)
            retTkn = _PHRASE;
        else
            retTkn = DetermineTokenType();
    }

    switch (retTkn)
    {
    case _PHRASE:

        {    
            LPWSTR pLast;

            pLast = pwsz + wcslen(pwsz) - 1;

            // if long version, find the phrase
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{phrase}");
                pLast = pLast - wcslen(L"{/phrase}"+1);
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    
            // NOTE: Don't strip double quotes here, they will be stripped later
            
            yaccDebugOut((DEB_ITRACE, "Phrase %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;
    case _PROPNAME:

        {
            LPWSTR pLast;
            
            if (fLong)  // looks like: { prop name = "prop name"  }
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++; 

                pLast = pwsz + wcslen(pwsz) - 1;
                Win4Assert( *pLast == L'}');
                *pLast-- = L'\0';
            }
            else
            {
                // Strip @ or # or $ token
                Win4Assert(*pwsz == L'@' || *pwsz == L'#' || *pwsz == L'$');
                pwsz = pwsz + 1;
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast--= L'\0';
            }    

            if (fQuote)
            {
                pwsz++;
                *pLast = L'\0';                              
            }

            yaccDebugOut((DEB_ITRACE, "Propname %ws in %ws format and %ws\n", 
                          pwsz, fLong ? L"Long" : L"Short", fQuote ? L"quoted" : L"unquoted"));
        }
        break;                
    case _FREETEXT:
        {    
            LPWSTR pLast;

            // if long version, find the FREETEXT
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{freetext}");
                pLast = pwsz + wcslen(pwsz) - 1;                
                pLast = pLast - wcslen(L"{/freetext}")+1;
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    

            if (fQuote)
            {
                Win4Assert(pLast >= pwsz+1);
                // Strip quotes
                pwsz = pwsz + 1;
                *pLast = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "Freetext %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;

    case _REGEX:
        {
            LPWSTR pLast;

            // if long version, find the regex
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{regex}");
                pLast = pwsz + wcslen(pwsz);                
                pLast = pLast - wcslen(L"{/regex}");
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }
            
            // strip leading blanks
            while (L' ' == *pwsz)
                pwsz++;
                
            // If the first char is =, ignore it. We only ignore the first
            // = character. This is backward compatible with Triplish1
            if (L'=' == *pwsz)
                pwsz++;

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;
                
            pLast = pwsz + wcslen(pwsz) - 1;
            
            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    
                
            // After we strip a leading =, we might have a quoted phrase
            // Check only if fQuote is false.
            // We don't want to deal with an unpaired double quote.
            if (!fQuote && *pwsz == L'"' && *pLast == L'"' && pLast > pwsz )
                fQuote = TRUE;
                
            if (fQuote)
            {
                Win4Assert(pLast >= pwsz+1);
                // Strip quotes
                pwsz = pwsz + 1;
                *pLast = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "RegEx %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                

    case _WEIGHT:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: {weight value = number }
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;

                // remove trailing } and blanks
                LPWSTR pLast = pwsz + wcslen(pwsz) - 1;
                Win4Assert(*pLast == L'}');
                *(pLast--) = L'\0';

                while (pLast >= pwsz && L' ' == *pLast )
                {
                    *(pLast--) = L'\0';
                }    
            }
        }
        break;                

    case _NEARDIST:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: dist = number
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;
            }
            
            yaccDebugOut((DEB_ITRACE, "NearDist string: %ws in %s format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                
    case _NEARUNIT:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: unit = blah
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;
            }
            
            yaccDebugOut((DEB_ITRACE, "NearUnit string: %ws in %s format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break; 
    case _VECTORELEMENT:
        {              
            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            LPWSTR pTemp = pwsz + wcslen(pwsz) - 1;

            if (fLong)  // strip trailing ; 
            {
                Win4Assert(L';' == *pTemp);
                *pTemp--='\0';
            }

            while (L' ' == *pTemp && pTemp > pwsz)
                *pTemp-- = L'\0';

            if (fQuote)
            {
                // Strip quotes
                pwsz = pwsz + 1;
                pwsz[wcslen(pwsz)-1] = L'\0';               
            }

            yaccDebugOut((DEB_ITRACE, "VectorElem %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                        
    case _VEMETHOD:
        { 
            Assert (fLong);

            LPWSTR pTemp;

            if (fLong)  // looks like: {vector rankmethod= blah}
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // strip trailing }
                pTemp = pwsz + wcslen(pwsz) - 1;               
                Win4Assert(L'}' == *pTemp);
                *pTemp-- = L'\0';

            }

            // strip leading and trailing blanks and quotes          
            while (L' ' == *pwsz)
                pwsz++;

            pTemp = pwsz + wcslen(pwsz) - 1;

            while (L' ' == *pTemp && pTemp > pwsz)
                *pTemp-- = L'\0';

            if (fQuote)
            {
                // Strip quotes
                pwsz = pwsz + 1;
                pwsz[wcslen(pwsz)-1] = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "VectorMethod %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break; 


    }

    int len = wcslen(pwsz);
    XPtrST<WCHAR> xwszRet(new WCHAR[len + 1]);
    
    _allocations.Add(xwszRet.GetPointer(), _allocations.Count());
    
    RtlCopyMemory(xwszRet.GetPointer(), pwsz, (len+1) * sizeof(WCHAR));
    (*ppStg).pwszChar = xwszRet.Acquire();
    
    return retTkn;
}        


//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::DetermineTokenType 
//
//  Synopsis:   Determines if we have a regular expression or a regular string.  
//              A  regular expression is a string that contains atleast one of
//              *, ?, or | characters.
//
//  Returns:    Token id
//
//  History:    Jun-05-98        KrishnaN  created
//
//----------------------------------------------------------------------------

short YYLEXER::DetermineTokenType()
{
    LPWSTR pwsz = yytext;
    
    LPWSTR pLast = pwsz + wcslen(pwsz) - 1;

    while (pLast >= pwsz)
    {
        if (L'|' == *pwsz || L'*' == *pwsz || L'?' == *pwsz)
            return _REGEX;
            
        pwsz++;
    }    
    
    // None of the regular expression defining characters have been found
    return _PHRASE;
}        


        //
        // 
        //    RULES       
        // 
        // Notes:  Any characters which are not matched, cause yylexer to throw.
        //         We can also throw if E_OUTOFMEMORY.
        //         Tokens which need 2 return more than 1 value (e.g. {near}
        //         use start states to return each pice of the value. The start
        //         states also emit a "token end" token so that the parser can
        //         check that they are syntactically complete.
        //         Lex matches to the longest match in the rules.  If 2 matches
        //         are the same, it matches to the 1st match. 
#define innear 1

#define shortgen 2

#define shortregex 3

#define mayberegex 4

#define implicitphrase 5

#define infreefreetext 6

#define invector 7


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
 int yywrap YY_PROTO(( void )) {return 1;}
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif


#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( YY_CHAR *, yyconst YY_CHAR *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst YY_CHAR * ));
#endif

#ifndef YY_NO_INPUT
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE (8192 / sizeof(WCHAR))
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( (result = LexerInput( (YY_CHAR *) buf, max_size )) < 0 ) \
                YY_FATAL_ERROR( L"input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int YYLEXER::yylex(YYSTYPE *yylval)
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp, *yy_bp;
        register int yy_act;




        if ( yy_init )
                {
                yy_init = 0;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yy_start )
                        yy_start = 1;   /* first start state */

                if ( ! yy_current_buffer )
                        yy_current_buffer =
                                yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

                yy_load_buffer_state();

                if (yyprimetoken)
                        {
                        int yysavetoken = yyprimetoken;
                        yyprimetoken = 0;
                        return yysavetoken;
                        } 
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
		yy_more_len = 0;
		if ( yy_more_flag )
			{
			yy_more_len = (int) (yy_c_buf_p - yytext_ptr);
			yy_more_flag = 0;
			}
                yy_cp = yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = 1; if (256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 804 )
					yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 803 );
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

                YY_DO_BEFORE_ACTION;


do_action:      /* This label is used only to access EOF actions. */


                switch ( yy_act )
        { /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
{ /* do nothing */ }
	YY_BREAK
case 2:
YY_RULE_SETUP
{    fContinueImplicitPhrase = FALSE;
                        fContinueRegex = FALSE;
                        fContinueMaybeRegex = FALSE;
                        TOKEN (_OPEN);
                   }
	YY_BREAK
case 3:
YY_RULE_SETUP
{
                        fContinueImplicitPhrase = FALSE;
                        fContinueRegex = FALSE;
                        fContinueMaybeRegex = FALSE;
                        TOKEN (_CLOSE); 
                   }
	YY_BREAK
// ************
      // PROPNAME
      // ************
 // If something was treated as a phrase in Tripolish 1, it should
       // be treated as such even now. That applies here. For e.g. @propname
       // caused the following text to be treated as a phrase. The same should
       // apply to {prop name = propname}
       // 

// shorthand, quoted
case 4:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 5:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }
	YY_BREAK
// shorthand, quoted
case 6:
YY_RULE_SETUP
{ 
                                            // treat value as freetext
                                            BEGIN infreefreetext;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 7:
YY_RULE_SETUP
{ 
                                            // treat value as freetext
                                            BEGIN infreefreetext;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }    
	YY_BREAK
// longhand, quoted
case 8:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, TRUE, TRUE);
                                        }
	YY_BREAK
// longhand, not quoted
case 9:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, TRUE, FALSE);
                                        }
	YY_BREAK
// closing token
case 10:
YY_RULE_SETUP
{ TOKEN (_PROPEND); }
	YY_BREAK
// *********
     // OPERATORS
     // *********
case 11:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_CONTAINS); 
                 }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);
                 }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);
                 }		 
	YY_BREAK
case 14:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueImplicitPhrase\n" )); 
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueRegex\n" ));  
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueMaybeRegex\n" ));  
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
		   yaccDebugOut(( DEB_ITRACE, "OR TOKEN found !!!\n" ));
                   TOKEN (_OR); }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueImplicitPhrase\n" )); 
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueRegex\n" ));  
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueMaybeRegex\n" ));  
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
		   yaccDebugOut(( DEB_ITRACE, "OR{ TOKEN found !!!\n" ));
                   TOKEN (_OR); }     	   
	YY_BREAK
case 16:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}
	YY_BREAK
case 17:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
		   {
		       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}		   
	YY_BREAK
case 18:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);}
	YY_BREAK
case 19:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_OR);}
	YY_BREAK
case 20:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}
	YY_BREAK
case 21:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "near[ ]+ _NEAR token, begin implicitphrase\n" ));
		   BEGIN implicitphrase;
                   TOKEN (_NEAR);}
	YY_BREAK
case 22:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "near{ _NEAR token, begin implicitphrase\n" ));
		   yyless(yyleng-1);
		   BEGIN implicitphrase;
                   TOKEN (_NEAR);}			   
	YY_BREAK
case 23:
YY_RULE_SETUP
{ BEGIN implicitphrase;
                   TOKEN (_NEAR);}
	YY_BREAK
case 24:
YY_RULE_SETUP
{ TOKEN (_LT);}
	YY_BREAK
case 25:
YY_RULE_SETUP
{ TOKEN (_GT);}
	YY_BREAK
case 26:
YY_RULE_SETUP
{ TOKEN (_LTE);}
	YY_BREAK
case 27:
YY_RULE_SETUP
{ TOKEN (_GTE);}
	YY_BREAK
case 28:
YY_RULE_SETUP
{ if (fContinueMaybeRegex) 
                      {
                          // We are not sure if we are going to find a
                          // regular expression or a phrase.
                          
                          BEGIN mayberegex;
                          fContinueMaybeRegex = FALSE;
                      }
                      TOKEN (_EQ);
                    }
	YY_BREAK
case 29:
YY_RULE_SETUP
{ TOKEN (_NE); }
	YY_BREAK
case 30:
YY_RULE_SETUP
{ TOKEN (_ALLOF); }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ TOKEN (_SOMEOF); }
	YY_BREAK
case 32:
case 33:
YY_RULE_SETUP
{ TOKEN (_LTSOME); }
	YY_BREAK
case 34:
case 35:
YY_RULE_SETUP
{ TOKEN (_GTSOME); }
	YY_BREAK
case 36:
case 37:
YY_RULE_SETUP
{ TOKEN (_LTESOME); }
	YY_BREAK
case 38:
case 39:
YY_RULE_SETUP
{ TOKEN (_GTESOME); }
	YY_BREAK
case 40:
case 41:
YY_RULE_SETUP
{ TOKEN (_EQSOME); }
	YY_BREAK
case 42:
case 43:
YY_RULE_SETUP
{ TOKEN (_NESOME); }
	YY_BREAK
case 44:
YY_RULE_SETUP
{ TOKEN (_ALLOFSOME); }
	YY_BREAK
case 45:
YY_RULE_SETUP
{ TOKEN (_SOMEOFSOME); }
	YY_BREAK
case 46:
case 47:
YY_RULE_SETUP
{ TOKEN (_LTALL); }
	YY_BREAK
case 48:
case 49:
YY_RULE_SETUP
{ TOKEN (_GTALL); }
	YY_BREAK
case 50:
case 51:
YY_RULE_SETUP
{ TOKEN (_LTEALL); }
	YY_BREAK
case 52:
case 53:
YY_RULE_SETUP
{ TOKEN (_GTEALL); }
	YY_BREAK
case 54:
case 55:
YY_RULE_SETUP
{ TOKEN (_EQALL); }
	YY_BREAK
case 56:
case 57:
YY_RULE_SETUP
{ TOKEN (_NEALL); }
	YY_BREAK
case 58:
YY_RULE_SETUP
{ TOKEN (_ALLOFALL); }
	YY_BREAK
case 59:
YY_RULE_SETUP
{ TOKEN (_SOMEOFALL); }
	YY_BREAK
// *************
     // VECTOR SPACE TOKENS
     // *************
case 60:
YY_RULE_SETUP
{ STRING_VALUE(_VEMETHOD, TRUE, TRUE); }
	YY_BREAK
case 61:
YY_RULE_SETUP
{ STRING_VALUE(_VEMETHOD, TRUE, FALSE); }
	YY_BREAK
case 62:
YY_RULE_SETUP
{
                                                    // makes more sense to enter phrase mode
                                                    // rather than freetext mode.
                                                    fContinueImplicitPhrase = TRUE;
                                                    BEGIN implicitphrase;
                                                    TOKEN (_VE);
                                                }
	YY_BREAK
case 63:
YY_RULE_SETUP
{ TOKEN (_VECTOR_END); }
	YY_BREAK
// *************
      // longhand NEAR
      // *************
// must return both unit and distance, so use start state to pull them out, and 
      // return _NEAR_END so parser knows we hit the closing }  

case 64:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "Longhand _NEAR token, begin innear\n" ));
		  BEGIN innear; }
	YY_BREAK
case 65:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "Longhand _NEAR{ token, begin innear\n" ));
		  yyless(yyleng-1);
		  BEGIN innear; }
	YY_BREAK
// ************
     // WEIGHT
     // ************
case 66:
YY_RULE_SETUP
{ 
							  if (fContinueImplicitPhrase)
							  {
							      BEGIN implicitphrase;
							      fContinueImplicitPhrase = FALSE;
							  }
						
							  yaccDebugOut(( DEB_ITRACE, "_WEIGHT TOKEN FOUND!!\n" ));
							  STRING_VALUE(_WEIGHT,TRUE,FALSE);
						      }
	YY_BREAK
case 67:
YY_RULE_SETUP
{
                        if (fContinueImplicitPhrase)
                        {
                            BEGIN implicitphrase;
                            fContinueImplicitPhrase = FALSE;
                        }
                        TOKEN (_COERCE); }
	YY_BREAK
// ****************
     // longhand GENERATE
     // ****************
case 68:
YY_RULE_SETUP
{
                                                    if (fContinueImplicitPhrase)
                                                    {
                                                        BEGIN implicitphrase;
                                                        fContinueImplicitPhrase = FALSE;
                                                    }
                                                    yaccDebugOut((DEB_ITRACE, "Prefix recognized.\n"));
                                                    TOKEN(_GENPREFIX);
                                                }
	YY_BREAK
case 69:
YY_RULE_SETUP
{
                                                    if (fContinueImplicitPhrase)
                                                    {
                                                        BEGIN implicitphrase;
                                                        fContinueImplicitPhrase = FALSE;
                                                    }
                                                    yaccDebugOut((DEB_ITRACE, "Inflect recognized.\n"));
                                                    TOKEN(_GENINFLECT);
                                                }
	YY_BREAK
case 70:
YY_RULE_SETUP
{ TOKEN (_GENNORMAL); }
	YY_BREAK
// ****************
      // longhand REGEX
      // ****************
case 71:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,TRUE);}
	YY_BREAK
case 72:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,FALSE);}
	YY_BREAK
case 73:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,FALSE);}
	YY_BREAK
// ****************
      // shorthand REGEX
      // ****************
// shorthand, quoted
case 74:
YY_RULE_SETUP
{ 
                                            // Get into short form of reg expression
                                            BEGIN shortregex;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 75:
YY_RULE_SETUP
{
                                            // Get into short form of reg expression
                                            BEGIN shortregex;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }    
	YY_BREAK
// ***************
      // longhand PHRASE                                            
      // ***************
// quoted, with trailing * or **
case 76:
YY_RULE_SETUP
{
                                                // trailing * has to be for inflection - 
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen; 
                                                STRING_VALUE(_PHRASE,TRUE,TRUE); 
                                            }
	YY_BREAK
// quoted, without trailing * or **
case 77:
YY_RULE_SETUP
{   
                                                // no trailing * -- phrase only
                                                STRING_VALUE(_PHRASE,TRUE,TRUE);
                                            }
	YY_BREAK
// unquoted, with trailing * or **
case 78:
YY_RULE_SETUP
{  
                                                // trailing * has to be for inflection - 
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen; 
                                                STRING_VALUE(_PHRASE,TRUE,FALSE); 
                                            }
	YY_BREAK
// unquoted, without trailing * or **
case 79:
YY_RULE_SETUP
{   
                                                // no trailing * -- phrase only
                                                STRING_VALUE(_PHRASE,TRUE,FALSE); 
                                            }
	YY_BREAK
// *************                                        
      // shorthand PHRASE                                            
      // *************
// with trailing * or **
case 80:
YY_RULE_SETUP
{
                                                // trailing * has to be for inflection -        
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen;
                                                STRING_VALUE(_PHRASE, FALSE, TRUE); 
                                            } 
	YY_BREAK
 // without trailing * or **
case 81:
YY_RULE_SETUP
{
                                                // no trailing * -- phrase only 
                                                STRING_VALUE(_PHRASE, FALSE, TRUE); 
                                            }
	YY_BREAK
// *****************
    // longhand FREETEXT
    // *****************
// quoted, with trailing * or **
case 82:
YY_RULE_SETUP
{
                                                    // trailing * has to be for inflection - 
                                                    // process it in shortgen on next pass.  
                                                    // Grab freetext now.
                                                    yyless(yyleng-1); 
                                                    BEGIN shortgen;
                                                    STRING_VALUE(_FREETEXT,TRUE,TRUE); 
                                                }
	YY_BREAK
// quoted, without trailing * or **
case 83:
YY_RULE_SETUP
{
                                                    // no trailing * -- freetext  only
                                                    STRING_VALUE(_FREETEXT,TRUE,TRUE); 
                                                }
	YY_BREAK
// unquoted, with trailing * or **
case 84:
YY_RULE_SETUP
{
                                                    // trailing * has to be for inflection - 
                                                    // process it in shortgen on next pass.  
                                                    // Grab freetext now.
                                                    yyless(yyleng-1); 
                                                    BEGIN shortgen;
                                                    STRING_VALUE(_FREETEXT,TRUE,FALSE); 
                                                }
	YY_BREAK
// unquoted, without trailing * or **
case 85:
YY_RULE_SETUP
{
                                                    // no trailing * -- freetext  only
                                                    STRING_VALUE(_FREETEXT,TRUE,FALSE); 
                                                }
	YY_BREAK
// ******************
      // shorthand FREETEXT 
      // ******************
case 86:
YY_RULE_SETUP
{
                                            // For backward compatibility, we want to special
                                            // case and recognize the "not" operator when it
                                            // is immediately followed by a mode specifier character
                                            // (@, $, #). For e.g. "not@size > 2" should be treated
                                            // as if we have a "not" operator followed by "@size > 2".
                                            // Without this special case, "not@size > 2" gets recognized
                                            // as free text.
                                            
                                            if (IsNotOperator())
                                            {
                                                yyless(3);
                                                BEGIN INITIAL;
                                                TOKEN(_NOT);
                                            }
                                            
                                            yaccDebugOut(( DEB_ITRACE, "fTreatFreetextAsPhrase is %d\n", fTreatFreetextAsPhrase ));
                                            if (fTreatFreetextAsPhrase)
                                                BEGIN implicitphrase;
                                            else
                                                BEGIN infreefreetext;
                                        
                                            fTreatFreetextAsPhrase = FALSE;    
                                            yymore();
                                        }  
	YY_BREAK
case 87:
YY_RULE_SETUP
{
                                            // IsNotOperator is used here for the same reason as the
                                            // use above, except that this rule covers situations where
                                            // we have no spaces in the query. E.g. "not@size>2". 
                                            // This should be equivalent to 
                                            // "not@size > 2", which in turn should be equivalent to
                                            // "not @size > 2"
                                            
                                            if (IsNotOperator())
                                            {
                                                yyless(3);
                                                BEGIN INITIAL;
                                                TOKEN(_NOT);
                                            }
                                            
                                            if (fTreatFreetextAsPhrase)
                                            {
                                                STRING_VALUE(_PHRASE,FALSE,FALSE);
                                            }
                                            else
                                            {
                                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                                            }
                                            
                                            fTreatFreetextAsPhrase = FALSE;
                                        }  
	YY_BREAK
// *************
      // VECTOR VALUES
      // *************
// quoted multi-value vector - has ; separator.  Singlets caught in parser
case 88:
YY_RULE_SETUP
{ BEGIN invector; yyless(1);}
	YY_BREAK
// unquoted multi-value vector - has ; separator.  Singlets caught in parser
case 89:
YY_RULE_SETUP
{ BEGIN invector; yyless(1);}
	YY_BREAK
// 
    // INNEAR: longhand NEAR processing
    // 

case 90:
YY_RULE_SETUP
{}
	YY_BREAK
case 91:
YY_RULE_SETUP
{}
	YY_BREAK
case 92:
YY_RULE_SETUP
{ STRING_VALUE(_NEARDIST,TRUE,FALSE);}
	YY_BREAK
case 93:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}  
	YY_BREAK
case 94:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);} 
	YY_BREAK
case 95:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}
	YY_BREAK
case 96:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}
	YY_BREAK
case 97:
YY_RULE_SETUP
{ BEGIN implicitphrase; TOKEN (_NEAR_END);} 
	YY_BREAK
// 
      // INVECTOR: multi value vector processing
      // 

case 98:
YY_RULE_SETUP
{}
	YY_BREAK
case 99:
YY_RULE_SETUP
{}
	YY_BREAK
case 100:
YY_RULE_SETUP
{ STRING_VALUE(_VECTORELEMENT, FALSE, TRUE);}
	YY_BREAK
case 101:
YY_RULE_SETUP
{ STRING_VALUE(_VECTORELEMENT, TRUE, FALSE);}
	YY_BREAK
case 102:
YY_RULE_SETUP
{
                                //  Need to emit _VECTORELEMENT and _VE_END -- so backup 1
                                //  so we can emit _VE_END on next pass                               
                                yyless(yyleng-1);
                                STRING_VALUE(_VECTORELEMENT, FALSE, FALSE);
                            }
	YY_BREAK
case 103:
YY_RULE_SETUP
{ BEGIN INITIAL; TOKEN (_VE_END); } 
	YY_BREAK
// 
      // INFREEFREETEXT: shorthand FREETEXT processing
      //
      // NOTE:  and, or, near need to be localized
case 104:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 105:
YY_RULE_SETUP
{
                                yyless(yyleng-4); 
                                BEGIN INITIAL;                        
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  
	YY_BREAK
case 106:
YY_RULE_SETUP
{
                                yyless(yyleng-4); 
                                BEGIN INITIAL;                        
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  			    
	YY_BREAK
case 107:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }
	YY_BREAK
case 108:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 109:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{near}[ ]\n" ));
                                yyless(yyleng-5); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 110:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{near}{\n" ));
                                yyless(yyleng-5); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 111:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{{near}\n" ));
                                yyless(yyleng-6); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 112:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{{near}{\n" ));
                                yyless(yyleng-6); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 113:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  
	YY_BREAK
case 114:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }
	YY_BREAK
case 115:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 116:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 117:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 118:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                            }
	YY_BREAK
case 119:
YY_RULE_SETUP
{ 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                            }
	YY_BREAK
case 120:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 121:
YY_RULE_SETUP
{
				      BEGIN INITIAL;
				      STRING_VALUE(_FREETEXT,FALSE,FALSE); 
				  }   
	YY_BREAK
// 
      // SHORTGEN:  * or ** processing
      //
      // can only get here by backing up over *, 
      // so we will always find a match
case 122:
YY_RULE_SETUP
{  
                   BEGIN INITIAL; 
                   TOKEN(_SHGENINFLECT);
                }
	YY_BREAK
case 123:
YY_RULE_SETUP
{   
                   BEGIN INITIAL; 
                   TOKEN(_SHGENPREFIX); 
                }
	YY_BREAK
//
      // SHORTREGEX: #propname processing
      //
      // can only get here when #"propname" or #propname
      // (quoted or unquoted) version is detected.
      // NOTE:  and, or need to be localized
      // NOTE:  It doesn't make sense to have the near operator following 
      //        a regular expression. A regex is Boolean and doesn't evaluate
      //        to a position value. 
      //
      //
      

case 124:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 125:
YY_RULE_SETUP
{
                          // ignore equal operators...
                          BEGIN shortregex;
                        }
	YY_BREAK
case 126:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX, FALSE, TRUE);}
	YY_BREAK
case 127:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            yyless(yyleng-4); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 128:
YY_RULE_SETUP
{ 
                            fContinueRegex = TRUE;
                            yyless(yyleng-3); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 129:
YY_RULE_SETUP
{ 
                                yyless(yyleng-4); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a regex. Back off and let the lexer takes its
                                // normal course.
                                fContinueRegex = TRUE;
                                BEGIN INITIAL;
                        }                           
	YY_BREAK
case 130:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;                        
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 131:
YY_RULE_SETUP
{ 
                            fContinueRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 132:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a phrase. Back off and let the lexer takes its
                            // normal course.
                            fContinueRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK

    // When we find an operator we should treat it as one. 
    // So backup and get out if you see one.
    // Normally '^' is treated as part of an operator (e.g. ^a), but it also 
    // has a special meaning in regular expression syntax. So we will have to
    // let it through when it is part of a regular expression. As an alternative,
    // we can allow '^' in regular expression in a limited manner (i.e. only the use
    // in square brackets to exclude the set of chars "[^abc]" where abc are excluded).
    // This alternative will let the common case use of '^' in a regular expression
    // while allowing it to be treated as part of an operator when it doesn't 
    // occur immediately after a '['.
    // We are implementing the alternative here because our regex capability
    // only allows for the "[^" construct.

case 133:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1);
                            fContinueRegex = FALSE;
                            BEGIN INITIAL;
                        }
	YY_BREAK
case 134:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 135:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 136:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                     
	YY_BREAK
case 137:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 138:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 139:
YY_RULE_SETUP
{
                            yyless(yyleng-4); 
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 140:
YY_RULE_SETUP
{ 
                            yyless(yyleng-3); 
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 141:
YY_RULE_SETUP
{ 
                            yyless(yyleng-4); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a regex. Back off and let the lexer takes its
                            // normal course.
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK
case 142:
YY_RULE_SETUP
{
                            fContinueMaybeRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;                        
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 143:
YY_RULE_SETUP
{ 
                            fContinueMaybeRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 144:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a phrase. Back off and let the lexer takes its
                            // normal course.
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK
case 145:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 146:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 147:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 148:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 149:
YY_RULE_SETUP
{ STRING_VALUE(_PHRASE, FALSE, TRUE);}
	YY_BREAK
case 150:
YY_RULE_SETUP
{   yymore(); }
	YY_BREAK
case 151:
YY_RULE_SETUP
{
                                 fContinueMaybeRegex = TRUE;
                                 BEGIN INITIAL;
                                 STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                            }
	YY_BREAK

    // When we find an operator at the start of a phrase, 
    // we should treat it as one. So backup and get out if you see one.

case 152:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueMaybeRegex = FALSE;
                                BEGIN INITIAL;
                            }
	YY_BREAK
//
      // IMPLICITPHRASE: Where phrase is implied.
      //
      // can only get here when @propname or {prop name = propname} is detected.
      // NOTE:  and, or, not need to be localized when time permits.
      //
      // NTRAID#DB-NTBUG9-84571-2000/07/31-dlee Indexing Service tripolish2 query expressions misinterpreted as strings
      // if expression has trailing blanks, we'll emit a string value

case 153:
YY_RULE_SETUP
{   
				fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE, FALSE, TRUE);
                            }    
	YY_BREAK
case 154:
YY_RULE_SETUP
{   yymore(); }
	YY_BREAK
case 155:
YY_RULE_SETUP
{
				yyless(yyleng-4);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 156:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 157:
YY_RULE_SETUP
{ 
                                yyless(yyleng-5); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 158:
YY_RULE_SETUP
{ 
                                yyless(yyleng-5); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 159:
YY_RULE_SETUP
{ 
                                yyless(yyleng-4); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a phrase. Back off and let the lexer takes its
                                // normal course.
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                            }                           
	YY_BREAK
case 160:
YY_RULE_SETUP
{
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 161:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;                        
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 162:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a phrase. Back off and let the lexer takes its
                                // normal course.
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                            }                           
	YY_BREAK
case 163:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 164:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 165:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 166:
YY_RULE_SETUP
{
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = TRUE; 
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 167:
YY_RULE_SETUP
{
                                yyless(yyleng-9);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE);
                              }                           
	YY_BREAK

    // When we find an operator at the start of an implicit phrase, 
    // we should treat it as one. So backup and get out if you see one.

case 168:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                            }
	YY_BREAK

    // Triplish2 uses = to indicate that whatever appears after it may 
    // be using wildcards. Implement that here.

case 169:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueMaybeRegex = TRUE;
                                BEGIN INITIAL;
                            }                            
	YY_BREAK
case 170:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 171:
YY_RULE_SETUP
{
					    fContinueImplicitPhrase = TRUE;
                                            BEGIN INITIAL;
                                            STRING_VALUE(_PHRASE,FALSE,FALSE); 
                                         }   
	YY_BREAK
case 172:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(innear):
case YY_STATE_EOF(shortgen):
case YY_STATE_EOF(shortregex):
case YY_STATE_EOF(mayberegex):
case YY_STATE_EOF(implicitphrase):
case YY_STATE_EOF(infreefreetext):
case YY_STATE_EOF(invector):
	yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB YY_CHAR. */
                int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between yy_current_buffer and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yy_n_chars = yy_current_buffer->yy_n_chars;
                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer() )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yy_did_buffer_switch_on_eof = 0;

                                if ( yywrap() )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yy_c_buf_p =
                                        yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yy_c_buf_p =
                                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        L"fatal flex scanner internal error--no action found" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of yylex */

YYLEXER::YYLEXER()
        {
        yy_c_buf_p = 0;
        yy_init = 1;
        yy_start = 0;
        yyprimetoken = 0;
        yy_flex_debug = 0;
        yylineno = 1;   // this will only get updated if %option yylineno

        yy_did_buffer_switch_on_eof = 0;

        yy_looking_for_trail_begin = 0;
        yy_more_flag = 0;
        yy_more_len = 0;
        yy_more_offset = yy_prev_more_offset = 0;

        yy_start_stack_ptr = yy_start_stack_depth = 0;
        yy_start_stack = 0;

        yy_current_buffer = 0;

#ifdef YY_USES_REJECT
        yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
        yy_state_buf = 0;
#endif

        pszInputBuffer = pCurBuffer = (YY_CHAR *)NULL;
        cInputBuffer = 0;
        
        // Initialize these flags for this lexical session. They will be
        // set/reset within the lexer to control flow.
        fContinueImplicitPhrase = FALSE;
        fContinueMaybeRegex = FALSE;
        fContinueRegex = FALSE;
        fTreatFreetextAsPhrase = FALSE;
#ifdef DEBUG
        tkndebug = getenv("TKNDEBUG") ? 1 : 0;
#endif
        }


YYLEXER::~YYLEXER()
        {
        delete yy_state_buf;
        yy_delete_buffer( yy_current_buffer );
        yy_flex_free(pszInputBuffer);
        }

#ifdef YY_INTERACTIVE
int YYLEXER::LexerInput( YY_CHAR* buf, int /* max_size */ )
#else
int YYLEXER::LexerInput( YY_CHAR* buf, int max_size )
#endif
        {
        return 0;
        }

void YYLEXER::LexerOutput( const YY_CHAR* buf, int size )
        {
        // everthing should match
        THROW( CException( QPARSE_E_INVALID_QUERY  ) );
        return;
        }


#ifdef DEBUG
void YYLEXER::LexerTrace(const YY_CHAR* buf, int size, int tknNum)
        {
        if (tkndebug > 0)
                {
                cout << ">> Lexing Token : ";
                for (int i=0; i<size; i++)
                        cout << char(buf[i]);
                cout << " (" << tknNum << ")"<< endl;
                }
        }
#endif


void YYLEXER::ResetLexer()
        {
        yy_init = 1;
        yy_start = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNTRACE") ? 1 : 0;
#endif
        }

int YYLEXER::yybufferinput(YY_CHAR *pszBuffer, int cMax)
        {
        int n = min(cMax, cInputBuffer - (int) (pCurBuffer - pszInputBuffer));

        if (n > 0)
                {
                memcpy(pszBuffer, pCurBuffer, n * sizeof(WCHAR));
                pCurBuffer += n;
                }
        return n;
        }

void YYLEXER::yyprimebuffer(const YY_CHAR *pszBuffer)
        {
//      if (NULL != pszInputBuffer)
//              CoTaskMemFree(pszInputBuffer);

        Win4Assert(0 == pszInputBuffer);
        
        cInputBuffer = wcslen(pszBuffer) + 1;
        pszInputBuffer = pCurBuffer = new WCHAR[cInputBuffer];
        RtlCopyMemory(pszInputBuffer, pszBuffer, cInputBuffer*sizeof(WCHAR));

        cInputBuffer--; // get the real length

        ResetLexer();
        }

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */

int YYLEXER::yy_get_next_buffer()
        {
        register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
        register YY_CHAR *source = yytext_ptr;
        register int number_to_move, i;
        int ret_val;

        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
                YY_FATAL_ERROR(
                L"fatal flex scanner internal error--end of buffer missed" );

        if ( yy_current_buffer->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                yy_current_buffer->yy_n_chars = yy_n_chars = 0;

        else
                {
                int num_to_read =
                        yy_current_buffer->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
                        YY_FATAL_ERROR(
L"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = yy_current_buffer;

                        int yy_c_buf_p_offset =
                                (int) (yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (YY_CHAR *)
                                        /* Include room in for 2 EOB chars. */
                                        yy_flex_realloc( (void *) b->yy_ch_buf,
                                                         b->yy_buf_size,
                                                         b->yy_buf_size + 2 );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;
                        
                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = yy_current_buffer->yy_buf_size -
                                                number_to_move - 1;
#endif
                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                        yy_n_chars, num_to_read );

                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        if ( yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        yy_current_buffer->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        yy_n_chars += number_to_move;
        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

        return ret_val;
        }


/* yy_get_previous_state - get the state just before the EOB YY_CHAR was reached */

yy_state_type YYLEXER::yy_get_previous_state()
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp;

	yy_current_state = yy_start;

        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
                {
		register YY_CHAR yy_c = 1; if (0!= *yy_cp && 256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 804 )
				yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
        }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YYLEXER::yy_try_NUL_trans( yy_state_type yy_current_state )
        {
        register int yy_is_jam;
	register YY_CHAR *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 804 )
			yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 803);

        return yy_is_jam ? 0 : yy_current_state;
        }


void YYLEXER::yyunput( int c, register YY_CHAR* yy_bp )
        {
        register YY_CHAR *yy_cp = yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yy_hold_char;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                register int number_to_move = yy_n_chars + 2;
                register YY_CHAR *dest = &yy_current_buffer->yy_ch_buf[
                                        yy_current_buffer->yy_buf_size + 2];
                register YY_CHAR *source =
                                &yy_current_buffer->yy_ch_buf[number_to_move];

                while ( source > yy_current_buffer->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                yy_current_buffer->yy_n_chars =
                        yy_n_chars = yy_current_buffer->yy_buf_size;

                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                        YY_FATAL_ERROR( L"flex scanner push-back overflow" );
                }

        *--yy_cp = (YY_CHAR) c;


        yytext_ptr = yy_bp;
        yy_hold_char = *yy_cp;
        yy_c_buf_p = yy_cp;
        }


int YYLEXER::yyinput()
        {
        int c;

        *yy_c_buf_p = yy_hold_char;

        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        /* This was really a NUL. */
                        *yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = (int)(yy_c_buf_p - yytext_ptr);
                        ++yy_c_buf_p;

                        switch ( yy_get_next_buffer() )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( );

                                        /* fall through */

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yywrap() )
                                                return EOF;

                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yy_c_buf_p = yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(YY_CHAR *) yy_c_buf_p;    /* cast for 8-bit YY_CHAR's */
        *yy_c_buf_p = '\0';     /* preserve yytext */
        yy_hold_char = *++yy_c_buf_p;


        return c;
        }


void YYLEXER::yyrestart( )
        {
        if ( ! yy_current_buffer )
                yy_current_buffer = yy_create_buffer( (cInputBuffer * sizeof (YY_CHAR)) + sizeof (YY_CHAR) );

        yy_init_buffer( yy_current_buffer );
        yy_load_buffer_state();
        }


void YYLEXER::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        {
        if ( yy_current_buffer == new_buffer )
                return;

        if ( yy_current_buffer )
                {
                /* Flush out information for old buffer. */
                *yy_c_buf_p = yy_hold_char;
                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        yy_current_buffer = new_buffer;
        yy_load_buffer_state();

        /* We don't actually know whether we did this switch during
         * EOF (yywrap()) processing, but the only time this flag
         * is looked at is after yywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yy_did_buffer_switch_on_eof = 1;
        }


void YYLEXER::yy_load_buffer_state()
        {
        yy_n_chars = yy_current_buffer->yy_n_chars;
        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        yy_hold_char = *yy_c_buf_p;
        }


YY_BUFFER_STATE YYLEXER::yy_create_buffer( int size )
        {
        YY_BUFFER_STATE b;
        
        XPtrST<BYTE> xBuf((BYTE *)yy_flex_alloc( sizeof( struct yy_buffer_state ) ));

        ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_buf_size = size;
        
        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_ch_buf = 
                (YY_CHAR *) yy_flex_alloc( ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_buf_size + 2 );
                
        // if the second alloc succeeds, we acquire into b. Else, xBuf will be automatically
        // freed.
        
        b = (YY_BUFFER_STATE) xBuf.Acquire();

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b );

        return b;
        }


void YYLEXER::yy_delete_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        if ( b == yy_current_buffer )
                yy_current_buffer = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yy_flex_free( (void *) b->yy_ch_buf );

        yy_flex_free( (void *) b );
        }


 /* extern "C" int isatty YY_PROTO(( int )); */
void YYLEXER::yy_init_buffer( YY_BUFFER_STATE b )

        {
        yy_flush_buffer( b );

        b->yy_fill_buffer = 1;

        b->yy_is_interactive = 0;
        }


void YYLEXER::yy_flush_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == yy_current_buffer )
                yy_load_buffer_state();
        }


#ifndef YY_NO_SCAN_BUFFER
#endif


#ifndef YY_NO_SCAN_STRING
#endif


#ifndef YY_NO_SCAN_BYTES
#endif


#ifndef YY_NO_PUSH_STATE
void YYLEXER::yy_push_state( int new_state )
        {
        if ( yy_start_stack_ptr >= yy_start_stack_depth )
                {
                yy_size_t new_size, old_size;
                
                old_size = yy_start_stack_depth * sizeof( int );
                yy_start_stack_depth += YY_START_STACK_INCR;
                new_size = yy_start_stack_depth * sizeof( int );

                if ( ! yy_start_stack )
                        yy_start_stack = (int *) yy_flex_alloc( new_size );

                else
                        yy_start_stack = (int *) yy_flex_realloc(
                                        (void *) yy_start_stack, old_size, new_size );

                }

        yy_start_stack[yy_start_stack_ptr++] = YY_START;

        BEGIN(new_state);
        }
#endif


#ifndef YY_NO_POP_STATE
void YYLEXER::yy_pop_state()
        {
        if ( --yy_start_stack_ptr < 0 )
                YY_FATAL_ERROR( L"start-condition stack underflow" );

        BEGIN(yy_start_stack[yy_start_stack_ptr]);
        }
#endif


#ifndef YY_NO_TOP_STATE
int YYLEXER::yy_top_state()
        {
        return yy_start_stack[yy_start_stack_ptr - 1];
        }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif


void YYLEXER::LexerError( yyconst YY_CHAR msg[] )
        {
        yaccDebugOut(( DEB_WARN, "%s\n", msg ));
        THROW( CException( E_UNEXPECTED  ) );
        }


/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( YY_CHAR *s1, yyconst YY_CHAR *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
YY_CHAR *s1;
yyconst YY_CHAR *s2;
int n;
#endif
        {
        register int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
        }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst YY_CHAR *s )
#else
static int yy_flex_strlen( s )
yyconst YY_CHAR *s;
#endif
        {
        register int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
        }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
        {
            void *p = (void *)new BYTE[size];
            
            return p;
        }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t old_size, yy_size_t new_size )
#else
static void *yy_flex_realloc( ptr, old_size, new_size )
void *ptr;
yy_size_t size;
#endif
        {
         
        /* The cast to (YY_CHAR *) in the following accommodates both
         * implementations that use YY_CHAR* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
            void *p = (void *) new BYTE[new_size];
            
            RtlCopyMemory(p, ptr, min(old_size, new_size));
            
            yy_flex_free(ptr);
            
            return p;
        }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
        {
        delete[] (BYTE *)ptr;
        }


#if YY_MAIN
int main()
        {
        yylex();
        return 0;
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\parsepl.h ===
#ifndef _STUFF_H_INC
#define _STUFF_H_INC

//package is in use
#define YYAPI_PACKAGE               1 						// package is in use
#define YYAPI_TOKENNAME             yychar                 	
#define YYAPI_TOKENTYPE             int                     
#define YYAPI_TOKENNONE             -2                       
#define YYAPI_VALUENAME             yylval   
#define YYAPI_VALUETYPE             YYSTYPE 
#define YYLEX       					   _yylex.yylex
#define YYPARSEPROTO  
#undef  YYPARSER
#define YYPARSER						   TripParser
#undef  YYLEXER
#define YYLEXER							TripLexer
#undef  YY_CHAR	
#define YY_CHAR							WCHAR


#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif


#endif /* _STUFF_H_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\parser.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define _OR 257
#define _AND 258
#define _NEAR 259
#define _NEARDIST 260
#define _NOT 261
#define _CONTAINS 262
#define _LT 263
#define _GT 264
#define _LTE 265
#define _GTE 266
#define _EQ 267
#define _NE 268
#define _ALLOF 269
#define _SOMEOF 270
#define _OPEN 271
#define _CLOSE 272
#define _VECTOR_END 273
#define _VE 274
#define _VE_END 275
#define _PROPEND 276
#define _NEAR_END 277
#define _LTSOME 278
#define _GTSOME 279
#define _LTESOME 280
#define _GTESOME 281
#define _EQSOME 282
#define _NESOME 283
#define _ALLOFSOME 284
#define _SOMEOFSOME 285
#define _LTALL 286
#define _GTALL 287
#define _LTEALL 288
#define _GTEALL 289
#define _EQALL 290
#define _NEALL 291
#define _ALLOFALL 292
#define _SOMEOFALL 293
#define _COERCE 294
#define _SHGENPREFIX 295
#define _SHGENINFLECT 296
#define _GENPREFIX 297
#define _GENINFLECT 298
#define _GENNORMAL 299
#define _PHRASE 300
#define _PROPNAME 301
#define _NEARUNIT 302
#define _WEIGHT 303
#define _REGEX 304
#define _FREETEXT 305
#define _VECTORELEMENT 306
#define _VEMETHOD 307
#define _PHRASEORREGEX 308
typedef union
{
    WCHAR * pwszChar;
    DBCOMMANDOP dbop;
    CDbRestriction * pRest;
    CStorageVariant * pStorageVar;
    CValueParser  *pPropValueParser;
    int iInt;
    int iEmpty;
} YYSTYPE;
extern YYSTYPE triplval;
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define INITSTACKSIZE 30
class YYPARSER : public CTripYYBase
{
    friend class YYLEXER;
public:

    YYPARSER(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex);

    ~YYPARSER() {}

    int  Parse();

#ifdef YYAPI_VALUETYPE
    CDbRestriction* GetParseTree()          // Get result of parse
    {
        CDbRestriction* pRst = ((YYAPI_VALUETYPE)yyval).pRest;
        _setRst.Remove( pRst );
        Win4Assert( 0 == _setRst.Count() );
        Win4Assert( 0 == _setStgVar.Count() );
        Win4Assert( 0 == _setValueParser.Count() );
        return pRst;
    };
#endif

    void SetDebug() { yydebug = 1; }
    void EmptyValueStack(YYAPI_VALUETYPE yylval) {}
    void PopVs() { yyvsp--; }

private:

    int yydebug;
    int yynerrs;
    int yyerrflag;
    int yychar;
    short *yyssp;
    YYSTYPE *yyvsp;
    YYSTYPE yyval;
    YYSTYPE yylval;
    XGrowable<short, INITSTACKSIZE> xyyss;
    CDynArrayInPlace<YYSTYPE> xyyvs;
};
#define yystacksize YYSTACKSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\trparse.cxx ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#include <pch.cxx>
#pragma hdrstop
#define yyparse tripparse
#define yylex triplex
#define yyerror triperror
#define yychar tripchar
#define yyval tripval
#define yylval triplval
#define yydebug tripdebug
#define yynerrs tripnerrs
#define yyerrflag triperrflag
#define yyss tripss
#define yyssp tripssp
#define yyvs tripvs
#define yyvsp tripvsp
#define yylhs triplhs
#define yylen triplen
#define yydefred tripdefred
#define yydgoto tripdgoto
#define yysindex tripsindex
#define yyrindex triprindex
#define yygindex tripgindex
#define yytable triptable
#define yycheck tripcheck
#define yyname tripname
#define yyrule triprule
#define YYPREFIX "trip"

class CValueParser;

#if 0

typedef union
{
    WCHAR * pwszChar;
    DBCOMMANDOP dbop;
    CDbRestriction * pRest;
    CStorageVariant * pStorageVar;
    CValueParser  *pPropValueParser;
    int iInt;
    int iEmpty;
} YYSTYPE;

#endif

#define YYDEBUG CIDBG

#include <malloc.h>
#include "yybase.hxx"
#include "parser.h" // defines yystype
#include "parsepl.h"
#include "flexcpp.h"

#if CIDBG == 1
#define AssertReq(x)    Assert(x != NULL)
#else
#define AssertReq(x)
#endif

const GUID guidSystem = PSGUID_STORAGE;
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

//+---------------------------------------------------------------------------
//
//  Function:  TreeFromText, public
//
//  Synopsis:  Create a CDbRestriction from a restriction string
//
//  Arguments: [wcsRestriction] -- restriction
//             [ColumnMapper]   -- property list
//             [lcid]           -- locale id of the query
//
//  History:   01-Oct-97 emilyb    created
//             26-Aug-98 KLam      No longer need to lower case
//
//----------------------------------------------------------------------------


CDbContentRestriction * TreeFromText(
    WCHAR const *   wcsRestriction,
    IColumnMapper & ColumnMapper,
    LCID            lcid )
{
    unsigned cwc = 1 + wcslen( wcsRestriction );
    XGrowable<WCHAR> xRestriction( cwc );
    WCHAR * pwc = xRestriction.Get();
    RtlCopyMemory( pwc, wcsRestriction, cwc * sizeof WCHAR );

    cwc--;

    // The parser can't deal with trailing space so strip it off

    while ( cwc > 0 && L' ' == pwc[cwc-1] )
        cwc--;
    pwc[cwc] = 0;

    TripLexer Lexer;
    XPtr<YYPARSER> xParser( new TripParser( ColumnMapper, lcid, Lexer ) );

    xParser->yyprimebuffer( pwc );

    #if 0 // YYDEBUG == 1
        // Set this to 1 if you want command line output. to 0 otherwise.
        xParser->SetDebug();
    #endif

    // Actually parse the text producing a tree

    SCODE hr = xParser->Parse();

    if (FAILED(hr))
        THROW( CException( hr ) );

    // return the DBCOMMANDTREE
    return  (CDbContentRestriction *)( xParser->GetParseTree() );

} //TextFromTree

void StripQuotes(WCHAR *wcsPhrase)
{
    ULONG cChars = wcslen(wcsPhrase);
    LPWSTR pLast = wcsPhrase + cChars - 1;
    if (L'"' == *wcsPhrase && L'"' == *pLast)
    {
        *pLast = L'\0';
        MoveMemory(wcsPhrase, wcsPhrase+1, sizeof(WCHAR) * (cChars-1) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::CValueParser, public
//
//  Synopsis:  Allocs CStorageVariant of correct type
//
//  History:   01-Oct-97 emilyb    created
//             02-Sep-98 KLam      Added locale
//
//----------------------------------------------------------------------------

CValueParser::CValueParser(
    BOOL fVectorElement,
    DBTYPE PropType,
    LCID locale ) :
        _pStgVariant( 0 ),
        _fVector(fVectorElement),
        _PropType (PropType),
        _cElements ( 0 ),
        _locale ( locale )
{

    if ( _fVector )
    {
        // this is a vector
        if ( DBTYPE_VECTOR != ( _PropType & DBTYPE_VECTOR ) )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        VARENUM ve = (VARENUM ) _PropType;
        if ( _PropType == ( DBTYPE_VECTOR | DBTYPE_WSTR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( _PropType == ( DBTYPE_VECTOR | DBTYPE_STR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPSTR);

        _pStgVariant.Set( new CStorageVariant( ve, _cElements ) );
    }
    else
    {
        _pStgVariant.Set( new CStorageVariant() );
    }
    if ( _pStgVariant.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );
}

//+---------------------------------------------------------------------------
//
//  Member:    CValueParser::AddValue, public
//
//  Synopsis:  Adds value to CStorageVariant
//
//  Arguments: [pwszValue] -- value
//
//  History:   01-Oct-97 emilyb    code moved here from CPropertyValueParser
//
//----------------------------------------------------------------------------

void CValueParser::AddValue(WCHAR const * pwszValue)
{
    if ( _pStgVariant.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    switch ( _PropType & ~DBTYPE_VECTOR  )
    {

    case DBTYPE_WSTR :
    case DBTYPE_WSTR | DBTYPE_BYREF :
        {
            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetLPWSTR( pwszValue, _cElements );
            else
                _pStgVariant->SetLPWSTR( pwszValue );
            break;
        }
    case DBTYPE_BSTR :
        {
            BSTR bstr = SysAllocString( pwszValue );

            if ( 0 == bstr )
                THROW( CException( E_OUTOFMEMORY ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetBSTR( bstr, _cElements );
            else
                _pStgVariant->SetBSTR( bstr );

            SysFreeString( bstr );
            break;
        }
    case DBTYPE_STR :
    case DBTYPE_STR | DBTYPE_BYREF :
        {
            // make sure there's enough room to translate

            unsigned cbBuffer = 1 + 3 * wcslen( pwszValue );
            XArray<char> xBuf( cbBuffer );

            int cc = WideCharToMultiByte( CP_ACP,
                                          0,
                                          pwszValue,
                                          -1,
                                          xBuf.Get(),
                                          cbBuffer,
                                          NULL,
                                          NULL );

            if ( 0 == cc )
            {
                #if CIDBG
                ULONG ul = GetLastError();
                #endif
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
            }

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetLPSTR( xBuf.Get(), _cElements );
            else
                _pStgVariant->SetLPSTR( xBuf.Get() );
            break;
        }

    case DBTYPE_I1 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ( l > SCHAR_MAX ) ||
                 ( l < SCHAR_MIN ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI1( (CHAR) l, _cElements );
            else
                _pStgVariant->SetI1( (CHAR) l );

            break;
        }
    case DBTYPE_UI1 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ul > UCHAR_MAX )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI1( (BYTE) ul, _cElements );
            else
                _pStgVariant->SetUI1( (BYTE) ul );

            break;
        }
    case DBTYPE_I2 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ( l > SHRT_MAX ) ||
                 ( l < SHRT_MIN ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI2( (short) l, _cElements );
            else
                _pStgVariant->SetI2( (short) l );

            break;
        }
    case DBTYPE_UI2 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ul > USHRT_MAX )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI2( (USHORT) ul, _cElements );
            else
                _pStgVariant->SetUI2( (USHORT) ul );
            break;
        }
    case DBTYPE_I4 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI4( l, _cElements );
            else
                _pStgVariant->SetI4( l );
            break;
        }
    case DBTYPE_UI4 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI4( ul, _cElements );
            else
                _pStgVariant->SetUI4( ul );
            break;
        }
    case DBTYPE_ERROR :
        {
            // SCODE/HRESULT are typedefed as long (signed)

            CQueryScanner scan( pwszValue, FALSE, _locale );
            SCODE sc = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( sc, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetERROR( sc, _cElements );
            else
                _pStgVariant->SetERROR( sc );
            break;
        }
    case DBTYPE_I8 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            _int64 ll = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ll, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            LARGE_INTEGER LargeInt;
            LargeInt.QuadPart = ll;

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI8(  LargeInt , _cElements );
            else
                _pStgVariant->SetI8(  LargeInt  );

            break;
        }
    case DBTYPE_UI8 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            unsigned _int64 ull = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ull, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            ULARGE_INTEGER LargeInt;
            LargeInt.QuadPart = ull;

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI8(  LargeInt , _cElements );
            else
                _pStgVariant->SetUI8(  LargeInt  );

            break;
        }
    case DBTYPE_BOOL :
        {
            if ( pwszValue[0] == 'T' ||
                 pwszValue[0] == 't' )
                if ( _PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetBOOL( VARIANT_TRUE, _cElements );
                else
                    _pStgVariant->SetBOOL( VARIANT_TRUE );
            else
                if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetBOOL( VARIANT_FALSE, _cElements );
            else
                _pStgVariant->SetBOOL( VARIANT_FALSE );

            break;
        }
    case DBTYPE_R4 :
        {
            WCHAR *pwcEnd = 0;

            float Float = (float)( wcstod( pwszValue, &pwcEnd ) );

            if ( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetR4( Float, _cElements );
            else
                _pStgVariant->SetR4( Float );

            break;
        }
    case DBTYPE_R8 :
        {
            WCHAR *pwcEnd = 0;
            double Double = ( double )( wcstod( pwszValue, &pwcEnd ) );

            if ( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetR8( Double, _cElements );
            else
                _pStgVariant->SetR8( Double );

            break;
        }
    case DBTYPE_DECIMAL :
        {
            WCHAR *pwcEnd = 0;
            double Double = ( double )( wcstod( pwszValue, &pwcEnd ) );
     
            if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );
     
            // Vectors are not supported by OLE for VT_DECIMAL (yet)
     
            Win4Assert( 0 == ( _PropType & DBTYPE_VECTOR ) );
     
            PROPVARIANT * pPropVar = (PROPVARIANT *) _pStgVariant.GetPointer();
            VarDecFromR8( Double, &(pPropVar->decVal) );
            pPropVar->vt = VT_DECIMAL;
            break;
        }
    case DBTYPE_DATE :
        {
            FILETIME ftValue;
            ParseDateTime( pwszValue, ftValue );

            SYSTEMTIME stValue;
            BOOL fOK = FileTimeToSystemTime( &ftValue, &stValue );

            if ( !fOK )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            DATE dosDate;
            fOK = SystemTimeToVariantTime( &stValue, &dosDate );

            if ( !fOK )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetDATE( dosDate, _cElements );
            else
                _pStgVariant->SetDATE( dosDate );

            break;
        }
    case VT_FILETIME :
        {
            FILETIME ftValue;
            ParseDateTime( pwszValue, ftValue );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetFILETIME( ftValue, _cElements );
            else
                _pStgVariant->SetFILETIME( ftValue );

            break;
        }
    case DBTYPE_CY :
        {
            double dbl;

            if ( swscanf( pwszValue,
                          L"%lf",
                          &dbl ) < 1 )
                THROW( CParserException( QPARSE_E_EXPECTING_CURRENCY ) );

            CY cyCurrency;
            VarCyFromR8( dbl, &cyCurrency );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetCY( cyCurrency,  _cElements );
            else
                _pStgVariant->SetCY( cyCurrency );

            break;
        }
    case DBTYPE_GUID :
    case DBTYPE_GUID | DBTYPE_BYREF:
        {
            CLSID clsid;

            if ( swscanf( pwszValue,
                          L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                          &clsid.Data1,
                          &clsid.Data2,
                          &clsid.Data3,
                          &clsid.Data4[0], &clsid.Data4[1],
                          &clsid.Data4[2], &clsid.Data4[3],
                          &clsid.Data4[4], &clsid.Data4[5],
                          &clsid.Data4[6], &clsid.Data4[7] ) < 11 )
                THROW( CParserException( QPARSE_E_EXPECTING_GUID ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetCLSID( clsid, _cElements );
            else
                _pStgVariant->SetCLSID( &clsid );
            break;
        }
    default:
        {
            THROW( CParserException( QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ) );
        }
    } // switch

    // make sure memory allocations succeeded

    if ( !_pStgVariant->IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    if ( _fVector )
    {
        _cElements++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::ParseDateTime, private
//
//  Synopsis:   Attempts to parse a date expression.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft     -- reference to the FILETIME structure to fill in
//                        with the result
//
//  History:    31-May-96   dlee       Created
//              23-Jan-97   KyleP      Better Year 2000 support
//              02-Sep-98   KLam       Use user settings for Y2K support
//
//----------------------------------------------------------------------------

void CValueParser::ParseDateTime(
    WCHAR const *    phrase,
    FILETIME & ft )
{
    if( !CheckForRelativeDate( phrase, ft ) )
    {
        SYSTEMTIME stValue = { 0, 0, 0, 0, 0, 0, 0, 0 };

        int cItems = swscanf( phrase,
                              L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if ( 1 == cItems )
            cItems = swscanf( phrase,
                              L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if( cItems != 3 && cItems != 6 && cItems != 7)
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

        //
        // Make a sensible split for Year 2000 using the user's system settings
        //

        if ( stValue.wYear < 100 )
        {
            DWORD dwYearHigh = 0;
            if ( 0 == GetCalendarInfo ( _locale,
                                        CAL_GREGORIAN,
                                        CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                        0,
                                        0,
                                        &dwYearHigh ) )
            {
                THROW ( CException () );
            }

            if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                dwYearHigh = 2029;

            WORD wMaxDecade = (WORD) dwYearHigh % 100;
            WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
            if ( stValue.wYear <= wMaxDecade )
                stValue.wYear += wMaxCentury;
            else
                stValue.wYear += ( wMaxCentury - 100 );
        }

        if( !SystemTimeToFileTime( &stValue, &ft ) )
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
    }
} //ParseDateTime

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::CheckForRelativeDate, private
//
//  Synopsis:   Attempts to parse a relative date expression.  If successful,
//              it fills in the FILETIME structure with the calculated
//              absolute date.
//
//  Notes:      Returns TRUE if the phrase is recognized as a relative
//              date (i.e., it begins with a '-').  Otherwise, returns FALSE.
//              The format of a relative date is
//              "-"{INTEGER("h"|"n"|"s"|"y"|"q"|"m"|"d"|"w")}*
//              Case is not significant.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft -- reference to the FILETIME structure to fill in
//                      with the result
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Moved from CQueryParser to
//                                      be more accessible
//              22-Jan-97   KyleP       Fix local/UTC discrepancy
//
//----------------------------------------------------------------------------

BOOL CValueParser::CheckForRelativeDate(
    WCHAR const *    phrase,
    FILETIME & ft )
{
    if( *phrase++ == L'-' )
    {
        SYSTEMTIME st;
        LARGE_INTEGER liLocal;
        LONGLONG llTicksInADay = ((LONGLONG)10000000) * ((LONGLONG)3600)
                                 * ((LONGLONG) 24);
        LONGLONG llTicksInAHour = ((LONGLONG) 10000000) * ((LONGLONG)3600);
        int iMonthDays[12]  = {1,-1,1,0,1,0,1,1,0,1,0,1};
        int iLoopValue, iPrevMonth, iPrevQuarter, iQuarterOffset;
        WORD wYear, wDayOfMonth, wStartDate;

        //
        //Obtain local time and convert it to file time
        //Copy the filetime to largeint data struct
        //

        GetSystemTime(&st);
        if(!SystemTimeToFileTime(&st, &ft))
            THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        LONGLONG llRelDate = (LONGLONG)0;
        for( ;; )
        {
            // eat white space
            while( iswspace( *phrase ) )
                phrase++;

            if( *phrase == 0 ) break;

            // parse the number
            WCHAR * pwcEnd;
            LONG lValue = wcstol( phrase, &pwcEnd, 10 );

            if( lValue < 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            // eat white space
            phrase = pwcEnd;
            while( iswspace( *phrase ) )
                phrase++;

            // grab the unit char & subtract the appropriate amount
            WCHAR wcUnit = *phrase++;
            switch( wcUnit )
            {
            case L'y':
            case L'Y':
                lValue *= 4;
                // Fall through and handle year like 4 quarters

            case L'q':
            case L'Q':
                lValue *= 3;
                // Fall through and handle quarters like 3 months

            case L'm':
            case L'M':
                 // Getting the System time to determine the day and month.

                if(!FileTimeToSystemTime(&ft, &st))
                {
                    THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                }
                wStartDate = st.wDay;
                wDayOfMonth = st.wDay;
                iLoopValue = lValue;
                while(iLoopValue)
                {
                    // Subtracting to the end of previous month
                    llRelDate = llTicksInADay * ((LONGLONG)(wDayOfMonth));
                    liLocal.QuadPart -= llRelDate;
                    ft.dwLowDateTime = liLocal.LowPart;
                    ft.dwHighDateTime = liLocal.HighPart;
                    SYSTEMTIME stTemp;
                    if(!FileTimeToSystemTime(&ft, &stTemp))
                    {
                         THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                    }
                    //
                    // if the end of previous month is greated then start date then we subtract to back up to the
                    // start date.  This will take care of 28/29 Feb(backing from 30/31 by 1 month).
                    //
                    if(stTemp.wDay > wStartDate)
                    {
                        llRelDate = llTicksInADay * ((LONGLONG)(stTemp.wDay - wStartDate));
                        liLocal.QuadPart -= llRelDate;
                        ft.dwLowDateTime = liLocal.LowPart;
                        ft.dwHighDateTime = liLocal.HighPart;
                        // Getting the date into stTemp for further iteration
                        if(!FileTimeToSystemTime(&ft, &stTemp))
                        {
                           THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
                        }
                    }
                    wDayOfMonth = stTemp.wDay;
                    iLoopValue--;
                } //End While

                break;

            case L'w':
            case L'W':
                lValue *= 7;

            case L'd':
            case L'D':
                llRelDate = llTicksInADay * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'h':
            case L'H':
                llRelDate = llTicksInAHour * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'n':
            case L'N':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)60) * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L's':
            case L'S':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            default:
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
            }

        } // for( ;; )

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define _OR 257
#define _AND 258
#define _NEAR 259
#define _NEARDIST 260
#define _NOT 261
#define _CONTAINS 262
#define _LT 263
#define _GT 264
#define _LTE 265
#define _GTE 266
#define _EQ 267
#define _NE 268
#define _ALLOF 269
#define _SOMEOF 270
#define _OPEN 271
#define _CLOSE 272
#define _VECTOR_END 273
#define _VE 274
#define _VE_END 275
#define _PROPEND 276
#define _NEAR_END 277
#define _LTSOME 278
#define _GTSOME 279
#define _LTESOME 280
#define _GTESOME 281
#define _EQSOME 282
#define _NESOME 283
#define _ALLOFSOME 284
#define _SOMEOFSOME 285
#define _LTALL 286
#define _GTALL 287
#define _LTEALL 288
#define _GTEALL 289
#define _EQALL 290
#define _NEALL 291
#define _ALLOFALL 292
#define _SOMEOFALL 293
#define _COERCE 294
#define _SHGENPREFIX 295
#define _SHGENINFLECT 296
#define _GENPREFIX 297
#define _GENINFLECT 298
#define _GENNORMAL 299
#define _PHRASE 300
#define _PROPNAME 301
#define _NEARUNIT 302
#define _WEIGHT 303
#define _REGEX 304
#define _FREETEXT 305
#define _VECTORELEMENT 306
#define _VEMETHOD 307
#define _PHRASEORREGEX 308
#define YYERRCODE 256
short triplhs[] = {                                        -1,
    0,    0,    0,   21,   21,   21,   21,   20,   20,   20,
   19,   19,   19,   12,   12,   12,   13,   13,   18,   18,
   18,   22,   23,   23,   10,   11,   16,   16,   16,   16,
   16,   16,   17,   17,    8,    8,   14,   14,    6,    6,
    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    6,    6,    7,    7,    1,    1,    1,    2,    2,    2,
    4,    3,    3,    5,    5,    9,    9,   15,   15,   15,
};
short triplen[] = {                                         2,
    1,    3,    2,    1,    2,    3,    4,    1,    3,    5,
    3,    5,    5,    0,    1,    1,    0,    1,    1,    1,
    3,    2,    3,    3,    1,    1,    1,    5,    4,    6,
    3,    5,    4,    4,    0,    1,    0,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    0,    1,    1,    1,    1,    1,    1,    2,
    2,    3,    3,    2,    2,    0,    1,    0,    1,    1,
};
short tripdefred[] = {                                      0,
    0,   15,   16,    0,    0,    8,    0,    0,   36,    3,
    0,    5,    0,   25,    0,    0,    0,    0,    0,   20,
   27,    0,   19,    0,    0,    0,    0,   43,   41,   44,
   42,    0,   40,   45,   46,   51,   49,   52,   50,   47,
   48,   53,   54,   59,   57,   60,   58,   55,   56,   61,
   62,    0,    0,    0,    0,    0,    0,    0,   77,    0,
    0,   18,   11,   22,    0,    9,    0,    0,    6,    0,
   65,   66,    0,    0,   67,   69,   68,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   26,   21,    0,    0,
    7,   71,    0,    0,   74,   38,   34,   70,   75,   33,
   12,   13,   79,   80,   29,    0,    0,    0,   10,   72,
   73,   28,   32,    0,   30,
};
short tripdgoto[] = {                                       4,
   74,   75,   76,   77,   78,   52,   53,   18,   60,   19,
   88,    5,   63,   97,  106,   20,   21,   22,    6,    7,
    8,   23,   24,
};
short tripsindex[] = {                                   -234,
 -256,    0,    0, -243,  218,    0, -241, -249,    0,    0,
  312,    0, -148,    0, -275, -275, -258,  281, -234,    0,
    0, -279,    0, -248, -275, -274, -102,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -15, -265, -253, -249,  -54,  -54, -234,    0,  -43,
 -242,    0,    0,    0, -234,    0, -225, -275,    0, -100,
    0,    0, -247, -172,    0,    0,    0, -251, -172, -279,
 -279, -243, -170, -263, -243,  215,    0,    0, -243, -275,
    0,    0, -167, -163,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -172, -172, -279,    0,    0,
    0,    0,    0, -172,    0,
};
short triprindex[] = {                                   -147,
 -101,    0,    0,    0,  125,    0,   38,   10,    0,    0,
 -177,    0, -147,    0, -193, -193,    0, -254, -147,    0,
    0,   66,    0,    0, -193,    0, -147,    0,    0,    0,
    0, -269,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  213,   29,   80,   80, -147,    0,  -55,
    0,    0,    0,    0, -147,    0,    0, -193,    0,    0,
    0,    0,    0,    6,    0,    0,    0,    0,    6,   66,
   66, -194,    6,    1,   34,  170,    0,    0, -192, -193,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    6,    6,   58,    0,    0,
    0,    0,    0,    6,    0,
};
short tripgindex[] = {                                      2,
    0,    0,    0,    0,    0,    0,    0,    3,    0,    0,
    0,   -4,   22,  428,   44,    0,    7,   27,  -25,  -14,
  116,    0,    0,
};
#define YYTABLESIZE 605
short triptable[] = {                                      66,
   78,   39,   10,   11,    1,   37,   76,   12,   27,    1,
   56,   57,   69,   13,   13,   58,   76,   25,   26,   62,
   61,    2,    3,   98,   64,   65,    1,   67,    2,   87,
   39,  103,  104,   31,   64,   39,   39,    4,   79,   76,
    2,    3,   76,   76,    9,   76,   76,    9,   76,   63,
   76,   90,   76,   91,   99,   86,   11,   17,   95,   82,
   12,   85,    2,    3,  109,   17,   89,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   23,   23,
   24,   24,   80,   81,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,  101,  102,   96,  110,   96,   14,   14,  111,   14,
   14,   14,   54,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,  103,  104,   63,  107,   55,  114,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,    0,    2,    3,
    0,    0,   14,   14,    0,   14,   14,   14,   68,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
    0,   92,    0,    0,    0,    0,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,    0,    2,    3,    0,    0,   14,   93,
    0,   14,   14,   14,   94,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,    1,    0,    0,
    0,    0,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,    0,
    0,    0,    0,    0,    0,   14,    9,   14,   14,    0,
    0,   14,   17,    2,    3,   70,   83,   78,   78,   78,
   78,   84,   37,   37,   37,   37,    1,    0,    1,    1,
    0,    0,   78,   78,   78,    0,   78,   37,   37,   37,
    0,    1,    1,    1,   71,    2,    0,    2,    2,   72,
   73,   31,   31,   31,    4,    4,    0,    0,    0,   78,
    2,    2,    2,    0,   37,   31,   31,   31,    1,    4,
    4,    4,    0,    0,   17,   17,   17,   17,    0,    0,
    0,    0,   17,   17,   17,   17,    0,    2,    0,   17,
   17,   17,   31,   17,    0,    0,    4,   17,   17,   17,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
    0,    0,    0,    0,    0,    0,    0,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,    0,    0,   35,   35,    0,   35,
    0,    0,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,    0,    0,    0,    0,    0,
    0,    0,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,    0,    0,
    0,   35,   35,    0,   35,    0,    0,    0,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
    0,    0,    0,    0,    0,    0,    0,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,    0,    0,    0,   35,   35,    0,    0,
    0,    0,    0,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,    0,    0,   14,    0,    0,   14,    0,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,   35,  100,    0,   15,    0,
  105,   15,    0,    0,  108,    9,   35,   16,    9,    0,
   16,   17,    0,    0,   17,    0,    0,    0,    0,    0,
    0,    0,    0,  112,  113,    0,    0,    0,    0,    0,
    0,  115,   59,   28,   29,   30,   31,   32,   33,   34,
   35,    0,    0,    0,    0,    0,    0,    0,   36,   37,
   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,
   48,   49,   50,   51,   28,   29,   30,   31,   32,   33,
   34,   35,    0,    0,    0,    0,    0,    0,    0,   36,
   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,
   47,   48,   49,   50,   51,
};
short tripcheck[] = {                                      25,
    0,  271,    1,    1,  261,    0,  261,    1,  258,    0,
   15,   16,   27,  257,  257,  274,  271,  259,  260,  299,
   19,  297,  298,  275,  273,  274,  261,  302,    0,  272,
  300,  295,  296,    0,  304,  305,  306,    0,  304,  294,
  297,  298,  297,  298,  301,  300,  301,  301,  303,  304,
  305,  277,  307,   68,  306,   60,   54,    0,  306,   58,
   54,   60,  297,  298,   90,    0,   65,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  273,  274,
  273,  274,   56,   57,  278,  279,  280,  281,  282,  283,
  284,  285,  286,  287,  288,  289,  290,  291,  292,  293,
  294,   80,   81,  276,  272,  276,  300,  301,  272,  303,
  304,  305,  261,  307,  262,  263,  264,  265,  266,  267,
  268,  269,  270,  271,  295,  296,  304,   84,   13,  108,
  278,  279,  280,  281,  282,  283,  284,  285,  286,  287,
  288,  289,  290,  291,  292,  293,  294,   -1,  297,  298,
   -1,   -1,  300,  301,   -1,  303,  304,  305,  261,  307,
  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
   -1,  272,   -1,   -1,   -1,   -1,  278,  279,  280,  281,
  282,  283,  284,  285,  286,  287,  288,  289,  290,  291,
  292,  293,  294,   -1,  297,  298,   -1,   -1,  300,  300,
   -1,  303,  304,  305,  305,  307,  262,  263,  264,  265,
  266,  267,  268,  269,  270,  271,  271,  261,   -1,   -1,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,  285,
  286,  287,  288,  289,  290,  291,  292,  293,  294,   -1,
   -1,   -1,   -1,   -1,   -1,  301,  301,  303,  304,   -1,
   -1,  307,  307,  297,  298,  271,  300,  257,  258,  259,
  260,  305,  257,  258,  259,  260,  257,   -1,  259,  260,
   -1,   -1,  272,  273,  274,   -1,  276,  272,  273,  274,
   -1,  272,  273,  274,  300,  257,   -1,  259,  260,  305,
  306,  258,  259,  260,  257,  258,   -1,   -1,   -1,  299,
  272,  273,  274,   -1,  299,  272,  273,  274,  299,  272,
  273,  274,   -1,   -1,  257,  258,  259,  260,   -1,   -1,
   -1,   -1,  257,  258,  259,  260,   -1,  299,   -1,  272,
  273,  274,  299,  276,   -1,   -1,  299,  272,  273,  274,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,   -1,   -1,  297,  298,   -1,  300,
   -1,   -1,  303,  304,  305,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  270,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,  285,
  286,  287,  288,  289,  290,  291,  292,  293,   -1,   -1,
   -1,  297,  298,   -1,  300,   -1,   -1,   -1,  304,  305,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,   -1,   -1,   -1,  297,  298,   -1,   -1,
   -1,   -1,   -1,  304,  305,  263,  264,  265,  266,  267,
  268,  269,  270,   -1,   -1,  271,   -1,   -1,  271,   -1,
  278,  279,  280,  281,  282,  283,  284,  285,  286,  287,
  288,  289,  290,  291,  292,  293,   79,   -1,  294,   -1,
   83,  294,   -1,   -1,  300,  301,  304,  303,  301,   -1,
  303,  307,   -1,   -1,  307,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  106,  107,   -1,   -1,   -1,   -1,   -1,
   -1,  114,  262,  263,  264,  265,  266,  267,  268,  269,
  270,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,
  280,  281,  282,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  263,  264,  265,  266,  267,  268,
  269,  270,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,
  279,  280,  281,  282,  283,  284,  285,  286,  287,  288,
  289,  290,  291,  292,  293,
};
#define YYFINAL 4
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 308
#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
char *tripname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'('","')'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_OR","_AND","_NEAR",
"_NEARDIST","_NOT","_CONTAINS","_LT","_GT","_LTE","_GTE","_EQ","_NE","_ALLOF",
"_SOMEOF","_OPEN","_CLOSE","_VECTOR_END","_VE","_VE_END","_PROPEND","_NEAR_END",
"_LTSOME","_GTSOME","_LTESOME","_GTESOME","_EQSOME","_NESOME","_ALLOFSOME",
"_SOMEOFSOME","_LTALL","_GTALL","_LTEALL","_GTEALL","_EQALL","_NEALL",
"_ALLOFALL","_SOMEOFALL","_COERCE","_SHGENPREFIX","_SHGENINFLECT","_GENPREFIX",
"_GENINFLECT","_GENNORMAL","_PHRASE","_PROPNAME","_NEARUNIT","_WEIGHT","_REGEX",
"_FREETEXT","_VECTORELEMENT","_VEMETHOD","_PHRASEORREGEX",
};
char *triprule[] = {
"$accept : query",
"query : AndTerm",
"query : query _OR AndTerm",
"query : _NOT query",
"AndTerm : NearTerm",
"AndTerm : _NOT PropTerm",
"AndTerm : AndTerm _AND NearTerm",
"AndTerm : AndTerm _AND _NOT NearTerm",
"NearTerm : CoerceTerm",
"NearTerm : NearTerm _NEAR CoerceTerm",
"NearTerm : NearTerm _NEARDIST _NEARUNIT _NEAR_END CoerceTerm",
"CoerceTerm : Gen NestTerm GenEnd",
"CoerceTerm : Gen _COERCE Gen NestTerm GenEnd",
"CoerceTerm : Gen _WEIGHT Gen NestTerm GenEnd",
"Gen :",
"Gen : _GENPREFIX",
"Gen : _GENINFLECT",
"GenEnd :",
"GenEnd : _GENNORMAL",
"NestTerm : VectorTerm",
"NestTerm : Term",
"NestTerm : Open query Close",
"VectorTerm : VectorSpec _VECTOR_END",
"VectorSpec : _VEMETHOD _VE query",
"VectorSpec : VectorSpec _VE query",
"Open : _OPEN",
"Close : _CLOSE",
"Term : PropTerm",
"Term : Property Contains _PHRASE ShortGen PropEnd",
"Term : Property Contains _PHRASE PropEnd",
"Term : Property Contains Gen _PHRASE GenEnd PropEnd",
"Term : Property Contains query",
"Term : Property Contains _FREETEXT ShortGen PropEnd",
"PropTerm : Property Matches _REGEX PropEnd",
"PropTerm : Property Op Value PropEnd",
"Property :",
"Property : _PROPNAME",
"PropEnd :",
"PropEnd : _PROPEND",
"Op : _EQ",
"Op : _NE",
"Op : _GT",
"Op : _GTE",
"Op : _LT",
"Op : _LTE",
"Op : _ALLOF",
"Op : _SOMEOF",
"Op : _EQSOME",
"Op : _NESOME",
"Op : _GTSOME",
"Op : _GTESOME",
"Op : _LTSOME",
"Op : _LTESOME",
"Op : _ALLOFSOME",
"Op : _SOMEOFSOME",
"Op : _EQALL",
"Op : _NEALL",
"Op : _GTALL",
"Op : _GTEALL",
"Op : _LTALL",
"Op : _LTEALL",
"Op : _ALLOFALL",
"Op : _SOMEOFALL",
"Matches :",
"Matches : _EQ",
"Value : _PHRASE",
"Value : _FREETEXT",
"Value : VectorValue",
"VectorValue : EmptyVector",
"VectorValue : SingletVector",
"VectorValue : MultiVector _VE_END",
"EmptyVector : _OPEN _CLOSE",
"SingletVector : _OPEN _PHRASE _CLOSE",
"SingletVector : _OPEN _FREETEXT _CLOSE",
"MultiVector : _VECTORELEMENT _VECTORELEMENT",
"MultiVector : MultiVector _VECTORELEMENT",
"Contains :",
"Contains : _CONTAINS",
"ShortGen :",
"ShortGen : _SHGENPREFIX",
"ShortGen : _SHGENINFLECT",
};
#endif
YYPARSER::YYPARSER(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex)
        : CTripYYBase( ColumnMapper, locale, yylex ) {
    xyyvs.SetSize(INITSTACKSIZE);
    yydebug = 0;
}
#define YYABORT(sc) { return ResultFromScode(sc); }
#define YYFATAL   E_FAIL
#define YYSUCCESS S_OK
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
int YYPARSER::Parse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        try
        {
            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                yychar = 0;
        }
        catch (HRESULT hr)
        {
            switch(hr)
            {
            case E_OUTOFMEMORY:
                YYABORT(E_OUTOFMEMORY);
                break;

            default:
                YYABORT(E_FAIL);
                break;
            }
        }
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
        {
            int yysspLoc = (int) ( yyssp - xyyss.Get() );
            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
            yyssp = xyyss.Get() + yysspLoc;
        }
        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
        {
            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);
            yyvsp = xyyvs.Get() + yyvspLoc;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
    yyerror("syntax error");
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
                {
                    int yysspLoc = (int) ( yyssp - xyyss.Get() );
                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
                    yyssp = xyyss.Get() + yysspLoc;
                }
                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
                {
                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);
                    yyvsp = xyyvs.Get() + yyvspLoc;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= xyyss.Get()) goto yyabort;
                --yyssp;
                PopVs();
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
                   yyval.pRest = yyvsp[0].pRest;
                   }
break;
case 2:
{
                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstQuery(yyvsp[-2].pRest);
                    XDbRestriction prstTerm(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );


                    if (DBOP_or == yyvsp[-2].pRest->GetCommandType())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbBooleanNodeRestriction *)(yyvsp[-2].pRest))->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();
                        yyval.pRest = prstQuery.Acquire();
                    }
                    else
                    {
                        /* create smart Or node*/
                        XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_or ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add left term & release its smart pointer*/
                        prstNew->AppendChild( prstQuery.GetPointer() );
                        prstQuery.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        yyval.pRest = prstNew.Acquire();
                    }
                    _setRst.Add( yyval.pRest );
                }
break;
case 3:
{

                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[0].pRest );

                        /* Create not node*/

                        XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_not ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );


                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add right term and release its smart pointer*/
                        prstNew->AppendChild( prstQuery.GetPointer() );
                        prstQuery.Acquire();

                        yyval.pRest = prstNew.Acquire();
                        _setRst.Add( yyval.pRest );
                }
break;
case 4:
{ yyval.pRest = yyvsp[0].pRest;}
break;
case 5:
{
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[0].pRest );

                        /* Create not node*/

                        XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_not ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add right term and release its smart pointer*/
                        prstNew->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        yyval.pRest = prstNew.Acquire();
                        _setRst.Add( yyval.pRest );
                    }
break;
case 6:
{
                        AssertReq(yyvsp[-2].pRest);
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[-2].pRest);
                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[-2].pRest );
                        _setRst.Remove( yyvsp[0].pRest );

                        if (DBOP_and == yyvsp[-2].pRest->GetCommandType())
                        {
                            /* add right term & release its smart pointer*/
                            ((CDbBooleanNodeRestriction *)(yyvsp[-2].pRest))->AppendChild( prstTerm.GetPointer() );
                            prstTerm.Acquire();
                            yyval.pRest = prstQuery.Acquire();
                        }
                        else
                        {
                            /* create smart And node*/
                            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_and ) );
                            if( prstNew.GetPointer() == 0 )
                                THROW( CException( E_OUTOFMEMORY ) );

                            prstNew->SetWeight(MAX_QUERY_RANK);

                            /* add left term & release its smart pointer*/
                            prstNew->AppendChild( prstQuery.GetPointer() );
                            prstQuery.Acquire();

                            /* add right term & release its smart pointer*/
                            prstNew->AppendChild( prstTerm.GetPointer() );
                            prstTerm.Acquire();

                            yyval.pRest = prstNew.Acquire();
                        }
                        _setRst.Add( yyval.pRest );
                    }
break;
case 7:
{
                        AssertReq(yyvsp[-3].pRest);
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[-3].pRest);
                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[-3].pRest );
                        _setRst.Remove( yyvsp[0].pRest );

                        /* create smart Not node*/
                        XDbNotRestriction prstNot( new CDbNotRestriction );
                        if( prstNot.GetPointer() == 0 )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNot->SetWeight(MAX_QUERY_RANK);

                        /* set child of Not node & release smart factor pointer*/
                        prstNot->SetChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        if (DBOP_and == yyvsp[-3].pRest->GetCommandType())
                        {
                            /* add right term & release its smart pointer*/
                            ((CDbBooleanNodeRestriction *)(yyvsp[-3].pRest))->AppendChild( prstNot.GetPointer() );
                            prstNot.Acquire();

                            yyval.pRest = prstQuery.Acquire();
                        }
                        else
                        {
                            /* create smart And node*/
                            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_and ) );
                            if( prstNew.GetPointer() == 0 )
                                THROW( CException( E_OUTOFMEMORY ) );

                            prstNew->SetWeight(MAX_QUERY_RANK);

                            /* add left term & release its smart pointer*/
                            prstNew->AppendChild( prstQuery.GetPointer() );
                            prstQuery.Acquire();

                            /* add right term & release its smart pointer*/
                            prstNew->AppendChild( prstNot.GetPointer() );
                            prstNot.Acquire();

                            yyval.pRest = prstNew.Acquire();
                        }
                        _setRst.Add( yyval.pRest );
                    }
break;
case 8:
{ yyval.pRest = yyvsp[0].pRest; }
break;
case 9:
{
                    /* uses defaults*/

                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-2].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    if (DBOP_content_proximity == yyvsp[-2].pRest->GetCommandType() &&
                        50 == ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->GetProximityDistance() &&
                        PROXIMITY_UNIT_WORD == ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->GetProximityUnit())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstLeft.Acquire();
                    }
                    else
                    {
                        /* create smart Prox node*/
                        XDbProximityNodeRestriction prstNew(new CDbProximityNodeRestriction()); /* uses defaults*/

                        if ( prstNew.IsNull() || !prstNew->IsValid() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        /* add left phrase & release its smart pointer*/
                        prstNew->AppendChild( prstLeft.GetPointer() );
                        prstLeft.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstNew.Acquire();
                    }
                    _setRst.Add( yyval.pRest );
                }
break;
case 10:
{
                    AssertReq(yyvsp[-4].pRest);
                    AssertReq(yyvsp[-3].pwszChar);
                    AssertReq(yyvsp[-2].pwszChar);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-4].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-4].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    WCHAR * pwcEnd;
                    ULONG ulValue = wcstol( yyvsp[-3].pwszChar, &pwcEnd, 10 );
                    ULONG ulUnit;

                    if (L'w' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_WORD;
                    else if (L's' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_SENTENCE;
                    else if (L'p' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_PARAGRAPH;
                    else if (L'c' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_CHAPTER;

                    if (DBOP_content_proximity == yyvsp[-4].pRest->GetCommandType() &&
                        ulValue == ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->GetProximityDistance() &&
                        ulUnit == ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->GetProximityUnit())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstLeft.Acquire();
                    }
                    else
                    {
                        /* create smart Prox node*/
                        XDbProximityNodeRestriction prstNew(new CDbProximityNodeRestriction(ulUnit, ulValue));

                        if( prstNew.IsNull() || !prstNew->IsValid() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        /* add left phrase & release its smart pointer*/
                        prstNew->AppendChild( prstLeft.GetPointer() );
                        prstLeft.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstNew.Acquire();
                    }
                    _setRst.Add( yyval.pRest );
                }
break;
case 11:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 12:
{
                    AssertReq(yyvsp[-1].pRest);
                    XDbRestriction prstQuery(yyvsp[-1].pRest);

                    yyvsp[-1].pRest->SetWeight(MAX_QUERY_RANK);
                    yyval.pRest = prstQuery.Acquire();
                }
break;
case 13:
{
                    AssertReq(yyvsp[-3].pwszChar);
                    AssertReq(yyvsp[-1].pRest);
                    XDbRestriction prstQuery(yyvsp[-1].pRest);

                    WCHAR * pwcEnd;
                    double dWeight = wcstod( yyvsp[-3].pwszChar, &pwcEnd );
                    if ( dWeight > 1.0 )
                       THROW( CParserException( QPARSE_E_WEIGHT_OUT_OF_RANGE ) );
                    LONG lWeight = (LONG)(dWeight * MAX_QUERY_RANK);
                    yyvsp[-1].pRest->SetWeight(lWeight);
                    yyval.pRest = prstQuery.Acquire();
                }
break;
case 14:
{
                    yyval.iInt = 0;
                }
break;
case 15:
{
                    SetCurrentGenerate(GENERATE_METHOD_PREFIX);
                    yyval.iInt = GENERATE_METHOD_PREFIX;
                }
break;
case 16:
{
                    SetCurrentGenerate(GENERATE_METHOD_INFLECT);
                    yyval.iInt = GENERATE_METHOD_INFLECT;
                }
break;
case 17:
{
                    yyval.iEmpty = GENERATE_METHOD_EXACT;
                }
break;
case 18:
{
                    /* don't set the generate method to 0 here. Doing so will*/
                    /* reset the method before it gets used.*/
                    yyval.iEmpty = GENERATE_METHOD_EXACT;
                }
break;
case 19:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 20:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 21:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 22:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 23:
{
                    AssertReq(yyvsp[-2].pwszChar);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstQuery(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[0].pRest );

                    ULONG rankMethod = VECTOR_RANK_JACCARD; /* default if nothing else matches*/

                    if ( 0 == _wcsicmp( L"jaccard", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_JACCARD;
                    }
                    else if ( 0 == _wcsicmp( L"dice", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_DICE;
                    }
                    else if ( 0 == _wcsicmp( L"inner", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_INNER;
                    }
                    else if ( 0 == _wcsicmp( L"max", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_MAX;
                    }
                    else if ( 0 == _wcsicmp( L"min", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_MIN;
                    }
                    else
                    {
                        THROW( CException( QPARSE_E_INVALID_RANKMETHOD ) );
                    }

                    /* create smart Vector node*/
                    XDbVectorRestriction prstNew( new CDbVectorRestriction( rankMethod ) );

                    if ( prstNew.IsNull() || !prstNew->IsValid() )
                    {
                        THROW( CException( E_OUTOFMEMORY ) );
                    }

                    /* add expression & release its smart pointer*/
                    prstNew->AppendChild( prstQuery.GetPointer() );
                    prstQuery.Acquire();

                    /* Let the next vector element start off with a clean slate...*/
                    /* We don't want the current element's property and genmethod*/
                    /* to rub off on it.*/
                    InitState();


                    yyval.pRest = prstNew.Acquire();
                    _setRst.Add( yyval.pRest );
                }
break;
case 24:
{
                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-2].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    /* add right term & release its smart pointer*/
                    ((CDbVectorRestriction *)(yyvsp[-2].pRest))->AppendChild( prstRight.GetPointer() );
                    prstRight.Acquire();

                    /* Let the next vector element start off with a clean slate...*/
                    /* We don't want the current element's property and genmethod*/
                    /* to rub off on it.*/
                    InitState();

                    yyval.pRest = prstLeft.Acquire();
                    _setRst.Add( yyval.pRest );
                }
break;
case 25:
{
                    SaveState();
                    yyval.iEmpty = 0;
                }
break;
case 26:
{
                    RestoreState();
                    yyval.iEmpty = 0;
                }
break;
case 27:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 28:
{
                    yyval.pRest = BuildPhrase(yyvsp[-2].pwszChar, yyvsp[-1].iInt);
                    _setRst.Add( yyval.pRest );
                }
break;
case 29:
{
                    yyval.pRest = BuildPhrase(yyvsp[-1].pwszChar, 0);
                    _setRst.Add( yyval.pRest );
                }
break;
case 30:
{
                    yyval.pRest = BuildPhrase(yyvsp[-2].pwszChar, yyvsp[-3].iInt);
                    _setRst.Add( yyval.pRest );
                }
break;
case 31:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 32:
{
                    AssertReq(yyvsp[-2].pwszChar);
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    /* Clear generation method so it won't rub off on the following phrase*/
                    SetCurrentGenerate(GENERATE_METHOD_EXACT);

                    /* generation method not used - if it's there, ignore it*/
                    /* (already stripped from longhand version, but not from*/
                    /* shorthand version*/
                    LPWSTR pLast = yyvsp[-2].pwszChar + wcslen(yyvsp[-2].pwszChar) -1;
                    if ( L'*' == *pLast) /* prefix*/
                        *pLast-- = L'\0';
                    if ( L'*' == *pLast) /* inflect*/
                        *pLast-- = L'\0';

                    XDbNatLangRestriction pRest ( new CDbNatLangRestriction (yyvsp[-2].pwszChar, *pps, _lcid));
                    if ( pRest.IsNull() || !pRest->IsValid() )
                        THROW( CException( E_OUTOFMEMORY ) );

                    yyval.pRest = pRest.Acquire();
                    _setRst.Add( yyval.pRest );
                }
break;
case 33:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;

                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    if ( ( ( DBTYPE_WSTR|DBTYPE_BYREF ) != dbType ) &&
                        ( ( DBTYPE_STR|DBTYPE_BYREF ) != dbType ) &&
                        ( VT_BSTR != dbType ) &&
                        ( VT_LPWSTR != dbType ) &&
                        ( VT_LPSTR != dbType ) )
                        THROW( CParserException( QPARSE_E_EXPECTING_REGEX_PROPERTY ) );

                    if( yyvsp[-1].pwszChar == 0 )
                        THROW( CParserException( QPARSE_E_EXPECTING_REGEX ) );

                    /* create smart Property node*/
                    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
                    if( prstProp.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    prstProp->SetRelation(DBOP_like);      /* LIKE relation*/

                    if ( ( ! prstProp->SetProperty( *pps ) ) ||
                        ( ! prstProp->SetValue( yyvsp[-1].pwszChar ) ) ||
                        ( ! prstProp->IsValid() ) )
                        THROW( CException( E_OUTOFMEMORY ) );

                    /* release & return smart Property node*/
                    yyval.pRest = prstProp.Acquire();
                    _setRst.Add( yyval.pRest );
                }
break;
case 34:
{
                    AssertReq(yyvsp[-2].dbop);
                    AssertReq(yyvsp[-1].pStorageVar);
                    XPtr<CStorageVariant> pStorageVar( yyvsp[-1].pStorageVar );
                    _setStgVar.Remove( yyvsp[-1].pStorageVar );

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    /* create smart Property node*/
                    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
                    if( prstProp.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    if (! prstProp->SetProperty( *pps ) )
                        THROW( CException( E_OUTOFMEMORY ) );

                    /* don't allow @contents <relop> X -- it's too expensive and we'll*/
                    /* never find any hits anyway (until we implement this feature)*/

                    if ( *pps == psContents )
                        THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

                    prstProp->SetRelation( yyvsp[-2].dbop );

                    if ( 0 != pStorageVar.GetPointer() )
                    {
                        /* This should always be the case  - else PropValueParser would have thrown*/

                        if ( ! ( ( prstProp->SetValue( pStorageVar.GetReference() ) ) &&
                            ( prstProp->IsValid() ) ) )
                            THROW( CException( E_OUTOFMEMORY ) );
                    }
                    yyval.pRest = prstProp.Acquire();
                    _setRst.Add( yyval.pRest );
                }
break;
case 35:
{
                    yyval.iEmpty = 0;
                }
break;
case 36:
{
                    PushProperty(yyvsp[0].pwszChar);
                    yyval.iEmpty = 0;
                }
break;
case 37:
{
                    fDeferredPop = FALSE;
                    yyval.iEmpty = 0;
                }
break;
case 38:
{
                    /* When PropEnd is matched, the action of using the property*/
                    /* hasn't yet taken place. So popping the property right now*/
                    /* will cause the property to be unavailable when the action*/
                    /* is performed. Instead, pop it off after it has been used.*/
                    fDeferredPop = TRUE;
                    yyval.iEmpty = 0;
                }
break;
case 39:
{ yyval.dbop = DBOP_equal;}
break;
case 40:
{ yyval.dbop = DBOP_not_equal;}
break;
case 41:
{ yyval.dbop = DBOP_greater;}
break;
case 42:
{ yyval.dbop = DBOP_greater_equal;}
break;
case 43:
{ yyval.dbop = DBOP_less;}
break;
case 44:
{ yyval.dbop = DBOP_less_equal;}
break;
case 45:
{ yyval.dbop = DBOP_allbits;}
break;
case 46:
{ yyval.dbop = DBOP_anybits;}
break;
case 47:
{ yyval.dbop = DBOP_equal_any;}
break;
case 48:
{ yyval.dbop = DBOP_not_equal_any;}
break;
case 49:
{ yyval.dbop = DBOP_greater_any;}
break;
case 50:
{ yyval.dbop = DBOP_greater_equal_any;}
break;
case 51:
{ yyval.dbop = DBOP_less_any;}
break;
case 52:
{ yyval.dbop = DBOP_less_equal_any;}
break;
case 53:
{ yyval.dbop = DBOP_allbits_any;}
break;
case 54:
{ yyval.dbop = DBOP_anybits_any;}
break;
case 55:
{ yyval.dbop = DBOP_equal_all;}
break;
case 56:
{ yyval.dbop = DBOP_not_equal_all;}
break;
case 57:
{ yyval.dbop = DBOP_greater_all;}
break;
case 58:
{ yyval.dbop = DBOP_greater_equal_all;}
break;
case 59:
{ yyval.dbop = DBOP_less_all;}
break;
case 60:
{ yyval.dbop = DBOP_less_equal_all;}
break;
case 61:
{ yyval.dbop = DBOP_allbits_all;}
break;
case 62:
{ yyval.dbop = DBOP_anybits_all;}
break;
case 63:
{ yyval.dbop = 0; }
break;
case 64:
{ yyval.dbop = DBOP_equal; }
break;
case 65:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    CValueParser PropValueParser( FALSE, dbType, _lcid );
                    StripQuotes(yyvsp[0].pwszChar);
                    PropValueParser.AddValue( yyvsp[0].pwszChar );

                    yyval.pStorageVar = PropValueParser.AcquireStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                 }
break;
case 66:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    CValueParser PropValueParser( FALSE, dbType, _lcid );
                    PropValueParser.AddValue( yyvsp[0].pwszChar );

                    yyval.pStorageVar = PropValueParser.AcquireStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                }
break;
case 67:
{
                    yyval.pStorageVar = yyvsp[0].pStorageVar;
                }
break;
case 68:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[0].pPropValueParser );
                    _setValueParser.Remove( yyvsp[0].pPropValueParser );
                    yyval.pStorageVar = yyvsp[0].pPropValueParser->AcquireStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                }
break;
case 69:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[0].pPropValueParser );
                    _setValueParser.Remove( yyvsp[0].pPropValueParser );
                    yyval.pStorageVar = yyvsp[0].pPropValueParser->AcquireStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                }
break;
case 70:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[-1].pPropValueParser );
                    _setValueParser.Remove( yyvsp[-1].pPropValueParser );
                    yyval.pStorageVar = yyvsp[-1].pPropValueParser->AcquireStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                }
break;
case 71:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    yyval.pPropValueParser = pPropValueParser.Acquire();
                    _setValueParser.Add( yyval.pPropValueParser );
               }
break;
case 72:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    StripQuotes(yyvsp[-1].pwszChar);
                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.Acquire();
                    _setValueParser.Add( yyval.pPropValueParser );
                }
break;
case 73:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.Acquire();
                    _setValueParser.Add( yyval.pPropValueParser );
                }
break;
case 74:
{
                    AssertReq(yyvsp[-1].pwszChar);
                    AssertReq(yyvsp[0].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );
                    pPropValueParser->AddValue( yyvsp[0].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.Acquire();
                    _setValueParser.Add( yyval.pPropValueParser );
                }
break;
case 75:
{
                    AssertReq(yyvsp[-1].pPropValueParser);
                    AssertReq(yyvsp[0].pwszChar);

                    yyvsp[-1].pPropValueParser->AddValue(yyvsp[0].pwszChar);

                    yyval.pPropValueParser = yyvsp[-1].pPropValueParser;
                }
break;
case 76:
{
                   yyval.iEmpty = 0;
               }
break;
case 77:
{
                   yyval.iEmpty = 0;
               }
break;
case 78:
{
                   yyval.iInt = 0;
               }
break;
case 79:
{
                   yyval.iInt = 1;
               }
break;
case 80:
{
                   yyval.iInt = 2;
               }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            try
            {
                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                    yychar = 0;
            }
            catch (HRESULT hr)
            {
                switch(hr)
                {
                case E_OUTOFMEMORY:
                    YYABORT(E_OUTOFMEMORY);
                    break;

                default:
                    YYABORT(E_FAIL);
                    break;
                }
            }
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
    {
        int yysspLoc = (int) ( yyssp - xyyss.Get() );
        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);
        yyssp = xyyss.Get() + yysspLoc;
    }
    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
    {
        int yyvspLoc = (int) ( yyssp - xyyss.Get() );
        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);
        yyvsp = xyyvs.Get() + yyvspLoc;
    }
    *++yyssp = (short) yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyabort:
   EmptyValueStack(yylval);
    return YYFATAL;
yyaccept:
    return YYSUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\qutil\triplish\yybase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       YYBase.cxx
//
//  Contents:   Custom base class for YYPARSER
//
//  History:    18-Apr-2000   KitmanH       Created
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "yybase.hxx"
#include "parser.h"
#include "flexcpp.h"
#include "parsepl.h"

void StripQuotes(WCHAR *wcsPhrase);

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::CTripYYBase, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ColumnMapper] -- Column Mapper
//              [locale]       -- locale
//              [yylex]        -- Lexer
//
//  History:    18-Apr-2000   KitmanH       Created
//
//--------------------------------------------------------------------------

CTripYYBase::CTripYYBase( IColumnMapper & ColumnMapper, 
                          LCID & locale,
                          YYLEXER & yylex )
        : _yylex( yylex ),
          _ColumnMapper(ColumnMapper), 
          _lcid(locale)
{
    InitState();
    fDeferredPop = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::~CTripYYBase, public
//
//  Synopsis:   Destructor
//
//  History:    18-Apr-2000   KitmanH      Created
//
//--------------------------------------------------------------------------

CTripYYBase::~CTripYYBase()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::yyprimebuffer, public
//
//  Synopsis:   Prime lexer with text (passthrough to lexer)
//
//  Arguments:  [pszBuffer] -- Buffer
//
//  History:    18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::yyprimebuffer(const YY_CHAR *pszBuffer)
{
    _yylex.yyprimebuffer(pszBuffer);
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::triperror, protected
//
//  Synopsis:   Report parsing errors
//
//  Arguments:  [szError] -- Error string
//
//  History:    18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::triperror( char const * szError )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::InitState, public
//
//  Synopsis:   Initialize property and generate method
//
//  History:    01-Oct-1997   emilyb        created
//              18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::InitState(void)
{
    // Push makes a copy of what is passed in.
    PushProperty(L"contents");
    _currentState.iGenerateMethod = GENERATE_METHOD_EXACT;
    // We don't use xwszPropName field of _currentState. Instead,
    // we use the prop name stack to get the appropriate propname.
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::GetCurrentProperty, public
//
//  Synopsis:  Return info on current prop
//
//  Arguments: [pp_ps] -- filled with CDbColId * for current prop
//             [dbType] -- set to DBTYPE for current prop
//
//  History:   01-Oct-1997   emilyb        created
//             10-Apr-1999   KrishnaN      Modified to use stack
//             18-Apr-2000   KitmanH       Moved from YYPARSER 
//
//----------------------------------------------------------------------------

void  CTripYYBase::GetCurrentProperty(CDbColId ** pp_ps, DBTYPE *dbType)
{
    // Get the top most property off of the stack and use it

    if ( S_OK != _ColumnMapper.GetPropInfoFromName(
                                                   _propNameStack.Get(_propNameStack.Count() - 1),
                                                   (DBID **) pp_ps,
                                                   dbType,
                                                   0 ) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::PushProperty, public
//
//  Synopsis:  Pushes current property onto stack.
//
//  Arguments: [pwszProperty] - property
//
//  History:   01-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::PushProperty( WCHAR const * wszProperty)
{
    // Make a copy and save it. The copy will be automatically deleted
    // when the stack self destructs.

    int iLen = wcslen(wszProperty) + 1;
    XPtrST<WCHAR> xwszPropertyCopy(new WCHAR[iLen]);
    RtlCopyMemory(xwszPropertyCopy.GetPointer(), wszProperty, sizeof(WCHAR) * iLen);
    _propNameStack.Push(xwszPropertyCopy.GetPointer());
    xwszPropertyCopy.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::PopProperty, public
//
//  Synopsis:  Pops the current property off the stack
//
//  History:   10-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::PopProperty(void)
{
    // pop the property name off of the stack and delete it

    delete _propNameStack.Pop();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::SetCurrentGenerate, public
//
//  Synopsis:  Sets current generate method
//
//  Arguments: [iGenerateMethod] - generate method
//
//  History:    01-Oct-1997   emilyb        created
//              18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::SetCurrentGenerate(int iGenerateMethod)
{
    _currentState.iGenerateMethod = iGenerateMethod;
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::GetCurrentGenerate, public
//
//  Synopsis:  Return info on current generate method
//
//  Arguments: [iGenerateMethod] -- set to current generate method
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void  CTripYYBase::GetCurrentGenerate(int *iGenerateMethod)
{
    *iGenerateMethod = _currentState.iGenerateMethod;
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::SaveState, public
//
//  Synopsis:  Saves current state on state stack, and inits new state
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::SaveState(void)
{
    XPtr <STATE> xState( new STATE );

    xState.GetPointer()->iGenerateMethod = _currentState.iGenerateMethod;

    // When you save the state, pop the propname off of the
    // stack and save the ptr.
    xState.GetPointer()->xwszPropName.Set( _propNameStack.Pop() );

    _savedStates.Push( xState.GetPointer() );
    xState.Acquire();
    InitState();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::RestoreState, public
//
//  Synopsis:  Restores state from state stack
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::RestoreState(void)
{
    XPtr <STATE> xState (_savedStates.Pop());

    _currentState.iGenerateMethod = xState.GetPointer()->iGenerateMethod;

    Win4Assert(xState.GetPointer()->xwszPropName.GetPointer());

    // Push the saved state onto the stack
    _propNameStack.Push(xState.GetPointer()->xwszPropName.GetPointer());
    xState.GetPointer()->xwszPropName.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::BuildPhrase
//
//  Synopsis:  Builds a phrase node.
//
//  Arguments: [wcsPhrase]  - The phrase
//             [iGenMethod] - The generation method
//
//  History:   01-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER 
//
//----------------------------------------------------------------------------

CDbContentRestriction * CTripYYBase::BuildPhrase(WCHAR *wcsPhrase, int iGenMethod)
{
    Win4Assert(wcsPhrase);

    if (0 == *wcsPhrase)
        THROW( CException( QPARSE_E_EXPECTING_PHRASE ) );

    CDbColId *pps;
    DBTYPE dbType;
    GetCurrentProperty(&pps, &dbType);

    // We used the property. Now pop it off if need be
    if (fDeferredPop)
        PopProperty();

    // generation method stripped in some cases, but not all.
    // if it's there, use it

    LPWSTR pLast = wcsPhrase + wcslen(wcsPhrase) - 1;

    if (L'"' == *wcsPhrase && L'"' == *pLast)
    {
        StripQuotes(wcsPhrase);
        if (0 == *wcsPhrase)
            THROW( CException( QPARSE_E_EXPECTING_PHRASE ) );
    }
    else
    {
        if ( L'*' == *pLast) // prefix
        {
            *pLast-- = L'\0';
            SetCurrentGenerate(GENERATE_METHOD_PREFIX);
        }
        if ( L'*' == *pLast) // inflect
        {
            *pLast-- = L'\0';
            SetCurrentGenerate(GENERATE_METHOD_INFLECT);
        }
    }

    int fuzzy;
    GetCurrentGenerate(&fuzzy);
    if (0 != iGenMethod)
        fuzzy = iGenMethod;

    // Clear generation method so it won't rub off on the following phrase
    SetCurrentGenerate(GENERATE_METHOD_EXACT);

    XDbContentRestriction pRest( new CDbContentRestriction (wcsPhrase, *pps, fuzzy, _lcid));
    if( pRest.IsNull() || !pRest->IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    return pRest.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\memdeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemDeSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//
// The CMemSerStream and CDeMemSerStream have different requirements for
// handling buffer overflow conditions. In the case of the driver this
// is indicative of a corrupted stream and we would like to raise an
// exception. On the other hand in Query implementation we deal with
// streams whose sizes are precomputed in the user mode. Therefore we
// do not wish to incur any additional penalty in handling such situations.
// In debug builds this condition is asserted while in retail builds it is
// ignored. The CMemSerStream and CMemDeSerStream implementation are
// implemented using a macro HANDLE_OVERFLOW(fOverflow) which take the
// appropriate action.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "serover.hxx"

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif

BYTE CMemDeSerStream::GetByte()
{
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    BYTE b = *_pbCurrent;
    _pbCurrent += 1;
    return(b);
}

void CMemDeSerStream::SkipByte()
{
    _pbCurrent += 1;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetChar( char * pc, ULONG cc )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cc;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pc, pb, cc );
}

void CMemDeSerStream::SkipChar( ULONG cc )
{
    _pbCurrent += cc;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetWChar( WCHAR * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pwc, pwcTemp, cc * sizeof(WCHAR) );
}

void CMemDeSerStream::SkipWChar( ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

USHORT CMemDeSerStream::GetUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pus );
}

void CMemDeSerStream::SkipUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

ULONG CMemDeSerStream::GetULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pul );
}

void CMemDeSerStream::SkipULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

long CMemDeSerStream::GetLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pl );
}

void CMemDeSerStream::SkipLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

#if defined(KERNEL)     // Can not return floats in the kernel

ULONG CMemDeSerStream::GetFloat()
{
    ASSERT( sizeof(ULONG) == sizeof(float) );
    ULONG * pf = (ULONG *) AlignFloat(_pbCurrent);

#else

float CMemDeSerStream::GetFloat()
{
    float * pf = AlignFloat(_pbCurrent);

#endif

    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pf );
}

void CMemDeSerStream::SkipFloat()
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

#if defined(KERNEL)     // Can not return doubles in the kernel

LONGLONG CMemDeSerStream::GetDouble()
{
    ASSERT( sizeof(LONGLONG) == sizeof(double) );
    LONGLONG * pd = (LONGLONG *) AlignDouble(_pbCurrent);

#else

double CMemDeSerStream::GetDouble()
{
    double * pd = AlignDouble(_pbCurrent);

#endif

    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pd );
}

void CMemDeSerStream::SkipDouble()
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

ULONG CMemDeSerStream::PeekULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    HANDLE_OVERFLOW(((BYTE *)pul + sizeof(ULONG)) > _pbEnd);
    return( *pul );
}

char * CMemDeSerStream::GetString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    ULONG len = *pul;
    CHAR *pszTemp = (CHAR *)_pbCurrent;
    _pbCurrent += len;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    char * psz = new char[len+1];
    if (psz != NULL) {
        memcpy(psz, pszTemp, len);
        psz[len] = '\0';
        ASSERT(IsAnsiString(psz, len + 1));
    }

    return(psz);
}

WCHAR * CMemDeSerStream::GetWString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    ULONG len = *pul;
    WCHAR *pwszTemp = (WCHAR *)_pbCurrent;
    _pbCurrent += len * sizeof(WCHAR);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    WCHAR * pwsz = new WCHAR[len + 1];
    if (pwsz != NULL) {
        memcpy(pwsz, pwszTemp, len * sizeof(WCHAR) );
        pwsz[len] = L'\0';
        ASSERT(IsUnicodeString(pwsz, (len + 1) * sizeof(WCHAR)));
    }

    return(pwsz);
}

void CMemDeSerStream::GetBlob( BYTE * pb, ULONG cb )
{
    BYTE *pbTemp = _pbCurrent;
    _pbCurrent += cb;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pb, pbTemp, cb );
}

void CMemDeSerStream::SkipBlob( ULONG cb )
{
    _pbCurrent += cb;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetGUID( GUID & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    guid = *pguid;
}

void CMemDeSerStream::SkipGUID()
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\redist\h\iisext.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995-1997  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*      HTTP Server Extension interface used to build ISAPI Applications
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


/************************************************************
 *   Manifest Constants
 ************************************************************/

#define   HSE_VERSION_MAJOR           4      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

#define   HSE_VERSION     MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR )

//
// the following are the status codes returned by the Extension DLL
//

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

//
// The following are the values to request services with the
//   ServerSupportFunction().
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_SEND_URL_EX                      (HSE_REQ_END_RESERVED+4)
#define   HSE_REQ_IO_COMPLETION                    (HSE_REQ_END_RESERVED+5)
#define   HSE_REQ_TRANSMIT_FILE                    (HSE_REQ_END_RESERVED+6)
#define   HSE_REQ_REFRESH_ISAPI_ACL                (HSE_REQ_END_RESERVED+7)
#define   HSE_REQ_IS_KEEP_CONN                     (HSE_REQ_END_RESERVED+8)
#define   HSE_REQ_ASYNC_READ_CLIENT                (HSE_REQ_END_RESERVED+10)
#define   HSE_REQ_GET_IMPERSONATION_TOKEN          (HSE_REQ_END_RESERVED+11)
#define   HSE_REQ_MAP_URL_TO_PATH_EX               (HSE_REQ_END_RESERVED+12)
#define   HSE_REQ_ABORTIVE_CLOSE                   (HSE_REQ_END_RESERVED+14)
#define   HSE_REQ_GET_CERT_INFO_EX                 (HSE_REQ_END_RESERVED+15)
#define   HSE_REQ_SEND_RESPONSE_HEADER_EX          (HSE_REQ_END_RESERVED+16)

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// Flags for IO Functions, supported for IO Funcs.
//  TF means ServerSupportFunction( HSE_REQ_TRANSMIT_FILE)
//

# define HSE_IO_SYNC                      0x00000001   // for WriteClient
# define HSE_IO_ASYNC                     0x00000002   // for WriteClient/TF
# define HSE_IO_DISCONNECT_AFTER_SEND     0x00000004   // for TF
# define HSE_IO_SEND_HEADERS              0x00000008   // for TF


/************************************************************
 *   Type Definitions
 ************************************************************/

typedef   LPVOID          HCONN;

//
// structure passed to GetExtensionVersion()
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;


//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERRequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;




//
//  Bit field of flags that can be on a virtual directory
//

#define HSE_URL_FLAGS_READ          0x00000001    // Allow for Read
#define HSE_URL_FLAGS_WRITE         0x00000002    // Allow for Write
#define HSE_URL_FLAGS_EXECUTE       0x00000004    // Allow for Execute
#define HSE_URL_FLAGS_SSL           0x00000008    // Require SSL
#define HSE_URL_FLAGS_DONT_CACHE    0x00000010    // Don't cache (vroot only)
#define HSE_URL_FLAGS_NEGO_CERT     0x00000020    // Allow client SSL certs
#define HSE_URL_FLAGS_REQUIRE_CERT  0x00000040    // Require client SSL certs
#define HSE_URL_FLAGS_MAP_CERT      0x00000080    // Map SSL cert to NT account
#define HSE_URL_FLAGS_SSL128        0x00000100    // Require 128 bit SSL
#define HSE_URL_FLAGS_SCRIPT        0x00000200    // Allow for Script execution

#define HSE_URL_FLAGS_MASK          0x000003ff

//
//  Structure for extended information on a URL mapping
//

typedef struct _HSE_URL_MAPEX_INFO {

    CHAR   lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

    DWORD  dwReserved1;
    DWORD  dwReserved2;

} HSE_URL_MAPEX_INFO, * LPHSE_URL_MAPEX_INFO;



//
// PFN_HSE_IO_COMPLETION - callback function for the Async I/O Completion.
//

typedef VOID
  (WINAPI * PFN_HSE_IO_COMPLETION)(
                                   IN EXTENSION_CONTROL_BLOCK * pECB,
                                   IN PVOID    pContext,
                                   IN DWORD    cbIO,
                                   IN DWORD    dwError
                                   );



//
// HSE_TF_INFO defines the type for HTTP SERVER EXTENSION support for
//  ISAPI applications to send files using TransmitFile.
// A pointer to this object should be used with ServerSupportFunction()
//  for HSE_REQ_TRANSMIT_FILE.
//

typedef struct _HSE_TF_INFO  {

    //
    // callback and context information
    // the callback function will be called when IO is completed.
    // the context specified will be used during such callback.
    //
    // These values (if non-NULL) will override the one set by calling
    //  ServerSupportFunction() with HSE_REQ_IO_COMPLETION
    //
    PFN_HSE_IO_COMPLETION   pfnHseIO;
    PVOID  pContext;

    // file should have been opened with FILE_FLAG_SEQUENTIAL_SCAN
    HANDLE hFile;

    //
    // HTTP header and status code
    // These fields are used only if HSE_IO_SEND_HEADERS is present in dwFlags
    //

    LPCSTR pszStatusCode; // HTTP Status Code  eg: "200 OK"

    DWORD  BytesToWrite;  // special value of "0" means write entire file.
    DWORD  Offset;        // offset value within the file to start from

    PVOID  pHead;         // Head buffer to be sent before file data
    DWORD  HeadLength;    // header length
    PVOID  pTail;         // Tail buffer to be sent after file data
    DWORD  TailLength;    // tail length

    DWORD  dwFlags;       // includes HSE_IO_DISCONNECT_AFTER_SEND, ...

} HSE_TF_INFO, * LPHSE_TF_INFO;


//
//	HSE_SEND_HEADER_EX_INFO allows an ISAPI application to send headers
//	and specify keep-alive behavior in the same call.
//

typedef struct _HSE_SEND_HEADER_EX_INFO  {

    //
    // HTTP status code and header
    //

    LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
    LPCSTR  pszHeader;  // HTTP header

    DWORD   cchStatus;  // number of characters in status code
    DWORD   cchHeader;  // number of characters in header

    BOOL    fKeepConn;  // keep client connection alive?

} HSE_SEND_HEADER_EX_INFO, * LPHSE_SEND_HEADER_EX_INFO;


//
//	CERT_CONTEXT_EX is passed as an an argument to 
//  ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX )
//

typedef struct _CERT_CONTEXT_EX {
    CERT_CONTEXT    CertContext;
    DWORD           cbAllocated;
    DWORD           dwCertificateFlags;
} CERT_CONTEXT_EX;


/************************************************************
 *   Function Prototypes 
 *   o  for functions exported from the ISAPI Application DLL
 ************************************************************/

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for use in the server side

typedef BOOL
    (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );

typedef DWORD 
    (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK * pECB );

typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );


#ifdef __cplusplus
}
#endif


#endif  // end definition _HTTPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\coldesc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ColDesc.cxx
//
//  Contents:   Output column and sort column descriptors
//
//  History:    22-Jun-93 KyleP     Created
//              08 Mar 94 AlanW     Adapted for large tables
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CColumnSet 
//
//  Obsolete, bug can't delete without changing on-the-wire protocol.
//
//+-------------------------------------------------------------------------

inline void ReadOutputColumn(
    PROPID & Prop,
    PDeSerStream & stm,
    BOOL fAllBindingData
) {
    Prop = stm.GetULong();

    if (fAllBindingData)
    {
        //
        // The input stream has data for an obsolete CColumnOutputDesc.
        // Discard it.
        //

        ULONG dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = (VARTYPE)stm.GetULong();
    }
}

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CColumnSet and CSortSet
//
//+-------------------------------------------------------------------------

IMPL_DYNARRAY_INPLACE( CColumnSetBase, PROPID );

CColumnSet::CColumnSet(unsigned size)
        : CColumnSetBase( size )
{
}

void CColumnSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
    {
        stm.PutULong( Get(i) );
    }
}

CColumnSet::CColumnSet( PDeSerStream & stm, BOOL fAllBindingData )
        : CColumnSetBase( 0 )
{
    // Validate the count looks realistic.

    ULONG cInSet = stm.GetULong();

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
    {
        PROPID Prop;

        ReadOutputColumn( Prop, stm, fAllBindingData );

        Add( Prop, i);
    }
}

IMPL_DYNARRAY_INPLACE( CSortSetBase, SSortKey );

CSortSet::CSortSet(unsigned size)
        : CSortSetBase( size )
{
}

void CSortSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
    {
        stm.PutULong( Get(i).pidColumn );
        stm.PutULong( Get(i).dwOrder );
        stm.PutULong( Get(i).locale );
    }
}

CSortSet::CSortSet( PDeSerStream & stm )
        : CSortSetBase( 0 )
{
    ULONG cInSet = stm.GetULong();

    // Validate the count looks realistic.

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
    {
        SSortKey sk;
        sk.pidColumn = stm.GetULong();
        sk.dwOrder = stm.GetULong();

        Win4Assert( QUERY_SORTDESCEND == sk.dwOrder ||
                    QUERY_SORTASCEND == sk.dwOrder );

        if ( QUERY_SORTDESCEND != sk.dwOrder &&
             QUERY_SORTASCEND != sk.dwOrder )
            THROW( CException( E_ABORT ) );

        sk.locale = stm.GetULong();

        Add( sk, i);
    }
}

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CCategorizationSet
//
//+-------------------------------------------------------------------------

IMPL_DYNARRAY( CCategorizationSetBase, CCategorizationSpec );

CCategorizationSet::CCategorizationSet(unsigned size)
        : CCategorizationSetBase( size ),
          _cCat( 0 )
{
}

void CCategorizationSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
        Get(i)->Marshall( stm );
}

CCategorizationSet::CCategorizationSet( PDeSerStream & stm )
        : CCategorizationSetBase( 0 ),
          _cCat( 0 )
{
    ULONG cInSet = stm.GetULong();

    // Validate the count looks realistic.

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
        Add( new CCategorizationSpec( stm ), i);
}

CCategorizationSet::CCategorizationSet( CCategorizationSet const & rCateg )
        : CCategorizationSetBase( rCateg.Count() ),
          _cCat( 0 )
{
    // Validate the count looks realistic.

    if ( Size() >= 65536 )
        THROW( CException( E_INVALIDARG ) );

    for ( unsigned i = 0; i < Size(); i++ )
        Add( new CCategorizationSpec( *(rCateg.Get(i)) ), i);
}


void CCategorizationSpec::Marshall( PSerStream & stm ) const
{
    _csColumns.Marshall( stm );
    _xSpec->Marshall( stm );
} //Marshall

CCategorizationSpec::CCategorizationSpec( PDeSerStream &stm )
    : _csColumns( stm )
{
    unsigned type = stm.GetULong();

    if (CATEGORIZE_UNIQUE == type)
        _xSpec.Set( new CUniqueCategSpec( stm ) );
    else if (CATEGORIZE_BUCKETS == type)
        _xSpec.Set( new CBucketCategSpec( stm ) );
    else if (CATEGORIZE_RANGE == type)
        _xSpec.Set( new CRangeCategSpec( stm ) );
    else
        THROW( CException( E_INVALIDARG ) );
} //CCategorizationSpec

CCategorizationSpec::CCategorizationSpec( CCategorizationSpec const & rCatSpec )
    : _csColumns( rCatSpec.GetColumnSet().Count() )
{
    for ( unsigned i = 0; i < _csColumns.Size(); i++ )
        _csColumns.Add( rCatSpec._csColumns.Get(i), i);

    unsigned type = rCatSpec.Type();

    if (CATEGORIZE_UNIQUE == type)
        _xSpec.Set( new CUniqueCategSpec( rCatSpec.GetCategSpec() ) );
    else if (CATEGORIZE_BUCKETS == type)
        _xSpec.Set( new CBucketCategSpec( rCatSpec.GetCategSpec() ) );
    else if (CATEGORIZE_RANGE == type)
        _xSpec.Set( new CRangeCategSpec( rCatSpec.GetCategSpec() ) );
    else
        THROW( CException( E_INVALIDARG ) );
} //CCategorizationSpec
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\irest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       IRest.cxx
//
//  Contents:   Internal (non-public) restrictions.
//
//  Classes:    CInternalPropertyRestriction
//              COccRestriction
//              CWordRestriction
//              CSynRestriction
//              CRangeRestriction
//              CUnfilteredRestriction
//              CScopeRestriction
//              CPhraseRestriction
//
//  History:    19-Sep-91   BartoszM    Implemented.
//              29-Aug-92   MikeHew     Added serialization routines
//              30-Nov-92   KyleP       Removed CPhraseXpr
//              14-Jan-93   KyleP       Converted from expressions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vkrep.hxx>
#include <norm.hxx>
#include <compare.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   UnMarshallWideString
//
//  Synopsis:   Unmarshalls a wide string into a CoTaskMemAlloc'ed buffer.
//              This can't be in memdeser since it calls CoTaskMemAlloc,
//              which isn't available in ntdll.dll.
//
//  Arguments:  [stm]   -- stream from which string is deserialized
//
//  History:    22-Nov-95 dlee     Created from a few copies
//
//--------------------------------------------------------------------------

WCHAR * UnMarshallWideString( PDeSerStream & stm )
{
    ULONG cc = stm.GetULong();

    // Protect against attack.  We know our named pipes are < 64k

    if ( cc >= ( 65536 / sizeof WCHAR ) )
        return 0;

    XCoMem<WCHAR> xString( (WCHAR *) CoTaskMemAlloc( (cc + 1) * sizeof WCHAR ) );

    if ( xString.IsNull() )
    {
        // just eat the string

        WCHAR wc[10];

        while ( cc > 0 )
        {
            if ( cc >= 10 )
            {
                stm.GetWChar( wc, 10 );
                cc -= 10;
            }
            else
            {
                stm.GetWChar( wc, cc );
                cc = 0;
            }
        }
    }
    else
    {
        WCHAR * pwc = xString.GetPointer();
        stm.GetWChar( pwc, cc );
        pwc[cc] = 0;
    }

    return xString.Acquire();
} //UnMarshallWideString

WCHAR * UnMarshallWideStringNew( PDeSerStream & stm )
{
    ULONG cc = stm.GetULong();

    // Protect against attack.  We know our named pipes are < 64k

    if ( cc >= ( 65536 / sizeof WCHAR ) )
        THROW( CException( E_INVALIDARG ) );

    XArray<WCHAR> xString( cc + 1 );

    stm.GetWChar( xString.GetPointer(), cc );
    xString[cc] = 0;

    return xString.Acquire();
} //UnMarshallWideStringNew

//+-------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::CInternalPropertyRestriction
//
//  Synopsis:   Creates property restriction
//
//  Arguments:  [relop] -- Relational operator (<, >, etc.)
//              [pid]   -- Property id
//              [prval] -- Property value
//              [pcrst] -- 'Helper' content restriction
//
//  History:    07-Mar-93 KyleP     Created
//
//--------------------------------------------------------------------------

CInternalPropertyRestriction::CInternalPropertyRestriction( ULONG relop,
                                                            PROPID pid,
                                                            CStorageVariant const & prval,
                                                            CRestriction * pcrst )
        : CRestriction( RTInternalProp, MAX_QUERY_RANK ),
          _relop( relop ),
          _pid( pid ),
          _prval( prval ),
          _pcrst( pcrst )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::CInternalPropertyRestriction
//
//  Synopsis:   Copy constructor
//
//  History:    30-May-95   SitaramR    Created.
//
//----------------------------------------------------------------------------

CInternalPropertyRestriction::CInternalPropertyRestriction(
    CInternalPropertyRestriction const & intPropRst )
    : CRestriction( RTInternalProp, intPropRst.Weight() ),
      _relop( intPropRst.Relation() ),
      _pid( intPropRst.Pid() ),
      _prval( intPropRst.Value() ),
      _pcrst( 0 )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    CRestriction *pHelperRst = intPropRst.GetContentHelper();

    if ( pHelperRst )
        _pcrst  = pHelperRst->Clone();
}




//+-------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::~CInternalPropertyRestriction
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CInternalPropertyRestriction::~CInternalPropertyRestriction()
{
    delete _pcrst;

    SetType( RTNone );                  // Avoid recursion.
}

void CInternalPropertyRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _relop );
    stm.PutULong( _pid );
    _prval.Marshall( stm );

    if ( 0 == _pcrst )
        stm.PutByte( 0 );
    else
    {
        stm.PutByte( 1 );
        _pcrst->Marshall( stm );
    }
}

CInternalPropertyRestriction::CInternalPropertyRestriction( ULONG ulWeight,
                                                            PDeSerStream & stm )
        : CRestriction( RTInternalProp, ulWeight ),
          _relop( stm.GetULong() ),
          _pid( stm.GetULong() ),
          _prval( stm )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    BYTE fRst = stm.GetByte();

    if ( fRst )
        _pcrst = CRestriction::UnMarshall( stm );
    else
        _pcrst = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::Clone, public
//
//  Synopsis:   Clones an internal property restriction
//
//  History:    30-May-95   SitaramR    Created.
//
//----------------------------------------------------------------------------

CInternalPropertyRestriction *CInternalPropertyRestriction::Clone() const
{
    return new CInternalPropertyRestriction( *this );
}

//+---------------------------------------------------------------------------
//
//  Member:     COccRestriction::COccRestriction, public
//
//  Synopsis:   Creates occurrence restriction
//
//  Arguments:  [ulType]  -- type of restriction
//              [ulWeight] -- weight
//              [occ] -- occurrence
//              [cPrevNoiseWords] -- count of previous noise words skipped
//              [cPostNoiseWords] -- count of post noise words skipped
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

COccRestriction::COccRestriction( ULONG ulType, ULONG ulWeight, OCCURRENCE occ,
                                  ULONG cPrevNoiseWords, ULONG cPostNoiseWords )
            : CRestriction( ulType, ulWeight ),
              _occ( occ ),
              _cPrevNoiseWords( cPrevNoiseWords),
              _cPostNoiseWords( cPostNoiseWords )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::~COccRestriction, public
//
//  Synopsis:   Cleanup occurrence restriction
//
//  Notes:      This destructor simulates virtual destruction.
//
//              Classes derived from COccRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction::~COccRestriction()
{
    switch ( Type() )
    {
    case RTNone:
        break;

    case RTWord:
        ((CWordRestriction *)this)->CWordRestriction::~CWordRestriction();
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->CSynRestriction::~CSynRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL COccRestriction::IsValid() const
{
    BOOL fValid = TRUE;

    switch ( Type() )
    {
    case RTWord:
        fValid = ((CWordRestriction *)this)->CWordRestriction::IsValid();
        break;

    case RTSynonym:
        fValid = ((CSynRestriction *)this)->CSynRestriction::IsValid();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        fValid = FALSE;
        break;
    }

    return fValid;
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::Marshall, public
//
//  Synopsis:   Serialize occurrence restriction
//
//  Arguments:  [stm] -- stream to serialize to
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

void COccRestriction::Marshall( PSerStream& stm ) const
{
    stm.PutULong( _occ );
    stm.PutULong( _cPrevNoiseWords );
    stm.PutULong( _cPostNoiseWords );
    switch ( Type() )
    {
    case RTWord:
        ((CWordRestriction *)this)->Marshall( stm );
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->Marshall( stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        break;

    }
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::COccRestriction, public
//
//  Synopsis:   De-serialize occurrence restriction
//
//  Arguments:  [ulType] -- type of occurrence restriction
//              [ulWeight] -- weight of occurrence restriction
//              [stm] -- stream to serialize from
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction::COccRestriction( ULONG ulType, ULONG ulWeight, PDeSerStream& stm )
        : CRestriction( ulType, ulWeight )
{
    _occ = stm.GetULong();
    _cPrevNoiseWords = stm.GetULong();
    _cPostNoiseWords = stm.GetULong();
}




//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::Clone, public
//
//  Synopsis:   Clone occurrence restriction
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction *COccRestriction::Clone() const
{
    switch ( Type() )
    {
    case RTWord:
        return ((CWordRestriction *)this)->Clone();
        break;

    case RTSynonym:
        return ((CSynRestriction *)this)->Clone();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        return 0;
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::CWordRestriction, public
//
//  Synopsis:   Creates word expression
//
//  Arguments:  [keyBuf]  -- key to be matched
//              [occ]     -- occurrence (if in phrase)
//              [isRange] -- TRUE if key is a prefix
//
//  History:    19-Sep-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

CWordRestriction::CWordRestriction ( const CKeyBuf& keyBuf,
                                     OCCURRENCE occ,
                                     ULONG cPrevNoiseWords,
                                     ULONG cPostNoiseWords,
                                     BOOL isRange )
        : COccRestriction( RTWord, MAX_QUERY_RANK, occ, cPrevNoiseWords, cPostNoiseWords ),
          _isRange(isRange)
{
    // copy after init to 0 in case new fails and ~CWordRestriction is
    // called from ~CRestriction

    _key = keyBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::CWordRestriction, public
//
//  Synopsis:   Copy constuctor
//
//  Arguments:  [wordRst]  -- word restriction to be copied
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CWordRestriction::CWordRestriction( const CWordRestriction& wordRst )
    : COccRestriction( RTWord, wordRst.Weight(), wordRst.Occurrence(),
                       wordRst.CountPrevNoiseWords(), wordRst.CountPostNoiseWords() ),
      _isRange( wordRst.IsRange() )
{
    // copy after init to 0 in case new fails and ~CWordRestriction is
    // called from ~CRestriction

    _key = *wordRst.GetKey();
}




//+-------------------------------------------------------------------------
//
//  Member:     CWordRestriction::~CWordRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWordRestriction::~CWordRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CWordRestriction::Marshall( PSerStream & stm ) const
{
    _key.Marshall( stm );
    stm.PutByte( (BYTE)_isRange );
}

CWordRestriction::CWordRestriction( ULONG ulWeight, PDeSerStream & stm )
        : COccRestriction( RTWord, ulWeight, stm ),
          _key( stm ),
          _isRange( stm.GetByte() )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::Clone, public
//
//  Synopsis:   Clone restriction
//
//  History:    29-Nov-94   SitaramR   Created.
//
//----------------------------------------------------------------------------

CWordRestriction *CWordRestriction::Clone()  const
{
    return new CWordRestriction( *this );
}



//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::CSynRestriction, public
//
//  Synopsis:   Creates Syn expression
//
//  Arguments:  [occ] -- occurrence (if in phrase)
//              [isRange] -- is it range?
//
//  History:    07-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

const int cSynonyms = 2; // default initial count of synonyms

CSynRestriction::CSynRestriction ( const CKey& key,
                                   OCCURRENCE occ,
                                   ULONG cPrevNoiseWords,
                                   ULONG cPostNoiseWords,
                                   BOOL isRange )
        : COccRestriction( RTNone, MAX_QUERY_RANK, occ, cPrevNoiseWords, cPostNoiseWords ),
          _keyArray( cSynonyms, TRUE ),
          _isRange(isRange)
{
    _keyArray.Add ( key );
    SetType( RTSynonym );
}




//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::CSynRestriction, public
//
//  Synopsis:   Copy constuctor
//
//  Arguments:  [synRst]  -- synonym restriction to be copied
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CSynRestriction::CSynRestriction( CSynRestriction& synRst )
    : COccRestriction( RTNone, synRst.Weight(), synRst.Occurrence(),
                       synRst.CountPrevNoiseWords(), synRst.CountPostNoiseWords() ),
      _keyArray( synRst.GetKeys(), TRUE ),
      _isRange( synRst.IsRange() )
{
    SetType( RTSynonym );
}



//+-------------------------------------------------------------------------
//
//  Member:     CSynRestriction::~CSynRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CSynRestriction::~CSynRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CSynRestriction::Marshall( PSerStream & stm ) const
{
    _keyArray.Marshall( stm );
    stm.PutByte( (BYTE)_isRange );
}

CSynRestriction::CSynRestriction( ULONG ulWeight, PDeSerStream & stm )
        : COccRestriction( RTNone, ulWeight, stm),
          _keyArray( stm, TRUE ),
          _isRange( stm.GetByte() )
{
    SetType( RTSynonym );
}



//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::Clone, public
//
//  Synopsis:   Clone restriction
//
//  History:    29-Nov-94   SitaramR   Created.
//
//----------------------------------------------------------------------------

CSynRestriction *CSynRestriction::Clone() const
{
    return new CSynRestriction( *(CSynRestriction *)this );
}




//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::AddKey, public
//
//  Synopsis:   Adds synonym key
//
//  Arguments:  [keyBuf] -- key
//
//  History:    07-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CSynRestriction::AddKey ( const CKeyBuf& Key )
{
    _keyArray.Add ( Key );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::CRangeRestriction, public
//
//  Synopsis:   Creates word expression
//
//  Arguments:  [pid] -- property id
//              [keyStart] -- starting key
//              [keyEnd] -- ending key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

CRangeRestriction::CRangeRestriction()
        : CRestriction( RTRange, MAX_QUERY_RANK )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::CRangeRestriction
//
//  Synopsis:   Copy constructor
//
//  History:    30-May-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CRangeRestriction::CRangeRestriction( const CRangeRestriction& rangeRst )
    : CRestriction( RTNone, rangeRst.Weight() )
{
    const CKey *pKeyStart = rangeRst.GetStartKey();

    if ( pKeyStart )
        _keyStart = *pKeyStart;

    const CKey *pKeyEnd = rangeRst.GetEndKey();

    if ( pKeyEnd )
        _keyEnd = *pKeyEnd;

    SetType( RTRange );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::~CRangeRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CRangeRestriction::~CRangeRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CRangeRestriction::Marshall( PSerStream & stm ) const
{
    _keyStart.Marshall( stm );
    _keyEnd.Marshall( stm );
}

CRangeRestriction::CRangeRestriction( ULONG ulWeight, PDeSerStream & stm )
        : CRestriction( RTNone, ulWeight ),
          _keyStart( stm ),
          _keyEnd( stm )
{
    SetType( RTRange );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::SetStartKey, public
//
//  Arguments:  [keyStart] -- starting key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeRestriction::SetStartKey ( const CKeyBuf& keyStart )
{
    _keyStart = keyStart;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::SetEndKey, public
//
//  Arguments:  [keyEnd] -- Ending key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeRestriction::SetEndKey ( const CKeyBuf& keyEnd )
{
    _keyEnd = keyEnd;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::Clone
//
//  Synopsis:   Clones a range restriction
//
//  History:    30-May-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CRangeRestriction *CRangeRestriction::Clone() const
{
    return new CRangeRestriction( *this );
}




//+---------------------------------------------------------------------------
//
//  Member:     CUnfilteredRestriction::CUnfilteredRestriction, public
//
//  History:    10-Nov-94   KyleP       Created.
//
//  Notes:      This restriction is just a very special case of range
//              restriction that searches only for a particular value.
//              Standard procedure to create a range restriction is
//              sidetracked to save code.
//
//----------------------------------------------------------------------------

CUnfilteredRestriction::CUnfilteredRestriction()
{
    static const BYTE abUnfiltered[] = { VT_UI1,
                                  (BYTE)(pidUnfiltered >> 24),
                                  (BYTE)(pidUnfiltered >> 16),
                                  (BYTE)(pidUnfiltered >> 8),
                                  (BYTE) pidUnfiltered,
                                  0,
                                  1 };

    static CKeyBuf keyUnfilteredRange( pidUnfiltered, abUnfiltered, sizeof(abUnfiltered) );

    SetStartKey( keyUnfilteredRange );
    SetEndKey( keyUnfilteredRange );

#if DBG == 1 && CIDBG == 1
    CRangeKeyRepository krep;
    CValueNormalizer norm( krep );
    OCCURRENCE occ = 1;
    CStorageVariant var;
    var.SetBOOL( (VARIANT_BOOL)0xFFFF );

    norm.PutValue( pidUnfiltered, occ, var );
    norm.PutValue( pidUnfiltered, occ, var );

    CRestriction * prst = krep.AcqRst();

    Win4Assert( prst->Type() == RTRange );

    CRangeRestriction * pRange = (CRangeRestriction *)prst;

    Win4Assert( pRange->GetStartKey()->Compare( *GetStartKey() ) == 0 );
    Win4Assert( pRange->GetEndKey()->Compare( *GetEndKey() ) == 0 );

    delete prst;
#endif
}



//+---------------------------------------------------------------------------
//
//  Member:     CPhraseRestriction::CPhraseRestriction, public
//
//  Synopsis:   Deserializes phrase restriction
//
//  Arguments:  [ulWeight]  -- restriction weight
//              [stm] -- stream to deserialize from
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CPhraseRestriction::CPhraseRestriction( ULONG ulWeight, PDeSerStream& stm )
        : CNodeRestriction( RTPhrase, ulWeight, stm  )
{
#if CIDBG == 1
    for ( unsigned i = 0; i < _cNode; i++ )
        Win4Assert( _paNode[i]->Type() == RTWord || _paNode[i]->Type() == RTSynonym );
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseRestriction::~CPhraseRestriction, public
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CPhraseRestriction::~CPhraseRestriction()
{
    if ( 0 != _paNode )
    {
        for ( unsigned i = 0; i < _cNode; i++ )
        {
            #if CIDBG == 1
                if ( 0 != _paNode[i] )
                {
                    Win4Assert( _paNode[i]->Type() == RTWord ||
                                _paNode[i]->Type() == RTSynonym );
                }
            #endif // CIDBG

            delete (COccRestriction *) _paNode[i];
        }

        delete [] _paNode;
    }

    SetType( RTNone );                  // Avoid recursion.
}


CScopeRestriction::CScopeRestriction( WCHAR const * pwcsPath, BOOL fRecursive, BOOL fVirtual )
        : CRestriction( RTScope, MAX_QUERY_RANK ),
          _fValid( FALSE ),
          _fRecursive( fRecursive ),
          _fVirtual( fVirtual )
{
    SetPath( pwcsPath );
}

CScopeRestriction * CScopeRestriction::Clone() const
{
    return( new CScopeRestriction( _lowerFunnyPath.GetActualPath(), _fRecursive, _fVirtual ) );
}

CScopeRestriction::~CScopeRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CScopeRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutWString( _lowerFunnyPath.GetActualPath() );
    stm.PutULong( _lowerFunnyPath.GetActualLength() );
    stm.PutULong( _fRecursive );
    stm.PutULong( _fVirtual );
}

CScopeRestriction::CScopeRestriction( ULONG ulWeight, PDeSerStream & stm )
        : CRestriction( RTScope, ulWeight ),
          _fValid( FALSE )
{
    XCoMem<WCHAR> xString( UnMarshallWideString( stm ) );

    //
    // Simple validity checks; not all-inclusive.  Just
    // return with _fValid set to FALSE and the query
    // will fail with an out of memory error.
    //

    // We don't support long paths for scopes.

    if ( wcslen( xString.GetPointer() ) >= MAX_PATH )
        return;

    // We don't support the NTFS special stream syntax

    if ( 0 != wcsstr( xString.GetPointer(), L"::$" ) )
        return;

    stm.GetULong(); // length not needed

    _fRecursive = stm.GetULong();
    _fVirtual = stm.GetULong();
    _lowerFunnyPath.SetPath( xString.Acquire() );
    _fValid = TRUE; // since we have a valid path
}

CScopeRestriction & CScopeRestriction::operator =(
    CScopeRestriction const & source )
{
    _lowerFunnyPath = source._lowerFunnyPath;
    _fRecursive = source._fRecursive;
    _fVirtual = source._fVirtual;
    _fValid = source._fValid;

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CScopeRestriction::SetPath
//
//  Synopsis:   Validates and sets a path in a scope restriction
//
//  History:    24-Oct-96   dlee    Created.
//
//----------------------------------------------------------------------------

void CScopeRestriction::SetPath( WCHAR const * pwcsPath )
{
    _fValid = FALSE;

    //
    // Simple validity checks; not all-inclusive.  Just
    // return with _fValid set to FALSE and the query
    // wil fail with an out of memory error.
    //

    // We don't support long paths for scopes.

    if ( wcslen( pwcsPath ) >= MAX_PATH )
        return;

    // We don't support the NTFS special stream syntax

    if ( 0 != wcsstr( pwcsPath, L"::$" ) )
        return;

    _lowerFunnyPath.Truncate(0);
    if ( pwcsPath)
    {
        _lowerFunnyPath.SetPath( pwcsPath );
        _fValid = TRUE;
    }
} //SetPath

//+---------------------------------------------------------------------------
//
//  Function:   ValidateScopeRestriction
//
//  Synopsis:   Verifies a scope restriction looks ok.  Can't use
//              CRestriction::IsValid since this needs to make sure there
//              aren't any odd nodes in the tree (like proximity, etc.)
//
//  Returns:    TRUE if it is ok, FALSE otherwise
//
//  History:    24-Oct-96   dlee    Created.
//
//----------------------------------------------------------------------------

BOOL ValidateScopeRestriction( CRestriction * pRst )
{
    if ( 0 == pRst )
        return FALSE;

    switch ( pRst->Type() )
    {
#if 0 // someday we might support exclusion scopes
        case RTNot:
        {
            CRestriction *p = ((CNotRestriction *)pRst)->GetChild();
            return ValidateScopeRestriction( p );
            break;
        }
        case RTAnd:
#endif // 0 // exclusion scopes
        case RTOr:
        {
            CNodeRestriction * p = pRst->CastToNode();
            for ( ULONG x = 0; x < p->Count(); x++ )
            {
                if ( !ValidateScopeRestriction( p->GetChild( x ) ) )
                    return FALSE;
            }
            break;
        }
        case RTScope:
        {
            CScopeRestriction *p = (CScopeRestriction *) pRst;
            if ( !p->IsValid() )
                return FALSE;
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return TRUE;
} //ValidateScopeRestriction

#if CIDBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DisplayChar
//
//  Synopsis:   Debug print the non-ascii text buffer
//
//  Arguments:  [pwString] -- Pointer to string (not null terminated)
//              [cString]  -- len of the string in char
//              [infolevel] --
//
//  History:    22-Apr-98   KitmanH      Created
//
//--------------------------------------------------------------------------

void DisplayChar( WCHAR * pwString, DWORD cString, ULONG infolevel )
{

    BOOL fOk = TRUE;
    for ( unsigned i = 0; i < cString; i++ )
    {
        if ( pwString[i] > 0xFF )
        {
            fOk = FALSE;
            break;
        }
    }

    if ( fOk )
    {
        unsigned j = 0;
        WCHAR awcTemp[71];

        for ( unsigned i = 0; i < cString; i++ )
        {
            awcTemp[j] = pwString[i];
            j++;

            if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
            {
                awcTemp[j] = 0;
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\"%ws\"", awcTemp ));
                j = 0;
            }
        }

        awcTemp[j] = 0;
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\"%ws\"", awcTemp ));
    }
    else
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "0x" ));

        unsigned j = 0;

        for ( unsigned i = 0; i < cString; i++ )
        {
            if ( 0 == j )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "%04X", pwString[i] ));
            else if ( 14 == j )
            {
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, " %04X\n", pwString[i] ));
            }
            else
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, " %04X", pwString[i] ));

            j++;

            if ( j > 14 )
                j = 0;
        }

    }

}

void Display( CRestriction * pRst, int indent, ULONG infolevel )
{
    vqDebugOut(( infolevel, "    " ));

    for ( int i = 0; i < indent; i++ )
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "    " ));
    }

    switch ( pRst->Type() )
    {
    case RTContent:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     "CONTENT: \"%ws\", LOCALE: %lu\n",
                     ((CContentRestriction *)pRst)->GetPhrase(),
                     ((CContentRestriction *)pRst)->GetLocale() ));
        break;

    case RTNatLanguage:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     "NATURAL LANGUAGE: \"%ws\", LOCALE: %lu\n",
                     ((CNatLanguageRestriction *)pRst)->GetPhrase(),
                     ((CNatLanguageRestriction *)pRst)->GetLocale() ));
        break;

    case RTWord:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "WORD%s: ",
                     ((CWordRestriction *)pRst)->IsRange() ? " PREFIX" : "" ));
        DisplayChar( ((CWordRestriction *)pRst)->GetKey()->GetStr(),
                     ((CWordRestriction *)pRst)->GetKey()->StrLen(),
                     infolevel
                   );

        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     " PID %d OCC %d, WEIGHT %d\n",
                     ((CWordRestriction *)pRst)->Pid(),
                     ((CWordRestriction *)pRst)->Occurrence(),
                     ((CWordRestriction *)pRst)->Weight() ));
        break;

    case RTSynonym:
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "SYNONYM: OCC %d ",
                     ((CSynRestriction *)pRst)->Occurrence() ));
        CKeyArray & keys = ((CSynRestriction *)pRst)->GetKeys();

        for ( int i = 0; i < keys.Count(); i++ )
        {
            DisplayChar( keys.Get(i).GetStr(), keys.Get(i).StrLen(),
                         infolevel );
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, " " ));
        }
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;
    }

    case RTRange:
    {
        CRangeRestriction * pr = (CRangeRestriction *)pRst;

        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "RANGE: " ));

        char * pc = new char[pr->GetStartKey()->Count() * 2 +
                                            1 +
                                            pr->GetEndKey()->Count() * 2 +
                                            2];

        for ( unsigned i = 0; i < pr->GetStartKey()->Count(); i++ )
            sprintf( pc + i*2, "%02x", pr->GetStartKey()->GetBuf()[i] );

        pc[i*2] = '-';

        for ( unsigned j = 0; j < pr->GetEndKey()->Count(); j++ )
            sprintf( pc + i*2 + 1 + j*2, "%02x", pr->GetEndKey()->GetBuf()[j] );

        pc[i*2 + 1 + j*2] = '\n';
        pc[i*2 + 1 + j*2 + 1] = 0;
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, pc ));
        delete [] pc;
        break;
    }

    case RTProperty:
        if ( ((CPropertyRestriction *)pRst)->Relation() == PRRE )
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "REGEX " ));
        else
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROPERTY " ));

        ((CPropertyRestriction *) pRst)->Value().DisplayVariant(
                                                    infolevel | DEB_NOCOMPNAME,
                                                    0);
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;

    case RTInternalProp:
    {
        CInternalPropertyRestriction * pir = (CInternalPropertyRestriction *)pRst;

        if ( pir->Relation() == PRRE )
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "REGEX pid(0x%lx) ",
                         pir->Pid() ));
        else
        {
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROPERTY pid(0x%lx) ", pir->Pid() ));
            switch ( getBaseRelop( pir->Relation() ) )
            {
            case PRLT:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "< " ));
                break;

            case PRLE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "<= " ));
                break;

            case PRGT:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "> " ));
                break;

            case PRGE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, ">= " ));
                break;

            case PREQ:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "== " ));
                break;

            case PRNE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "!= " ));
                break;

            case PRAllBits:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "All bits " ));
                break;

            case PRSomeBits:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "Some bits " ));
                break;

            default:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "??? " ));
                break;
            }

            if ( pir->Relation() & PRAll )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "All " ));
            else if ( pir->Relation() & PRAny )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "Any " ));

        }

        pir->Value().DisplayVariant(infolevel | DEB_NOCOMPNAME, 0);

        if ( pir->GetContentHelper() )
        {
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));

            for ( int i = 0; i < indent+5; i++ )
            {
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "    " ));
            }
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "HELPER:\n" ));
            Display( pir->GetContentHelper(), indent+3, infolevel );
        }
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;
    }

    case RTNot:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NOT\n" ));
        Display( ((CNotRestriction *)pRst)->GetChild(), indent + 1, infolevel );
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:
    {
        switch( pRst->Type() )
        {
        case RTAnd:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "AND\n" ));
            break;

        case RTOr:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "OR\n" ));
            break;

        case RTNot:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NOT\n" ));
            break;

        case RTProximity:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROXIMITY\n" ));
            break;

        case RTVector:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "VECTOR " ));
            switch ( ((CVectorRestriction *)pRst)->RankMethod() )
            {
            case VECTOR_RANK_MIN:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Min)\n" ));
                break;

            case VECTOR_RANK_MAX:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Max)\n" ));
                break;

            case VECTOR_RANK_INNER:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Inner Product)\n" ));
                break;

            case VECTOR_RANK_DICE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Dice Coefficient)\n" ));
                break;

            case VECTOR_RANK_JACCARD:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Jaccard Coefficient)\n" ));
                break;

            default:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(???)\n" ));
                break;
            }
            break;

        case RTPhrase:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PHRASE\n" ));
            break;
        }

        CNodeRestriction * pNodeRst = pRst->CastToNode();

        for ( UINT i = 0; i < pNodeRst->Count(); i++ )
        {
            Display( pNodeRst->GetChild( i ), indent + 1, infolevel );
        }
        break;
    }

    case RTNone:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NONE -- empty\n" ));
        break;

    default:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "UNKNOWN\n" ));
        break;

    }
}

#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\norm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       NORM.CXX
//
//  Contents:   Normalizer
//
//  Classes:    CNormalizer
//
//  History:    28-May-91   t-WadeR     added CNormalizer
//              31-Jan-92   BartoszM    Created from lang.cxx
//              07-Oct-93   DwightKr    Added new methods to normalize
//                                      different data types
//
//  Notes:      The filtering pipeline is hidden in the Data Repository
//              object which serves as a sink for the filter.
//              The sink for the Data Repository is the Key Repository.
//              The language dependent part of the pipeline
//              is obtained from the Language List object and is called
//              Key Maker. It consists of:
//
//                  Word Breaker
//                  Stemmer (optional)
//                  Normalizer
//                  Noise List
//
//              Each object serves as a sink for its predecessor,
//              Key Repository is the final sink.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <plang.hxx>
#include <misc.hxx>
#include <norm.hxx>

//+---------------------------------------------------------------------------
//
//  Function    GetExpAndSign
//
//  Synopsis:   Finds the exponent and sign of a number
//
//  Arguments:  [d]          -- the input number to examine
//              [fPositive]  -- returns TRUE if positive, FALSE if negative
//
//  Returns:    The exponent
//
//  History:    21-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

int GetExpAndSign( double d, BOOL & fPositive )
{
    //
    // bit 63       = sign
    // bits 52 - 62 = exponent
    // bits 0 - 51  = mantissa
    //

    Win4Assert( sizeof(LARGE_INTEGER) == sizeof(double) );

    LARGE_INTEGER * pli = (LARGE_INTEGER *)&d;

    fPositive = (pli->HighPart & 0x80000000) == 0;

    int const bias = 0x3ff;

    return ( ( pli->HighPart & 0x7ff00000 ) >> 20 ) - bias;
} //GetExpAndSign

//+---------------------------------------------------------------------------
//
//  Function    NormDouble
//
//  Synopsis:   Normalizes doubles by taking log2 of the number
//
//  Notes:      This func converts doubles into one of 5 different categories
//
//              x < -1x2**32                 is in bin 0
//              -1x2**32  <= x <= -1x2**-32  are in bins 1 to 65
//              -1x2**-32 <= x <=  1x2**-32  is in bin 66
//               1x2**-32 <= x <=  1x2**32   are in bins 67 to 131
//               x > 1x2**32                 is bin bin 132
//
//  History:    21-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

static unsigned NormDouble(double dValue)
{
    const int SignificantExponent = 32;
    const int SignificantRange = SignificantExponent * 2;

    const unsigned LowestBin  = 0;                                // 0
    const unsigned LowerBin   = LowestBin + 1;                    // 1
    const unsigned MiddleBin  = LowerBin + SignificantRange + 1;  // 66
    const unsigned UpperBin   = MiddleBin + 1;                    // 67
    const unsigned HighestBin = UpperBin+ SignificantRange + 1;   // 132


    BOOL fPositive;

    int exp = GetExpAndSign( dValue, fPositive );

    unsigned bin;

    if ( exp < -SignificantExponent )
    {
        //
        // All numbers close to zero in middle bin
        //

        bin = MiddleBin;
    }
    else if ( exp > SignificantExponent )
    {
        if ( fPositive )
        {
            //
            // Very large positive numbers in top bin
            //

            bin = HighestBin;
        }
        else
        {
            //
            // Very large negative numbers in bottom bin
            //

            bin = LowestBin;
        }
    }
    else
    {
        if ( fPositive )
        {
            //
            // medium size positive numbers
            //

            bin = UpperBin + exp + SignificantExponent;
        }
        else
        {
            //
            // medium size negative numbers
            //

            bin = LowerBin - exp + SignificantExponent;
        }
    }
    return bin;
}

#ifdef  TEST_NORM
//
// a test to verify the validity of the NormDouble function.
//
void TestNormDouble()
{
    float fVal0 = 0.;
    float fVal1 = 1.;
    unsigned nZero = NormDouble( fVal0 );
    unsigned nOne = NormDouble( fVal1 );

    printf(" Value:Bin %f : 0x%4X (%d)\n", fVal0, nZero, nZero );
    printf(" Value:Bin %f : 0x%4X (%d)\n", fVal1, nOne, nOne );

    BOOL fPos;
    float f = fVal1;
    unsigned nPrev = nOne;
    while ( f > fVal0 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal > nPrev || nVal < nZero || nVal > nOne)
        {
            printf(" Value:Bin %f : 0x%4X (%d)\tExp %d\n", f, nVal, nVal, GetExpAndSign(f, fPos) );
        }

        nPrev = nVal;
        f = f/3;
    }

    f = fVal1;
    nPrev = nOne;
    while ( f < 1e+32 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal < nPrev)
            printf(" Value:Bin %f : 0x%4X (%d)\n", f, nVal, nVal );

        nPrev = nVal;
        f = f * (float)1.5;
    }

    float fValm1 = -1.;
    unsigned nMinusOne = NormDouble( fValm1 );

    printf(" Value:Bin %f : 0x%4X (%d)\n", fValm1, nMinusOne, nMinusOne );

    f = fValm1;
    nPrev = nMinusOne;
    while ( f < fVal0 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal < nPrev || nVal > nZero || nVal < nMinusOne)
            printf(" Value:Bin %f : 0x%4X (%d)\tExp %d\n", f, nVal, nVal, GetExpAndSign(f, fPos) );

        nPrev = nVal;
        f = f/3;
    }

    f = fValm1;
    nPrev = nMinusOne;
    while ( f > -1e+32 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal > nPrev)
            printf(" Value:Bin %f : 0x%4X (%d)\n", f, nVal, nVal );

        nPrev = nVal;
        f = f * (float)1.5;
    }
}
#endif  // 0


// ------------------------------------------------------------------------
// | Upper Limit  |  Divisor (2^x) | # of Bins        | (in hex)          |
// ------------------------------------------------------------------------
// | 2^10 - 1     |   2^0          | 2^10  - 0        | 0400 - 0000       |
// | 2^16 - 1     |   2^3          | 2^12  - 2^7      | 2000 - 0080       |
// | 2^20 - 1     |   2^6          | 2^14  - 2^10     | 4000 - 0400       |
// | 2^26 - 1     |   2^13         | 2^13  - 2^7      | 2000 - 0080       |
// | 2^30 - 1     |   2^23         | 2^7   - 2^3      | 0080 - 0008       |
// | 2^31 - 1     |   2^25         | 2^6   - 2^5      | 0040 - 0020       |
// ------------------------------------------------------------------------
// | Total        |                |                  | 84C0 - 04D8       |
// |              |                |                  |     7FE8          |
// ------------------------------------------------------------------------

const long limit1 = 0x400;
const long shift1 = 0;
const long cbins1 = 0x400;

const long limit2 = 0x10000;        // 2^16
const long shift2 = 3;
const long cSkip1 = limit1 >> shift2;
const long cbins2 = (limit2 >> shift2)-cSkip1;

const long limit3 = 0x100000;       // 2^20
const long shift3 = 6;
const long cSkip2 = limit2 >> shift3;
const long cbins3 = (limit3 >> shift3) - cSkip2;

const long limit4 = 0x4000000;      // 2^26
const long shift4 = 13;
const long cSkip3 = limit3 >> shift4;
const long cbins4 = (limit4 >> shift4) - cSkip3;

const long limit5 = 0x40000000;     // 2^30
const long shift5 = 23;
const long cSkip4 = limit4 >> shift5;
const long cbins5 = (limit5 >> shift5) - cSkip4;

const long limit6 = MINLONG;     // 2^31
const long shift6 = 25;
const long cSkip5 = limit5 >> shift6;
const long cbins6 = ((long) ((unsigned) limit6 >> shift6)) - cSkip5;

static unsigned MapLong( LONG lValue )
{

    Win4Assert( !(lValue & MINLONG) || ( MINLONG == lValue ) );

#if CIDBG==1
    const long cTotal = cbins1 + cbins2 + cbins3 + cbins4 + cbins5 + cbins6;
    Win4Assert( cTotal <= MINSHORT );
#endif  // CIDBG == 1

    unsigned ulValue = (unsigned) lValue;

    unsigned binNum = (unsigned) lValue;;

    if ( ulValue < limit1 )
    {
        //
        // Nothing to do.
        //
    }
    else if ( ulValue < limit2 )
    {
        binNum = cbins1 - cSkip1 + (ulValue >> shift2);
    }
    else if ( ulValue < limit3 )
    {
        binNum = cbins1 + cbins2 - cSkip2 + (binNum >> shift3);
    }
    else if ( ulValue < limit4 )
    {
        binNum = cbins1 + cbins2 + cbins3 - cSkip3 + (binNum >> shift4);
    }
    else if ( ulValue < limit5 )
    {
        binNum = cbins1 + cbins2 + cbins3 + cbins4 - cSkip4 + (binNum >> shift5);
    }
    else
    {
        binNum = cbins1 + cbins2 + cbins3 + cbins4 + cbins5 - cSkip5 + (binNum >> shift6);
    }

    return binNum;
}

//+---------------------------------------------------------------------------
//
//  Function:   NormLong
//
//  Synopsis:   Normalizes the given "signed" long value to a value between
//              0x0000 - 0xFFFF. The negative numbers occupy 0x0000-0x8000.
//              Positive numbers occupy 0x8000-0xFFFF
//
//  Arguments:  [lValue] - The value to be normalized.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormLong(LONG lValue)
{
    if (lValue >= 0)
    {
        return MapLong(lValue) + MINSHORT;
    }
    else
    {
        return MINSHORT - MapLong(-lValue);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NormULong
//
//  Synopsis:   Normalizes an "unsigned" long value to a value between
//              0x0000-0xFFFF.  Numbers from 0-2^31 - 1 are mapped in the
//              range 0x0000-0x7FFF.  Numbers 2^31 to 2^32 - 1 are mapped
//              in the range 0x8000 - 0xFFFF
//
//  Arguments:  [lValue] -  The value to be mapped.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormULong( ULONG lValue )
{
    unsigned val = MapLong( lValue & ~MINLONG );    // turn off the high bit

    Win4Assert( !(val & MINSHORT) );

    if ( lValue & MINLONG )
        val |= MINSHORT;

    return val;
}

//+---------------------------------------------------------------------------
//
//  Function:   MapLargeInteger
//
//  Synopsis:   Maps a LargeInteger to a number between 0x0000-0x7FFF.
//
//              Numbers with the "HighPart" = 0 are mapped in the range
//              0x0000-0x3FFF.  When the HighPart !=0, the values are
//              mapped to 0x4000 - 0x7FFF
//
//  Arguments:  [liValue] - The value to be mapped.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned MapLargeInteger( LARGE_INTEGER & liValue )
{
    Win4Assert( !(liValue.HighPart & MINLONG) || ( MINLONG == liValue.HighPart ) );

    unsigned normVal;

    if ( 0 == liValue.HighPart )
    {
        normVal = NormULong( liValue.LowPart );
        normVal >>= 2;
    }
    else
    {
        normVal = MapLong( liValue.HighPart );  // 0x0000-0x7FFF
        normVal >>= 1;
        normVal |= 0x4000;
    }

    Win4Assert( normVal < 0x8000 );

    return normVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   NormULargeInteger
//
//  Synopsis:   Normalizes an unsigned LargeInteger to a number between
//              0x0000-0xFFFF.
//
//              Numbers with the "HighPart" = 0 are mapped in the range
//              0x0000-0x7FFF.  When the HighPart !=0, the values are
//              mapped to 0x8000 - 0xFFFF.
//
//  Arguments:  [uliValue] - The value to be mapped.
//
//  History:    02-09-96   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormULargeInteger( ULARGE_INTEGER & uliValue )
{
    unsigned normVal;

    if ( 0 == uliValue.HighPart )
    {
        normVal = NormULong( uliValue.LowPart );
        normVal >>= 1;
    }
    else
    {
        normVal = NormULong( uliValue.HighPart );  // 0x0000-0x7FFF
        normVal |= 0x8000;
    }

    Win4Assert( normVal < 0x10000 );

    return normVal;
}


//+---------------------------------------------------------------------------
//
//  Function:   NormLargeInteger
//
//  Synopsis:   Normalizes a large integer to a value between 0x0000-0xFFFF.
//
//              -ve Numbers are mapped in the range 0x0000-0x8000.
//              +ve numbers are mapped in the range 0x8000-0xFFFF.
//
//  Arguments:  [liValue] -  The value to be normalized. Note that the
//              argument is NOT passed by reference. The value is changed
//              in this method and so should not be passed by reference.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormLargeInteger( LARGE_INTEGER liValue )
{
    unsigned normVal;

    if ( liValue.QuadPart < 0 )
    {
        liValue.QuadPart = -liValue.QuadPart;
        normVal = MINSHORT - MapLargeInteger( liValue );
    }
    else
    {
        normVal = MINSHORT + MapLargeInteger( liValue );
    }

    Win4Assert( normVal < 0x10000 );

    return normVal;
}

#ifdef  TEST_NORM
//
// a test to verify the validity of the NormLong function.
//
void TestNormLong()
{
    long lVal1 = 0;
    unsigned nVal1 = NormLong( lVal1 );

    printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal1, nVal1, lVal1, nVal1 );

    lVal1 = 2;
    long lVal2 = 0;
    unsigned nVal2 = NormLong(1);

    while ( !(lVal1 & 0x80000000) )
    {
        nVal1 = NormLong( lVal1 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal1, nVal1, lVal1, nVal1 );

        Win4Assert( nVal1 == nVal2+1 );

        lVal2 = lVal1 + lVal1-1;
        nVal2 = NormLong( lVal2 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal2, nVal2, lVal2, nVal2 );

        lVal1 <<= 1;
    }

    lVal1 = 2;
    nVal2 = NormLong(-1);
    printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", -1, nVal2, -1, nVal2 );

    while ( !(lVal1 & 0x80000000) )
    {
        nVal1 = NormLong( -lVal1 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", -lVal1, nVal1, -lVal1, nVal1 );

        Win4Assert( nVal1 == nVal2-1 );

        lVal2 = lVal1 + lVal1-1;
        lVal2 = -lVal2;

        nVal2 = NormLong( lVal2 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal2, nVal2, lVal2, nVal2 );

        lVal1 <<= 1;
    }
}
#endif  // 0

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::CNormalizer
//
//  Synopsis:   constructor for normalizer
//
//  Effects:    gets buffers from noiselist
//
//  Arguments:  [nl] -- Noise list object to pass data on to.
//
//  History:    05-June-91   t-WadeR     Created.
//
//  Notes:
//
//----------------------------------------------------------------------------
CNormalizer::CNormalizer( PNoiseList& nl )
    : _noiseList(nl)
{
    SetWordBuffer();

    // check that input size + prefix fits in the output buffer
    Win4Assert( cwcMaxKey * sizeof( WCHAR ) + cbKeyPrefix <= *_pcbOutBuf );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::GetFlags
//
//  Synopsis:   Returns address of ranking and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Fab-92   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CNormalizer::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    _noiseList.GetFlags ( ppRange, ppRank );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessAltWord, public
//
//  Synopsis:   Normalizes a UniCode string, passes it to NoiseList.
//
//  Effects:    Deposits a normalized version [pwcInBuf] in [_pbOutBuf]
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  History:    03-May-95     SitaramR     Created.
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessAltWord( WCHAR const *pwcInBuf,  ULONG cwc )
{
    SetNextAltBuffer();

    unsigned hash = NormalizeWord( pwcInBuf, cwc );
    SetAltHash( hash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessWord, public
//
//  Synopsis:   Normalizes a UniCode string, passes it to NoiseList.
//
//  Effects:    Deposits a normalized version of [pwcInBuf] in [_pbOutBuf].
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  History:    05-June-91  t-WadeR     Created.
//              13-Oct-92   AmyA        Added unicode support
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessWord( WCHAR const *pwcInBuf,  ULONG cwc )
{
    if ( UsingAltBuffers() )
        SetNextAltBuffer();

    unsigned hash = NormalizeWord( pwcInBuf, cwc );

    if ( UsingAltBuffers() )
    {
        SetAltHash( hash );
        ProcessAllWords();
    }
    else
        _noiseList.PutWord( hash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessAllWords, private
//
//  Synopsis:   Removes duplicate alternate words and emits remainder.
//
//  History:    17-Sep-1999    KyleP     Created.
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessAllWords()
{
    //
    // Check for duplicate keys.  Since the number of alternate forms will always be
    // quite small it's ok to use a O(n^2) algorithm here.
    //

    unsigned iFinal = 0;

    for ( unsigned i = 0; i < _cAltKey; i++ )
    {
        //
        // Already marked duplicate?
        //

        if ( 0 == _aAltKey[i].Count() )
            continue;

        iFinal = i;

        for ( unsigned j = i+1; j < _cAltKey; j++ )
        {
            //
            // Remember, Pid is really the hash here.
            //

            if ( _aAltKey[i].Pid() == _aAltKey[j].Pid() &&
                 _aAltKey[i].Count() == _aAltKey[j].Count() &&
                 RtlEqualMemory( _aAltKey[i].GetBuf(), _aAltKey[j].GetBuf(), _aAltKey[j].Count() ) )
            {
                ciDebugOut(( DEB_TRACE, "Duplicate keys: %u and %u\n", i, j ));
                _aAltKey[j].SetCount( 0 );
            }
        }
    }

    //
    // Now transfer any remaining key(s).
    //

    SetWordBuffer();
    unsigned hash;

    for ( i = 0; i <= iFinal; i++ )
    {
        //
        // Ignore duplicates
        //

        if ( 0 == _aAltKey[i].Count() )
            continue;

        //
        // Copy to the transfer buffer.
        //

        *_pcbOutBuf = _aAltKey[i].Count();
        RtlCopyMemory( _pbOutBuf, _aAltKey[i].GetBuf(), *_pcbOutBuf );
        hash = _aAltKey[i].Pid();

        //
        // If this is not the final "PutWord" call, send the data along.
        //

        if ( i != iFinal )
            _noiseList.PutAltWord( hash );
    }

    //
    // Put the final word
    //

    _noiseList.PutWord( hash );
} //ProcessAllWords

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWord
//
//  Synopsis:   Normalizes a UniCode string
//              Calculates the hash function for normalized string.
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  Returns:    unsigned hash value of string
//
//  History:    03-May-95    SitaramR     Created.
//
//----------------------------------------------------------------------------

unsigned CNormalizer::NormalizeWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    return NormalizeWord( pwcInBuf, cwc, _pbOutBuf, _pcbOutBuf );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWord
//
//  Synopsis:   Normalizes a UniCode string
//              Calculates the hash function for normalized string. This 
//              function is identical to the other NormalizeWord funtion,
//              except that it puts the outputs int he output parameters
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//              [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  Returns:    unsigned hash value of string
//
//  History:    03-May-1995    SitaramR     Created.
//              03-Oct-2000    KitmanH      Added output parameters              
//
//----------------------------------------------------------------------------

unsigned CNormalizer::NormalizeWord( WCHAR const *pwcInBuf, 
                                     ULONG cwc, 
                                     BYTE *pbOutBuf, 
                                     unsigned *pcbOutBuf )
{
    // count of bytes needs to take into account STRING_KEY

    *pcbOutBuf = cwc * sizeof(WCHAR) + cbKeyPrefix;

    // prefix with the string key identifier

    *pbOutBuf++ = STRING_KEY;

    unsigned hash = 0;

    Win4Assert ( cwc != 0 && cwc <= cwcMaxKey );
    for ( unsigned i = 0; i < cwc; i++ )
    {
        WCHAR c = *pwcInBuf++;

        // normalize the character to upcase.

        c = ( c < 'a' ) ? c : ( c <= 'z' ) ? ( c - ('a' - 'A') ) :
            RtlUpcaseUnicodeChar( c );

        //
        // Store.  Do it one byte at a time because the normalized string
        // must be byte compared.
        //

        *pbOutBuf++ = (BYTE)(c >> 8);
        *pbOutBuf++ = (BYTE)c;

        // hash
        hash = ( hash << 2 ) + c;
    }

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWstr - Public
//
//  Synopsis:   Normalizes a UniCode string
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwcInBuf] -- count of chars in pwcInBuf
//              [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  History:    10-Feb-2000     KitmanH    Created
//
//----------------------------------------------------------------------------

void CNormalizer::NormalizeWStr( WCHAR const *pwcInBuf, 
                                 ULONG cwcInBuf,
                                 BYTE *pbOutBuf, 
                                 unsigned *pcbOutBuf )
{
    NormalizeWord( pwcInBuf, 
                   cwcInBuf,
                   pbOutBuf, 
                   pcbOutBuf );
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::CValueNormalizer
//
//  Synopsis:   Constructor
//
//  Arguments:  [krep] -- key repository sink for keys
//
//  History:    21-Sep-92   BartoszM     Created.
//
//----------------------------------------------------------------------------

CValueNormalizer::CValueNormalizer( PKeyRepository& krep )
  : _krep(krep)
{
    _krep.GetBuffers( &_pcbOutBuf, &_pbOutBuf, &_pOcc );
    _cbMaxOutBuf = *_pcbOutBuf;
    *_pOcc = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue, public
//
//  Synopsis:   Store a variant
//
//  Arguments:  [pid] -- property id
//              [occ] -- On input:  starting occurrence.
//                       On output: next starting occurrence.
//              [var] -- value
//
//  History:    04-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid,
                                 OCCURRENCE & occ,
                                 CStorageVariant const & var )
{
    *_pOcc = occ;

    switch ( var.Type() )
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        PutValue( pid, var.GetUI1() );
        break;

    case VT_I1:
        PutValue( pid, var.GetI1() );
        break;

    case VT_UI2:
        PutValue( pid, (USHORT) var.GetUI2() );
        break;

    case VT_I2:
        PutValue( pid, var.GetI2() );
        break;

    case VT_I4:
    case VT_INT:
        PutValue( pid, var.GetI4() );
        break;

    case VT_R4:
        PutValue( pid, var.GetR4() );
        break;

    case VT_R8:
        PutValue( pid, var.GetR8() );
        break;

    case VT_UI4:
    case VT_UINT:
        PutValue( pid, var.GetUI4() );
        break;

    case VT_I8:
        PutValue( pid, var.GetI8() );
        break;

    case VT_UI8:
        PutValue( pid, var.GetUI8() );
        break;

    case VT_BOOL:
        PutValue( pid, (BYTE) (FALSE != var.GetBOOL()) );
        break;

    case VT_ERROR:
        PutValue( pid, var.GetERROR() );
        break;

    case VT_CY:
        PutValue( pid, var.GetCY() );
        break;

    case VT_DATE:
        PutDate( pid, var.GetDATE() );
        break;

    case VT_FILETIME:
        PutValue( pid, var.GetFILETIME() );
        break;

    case VT_CLSID:
        PutValue( pid, *var.GetCLSID() );
        break;

    // NTRAID#DB-NTBUG9-84589-2000/07/31-dlee Indexing Service data type normalization doesn't handle VT_DECIMAL, VT_VECTOR, or VT_ARRAY.

    default:
        ciDebugOut(( DEB_IWARN, "Unhandled type %d (%x) sent to normalization\n",
                     var.Type(), var.Type() ));
        break;
    }

    occ = *_pOcc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  private
//
//  Synopsis:   Store a unsigned 2 byte value without altering it
//
//  Arguments:  [pid]    -- property id
//              [uValue] -- value
//              [bType]  -- value type
//
//  History:    07-Oct-93   DwightKr     Created.
//
//  Notes:      This is the principal PutValue method that other PutValue()s
//              will call.  Each of the OTHER PutValue()'s sole purpose is
//              to normalize their input data into a 2-byte unsigned value.
//              This version of PutValue() will store the value together
//              with its WID, PID, size, etc. in the CDataRepository object.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, unsigned uValue, BYTE bType )
{
    BYTE* pb = _pbOutBuf;

    // Store size of entry
    *_pcbOutBuf = sizeof(USHORT) + sizeof(PROPID) + 1;

    // Store key type
    *pb++ = bType;

    // store property id
    *pb++ = (BYTE)(pid >> 24);
    *pb++ = (BYTE)(pid >> 16);
    *pb++ = (BYTE)(pid >> 8);
    *pb++ = (BYTE) pid;

    // Store key
    Win4Assert( uValue < 0x10000 );
    *pb++ = BYTE (uValue >> 8);
    *pb++ = BYTE (uValue);

#if CIDBG == 1
    for (unsigned i =  0; i < *_pcbOutBuf; i++ )
    {
        ciDebugOut (( DEB_USER1 | DEB_NOCOMPNAME, "%02x ", _pbOutBuf[i] ));
    }
    ciDebugOut (( DEB_USER1 | DEB_NOCOMPNAME, "\n" ));
#endif

    _krep.PutPropId(pid);
    _krep.PutKey();
    (*_pOcc)++;
}

void CValueNormalizer::PutMinValue( PROPID pid, OCCURRENCE & occ, VARENUM Type )
{
    *_pOcc = occ;
    PutValue( pid, 0, Type );
    occ = *_pOcc;
}

void CValueNormalizer::PutMaxValue( PROPID pid, OCCURRENCE & occ, VARENUM Type )
{
    *_pOcc = occ;
    PutValue( pid, 0xFFFF, Type );
    occ = *_pOcc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store a 1 byte value without altering it
//
//  Arguments:  [pid]  -- property id
//              [byte] -- value
//
//  History:    25-Oct-93   DwightKr     Created.
//
//  Notes:      One byte values are NOT normalized, they are stored as is.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, BYTE byte )
{
    PutValue(pid, (unsigned) byte, VT_UI1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store a 1 byte signed value without altering it
//
//  Arguments:  [pid]  -- property id
//              [ch]   -- value
//
//  History:    25-Oct-1993   DwightKr     Created.
//              29-Sep-2000   KitmanH      Normalize VT_I1 values
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, CHAR ch )
{
    PutValue(pid, ( ((BYTE) ch) + 0x80 ) & 0xFF, VT_I1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the high byte of an unsigned 2 byte value
//
//  Arguments:  [pid]     -- property id
//              [usValue] -- value
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, USHORT usValue )
{
    PutValue(pid, (usValue >> 8) & 0xFF, VT_UI2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store the high byte of a signed 2 byte value.
//
//  Arguments:  [pid]     -- property id
//              [sValue]  -- value
//
//  Notes:      Add the smallest BYTE to this so that we translate numbers
//              into the range above 0.  i.e. -32768 maps into 0x00, and 32767
//              maps into 0xFF.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, SHORT sValue )
{
    PutValue(pid, ((sValue >> 8) + 0x80) & 0xFF, VT_I2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store the base-2 log of the ULONG value.
//
//  Arguments:  [pid]     -- property id
//              [ulValue] -- value
//
//  Notes:      This convert ULONGs into the range 0 - 31 by taking the Log2
//              of the number.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, ULONG  ulValue )
{
    PutValue(pid, NormULong ( ulValue ), VT_UI4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-2 log of the signed LONG value.
//
//  Arguments:  [pid]     -- property id
//              [lValue]  -- value
//
//  Notes:      This converts LONGs into numbers larger than 0.  This
//              translates into 64 bins; 32 bins for #'s < 0 & 32 bins for
//              #'s >= 0.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, LONG lValue )
{
     PutValue(pid, NormLong(lValue), VT_I4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-10 log of the FLOAT value.
//
//  Arguments:  [pid]     -- property id
//              [rValue]  -- value
//
//  Notes:      floats fit into a total of 41 bins.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, float rValue )
{
    PutValue(pid, NormDouble(rValue), VT_R4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-10 log of the DOUBLE value.
//
//  Arguments:  [pid]     -- property id
//              [dValue]  -- value
//
//  Notes:      doubles fit into a total of 41 bins.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, double dValue )
{
    PutValue(pid, NormDouble(dValue), VT_R8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the exponent of a large integer
//
//  Arguments:  [pid] -- property id
//              [li]  -- value
//
//  History:    21-Sep-92   BartoszM    Created.
//              04-Feb-93   KyleP       Use LARGE_INTEGER
//              25-Oct-92   DwightKr    Copied here & removed extra code &
//                                      accounted for negative numbers
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, LARGE_INTEGER liValue )
{
    unsigned uExponent = NormLargeInteger(liValue);

    PutValue( pid, uExponent, VT_I8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store a compressed large integer
//
//  Arguments:  [pid] -- property id
//              [uli] -- value
//
//  History:    09 Feb 96   AlanW      Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, ULARGE_INTEGER uliValue )
{
    unsigned uExponent = NormULargeInteger(uliValue);

    PutValue( pid, uExponent, VT_UI8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the least byte of a GUID
//
//  Arguments:  [pid]   -- property id
//              [guid]  -- value
//
//  Notes:      The GUID generators are guaranteed to modify the TOP DWORD
//              of the 32-byte GUID each time a new GUID is generated.
//              The lower bytes of the GUID is the network address of the
//              card which generated the UUID.
//
//              We would like to cluster together together objects of a single
//              class (all MS-Word objects together for example).  Since it
//              is possible that someone could generate UUIDs for more than
//              one application on a single machine, the lower portion of
//              the UUID will perhaps remain constant between class IDs.  The
//              only part of the UUID which is guaranteed to be unique between
//              multiple objects is the field which represents time.  It is
//              unlikely that two classes were generated the same second on
//              two different machines.
//
//  History:    25-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, GUID const & Guid )
{
    PutValue(pid, Guid.Data1 & 0xFFFF, VT_CLSID);
}

long CastToLong( double d )
{
    //
    // bit 63       = sign
    // bits 52 - 62 = exponent
    // bits 0 - 51  = mantissa
    //

    LARGE_INTEGER * pli = (LARGE_INTEGER *)&d;

    int exp  = (pli->HighPart & 0x7ff00000) >> 20;

    if ( exp == 0 )
    {
        //
        // Special case: Zero, NaNs, etc.
        //

        return( 0 );
    }

    //
    // Subtract off bias
    //

    exp -= 0x3ff;

    if ( exp < 0 )
    {
        // Cast of very small number to unsigned long.  Loss of precision
        return( 0 );
    }
    else if ( exp > 30 )
    {
        // Cast of very large number to unsigned long.  Overflow
        if ( pli->HighPart & 0x80000000 )
            return( LONG_MIN );
        else
            return( LONG_MAX );
    }
    else
    {
        //
        // We need to get the top 32 bits of the mantissa
        // into a dword.
        //

        unsigned long temp = pli->LowPart >> (32 - 12);
        temp |= pli->HighPart << (32 - 20);

        //
        // Add the 'hidden' bit of the mantissa. (Since all doubles
        // are normalized to 1.?????? the highest 1 bit isn't stored)
        //

        temp = temp >> 1;
        temp |= 0x80000000;

        //
        // Thow away digits to the right of decimal
        //

        temp = temp >> (31 - exp);

        //
        // Adjust for sign
        //

        Win4Assert( (temp & 0x80000000) == 0 );
        long temp2;

        if ( pli->HighPart & 0x80000000 )
            temp2 = temp * -1;
        else
            temp2 = temp;

        return( temp2 );
    }
} //CastToLong

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutDate
//
//  Synopsis:   Dates are passed in as the number of days (and fractional days)
//              since Jan. 1, 1900.  We'll crunch this down to the number of
//              weeks.  Dates are passed in a doubles.  We'll assume that
//              negative numbers represent dates before Jan. 1, 1900.
//
//  Arguments:  [pid]     -- property id
//              [DATE]    -- value (double)
//
//  Notes:      Since dates before Jan 1, 1900 are passed as negative numbers
//              we'll need to normalize them to something >= 0.
//
//              time period                    resolution            # bins
//              ===========================    ===============       ======
//              year < 10Bil BC                -- bin = 0               1
//              10Bil BC <= year <=    1 BC    -- log10 (year)         11
//                 1 BC  <  year <= 1900       -- year               1902
//              1901 AD  <= year <= 2050 AD    -- daily             54787
//              2051 AD  <= year <= 10Bil AD   -- log10 (year)          8
//              year > 10Bil AD                -- bin = 0xFFFF          1
//
//
//              I choose the daily range from 1901 - 2050 since there is a lot
//              of events in the 20th century (WW I, WW II, landing on the
//              moon, my wife's birthday, etc.) that are interesting, and
//              imporant.  It is likely that dates outside of this range will
//              be rounded to the nearest year (1492, 1776, 1812, 1867, etc).
//
//              Also by breaking the log10(year) at 1 BC rather than some other
//              date (such as 0000 AD, or 1 AD) we avoid values in the range
//              1 BC < year < 1 AD, calculating log10(year) resulting in
//              large negative numbers.  Everything in this range should be in
//              bin #12.  It also avoids taking log10(0).
//
//
//  History:    25-Oct-93   DwightKr     Created.
//              07-Dec-94   KyleP        Remove use of floating point
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutDate( PROPID pid, DATE const & Date )
{
    const int MinDate = 42;     // 2^42 --> ~4.4E12 days --> ~12E9 years  --> 12 billion B.C.
    const int MinByYear = 20;   // 2^20 --> ~1.0E6  days --> ~2.9E3 years --> 970 B.C.
    const int cMinByYear = (1 << MinByYear) / 365 + 1;   // 2873
    const int MaxDaily = (2051 - 1900) * 365;            // 55115
    const int MinByYearAD = 15; // 2^15 --> ~32768 days  --> ...
    const int MaxDate = 42;     // 2^42 --> ~4.4E12 days --> ~12E9 years  --> 12 billion A.D.

    const unsigned FirstBC            = 0;
    const unsigned FirstLogBC         = FirstBC + 1;
    const unsigned LastLogBC          = FirstLogBC + MinDate - MinByYear;
    const unsigned FirstYearBC        = LastLogBC + 1;
    const unsigned LastYearBC         = FirstYearBC + cMinByYear;
    const unsigned FirstDaily         = LastYearBC + 1;
    const unsigned LastDaily          = FirstDaily + MaxDaily;
    const unsigned FirstLogAD         = LastDaily + 1;
    const unsigned LastLogAD          = FirstLogAD + MaxDate - MinByYearAD;
    const unsigned LastAD             = 0xFFFF;

    Win4Assert( LastLogAD < 0xFFFF );

    unsigned bin;
    BOOL fPositive;

    int exp = GetExpAndSign( Date, fPositive );

    if ( !fPositive )
    {
        //
        // Very large negative dates go in first bin
        //

        if ( exp >= MinDate )
            bin = FirstBC;

        //
        // Medium size negative dates get 1 bin / power of 2
        //

        else if ( exp >= MinByYear )
            bin = FirstLogBC - exp + MinByYear;

        //
        // All other dates before 1900 get 1 bucket per 365 days.
        //

        else
        {
            long cYears = CastToLong( Date ) / 365;

            Win4Assert( cYears >= -cMinByYear && cYears <= 0 );

            bin = FirstYearBC + cYears + cMinByYear;
        }
    }
    else
    {
        //
        // Very large positive dates go in last bin
        //

        if ( exp >= MaxDate )
            bin = LastAD;
        else
        {
            long cDays = CastToLong( Date );

            //
            // Dates rather far in the future get 1 bucket / power of 2
            //

            if ( cDays >= MaxDaily )
                bin = FirstLogAD + exp - MinByYearAD;

            //
            // Days close to today get 1 bucket per day
            //

            else
                bin = FirstDaily + cDays;
        }
    }

    PutValue(pid, bin, VT_DATE);
} //PutDate

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the hashed value of an 8-byte currency.
//
//  Arguments:  [pid]     -- property id
//              [cyValue]  -- value
//
//  Notes:      Currency values are stored as a ULONG cents, and a LONG $.
//              We'll ignore the cents portion and store the $ part using
//              the standard LONG storage method.
//
//  History:    26-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid, CURRENCY const & cyValue)
{
    PutValue(pid, NormLong(cyValue.Hi), VT_CY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the number of days since Jan 1, 1980;
//
//  Arguments:  [pid]     -- property id
//              [ulValue] -- value
//
//  History:    07-Oct-93   DwightKr     Created.
//
//  Notes:      This algorithym calculates the number of days since Jan 1,
//              1980; and stores it into a unsigned.  FileTimes are divided
//              into the following ranges:
//
//              FileTime < 1980                              => bin  0
//              1980 <= FileTime <= 1993    week granularity => bins 1 - 729
//              1994 <= FileTime <= 2160    day granularity  => bins 730+
//              FileTime > 2160                              => bin 0xFFFF
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid, FILETIME const & ftValue )
{
    //
    //  Determine the number of days since Jan 1, 1601 by dividing by
    //  the number of 100 nanosecond intervals in a day.  The result
    //  will fit into a ULONG.
    //
    //  Then map the result into one of the ranges: before 1980, between
    //  1980 and 1994, between 1994 and 2160, and after 2160.  To make
    //  the computation easier, we use precomputed values of the number
    //  of days from 1601 and the breakpoints of our range.
    //

    // 100s of nanosecs per day
    const ULONGLONG uliTicsPerDay = 24 * 60 * 60 * (ULONGLONG)10000000;

    const ULONG ulStart = 138426;       // number of days from 1601 to 1980
    const ULONG ulMiddle= 143542;       // number of days from 1601 to 1/2/1994
    const ULONG ulEnd   = 204535;       // number of days from 1601 to 2161

    ULARGE_INTEGER liValue = {ftValue.dwLowDateTime, ftValue.dwHighDateTime};

    ULONG ulDays = (ULONG) (liValue.QuadPart / uliTicsPerDay);

    //
    //  We now have the number of days since Jan. 01, 1601 in ulDays.
    //  Map into buckets.
    //

    if (ulDays < ulStart)                  // Store in bin 0
    {
        PutValue(pid, 0, VT_FILETIME);
    }
    else if (ulDays <= ulMiddle)           // Store week granularity
    {
        PutValue(pid, (ulDays + 1 - ulStart) / 7, VT_FILETIME);
    }
    else if (ulDays <= ulEnd)             // Store day granularity
    {
        //
        // Bins 0 - 730 are used by the two clauses above.  It doesn't
        // really matter if we reuse bin 730 for the start of the next
        // range (this might happen because of the division we do).
        //

        PutValue(pid, (ulDays + 1 - ulMiddle) + ((ulMiddle - ulStart) / 7),
                 VT_FILETIME);
    }
    else                                            // FileTime > 2160
    {
        PutValue(pid, 0xFFFF, VT_FILETIME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\pickle.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       Pickle.cxx
//
//  Contents:   Pickling/Unpickling routines for restrictions.
//
//  History:    22-Dec-92 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <coldesc.hxx>
#include <pidmap.hxx>
#include <rstprop.hxx>
#include <sizeser.hxx>
#include <memser.hxx>
#include <memdeser.hxx>
#include <pickle.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   DoPickle
//
//  Synopsis:   Pickles a query into a stream
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [ss]      -- Stream into which query is pickled
//              [cb]      -- Size of pickled query
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//
//  History:    18-Apr-95 dlee  From duplicate code in Pickle & PickledSize
//
//--------------------------------------------------------------------------

void DoPickle( int sver,
               PSerStream &ss,
               ULONG cb,
               CColumnSet const * pcol,
               CRestriction const * prst,
               CSortSet const * pso,
               CCategorizationSet const *pcateg,
               CRowsetProperties const *pProps,
               CPidMapper const * pidmap )
{
    // must be 8-byte aligned

    ss.PutULong( cb );         // Size

    if ( 0 == pcol )
        ss.PutByte( PickleColNone );
    else
    {
        ss.PutByte( PickleColSet );
        pcol->Marshall( ss );
    }

    if ( 0 == prst )
        ss.PutByte( FALSE );
    else
    {
        if ( !prst->IsValid() )
        {
            vqDebugOut(( DEB_ERROR, "Marshalling invalid restriction!\n" ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }

        ss.PutByte( TRUE );
        prst->Marshall( ss );
    }

    if ( 0 == pso )
        ss.PutByte( FALSE );
    else
    {
        ss.PutByte( TRUE );
        pso->Marshall( ss );
    }

    if ( 0 == pcateg )
        ss.PutByte( FALSE );
    else
    {
        ss.PutByte( TRUE );
        pcateg->Marshall( ss );
    }

    pProps->Marshall(ss);

    Win4Assert( 0 != pidmap );
    pidmap->Marshall( ss );
} //DoPickle

//+-------------------------------------------------------------------------
//
//  Function:   PickledSize, public
//
//  Synopsis:   Computes size of buffer required to pickle query.
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//
//  Returns:    Size (in bytes) of buffer needed to serialize query.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

ULONG PickledSize( int sver,
                   CColumnSet const * pcol,
                   CRestriction const * prst,
                   CSortSet const * pso,
                   CCategorizationSet const *pcateg,
                   CRowsetProperties const *pProps,
                   CPidMapper const * pidmap )
{
    CSizeSerStream ss;

    DoPickle( sver, ss, 0, pcol, prst, pso, pcateg, pProps, pidmap );

    vqDebugOut(( DEB_ITRACE, "Marshalled size = %d bytes\n", ss.Size() ));

    return ss.Size();
} //PickledSize

//+-------------------------------------------------------------------------
//
//  Function:   Pickle, public
//
//  Synopsis:   Pickles query
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//              [pb]      -- Buffer to serialize query into
//              [cb]      -- Size (in bytes) of pb.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

void Pickle( int sver,
             CColumnSet const * pcol,
             CRestriction const * prst,
             CSortSet const * pso,
             CCategorizationSet const *pcateg,
             CRowsetProperties const *pProps,
             CPidMapper const * pidmap,
             BYTE * pb,
             ULONG cb )
{
    CMemSerStream ss( pb, cb );

    DoPickle( sver, ss, cb, pcol, prst,  pso, pcateg, pProps, pidmap );
} //Pickle

//+-------------------------------------------------------------------------
//
//  Function:   UnPickle, public
//
//  Synopsis:   Deserializes pickled query into buffer.
//
//  Arguments:  [cver]     -- version of the client that pickled the query
//              [col]      -- Columns in table here on exit
//              [rst]      -- Restriction here on exit
//              [sort]     -- Sort order here on exit
//              [categ]    -- Categorization specification here on exit
//              [RstProp]  -- Rowset properties initialized here on exit
//              [pidmap]   -- Pidmap here on exit
//              [pbInput]  -- Buffer containing pickled query
//              [cbInput]  -- Size (in bytes) of pbInput.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

void UnPickle( int cver,
               XColumnSet & col,
               XRestriction & rst,
               XSortSet & sort,
               XCategorizationSet & categ,
               CRowsetProperties & RstProps,
               XPidMapper & pidmap,
               BYTE * pbInput,
               ULONG cbInput )
{
    CMemDeSerStream ss( pbInput, cbInput );

    ULONG cbPickleBuf = 0;

    cbPickleBuf = ss.GetULong();    // length of buffer

    if (cbPickleBuf > cbInput)
    {
        vqDebugOut(( DEB_ERROR, "cbPickleBuf %d, cbInput %d\n",
                     cbPickleBuf, cbInput ));
        Win4Assert(cbPickleBuf <= cbInput);
        THROW(CException(STATUS_INVALID_PARAMETER_MIX));
    }

    BYTE bColType = ss.GetByte();
    switch (bColType)
    {
    case PickleColSet:
        col.Set( new CColumnSet(ss) );
        break;

    default:
        Win4Assert(bColType <= PickleColSet);

    case PickleColNone:
        break;
    }

    BOOL fNonZero = ss.GetByte();
    if ( fNonZero )
    {
        rst.Set( CRestriction::UnMarshall(ss) );

        // would have thrown on out of memory, so rst must be valid

        Win4Assert( !rst.IsNull() );
        Win4Assert( rst->IsValid() );
    }

    fNonZero = ss.GetByte();
    if ( fNonZero )
        sort.Set( new CSortSet(ss) );

    fNonZero = ss.GetByte();
    if ( fNonZero )
        categ.Set( new CCategorizationSet(ss) );

    RstProps.Unmarshall(ss);

    pidmap.Set( new CPidMapper(ss) );
} //UnPickle

void CRowsetProperties::Marshall( PSerStream & ss ) const
{
    ss.PutULong( _uBooleanOptions );
    ss.PutULong( _ulMaxOpenRows );
    ss.PutULong( _ulMemoryUsage );
    ss.PutULong( _cMaxResults );
    ss.PutULong( _cCmdTimeout );
} //Marshall

void CRowsetProperties::Unmarshall( PDeSerStream & ss )
{
    _uBooleanOptions = ss.GetULong();
    _ulMaxOpenRows = ss.GetULong();
    _ulMemoryUsage = ss.GetULong();
    _cMaxResults = ss.GetULong();
    _cCmdTimeout = ss.GetULong();
} //Unmarshall
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\pidcvt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       PidCvt.cxx
//
//  Contents:   CPidConverter -- Convert FULLPROPSPEC to PROPID
//
//  History:    29-Dec-97 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidcvt.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CPidConverter::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC property specification
//              [pid] -- PROPID written here on successful execution
//
//  Returns:    Status code (from framework client)
//
//  History:    29-Dec-1997    KyleP     Created
//
//--------------------------------------------------------------------------

SCODE CPidConverter::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    return _xPropMapper->PropertyToPropid( fps.CastToStruct(), // FULLPROPSPEC
                                           TRUE,               // create
                                           &pid );             // Pid returned here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\sizeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       SizeSer.cxx
//
//  Contents:   Class to compute size of serialized structure.
//
//  History:    28-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sizeser.hxx>

CSizeSerStream::CSizeSerStream()
        : _cb( 0 )
{
}

CSizeSerStream::~CSizeSerStream()
{
}

void CSizeSerStream::PutByte( BYTE b )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += 1;
}

void CSizeSerStream::PutChar( char const * pc, ULONG cc )
{
    Win4Assert( sizeof(char) == 1 );
    _cb += cc;
}

void CSizeSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignWCHAR((BYTE *) UIntToPtr( _cb ) )) + sizeof(WCHAR) * cc;
}

void CSizeSerStream::PutUShort( USHORT us )
{
    Win4Assert( sizeof(USHORT) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignUSHORT((BYTE *) UIntToPtr( _cb ) )) + sizeof(USHORT);
}

void CSizeSerStream::PutULong( ULONG ul )
{
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG);
}

void CSizeSerStream::PutLong( long l )
{
    Win4Assert( sizeof(long) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignLong((BYTE *) UIntToPtr( _cb ) )) + sizeof(long);
}

void CSizeSerStream::PutFloat( float f )
{
    Win4Assert( sizeof(float) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignFloat((BYTE *) UIntToPtr( _cb ) )) + sizeof(float);
}

void CSizeSerStream::PutDouble( double d )
{
    Win4Assert( sizeof(double) == 8 );
    _cb = (unsigned)((ULONG_PTR)AlignDouble((BYTE *) UIntToPtr( _cb ) )) + sizeof(double);
}

void CSizeSerStream::PutString( char const * psz )
{
    Win4Assert( sizeof(char) == 1 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) + strlen(psz);
}

void CSizeSerStream::PutWString( WCHAR const * pwsz )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) +
        wcslen(pwsz) * sizeof(WCHAR);
}

void CSizeSerStream::PutBlob( BYTE const * pb, ULONG cb )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += cb;
}

void CSizeSerStream::PutGUID( GUID const & guid )
{
    Win4Assert( sizeof(GUID) == 16 );
    _cb = (unsigned)((ULONG_PTR)AlignGUID((BYTE *) UIntToPtr( _cb ) )) + sizeof(GUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\memser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//
// The CMemSerStream and CDeMemSerStream have different requirements for
// handling buffer overflow conditions. In the case of the driver this
// is indicative of a corrupted stream and we would like to raise an
// exception. On the other hand in Query implementation we deal with
// streams whose sizes are precomputed in the user mode. Therefore we
// do not wish to incur any additional penalty in handling such situations.
// In debug builds this condition is asserted while in retail builds it is
// ignored. The CMemSerStream and CMemDeSerStream implementation are
// implemented using a macro HANDLE_OVERFLOW(fOverflow) which take the
// appropriate action.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "serover.hxx"

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif

CMemSerStream::CMemSerStream( unsigned cb )
        : _cb( cb )
{
    _pb = new BYTE[cb];
    if (_pb != NULL) {
        _pbCurrent = _pb;
        _pbEnd = _pb + _cb;
    }
}

CMemSerStream::CMemSerStream( BYTE * pb, ULONG cb )
        : _cb( 0 ),
          _pb( pb ),
          _pbCurrent( _pb ),
          _pbEnd(_pb + cb)
{
}

CMemSerStream::~CMemSerStream()
{
    if ( _cb > 0 )
        delete [] _pb;
}

void CMemSerStream::PutByte( BYTE b )
{
    HANDLE_OVERFLOW((_pbCurrent + 1) > _pbEnd);

    *_pbCurrent++ = b;
}

void CMemSerStream::PutChar( char const * pc, ULONG cc )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cc;

    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pb, pc, cc );
}

void CMemSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pwcTemp, pwc, cc * sizeof(WCHAR) );
}

void CMemSerStream::PutUShort( USHORT us )
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pus = us;
}

void CMemSerStream::PutULong( ULONG ul )
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent  > _pbEnd);
    *pul = ul;
}

void CMemSerStream::PutLong( long l )
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pl = l;
}

void CMemSerStream::PutFloat( float f )
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pf = f;
}

void CMemSerStream::PutDouble( double d )
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pd = d;
}

void CMemSerStream::PutString( char const * psz )
{
    ASSERT(IsAnsiString(psz, MAXULONG));
    ULONG len = strlen(psz);
    ULONG * pul = AlignULONG(_pbCurrent);
    BYTE *pb = (BYTE *)(pul + 1);
    _pbCurrent = pb + len;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pul = len;
    memcpy(pb, psz, len);
}

void CMemSerStream::PutWString( WCHAR const * pwsz )
{
    ASSERT(IsUnicodeString(pwsz, MAXULONG));
    ULONG len = wcslen(pwsz);
    ULONG * pul = AlignULONG(_pbCurrent);
    BYTE *pb = (BYTE *)(pul + 1);

    _pbCurrent = pb + len * sizeof(WCHAR);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    *pul = len;
    memcpy(pb, pwsz, (len * sizeof(WCHAR)));
}

void CMemSerStream::PutBlob( BYTE const * pbBlob, ULONG cb )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cb;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pb, pbBlob, cb );
}

void CMemSerStream::PutGUID( GUID const & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pguid, &guid, sizeof(guid) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\restrict.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       Restrict.cxx
//
//  Contents:   C++ wrappers for restrictions.
//
//  History:    31-Dec-92 KyleP     Created
//              28-Jul-94 KyleP     Hand marshalling
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>
#include <pickle.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source property spec
//
//  History:    17-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( CFullPropSpec const & src )
        : _guidPropSet( src._guidPropSet )
{
    _psProperty.ulKind = src._psProperty.ulKind;

    if ( _psProperty.ulKind == PRSPEC_LPWSTR )
    {
        if ( src._psProperty.lpwstr )
        {
            _psProperty.ulKind = PRSPEC_PROPID;
            SetProperty( src._psProperty.lpwstr );
        }
        else
            _psProperty.lpwstr = 0;
    }
    else
    {
        _psProperty.propid = src._psProperty.propid;
    }
}

void CFullPropSpec::Marshall( PSerStream & stm ) const
{
    stm.PutGUID( _guidPropSet );
    stm.PutULong( _psProperty.ulKind );

    switch( _psProperty.ulKind )
    {
    case PRSPEC_PROPID:
        stm.PutULong( _psProperty.propid );
        break;

    case PRSPEC_LPWSTR:
    {
        ULONG cc = wcslen( _psProperty.lpwstr );
        stm.PutULong( cc );
        stm.PutWChar( _psProperty.lpwstr, cc );
        break;
    }

    default:
        Win4Assert( !"Invalid PROPSPEC" );
        break;
    }
}

CFullPropSpec::CFullPropSpec( PDeSerStream & stm )
{
    stm.GetGUID( _guidPropSet );
    _psProperty.ulKind = stm.GetULong();

    switch( _psProperty.ulKind )
    {
    case PRSPEC_PROPID:
        _psProperty.propid = stm.GetULong();
        break;

    case PRSPEC_LPWSTR:
    {
        _psProperty.lpwstr = UnMarshallWideString( stm );
        break;
    }

    default:
        Win4Assert( !"Invalid PROPSPEC" );

        // Make the fullpropspec look invalid, so the later check fails.

        _psProperty.ulKind = PRSPEC_LPWSTR;
        _psProperty.lpwstr = 0;
        break;
    }
}

void CFullPropSpec::SetProperty( PROPID pidProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

BOOL CFullPropSpec::SetProperty( WCHAR const * wcsProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_LPWSTR;

    int len = (wcslen( wcsProperty ) + 1) * sizeof( WCHAR );

    _psProperty.lpwstr = (WCHAR *)CoTaskMemAlloc( len );

    if ( 0 != _psProperty.lpwstr )
    {
        memcpy( _psProperty.lpwstr,
                wcsProperty,
                len );
        return( TRUE );
    }
    else
    {
        _psProperty.lpwstr = 0;
        return( FALSE );
    }
}


//
// Methods for CColumns
//

CColumns::CColumns( unsigned size )
        : _size( size ),
          _cCol( 0 ),
          _aCol( 0 )
{
    Win4Assert( OFFSETS_MATCH( COLUMNSET, cCol, CColumns, _cCol ) );
    Win4Assert( OFFSETS_MATCH( COLUMNSET, aCol, CColumns, _aCol ) );

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    if ( _size == 0 )
        _size = 8;

    _aCol = new CFullPropSpec [ _size ];

    memset( _aCol, PRSPEC_PROPID, _size * sizeof( CFullPropSpec ) );
}

CColumns::CColumns( CColumns const & src )
       : _size( src._cCol ),
         _cCol( 0 )
{
    Win4Assert( OFFSETS_MATCH( COLUMNSET, cCol, CColumns, _cCol ) );
    Win4Assert( OFFSETS_MATCH( COLUMNSET, aCol, CColumns, _aCol ) );

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    if ( _size == 0 )
        _size = 1;

    _aCol = new CFullPropSpec [ _size ];

    if ( 0 == _aCol )
        THROW( CException( E_OUTOFMEMORY ) );

    memset( _aCol, PRSPEC_PROPID, _size * sizeof( CFullPropSpec ) );

    // Add does not throw since the array has been sized already

    while ( _cCol < src._cCol )
    {
        Add( src.Get( _cCol ), _cCol );
        if ( !Get( _cCol-1 ).IsValid() )
        {
            delete [] _aCol;
            _aCol = 0;
            THROW( CException( E_OUTOFMEMORY ) );
        }
    }
}

CColumns::~CColumns()
{
    delete [] _aCol;
}

void CColumns::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _cCol );

    for ( unsigned i = 0; i < _cCol; i++ )
    {
        _aCol[i].Marshall( stm );
    }
}

CColumns::CColumns( PDeSerStream & stm )
{
    _size = stm.GetULong();

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    // Guard against attack

    if ( _size == 0 )
        _size = 1;
    else if ( _size > 1000 )
        THROW( CException( E_INVALIDARG ) );

    XArray< CFullPropSpec > xCol( _size );

    _aCol = xCol.GetPointer();

    for( _cCol = 0; _cCol < _size; _cCol++ )
    {
        CFullPropSpec ps(stm);
        Add( ps, _cCol );
    }

    xCol.Acquire();
}

void CColumns::Add( CFullPropSpec const & Property, unsigned pos )
{
    if ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 8;
        while ( pos >= cNew )
            cNew = cNew * 2;

        CFullPropSpec * aNew = new CFullPropSpec[cNew];

        if ( _aCol )
        {
            memcpy( aNew, _aCol, _cCol * sizeof( CFullPropSpec ) );
            memset( _aCol, PRSPEC_PROPID, _size * sizeof CFullPropSpec );
            delete [] _aCol;
        }

        memset( aNew + _cCol, PRSPEC_PROPID, (cNew - _cCol) * sizeof( CFullPropSpec ) );

        _aCol = aNew;
        _size = cNew;
    }

    _aCol[pos] = Property;

    if ( pos >= _cCol )
        _cCol = pos + 1;
}

void CColumns::Remove( unsigned pos )
{
    if ( pos < _cCol )
    {
        _aCol[pos].CFullPropSpec::~CFullPropSpec();

        _cCol--;
        RtlMoveMemory( _aCol + pos,
                 _aCol + pos + 1,
                 (_cCol - pos) * sizeof( CFullPropSpec ) );
    }
}

//
// Methods for CSort
//

CSort::CSort( unsigned size )
        : _size( size ),
          _csk( 0 ),
          _ask( 0 )
{
    Win4Assert( OFFSETS_MATCH( SORTSET, cCol, CSort, _csk ) );
    Win4Assert( OFFSETS_MATCH( SORTSET, aCol, CSort, _ask ) );

    if ( _size > 0 )
    {
        _ask = new CSortKey[_size];

        memset( _ask, PRSPEC_PROPID, _size * sizeof( CSortKey ) );
    }
}

CSort::CSort( CSort const & src )
       : _size( src._csk ),
         _csk( 0 ),
         _ask( 0 )
{
    Win4Assert( OFFSETS_MATCH( SORTSET, cCol, CSort, _csk ) );
    Win4Assert( OFFSETS_MATCH( SORTSET, aCol, CSort, _ask ) );

    if ( _size > 0 )
    {
        _ask = new CSortKey[ _size ];

        memset( _ask, PRSPEC_PROPID, _size * sizeof( CSortKey ) );
        while( _csk < src._csk )
        {
            Add( src.Get( _csk ), _csk );
        }
    }
}

void CSortKey::Marshall( PSerStream & stm ) const
{
    //
    // NOTE: Order is important!
    //

    _property.Marshall( stm );
    stm.PutULong( _dwOrder );
}

CSortKey::CSortKey( PDeSerStream & stm )
        : _property( stm ),
          _dwOrder( stm.GetULong() )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

CSort::~CSort()
{
    delete [] _ask;
}

void CSort::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _csk );

    for ( unsigned i = 0; i < _csk; i++ )
    {
        _ask[i].Marshall( stm );
    }
}

CSort::CSort( PDeSerStream & stm )
        : _csk( stm.GetULong() ),
          _size( _csk )
{
    XPtr<CSortKey> xSortKey( new CSortKey[ _csk ] );

    _ask = xSortKey.GetPointer();

    for ( unsigned i = 0; i < _csk; i++ )
    {
        CSortKey sk( stm );

        Add( sk, i );
    }

    xSortKey.Acquire();
}

void CSort::Add( CSortKey const & sk, unsigned pos )
{
    if ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 4;
        while ( pos >= cNew )
        {
            cNew = cNew * 2;    
        }

        CSortKey * aNew = new CSortKey[ cNew ];

        if ( _ask )
        {
            memcpy( aNew, _ask, _csk * sizeof( CSortKey ) );
            memset( _ask, PRSPEC_PROPID, _size * sizeof CSortKey );
            delete [] _ask;
        }

        memset( aNew + _csk, PRSPEC_PROPID, (cNew - _csk) * sizeof( CSortKey ) );

        _ask = aNew;
        _size = cNew;
    }

    _ask[pos] = sk;

    if ( !_ask[pos].IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    if ( pos >= _csk )
    {
        _csk = pos + 1;
    }
}


void CSort::Add( CFullPropSpec const & property, ULONG dwOrder, unsigned pos )
{
    CSortKey sk( property, dwOrder );

    Add(sk, pos);
}

void CSort::Remove( unsigned pos )
{
    if ( pos < _csk )
    {
        _ask[pos].GetProperty().CFullPropSpec::~CFullPropSpec();
        _csk--;
        RtlMoveMemory( _ask + pos,
                       _ask + pos + 1,
                       (_csk - pos) * sizeof( CSortKey ) );
    }
}

//
// Methods for CRestriction
//

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::~CRestriction(), public
//
//  Synopsis:   Destroy restriction.  See Notes below.
//
//  History:    31-Dec-92 KyleP     Created
//
//  Notes:      This destructor simulates virtual destruction.  A
//              virtual destructor is not possible in CRestriction
//              because it maps directly to the C structure SRestriction.
//
//              Classes derived from CRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//--------------------------------------------------------------------------

CRestriction::~CRestriction()
{
    //
    // It would be nice to assert in constructor but it's inline and
    // Win4Assert is not a public export.
    //

    Win4Assert( OFFSETS_MATCH( RESTRICTION, rt, CRestriction, _ulType ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, weight,
                               CRestriction, _lWeight ) );

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:

        CastToNode()->CNodeRestriction::~CNodeRestriction();
        break;

    case RTNot:
        ((CNotRestriction *)this)->
            CNotRestriction::~CNotRestriction();
        break;

    case RTProperty:
        ((CPropertyRestriction *)this)->
            CPropertyRestriction::~CPropertyRestriction();
        break;

    case RTContent:
        ((CContentRestriction *)this)->
            CContentRestriction::~CContentRestriction();
        break;

    case RTNatLanguage:
        ((CNatLanguageRestriction *)this)->
            CNatLanguageRestriction::~CNatLanguageRestriction();
        break;

    case RTScope:
        ((CScopeRestriction *)this)->CScopeRestriction::~CScopeRestriction();
        break;

    case RTWord:
        ((CWordRestriction *)this)->CWordRestriction::~CWordRestriction();
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->CSynRestriction::~CSynRestriction();
        break;

    case RTRange:
        ((CRangeRestriction *)this)->CRangeRestriction::~CRangeRestriction();
        break;

    case RTInternalProp:
        ((CInternalPropertyRestriction *)this)->
            CInternalPropertyRestriction::~CInternalPropertyRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::TreeCount(), public
//
//  Synopsis:   Returns the number of items in the tree
//
//  History:    15-Jul-96 dlee     Created
//
//--------------------------------------------------------------------------

ULONG CRestriction::TreeCount() const
{
    ULONG cItems = 1;

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:
    {
        CNodeRestriction * p = CastToNode();
        for ( ULONG x = 0; x < p->Count(); x++ )
        {
            cItems += p->GetChild( x )->TreeCount();
        }
        break;
    }
    case RTNot:
    {
        CNotRestriction * p = (CNotRestriction *) this;

        cItems += p->GetChild()->TreeCount();
        break;
    }

    case RTProperty:
    case RTContent:
    case RTNatLanguage:
    case RTScope:
    case RTWord:
    case RTSynonym:
    case RTRange:
    case RTInternalProp:
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }

    return cItems;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL CRestriction::IsValid() const
{
    BOOL fValid = TRUE;

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:

        fValid = CastToNode()->CNodeRestriction::IsValid();
        break;

    case RTNot:
        fValid = ((CNotRestriction *)this)->
            CNotRestriction::IsValid();
        break;

    case RTProperty:
        fValid = ((CPropertyRestriction *)this)->
            CPropertyRestriction::IsValid();
        break;

    case RTContent:
        fValid = ((CContentRestriction *)this)->
            CContentRestriction::IsValid();
        break;

    case RTNatLanguage:
        fValid = ((CNatLanguageRestriction *)this)->
            CNatLanguageRestriction::IsValid();
        break;

    case RTScope:
        fValid = ((CScopeRestriction *)this)->
            CScopeRestriction::IsValid();
        break;

    case RTWord:
        fValid = ((CWordRestriction *)this)->
            CWordRestriction::IsValid();
        break;

    case RTSynonym:
        fValid = ((CSynRestriction *)this)->
            CSynRestriction::IsValid();
        break;

    case RTRange:
        fValid = ((CRangeRestriction *)this)->
            CRangeRestriction::IsValid();
        break;

    case RTInternalProp:
        fValid = ((CInternalPropertyRestriction *)this)->
            CInternalPropertyRestriction::IsValid();
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        fValid = FALSE;
        break;
    }

    return fValid;
}

void CRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Type() );
    stm.PutLong( Weight() );

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTPhrase:
        ((CNodeRestriction *)this)->Marshall( stm );
        break;

    case RTVector:
        ((CVectorRestriction *)this)->Marshall( stm );
        break;

    case RTNot:
        ((CNotRestriction *)this)->Marshall( stm );
        break;

    case RTProperty:
        ((CPropertyRestriction *)this)->Marshall( stm );
        break;

    case RTContent:
        ((CContentRestriction *)this)->Marshall( stm );
        break;

    case RTNatLanguage:
        ((CNatLanguageRestriction *)this)->Marshall( stm );
        break;

    case RTScope:
        ((CScopeRestriction *)this)->Marshall( stm );
        break;

    case RTWord:
    case RTSynonym:
        ((COccRestriction *)this)->Marshall( stm );
        break;

    case RTRange:
        ((CRangeRestriction *)this)->Marshall( stm );
        break;

    case RTInternalProp:
        ((CInternalPropertyRestriction *)this)->Marshall( stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }
}

CRestriction * CRestriction::UnMarshall( PDeSerStream & stm )
{
    ULONG ulType = stm.GetULong();
    LONG  lWeight = stm.GetLong();

    switch ( ulType )
    {
    case RTNone:
        return new CRestriction( ulType, lWeight );

    case RTAnd:
    case RTOr:
    case RTProximity:
        return new CNodeRestriction( ulType, lWeight, stm );
        break;

    case RTPhrase:
        return new CPhraseRestriction( lWeight, stm );
        break;

    case RTVector:
        return new CVectorRestriction( lWeight, stm );
        break;

    case RTNot:
        return new CNotRestriction( lWeight, stm );
        break;

    case RTProperty:
        return new CPropertyRestriction( lWeight, stm );
        break;

    case RTContent:
        return new CContentRestriction( lWeight, stm );
        break;

    case RTNatLanguage:
        return new CNatLanguageRestriction( lWeight, stm );
        break;

    case RTScope:
        return new CScopeRestriction( lWeight, stm );
        break;

    case RTWord:
        return new CWordRestriction( lWeight, stm );
        break;

    case RTSynonym:
        return new CSynRestriction( lWeight, stm );
        break;

    case RTRange:
        return new CRangeRestriction( lWeight, stm );
        break;

    case RTInternalProp:
        return new CInternalPropertyRestriction( lWeight, stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction during unmarshalling\n",
                     ulType ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        THROW( CException( E_INVALIDARG ) );
        break;
    }

    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::IsLeaf, public
//
//  Returns:    TRUE if node is a leaf node
//
//  History:    12-Feb-93 KyleP     Moved from .hxx
//
//--------------------------------------------------------------------------

BOOL CRestriction::IsLeaf() const
{
    switch( Type() )
    {
    case RTAnd:
    case RTOr:
    case RTNot:
    case RTProximity:
    case RTVector:
    case RTPhrase:
        return( FALSE );

    default:
        return( TRUE );
    }
}


CRestriction *CRestriction::Clone() const
{
    switch ( Type() )
    {
    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTPhrase:
        return ( (CNodeRestriction *) this)->Clone();

    case RTVector:
        return ( (CVectorRestriction *) this)->Clone();

    case RTNot:
        return ( (CNotRestriction *) this)->Clone();

    case RTInternalProp:
        return ( (CInternalPropertyRestriction *) this)->Clone();

    case RTContent:
        return ( (CContentRestriction *) this)->Clone();

    case RTWord:
        return ( (CWordRestriction *) this)->Clone();

    case RTSynonym:
        return ( (CSynRestriction *) this)->Clone();

    case RTRange:
        return( (CRangeRestriction *) this)->Clone();

    case RTScope:
        return ((CScopeRestriction *) this)->Clone();

    case RTNone:
        return new CRestriction;

    default:
        ciDebugOut(( DEB_ERROR, "No clone method for restriction type - %d\n", Type() ));
        Win4Assert( !"CRestriction: Clone method should be overridden in child class" );

        return 0;
    }
}

CNodeRestriction::CNodeRestriction( ULONG NodeType,
                                    unsigned cInitAllocated )
        : CRestriction( NodeType, MAX_QUERY_RANK ),
          _cNode( 0 ),
          _paNode( 0 ),
          _cNodeAllocated( cInitAllocated )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    if ( _cNodeAllocated > 0 )
    {
        _paNode = new CRestriction * [ _cNodeAllocated ];
    }
}

CNodeRestriction::CNodeRestriction( const CNodeRestriction& nodeRst )
    : CRestriction( nodeRst.Type(), nodeRst.Weight() ),
      _cNode( nodeRst.Count() ),
      _cNodeAllocated( nodeRst.Count() ),
      _paNode( 0 )
{
    if ( _cNodeAllocated > 0 )
    {
        _paNode = new CRestriction * [ _cNodeAllocated ];
        RtlZeroMemory( _paNode, _cNodeAllocated * sizeof( CRestriction * ) );

        for ( unsigned i=0; i<_cNode; i++ )
            _paNode[i] = nodeRst.GetChild( i )->Clone();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNodeRestriction::~CNodeRestriction(), public
//
//  Synopsis:   Destroy node restriction.  See Notes below.
//
//  History:    31-Dec-92 KyleP     Created
//
//  Notes:      This destructor simulates virtual destruction.  A
//              virtual destructor is not possible in CNodeRestriction
//              because it maps directly to a C structure.
//
//              Classes derived from CNodeRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//--------------------------------------------------------------------------

CNodeRestriction::~CNodeRestriction()
{
    switch( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    {
        if ( 0 != _paNode )
        {
            for ( unsigned i = 0; i < _cNode; i++ )
                delete _paNode[i];

            delete [] _paNode;
        }

        SetType( RTNone );                  // Avoid recursion.
        break;
    }

    case RTPhrase:
        (( CPhraseRestriction *)this)->CPhraseRestriction::~CPhraseRestriction();
        break;

    case RTScope:
        (( CScopeRestriction *)this)->CScopeRestriction::~CScopeRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class CNodeRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class CNodeRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNodeRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL CNodeRestriction::IsValid() const
{
    if ( 0 == _paNode )
        return FALSE;

    for ( unsigned i = 0; i < _cNode; i++ )
    {
        if ( 0 == _paNode[i] || !_paNode[i]->IsValid() )
            return FALSE;
    }

    return TRUE;
}

void CNodeRestriction::Marshall( PSerStream & stm ) const
{
#if CIDBG == 1
    if ( Type() == RTPhrase )
    {
        for ( unsigned i = 0; i < _cNode; i++ )
            Win4Assert( _paNode[i]->Type() == RTWord || _paNode[i]->Type() == RTSynonym );
    }
#endif

    stm.PutULong( _cNode );
    for ( unsigned i = 0; i < _cNode; i++ )
    {
        _paNode[i]->Marshall( stm );
    }
}

CNodeRestriction::CNodeRestriction( ULONG ulType, LONG lWeight, PDeSerStream & stm )
        : CRestriction( ulType, lWeight ),
          _cNode( 0 ),
          _paNode( 0 ),
          _cNodeAllocated( 0 )
{
    ULONG cNodeAllocated = stm.GetULong();

    // Note: this is an arbitrary limit intended to protect against attack

    if ( cNodeAllocated > 65536 )
        THROW( CException( E_INVALIDARG ) );

    _cNodeAllocated = cNodeAllocated;

    //
    // Note: the destructor will be called if the constructor doesn't finish,
    // from ~CRestriction.  So _paNode will be freed if AddChild fails.
    //

    _paNode = new CRestriction * [ _cNodeAllocated ];

    RtlZeroMemory( _paNode, _cNodeAllocated * sizeof( CRestriction * ) );

    for ( unsigned i = 0; i < _cNodeAllocated; i++ )
        AddChild( CRestriction::UnMarshall( stm ) );
}

void CNodeRestriction::AddChild( CRestriction * presChild, unsigned & pos )
{
    if ( _cNode == _cNodeAllocated )
        Grow();

    _paNode[_cNode] = presChild;
    pos = _cNode;
    _cNode++;
}

CRestriction * CNodeRestriction::RemoveChild( unsigned pos )
{
    if ( pos < _cNode )
    {
        CRestriction * prstRemoved = _paNode[pos];

        //
        // A memcpy would be nice, but is dangerous with overlapping
        // regions.
        //

        for ( pos++; pos < _cNode; pos++ )
        {
            _paNode[pos-1] = _paNode[pos];
        }

        _cNode--;

        return( prstRemoved );
    }
    else
    {
        return( 0 );
    }
}

void CNodeRestriction::Grow()
{
    int count = (_cNodeAllocated != 0) ? _cNodeAllocated * 2 : 2;

    CRestriction ** paNew= new CRestriction * [ count ];
    RtlZeroMemory( paNew, count * sizeof( CRestriction * ) );

    memcpy( paNew, _paNode, _cNode * sizeof( CRestriction * ) );

    delete (BYTE *) _paNode;

    _paNode = paNew;
    _cNodeAllocated = count;
}

CNodeRestriction *CNodeRestriction::Clone() const
{
    return new CNodeRestriction( *this );
}

CNotRestriction::CNotRestriction( CNotRestriction const & notRst )
    : CRestriction( RTNot, notRst.Weight() ),
      _pres( 0 )
{
    CRestriction *pChildRst = notRst.GetChild();

    if ( pChildRst )
        _pres = pChildRst->Clone();
}


CNotRestriction::~CNotRestriction()
{
    delete _pres;
    SetType( RTNone );                  // Avoid recursion.
}

void CNotRestriction::Marshall( PSerStream & stm ) const
{
    _pres->Marshall( stm );
}

CNotRestriction::CNotRestriction( LONG lWeight, PDeSerStream & stm )
        : CRestriction( RTNot, lWeight ),
          _pres( 0 )
{
    _pres = CRestriction::UnMarshall( stm );
}

CNotRestriction *CNotRestriction::Clone() const
{
    return new CNotRestriction( *this );
}


void CVectorRestriction::Marshall( PSerStream & stm ) const
{
    CNodeRestriction::Marshall( stm );
    stm.PutULong( _ulRankMethod );
}

CVectorRestriction::CVectorRestriction( LONG lWeight, PDeSerStream & stm )
        : CNodeRestriction( RTVector, lWeight, stm ),
          _ulRankMethod( stm.GetULong() )
{
}


CVectorRestriction *CVectorRestriction::Clone() const
{
    return new CVectorRestriction( *this );
}

CContentRestriction::CContentRestriction( WCHAR const * pwcsPhrase,
                                          CFullPropSpec const & Property,
                                          ULONG ulGenerateMethod,
                                          LCID lcid )

    : CRestriction( RTContent, MAX_QUERY_RANK ),
      _pwcsPhrase( 0 ),
      _Property( Property ),
      _lcid( lcid ),
      _ulGenerateMethod( ulGenerateMethod )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.prop,
                               CContentRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.pwcsPhrase,
                               CContentRestriction, _pwcsPhrase ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.lcid,
                               CContentRestriction, _lcid ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.ulGenerateMethod,
                               CContentRestriction, _ulGenerateMethod ) );

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    SetPhrase( pwcsPhrase );
}

CContentRestriction::CContentRestriction( CContentRestriction const & contentRst )
    : CRestriction( RTContent, contentRst.Weight() ),
      _pwcsPhrase( 0 ),
      _Property( contentRst.GetProperty() ),
      _lcid( contentRst.GetLocale() ),
      _ulGenerateMethod( contentRst.GenerateMethod() )
{
    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
    SetPhrase( contentRst.GetPhrase() );
}

CContentRestriction::~CContentRestriction()
{
    delete [] _pwcsPhrase;

    SetType( RTNone );                  // Avoid recursion.
}

void CContentRestriction::Marshall( PSerStream & stm ) const
{
    _Property.Marshall( stm );
    ULONG cc = wcslen( _pwcsPhrase );
    stm.PutULong( cc );
    stm.PutWChar( _pwcsPhrase, cc );
    stm.PutULong( _lcid );
    stm.PutULong( _ulGenerateMethod );
}

CContentRestriction::CContentRestriction( LONG lWeight, PDeSerStream & stm )
    : CRestriction( RTContent, lWeight ),
      _Property( stm )
{
    // set to 0 in case allocation fails, since ~CRestriction will call
    // ~CNatLanguageRestriction

    _pwcsPhrase = 0;

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    XPtrST<WCHAR> xPhrase( UnMarshallWideStringNew( stm ) );

    _lcid = stm.GetULong();
    _ulGenerateMethod = stm.GetULong();

    _pwcsPhrase = xPhrase.Acquire();
}

void CContentRestriction::SetPhrase( WCHAR const * pwcsPhrase )
{
    delete [] _pwcsPhrase;
    _pwcsPhrase = 0;

    int len = ( wcslen( pwcsPhrase ) + 1 ) * sizeof( WCHAR );

    _pwcsPhrase = new WCHAR[len];
    memcpy( _pwcsPhrase, pwcsPhrase, len );
}


CContentRestriction *CContentRestriction::Clone() const
{
    return new CContentRestriction( *this );
}

CNatLanguageRestriction::CNatLanguageRestriction( WCHAR const * pwcsPhrase,
                                                  CFullPropSpec const & Property,
                                                  LCID lcid )
    : CRestriction( RTNatLanguage, MAX_QUERY_RANK ),
      _pwcsPhrase( 0 ),
      _Property( Property ),
      _lcid( lcid )
{
    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.prop,
                               CNatLanguageRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.pwcsPhrase,
                               CNatLanguageRestriction, _pwcsPhrase ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.lcid,
                               CNatLanguageRestriction, _lcid ) );

    SetPhrase( pwcsPhrase );
}

CNatLanguageRestriction::~CNatLanguageRestriction()
{
    delete [] _pwcsPhrase;

    SetType( RTNone );                  // Avoid recursion.
}

void CNatLanguageRestriction::Marshall( PSerStream & stm ) const
{
    _Property.Marshall( stm );
    ULONG cc = wcslen( _pwcsPhrase );
    stm.PutULong( cc );
    stm.PutWChar( _pwcsPhrase, cc );
    stm.PutULong( _lcid );
}

CNatLanguageRestriction::CNatLanguageRestriction( LONG lWeight, PDeSerStream & stm )
    : CRestriction( RTNatLanguage, lWeight ),
      _Property( stm )
{
    // set to 0 in case allocation fails, since ~CRestriction will call
    // ~CNatLanguageRestriction

    _pwcsPhrase = 0;

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    XPtrST<WCHAR> xPhrase( UnMarshallWideStringNew( stm ) );

    _lcid = stm.GetULong();

    _pwcsPhrase = xPhrase.Acquire();
}

void CNatLanguageRestriction::SetPhrase( WCHAR const * pwcsPhrase )
{
    delete [] _pwcsPhrase;
    _pwcsPhrase = 0;

    int len = ( wcslen( pwcsPhrase ) + 1 ) * sizeof( WCHAR );

    _pwcsPhrase = new WCHAR[len];

    RtlCopyMemory( _pwcsPhrase, pwcsPhrase, len );
}


CPropertyRestriction::CPropertyRestriction()
        : CRestriction( RTProperty, MAX_QUERY_RANK )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.rel,
                               CPropertyRestriction, _relop ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prop,
                               CPropertyRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prval,
                               CPropertyRestriction, _prval ) );
}

CPropertyRestriction::CPropertyRestriction( ULONG relop,
                                            CFullPropSpec const & Property,
                                            CStorageVariant const & prval )
        : CRestriction( RTProperty, MAX_QUERY_RANK ),
          _relop( relop ),
          _Property( Property ),
          _prval( prval )
{
    if ( !_Property.IsValid() ||
         !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.rel,
                               CPropertyRestriction, _relop ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prop,
                               CPropertyRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prval,
                               CPropertyRestriction, _prval ) );

}

CPropertyRestriction::~CPropertyRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CPropertyRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _relop );
    _Property.Marshall( stm );
    _prval.Marshall( stm );
}

CPropertyRestriction::CPropertyRestriction( LONG lWeight, PDeSerStream & stm )
        : CRestriction( RTProperty, lWeight ),
          _relop( stm.GetULong() ),
          _Property( stm ),
          _prval( stm )
{
    if ( !_Property.IsValid() ||
         !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

void CPropertyRestriction::SetValue( WCHAR * pwcsValue )
{
    _prval = pwcsValue;
}

void CPropertyRestriction::SetValue( BLOB & bValue )
{
    _prval = bValue;
}

void CPropertyRestriction::SetValue( GUID * pguidValue )
{
    _prval = pguidValue;
}

CSortKey::CSortKey( CFullPropSpec const & ps, ULONG dwOrder )
        : _property( ps ),
          _dwOrder( dwOrder )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

CSortKey::CSortKey( CFullPropSpec const & ps, ULONG dwOrder, LCID locale )
        : _property( ps ),
          _dwOrder( dwOrder ),
          _locale ( locale )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\pidmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       pidmap.cxx
//
//  Contents:   Maps pid <--> property name.
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>

IMPL_DYNARRAY( CPropNameArrayBase, CFullPropSpec );

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CPropNameArray::CPropNameArray(unsigned size)
        : CPropNameArrayBase( size )
{
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPropNameArray::Marshall( PSerStream & stm ) const
{
    //
    // Compute # non-zero items
    //

    for ( unsigned len = 0; len < Size(); len++ )
    {
        if ( 0 == Get(len) )
            break;
    }

    stm.PutULong( len );

    for ( unsigned i = 0; i < len; i++ )
    {
        Get(i)->Marshall( stm );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CPropNameArray::CPropNameArray( PDeSerStream & stm )
        : CPropNameArrayBase( 0 )
{
    ULONG cItems = stm.GetULong();

    // Guard against attack

    if ( 0 == cItems || cItems > 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cItems );

    for ( unsigned i = 0; i < cItems; i++ )
    {
        CFullPropSpec * pps = new CFullPropSpec( stm );

        XPtr<CFullPropSpec> xpps(pps);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        Add( pps, i);
        xpps.Acquire();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidMapper::NameToPid, public
//
//  Arguments:  [wcsProperty] -- Property name
//
//  Returns:    'fake' (pid) for [wcsProperty].
//
//  History:    31-Jan-93   KyleP       Created
//
//--------------------------------------------------------------------------

PROPID CPidMapper::NameToPid( CFullPropSpec const & Property )
{
    if ( !Property.IsValid() )
        return pidInvalid;

    //
    // Just linear search the array.  It should be small.
    //

    for ( int i = Count() - 1; i >= 0; i-- )
    {
        Win4Assert( Get(i) != 0 );
        if ( *Get( i ) == Property )
        {
            return( i );
        }
    }

    //
    // Wasn't in array. Add.
    //

    CFullPropSpec * ppsFull = new CFullPropSpec( Property );

    XPtr<CFullPropSpec> xpps(ppsFull);

    if ( xpps.IsNull() || !xpps->IsValid() )
    {
        THROW( CException( STATUS_NO_MEMORY ) );
    }

    PROPID pidNew = Count();

    Add( ppsFull, pidNew );
    xpps.Acquire();

    _apidReal[pidNew] = pidInvalid;

    return pidNew;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidMapper::PidToRealPid, public
//
//  Synopsis:   Converts a fake (index) pid to real pid.
//
//  Arguments:  [pidFake] -- Fake (index) pid
//
//  Returns:    Real pid
//
//  History:    30-Dec-1997   KyleP       Created
//
//--------------------------------------------------------------------------

PROPID CPidMapper::PidToRealPid( PROPID pidFake )
{
    if ( pidInvalid == _apidReal[pidFake] )
    {
         Win4Assert( 0 != _pPidConverter );

         SCODE sc = _pPidConverter->FPSToPROPID( *Get(pidFake), _apidReal[pidFake] );

         if ( FAILED(sc) )
         {
             THROW( CException( sc ) );
         }

         #if CIDBG == 1
         if ( vqInfoLevel & DEB_ITRACE )
         {
             CFullPropSpec const & ps = *Get(pidFake);

             GUID const & guid = ps.GetPropSet();

             char szGuid[50];

             sprintf( szGuid,
                      "%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                      guid.Data1,
                      guid.Data2,
                      guid.Data3,
                      guid.Data4[0], guid.Data4[1],
                      guid.Data4[2], guid.Data4[3],
                      guid.Data4[4], guid.Data4[5],
                      guid.Data4[6], guid.Data4[7] );

             vqDebugOut(( DEB_ITRACE, szGuid ));

             if ( ps.IsPropertyName() )
                 vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                              "%ws ",
                              ps.GetPropertyName() ));
             else
                 vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                              "0x%x ",
                              ps.GetPropertyPropid() ));

             vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, " --> pid 0x%x\n",
                          _apidReal[pidFake] ));

         }
         #endif // CIDBG == 1
    }

    return _apidReal[pidFake];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\stgvar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVar.cxx
//
//  Contents:   C++ wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              01-Apr-95 t-ColinB  Added definitions for vector related
//                                  SetValue() members
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

CCoTaskAllocator CoTaskAllocator; // exported data definition

void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return(CoTaskMemAlloc(cbSize));
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

#define VECTOR_SET_BODY( type, vtype )                                    \
                                                                          \
void CStorageVariant::Set##vtype (                                        \
    type val,                                                             \
    unsigned pos )                                                        \
{                                                                         \
    CAllocStorageVariant::Set##vtype( val, pos, CoTaskAllocator );        \
}

VECTOR_SET_BODY( CHAR, I1 );
VECTOR_SET_BODY( BYTE, UI1 );
VECTOR_SET_BODY( short, I2 );
VECTOR_SET_BODY( USHORT, UI2 );
VECTOR_SET_BODY( long,  I4 );
VECTOR_SET_BODY( ULONG,  UI4 );
VECTOR_SET_BODY( SCODE,  ERROR );
VECTOR_SET_BODY( LARGE_INTEGER, I8 );
VECTOR_SET_BODY( ULARGE_INTEGER, UI8 );
VECTOR_SET_BODY( float,  R4 );
VECTOR_SET_BODY( double, R8 );
VECTOR_SET_BODY( VARIANT_BOOL, BOOL );
VECTOR_SET_BODY( CY, CY );
VECTOR_SET_BODY( DATE, DATE );
VECTOR_SET_BODY( char const *, LPSTR );
VECTOR_SET_BODY( WCHAR const *, LPWSTR );
VECTOR_SET_BODY( BSTR, BSTR );
VECTOR_SET_BODY( FILETIME, FILETIME );
VECTOR_SET_BODY( CLSID, CLSID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\advquery\disptree.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// FILE:     disptree.cxx
//
// PURPOSE:  Displays a command tree, for debugging.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayVariant
//
//  Synopsis:   Displays a PROPVARIANT.  This is not a complete
//              implementation; many VT_ types are not complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayVariant( PROPVARIANT * pVar )
{
    if ( 0 == pVar )
    {
        printf( "NULL" );
        return;
    }

    PROPVARIANT & v = *pVar;

    switch ( v.vt )
    {
        case VT_I4 : printf( "VT_I4 %d", v.lVal ); break;
        case VT_UI1 : printf( "VT_UI1 %d", v.bVal ); break;
        case VT_I2 : printf( "VT_I2 %d", v.iVal ); break;
        case VT_R4 : printf( "VT_R4 %f", v.fltVal ); break;
        case VT_R8 : printf( "VT_R8 %lf", v.dblVal ); break;
        case VT_BOOL : printf( "VT_BOOL %d", v.boolVal ); break;
        case VT_ERROR : printf( "VT_ERROR %#x", v.scode ); break;
        case VT_CY :
        {
            double dbl;
            VarR8FromCy( pVar->cyVal, &dbl );

            printf( "VT_CY %lf", dbl );
            break;
        }
        case VT_DATE : printf( "VT_DATE " ); break;
        case VT_FILETIME : printf( "VT_FILETIME %#I64x ", v.filetime ); break;
        case VT_BSTR : printf( "VT_BSTR '%ws'", v.bstrVal ); break;
        case VT_UNKNOWN : printf( "VT_UNKNOWN " ); break;
        case VT_DISPATCH : printf( "VT_DISPATCH " ); break;
        case VT_BYREF|VT_UI1 : printf( "VT_BYREF|VT_UI1 " ); break;
        case VT_BYREF|VT_I2 : printf( "VT_BYREF|VT_I2 " ); break;
        case VT_BYREF|VT_I4 : printf( "VT_BYREF|VT_I4 " ); break;
        case VT_BYREF|VT_R4 : printf( "VT_BYREF|VT_R4 " ); break;
        case VT_BYREF|VT_R8 : printf( "VT_BYREF|VT_R8 " ); break;
        case VT_BYREF|VT_BOOL : printf( "VT_BYREF|VT_BOOL " ); break;
        case VT_BYREF|VT_ERROR : printf( "VT_BYREF|VT_ERROR " ); break;
        case VT_BYREF|VT_CY : printf( "VT_BYREF|VT_CY " ); break;
        case VT_BYREF|VT_DATE : printf( "VT_BYREF|VT_DATE " ); break;
        case VT_BYREF|VT_BSTR : printf( "VT_BYREF|VT_BSTR " ); break;
        case VT_BYREF|VT_UNKNOWN : printf( "VT_BYREF|VT_UNKNOWN " ); break;
        case VT_BYREF|VT_DISPATCH : printf( "VT_BYREF|VT_DISPATCH " ); break;
        case VT_BYREF|VT_ARRAY : printf( "VT_BYREF|VT_ARRAY " ); break;
        case VT_BYREF|VT_VARIANT : printf( "VT_BYREF|VT_VARIANT " ); break;
        case VT_I1 : printf( "VT_I1 %d", v.bVal ); break;
        case VT_UI2 : printf( "VT_UI2 %u", v.uiVal ); break;
        case VT_UI4 : printf( "VT_UI4 %u", v.ulVal ); break;
        case VT_INT : printf( "VT_INT %d", v.lVal ); break;
        case VT_UINT : printf( "VT_UINT %u", v.ulVal ); break;
        case VT_BYREF|VT_DECIMAL : printf( "VT_BYREF|VT_DECIMAL " ); break;
        case VT_BYREF|VT_I1 : printf( "VT_BYREF|VT_I1 " ); break;
        case VT_BYREF|VT_UI2 : printf( "VT_BYREF|VT_UI2 " ); break;
        case VT_BYREF|VT_UI4 : printf( "VT_BYREF|VT_UI4 " ); break;
        case VT_BYREF|VT_INT : printf( "VT_BYREF|VT_INT " ); break;
        case VT_BYREF|VT_UINT : printf( "VT_BYREF|VT_UINT " ); break;
        case VT_LPSTR : printf( "VT_LPSTR '%s'", v.pszVal ); break;
        case VT_LPWSTR : printf( "VT_LPWSTR '%ws'", v.pwszVal ); break;
        case VT_I8 : printf( "VT_I8 %I64d", v.hVal ); break;
        case VT_UI8 : printf( "VT_I8 %I64u", v.hVal ); break;
        case VT_VECTOR | VT_I1:
            printf( "VT_VECTOR | VT_I1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I2:
            printf( "VT_VECTOR | VT_I2 " );
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I4:
            printf( "VT_VECTOR | VT_I4 " );
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I8:
            printf( "VT_VECTOR | VT_I8 " );
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" );
            break;
        case VT_VECTOR | VT_UI1:
            printf( "VT_VECTOR | VT_UI1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI2:
            printf( "VT_VECTOR | VT_UI2 " );
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI4:
            printf( "VT_VECTOR | VT_UI4 " );
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI8:
            printf( "VT_VECTOR | VT_UI8 " );
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" );
            break;
        case VT_VECTOR | VT_BSTR:
            printf( "VT_VECTOR | VT_BSTR " );
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_LPSTR:
            printf( "VT_VECTOR | VT_LPSTR " );
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%s" );
            break;
        case VT_VECTOR | VT_LPWSTR:
            printf( "VT_VECTOR | VT_LPWSTR " );
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_R4:
            printf( "VT_VECTOR | VT_R4 " );
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" );
            break;
        case VT_VECTOR | VT_R8:
            printf( "VT_VECTOR | VT_R8 " );
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" );
            break;
        default : printf( "unknown vt %#x", v.vt );
    }
} //DisplayVariant

//+-------------------------------------------------------------------------
//
//  Function:   PrintSpace
//
//  Synopsis:   Prints white space.
//
//  Arguments:  [cPlaces] - Number of levels to print
//
//--------------------------------------------------------------------------

void PrintSpace( ULONG cPlaces )
{
    for( ULONG iPlace = 0; iPlace < cPlaces; iPlace++ )
        printf( "  " );
} //PrintSpace

//+-------------------------------------------------------------------------
//
//  Function:   DisplayCommandTree
//
//  Synopsis:   Displays the command tree, useful for debugging.  This is
//              not a complete implementation; many DBVALUEKINDs are not
//              complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayCommandTree(
    DBCOMMANDTREE * pNode,
    ULONG           iLevel )
{
    PrintSpace( iLevel );
    printf( "op: (%d) ", pNode->op );
    switch ( pNode->op )
    {
        case DBOP_scalar_constant : printf( "DBOP_scalar_constant" ); break;
        case DBOP_DEFAULT : printf( "DBOP_DEFAULT" ); break;
        case DBOP_NULL : printf( "DBOP_NULL" ); break;
        case DBOP_bookmark_name : printf( "DBOP_bookmark_name" ); break;
        case DBOP_catalog_name : printf( "DBOP_catalog_name" ); break;
        case DBOP_column_name : printf( "DBOP_column_name" ); break;
        case DBOP_schema_name : printf( "DBOP_schema_name" ); break;
        case DBOP_outall_name : printf( "DBOP_outall_name" ); break;
        case DBOP_qualifier_name : printf( "DBOP_qualifier_name" ); break;
        case DBOP_qualified_column_name : printf( "DBOP_qualified_column_name" ); break;
        case DBOP_table_name : printf( "DBOP_table_name" ); break;
        case DBOP_nested_table_name : printf( "DBOP_nested_table_name" ); break;
        case DBOP_nested_column_name : printf( "DBOP_nested_column_name" ); break;
        case DBOP_row : printf( "DBOP_row" ); break;
        case DBOP_table : printf( "DBOP_table" ); break;
        case DBOP_sort : printf( "DBOP_sort" ); break;
        case DBOP_distinct : printf( "DBOP_distinct" ); break;
        case DBOP_distinct_order_preserving : printf( "DBOP_distinct_order_preserving" ); break;
        case DBOP_alias : printf( "DBOP_alias" ); break;
        case DBOP_cross_join : printf( "DBOP_cross_join" ); break;
        case DBOP_union_join : printf( "DBOP_union_join" ); break;
        case DBOP_inner_join : printf( "DBOP_inner_join" ); break;
        case DBOP_left_semi_join : printf( "DBOP_left_semi_join" ); break;
        case DBOP_right_semi_join : printf( "DBOP_right_semi_join" ); break;
        case DBOP_left_anti_semi_join : printf( "DBOP_left_anti_semi_join" ); break;
        case DBOP_right_anti_semi_join : printf( "DBOP_right_anti_semi_join" ); break;
        case DBOP_left_outer_join : printf( "DBOP_left_outer_join" ); break;
        case DBOP_right_outer_join : printf( "DBOP_right_outer_join" ); break;
        case DBOP_full_outer_join : printf( "DBOP_full_outer_join" ); break;
        case DBOP_natural_join : printf( "DBOP_natural_join" ); break;
        case DBOP_natural_left_outer_join : printf( "DBOP_natural_left_outer_join" ); break;
        case DBOP_natural_right_outer_join : printf( "DBOP_natural_right_outer_join" ); break;
        case DBOP_natural_full_outer_join : printf( "DBOP_natural_full_outer_join" ); break;
        case DBOP_set_intersection : printf( "DBOP_set_intersection" ); break;
        case DBOP_set_union : printf( "DBOP_set_union" ); break;
        case DBOP_set_left_difference : printf( "DBOP_set_left_difference" ); break;
        case DBOP_set_right_difference : printf( "DBOP_set_right_difference" ); break;
        case DBOP_set_anti_difference : printf( "DBOP_set_anti_difference" ); break;
        case DBOP_bag_intersection : printf( "DBOP_bag_intersection" ); break;
        case DBOP_bag_union : printf( "DBOP_bag_union" ); break;
        case DBOP_bag_left_difference : printf( "DBOP_bag_left_difference" ); break;
        case DBOP_bag_right_difference : printf( "DBOP_bag_right_difference" ); break;
        case DBOP_bag_anti_difference : printf( "DBOP_bag_anti_difference" ); break;
        case DBOP_division : printf( "DBOP_division" ); break;
        case DBOP_relative_sampling : printf( "DBOP_relative_sampling" ); break;
        case DBOP_absolute_sampling : printf( "DBOP_absolute_sampling" ); break;
        case DBOP_transitive_closure : printf( "DBOP_transitive_closure" ); break;
        case DBOP_recursive_union : printf( "DBOP_recursive_union" ); break;
        case DBOP_aggregate : printf( "DBOP_aggregate" ); break;
        case DBOP_remote_table : printf( "DBOP_remote_table" ); break;
        case DBOP_select : printf( "DBOP_select" ); break;
        case DBOP_order_preserving_select : printf( "DBOP_order_preserving_select" ); break;
        case DBOP_project : printf( "DBOP_project" ); break;
        case DBOP_project_order_preserving : printf( "DBOP_project_order_preserving" ); break;
        case DBOP_top : printf( "DBOP_top" ); break;
        case DBOP_top_percent : printf( "DBOP_top_percent" ); break;
        case DBOP_top_plus_ties : printf( "DBOP_top_plus_ties" ); break;
        case DBOP_top_percent_plus_ties : printf( "DBOP_top_percent_plus_ties" ); break;
        case DBOP_rank : printf( "DBOP_rank" ); break;
        case DBOP_rank_ties_equally : printf( "DBOP_rank_ties_equally" ); break;
        case DBOP_rank_ties_equally_and_skip : printf( "DBOP_rank_ties_equally_and_skip" ); break;
        case DBOP_navigate : printf( "DBOP_navigate" ); break;
        case DBOP_nesting : printf( "DBOP_nesting" ); break;
        case DBOP_unnesting : printf( "DBOP_unnesting" ); break;
        case DBOP_nested_apply : printf( "DBOP_nested_apply" ); break;
        case DBOP_cross_tab : printf( "DBOP_cross_tab" ); break;
        case DBOP_is_NULL : printf( "DBOP_is_NULL" ); break;
        case DBOP_is_NOT_NULL : printf( "DBOP_is_NOT_NULL" ); break;
        case DBOP_equal : printf( "DBOP_equal" ); break;
        case DBOP_not_equal : printf( "DBOP_not_equal" ); break;
        case DBOP_less : printf( "DBOP_less" ); break;
        case DBOP_less_equal : printf( "DBOP_less_equal" ); break;
        case DBOP_greater : printf( "DBOP_greater" ); break;
        case DBOP_greater_equal : printf( "DBOP_greater_equal" ); break;
        case DBOP_equal_all : printf( "DBOP_equal_all" ); break;
        case DBOP_not_equal_all : printf( "DBOP_not_equal_all" ); break;
        case DBOP_less_all : printf( "DBOP_less_all" ); break;
        case DBOP_less_equal_all : printf( "DBOP_less_equal_all" ); break;
        case DBOP_greater_all : printf( "DBOP_greater_all" ); break;
        case DBOP_greater_equal_all : printf( "DBOP_greater_equal_all" ); break;
        case DBOP_equal_any : printf( "DBOP_equal_any" ); break;
        case DBOP_not_equal_any : printf( "DBOP_not_equal_any" ); break;
        case DBOP_less_any : printf( "DBOP_less_any" ); break;
        case DBOP_less_equal_any : printf( "DBOP_less_equal_any" ); break;
        case DBOP_greater_any : printf( "DBOP_greater_any" ); break;
        case DBOP_greater_equal_any : printf( "DBOP_greater_equal_any" ); break;
        case DBOP_anybits : printf( "DBOP_anybits" ); break;
        case DBOP_allbits : printf( "DBOP_allbits" ); break;
        case DBOP_anybits_any : printf( "DBOP_anybits_any" ); break;
        case DBOP_allbits_any : printf( "DBOP_allbits_any" ); break;
        case DBOP_anybits_all : printf( "DBOP_anybits_all" ); break;
        case DBOP_allbits_all : printf( "DBOP_allbits_all" ); break;
        case DBOP_between : printf( "DBOP_between" ); break;
        case DBOP_between_unordered : printf( "DBOP_between_unordered" ); break;
        case DBOP_match : printf( "DBOP_match" ); break;
        case DBOP_match_unique : printf( "DBOP_match_unique" ); break;
        case DBOP_match_partial : printf( "DBOP_match_partial" ); break;
        case DBOP_match_partial_unique : printf( "DBOP_match_partial_unique" ); break;
        case DBOP_match_full : printf( "DBOP_match_full" ); break;
        case DBOP_match_full_unique : printf( "DBOP_match_full_unique" ); break;
        case DBOP_scalar_parameter : printf( "DBOP_scalar_parameter" ); break;
        case DBOP_scalar_function : printf( "DBOP_scalar_function" ); break;
        case DBOP_plus : printf( "DBOP_plus" ); break;
        case DBOP_minus : printf( "DBOP_minus" ); break;
        case DBOP_times : printf( "DBOP_times" ); break;
        case DBOP_over : printf( "DBOP_over" ); break;
        case DBOP_div : printf( "DBOP_div" ); break;
        case DBOP_modulo : printf( "DBOP_modulo" ); break;
        case DBOP_power : printf( "DBOP_power" ); break;
        case DBOP_like : printf( "DBOP_like" ); break;
        case DBOP_sounds_like : printf( "DBOP_sounds_like" ); break;
        case DBOP_like_any : printf( "DBOP_like_any" ); break;
        case DBOP_like_all : printf( "DBOP_like_all" ); break;
        case DBOP_is_INVALID : printf( "DBOP_is_INVALID" ); break;
        case DBOP_is_TRUE : printf( "DBOP_is_TRUE" ); break;
        case DBOP_is_FALSE : printf( "DBOP_is_FALSE" ); break;
        case DBOP_and : printf( "DBOP_and" ); break;
        case DBOP_or : printf( "DBOP_or" ); break;
        case DBOP_xor : printf( "DBOP_xor" ); break;
        case DBOP_equivalent : printf( "DBOP_equivalent" ); break;
        case DBOP_not : printf( "DBOP_not" ); break;
        case DBOP_implies : printf( "DBOP_implies" ); break;
        case DBOP_overlaps : printf( "DBOP_overlaps" ); break;
        case DBOP_case_condition : printf( "DBOP_case_condition" ); break;
        case DBOP_case_value : printf( "DBOP_case_value" ); break;
        case DBOP_nullif : printf( "DBOP_nullif" ); break;
        case DBOP_cast : printf( "DBOP_cast" ); break;
        case DBOP_coalesce : printf( "DBOP_coalesce" ); break;
        case DBOP_position : printf( "DBOP_position" ); break;
        case DBOP_extract : printf( "DBOP_extract" ); break;
        case DBOP_char_length : printf( "DBOP_char_length" ); break;
        case DBOP_octet_length : printf( "DBOP_octet_length" ); break;
        case DBOP_bit_length : printf( "DBOP_bit_length" ); break;
        case DBOP_substring : printf( "DBOP_substring" ); break;
        case DBOP_upper : printf( "DBOP_upper" ); break;
        case DBOP_lower : printf( "DBOP_lower" ); break;
        case DBOP_trim : printf( "DBOP_trim" ); break;
        case DBOP_translate : printf( "DBOP_translate" ); break;
        case DBOP_convert : printf( "DBOP_convert" ); break;
        case DBOP_string_concat : printf( "DBOP_string_concat" ); break;
        case DBOP_current_date : printf( "DBOP_current_date" ); break;
        case DBOP_current_time : printf( "DBOP_current_time" ); break;
        case DBOP_current_timestamp : printf( "DBOP_current_timestamp" ); break;
        case DBOP_content_select : printf( "DBOP_content_select" ); break;
        case DBOP_content : printf( "DBOP_content" ); break;
        case DBOP_content_freetext : printf( "DBOP_content_freetext" ); break;
        case DBOP_content_proximity : printf( "DBOP_content_proximity" ); break;
        case DBOP_content_vector_or : printf( "DBOP_content_vector_or" ); break;
        case DBOP_delete : printf( "DBOP_delete" ); break;
        case DBOP_update : printf( "DBOP_update" ); break;
        case DBOP_insert : printf( "DBOP_insert" ); break;
        case DBOP_min : printf( "DBOP_min" ); break;
        case DBOP_max : printf( "DBOP_max" ); break;
        case DBOP_count : printf( "DBOP_count" ); break;
        case DBOP_sum : printf( "DBOP_sum" ); break;
        case DBOP_avg : printf( "DBOP_avg" ); break;
        case DBOP_any_sample : printf( "DBOP_any_sample" ); break;
        case DBOP_stddev : printf( "DBOP_stddev" ); break;
        case DBOP_stddev_pop : printf( "DBOP_stddev_pop" ); break;
        case DBOP_var : printf( "DBOP_var" ); break;
        case DBOP_var_pop : printf( "DBOP_var_pop" ); break;
        case DBOP_first : printf( "DBOP_first" ); break;
        case DBOP_last : printf( "DBOP_last" ); break;
        case DBOP_in : printf( "DBOP_in" ); break;
        case DBOP_exists : printf( "DBOP_exists" ); break;
        case DBOP_unique : printf( "DBOP_unique" ); break;
        case DBOP_subset : printf( "DBOP_subset" ); break;
        case DBOP_proper_subset : printf( "DBOP_proper_subset" ); break;
        case DBOP_superset : printf( "DBOP_superset" ); break;
        case DBOP_proper_superset : printf( "DBOP_proper_superset" ); break;
        case DBOP_disjoint : printf( "DBOP_disjoint" ); break;
        case DBOP_pass_through : printf( "DBOP_pass_through" ); break;
        case DBOP_defined_by_GUID : printf( "DBOP_defined_by_GUID" ); break;
        case DBOP_text_command : printf( "DBOP_text_command" ); break;
        case DBOP_SQL_select : printf( "DBOP_SQL_select" ); break;
        case DBOP_prior_command_tree : printf( "DBOP_prior_command_tree" ); break;
        case DBOP_add_columns : printf( "DBOP_add_columns" ); break;
        case DBOP_column_list_anchor : printf( "DBOP_column_list_anchor" ); break;
        case DBOP_column_list_element : printf( "DBOP_column_list_element" ); break;
        case DBOP_command_list_anchor : printf( "DBOP_command_list_anchor" ); break;
        case DBOP_command_list_element : printf( "DBOP_command_list_element" ); break;
        case DBOP_from_list_anchor : printf( "DBOP_from_list_anchor" ); break;
        case DBOP_from_list_element : printf( "DBOP_from_list_element" ); break;
        case DBOP_project_list_anchor : printf( "DBOP_project_list_anchor" ); break;
        case DBOP_project_list_element : printf( "DBOP_project_list_element" ); break;
        case DBOP_row_list_anchor : printf( "DBOP_row_list_anchor" ); break;
        case DBOP_row_list_element : printf( "DBOP_row_list_element" ); break;
        case DBOP_scalar_list_anchor : printf( "DBOP_scalar_list_anchor" ); break;
        case DBOP_scalar_list_element : printf( "DBOP_scalar_list_element" ); break;
        case DBOP_set_list_anchor : printf( "DBOP_set_list_anchor" ); break;
        case DBOP_set_list_element : printf( "DBOP_set_list_element" ); break;
        case DBOP_sort_list_anchor : printf( "DBOP_sort_list_anchor" ); break;
        case DBOP_sort_list_element : printf( "DBOP_sort_list_element" ); break;
        case DBOP_alter_character_set : printf( "DBOP_alter_character_set" ); break;
        case DBOP_alter_collation : printf( "DBOP_alter_collation" ); break;
        case DBOP_alter_domain : printf( "DBOP_alter_domain" ); break;
        case DBOP_alter_index : printf( "DBOP_alter_index" ); break;
        case DBOP_alter_procedure : printf( "DBOP_alter_procedure" ); break;
        case DBOP_alter_schema : printf( "DBOP_alter_schema" ); break;
        case DBOP_alter_table : printf( "DBOP_alter_table" ); break;
        case DBOP_alter_trigger : printf( "DBOP_alter_trigger" ); break;
        case DBOP_alter_view : printf( "DBOP_alter_view" ); break;
        case DBOP_coldef_list_anchor : printf( "DBOP_coldef_list_anchor" ); break;
        case DBOP_coldef_list_element : printf( "DBOP_coldef_list_element" ); break;
        case DBOP_create_assertion : printf( "DBOP_create_assertion" ); break;
        case DBOP_create_character_set : printf( "DBOP_create_character_set" ); break;
        case DBOP_create_collation : printf( "DBOP_create_collation" ); break;
        case DBOP_create_domain : printf( "DBOP_create_domain" ); break;
        case DBOP_create_index : printf( "DBOP_create_index" ); break;
        case DBOP_create_procedure : printf( "DBOP_create_procedure" ); break;
        case DBOP_create_schema : printf( "DBOP_create_schema" ); break;
        case DBOP_create_synonym : printf( "DBOP_create_synonym" ); break;
        case DBOP_create_table : printf( "DBOP_create_table" ); break;
        case DBOP_create_temporary_table : printf( "DBOP_create_temporary_table" ); break;
        case DBOP_create_translation : printf( "DBOP_create_translation" ); break;
        case DBOP_create_trigger : printf( "DBOP_create_trigger" ); break;
        case DBOP_create_view : printf( "DBOP_create_view" ); break;
        case DBOP_drop_assertion : printf( "DBOP_drop_assertion" ); break;
        case DBOP_drop_character_set : printf( "DBOP_drop_character_set" ); break;
        case DBOP_drop_collation : printf( "DBOP_drop_collation" ); break;
        case DBOP_drop_domain : printf( "DBOP_drop_domain" ); break;
        case DBOP_drop_index : printf( "DBOP_drop_index" ); break;
        case DBOP_drop_procedure : printf( "DBOP_drop_procedure" ); break;
        case DBOP_drop_schema : printf( "DBOP_drop_schema" ); break;
        case DBOP_drop_synonym : printf( "DBOP_drop_synonym" ); break;
        case DBOP_drop_table : printf( "DBOP_drop_table" ); break;
        case DBOP_drop_translation : printf( "DBOP_drop_translation" ); break;
        case DBOP_drop_trigger : printf( "DBOP_drop_trigger" ); break;
        case DBOP_drop_view : printf( "DBOP_drop_view" ); break;
        case DBOP_foreign_key : printf( "DBOP_foreign_key" ); break;
        case DBOP_grant_privileges : printf( "DBOP_grant_privileges" ); break;
        case DBOP_index_list_anchor : printf( "DBOP_index_list_anchor" ); break;
        case DBOP_index_list_element : printf( "DBOP_index_list_element" ); break;
        case DBOP_primary_key : printf( "DBOP_primary_key" ); break;
        case DBOP_property_list_anchor : printf( "DBOP_property_list_anchor" ); break;
        case DBOP_property_list_element : printf( "DBOP_property_list_element" ); break;
        case DBOP_referenced_table : printf( "DBOP_referenced_table" ); break;
        case DBOP_rename_object : printf( "DBOP_rename_object" ); break;
        case DBOP_revoke_privileges : printf( "DBOP_revoke_privileges" ); break;
        case DBOP_schema_authorization : printf( "DBOP_schema_authorization" ); break;
        case DBOP_unique_key : printf( "DBOP_unique_key" ); break;
        case DBOP_scope_list_anchor : printf( "DBOP_scope_list_anchor" ); break;
        case DBOP_scope_list_element : printf( "DBOP_scope_list_element" ); break;
        case DBOP_content_table : printf( "DBOP_content_table" ); break;

        default : printf( "unknown DBOP" ); break;
    }

    printf( "\n" );

    PrintSpace( iLevel );
    printf( "wKind: (%d) ", pNode->wKind );
    switch( pNode->wKind )
    {
        case DBVALUEKIND_BYGUID :
        {
            printf( "DBVALUEKIND_BYGUID " );
            break;
        }
        case DBVALUEKIND_COLDESC :
        {
            printf( "DBVALUEKIND_COLDESC " );
            break;
        }
        case DBVALUEKIND_ID :
        {
            printf( "DBVALUEKIND_ID: " );
            if ( 0 == pNode->value.pdbidValue )
                printf( "NULL" );
            else
            {
                DBKIND kind = pNode->value.pdbidValue->eKind;

                if ( DBKIND_GUID        == kind ||
                     DBKIND_GUID_NAME   == kind ||
                     DBKIND_GUID_PROPID == kind )
                {
                    GUID &g = pNode->value.pdbidValue->uGuid.guid;
                    printf( "%8.8x-%4.4x-%4.4x-%2.2x%2.2x-"
                            "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                            g.Data1,g.Data2,g.Data3,g.Data4[0],
                            g.Data4[1],g.Data4[2],g.Data4[3],g.Data4[4],
                            g.Data4[5],g.Data4[6],g.Data4[7] );
                }
                if ( DBKIND_GUID_PROPID == kind ||
                     DBKIND_PROPID      == kind )
                    printf( " %d", pNode->value.pdbidValue->uName.ulPropid );
                if ( DBKIND_GUID_NAME == kind ||
                     DBKIND_NAME      == kind )
                    printf( " '%ws'", pNode->value.pdbidValue->uName.pwszName );
            }
            break;
        }
        case DBVALUEKIND_CONTENT :
        {
            printf( "DBVALUEKIND_CONTENT: " );
            if ( 0 == pNode->value.pdbcntntValue )
                printf( "NULL" );
            else
                printf( "'%ws', method %d, weight %d, lcid %#x",
                        pNode->value.pdbcntntValue->pwszPhrase,
                        pNode->value.pdbcntntValue->dwGenerateMethod,
                        pNode->value.pdbcntntValue->lWeight,
                        pNode->value.pdbcntntValue->lcid );
            break;
        }
        case DBVALUEKIND_CONTENTVECTOR :
        {
            printf( "DBVALUEKIND_CONTENTVECTOR: " );
            DBCONTENTVECTOR *p = pNode->value.pdbcntntvcValue;
            if ( 0 == p )
                printf( "NULL" );
            else
            {
                printf( "method %d, weight %d ",
                         p->dwRankingMethod,
                         p->lWeight );
            }
            break;
        }
        case DBVALUEKIND_GROUPINFO :
        {
            printf( "DBVALUEKIND_GROUPINFO " );
            break;
        }
        case DBVALUEKIND_PARAMETER :
        {
            printf( "DBVALUEKIND_PARAMETER " );
            break;
        }
        case DBVALUEKIND_PROPERTY :
        {
            printf( "DBVALUEKIND_PROPERTY " );
            break;
        }
        case DBVALUEKIND_SETFUNC :
        {
            printf( "DBVALUEKIND_SETFUNC " );
            break;
        }
        case DBVALUEKIND_SORTINFO :
        {
            printf( "DBVALUEKIND_SORTINFO: " );
            if ( 0 == pNode->value.pdbsrtinfValue )
                printf( "NULL" );
            else
                printf( "fDesc %d, lcid %#x",
                        pNode->value.pdbsrtinfValue->fDesc,
                        pNode->value.pdbsrtinfValue->lcid );
            break;
        }
        case DBVALUEKIND_TEXT :
        {
            printf( "DBVALUEKIND_TEXT " );
            break;
        }
        case DBVALUEKIND_COMMAND :
        {
            printf( "DBVALUEKIND_COMMAND " );
            break;
        }
        case DBVALUEKIND_MONIKER :
        {
            printf( "DBVALUEKIND_MONIKER " );
            break;
        }
        case DBVALUEKIND_ROWSET :
        {
            printf( "DBVALUEKIND_ROWSET " );
            break;
        }
        case DBVALUEKIND_LIKE :
        {
            printf( "DBVALUEKIND_LIKE " );
            break;
        }
        case DBVALUEKIND_CONTENTPROXIMITY :
        {
            printf( "DBVALUEKIND_CONTENTPROXIMITY " );
            break;
        }
        case DBVALUEKIND_CONTENTSCOPE :
        {
            printf( "DBVALUEKIND_CONTENTSCOPE " );
            if ( 0 == pNode->value.pdbcntntscpValue )
                printf( "NULL" );
            else
                printf( "dwFlags %#x, pwszElementValue %ws",
                        pNode->value.pdbcntntscpValue->dwFlags,
                        pNode->value.pdbcntntscpValue->pwszElementValue );
            break;
        }
        case DBVALUEKIND_CONTENTTABLE :
        {
            printf( "DBVALUEKIND_CONTENTTABLE " );
            if ( 0 == pNode->value.pdbcntnttblValue )
                printf( "NULL" );
            else
                printf( "machine %ws, catalog %ws",
                        pNode->value.pdbcntnttblValue->pwszMachine,
                        pNode->value.pdbcntnttblValue->pwszCatalog );
            break;
        }
        case DBVALUEKIND_IDISPATCH :
        {
            printf( "DBVALUEKIND_IDISPATCH " );
            break;
        }
        case DBVALUEKIND_IUNKNOWN :
        {
            printf( "DBVALUEKIND_IUNKNOWN " );
            break;
        }
        case DBVALUEKIND_EMPTY :
        {
            printf( "DBVALUEKIND_EMPTY " );
            break;
        }
        case DBVALUEKIND_NULL :
        {
            printf( "DBVALUEKIND_NULL " );
            break;
        }
        case DBVALUEKIND_I2 :
        {
            printf( "DBVALUEKIND_I2: %d", pNode->value.sValue );
            break;
        }
        case DBVALUEKIND_I4 :
        {
            printf( "DBVALUEKIND_I4: %d", pNode->value.lValue );
            break;
        }
        case DBVALUEKIND_R4 :
        {
            printf( "DBVALUEKIND_R4: %f", pNode->value.flValue );
            break;
        }
        case DBVALUEKIND_R8 :
        {
            printf( "DBVALUEKIND_R8: %lf", pNode->value.dblValue );
            break;
        }
        case DBVALUEKIND_CY :
        {
            printf( "DBVALUEKIND_CY " );
            break;
        }
        case DBVALUEKIND_DATE :
        {
            printf( "DBVALUEKIND_DATE " );
            break;
        }
        case DBVALUEKIND_BSTR :
        {
            printf( "DBVALUEKIND_BSTR: '%ws'", pNode->value.pbstrValue );
            break;
        }
        case DBVALUEKIND_ERROR :
        {
            printf( "DBVALUEKIND_ERROR: %d", pNode->value.scodeValue );
            break;
        }
        case DBVALUEKIND_BOOL :
        {
            printf( "DBVALUEKIND_BOOL: %d", pNode->value.fValue );
            break;
        }
        case DBVALUEKIND_VARIANT :
        {
            printf( "DBVALUEKIND_VARIANT " );

            // Indexing Service uses PROPVARIANTs (extended VARIANTs)

            DisplayVariant( (PROPVARIANT *) pNode->value.pvarValue );
            break;
        }
        case DBVALUEKIND_I1 :
        {
            printf( "DBVALUEKIND_I1: %d", pNode->value.schValue );
            break;
        }
        case DBVALUEKIND_UI1 :
        {
            printf( "DBVALUEKIND_UI1: %u", pNode->value.uchValue );
            break;
        }
        case DBVALUEKIND_UI2 :
        {
            printf( "DBVALUEKIND_UI2: %u", pNode->value.usValue );
            break;
        }
        case DBVALUEKIND_UI4 :
        {
            printf( "DBVALUEKIND_UI4: %u", pNode->value.ulValue );
            break;
        }
        case DBVALUEKIND_I8 :
        {
            printf( "DBVALUEKIND_I8: %I64d", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_UI8 :
        {
            printf( "DBVALUEKIND_UI8: %I64u", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_GUID :
        {
            printf( "DBVALUEKIND_GUID " );
            break;
        }
        case DBVALUEKIND_BYTES :
        {
            printf( "DBVALUEKIND_BYTES " );
            break;
        }
        case DBVALUEKIND_STR :
        {
            printf( "DBVALUEKIND_STR: '%s'", pNode->value.pzValue );
            break;
        }
        case DBVALUEKIND_WSTR :
        {
            printf( "DBVALUEKIND_WSTR: '%ws'", pNode->value.pwszValue );
            break;
        }
        case DBVALUEKIND_NUMERIC :
        {
            printf( "DBVALUEKIND_NUMERIC " );
            break;
        }
        case DBVALUEKIND_DBDATE :
        {
            printf( "DBVALUEKIND_DBDATE " );
            break;
        }
        case DBVALUEKIND_DBTIME :
        {
            printf( "DBVALUEKIND_DBTIME " );
            break;
        }
        case DBVALUEKIND_DBTIMESTAMP :
        {
            printf( "DBVALUEKIND_DBTIMESTAMP " );
            break;
        }
        default :
        {
            printf( "unknown DBVALUEKIND " );
            break;
        }
    }

    printf( "\n" );

    if ( pNode->pctFirstChild )
    {
        PrintSpace( iLevel );
        printf( "first child:\n" );
        DisplayCommandTree( pNode->pctFirstChild, iLevel + 1 );
    }

    if ( pNode->pctNextSibling )
    {
        PrintSpace( iLevel );
        printf( "next sibling:\n" );
        DisplayCommandTree( pNode->pctNextSibling, iLevel + 1 );
    }

    if ( 0 == iLevel )
        printf( "\n" );
} //DisplayCommandTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\advquery\advquery.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// PROGRAM:  advquery.cxx
//
// PURPOSE:  Illustrates an advanced query using Indexing Service.
//           Uses the OLE DB Provider for Indexing Service, not
//           Indexing Service helper functions.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#ifndef UNICODE
  #define UNICODE
#endif

#include <stdio.h>
#include <windows.h>

#define OLEDBVER 0x0250 // need the command tree definitions
#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <olectl.h>

#include <ntquery.h>

// This is found in disptree.cxx

extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 );

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Function:   CreateICommand
//
//  Synopsis:   Creates an ICommand.
//
//  Arguments:  [ppICommand] - Where the ICommand is returned on success
//
//  Returns:    HRESULT result
//
//--------------------------------------------------------------------------

HRESULT CreateICommand( ICommand ** ppICommand )
{
    // Instantiate the data source object

    XInterface<IDBInitialize> xIDBInit;
    static const GUID guidIndexingServiceDSO = CLSID_INDEX_SERVER_DSO;
    HRESULT hr = CoCreateInstance( guidIndexingServiceDSO,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IDBInitialize,
                                   xIDBInit.GetQIPointer() );
    if ( FAILED(hr) )
        return hr;

    // Initialize, verifying that we supplied the right variables

    hr = xIDBInit->Initialize();
    if ( FAILED(hr) )
        return hr;

    // Get a session object

    XInterface<IDBCreateSession> xIDBSess;
    hr = xIDBInit->QueryInterface( IID_IDBCreateSession,
                                   xIDBSess.GetQIPointer() );
    if ( FAILED(hr) )
        return hr;

    // Get a Create Command object

    XInterface<IDBCreateCommand> xICreateCommand;
    hr = xIDBSess->CreateSession( 0,
                                  IID_IDBCreateCommand,
                                  xICreateCommand.GetIUPointer() );
    if ( FAILED(hr) )
        return hr;

    // Create the ICommand

    XInterface<ICommand> xICommand;
    hr = xICreateCommand->CreateCommand( 0,
                                         IID_ICommand,
                                         xICommand.GetIUPointer() );
    if ( FAILED(hr) )
        return hr;

    *ppICommand = xICommand.Acquire();

    return hr;
} //CreateICommand

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.
//
//              Also sets the asynchronous property, so the Execute() call
//              returns before the query is complete.
//
//              Both of these properties are unique to the OLE DB Provider
//              for Indexing Service implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties( ICommand * pICommand )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
    static const GUID guidRowsetProps = DBPROPSET_ROWSET;

    DBPROP aProp[3];

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;

    aProp[2] = aProp[0];
    aProp[2].dwOptions = DBPROPOPTIONS_REQUIRED;
    aProp[2].dwPropertyID = DBPROP_IDBAsynchStatus;

    DBPROPSET aPropSet[2];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 2;
    aPropSet[0].guidPropertySet = guidQueryExt;

    aPropSet[1].rgProperties = &aProp[2];
    aPropSet[1].cProperties = 1;
    aPropSet[1].guidPropertySet = guidRowsetProps;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    return xICommandProperties->SetProperties( 2,          // 2 property sets
                                               aPropSet ); // the properties
} //SetCommandProperties

//+-------------------------------------------------------------------------
//
//  Function:   SetScopeCatalogAndMachine
//
//  Synopsis:   Sets the catalog and machine properties in the ICommand.
//              Also sets a default scope.
//
//  Arguments:  [pICommand]       - ICommand to set props on
//              [pwcQueryScope]   - Scope for the query
//              [pwcQueryCatalog] - Catalog name over which query is run
//              [pwcQueryMachine] - Machine name on which query is run
//
//  Returns:    HRESULT result of the operation
//
//--------------------------------------------------------------------------

HRESULT SetScopeCatalogAndMachine(
    ICommand *    pICommand,
    WCHAR const * pwcQueryScope,
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine )
{
    // Get an ICommandProperties so we can set the properties

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // note: SysAllocString, SafeArrayCreate, and SafeArrayPutElement can
    // fail, but this isn't checked here for brevity.

    SAFEARRAYBOUND rgBound[1];
    rgBound[0].lLbound = 0;
    rgBound[0].cElements = 1;
    SAFEARRAY * pMachines = SafeArrayCreate( VT_BSTR, 1, rgBound );
    long i = 0;
    SafeArrayPutElement( pMachines, &i, SysAllocString( pwcQueryMachine ) );

    SAFEARRAY * pCatalogs = SafeArrayCreate( VT_BSTR, 1, rgBound );
    SafeArrayPutElement( pCatalogs, &i, SysAllocString( pwcQueryCatalog ) );

    SAFEARRAY * pScopes = SafeArrayCreate( VT_BSTR, 1, rgBound );
    SafeArrayPutElement( pScopes, &i, SysAllocString( pwcQueryScope ) );

    LONG lFlags = QUERY_DEEP;
    SAFEARRAY * pFlags = SafeArrayCreate( VT_I4, 1, rgBound );
    SafeArrayPutElement( pFlags, &i, &lFlags );

    DBPROP aScopeProperties[2];
    memset( aScopeProperties, 0, sizeof aScopeProperties );
    aScopeProperties[0].dwPropertyID = DBPROP_CI_INCLUDE_SCOPES;
    aScopeProperties[0].vValue.vt = VT_BSTR | VT_ARRAY;
    aScopeProperties[0].vValue.parray = pScopes;
    aScopeProperties[0].colid.eKind = DBKIND_GUID_PROPID;

    aScopeProperties[1].dwPropertyID = DBPROP_CI_SCOPE_FLAGS;
    aScopeProperties[1].vValue.vt = VT_I4 | VT_ARRAY;
    aScopeProperties[1].vValue.parray = pFlags;
    aScopeProperties[1].colid.eKind = DBKIND_GUID_PROPID;

    DBPROP aCatalogProperties[1];
    memset( aCatalogProperties, 0, sizeof aCatalogProperties );
    aCatalogProperties[0].dwPropertyID = DBPROP_CI_CATALOG_NAME;
    aCatalogProperties[0].vValue.vt = VT_BSTR | VT_ARRAY;
    aCatalogProperties[0].vValue.parray = pCatalogs;
    aCatalogProperties[0].colid.eKind = DBKIND_GUID_PROPID;

    DBPROP aMachineProperties[1];
    memset( aMachineProperties, 0, sizeof aMachineProperties );
    aMachineProperties[0].dwPropertyID = DBPROP_MACHINE;
    aMachineProperties[0].vValue.vt = VT_BSTR | VT_ARRAY;
    aMachineProperties[0].vValue.parray = pMachines;
    aMachineProperties[0].colid.eKind = DBKIND_GUID_PROPID;

    const GUID guidFSCI = DBPROPSET_FSCIFRMWRK_EXT;
    DBPROPSET aAllPropsets[3];
    aAllPropsets[0].rgProperties = aScopeProperties;
    aAllPropsets[0].cProperties = 2;
    aAllPropsets[0].guidPropertySet = guidFSCI;

    aAllPropsets[1].rgProperties = aCatalogProperties;
    aAllPropsets[1].cProperties = 1;
    aAllPropsets[1].guidPropertySet = guidFSCI;

    const GUID guidCI = DBPROPSET_CIFRMWRKCORE_EXT;
    aAllPropsets[2].rgProperties = aMachineProperties;
    aAllPropsets[2].cProperties = 1;
    aAllPropsets[2].guidPropertySet = guidCI;

    const ULONG cPropertySets = sizeof aAllPropsets / sizeof aAllPropsets[0];

    hr = xICommandProperties->SetProperties( cPropertySets,  // # of propsets
                                             aAllPropsets ); // the propsets

    SafeArrayDestroy( pScopes );
    SafeArrayDestroy( pFlags );
    SafeArrayDestroy( pCatalogs );
    SafeArrayDestroy( pMachines );

    return hr;
} //SetScopeCatalogAndMachine

//+-------------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   Allocates and duplicates a string.
//
//  Arguments:  [pwcIn]  - The string to copy
//
//  Returns:    A string
//
//--------------------------------------------------------------------------

WCHAR * AllocAndCopy( WCHAR const * pwcIn )
{
    ULONG cwc = wcslen( pwcIn ) + 1;

    // note: CoTaskMemAlloc can return 0 if out of memory, not checked

    WCHAR * pwc = (WCHAR *) CoTaskMemAlloc( cwc * sizeof WCHAR );
    wcscpy( pwc, pwcIn );
    return pwc;
} //AllocAndCopy

//+-------------------------------------------------------------------------
//
//  Function:   NewTreeNode
//
//  Synopsis:   Allocates and initializes a DBCOMMANDTREE object
//
//  Arguments:  [op]     - The node's operator
//              [wKind]  - The kind of node
//
//  Returns:    an initialized DBCOMMANDTREE object
//
//--------------------------------------------------------------------------

DBCOMMANDTREE * NewTreeNode(
    DBCOMMANDOP op,
    WORD        wKind )
{
    DBCOMMANDTREE * pTree = (DBCOMMANDTREE *)
                             CoTaskMemAlloc( sizeof DBCOMMANDTREE );
    memset( pTree, 0, sizeof DBCOMMANDTREE );
    pTree->op = op;
    pTree->wKind = wKind;
    return pTree;
} //NewTreeNode

//+-------------------------------------------------------------------------
//
//  Function:   CreateQueryTree
//
//  Synopsis:   Creates a DBCOMMANDTREE for the query
//
//  Arguments:  [pwcQueryRestrition] - The actual query string
//              [ppTree]             - Resulting query tree
//
//  Returns:    HRESULT result of the operation
//
//  Notes:      The query tree has a string restriction, a list of
//              columns to return (rank, size, and path), and a sort
//              order (rank).
//              Here are two views of the query tree
//               
//              sort:
//                child: project
//                  sibling: sort_list_anchor
//                    child: sort_list_element
//                      value: SORTINFO (descending, lcid)
//                      child: column_name
//                        value: DBID rank
//                  child: select
//                    sibling: project_list_anchor
//                      child: project_list_element
//                        child: column_name
//                          value: DBID rank
//                        sibling: project_list_element
//                          child: column_name
//                            value: DBID size
//                          sibling: project_list_element
//                            child: column_name
//                              value: DBID path
//                    child: table_name
//                      value: WSTR: "Table"
//                      sibling: content
//                        value: DBCONTENT (restriction, weight, lcid)
//                        child: column_name
//                          value: DBID contents
//
// +---------------------------+
// | DBOP_sort                 |
// | DBVALUEKIND_EMPTY         |
// +---------------------------+
// |
// |child
// |                            sibling
// +---------------------------+-------+---------------------------+
// | DBOP_project              |       | DBOP_sort_list_anchor     |
// | DBVALUEKIND_EMPTY         |       | DBVALUEKIND_EMPTY         |
// +---------------------------+       +---------------------------+
// |                                   |
// |child                              |child
// |                                   |
// |                                   +---------------------------+
// |                                   | DBOP_sort_list_element    |
// |                                   | DBVALUEKIND_SORTINFO      |
// |                                   +---------------------------+
// |                                   |            |
// |                                   |child       | pdbsrtinfValue
// |                                   |            |
// |                                   |     +-------------+
// |                                   |     | DBSORTIFO   |
// |                                   |     | fDesc TRUE  |
// |                                   |     | lcid system |
// |                                   |     +-------------+
// |                                   |
// |                                   |
// |                                   |
// |                                   +---------------------------+
// |                                   | DBOP_column_name          |
// |                                   | DBVALUEKIND_ID            |
// |                                   +---------------------------+
// |                                                |
// |                                                | pdbidValue
// |                                                |
// |                                             +------+
// |                                             | DBID |
// |                                             | rank |
// |                                             +------+
// |
// |                            sibling
// +---------------------------+-------+---------------------------+-------+
// | DBOP_select               |       | DBOP_project_list_anchor  |       | s
// | DBVALUEKIND_EMPTY         |       | DBVALUEKIND_EMPTY         |       | i
// +---------------------------+       +---------------------------+       | b
// |                                   |                                   | l
// |child                              |child                              | i
// |                                   |                                   | n
// |                                   +---------------------------+       | g
// |                                   | DBOP_project_list_element |       |
// |                                   | DBVALUEKIND_EMPTY         |       |
// |                                   +---------------------------+       |
// |                                   |                                   |
// |                                   |child                              |
// |                                   |                                   |
// |                                   +---------------------------+       |
// |                                   | DBOP_column_name          |       |
// |                                   | DBVALUEKIND_ID            |       |
// |                                   +---------------------------+       |
// |                                                |                      |
// |                                                | pdbidValue           |
// |                                                |                      |
// |                                             +------+                  |
// |                                             | DBID |                  |
// |                                             | rank |                  |
// |                                             +------+                  |
// |                                                                       |
// |                                   +-----------------------------------+
// |                                   |
// |                                   +---------------------------+-------+
// |                                   | DBOP_project_list_element |       | s
// |                                   | DBVALUEKIND_EMPTY         |       | i
// |                                   +---------------------------+       | b
// |                                   |                                   | l
// |                                   |child                              | i
// |                                   |                                   | n
// |                                   +---------------------------+       | g
// |                                   | DBOP_column_name          |       |
// |                                   | DBVALUEKIND_ID            |       |
// |                                   +---------------------------+       |
// |                                                |                      |
// |                                                | pdbidValue           |
// |                                                |                      |
// |                                             +------+                  |
// |                                             | DBID |                  |
// |                                             | size |                  |
// |                                             +------+                  |
// |                                                                       |
// |                                   +-----------------------------------+
// |                                   |
// |                                   +---------------------------+
// |                                   | DBOP_project_list_element |
// |                                   | DBVALUEKIND_EMPTY         |
// |                                   +---------------------------+
// |                                   |
// |                                   |child
// |                                   |
// |                                   +---------------------------+
// |                                   | DBOP_column_name          |
// |                                   | DBVALUEKIND_ID            |
// |                                   +---------------------------+
// |                                                |
// |                                                | pdbidValue
// |                                                |
// |                                             +------+
// |                                             | DBID |
// |                                             | path |
// |                                             +------+
// |
// |                            sibling
// +---------------------------+-------+---------------------------+
// | DBOP_table_name           |       | DBOP_content              |
// | DBVALUEKIND_WSTR: 'Table' |       | DBVALUEKIND_CONTENT       |
// +---------------------------+       +---------------------------+
//                                     |            |
//                                     |child       | pdbcntntValue
//                                     |            |
//                                     |  +---------------------------+
//                                     |  | DBCONTENT                 |
//                                     |  | dwGenerateMethod: GENERATE_METHOD_EXACT |
//                                     |  | lWeight: 1000             |
//                                     |  | lcid: system              |
//                                     |  | pwszPhrase: the query     |
//                                     |  +---------------------------+
//                                     |
//                                     |
//                                     |
//                                     +---------------------------+
//                                     | DBOP_column_name          |
//                                     | DBVALUEKIND_ID            |
//                                     +---------------------------+
//                                                  |
//                                                  | pdbidValue
//                                                  |
//                                             +----------+
//                                             | DBID     |
//                                             | contents |
//                                             +----------+
//
//--------------------------------------------------------------------------

HRESULT CreateQueryTree(
    WCHAR const *    pwcQueryRestriction,
    DBCOMMANDTREE ** ppTree )
{
    // These are the properties that'll be referenced below

    const DBID dbidContents = { PSGUID_STORAGE, DBKIND_GUID_PROPID,
                                (LPOLESTR) PID_STG_CONTENTS };
    const DBID dbidPath =     { PSGUID_STORAGE, DBKIND_GUID_PROPID,
                                (LPOLESTR) PID_STG_PATH };
    const DBID dbidSize =     { PSGUID_STORAGE, DBKIND_GUID_PROPID,
                                (LPOLESTR) PID_STG_SIZE };
    DBID dbidRank;
    dbidRank.uGuid.guid = PSGUID_QUERY;
    dbidRank.eKind = DBKIND_GUID_PROPID;
    dbidRank.uName.ulPropid = PROPID_QUERY_RANK ;

    // The restriction is a content node with either a word or a phrase.
    // This is the most simple possible query.  Other types of nodes include
    // AND, OR, NOT, etc.
    // The CITextToFullTree function is available for building more complex
    // queries given a text string.

    DBCOMMANDTREE *pRestriction = NewTreeNode( DBOP_content,
                                               DBVALUEKIND_CONTENT );
    DBCONTENT * pDBContent = (DBCONTENT *) CoTaskMemAlloc( sizeof DBCONTENT );
    memset( pDBContent, 0, sizeof DBCONTENT );
    pRestriction->value.pdbcntntValue = pDBContent;
    pDBContent->dwGenerateMethod = GENERATE_METHOD_EXACT;
    pDBContent->lWeight = 1000; // maximum possible weight
    pDBContent->lcid = GetSystemDefaultLCID();
    pDBContent->pwszPhrase = AllocAndCopy( pwcQueryRestriction );

    // This identifies "file contents" as the property for the restrition

    DBCOMMANDTREE *pPropID = NewTreeNode( DBOP_column_name, DBVALUEKIND_ID );
    pRestriction->pctFirstChild = pPropID;
    DBID *pDBID = (DBID *) CoTaskMemAlloc( sizeof DBID );
    *pDBID = dbidContents;
    pPropID->value.pdbidValue = pDBID;

    DBCOMMANDTREE *pSelect = NewTreeNode( DBOP_select, DBVALUEKIND_EMPTY );
    DBCOMMANDTREE *pTableId = NewTreeNode( DBOP_table_name, DBVALUEKIND_WSTR );
    pSelect->pctFirstChild = pTableId;
    pTableId->value.pwszValue = AllocAndCopy( L"Table" );
    pTableId->pctNextSibling = pRestriction;

    DBCOMMANDTREE *pProject = NewTreeNode( DBOP_project, DBVALUEKIND_EMPTY );
    pProject->pctFirstChild = pSelect;

    // The project anchor holds the list of columns that are retrieved

    DBCOMMANDTREE * pProjectAnchor = NewTreeNode( DBOP_project_list_anchor,
                                                  DBVALUEKIND_EMPTY );
    pSelect->pctNextSibling = pProjectAnchor;

    // Retrieve rank as column 1

    DBCOMMANDTREE * pProjectRank = NewTreeNode( DBOP_project_list_element,
                                                  DBVALUEKIND_EMPTY );
    pProjectAnchor->pctFirstChild = pProjectRank;

    DBCOMMANDTREE * pColumnRank = NewTreeNode( DBOP_column_name,
                                               DBVALUEKIND_ID );
    pProjectRank->pctFirstChild = pColumnRank;
    DBID *pDBIDRank = (DBID *) CoTaskMemAlloc( sizeof DBID );
    pColumnRank->value.pdbidValue = pDBIDRank;
    *pDBIDRank = dbidRank;

    // Retrieve file size as column 2

    DBCOMMANDTREE * pProjectSize = NewTreeNode( DBOP_project_list_element,
                                                DBVALUEKIND_EMPTY );
    pProjectRank->pctNextSibling = pProjectSize;

    DBCOMMANDTREE * pColumnSize = NewTreeNode( DBOP_column_name,
                                               DBVALUEKIND_ID );
    pProjectSize->pctFirstChild = pColumnSize;
    DBID *pDBIDSize = (DBID *) CoTaskMemAlloc( sizeof DBID );
    pColumnSize->value.pdbidValue = pDBIDSize;
    *pDBIDSize = dbidSize;

    // Retrieve file path as column 3

    DBCOMMANDTREE * pProjectPath = NewTreeNode( DBOP_project_list_element,
                                                DBVALUEKIND_EMPTY );
    pProjectSize->pctNextSibling = pProjectPath;

    DBCOMMANDTREE * pColumnPath = NewTreeNode( DBOP_column_name,
                                               DBVALUEKIND_ID );
    pProjectPath->pctFirstChild = pColumnPath;
    DBID *pDBIDPath = (DBID *) CoTaskMemAlloc( sizeof DBID );
    pColumnPath->value.pdbidValue = pDBIDPath;
    *pDBIDPath = dbidPath;

    // The sort node specifies the sort order for the results

    DBCOMMANDTREE * pSort = NewTreeNode( DBOP_sort, DBVALUEKIND_EMPTY );
    pSort->pctFirstChild = pProject;

    // The sort anchor is the start of the list of sort properties

    DBCOMMANDTREE * pSortAnchor = NewTreeNode( DBOP_sort_list_anchor,
                                               DBVALUEKIND_EMPTY );
    pProject->pctNextSibling = pSortAnchor;

    // The sort order is rank

    DBCOMMANDTREE * pSortRank = NewTreeNode( DBOP_sort_list_element,
                                             DBVALUEKIND_SORTINFO );
    pSortAnchor->pctFirstChild = pSortRank;

    DBSORTINFO * pSortInfo = (DBSORTINFO *) CoTaskMemAlloc( sizeof DBSORTINFO );
    memset( pSortInfo, 0, sizeof DBSORTINFO );
    pSortRank->value.pdbsrtinfValue = pSortInfo;
    pSortInfo->fDesc = TRUE; // descending, not ascending
    pSortInfo->lcid = GetSystemDefaultLCID();

    DBCOMMANDTREE * pSortColumnRank = NewTreeNode( DBOP_column_name,
                                                   DBVALUEKIND_ID );
    pSortRank->pctFirstChild = pSortColumnRank;
    DBID *pDBIDSortRank = (DBID *) CoTaskMemAlloc( sizeof DBID );
    pSortColumnRank->value.pdbidValue = pDBIDSortRank;
    *pDBIDSortRank = dbidRank;

    // The sort node is the head of the tree

    *ppTree = pSort;

    return S_OK;
} //CreateQueryTree

//+---------------------------------------------------------------------------
//
//  Class:      CAsynchNotify
//
//  Synopsis:   Class for the IDBAsynchNotify callbacks
//
//----------------------------------------------------------------------------

class CAsynchNotify : public IDBAsynchNotify
{
public:
    CAsynchNotify() :
        _cRef( 1 ),
        _cLowResource( 0 ),
        _hEvent( 0 )
    {
        _hEvent = CreateEventW( 0, TRUE, FALSE, 0 );
    }

    ~CAsynchNotify()
    {
        if ( 0 != _hEvent )
            CloseHandle( _hEvent );
    }

    BOOL IsValid() const { return 0 != _hEvent; }

    //
    // IUnknown methods.
    //

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID *ppiuk )
    {
        *ppiuk = (void **) this; // hold our breath and jump
        AddRef();
        return S_OK;
    }

    STDMETHOD_( ULONG, AddRef ) () { return InterlockedIncrement( &_cRef ); }

    STDMETHOD_( ULONG, Release) () { return InterlockedDecrement( &_cRef ); }

    //
    // IDBAsynchNotify methods
    //

    STDMETHOD( OnLowResource ) ( DB_DWRESERVE dwReserved )
    {
        _cLowResource++;

        // If we've failed a few times due to low resource, give up
        // on the query since there may not be sufficient resources
        // to ever get an OnStop call.

        if ( _cLowResource >= 5 )
            SetEvent( _hEvent );

        return S_OK;
    }

    STDMETHOD( OnProgress ) ( HCHAPTER hChap, DBASYNCHOP ulOp,
                              DBCOUNTITEM ulProg, DBCOUNTITEM ulProgMax,
                              DBASYNCHPHASE ulStat, LPOLESTR pwszStatus )
    {
        return S_OK;
    }

    STDMETHOD( OnStop ) ( HCHAPTER hChap, ULONG ulOp,
                          HRESULT hrStat, LPOLESTR pwszStatus )
    {
        // If the query is complete (successfully or not), set the event

        if ( DBASYNCHOP_OPEN == ulOp )
            SetEvent( _hEvent );

        return S_OK;
    }

    void Wait()
    {
        WaitForSingleObject( _hEvent, INFINITE );
    }

private:
    LONG   _cRef;
    LONG   _cLowResource;
    HANDLE _hEvent;
};

//+-------------------------------------------------------------------------
//
//  Function:   WaitForQueryToComplete
//
//  Synopsis:   Waits for the query to complete.  This function polls for
//              completion.  Alternatively, the IConnectionPointContainer
//              and IRowsetWatchNotify interfaces could be used for
//              asynchronous notification when the query completes.
//
//  Arguments:  [pRowset]  -- The rowset to wait for
//
//  Returns:    HRESULT result
//
//--------------------------------------------------------------------------

HRESULT WaitForQueryToComplete( IRowset * pRowset )
{
    HRESULT hr;

    //
    // Both methods (notifications and polling) work.  It depends on the
    // application which is the best choice.
    //

#if 1

    // Register for notifications

    XInterface<IConnectionPointContainer> xCPC;
    hr = pRowset->QueryInterface( IID_IConnectionPointContainer,
                                  xCPC.GetQIPointer() );
    if (FAILED(hr))
        return hr;

    XInterface<IConnectionPoint> xCP;
    hr = xCPC->FindConnectionPoint( IID_IDBAsynchNotify,
                                    xCP.GetPPointer() );
    if (FAILED(hr) && CONNECT_E_NOCONNECTION != hr )
        return hr;

    CAsynchNotify Notify;

    if ( !Notify.IsValid() )
        return HRESULT_FROM_WIN32( GetLastError() );

    DWORD dwAdviseID;
    hr = xCP->Advise( (IUnknown *) &Notify, &dwAdviseID );
    if (FAILED(hr))
        return hr;

    //
    // In a real app, we'd be off doing other work rather than waiting
    // for the query to complete, but this will do.
    // MsgWaitForSingleObject is a good choice for a GUI app.  You could
    // also post a user-defined windows message when a notification is
    // received.
    //

    Notify.Wait();

    hr = xCP->Unadvise( dwAdviseID );
    if ( S_OK != hr )
        return hr;

    Notify.Release();

#else

    // Poll for query completion

    XInterface<IDBAsynchStatus> xIDBAsynch;
    hr = pRowset->QueryInterface( IID_IDBAsynchStatus,
                                  xIDBAsynch.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    do
    {
        DBCOUNTITEM Numerator, Denominator;
        DBASYNCHPHASE Phase;
        hr = xIDBAsynch->GetStatus( DB_NULL_HCHAPTER,
                                    DBASYNCHOP_OPEN,
                                    &Numerator,
                                    &Denominator,
                                    &Phase,
                                    0 );
        if ( FAILED( hr ) )
            return hr;

        if ( DBASYNCHPHASE_COMPLETE == Phase )
            break;

        Sleep( 50 );  // Give the query a chance to run
    } while ( TRUE );

#endif

    return hr;
} //WaitForQueryToComplete

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryScope]      - Root path for all results
//              [pwcQueryCatalog]    - Catalog name over which query is run
//              [pwcQueryMachine]    - Machine name on which query is run
//              [pwcQueryRestrition] - The actual query string
//              [fDisplayTree]       - TRUE to display the command tree
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcQueryScope,
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryRestriction,
    BOOL          fDisplayTree )
{
    // Create an ICommand object.  The default scope for the query is the
    // entire catalog.

    XInterface<ICommand> xICommand;
    HRESULT hr = CreateICommand( xICommand.GetPPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Set the scope, catalog, and machine in the ICommand

    hr = SetScopeCatalogAndMachine( xICommand.GetPointer(),
                                    pwcQueryScope,
                                    pwcQueryCatalog,
                                    pwcQueryMachine );
    if ( FAILED( hr ) )
        return hr;

    // Set required properties on the ICommand

    hr = SetCommandProperties( xICommand.GetPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Create an OLE DB query tree from a text restriction

    DBCOMMANDTREE * pTree;
    hr = CreateQueryTree( pwcQueryRestriction, // the input query
                          &pTree );            // the output tree
    if ( FAILED( hr ) )
        return hr;

    // If directed, display the command tree

    if ( fDisplayTree )
        DisplayCommandTree( pTree );

    // Set the tree in the ICommandTree

    XInterface<ICommandTree> xICommandTree;
    hr = xICommand->QueryInterface( IID_ICommandTree,
                                    xICommandTree.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xICommandTree->SetCommandTree( &pTree,
                                        DBCOMMANDREUSE_NONE,
                                        FALSE );
    if ( FAILED( hr ) )
        return hr;

    // Execute the query.  The query is asynchronously executed.

    XInterface<IRowset> xIRowset;
    hr = xICommand->Execute( 0,            // no aggregating IUnknown
                             IID_IRowset,  // IID for interface to return
                             0,            // no DBPARAMs
                             0,            // no rows affected
                             xIRowset.GetIUPointer() ); // result
    if ( FAILED( hr ) )
        return hr;

    // Wait for the query to complete, since DBPROP_IDBAsynchStatus was set
    // as a command property.  If DBPROP_IDBAsynchStatus isn't set, Execute()
    // is synchronous and there is no need to wait for completion here.

    hr = WaitForQueryToComplete( xIRowset.GetPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Create an accessor, so data can be retrieved from the rowset

    XInterface<IAccessor> xIAccessor;
    hr = xIRowset->QueryInterface( IID_IAccessor,
                                   xIAccessor.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Column iOrdinals are parallel with those passed to CiTextToFullTree,
    // so MapColumnIDs isn't necessary.  These binding values for dwPart,
    // dwMemOwner, and wType are the most optimal bindings for Indexing
    // Service.

    const ULONG cColumns = 3; // 3 for Rank, Size, and Path
    DBBINDING aColumns[ cColumns ];
    memset( aColumns, 0, sizeof aColumns );

    aColumns[0].iOrdinal   = 1; // first column specified above (rank)
    aColumns[0].obValue    = 0; // offset where value is written in GetData
    aColumns[0].dwPart     = DBPART_VALUE;  // retrieve value, not status
    aColumns[0].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Provider owned
    aColumns[0].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT *

    aColumns[1] = aColumns[0];
    aColumns[1].iOrdinal   = 2; // second column specified above (size)
    aColumns[1].obValue    = sizeof (PROPVARIANT *); // offset for value

    aColumns[2] = aColumns[0];
    aColumns[2].iOrdinal   = 3; // third column specified above (path)
    aColumns[2].obValue    = 2 * sizeof (PROPVARIANT *); // offset for value

    HACCESSOR hAccessor;
    hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                     cColumns,           // # of columns
                                     aColumns,           // columns
                                     0,                  // ignored
                                     &hAccessor,         // result
                                     0 );                // no status
    if ( FAILED( hr ) )
        return hr;

    // Display the results of the query.  Print file size and file path.

    printf( " Rank       Size  Path\n" );

    DBCOUNTITEM cRowsSoFar = 0;

    do
    {
        DBCOUNTITEM cRowsReturned = 0;
        const ULONG cRowsAtATime = 10;
        HROW aHRow[cRowsAtATime];
        HROW * pgrHRows = aHRow;
        hr = xIRowset->GetNextRows( 0,              // no chapter
                                    0,              // no rows to skip
                                    cRowsAtATime,   // # rows to get
                                    &cRowsReturned, // # rows returned
                                    &pgrHRows);     // resulting hrows

        if ( FAILED( hr ) )
            break;

        for ( DBCOUNTITEM iRow = 0; iRow < cRowsReturned; iRow++ )
        {
            PROPVARIANT * aData[cColumns];
            hr = xIRowset->GetData( aHRow[iRow],  // hrow being accessed
                                    hAccessor,    // accessor to use
                                    &aData );     // resulting data
            if ( FAILED( hr ) )
                break;

            if ( VT_I4 ==     aData[0]->vt &&
                 VT_I8 ==     aData[1]->vt &&
                 VT_LPWSTR == aData[2]->vt )
                printf( "%5d %10I64d  %ws\n",
                        aData[0]->lVal,
                        aData[1]->hVal,
                        aData[2]->pwszVal );
            else
                printf( "could not retrieve a file's values\n" );
        }

        if ( 0 != cRowsReturned )
            xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                   aHRow,         // rows to release
                                   0,             // no options
                                   0,             // no refcounts
                                   0 );           // no status

        if ( DB_S_ENDOFROWSET == hr )
        {
            hr = S_OK; // succeeded, return S_OK from DoQuery
            break;
        }

        if ( FAILED( hr ) )
            break;

        cRowsSoFar += cRowsReturned;
    } while ( TRUE );

    printf( "%d files matched the query '%ws'\n",
            cRowsSoFar,
            pwcQueryRestriction );

    xIAccessor->ReleaseAccessor( hAccessor, 0 );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "usage: ADVQUERY query [/c:catalog] [/m:machine] [/s:scope] [/d]\n\n" );
    printf( "    query        word or phrase used for the search\n" );
    printf( "    /c:catalog   name of the catalog, default is SYSTEM\n" );
    printf( "    /m:machine   name of the machine, default is local machine\n" );
    printf( "    /s:scope     root path, default is entire catalog (\\) \n" );
    printf( "    /d           display the DBCOMMANDTREE, default is off\n" );
    exit( -1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments
//              and issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcScope       = L"\\";     // default scope: entire catalog
    WCHAR const * pwcCatalog     = L"system"; // default: system catalog
    WCHAR const * pwcMachine     = L".";      // default: local machine
    WCHAR const * pwcRestriction = 0;         // no default restriction
    BOOL fDisplayTree            = FALSE;     // don't display the tree

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = toupper( argv[i][1] );

            if ( ':' != argv[i][2] && 'D' != wc )
                Usage();

            if ( 'C' == wc )
                pwcCatalog = argv[i] + 3;
            else if ( 'M' == wc )
                pwcMachine = argv[i] + 3;
            else if ( 'S' == wc )
                pwcScope = argv[i] + 3;
            else if ( 'D' == wc )
                fDisplayTree = TRUE;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction is necessary.  Fail if none is given.

    if ( 0 == pwcRestriction )
        Usage();

    // Initialize COM

    HRESULT hr = CoInitialize( 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Run the query

        hr = DoQuery( pwcScope,
                      pwcCatalog,
                      pwcMachine,
                      pwcRestriction,
                      fDisplayTree );

        CoUninitialize();
    }

    if ( FAILED( hr ) )
    {
        printf( "the query '%ws' failed with error %#x\n",
                pwcRestriction, hr );
        return -1;
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              31-Jul-96 MikeHill  - Relaxed assert in IsUnicodeString.
//                                  - Allow NULL strings.
//              14-May-97 mohamedn  - Allow marshalling of VT_ARRAY
//              28 Apr 98 AlanW     - Added all permitted VARIANT types
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propset.h>
#include <propvar.h>

#include "debtrace.hxx"

#undef PROPASSERT
#define PROPASSERT Win4Assert

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
        ULONG i, cchDoubleAnsi, cchNull;

        cchNull = cchDoubleAnsi = 0;
        for (i = 0; pwszname[i] != L'\0'; i++)
        {
            if ((char) pwszname[i] == '\0' || (char) (pwszname[i] >> 8) == '\0')
            {
                cchNull++;
                if (i > 8 && cchDoubleAnsi > (3*i)/4)
                {
                    return(TRUE);
                }
            }
            else
            if (isprint((char) pwszname[i]) && isprint((char) (pwszname[i] >> 8)))
            {
                cchDoubleAnsi++;
            }
        }

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
        ULONG i;

        // If the string is NULL, then it's not not an Ansi string,
        // so we'll call it an Ansi string.

        if( NULL == pszname )
            return( TRUE );

        for (i = 0; pszname[i] != '\0'; i++)
        {
        }
        if (i == 1 && isprint(pszname[0]) &&
            ((ULONG_PTR) &pszname[8] & 0xfff) == ((ULONG_PTR) pszname & 0xfff) &&
            isprint(pszname[2]) && pszname[3] == '\0' &&
            isprint(pszname[4]) && pszname[5] == '\0' &&
            isprint(pszname[6]) && pszname[7] == '\0')
        {
            PROPASSERT(!"IsAnsiString: Suspicious string: looks like Unicode");
            return(FALSE);
        }

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif


//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::UnmarshalledSize, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [cb]  -- size of *additional* data goes here.  Size of
//                      base PROPVARIANT not included.
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//
//  Notes:     The size is computed assuming 4-byte granular allocations.
//
//--------------------------------------------------------------------

#if defined(WINNT) && !defined(IPROPERTY_DLL)

//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::Unmarshall, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [var] -- unmarshalled PROPVARIANT instance
//             [MemAlloc] -- memory allocator for unmarshalling
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INSUFFICIENT_RESOURCES -- out of memory.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//
//--------------------------------------------------------------------

NTSTATUS
CBaseStorageVariant::Unmarshall(
    PDeSerStream& stm,
    PROPVARIANT& var,
    PMemoryAllocator &MemAlloc)
{
#if DBG
    switch (stm.PeekULong())
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_VERSIONED_STREAM:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
    case VT_VECTOR | VT_CLSID:
    case VT_VECTOR | VT_CF:
    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
    case VT_VECTOR | VT_VARIANT:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
        break;

    default:
        PROPASSERT(!"Invalid type (peek) for PROPVARIANT unmarshalling");
        break;
    }
#endif

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbAlloc = 0;
    VOID **ppv = NULL;
    BOOLEAN fZero = FALSE;

    // Zero the entire variant data structure before assembling it together.
    RtlZeroMemory(&var, sizeof(PROPVARIANT));

    var.vt = (VARTYPE) stm.GetULong();

    switch (var.vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I1:
    case VT_UI1:
        var.bVal = stm.GetByte();
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        var.iVal = stm.GetUShort();
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_INT:
    case VT_UINT:
        var.lVal = stm.GetULong();
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.GetBlob((BYTE *)&var.hVal, sizeof(LARGE_INTEGER));
        break;

    case VT_DECIMAL:
        stm.GetBlob((BYTE *)&var, sizeof(DECIMAL));
        var.vt = VT_DECIMAL;
        break;

    case VT_CLSID:
        cbAlloc = sizeof(GUID);
        ppv = (void **)&var.puuid;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        var.blob.cbSize = stm.GetULong();
        cbAlloc = var.blob.cbSize;
        ppv = (void **)&var.blob.pBlobData;
        break;

    case VT_CF:
        var.pclipdata = (CLIPDATA *) MemAlloc.Allocate(sizeof(*var.pclipdata));
        if (var.pclipdata == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        var.pclipdata->cbSize = stm.GetULong();
        cbAlloc = CBPCLIPDATA(*var.pclipdata);
        var.pclipdata->ulClipFmt = stm.GetULong();
        ppv = (void **) &var.pclipdata->pClipData;
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_VERSIONED_STREAM:
        // NTRAID#DB-NTBUG9-84615-2000/07/31-dlee Some VT types not supported by Indexing Service

        var.vt = VT_EMPTY;
        break;

    case VT_BSTR:
        cbAlloc = stm.GetULong();
        ppv = (void **)&var.bstrVal;
        break;

    case VT_LPSTR:
        cbAlloc = stm.GetULong();
        ppv = (void **)&var.pszVal;
        break;

    case VT_LPWSTR:
        cbAlloc = stm.GetULong() * sizeof(WCHAR);
        ppv = (void **)&var.pwszVal;
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        var.caub.cElems = stm.GetULong();
        cbAlloc = var.caub.cElems * sizeof(BYTE);
        ppv = (void **)&var.caub.pElems;
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        var.cai.cElems = stm.GetULong();
        cbAlloc = var.cai.cElems * sizeof(SHORT);
        ppv = (void **)&var.cai.pElems;
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        var.cal.cElems = stm.GetULong();
        cbAlloc = var.cal.cElems * sizeof(LONG);
        ppv = (void **)&var.cal.pElems;
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        var.cah.cElems = stm.GetULong();
        cbAlloc = var.cah.cElems * sizeof(LARGE_INTEGER);
        ppv = (void **)&var.cah.pElems;
        break;

    case VT_VECTOR | VT_CLSID:
        var.cauuid.cElems = stm.GetULong();
        cbAlloc = var.cauuid.cElems * sizeof(GUID);
        ppv = (void **)&var.cauuid.pElems;
        break;

    case VT_VECTOR | VT_CF:
        var.caclipdata.cElems = stm.GetULong();
        cbAlloc = var.caclipdata.cElems * sizeof(CLIPDATA);
        ppv = (void **)&var.caclipdata.pElems;
        fZero = TRUE;   // set all pClipData pointers to NULL
        break;

    case VT_VECTOR | VT_BSTR:
        var.cabstr.cElems = stm.GetULong();
        cbAlloc = var.cabstr.cElems * sizeof(BSTR);
        ppv = (void **)&var.cabstr.pElems;
        fZero = TRUE;   // set all BSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPSTR:
        var.calpstr.cElems = stm.GetULong();
        cbAlloc = var.calpstr.cElems * sizeof(LPSTR);
        ppv = (void **)&var.calpstr.pElems;
        fZero = TRUE;   // set all LPSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPWSTR:
        var.calpwstr.cElems = stm.GetULong();
        cbAlloc = var.calpwstr.cElems * sizeof(LPWSTR);
        ppv = (void **)&var.calpwstr.pElems;
        fZero = TRUE;   // set all LPWSTR pointers to NULL
        break;

    case VT_VECTOR | VT_VARIANT:
        var.capropvar.cElems = stm.GetULong();
        cbAlloc = var.capropvar.cElems * sizeof(PROPVARIANT);
        ppv = (void **)&var.capropvar.pElems;
        fZero = TRUE;   // set all vt pointers to VT_EMPTY
        PROPASSERT(VT_EMPTY == 0);
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
    {
        unsigned short cDims = stm.GetUShort();
        SAFEARRAY * psaDest;
        HRESULT hr = SafeArrayAllocDescriptorEx( var.vt & (~VT_ARRAY),
                                                 cDims,
                                                 &psaDest );

        if ( FAILED( hr ) )
            return hr;

        var.parray = psaDest;

        psaDest->fFeatures = stm.GetUShort();
        psaDest->cbElements= stm.GetULong();

        // Override what was written to support Win64 interop

        if ( (VT_ARRAY | VT_BSTR) == var.vt )
            psaDest->cbElements = sizeof(void *);
        else if ( (VT_ARRAY | VT_VARIANT) == var.vt )
            psaDest->cbElements = sizeof PROPVARIANT;

        psaDest->cLocks = 0; // no one has this locked, and if it's
                             // locked, it can't be freed

        for ( unsigned i = 0; i < cDims; i++ )
        {
            psaDest->rgsabound[i].cElements = stm.GetULong();
            psaDest->rgsabound[i].lLbound   = stm.GetLong();
        }

        ppv = (void **) &(psaDest->pvData);
        fZero = TRUE;   // set all vt pointers to VT_EMPTY
        break;
    }

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT unmarshalling");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if ( FAILED( Status ) )
        return Status;

    if ( ( 0 == ( var.vt & VT_ARRAY ) ) &&
         ( cbAlloc == 0 || Status != STATUS_SUCCESS ) )
    {
        // No further work need be done. The Ummarshalling is complete,
        // i.e., fixed size variant or no variable length data.

        if (ppv != NULL)
            *ppv = NULL;

        return(Status);
    }

    // Guard against attack

    if ( cbAlloc >= 65536 )
        return E_INVALIDARG;

    // Allocate the desired amount of memory and continue unmarshalling
    // if allocation was successfull.

    PROPASSERT(ppv != NULL);

    if ( var.vt == VT_BSTR )
    {
        *ppv = (void *)SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR))/sizeof(OLECHAR) );
    }
    else if ( 0 != ( VT_ARRAY & var.vt ) )
    {
        HRESULT hr = SafeArrayAllocData( var.parray );

        if ( FAILED( hr ) )
            return hr;

        Win4Assert( 0 != *ppv );
    }
    else
    {
        *ppv = MemAlloc.Allocate(cbAlloc);
    }

    if (0 == *ppv )
        return STATUS_INSUFFICIENT_RESOURCES;

    if (fZero)
        RtlZeroMemory(*ppv, cbAlloc);

    ULONG i;

    // We have a variant with variable sized data which requires
    // further unmarshalling.
    switch(var.vt)
    {
    case VT_CLSID:
        stm.GetBlob((BYTE *)var.puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.GetBlob(var.blob.pBlobData, var.blob.cbSize);
        break;

    case VT_CF:
        stm.GetBlob(var.pclipdata->pClipData, CBPCLIPDATA(*var.pclipdata));
        break;

    case VT_BSTR:
        stm.GetChar((char *) var.bstrVal, cbAlloc );
        break;

    case VT_LPSTR:
        stm.GetChar(var.pszVal, cbAlloc);
        break;

    case VT_LPWSTR:
        stm.GetWChar(var.pwszVal, cbAlloc / sizeof(WCHAR));
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        for (i = 0; i < var.caub.cElems; i++)
        {
            var.caub.pElems[i] = stm.GetByte();
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        for (i = 0; i < var.cai.cElems; i++)
        {
            var.cai.pElems[i] = stm.GetUShort();
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        for (i = 0; i < var.cal.cElems; i++)
        {
            var.cal.pElems[i] = stm.GetULong();
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        for (i = 0; i < var.cah.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        for (i = 0; i < var.cauuid.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        for (i = 0; i < var.caclipdata.cElems; i++)
        {
            PROPASSERT(var.caclipdata.pElems[i].pClipData == NULL);
            var.caclipdata.pElems[i].cbSize = stm.GetULong();
            cbAlloc = CBPCLIPDATA(var.caclipdata.pElems[i]);
            var.caclipdata.pElems[i].ulClipFmt = stm.GetULong();
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.caclipdata.pElems[i].pClipData =
                (BYTE *) MemAlloc.Allocate(cbAlloc);
            if (var.caclipdata.pElems[i].pClipData == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetBlob(var.caclipdata.pElems[i].pClipData, cbAlloc);
        }
        break;

    case VT_VECTOR | VT_BSTR:
        for (i = 0; i < var.cabstr.cElems; i++)
        {
            PROPASSERT(var.cabstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            // cbAlloc includes sizeof(OLECHAR)
            var.cabstr.pElems[i] = SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR)) / sizeof(OLECHAR) );
            if (var.cabstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetChar((char *) var.cabstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        for (i = 0; i < var.calpstr.cElems; i++)
        {
            PROPASSERT(var.calpstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpstr.pElems[i] = (LPSTR) MemAlloc.Allocate(cbAlloc);
            if (var.calpstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetChar(var.calpstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        for (i = 0; i < var.calpwstr.cElems; i++)
        {
            PROPASSERT(var.calpwstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();   // actually, a count of WCHARs

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpwstr.pElems[i] = (WCHAR *) MemAlloc.Allocate(cbAlloc * sizeof(WCHAR));
            if (var.calpwstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetWChar(var.calpwstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        for (i = 0; i < var.capropvar.cElems; i++)
        {
            PROPASSERT(var.capropvar.pElems[i].vt == VT_EMPTY);
            Status = CBaseStorageVariant::Unmarshall(
                                            stm,
                                            var.capropvar.pElems[i],
                                            MemAlloc);
            if (Status != STATUS_SUCCESS)
            {
               break;
            }
        }
        break;


    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
        {
            SAFEARRAY *pSaDest       = var.parray;
            unsigned  cDataElements  = 1;

            //
            // get total # of data elements to be unmarshalled.
            //
            for ( i = 0; i < pSaDest->cDims; i++)
            {
                cDataElements *= pSaDest->rgsabound[i].cElements;
            }

            //
            // unmarshall data elements
            //
            switch (var.vt)
            {
            case VT_ARRAY | VT_I1:
            case VT_ARRAY | VT_UI1:
                 {
                    BYTE * pByte = (BYTE *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                          pByte[i] = stm.GetByte();
                 }
                 break;

            case VT_ARRAY | VT_I2:
            case VT_ARRAY | VT_UI2:
            case VT_ARRAY | VT_BOOL:
                 {
                    Win4Assert( sizeof VARIANT_BOOL == sizeof USHORT );

                    USHORT * pUShort = (USHORT *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                          pUShort[i] = stm.GetUShort();
                 }
                 break;

            case VT_ARRAY | VT_I4:
            case VT_ARRAY | VT_UI4:
            case VT_ARRAY | VT_INT:
            case VT_ARRAY | VT_UINT:
            case VT_ARRAY | VT_R4:
            case VT_ARRAY | VT_ERROR:
                 {
                    Win4Assert( sizeof(ULONG) == sizeof (INT) );
                    Win4Assert( sizeof(ULONG) == sizeof (UINT) );
                    Win4Assert( sizeof(ULONG) == sizeof (SCODE) ); // VT_ERROR

                    ULONG * pULong = (ULONG *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                    {
                          pULong[i] = stm.GetULong();
                    }
                 }
                 break;

            case VT_ARRAY | VT_R8:
            case VT_ARRAY | VT_CY:
            case VT_ARRAY | VT_DATE:
                 {
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (CY)  );
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (DATE));
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (double));

                    LARGE_INTEGER * pLargInt = (LARGE_INTEGER *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                    {
                        stm.GetBlob( (BYTE *) &pLargInt[i], sizeof(LARGE_INTEGER) );
                    }
                 }
                 break;

            case VT_ARRAY | VT_DECIMAL:
                 {
                    Win4Assert( sizeof (DECIMAL) == pSaDest->cbElements );

                    DECIMAL * pDecVal = (DECIMAL *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                    {
                        stm.GetBlob( (BYTE *) &pDecVal[i], sizeof(DECIMAL) );
                    }
                 }
                 break;

            case VT_ARRAY|VT_BSTR:
                 {
                    BSTR *pBstrDest = (BSTR *) pSaDest->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                    {
                        PROPASSERT( pBstrDest[i] == NULL );

                        cbAlloc = stm.GetULong();   // actually, a count of WCHARs + NULL terminator
                        if ( cbAlloc == 0 || cbAlloc >= 65536 )
                        {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                        // cbAlloc already contains sizeof(OLECHAR), ie null terminator.
                        pBstrDest[i] = (BSTR) SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR)) / sizeof(OLECHAR) );
                        if ( !pBstrDest[i] )
                        {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }

                        stm.GetChar( (char *) pBstrDest[i], cbAlloc );
                    }
                 }
                 break;

            case VT_ARRAY | VT_VARIANT:
                {
                    Win4Assert( sizeof (PROPVARIANT) == pSaDest->cbElements );
                    PROPVARIANT *pVarDest = (PROPVARIANT *) pSaDest->pvData;
                    for (i = 0; i < cDataElements; i++)
                    {
                        PROPASSERT(pVarDest[i].vt == VT_EMPTY);
                        Status = CBaseStorageVariant::Unmarshall(
                                                        stm,
                                                        pVarDest[i],
                                                        MemAlloc);
                        if (Status != STATUS_SUCCESS)
                        {
                           break;
                        }
                    }
                }
                break;

            default:
                Win4Assert( !"Unexpected SAFEARRAY type" );
            }

        }
        break;

    default:
        PROPASSERT(!"Invalid type (peek) for PROPVARIANT unmarshalling");
        break;
    }
    return(Status);
}


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_CF(CLIPDATA *pclipdata, PSerStream &stm)
{
    CLIPDATA clipdata;

    clipdata.cbSize = 0;
    clipdata.ulClipFmt = 0;

    if (pclipdata != NULL)
    {
        clipdata.cbSize = pclipdata->cbSize;
        clipdata.ulClipFmt = pclipdata->ulClipFmt;
        if (pclipdata->pClipData == NULL)
        {
            clipdata.cbSize = 0;
        }
    }
    stm.PutULong(clipdata.cbSize);
    stm.PutULong(clipdata.ulClipFmt);
    if (clipdata.cbSize)
    {
        stm.PutBlob((BYTE *) pclipdata->pClipData, CBPCLIPDATA(clipdata));
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_BSTR(BSTR bstrVal, PSerStream &stm)
{
    if (bstrVal != NULL)
    {
        ULONG cc = BSTRLEN(bstrVal) + sizeof(OLECHAR);

        stm.PutULong(cc);
        stm.PutChar((char *) bstrVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPSTR(CHAR *pszVal, PSerStream &stm)
{
    if (pszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.
        ULONG cc = strlen(pszVal) + 1;

        stm.PutULong(cc);
        stm.PutChar(pszVal, cc);
        PROPASSERT(IsAnsiString(pszVal, cc));
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPWSTR(LPWSTR pwszVal, PSerStream &stm)
{
    if (pwszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.

        ULONG cc = Prop_wcslen(pwszVal) + 1;

        PROPASSERT(IsUnicodeString(pwszVal, cc * sizeof(WCHAR)));
        stm.PutULong(cc);
        stm.PutWChar(pwszVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
void
CBaseStorageVariant::Marshall(PSerStream & stm) const
{
    ULONG i;

    if ((VT_BYREF|VT_VARIANT) == vt)
    {
        PROPASSERT(pvarVal->vt != (VT_BYREF|VT_VARIANT));
        ((CBaseStorageVariant*)pvarVal)->Marshall(stm);
        return;
    }

    stm.PutULong(vt & ~VT_BYREF);

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I1:
    case VT_UI1:
        stm.PutByte(bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        stm.PutUShort(iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        stm.PutULong(lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.PutBlob((BYTE *) &hVal, sizeof(hVal));
        break;

    case VT_DECIMAL:
        stm.PutBlob((BYTE *) &decVal, sizeof(DECIMAL));
        break;

    case VT_CLSID:
        stm.PutBlob((BYTE *)puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.PutULong(blob.cbSize);
        stm.PutBlob(blob.pBlobData, blob.cbSize);
        break;

    case VT_CF:
        _Marshall_VT_CF(pclipdata, stm);
        break;

    case VT_STREAM:
    case VT_VERSIONED_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
        // NTRAID#DB-NTBUG9-84615-2000/07/31-dlee Some VT types not supported by Indexing Service
        break;

    case VT_BSTR:
        _Marshall_VT_BSTR(bstrVal, stm);
        break;

    case VT_LPSTR:
        _Marshall_VT_LPSTR(pszVal, stm);
        break;

    case VT_LPWSTR:
        _Marshall_VT_LPWSTR(pwszVal, stm);
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        stm.PutULong(caub.cElems);
        for (i = 0; i < caub.cElems; i++)
        {
            stm.PutByte(caub.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        stm.PutULong(cai.cElems);
        for (i = 0; i < cai.cElems; i++)
        {
            stm.PutUShort(cai.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        stm.PutULong(cal.cElems);
        for (i = 0; i < cal.cElems; i++)
        {
            stm.PutULong(cal.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        stm.PutULong(cah.cElems);
        for (i = 0; i < cah.cElems; i++)
        {
            stm.PutBlob((BYTE *) &cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        stm.PutULong(cauuid.cElems);
        for (i = 0; i < cauuid.cElems; i++)
        {
            stm.PutBlob((BYTE *)&cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        stm.PutULong(caclipdata.cElems);
        for (i = 0; i < caclipdata.cElems; i++)
        {
            _Marshall_VT_CF(&caclipdata.pElems[i], stm);
        }
        break;
        break;

    case VT_VECTOR | VT_BSTR:
        stm.PutULong(cabstr.cElems);
        for (i = 0; i < cabstr.cElems; i++)
        {
            _Marshall_VT_BSTR(cabstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        stm.PutULong(calpstr.cElems);
        for (i = 0; i < calpstr.cElems; i++)
        {
            _Marshall_VT_LPSTR(calpstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        stm.PutULong(calpwstr.cElems);
        for (i = 0; i < calpwstr.cElems; i++)
        {
            _Marshall_VT_LPWSTR(calpwstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        stm.PutULong(capropvar.cElems);
        for (i = 0; i < capropvar.cElems; i++)
        {
            ((CBaseStorageVariant &) capropvar.pElems[i]).Marshall(stm);
        }
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
         {
            SAFEARRAY *pSa = parray;
            unsigned   cDataElements = 1;

            stm.PutUShort(pSa->cDims);
            stm.PutUShort(pSa->fFeatures);
            stm.PutULong(pSa->cbElements);
            // don't marshall cLocks member, set to 1 upon unmarshalling

            //
            // marshall rgsabound
            //
            for ( i = 0; i < pSa->cDims; i++ )
            {
                stm.PutULong(pSa->rgsabound[i].cElements);
                stm.PutLong(pSa->rgsabound[i].lLbound);
                cDataElements *= pSa->rgsabound[i].cElements;
            }

            //
            // marshall pvData
            //
            switch ( vt )
            {

            case VT_ARRAY | VT_I1:
            case VT_ARRAY | VT_UI1:
                 {
                    BYTE * pByte = (BYTE *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutByte(pByte[i]);
                 }
                 break;

            case VT_ARRAY | VT_I2:
            case VT_ARRAY | VT_UI2:
            case VT_ARRAY | VT_BOOL:
                 {
                    Win4Assert( sizeof VARIANT_BOOL == sizeof USHORT );

                    USHORT * pUShort = (USHORT *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutUShort(pUShort[i]);
                 }
                 break;

            case VT_ARRAY | VT_I4:
            case VT_ARRAY | VT_UI4:
            case VT_ARRAY | VT_INT:
            case VT_ARRAY | VT_UINT:
            case VT_ARRAY | VT_R4:
            case VT_ARRAY | VT_ERROR:
                 {
                    Win4Assert( sizeof(ULONG) == sizeof (INT) );
                    Win4Assert( sizeof(ULONG) == sizeof (UINT) );
                    Win4Assert( sizeof(ULONG) == sizeof (SCODE) ); // VT_ERROR

                    ULONG * pULong = (ULONG *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutULong(pULong[i]);
                 }
                 break;

            case VT_ARRAY | VT_R8:
            case VT_ARRAY | VT_CY:
            case VT_ARRAY | VT_DATE:
                 {
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (CY)  );
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (DATE));
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (double));

                    LARGE_INTEGER * pLargInt = (LARGE_INTEGER *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutBlob( (BYTE *) &pLargInt[i], sizeof(LARGE_INTEGER) );
                 }
                 break;

            case VT_ARRAY | VT_DECIMAL:
                 {
                    Win4Assert( sizeof (DECIMAL) == pSa->cbElements );

                    DECIMAL * pDecVal = (DECIMAL *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutBlob( (BYTE *) &pDecVal[i], sizeof(DECIMAL) );
                 }
                 break;

            case VT_ARRAY | VT_BSTR:
                 {
                    for ( i = 0 ; i < cDataElements; i++ )
                        _Marshall_VT_BSTR( ((BSTR *)pSa->pvData)[i], stm );
                 }
                 break;

            case VT_ARRAY | VT_VARIANT:
                 {
                    PROPVARIANT *pVarnt = (PROPVARIANT *) pSa->pvData;
                    for ( i = 0 ; i < cDataElements; i++ )
                        ((CBaseStorageVariant &) pVarnt[i]).Marshall(stm);
                 }
                 break;

            default:
                Win4Assert( !"Invalid SAFEARRAY type" );

            }
         }

         break;

    case VT_BYREF | VT_I1:
    case VT_BYREF | VT_UI1:
        stm.PutByte(*pbVal);
        break;

    case VT_BYREF | VT_I2:
    case VT_BYREF | VT_UI2:
    case VT_BYREF | VT_BOOL:
        stm.PutUShort(*piVal);
        break;

    case VT_BYREF | VT_I4:
    case VT_BYREF | VT_UI4:
    case VT_BYREF | VT_INT:
    case VT_BYREF | VT_UINT:
    case VT_BYREF | VT_R4:
    case VT_BYREF | VT_ERROR:
        stm.PutULong(*plVal);
        break;

    case VT_BYREF | VT_R8:
    case VT_BYREF | VT_CY:
    case VT_BYREF | VT_DATE:
        stm.PutBlob((BYTE *) pdblVal, sizeof(double));
        break;

    case VT_BYREF | VT_DECIMAL:
        stm.PutBlob((BYTE *) pdecVal, sizeof(DECIMAL));
        break;

    case VT_BYREF | VT_BSTR:
        _Marshall_VT_BSTR( *pbstrVal, stm );
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT marshalling");
        break;

    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef OLDSUMCATAPI
void
MarshallVariant(PSerStream &stm, PROPVARIANT &stgvar)
{
    CBaseStorageVariant *pstgvar = (CBaseStorageVariant *)&stgvar;
    pstgvar->Marshall(stm);
}
#endif //ifdef OLDSUMCATAPI


#ifdef ENABLE_DISPLAY_VARIANT
VOID
CBaseStorageVariant::DisplayVariant(
    ULONG ulLevel,
    USHORT CodePage) const
{
    char *psz;

    switch (vt)
    {
    case VT_ILLEGAL: psz = "ILLEGAL"; goto EmptyType;
    case VT_EMPTY:   psz = "EMPTY";   goto EmptyType;
    case VT_NULL:    psz = "NULL";    goto EmptyType;

BlobType:
EmptyType:
        DEBTRACE((DBGFLAG "%s", psz));
        break;

    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
        DEBTRACE((DBGFLAG "UI1=%hx", bVal));
        break;

    case VT_I2:  psz = "I2";  goto ShortType;
    case VT_UI2: psz = "UI2"; goto ShortType;

ShortType:
        AssertShortField(iVal);                 // VT_I2
        AssertShortField(uiVal);                // VT_UI2
        DEBTRACE((DBGFLAG "%s=%hx", psz, iVal));
        break;

    case VT_BOOL:
        switch (boolVal)
        {
            case VARIANT_TRUE:
                DEBTRACE((DBGFLAG "BOOL=TRUE"));
                break;

            case FALSE:
                DEBTRACE((DBGFLAG "BOOL=FALSE"));
                break;

            default:
                DEBTRACE((DBGFLAG "BOOL=%hx???", boolVal));
                break;
        }
        break;

    case VT_I4:    psz = "I4";    goto LongType;
    case VT_UI4:   psz = "UI4";   goto LongType;
    case VT_R4:    psz = "R4";    goto LongType;
    case VT_ERROR: psz = "ERROR"; goto LongType;

LongType:
        AssertLongField(lVal);                  // VT_I4
        AssertLongField(ulVal);                 // VT_UI4
        AssertLongField(fltVal);                // VT_R4
        AssertLongField(scode);                 // VT_ERROR
        DEBTRACE((DBGFLAG "%s=%x", psz, lVal));
        break;

    case VT_I8:       psz = "I8";       goto LongLongType;
    case VT_UI8:      psz = "UI8";      goto LongLongType;
    case VT_R8:       psz = "R8";       goto LongLongType;
    case VT_CY:       psz = "CY";       goto LongLongType;
    case VT_DATE:     psz = "DATE";     goto LongLongType;
    case VT_FILETIME: psz = "FILETIME"; goto LongLongType;

LongLongType:
        AssertLongLongField(hVal);              // VT_I8
        AssertLongLongField(uhVal);             // VT_UI8
        AssertLongLongField(dblVal);            // VT_R8
        AssertLongLongField(cyVal);             // VT_CY
        AssertLongLongField(date);              // VT_DATE
        AssertLongLongField(filetime);          // VT_FILETIME
        DEBTRACE((DBGFLAG "%s=%x:%x", psz, hVal.HighPart, hVal.LowPart));
        break;

    case VT_CLSID: psz = "CLSID"; goto EmptyType;

    case VT_BLOB:        psz = "BLOB";        goto BlobType;
    case VT_BLOB_OBJECT: psz = "BLOB_OBJECT"; goto BlobType;
    case VT_CF:          psz = "CF";          goto BlobType;

    case VT_STREAM:          psz = "STREAM";          goto TestUnicode;
    case VT_STREAMED_OBJECT: psz = "STREAMED_OBJECT"; goto TestUnicode;
    case VT_STORAGE:         psz = "STORAGE";         goto TestUnicode;
    case VT_STORED_OBJECT:   psz = "STORED_OBJECT";   goto TestUnicode;
    case VT_VERSIONED_STREAM:  psz = "VERSIONED_STREAM";   goto TestUnicode;
    case VT_LPSTR:           psz = "LPSTR";           goto TestUnicode;

TestUnicode:
        AssertStringField(pszVal);              // VT_STREAM, VT_STREAMED_OBJECT
        AssertStringField(pszVal);              // VT_STORAGE, VT_STORED_OBJECT
        AssertStringField(pszVal);              // VT_LPSTR
        DEBTRACE((
            DBGFLAG
            CodePage == CP_WINUNICODE? "%s=L'%ws'" : "%s='%s'",
            psz,
            pszVal));
        break;

    case VT_BSTR:            psz = "BSTR";            goto PrintUnicode;
    case VT_LPWSTR:          psz = "LPWSTR";          goto PrintUnicode;

PrintUnicode:
        AssertStringField(pwszVal);             // VT_LPWSTR
        AssertStringField(bstrVal);             // VT_BSTR
        DEBTRACE((DBGFLAG "%s=L'%ws'", psz, pwszVal));
        break;

    default:
        if (vt & VT_VECTOR)
        {
            DEBTRACE((DBGFLAG "UNPRINTABLE VECTOR TYPE=%x(%u)", vt, vt));
        }
        else
        {
            DEBTRACE((DBGFLAG "UNKNOWN TYPE=%x(%u)", vt, vt));
        }
        break;

    }
}
#endif //ifdef ENABLE_DISPLAY_VARIANT

#endif //ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\pidremap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       pidmap.cxx
//
//  Contents:   Maps pid <--> property name.
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidremap.hxx>
#include <coldesc.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::CPidRemapper, public
//
//  Synopsis:   Creates a prop id remapper.  Translates input arguments
//              'fake' propids to real propids.
//
//  Arguments:  [pidmap]      - input prop ID mapping array
//              [xPropMapper] - property mapper for real pid lookup
//              [prst]        - optional restriction, pids will be mapped
//              [pcol]        - optional output columns, pids will be mapped
//              [pso]         - optional sort specification, pids will be mapped
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

CPidRemapper::CPidRemapper( const CPidMapper & pidmap,
                            XInterface<IPropertyMapper> & xPropMapper,
                            CRestriction * prst,
                            CColumnSet * pcol,
                            CSortSet * pso )
        : _xPropMapper( xPropMapper.Acquire() ),
          _fAnyStatProps( FALSE ),
          _fContentProp ( FALSE ),
          _fRankVectorProp( FALSE ),
          _cRefs( 1 )
{
    _cpidReal = pidmap.Count();
    _xaPidReal.Set( _cpidReal, new PROPID[ _cpidReal ] );

    //
    // Iterate through the list
    //

    for ( unsigned i = 0; i < _cpidReal; i++ )
    {
        PROPID pid;
        FULLPROPSPEC const * pFullPropSpec =  pidmap.Get(i)->CastToStruct();
        SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &pid );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        _xaPidReal[i] = pid;

        if ( IsUserDefinedPid( _xaPidReal[i] ) )
        {
            //
            // Any user-defined property is a content property.
            // Note that the document characterization is a user-defined prop.
            //
            _fContentProp = TRUE;
        }
        else
        {
            if ( _xaPidReal[i] == pidContents )
                _fContentProp = TRUE;
            else
                _fAnyStatProps = TRUE;

            if ( _xaPidReal[i] == pidRankVector )
                _fRankVectorProp = TRUE;
        }

#if CIDBG == 1
        if ( vqInfoLevel & DEB_ITRACE )
        {
            CFullPropSpec const & ps = *pidmap.Get(i);

            GUID const & guid = ps.GetPropSet();

            char szGuid[50];

            sprintf( szGuid,
                     "%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                     guid.Data1,
                     guid.Data2,
                     guid.Data3,
                     guid.Data4[0], guid.Data4[1],
                     guid.Data4[2], guid.Data4[3],
                     guid.Data4[4], guid.Data4[5],
                     guid.Data4[6], guid.Data4[7] );

            vqDebugOut(( DEB_ITRACE, szGuid ));

            if ( ps.IsPropertyName() )
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                             "%ws ",
                             ps.GetPropertyName() ));
            else
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                             "0x%x ",
                             ps.GetPropertyPropid() ));

            vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, " --> pid 0x%x\n",
                         _xaPidReal[i] ));

        }
#endif // CIDBG == 1

        CFullPropSpec * ppsFull = new CFullPropSpec( *pidmap.Get(i) );

        XPtr<CFullPropSpec> xpps(ppsFull);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        _propNames.Add( ppsFull, i );
        xpps.Acquire();

        Win4Assert( _xaPidReal[i] != pidInvalid );
    }

    if ( prst )
        RemapPropid( prst );

    if ( pcol )
        RemapPropid( pcol );

    if ( pso )
        RemapPropid( pso );
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::CPidRemapper, public
//
//  Synopsis:   Creates a prop id remapper.
//
//  Arguments:  [xPropMapper] - Property mapper for real pid lookup
//
//  History:    12-Mar-95   DwightKr    Created
//
//--------------------------------------------------------------------------
CPidRemapper::CPidRemapper( XInterface<IPropertyMapper> & xPropMapper )
        : _xPropMapper( xPropMapper.Acquire() ),
          _cpidReal( 0 ),
          _cRefs( 1 )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::~CPidRemapper, public
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CPidRemapper::~CPidRemapper()
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RealToName, public
//
//  Effects:    Convert a PROPID to a propspec
//
//  Arguments:  [pid] - Given pid
//
//  History:    22-Jan-97     SitaramR         Added header
//
//--------------------------------------------------------------------------

CFullPropSpec const * CPidRemapper::RealToName( PROPID pid ) const
{
    Win4Assert( ! _xaPidReal.IsNull() );

    //
    // Just linear search
    //
    for ( unsigned i = 0;
          i < _cpidReal && _xaPidReal[i] != pid;
          i++
        )
    {
        continue;
    }

    Win4Assert( i < _cpidReal );

    //
    // This can happen if a hacker tries to munge query requests
    //

    if ( i == _cpidReal )
        THROW( CException( E_ABORT ) );

    return( _propNames.Get( i ) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::NameToReal, public
//
//  Effects:    Convert a property which is not necessarily in the pid map
//              to a PROPID.
//
//  Arguments:  [pProperty] - pointer to the propspec.
//
//  Returns:    PROPID - the mapped property ID or pidInvalid.
//
//  History:    28 Jun 94       AlanW   Created
//
//--------------------------------------------------------------------------

PROPID CPidRemapper::NameToReal( CFullPropSpec const * pProperty )
{
    for (unsigned i = 0; i < _cpidReal; i++)
    {
        if (*pProperty == *_propNames.Get(i))
        {
            return _xaPidReal[ i ];
        }
    }

    //
    //  Property is not in the mapping array.  Add it.
    //
    PROPID Prop;
    FULLPROPSPEC const * pFullPropSpec =  pProperty->CastToStruct();
    SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &Prop );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    if (Prop != pidInvalid)
    {
        PROPID *ppidReal = new PROPID[ _cpidReal+1 ];
        memcpy(ppidReal, _xaPidReal.GetPointer(), _cpidReal * sizeof (PROPID));

        //
        // No lock is needed here to prevent races with RealToName since in current
        // usage everything is added in the query path by a single thread before
        // reads happen from multiple threads.
        //

        PROPID *ppidTemp = _xaPidReal.Acquire();
        _xaPidReal.Set( _cpidReal+1, ppidReal );
        delete [] ppidTemp;

        CFullPropSpec * ppsFull = new CFullPropSpec( *pProperty );

        XPtr<CFullPropSpec> xpps(ppsFull);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        _propNames.Add( ppsFull, _cpidReal );
        xpps.Acquire();

        Win4Assert(*_propNames.Get(_cpidReal) == *pProperty);
        _xaPidReal[_cpidReal] = Prop;

        _cpidReal++;
    }

    return Prop;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pRst], converting 'fake' propid to 'real'
//
//  Arguments:  [pRst] -- Restriction
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CRestriction * pRst )
{
    Win4Assert ( pRst != 0 );

    switch( pRst->Type() )
    {
    case RTInternalProp:
    {
        CInternalPropertyRestriction * pPropRst =
            (CInternalPropertyRestriction *)pRst;

        pPropRst->SetPid( FakeToReal( pPropRst->Pid() ) );
        if ( 0 != pPropRst->GetContentHelper() )
            RemapPropid( pPropRst->GetContentHelper() );
        break;
    }

    case RTWord:
    {
        CWordRestriction * pWordRst = (CWordRestriction *)pRst;
        pWordRst->SetPid( FakeToReal( pWordRst->Pid() ) );
        break;
    }

    case RTSynonym:
    {
        CSynRestriction * pSynRst = (CSynRestriction *)pRst;
        CKeyArray & keys = pSynRst->GetKeys();

        for ( int i = keys.Count() - 1; i >= 0; i-- )
        {
            CKey & key = keys.Get(i);
            key.SetPid( FakeToReal( key.Pid() ) );
        }
        break;
    }

    case RTNot:
    {
        CNotRestriction * pnrst = (CNotRestriction *)pRst;

        RemapPropid( pnrst->GetChild() );
        break;
    }

    case RTAnd:
    case RTOr:
    case RTVector:
    case RTProximity:
    case RTPhrase:
    {
        CNodeRestriction * pNodeRst = pRst->CastToNode();

        for ( int i = pNodeRst->Count() - 1; i >= 0; i-- )
        {
            RemapPropid( pNodeRst->GetChild( i ) );
        }
        break;
    }
    case RTRange:
    case RTNone:   // probably a noise word in a vector query
        break;

    default:
        Win4Assert( !"RemapPropid: Unknown type." );
        break;

    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pColumns], converting 'fake' propid to 'real'
//
//  Arguments:  [pColumns] -- Output columns
//
//  History:    22-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CColumnSet * pColumns )
{
    for ( unsigned i = 0; i < pColumns->Count(); i++ )
    {
        pColumns->Get(i) = FakeToReal( pColumns->Get(i) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pSort], converting 'fake' propid to 'real'
//
//  Arguments:  [pSort] -- Restriction
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CSortSet * pSort )
{
    for ( unsigned i = 0; i < pSort->Count(); i++ )
    {
        pSort->Get(i).pidColumn = FakeToReal( pSort->Get(i).pidColumn );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPidRemapper::ReBuild( const CPidMapper & pidmap )
{
    if ( _cpidReal < pidmap.Count() )
    {
        delete [] _xaPidReal.Acquire();

        _cpidReal = 0;

        _xaPidReal.Set( pidmap.Count(), new PROPID[ pidmap.Count() ] );
    }

    _cpidReal = pidmap.Count();

    //
    // Iterate through the list
    //

    for ( unsigned i = 0; i < _cpidReal; i++ )
    {
        PROPID pid;
        FULLPROPSPEC const * pFullPropSpec =  pidmap.Get(i)->CastToStruct();
        SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &pid );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        _xaPidReal[i] = pid;

        Win4Assert( _xaPidReal[i] != pidInvalid );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPidRemapper::Set( XArray<PROPID> & aPids )
{
    delete [] _xaPidReal.Acquire();

    _cpidReal = aPids.Count();
    _xaPidReal.Set( _cpidReal, aPids.Acquire() );
}

//
// This has to go somewhere...
//

UNICODECALLOUTS UnicodeCallouts = { WIN32_UNICODECALLOUTS };



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    22-Jan-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CPidRemapper::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    22-Jan-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CPidRemapper::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::QueryInterface(
    REFIID riid,
    void ** ppvObject)
{
    if ( IID_ICiQueryPropertyMapper == riid )
        *ppvObject = (ICiQueryPropertyMapper *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::PropertyToPropid
//
//  Synopsis:   Convert propspec to pid
//
//  Arguments:  [pFullPropSpec] -- propspec to convert
//              [pPropId]       -- pid returned here
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::PropertyToPropid( const FULLPROPSPEC *pFullPropSpec,
                                                        PROPID *pPropId)
{
    SCODE sc = S_OK;

    TRY
    {
        CFullPropSpec const * pProperty = (CFullPropSpec const *) pFullPropSpec;
        *pPropId = NameToReal( pProperty );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CPidRemapper:PropertyToPropid - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::PropidToProperty
//
//  Synopsis:   Convert pid to propspec
//
//  Arguments:  [pPropId]       -- pid to convert
//              [pFullPropSpec] -- propspec returned here
//
//  Notes:      *ppFullPropSpec is owned by CPidRemapper
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::PropidToProperty( PROPID propId,
                                                        FULLPROPSPEC const **ppFullPropSpec )
{
    SCODE sc = S_OK;

    TRY
    {
        *ppFullPropSpec = RealToName( propId )->CastToStruct();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CPidRemapper:PropidToProperty - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\restrict\stgvara.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       StgVarA.cxx
//
//  Contents:   C++ wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              14-May-97 mohamedn  allocate/deallocate SafeArrays (VT_ARRAY)
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#ifndef _NTDLLBUILD_

#include <propset.h>
#include <propvar.h>
#include <pmalloc.hxx>

CAllocStorageVariant::CAllocStorageVariant(
    BYTE *pb,
    ULONG cb,
    PMemoryAllocator &ma)
{
    vt = VT_BLOB;

    if ( 0 == pb )
    {
        blob.cbSize = 0;
        blob.pBlobData = 0;
    }
    else
    {
        blob.cbSize = cb;
        blob.pBlobData = (BYTE *) ma.Allocate(cb);

        if (blob.pBlobData != NULL)
        {
            memcpy(blob.pBlobData, pb, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    char const *psz,
    PMemoryAllocator &ma)
{
    vt = VT_LPSTR;

    if ( 0 == psz )
    {
        pszVal = 0;
    }
    else
    {
        int cb = strlen(psz) + 1;

        pszVal = (char *) ma.Allocate(cb);

        if (pszVal != NULL)
        {
            memcpy(pszVal, psz, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    WCHAR const *pwsz,
    PMemoryAllocator &ma)
{
    vt = VT_LPWSTR;

    if ( 0 == pwsz )
    {
        pwszVal = 0;
    }
    else
    {
        int cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);

        pwszVal = (WCHAR *) ma.Allocate(cb);

        if (pszVal != NULL)
        {
            memcpy(pwszVal, pwsz, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    CLSID const *pcid,
    PMemoryAllocator &ma)
{
    vt = VT_CLSID;
    puuid = (CLSID *) ma.Allocate(sizeof(CLSID));

    if (puuid != NULL)
    {
        memcpy(puuid, pcid, sizeof(CLSID));
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    VARENUM v,
    ULONG cElements,
    PMemoryAllocator &ma)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        AssertByteVector(cac);                  // VT_I1
        AssertByteVector(caub);                 // VT_UI1
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        AssertShortVector(cai);                 // VT_I2
        AssertShortVector(caui);                // VT_UI2
        AssertShortVector(cabool);              // VT_BOOL
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        AssertLongVector(cal);                  // VT_I4
        AssertLongVector(caul);                 // VT_UI4
        AssertLongVector(caflt);                // VT_R4
        AssertLongVector(cascode);              // VT_ERROR
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        AssertLongLongVector(cah);              // VT_I8
        AssertLongLongVector(cauh);             // VT_UI8
        AssertLongLongVector(cadbl);            // VT_R8
        AssertLongLongVector(cacy);             // VT_CY
        AssertLongLongVector(cadate);           // VT_DATE
        AssertLongLongVector(cafiletime);       // VT_FILETIME
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        AssertVarVector(cauuid, sizeof(GUID));
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        AssertVarVector(caclipdata, sizeof(CLIPDATA));  // VT_CF
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        AssertStringVector(calpwstr);                   // VT_LPWSTR
        AssertStringVector(cabstr);                     // VT_BSTR
        AssertStringVector(calpstr);                    // VT_LPSTR
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_VARIANT:
        AssertVarVector(capropvar, sizeof(PROPVARIANT)); // VT_VARIANT
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) ma.Allocate(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}


#define POINTER_FIXUP(type, field)                 \
  field.pElems = (type *) ma.Allocate(field.cElems * sizeof(field.pElems[0]));\
  if (field.pElems != NULL)                        \
  {                                                \
      memcpy(                                      \
          field.pElems,                            \
          var.field.pElems,                        \
          field.cElems * sizeof(field.pElems[0])); \
  }


CAllocStorageVariant::CAllocStorageVariant(
    PROPVARIANT& var,
    PMemoryAllocator &ma): CBaseStorageVariant(var)
{
    BOOLEAN fNoMemory = FALSE;
    ULONG i;

    //
    // Fixup any pointers
    //

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;

    case VT_CLSID:
        vt = VT_EMPTY;
        SetCLSID(var.puuid, ma);
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        blob.pBlobData = (BYTE *) ma.Allocate(blob.cbSize);
        if (blob.pBlobData == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memcpy(blob.pBlobData, var.blob.pBlobData, blob.cbSize);
        break;

    case VT_CF:
        pclipdata = (CLIPDATA *) ma.Allocate(sizeof(*pclipdata));
        if (pclipdata == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        *pclipdata = *var.pclipdata;
        pclipdata->pClipData = (BYTE *) ma.Allocate(CBPCLIPDATA(*pclipdata));
        if (pclipdata->pClipData == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memcpy(pclipdata->pClipData, var.pclipdata->pClipData, CBPCLIPDATA(*pclipdata));
        break;

    case VT_STREAM:
    case VT_VERSIONED_STREAM:
    case VT_STREAMED_OBJECT:
        pStream->AddRef();
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        pStorage->AddRef();
        break;

    case VT_BSTR:
        vt = VT_EMPTY;
        SetBSTR(var.bstrVal, ma);
        break;

    case VT_LPSTR:
        vt = VT_EMPTY;
        SetLPSTR(var.pszVal, ma);
        break;

    case VT_LPWSTR:
        vt = VT_EMPTY;
        SetLPWSTR(var.pwszVal, ma);
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        POINTER_FIXUP(BYTE, caub);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        AssertShortVector(cai);                 // VT_I2
        AssertShortVector(caui);                // VT_UI2
        AssertShortVector(cabool);              // VT_BOOL
        POINTER_FIXUP(short, cai);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        AssertLongVector(cal);                  // VT_I4
        AssertLongVector(caul);                 // VT_UI4
        AssertLongVector(caflt);                // VT_R4
        AssertLongVector(cascode);              // VT_ERROR
        POINTER_FIXUP(long, cal);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        AssertLongLongVector(cah);              // VT_I8
        AssertLongLongVector(cauh);             // VT_UI8
        AssertLongLongVector(cadbl);            // VT_R8
        AssertLongLongVector(cacy);             // VT_CY
        AssertLongLongVector(cadate);           // VT_DATE
        AssertLongLongVector(cafiletime);       // VT_FILETIME
        POINTER_FIXUP(LARGE_INTEGER, cah);
        break;

    case VT_VECTOR | VT_CLSID:
        POINTER_FIXUP(CLSID, cauuid);
        break;

    case VT_VECTOR | VT_CF:
    {
        caclipdata.pElems = (CLIPDATA *)
            ma.Allocate(caclipdata.cElems * sizeof(caclipdata.pElems[0]));
        if (caclipdata.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(
            caclipdata.pElems,
            0,
            caclipdata.cElems * sizeof(caclipdata.pElems[0]));
        for (i = 0; i < caclipdata.cElems; i++)
        {
            caclipdata.pElems[i] = var.caclipdata.pElems[i];
            caclipdata.pElems[i].pClipData = (BYTE *)
                ma.Allocate(CBPCLIPDATA(caclipdata.pElems[i]));

            if (caclipdata.pElems[i].pClipData == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(
                caclipdata.pElems[i].pClipData,
                var.caclipdata.pElems[i].pClipData,
                CBPCLIPDATA(caclipdata.pElems[i]));
        }
        break;
    }

    case VT_VECTOR | VT_BSTR:
    {
        cabstr.pElems = (BSTR *)
        ma.Allocate(cabstr.cElems * sizeof(cabstr.pElems[0]));
        if (cabstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(cabstr.pElems, 0, cabstr.cElems * sizeof(cabstr.pElems[0]));
        for (i = 0; i < cabstr.cElems; i++)
        {
            cabstr.pElems[i] = SysAllocString(var.cabstr.pElems[i]);
            if (cabstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
        }
        break;
    }

    case VT_VECTOR | VT_LPSTR:
    {
        calpstr.pElems = (LPSTR *)
            ma.Allocate(calpstr.cElems * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(calpstr.pElems, 0, calpstr.cElems * sizeof(calpstr.pElems[0]));
        for (i = 0; i < calpstr.cElems; i++)
        {
            unsigned cb = strlen(var.calpstr.pElems[i]) + 1;
            calpstr.pElems[i] = (char *) ma.Allocate(cb);
            if (calpstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(calpstr.pElems[i], var.calpstr.pElems[i], cb);
        }
        break;
    }

    case VT_VECTOR | VT_LPWSTR:
    {
        calpwstr.pElems = (LPWSTR *)
            ma.Allocate(calpwstr.cElems * sizeof(calpwstr.pElems[0]));
        if (calpwstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(calpwstr.pElems, 0, calpwstr.cElems * sizeof(calpwstr.pElems[0]));
        for (i = 0; i < calpwstr.cElems; i++)
        {
            unsigned cb = (wcslen(var.calpwstr.pElems[i]) + 1) * sizeof(WCHAR);
            calpwstr.pElems[i] = (WCHAR *) ma.Allocate(cb);
            if (calpwstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(calpwstr.pElems[i], var.calpwstr.pElems[i], cb);
        }
        break;
    }

    case VT_VECTOR | VT_VARIANT:
        capropvar.pElems = (PROPVARIANT *)
            ma.Allocate(capropvar.cElems * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        ASSERT(VT_EMPTY == 0);
        memset(
            capropvar.pElems,
            0,
            capropvar.cElems * sizeof(capropvar.pElems[0]));

        for (i = 0; i < capropvar.cElems; i++)
        {
            new (&capropvar.pElems[i]) CAllocStorageVariant(
                                                var.capropvar.pElems[i],
                                                ma);

            if (!((CAllocStorageVariant *) &capropvar.pElems[i])->IsValid())
            {
                fNoMemory = TRUE;
                break;
            }
        }
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
        {
            //
            // avoid double delete of the source variant
            //

            parray = 0;

            SAFEARRAY * pSaDst = 0;

            if ( FAILED( SafeArrayCopy( var.parray, &pSaDst ) ) )
            {
                fNoMemory = TRUE;
                break;
            }

            parray = pSaDst;
        }
        break;

    default:
        {
            Win4Assert( !"Unexpected vt type" );
            return;
        }
    }
    if (fNoMemory || !IsValid())
    {
        ResetType(ma);

        // We cannot raise in a non-unwindable constructor.
        // Just return a PROPVARIANT guaranteed to look invalid.

        vt = VT_LPSTR;
        pszVal = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SaCreateAndCopy
//
//  Synopsis:   Creates a safearray & initializes it with source safearray.
//
//  Arguments:  [ma]       - memory allocator to use
//              [psaSrc]   - source safearry
//              [ppsaDst] - safearray to be created.
//
//  Returns:    TRUE    - upon success
//              FALSE   - upon failure
//
//  History:    5-10-97     mohamedn    created
//
//----------------------------------------------------------------------------

BOOL SaCreateAndCopy( PMemoryAllocator &ma,
                      SAFEARRAY * psaSrc,
                      SAFEARRAY **ppsaDst )
{
    ULONG cb  = sizeof SAFEARRAY + ( ( 0 != psaSrc->cDims ?
                (psaSrc->cDims-1) : 0) * sizeof SAFEARRAYBOUND );

    Win4Assert( psaSrc->cDims > 0);

    SAFEARRAY * psaDst = (SAFEARRAY *) ma.Allocate( cb );
    if ( 0 == psaDst )
    {
        *ppsaDst = 0;
        return FALSE;
    }

    RtlCopyMemory(psaDst, psaSrc, cb);

    // reset fields and values
    psaDst->fFeatures &= ~( FADF_AUTO | FADF_STATIC );
    psaDst->cLocks     = 1;        // new safearray has lockcount of 1
    psaDst->pvData     = 0;

    *ppsaDst = psaDst;

    return TRUE;
} //SaCreateAndCopy

//+---------------------------------------------------------------------------
//
//  Function:   SaCreateData
//
//  Synopsis:   Creates/initializes SafeArray's data area
//
//  Arguments:  [ma]       - memory allocator to use
//              [vt]       - variant type (VT_ARRAY assumed)
//              [saSrc]    - source safearry
//              [saDst]    - destination safearray.
//              [fUseAllocatorOnly] - if TRUE, BSTRs are allocated using [ma]
//
//  Returns:    TRUE    - upon success
//              FALSE   - upon failure
//
//  History:    5-10-97     mohamedn    created
//
//----------------------------------------------------------------------------

BOOL SaCreateData(
    PVarAllocator & ma,
    VARTYPE         vt,
    SAFEARRAY &     saSrc,
    SAFEARRAY &     saDst,
    BOOL            fUseAllocatorOnly )
{
    //
    // Find out how much memory is needed for the array and allocate it.
    //
    unsigned cDataElements = SaCountElements(saSrc);
    ULONG cb = cDataElements * saSrc.cbElements;
    void * pv = ma.Allocate( cb );

    if ( !pv )
        return FALSE;

    RtlZeroMemory( pv, cb );

    switch (vt)
    {
    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
        {
            RtlCopyMemory( pv, saSrc.pvData, cb);
            saDst.pvData = pv;
        }
        break;

    case VT_BSTR:
        {
            BSTR *pBstrSrc  = (BSTR *) saSrc.pvData;
            BSTR *pBstrDst = (BSTR *) pv;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pBstrSrc[i]  != 0 );
                Win4Assert( pBstrDst[i] == 0 );

                if ( fUseAllocatorOnly )
                {
                    ULONG cbBstr = SysStringByteLen(pBstrSrc[i]) +
                                   sizeof (ULONG) +
                                   sizeof (WCHAR);
                    void * pv = ma.Allocate( cbBstr );
                    if ( 0 != pv )
                    {
                        BYTE * pbSrc = (BYTE *) pBstrSrc[i];
                        pbSrc -= sizeof ULONG;
                        RtlCopyMemory( pv, pbSrc, cbBstr);
                        pBstrDst[i] = (BSTR) ( (BYTE *) pv + sizeof ULONG );
                        pBstrDst[i] = (BSTR) ma.PointerToOffset( pBstrDst[i] );
                    }
                }
                else
                {
                    pBstrDst[i] = SysAllocString(pBstrSrc[i]);
                }

                if ( 0 == pBstrDst[i] )
                    return FALSE;
            }

            saDst.pvData = pv;
        }
        break;

    case VT_VARIANT:
        {
            CAllocStorageVariant *pVarntSrc = (CAllocStorageVariant *)saSrc.pvData;
            CAllocStorageVariant *pVarntDst = (CAllocStorageVariant *)pv;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pVarntDst[i].vt == 0 );

                if ( VT_BSTR == pVarntSrc[i].vt )
                {
                    if ( fUseAllocatorOnly )
                    {
                        ULONG cbBstr = SysStringByteLen(pVarntSrc[i].bstrVal) +
                                       sizeof (ULONG) +
                                       sizeof (WCHAR);
                        void * pv = ma.Allocate( cbBstr );
                        if ( 0 != pv )
                        {
                            BYTE * pbSrc = (BYTE *) pVarntSrc[i].bstrVal;
                            pbSrc -= sizeof ULONG;
                            RtlCopyMemory( pv, pbSrc, cbBstr);
                            pVarntDst[i].bstrVal = (BSTR) ((BYTE *) pv + sizeof ULONG);
                            pVarntDst[i].bstrVal = (BSTR) ma.PointerToOffset( pVarntDst[i].bstrVal );
                        }
                    }
                    else
                    {
                        pVarntDst[i].bstrVal = SysAllocString(pVarntSrc[i].bstrVal);
                    }

                    if (  0 == pVarntDst[i].bstrVal )
                        return FALSE;

                    pVarntDst[i].vt = VT_BSTR;
                }
                else if ( 0 != (pVarntSrc[i].vt & VT_ARRAY) )
                {
                    SAFEARRAY * pSaSrc = pVarntSrc[i].parray;
                    SAFEARRAY * pSaDst = 0;

                    if ( !SaCreateAndCopy( ma, pSaSrc, &pSaDst ) )
                        return FALSE;

                    if ( !SaCreateData( ma,
                                        pVarntSrc[i].vt & ~VT_ARRAY,
                                        *pSaSrc,
                                        *pSaDst,
                                        fUseAllocatorOnly ) )
                        return FALSE;

                    pVarntDst[i].parray = (SAFEARRAY *) ma.PointerToOffset( pSaDst );
                    pVarntDst[i].vt = pVarntSrc[i].vt;
                }
                else
                {
                    Win4Assert( pVarntSrc[i].vt != VT_VARIANT );
                    Win4Assert( pVarntSrc[i].vt != VT_LPWSTR );
                    Win4Assert( pVarntSrc[i].vt != VT_LPSTR );
                    Win4Assert( pVarntSrc[i].vt != VT_CLSID );

                    pVarntDst[i] = pVarntSrc[i];
                }
            }

            saDst.pvData = pv;
        }
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unexpected SafeArray type: vt=%x\n", vt ) );
        Win4Assert( !"Unexpected SafeArray Type" );
        return FALSE;
    }

    saDst.pvData = (void *) ma.PointerToOffset( saDst.pvData );

    return TRUE;
} //SaCreateData

//+---------------------------------------------------------------------------
//
//  Function:   SaComputeSize
//
//  Synopsis:   Computes the size of a safearray.
//
//  Arguments:  [vt]       - variant type (VT_ARRAY assumed)
//              [saSrc]    - source safearry
//
//  Returns:    ULONG - number of bytes of memory needed to store safearray
//
//  History:    5-01-98     AlanW       Created
//
//----------------------------------------------------------------------------

ULONG SaComputeSize( VARTYPE vt,
                     SAFEARRAY & saSrc )
{
    //
    // get number of data elements in array and size of the header.
    //
    unsigned cDataElements = SaCountElements(saSrc);

    Win4Assert( 0 != saSrc.cDims );

    ULONG    cb = sizeof (SAFEARRAY) +
                  (saSrc.cDims-1) * sizeof (SAFEARRAYBOUND) +
                  cDataElements * saSrc.cbElements;

    cb = AlignBlock( cb, sizeof LONGLONG );

    switch (vt)
    {
    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
        break;

    case VT_BSTR:
        {
            BSTR *pBstrSrc  = (BSTR *) saSrc.pvData;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pBstrSrc[i]  != 0 );

                cb += AlignBlock( SysStringByteLen(pBstrSrc[i]) +
                                  sizeof ULONG + sizeof WCHAR,
                                  sizeof LONGLONG );
            }
        }
        break;

    case VT_VARIANT:
        {
            CAllocStorageVariant *pVarnt = (CAllocStorageVariant *)saSrc.pvData;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                if ( VT_BSTR == pVarnt[i].vt )
                {
                    cb += AlignBlock( SysStringByteLen(pVarnt[i].bstrVal) +
                                      sizeof ULONG + sizeof WCHAR,
                                      sizeof LONGLONG );
                }
                else if ( 0 != (pVarnt[i].vt & VT_ARRAY) )
                {
                    cb += AlignBlock( SaComputeSize( (pVarnt[i].vt & ~VT_ARRAY),
                                                     *pVarnt[i].parray),
                                      sizeof LONGLONG );
                }
                else
                {
                    Win4Assert( pVarnt[i].vt != VT_VARIANT );
                }
            }
        }
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unexpected SafeArray type: vt=%x\n", vt ) );
        Win4Assert( !"Unexpected SafeArray Type" );
        return 1;
    }

    return cb;
}



CAllocStorageVariant::~CAllocStorageVariant()
{
    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;

    default:
        ciDebugOut(( DEB_ERROR, "~CAllocStorageVariant -- Memory Leak: vt=%x\n", vt ) );
    }
}


void
CAllocStorageVariant::ResetType(PMemoryAllocator &ma)
{
    // The most typical case

    if ( VT_EMPTY == vt )
        return;

    ULONG i;

    if ((vt & VT_BYREF) == 0)
    {
        switch (vt)
        {
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_INT:
        case VT_UINT:
        case VT_DECIMAL:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            break;

        case VT_CLSID:
            ma.Free(puuid);
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            ma.Free(blob.pBlobData);
            break;

        case VT_CF:
            if (pclipdata != NULL)
            {
                ma.Free(pclipdata->pClipData);
                ma.Free(pclipdata);
            }
            break;

        case VT_STREAM:
        case VT_VERSIONED_STREAM:
        case VT_STREAMED_OBJECT:
            pStream->Release();
            break;

        case VT_STORAGE:
        case VT_STORED_OBJECT:
            pStorage->Release();
            break;

        case VT_BSTR:
            SysFreeString(bstrVal);
            break;

        case VT_LPSTR:
        case VT_LPWSTR:
            AssertStringField(pszVal);              // VT_LPSTR
            AssertStringField(pwszVal);             // VT_LPWSTR
            ma.Free(pwszVal);
            break;

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);                  // VT_I1
            AssertByteVector(caub);                 // VT_UI1
            AssertShortVector(cai);                 // VT_I2
            AssertShortVector(caui);                // VT_UI2
            AssertShortVector(cabool);              // VT_BOOL
            AssertLongVector(cal);                  // VT_I4
            AssertLongVector(caul);                 // VT_UI4
            AssertLongVector(caflt);                // VT_R4
            AssertLongVector(cascode);              // VT_ERROR
            AssertLongLongVector(cah);              // VT_I8
            AssertLongLongVector(cauh);             // VT_UI8
            AssertLongLongVector(cadbl);            // VT_R8
            AssertLongLongVector(cacy);             // VT_CY
            AssertLongLongVector(cadate);           // VT_DATE
            AssertLongLongVector(cafiletime);       // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID));  // VT_CLSID
            ma.Free(cal.pElems);
            break;

        case VT_VECTOR | VT_CF:
            if (caclipdata.pElems != NULL)
            {
                for (i = 0; i < caclipdata.cElems; i++)
                {
                    ma.Free(caclipdata.pElems[i].pClipData);
                }
                ma.Free(caclipdata.pElems);
            }
            break;


        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(calpwstr);                   // VT_LPWSTR
            AssertStringVector(calpstr);                    // VT_LPSTR
            if (calpwstr.pElems != NULL)
            {
                for (i = 0; i < calpwstr.cElems; i++)
                {
                    if (calpstr.pElems[i] != NULL)  // don't free (NULL - cbbstr)
                    {
                        ma.Free((BYTE *) calpstr.pElems[i] );
                    }
                }
                ma.Free(calpwstr.pElems);
            }
            break;

        case VT_VECTOR | VT_BSTR:

            AssertStringVector(cabstr);                     // VT_BSTR

            if (cabstr.pElems != NULL )
            {
                for (i = 0; i < cabstr.cElems; i++)
                {
                     SysFreeString(cabstr.pElems[i]);
                }
                ma.Free(cabstr.pElems);
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            if (capropvar.pElems != NULL)
            {
                for (i = 0; i < calpstr.cElems; i++)
                {
                    ((CAllocStorageVariant *) &capropvar.pElems[i])->ResetType(ma);
                }
                ma.Free(capropvar.pElems);
            }
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:
        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_DECIMAL:
        case VT_ARRAY | VT_BSTR:
        case VT_ARRAY | VT_VARIANT:
            {
                //
                // What should we do if the array is locked?
                // Perhaps just set cLocks to 0 so it can be freed.
                // Note that we never hit the assert below because
                // we deal with SafeArrays under our control so we
                // know they won't be locked.
                //

                if ( 0 != parray )
                {
                    Win4Assert( 0 == parray->cLocks );
                    HRESULT hr = SafeArrayDestroy( parray );
                    Win4Assert( S_OK == hr );
                }
                break;
            }

        default:
                Win4Assert( !" Unexpected VT type" );
        }
    }

    vt = VT_EMPTY;
}


// Invalid variants have a pointer type but a NULL pointer.
// Some are valid in this form in general, but not for many uses.

BOOL
CAllocStorageVariant::IsValid() const
{
    ULONG i;

    if ((VT_VECTOR & vt) && cal.cElems != 0 && cal.pElems == NULL)
    {
        return(FALSE);
    }
    switch (vt)
    {
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
        case VT_I8:
        case VT_UI8:
        case VT_INT:
        case VT_UINT:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            break;

        case VT_DECIMAL:
            return ( 0 == decVal.sign || DECIMAL_NEG == decVal.sign );

        case VT_CLSID:
            return(puuid != NULL);

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            return(blob.cbSize == 0 || blob.pBlobData != NULL);

        case VT_CF:
            return(pclipdata != NULL && pclipdata->pClipData != NULL);

        case VT_STREAM:
        case VT_VERSIONED_STREAM:
        case VT_STREAMED_OBJECT:
            return(pStream != NULL);

        case VT_STORAGE:
        case VT_STORED_OBJECT:
            return(pStorage != NULL);

        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            AssertStringField(bstrVal);         // VT_BSTR
            AssertStringField(pszVal);          // VT_LPSTR
            AssertStringField(pwszVal);         // VT_LPWSTR
            return(pszVal != NULL);

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);              // VT_I1
            AssertByteVector(caub);             // VT_UI1
            AssertShortVector(cai);             // VT_I2
            AssertShortVector(caui);            // VT_UI2
            AssertShortVector(cabool);          // VT_BOOL
            AssertLongVector(cal);              // VT_I4
            AssertLongVector(caul);             // VT_UI4
            AssertLongVector(caflt);            // VT_R4
            AssertLongVector(cascode);          // VT_ERROR
            AssertLongLongVector(cah);          // VT_I8
            AssertLongLongVector(cauh);         // VT_UI8
            AssertLongLongVector(cadbl);        // VT_R8
            AssertLongLongVector(cacy);         // VT_CY
            AssertLongLongVector(cadate);       // VT_DATE
            AssertLongLongVector(cafiletime);   // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID)); // VT_CLSID
            break;

        case VT_VECTOR | VT_CF:
            for (i = 0; i < caclipdata.cElems; i++)
            {
                if (caclipdata.pElems[i].pClipData == NULL)
                {
                    return(FALSE);
                }
            }

        case VT_VECTOR | VT_BSTR:
        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(calpwstr);               // VT_LPWSTR
            AssertStringVector(cabstr);                 // VT_BSTR
            AssertStringVector(calpstr);                // VT_LPSTR
            for (i = 0; i < calpstr.cElems; i++)
            {
                if (calpstr.pElems[i] == NULL)
                {
                    return(FALSE);
                }
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            for (i = 0; i < capropvar.cElems; i++)
            {
                if (!((CAllocStorageVariant *) &capropvar.pElems[i])->IsValid())
                {
                    return(FALSE);
                }
            }
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:
        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_BSTR:
        case VT_ARRAY | VT_DECIMAL:
        case VT_ARRAY | VT_VARIANT:
             {
                SAFEARRAY *pSa = parray;

                if ( 0 == pSa )
                    return FALSE;

                if ( !(pSa->cDims && pSa->pvData) )
                    return FALSE;

                // validate all the bstrs are allocated

                if ( ( VT_BSTR | VT_ARRAY ) == vt )
                {
                    unsigned cDataElements = SaCountElements(*pSa);
                    BSTR *pBstr = (BSTR *)pSa->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                        if ( 0 == pBstr[i] )
                            return FALSE;
                }
                if ( ( VT_VARIANT | VT_ARRAY ) == vt )
                {
                    unsigned cDataElements = SaCountElements(*pSa);
                    CAllocStorageVariant *pVarnt = (CAllocStorageVariant *)pSa->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                        if ( ! pVarnt[i].IsValid() )
                            return FALSE;
                }
             }
             break;

        case VT_BYREF | VT_I2:
        case VT_BYREF | VT_I4:
        case VT_BYREF | VT_R4:
        case VT_BYREF | VT_R8:
        case VT_BYREF | VT_CY:
        case VT_BYREF | VT_DATE:
        case VT_BYREF | VT_ERROR:
        case VT_BYREF | VT_BOOL:
        case VT_BYREF | VT_I1:
        case VT_BYREF | VT_UI1:
        case VT_BYREF | VT_UI2:
        case VT_BYREF | VT_UI4:
        case VT_BYREF | VT_INT:
        case VT_BYREF | VT_UINT:
            return (piVal != 0);

        case VT_BYREF | VT_BSTR:
            return ( pbstrVal != 0 && *pbstrVal != 0 );

        case VT_BYREF | VT_DECIMAL:
            return ( pdecVal != 0 &&
                     ( 0 == pdecVal->sign || DECIMAL_NEG == pdecVal->sign ) );

        case VT_BYREF | VT_VARIANT:
            return ( pvarVal != 0 && pvarVal->vt != (VT_BYREF|VT_VARIANT) &&
                    ((CAllocStorageVariant*)pvarVal)->IsValid() );

        default:
            ASSERT(!"CAllocStorageVariant::IsValid -- Invalid variant type");
            return FALSE;
    }
    return TRUE;
}


CAllocStorageVariant::CAllocStorageVariant(
    PDeSerStream& stm,
    PMemoryAllocator &ma)
{
    Unmarshall(stm, *((PROPVARIANT *)this), ma);
}


#define VECTOR_SET_BODY(type, vtype, val, aval)                               \
                                                                              \
void CAllocStorageVariant::Set##vtype(                                        \
    type val,                                                                 \
    unsigned pos,                                                             \
    PMemoryAllocator &ma)                                                     \
{                                                                             \
    if (vt != ( VT_##vtype | VT_VECTOR ) )                                    \
    {                                                                         \
        ResetType(ma);                                                        \
        new (this) CAllocStorageVariant(VT_##vtype, pos, ma);                 \
    }                                                                         \
                                                                              \
    if (pos >= cai.cElems)                                                    \
    {                                                                         \
        type *pTemp = aval.pElems;                                            \
        aval.pElems = (type *) ma.Allocate( (pos+1) * sizeof(aval.pElems[0]));\
        if (aval.pElems != NULL)                                              \
        {                                                                     \
            memcpy(aval.pElems, pTemp, aval.cElems * sizeof(aval.pElems[0])); \
            memset(                                                           \
                &aval.pElems[aval.cElems],                                    \
                0,                                                            \
                (( pos+1 ) - aval.cElems) * sizeof(aval.pElems[0]));          \
            aval.pElems[pos] = val;                                           \
            aval.cElems = pos+1;                                              \
            ma.Free(pTemp);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        aval.pElems[pos] = val;                                               \
    }                                                                         \
}


#define VECTOR_GET_BODY(type, vtype, aval, nullval)              \
                                                                 \
type CAllocStorageVariant::Get##vtype(unsigned pos) const        \
{                                                                \
    if (vt == (VT_##vtype | VT_VECTOR) && pos < aval.cElems)     \
    {                                                            \
        return(aval.pElems[pos]);                                \
    }                                                            \
    return(nullval);                                             \
}


VECTOR_SET_BODY(CHAR, I1, i, cac)
VECTOR_GET_BODY(CHAR, I1, cac, 0)

VECTOR_SET_BODY(BYTE, UI1, ui, caub)
VECTOR_GET_BODY(BYTE, UI1, caub, 0)

VECTOR_SET_BODY(short, I2, i, cai)
VECTOR_GET_BODY(short, I2, cai, 0)

VECTOR_SET_BODY(USHORT, UI2, ui, caui)
VECTOR_GET_BODY(USHORT, UI2, caui, 0)

VECTOR_SET_BODY(long, I4, l, cal)
VECTOR_GET_BODY(long, I4, cal, 0)

VECTOR_SET_BODY(ULONG, UI4, ul, caul)
VECTOR_GET_BODY(ULONG, UI4, caul, 0)

VECTOR_SET_BODY(SCODE, ERROR, scode, cascode)
VECTOR_GET_BODY(SCODE, ERROR, cascode, 0)

static LARGE_INTEGER const liZero = { 0, 0 };
VECTOR_SET_BODY(LARGE_INTEGER, I8, li, cah)
VECTOR_GET_BODY(LARGE_INTEGER, I8, cah, liZero)

static ULARGE_INTEGER const uliZero = { 0, 0 };
VECTOR_SET_BODY(ULARGE_INTEGER, UI8, uli, cauh)
VECTOR_GET_BODY(ULARGE_INTEGER, UI8, cauh, uliZero)

VECTOR_SET_BODY(float, R4, f, caflt)
VECTOR_GET_BODY(float, R4, caflt, (float)0.0)

VECTOR_SET_BODY(double, R8, d, cadbl)
VECTOR_GET_BODY(double, R8, cadbl, 0.0)

VECTOR_SET_BODY(VARIANT_BOOL, BOOL, b, cabool)
VECTOR_GET_BODY(VARIANT_BOOL, BOOL, cabool, FALSE)

static CY const cyZero = { 0, 0 };
VECTOR_SET_BODY(CY, CY, cy, cacy)
VECTOR_GET_BODY(CY, CY, cacy, cyZero)

VECTOR_SET_BODY(DATE, DATE, d, cadate)
VECTOR_GET_BODY(DATE, DATE, cadate, 0.0)


BOOLEAN
CAllocStorageVariant::_AddStringToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb,
    PMemoryAllocator &ma)
{
    ASSERT(vt == (VT_VECTOR | VT_BSTR) ||
           vt == (VT_VECTOR | VT_LPSTR) ||
           vt == (VT_VECTOR | VT_LPWSTR));
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) ma.Allocate((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(FALSE);
        }
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));
        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));
        calpstr.cElems = pos + 1;
        ma.Free(ppsz);
    }

    if ( vt == (VT_VECTOR|VT_BSTR) )
    {
        BSTR bstrVal = SysAllocString( (OLECHAR *)pv );

        if (bstrVal == NULL)
        {
            return (FALSE);
        }

        if ( cabstr.pElems[pos] != NULL )
        {
            SysFreeString(cabstr.pElems[pos]);
        }

        cabstr.pElems[pos] = bstrVal;
    }
    else
    {
        char *psz = (char *) ma.Allocate(cb);

        if (psz == NULL)
        {
            return(FALSE);
        }

        memcpy(psz, pv, cb);

        if (calpstr.pElems[pos] != NULL)
        {
            ma.Free(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }

    return(TRUE);
}

void
CAllocStorageVariant::SetBSTR(BSTR b, PMemoryAllocator &ma)
{
    ResetType(ma);
    vt = VT_BSTR;

    bstrVal = SysAllocString(b);
}


void
CAllocStorageVariant::SetBSTR(
    BSTR b,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_BSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_BSTR, pos, ma);
    }

    _AddStringToVector(
                pos,
                b,
                -1,    // not used, pass an invalid value to detect failure.
                ma);
}


void
CAllocStorageVariant::SetLPSTR(
    char const *psz,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_LPSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_LPSTR, pos, ma);
    }
    _AddStringToVector(pos, (VOID *) psz, strlen(psz) + 1, ma);
}


void
CAllocStorageVariant::SetLPWSTR(
    WCHAR const *pwsz,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_LPWSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_LPWSTR, pos, ma);
    }
    _AddStringToVector(
                pos,
                (VOID *) pwsz,
                (wcslen(pwsz) + 1) * sizeof(WCHAR),
                ma);
}


VECTOR_GET_BODY(char *, LPSTR, calpstr, 0);
VECTOR_GET_BODY(WCHAR *, LPWSTR, calpwstr, 0);

static FILETIME const fiZero = { 0, 0 };
VECTOR_SET_BODY(FILETIME, FILETIME, ft, cafiletime)
VECTOR_GET_BODY(FILETIME, FILETIME, cafiletime, fiZero)

static CLSID const guidZero =
{
    0x00000000,
    0x0000,
    0x0000,
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
};

VECTOR_SET_BODY(CLSID, CLSID, c, cauuid)
VECTOR_GET_BODY(CLSID, CLSID, cauuid, guidZero)
#endif //ifndef _NTDLLBUILD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\chgstate\chgstate.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  ChgState.cxx
//
// PURPOSE:  To change the state of a catalog (on local machine) 
//
// PLATFORM: Windows  2000
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "Usage: ChgState /a:<RO|RW|Stop|GetState> /c:<Catalog Name>\n" ); 
    printf( "    /m:<Machine Name>\n\n" );
    printf( "    ChgState            Change the state of a catalog\n" );
    printf( "    /a:<Action>         the action to be taken, default is RO\n" );
    printf( "    The three actions are states RO (Read Only), RW (Read\\Write) and Stop (Stopped)\n" );
    printf( "    You can also specify GetState to check the state of a catalog\n" ); 
    printf( "    /c:<Catalog Name>   name of the catalog, default is SYSTEM\n" );
    printf( "    /m:<Machine Name>   name of the machine, default is local machine\n" );
    exit( -1 );
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcsCatalog     = L"system"; // default: system
    WCHAR const * pwcsMachine     = L".";      // default: local machine
    WCHAR const * pwcsAction      = L"RO";     // default: ReadOnly
    DWORD dwNewState              = CICAT_READONLY;
    DWORD dwOldState;

    SCODE sc = S_OK;

    // Parse the command for arguments
    if ( argc > 1 )
    {
        for ( int i = 1; i < argc; i++ )
        {
            if ( L'/' == argv[i][0] )
            {
                WCHAR wc = (WCHAR) toupper( argv[i][1] );

                if ( ':' != argv[i][2] )
                    Usage();

                if ( 'A' == wc )  
                    pwcsAction = argv[i] + 3;
                else if ( 'C' == wc )
                    pwcsCatalog = argv[i] + 3;
                else if ( 'M' == wc )
                    pwcsMachine = argv[i] + 3;
                else
                    Usage();
            }
            else 
                Usage();
        }
    }
    else
    {
        Usage();
    }

    if ( !wcscmp( pwcsAction, L"RO" ) )          // ReadOnly
        dwNewState = CICAT_READONLY;
    else if ( !wcscmp( pwcsAction, L"RW" ) )     // ReadWrite
        dwNewState = CICAT_WRITABLE;   
    else if ( !wcscmp( pwcsAction, L"Stop" ) )   // Stop
        dwNewState = CICAT_STOPPED;
    else if ( !wcscmp( pwcsAction, L"GetState" ) ) // Get the current state 
        dwNewState = CICAT_GET_STATE;
    else
    {
        fprintf( stderr, "Action undefined!\n" );
        exit(-1);
    }

    // call the API
    sc = SetCatalogState ( pwcsCatalog,
                           pwcsMachine,  
                           dwNewState,
                           &dwOldState );   

    if ( FAILED( sc ) )
    {
        printf( "ChangeState for catalog %ws failed with error %#x\n", pwcsCatalog ,sc );
        return -1;
    }

    printf(" Old State is " );
    if ( CICAT_STOPPED == dwOldState ) 
        printf( "CICAT_STOPPED.\n" );
    else
    {
        if ( CICAT_WRITABLE & dwOldState ) 
            printf( "CICAT_WRITABLE.\n" );
        else if ( CICAT_READONLY & dwOldState )
            printf( "CICAT_READONLY.\n" );
        else printf( "Error obtaining oldState. The return value is %d\n", dwOldState );
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\genlib\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

NTQUERYDEF = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\ntquery.def

NTQUERYLIB = $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\ntquery.lib

$(NTQUERYDEF): ntquery.def ..\..\query\query.org

$(NTQUERYLIB): $(NTQUERYDEF)
   -lib -out:$(NTQUERYLIB) $(LIBRARIAN_FLAGS) -def:$(NTQUERYDEF) $(UMLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\htmlprop\htmlprop.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  htmlprop.cxx
//
// PURPOSE:  Sits on the Indexing Service HTML filter to translate string
//           meta properties into specified data types.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <wchar.h>

#include <windows.h>
#include <oledb.h>
#include <cmdtree.h>

#include <filterr.h>
#include <filter.h>

#include "htmlprop.hxx"
#include "filtreg.hxx"

// The typid of the html filter

CLSID TYPID_HtmlPropIFilter =
{
    0xc8e2ab80, 0xa1db, 0x11d1,
    { 0xa8, 0xfb, 0x00, 0xe0, 0x98, 0x00, 0x6e, 0xd3 }
};

// The CLSID for the html property filter

CLSID CLSID_HtmlPropIFilter =
{
    0xf4309e80, 0xa1db, 0x11d1,
    { 0xa8, 0xfb, 0x00, 0xe0, 0x98, 0x00, 0x6e, 0xd3 }
};

// Class of the html property filter

CLSID CLSID_HtmlPropClass =
{
    0x4cbd1020, 0xa1db, 0x11d1,
    { 0xa8, 0xfb, 0x00, 0xe0, 0x98, 0x00, 0x6e, 0xd3 }
};

// The built-in html filter

CLSID CLSID_HtmlIFilter =
{
    0xe0ca5340, 0x4534, 0x11cf,
    { 0xb9, 0x52, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20 }
};

// The guid for html meta properties

CLSID CLSID_MetaProperty =
{
    0xd1b5d3f0, 0xc0b3, 0x11cf,
    { 0x9a, 0x92, 0x00, 0xa0, 0xc9, 0x08, 0xdb, 0xf1 }
};

// The guid for html meta properties in string form

const WCHAR * pwcMetaProperty = L"d1b5d3f0-c0b3-11cf-9a92-00a0c908dbf1";

struct SPropertyEntry
{
    WCHAR  awcName[cwcMaxName]; // name of the meta property
    DBTYPE dbType;              // data type of property
};

const SPropertyEntry aTypeEntries[] =
{
    { L"DBTYPE_I1",   DBTYPE_I1   }, //  0: signed char
    { L"DBTYPE_UI1",  DBTYPE_UI1  }, //  1: unsigned char
    { L"DBTYPE_I2",   DBTYPE_I2   }, //  2: 2 byte signed int
    { L"DBTYPE_UI2",  DBTYPE_UI2  }, //  3: 2 byte unsigned int
    { L"DBTYPE_I4",   DBTYPE_I4   }, //  4: 4 byte signed int
    { L"DBTYPE_UI4",  DBTYPE_UI4  }, //  5: 4 byte unsigned int
    { L"DBTYPE_I8",   DBTYPE_I8   }, //  6: 8 byte signed int
    { L"DBTYPE_UI8",  DBTYPE_UI8  }, //  7: 8 byte unsigned int
    { L"DBTYPE_R4",   DBTYPE_R4   }, //  8: 4 byte float
    { L"DBTYPE_R8",   DBTYPE_R8   }, //  9: 8 byte float
    { L"DBTYPE_BOOL", DBTYPE_BOOL }, // 12: BOOL (true=-1, false=0)
    { L"DBTYPE_WSTR", DBTYPE_WSTR }, // 14: wide null terminated string
    { L"VT_FILETIME", VT_FILETIME }  // 19: I8 filetime
};

const ULONG cTypeEntries = sizeof aTypeEntries / sizeof aTypeEntries[0];

const WCHAR * pwcHTMLPropertyFile = L"htmlprop.ini";

const ULONG maxEntries = 500;
SPropertyEntry g_aEntries[ maxEntries ];
ULONG g_cEntries = 0; // count of entries in g_aEntries

long g_cInstances = 0;
HMODULE g_hHtmlDll = 0; // module handle for nlhtml.dll

// htmlfilt.dll for IS 1.x and nlhtml.dll for IS 2.x

const WCHAR * pwcHTMLFilter = L"nlhtml.dll";

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::HtmlPropIFilter
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

HtmlPropIFilter::HtmlPropIFilter() :
    _pHtmlFilter( 0 ),
    _pPersistFile( 0 ),
    _lRefs( 1 )
{
    InterlockedIncrement( &g_cInstances );
} //HtmlPropIFilter

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::~HtmlPropIFilter
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

HtmlPropIFilter::~HtmlPropIFilter()
{
    InterlockedDecrement( &g_cInstances );

    if ( _pHtmlFilter )
        _pHtmlFilter->Release();

    if ( _pPersistFile )
        _pPersistFile->Release();
} //~HtmlPropIFilter

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here     
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::QueryInterface(
    REFIID   riid,
    void  ** ppvObject)
{
    if ( IID_IFilter == riid )
        *ppvObject = (IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE HtmlPropIFilter::AddRef()
{
    return InterlockedIncrement( &_lRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE HtmlPropIFilter::Release()
{
    long lTmp = InterlockedDecrement( &_lRefs );

    if ( 0 == lTmp )
        delete this;
    return lTmp;
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     HtmlPropIFilter::Init, public
//
//  Synopsis:   Initializes instance of property filter
//
//  Arguments:  [grfFlags]      -- flags for filter behavior
//              [cAttributes]   -- number of attributes in array aAttributes
//              [aAttributes]   -- array of attributes
//              [pFlags]        -- flags
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::Init(
    ULONG                grfFlags,
    ULONG                cAttributes,
    FULLPROPSPEC const * aAttributes,
    ULONG *              pFlags )
{
    return _pHtmlFilter->Init( grfFlags, cAttributes, aAttributes, pFlags );
} //Init

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::GetChunk
//
//  Synopsis:   Gets the next chunk
//
//  Arguments:  [pStat]      -- Chunk info
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::GetChunk(
    STAT_CHUNK * pStat )
{
    SCODE sc = _pHtmlFilter->GetChunk( pStat );

    // If we got a chunk, it's a value chunk, and it's a meta property with
    // a string identifier, store away the name so it's available when the
    // value is retrieved.

    if ( ( SUCCEEDED( sc ) ) &&
         ( 0 != ( pStat->flags & CHUNK_VALUE ) ) &&
         ( PRSPEC_LPWSTR == pStat->attribute.psProperty.ulKind ) &&
         ( CLSID_MetaProperty == pStat->attribute.guidPropSet ) &&
         ( 0 != pStat->attribute.psProperty.lpwstr ) &&
         ( wcslen( pStat->attribute.psProperty.lpwstr ) < cwcMaxName ) )
    {
        _fMetaProperty = TRUE;
        wcscpy( _awcName, pStat->attribute.psProperty.lpwstr );
    }
    else
    {
        _fMetaProperty = FALSE;
    }

    return sc;
} //GetChunk

//+-------------------------------------------------------------------------
//
//  Function:   ParseDateTime
//
//  Synopsis:   Parse the string and return a date/time
//              n.b. If the date is ill-formed and this function returns
//              an error code, the file will be unfiltered, and can be
//              found by using the unfiltered admin query.
//              The date parsing is very strict.
//              Times are in any time zone you like, but .htx will interpret
//              all dates as GMT.  You can always use .asp script to munge
//              dates as you like.
//
//  Arguments:  [pwcDate]   -- String form of the date/time
//              [ft]        -- Returns the date/time
//
//--------------------------------------------------------------------------

SCODE ParseDateTime(
    WCHAR *    pwcDate,
    FILETIME & ft )
{
    SYSTEMTIME stValue = { 0, 0, 0, 0, 0, 0, 0, 0 };

    // Some day add more flexible date formats!

    int cItems = swscanf( pwcDate,
                          L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                          &stValue.wYear,
                          &stValue.wMonth,
                          &stValue.wDay,
                          &stValue.wHour,
                          &stValue.wMinute,
                          &stValue.wSecond,
                          &stValue.wMilliseconds );

    if ( 1 == cItems )
        cItems = swscanf( pwcDate,
                          L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                          &stValue.wYear,
                          &stValue.wMonth,
                          &stValue.wDay,
                          &stValue.wHour,
                          &stValue.wMinute,
                          &stValue.wSecond,
                          &stValue.wMilliseconds );

    if( cItems != 3 && cItems != 6 && cItems != 7)
        return E_INVALIDARG;

    // Make a sensible split for Year 2000

    if (stValue.wYear < 30)
        stValue.wYear += 2000;
    else if (stValue.wYear < 100)
        stValue.wYear += 1900;

    if( !SystemTimeToFileTime( &stValue, &ft ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
} //ParseDateTime

//+-------------------------------------------------------------------------
//
//  Function:   Translate
//
//  Synopsis:   Translates the string property value to the given type
//
//  Arguments:  [v]      -- The variant to translate
//              [dbType] -- The resulting data type
//
//--------------------------------------------------------------------------

SCODE Translate(
    PROPVARIANT & v,
    DBTYPE        dbType )
{
    PROPVARIANT varCopy = v;
    BOOL fChange = TRUE;
    SCODE sc = S_OK;

    WCHAR *p = v.pwszVal;

    // The source must be a string variant

    if ( 0 == p || VT_LPWSTR != v.vt )
        return S_OK;

    v.vt = dbType;

    // Eat leading white space

    while ( ' ' == *p )
        p++;

    int base = 10;

    // Is this a hex number?

    if ( '0' == *p && ( 'x' == *(p+1) || 'X' == *(p+1) ) )
    {
        p += 2;
        base = 16;
    }

    WCHAR * pwc;

    // DBTYPE_I1 isn't an official OLE property type, so it isn't supported.
    //
    // Note: range checking could be added and a failure code could be
    // returned if the check failed.  That would put the file in the
    // unfiltered list.

    switch ( dbType )
    {
        case DBTYPE_UI1 :
            v.bVal = (BYTE) wcstoul( v.pwszVal, &pwc, base );
            break;
        case DBTYPE_I2 :
            v.iVal = (SHORT) wcstol( v.pwszVal, &pwc, base );
            break;
        case DBTYPE_UI2 :
            v.uiVal = (USHORT) wcstoul( v.pwszVal, &pwc, base );
            break;
        case DBTYPE_I4 :
            v.lVal = (LONG) wcstol( v.pwszVal, &pwc, base );
            break;
        case DBTYPE_UI4 :
            v.ulVal = (ULONG) wcstoul( v.pwszVal, &pwc, base );
            break;
        case DBTYPE_I8 :
            swscanf( v.pwszVal, L"%I64d", &v.fltVal );
            break;
        case DBTYPE_UI8 :
            swscanf( v.pwszVal, L"%I64u", &v.fltVal );
            break;
        case DBTYPE_R4 :
            swscanf( v.pwszVal, L"%f", &v.fltVal );
            break;
        case DBTYPE_R8 :
            swscanf( v.pwszVal, L"%lf", &v.dblVal );
            break;
        case DBTYPE_BOOL :

            // If the first character is t or 1, assume VARIANT_TRUE

            if ( 't' == *v.pwszVal ||
                 'T' == *v.pwszVal ||
                 '1' == *v.pwszVal )
                v.boolVal = VARIANT_TRUE;
            else
                v.boolVal = VARIANT_FALSE;
            break;
        case VT_FILETIME :
            sc = ParseDateTime( p, v.filetime );
            break;
        default :

            // leave the property as it was

            fChange = FALSE;
            v.vt = varCopy.vt;
            break;
    }

    // Free the memory for the (now converted) string value

    if ( fChange )
        PropVariantClear( &varCopy );

    return sc;
} //Translate

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::GetValue
//
//  Synopsis:   Retrieves the current value
//
//  Arguments:  [ppPropValue]  -- Where the value is stored
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::GetValue(
    PROPVARIANT ** ppPropValue )
{
    SCODE sc = _pHtmlFilter->GetValue( ppPropValue );

    // Is this a value that must be translated?

    if ( SUCCEEDED( sc ) && _fMetaProperty && 0 != *ppPropValue )
    {
        // lookup the datatype of the translation based on property name

        for ( ULONG i = 0; i < g_cEntries; i++ )
        {
            if ( !_wcsicmp( g_aEntries[i].awcName, _awcName ) )
            {
                // found it, so translate it

                sc = Translate( **ppPropValue,
                                g_aEntries[i].dbType );
                break;
            }
        }
    }

    return sc;
} //GetValue

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::GetText
//
//  Synopsis:   Gets text from the filter
//
//  Arguments:  [pcwcBuffer]  -- Returns the # of WCHARs returned
//              [awcBuffer]   -- Where text is written
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::GetText(
    ULONG * pcwcBuffer,
    WCHAR * awcBuffer )
{
    return _pHtmlFilter->GetText( pcwcBuffer, awcBuffer );
} //GetText

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::BindRegion
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::BindRegion(
    FILTERREGION origPos,
    REFIID       riid,
    void **      ppunk )
{
    return _pHtmlFilter->BindRegion( origPos, riid, ppunk );
} //BindRegion

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::GetClassID
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_HtmlPropIFilter;
    return S_OK;
} //GetClassID

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::IsDirty
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::IsDirty()
{
    return S_FALSE;
} //IsDirty

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::Load
//
//  Synopsis:   Loads the file for the filter
//
//  Arguments:  [pszFileName] -- Name of the file
//              [dwMode]      -- Mode of the load
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::Load(
    LPCWSTR pszFileName,
    DWORD   dwMode)
{
    //
    // Get html filter class object and class factory
    //

    IClassFactory * pcf;
    SCODE sc = E_FAIL;

    if ( 0 != g_hHtmlDll )
    {
        LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)GetProcAddress(
                                 g_hHtmlDll,
                                 "DllGetClassObject" );

        if ( 0 != pfn )
            sc = (pfn)( CLSID_HtmlIFilter, IID_IClassFactory, (void **)&pcf );
    }

    if ( SUCCEEDED(sc) )
    {
        // Get an html filter

        sc = pcf->CreateInstance( 0, IID_IFilter, (void **)&_pHtmlFilter );
        pcf->Release();

        if ( SUCCEEDED(sc) )
        {
            // Load the file

            sc = _pHtmlFilter->QueryInterface( IID_IPersistFile,
                                               (void **) &_pPersistFile );

            if ( SUCCEEDED(sc) )
            {
                sc = _pPersistFile->Load( pszFileName, dwMode );
            }
            else
            {
                _pHtmlFilter->Release();
                _pHtmlFilter = 0;
            }
        }
    }

    return sc;
} //Load

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::Save
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::Save(
    LPCWSTR pszFileName,
    BOOL    fRemember )
{
    return E_FAIL;
} //Save

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::SaveCompleted
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::SaveCompleted(
    LPCWSTR pszFileName )
{
    return E_FAIL;
} //SaveCompleted

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilter::GetcurFile
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilter::GetCurFile(
    LPWSTR * ppszFileName )
{
    return _pPersistFile->GetCurFile( ppszFileName );
} //GetCurFile

//+-------------------------------------------------------------------------
//
//  Function:   ParsePropertyFile
//
//  Synopsis:   Parses a property file and stores datatypes for html meta
//              properties.  Property files are in .idq format, with a
//              [Names] section.
//
//--------------------------------------------------------------------------

void ParsePropertyFile()
{
    // already parsed the file?

    if ( g_cEntries > 0 )
        return;

    // open the property file in the system32 directory

    WCHAR awcFile[ MAX_PATH ];
    GetSystemDirectory( awcFile, sizeof awcFile / sizeof WCHAR );

    wcscat( awcFile, L"\\" );
    wcscat( awcFile, pwcHTMLPropertyFile );

    FILE *file = _wfopen( awcFile, L"r" );

    if ( 0 != file )
    {
        WCHAR awc[ 500 ];
        BOOL fNames = FALSE;

        // for each line of the file

        while ( fgetws( awc, sizeof awc, file ) )
        {
            int cwc = wcslen( awc );
            if ( 0 == cwc )
                continue;

            // trim off trailing newline

            if ( awc[ cwc - 1 ] == '\n' )
            {
                cwc--;
                awc[cwc] = 0;
            }

            // is this a section line?

            if ( '[' == awc[0] )
            {
                fNames = !_wcsicmp( L"[names]", awc );
            }
            else if ( ( '#' != awc[0] ) && fNames )
            {
                // parse the data type

                WCHAR *pwcType = wcschr( awc, L'(' );

                if ( 0 != pwcType )
                {
                    pwcType++;
                    while ( ' ' == *pwcType )
                        pwcType++;

                    WCHAR *pwcX = wcstok( pwcType, L", )" );

                    if ( 0 != pwcType )
                    {
                        // lookup the type in the list of types

                        for ( ULONG i = 0; i < cTypeEntries; i++ )
                        {
                            if ( !_wcsicmp( aTypeEntries[i].awcName,
                                            pwcType ) )
                                break;
                        }

                        // got the type, so find the guid

                        if ( i < cTypeEntries )
                        {
                            // find the property guid

                            pwcType += 1 + wcslen( pwcType );

                            WCHAR *pwcName = wcschr( pwcType, '=' );

                            if ( pwcName )
                            {
                                pwcName++;
                                while ( ' ' == *pwcName )
                                    pwcName++;

                                // is this the html guid?

                                if ( !_wcsnicmp( pwcName,
                                                 pwcMetaProperty,
                                                 wcslen( pwcMetaProperty ) ) )
                                {
                                    // find the property name

                                    pwcName = wcschr( pwcName, ' ' );
                                    if ( pwcName )
                                    {
                                        // skip white space

                                        while ( ' ' == *pwcName )
                                            pwcName++;

                                        // got it -- save it away if it fits

                                        if ( ( wcslen( pwcName ) < cwcMaxName ) &&
                                             ( g_cEntries < maxEntries ) )
                                        {
                                            wcscpy( g_aEntries[g_cEntries].awcName,
                                                    pwcName );
                                            g_aEntries[g_cEntries++].dbType =
                                                aTypeEntries[i].dbType;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        fclose( file );
    }
} //ParsePropertyFile

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::HtmlPropIFilterCF
//
//  Synopsis:   HTML Property IFilter class factory constructor
//
//--------------------------------------------------------------------------

HtmlPropIFilterCF::HtmlPropIFilterCF()
{
    _lRefs = 1;

    long c = InterlockedIncrement( &g_cInstances );

    if ( 0 == g_hHtmlDll && 1 == c )
    {
        // load the html filter dll

        g_hHtmlDll = LoadLibrary( pwcHTMLFilter );

        // load the property information

        ParsePropertyFile();
    }
} //HtmlPropIFilterCF

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::~HtmlPropIFilterCF
//
//  Synopsis:   HTML IFilter class factory constructor
//
//--------------------------------------------------------------------------

HtmlPropIFilterCF::~HtmlPropIFilterCF()
{
    long c = InterlockedDecrement( &g_cInstances );

    if ( 0 != g_hHtmlDll && 0 == c )
    {
        FreeLibrary( g_hHtmlDll );
        g_hHtmlDll = 0;
    }
} //~HtmlPropIFilterCF

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilterCF::QueryInterface(
    REFIID   riid,
    void  ** ppvObject )
{
    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *) (IClassFactory *) this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) (IPersist *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE HtmlPropIFilterCF::AddRef()
{
    return InterlockedIncrement( &_lRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE HtmlPropIFilterCF::Release()
{
    long lTmp = InterlockedDecrement( &_lRefs );

    if ( 0 == lTmp )
        delete this;

    return lTmp;
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::CreateInstance
//
//  Synopsis:   Creates new HtmlPropIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilterCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid,
    void * *   ppvObject )
{
    *ppvObject = 0;

    HtmlPropIFilter * pFilter = new HtmlPropIFilter;

    if ( 0 == pFilter )
        return E_OUTOFMEMORY;

    SCODE sc = pFilter->QueryInterface( riid , ppvObject );

    pFilter->Release();

    return sc;
} //CreateInstance

//+-------------------------------------------------------------------------
//
//  Method:     HtmlPropIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE HtmlPropIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &g_cInstances );
    else
        InterlockedDecrement( &g_cInstances );

    return S_OK;
} //LockServer

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    HTML Property filter class factory
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject(
    REFCLSID cid,
    REFIID   iid,
    void **  ppvObj )
{
    IUnknown * pUnk = 0;

    if ( CLSID_HtmlPropIFilter == cid ||
         CLSID_HtmlPropClass   == cid )
    {
        pUnk = new HtmlPropIFilterCF;

        if ( 0 == pUnk )
            return E_OUTOFMEMORY;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }

    SCODE sc = pUnk->QueryInterface( iid, ppvObj );

    pUnk->Release();

    return sc;
} //DllGetClassObject

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == g_cInstances )
        return S_OK;
    else
        return S_FALSE;
} //DllCanUnloadNow

SClassEntry const aHtmlPropClasses[] =
{
    { L".hhc",  L"hhcfile",       L"HHC file",      L"{7f73b8f6-c19c-11d0-aa66-00c04fc2eddc}", L"HHC file" },
    { L".htm",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".html", L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htx",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".stm",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htw",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".asp",  L"asp_auto_file", L"ASP auto file", L"{bd70c020-2d24-11d0-9110-00004c752752}", L"ASP auto file" },
};

SHandlerEntry const HtmlPropHandler =
{
    L"{c694d910-a439-11d1-a903-00e098006ed3}",
    L"html property persistent handler",
    L"{f4309e80-a1db-11d1-a8fb-00e098006ed3}",
};

SFilterEntry const HtmlPropFilter =
{
    L"{f4309e80-a1db-11d1-a8fb-00e098006ed3}",
    L"html property filter",
    L"HtmlProp.dll",
    L"Both"
};

DEFINE_DLLREGISTERFILTER( HtmlPropHandler, HtmlPropFilter, aHtmlPropClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright 1996 - 1998 Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debug assert function
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   Win4Assert
//
//  Synopsis:   Display assertion information
//
//----------------------------------------------------------------------------

void Win4AssertEx( char const * szFile,
                   int iLine,
                   char const * szMessage)
{
     char acsString[200];

     sprintf( acsString, "%s, File: %s Line: %u\n", szMessage, szFile, iLine );
     OutputDebugStringA( acsString );

     DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\anchor.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       anchor.cxx
//
//  Contents:   Parsing algorithm for anchor tag in Html
//
//  Classes:    CAnchorTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <anchor.hxx>
#include <htmlguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::CAnchorTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CAnchorTag::CAnchorTag( CHtmlIFilter& htmlIFilter,
                        CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _eState(StartAnchor),
      _pwcHrefBuf(0),
      _uLenHrefBuf(0),
      _cHrefChars(0),
      _cHrefCharsFiltered(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::~CAnchorTag
//
//  Synopsis:   Destructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CAnchorTag::~CAnchorTag()
{
    delete[] _pwcHrefBuf;
}


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CAnchorTag::GetChunk( STAT_CHUNK * pStat )
{
    //
    // Toggle state
    //
    if ( _eState == StartAnchor )
        _eState = EndAnchor;
    else
        _eState = StartAnchor;

    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CAnchorTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    if ( _eState == StartAnchor )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    ULONG cCharsRemaining = _cHrefChars - _cHrefCharsFiltered;

    if ( cCharsRemaining == 0 )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcBuffer,
                       _pwcHrefBuf + _cHrefCharsFiltered,
                       *pcwcOutput * sizeof(WCHAR) );
        _cHrefCharsFiltered += *pcwcOutput;

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcBuffer,
                       _pwcHrefBuf + _cHrefCharsFiltered,
                       cCharsRemaining * sizeof(WCHAR) );
        _cHrefCharsFiltered += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

        return FILTER_S_LAST_TEXT;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CAnchorTag::InitStatChunk( STAT_CHUNK *pStat )
{
    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->attribute.guidPropSet = CLSID_HtmlInformation;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_HREF;
    pStat->breakType = CHUNK_EOS;

    if ( _eState == StartAnchor)
    {
        //
        // Start tag, hence read href field into local buffer
        //
        _scanner.ReadTagIntoBuffer();

        WCHAR *pwcHrefBuf;
        unsigned cHrefChars;
        _scanner.ScanTagBuffer( L"href=\"", pwcHrefBuf, cHrefChars );

        //
        // Need to grow internal buffer ?
        //
        if ( cHrefChars > _uLenHrefBuf )
        {
            delete[] _pwcHrefBuf;
            _pwcHrefBuf = 0;
            _uLenHrefBuf = 0;

            _pwcHrefBuf = newk(mtNewX, NULL) WCHAR[cHrefChars];
            _uLenHrefBuf = cHrefChars;
        }

        RtlCopyMemory( _pwcHrefBuf, pwcHrefBuf, cHrefChars*sizeof(WCHAR) );
        _cHrefChars = cHrefChars;
        _cHrefCharsFiltered = 0;

        pStat->idChunkSource = 0;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;
    }
    else
    {
        Win4Assert( _eState == EndAnchor );

        _scanner.EatTag();

        //
        // Set up the filter region to be the one between the start and end
        // anchor tags, i.e. the region belonging to the current Html element,
        // because we haven't changed state yet.
        //
        _htmlIFilter.GetCurHtmlElement()->InitFilterRegion( pStat->idChunkSource,
                                                            pStat->cwcStartSource,
                                                            pStat->cwcLenSource );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\charhash.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       charhash.cxx
//
//  Contents:   Hash table that maps special characters to Unicode
//
//  Classes:    CSpecialCharHashTable
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <charhash.hxx>
#include <htmlfilt.hxx>


//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashEntry::CSpecialCharHashEntry
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CSpecialCharHashEntry::CSpecialCharHashEntry( WCHAR *pwszName, WCHAR wch )
    : _wch(wch),
      _pHashEntryNext(0)
{
    Win4Assert( wcslen(pwszName) + 1 < MAX_TAG_LENGTH );
    wcscpy( _wszName, pwszName );
}




//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::~CSpecialCharHashTable
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CSpecialCharHashTable::~CSpecialCharHashTable()
{
    for ( unsigned i=0; i<SPECIAL_CHAR_HASH_TABLE_SIZE; i++)
    {
        CSpecialCharHashEntry *pHashEntry = _aHashTable[i];
        while ( pHashEntry != 0 )
        {
            CSpecialCharHashEntry *pHashEntryNext = pHashEntry->GetNextHashEntry();
            delete pHashEntry;
            pHashEntry = pHashEntryNext;
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::Add
//
//  Synopsis:   Add a special char -> Unicode char mapping
//
//  Arguments:  [pwszName] -- the special char
//              [wch]      -- the corresponding Unicode char
//
//--------------------------------------------------------------------------

void CSpecialCharHashTable::Add( WCHAR *pwszName, WCHAR wch )
{
#if DBG == 1
    //
    // Check for duplicate entries
    //
    WCHAR wchExisting;

    BOOL fFound = Lookup( pwszName, wcslen(pwszName), wchExisting );
    Win4Assert( !fFound );
#endif

    CSpecialCharHashEntry *pHashEntry = newk(mtNewX, NULL) CSpecialCharHashEntry( pwszName,
                                                                                  wch );
    unsigned uHashValue = Hash( pwszName, wcslen(pwszName) );
    pHashEntry->SetNextHashEntry( _aHashTable[uHashValue] );
    _aHashTable[uHashValue] = pHashEntry;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::Lookup
//
//  Synopsis:   Return the Unicode mapping corresponding to given special char
//
//  Arguments:  [pwcInputBuf] -- input buffer
//              [uLen]      -- Length of input (not \0 terminated)
//              [wch]       -- Unicode mapping returned here
//
//  Returns:    True if a mapping was found in the hash table
//
//--------------------------------------------------------------------------

BOOL CSpecialCharHashTable::Lookup( WCHAR *pwcInputBuf,
                                    unsigned uLen,
                                    WCHAR& wch )
{
    unsigned uHashValue = Hash( pwcInputBuf, uLen );

    Win4Assert( uHashValue < SPECIAL_CHAR_HASH_TABLE_SIZE );

    for ( CSpecialCharHashEntry *pHashEntry = _aHashTable[uHashValue];
          pHashEntry != 0;
          pHashEntry = pHashEntry->GetNextHashEntry() )
    {
        if ( wcsncmp( pwcInputBuf, pHashEntry->GetName(), uLen ) == 0 )
        {
            wch  = pHashEntry->GetWideChar();
            return TRUE;
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::Hash
//
//  Synopsis:   Implements the hash function
//
//  Arguments:  [pwszName]  -- name to hash
//              [cLen]     -- length of pszName (it is not null terminated)
//
//  Returns:    Position of chained list in hash table
//
//--------------------------------------------------------------------------

unsigned CSpecialCharHashTable::Hash( WCHAR *pwszName, unsigned cLen )
{
    for ( ULONG uHashValue=0; cLen>0; pwszName++ )
    {
        uHashValue = *pwszName + 31 * uHashValue;
        cLen--;
    }

    return uHashValue % SPECIAL_CHAR_HASH_TABLE_SIZE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::CSpecialCharHashTable
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CSpecialCharHashTable::CSpecialCharHashTable()
{
    for (unsigned i=0; i<SPECIAL_CHAR_HASH_TABLE_SIZE; i++)
        _aHashTable[i] = 0;

    //
    // Initialize the table with various Ascii string->Unicode mappings
    //

    //
    // For lt and gt, use Unicode chars from private use area to avoid
    // collision with '<' and '>' chars in Html tags. These will be
    // mapped back to '<' and '>' by the scanner.
    //
    Add(L"lt",      PRIVATE_USE_MAPPING_FOR_LT);
    Add(L"gt",      PRIVATE_USE_MAPPING_FOR_GT);

    Add(L"amp",     0x26);
    Add(L"quot",    0x22);
    Add(L"nbsp",    0xa0);
    Add(L"shy",     0xad);
    Add(L"Agrave",  0xc0);
    Add(L"agrave",  0xe0);
    Add(L"Aacute",  0xc1);
    Add(L"aacute",  0xe1);
    Add(L"Acirc",   0xc2);
    Add(L"acirc",   0xe2);
    Add(L"Atilde",  0xc3);
    Add(L"atilde",  0xe3);
    Add(L"Auml",    0xc4);
    Add(L"auml",    0xe4);
    Add(L"Aring",   0xc5);
    Add(L"aring",   0xe5);
    Add(L"AElig",   0xc6);
    Add(L"aelig",   0xe6);
    Add(L"Ccedil",  0xc7);
    Add(L"ccedil",  0xe7);
    Add(L"Egrave",  0xc8);
    Add(L"egrave",  0xe8);
    Add(L"Eacute",  0xc9);
    Add(L"eacute",  0xe9);
    Add(L"Ecirc",   0xca);
    Add(L"ecirc",   0xea);
    Add(L"Euml",    0xcb);
    Add(L"euml",    0xeb);
    Add(L"Igrave",  0xcc);
    Add(L"igrave",  0xec);
    Add(L"Iacute",  0xcd);
    Add(L"iacute",  0xed);
    Add(L"Icirc",   0xce);
    Add(L"icirc",   0xee);
    Add(L"Iuml",    0xcf);
    Add(L"iuml",    0xef);
    Add(L"ETH",     0xd0);
    Add(L"eth",     0xf0);
    Add(L"Ntilde",  0xd1);
    Add(L"ntilde",  0xf1);
    Add(L"Ograve",  0xd2);
    Add(L"ograve",  0xf2);
    Add(L"Oacute",  0xd3);
    Add(L"oacute",  0xf3);
    Add(L"Ocirc",   0xd4);
    Add(L"ocirc",   0xf4);
    Add(L"Otilde",  0xd5);
    Add(L"otilde",  0xf5);
    Add(L"Ouml",    0xd6);
    Add(L"ouml",    0xf6);
    Add(L"Oslash",  0xd8);
    Add(L"oslash",  0xf8);
    Add(L"Ugrave",  0xd9);
    Add(L"ugrave",  0xf9);
    Add(L"Uacute",  0xda);
    Add(L"uacute",  0xfa);
    Add(L"Ucirc",   0xdb);
    Add(L"ucirc",   0xfb);
    Add(L"Uuml",    0xdc);
    Add(L"uuml",    0xfc);
    Add(L"Yacute",  0xdd);
    Add(L"yacute",  0xfd);
    Add(L"THORN",   0xde);
    Add(L"thorn",   0xfe);
    Add(L"szlig",   0xdf);
    Add(L"yuml",    0xff);
    Add(L"iexcl",   0xa1);
    Add(L"cent",    0xa2);
    Add(L"pound",   0xa3);
    Add(L"curren",  0xa4);
    Add(L"yen",     0xa5);
    Add(L"brvbar",  0xa6);
    Add(L"sect",    0xa7);
    Add(L"die",     0xa8);
    Add(L"copy",    0xa9);
    Add(L"laquo",   0xab);
    Add(L"reg",     0xae);
    Add(L"macron",  0xaf);
    Add(L"deg",     0xb0);
    Add(L"plusmn",  0xb1);
    Add(L"sup2",    0xb2);
    Add(L"sup3",    0xb3);
    Add(L"acute",   0xb4);
    Add(L"micro",   0xb5);
    Add(L"para",    0xb6);
    Add(L"middot",  0xb7);
    Add(L"cedil",   0xb8);
    Add(L"supl",    0xb9);
    Add(L"raquo",   0xbb);
    Add(L"frac14",  0xbc);
    Add(L"frac12",  0xbd);
    Add(L"frac34",  0xbe);
    Add(L"iquest",  0xbf);
    Add(L"times",   0xd7);
    Add(L"divide",  0xf7);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\bag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       bag.cxx
//
//  Contents:   Bag for Html parsing elements
//
//  Classes:    CHtmlElementBag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <bag.hxx>
#include <htmlelem.hxx>

//+-------------------------------------------------------------------------
//
//  Class:      CHtmlElemBagEntry::CHtmlElemBagEntry
//
//  Purpose:    Constructor
//
//--------------------------------------------------------------------------

CHtmlElemBagEntry::CHtmlElemBagEntry()
    : _pHtmlElement(0),
      _eTokType(GenericToken)
{
}



//+-------------------------------------------------------------------------
//
//  Class:      CHtmlElemBagEntry::~CHtmlElemBagEntry
//
//  Purpose:    Destructor
//
//--------------------------------------------------------------------------

CHtmlElemBagEntry::~CHtmlElemBagEntry()
{
    delete _pHtmlElement;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElementBag::CHtmlElementBag
//
//  Synopsis:   Constructor
//
//  Arguments:  [cElems]  -- Count of Html elements in bag
//
//--------------------------------------------------------------------------

CHtmlElementBag::CHtmlElementBag( unsigned cElems )
    : _uMaxSize(cElems),
      _uCurSize(0)
{
    _aBagEntry = newk(mtNewX, NULL) CHtmlElemBagEntry[cElems];
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElementBag::~CHtmlElementBag
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CHtmlElementBag::~CHtmlElementBag()
{
    delete[] _aBagEntry;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElementBag::AddElement
//
//  Synopsis:   Add a new mapping the bag
//
//  Arguments:  [eHtmlToken]  -- token type
//              [pHtmlElem] -- Html element corresponding to eHtmlToken
//
//--------------------------------------------------------------------------

void CHtmlElementBag::AddElement( HtmlTokenType eTokType,
                                  CHtmlElement *pHtmlElement )
{
    Win4Assert( _uCurSize < _uMaxSize );

    _aBagEntry[_uCurSize].SetTokenType( eTokType );
    _aBagEntry[_uCurSize].SetHtmlElement( pHtmlElement );
    _uCurSize++;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElementBag::QueryElement
//
//  Synopsis:   Retrieve the Html element corresponding to given token type
//
//  Arguments:  [eHtmlToken]  -- token type
//
//--------------------------------------------------------------------------

CHtmlElement *CHtmlElementBag::QueryElement( HtmlTokenType eTokType )
{
    for (unsigned i=0; i<_uCurSize; i++)
    {
        if ( _aBagEntry[i].GetTokenType() == eTokType )
            return _aBagEntry[i].GetHtmlElement();
    }

    htmlDebugOut(( DEB_ERROR,
                 "Unknown Html token type 0x%x in CHtmlElementBag::QueryElement\n",
                 eTokType ));
    Win4Assert( !"Cannot map Html token type" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\codepage.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:   codepage.hxx
//
//  Contents:   Locale to codepage
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <osv.hxx>
#include <codepage.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Purpose:    Returns a codepage from a locale
//
//  Arguments:  [lcid]  --  Locale
//
//  History:    08-Jul-96   SitaramR    Created
//
//----------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    const BUFFER_LENGTH = 10;
    WCHAR wcsCodePage[BUFFER_LENGTH];
    int cwc;

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        cwc = GetLocaleInfoW( lcid, LOCALE_IDEFAULTANSICODEPAGE, wcsCodePage, BUFFER_LENGTH );
    }
    else // win95
    {
        char *pszCodePage = new char[BUFFER_LENGTH*2];

        if ( pszCodePage == NULL )
        {
            cwc = 0;
            SetLastErrorEx( ERROR_INVALID_PARAMETER, SLE_ERROR );
        }
        else
        {
            cwc = GetLocaleInfoA( lcid,
                                  LOCALE_IDEFAULTANSICODEPAGE,
                                  pszCodePage,
                                  BUFFER_LENGTH );

            if ( cwc && mbstowcs( wcsCodePage, pszCodePage, cwc ) == -1 )
            {
                cwc = 0;
                SetLastErrorEx( ERROR_INVALID_PARAMETER, SLE_ERROR );
            }

            delete [] pszCodePage;
            pszCodePage = NULL;
        }
    }

    //
    // If error, return Ansi code page
    //
    if ( cwc == 0 )
    {
         htmlDebugOut(( DEB_ERROR, "GetLocaleInfoW for lcid %d returned %d\n", lcid, GetLastError() ));

         return CP_ACP;
    }

    return wcstoul( wcsCodePage, 0 , 10 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\except.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1991-1998 Microsoft Corporation.
//
//  File:       Except.cxx
//
//  Contents:   Conversion to Ole errors
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

typedef LONG NTSTATUS;

//+-------------------------------------------------------------------------
//
//  Method:     IsOleError, public
//
//  Synopsis:   return TRUE if sc looks like an OLE SCODE.
//
//--------------------------------------------------------------------------

inline BOOL IsOleError (NTSTATUS sc)
{
    return ((sc & 0xFFF00000) == 0x80000000) ||
           (SUCCEEDED(sc) && (sc & 0xFFFFF000) != 0);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetOleError, public
//
//  Purpose:    Converts a status code to an Ole error code, because interfaces
//              return Ole error code only.
//
//--------------------------------------------------------------------------

SCODE GetOleError(CException & e)
{
    NTSTATUS scError = e.GetErrorCode();

    if (IsOleError(scError))
    {
        return scError;
    }
    else if ( STATUS_NO_MEMORY == scError )
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        return E_FAIL;
    }
}

void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept )
{
    throw CException( uiWhat ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\htmlguid.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation
//
//  File:       htmlguid.cxx
//
//  Contents:   Definitions of Html properties
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlguid.hxx>
#include <ntquery.h>

GUID CLSID_Storage = PSGUID_STORAGE;

GUID CLSID_SummaryInformation = {
    0xF29F85E0,
    0x4FF9,
    0x1068,
    { 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9 }
};

GUID CLSID_HtmlInformation = {
    0x70eb7a10,
    0x55d9,
    0x11cf,
    { 0xb7, 0x5b, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\imagetag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       imagetag.cxx
//
//  Contents:   Parsing algorithm for image tag in Html
//
//  Classes:    CImageTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <imagetag.hxx>
#include <htmlguid.hxx>
#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Method:     CImageTag::CImageTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CImageTag::CImageTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _pwcValueBuf(0),
      _cValueChars(0),
      _cValueCharsFiltered(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CImageTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CImageTag::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CImageTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CImageTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    ULONG cCharsRemaining = _cValueChars - _cValueCharsFiltered;

    if ( cCharsRemaining == 0 )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       *pcwcOutput * sizeof(WCHAR) );
        _cValueCharsFiltered += *pcwcOutput;

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       cCharsRemaining * sizeof(WCHAR) );
        _cValueCharsFiltered += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

        return FILTER_S_LAST_TEXT;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CImageTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CImageTag::InitStatChunk( STAT_CHUNK *pStat )
{
    //
    // Read the alt field of image tag
    //
    _scanner.ReadTagIntoBuffer();
    _scanner.ScanTagBuffer( L"alt=\"", _pwcValueBuf, _cValueChars );

    _cValueCharsFiltered = 0;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->attribute.guidPropSet = CLSID_Storage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\htmlelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       htmlelem.cxx
//
//  Contents:   Base class for Html element
//
//  Classes:    CHtmlElement
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlelem.hxx>


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::CHtmlElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]     -- Reference to IFilter
//              [mmSerialStream]  -- Reference to input stream
//
//--------------------------------------------------------------------------

CHtmlElement::CHtmlElement( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : _htmlIFilter(htmlIFilter),
      _serialStream(serialStream),
      _scanner(htmlIFilter, serialStream)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetValue
//
//  Synopsis:   Default implementation for returning value in current chunk
//
//  Arguments:  [ppPropValue]  -- Value returned here
//
//--------------------------------------------------------------------------
SCODE CHtmlElement::GetValue( PROPVARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::InitFilterRegion
//
//  Synopsis:   Initializes the filter region of a chunk to default value
//
//  Arguments:  [idChunkSource]  -- Id of source chunk
//              [cwcStartSource] -- Offset of source text in chunk
//              [cwcLenSource]   -- Length of source text in chunk
//
//--------------------------------------------------------------------------

void CHtmlElement::InitFilterRegion( ULONG& idChunkSource,
                                     ULONG& cwcStartSource,
                                     ULONG& cwcLenSource )
{
    idChunkSource = 0;
    cwcStartSource = 0;
    cwcLenSource = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SwitchToNextHtmlElement
//
//  Synopsis:   Find the next Html element and switch to it's parsing algorithm
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::SwitchToNextHtmlElement( STAT_CHUNK *pStat )
{
    CToken token;

    _scanner.SkipCharsUntilNextRelevantToken( token );
    HtmlTokenType eTokType = token.GetTokenType();
    if ( eTokType == EofToken )
        return FILTER_E_END_OF_CHUNKS;

    CHtmlElement *pHtmlElemNext = _htmlIFilter.QueryHtmlElement( eTokType );
    Win4Assert( pHtmlElemNext );
    pHtmlElemNext->InitStatChunk( pStat );
    _htmlIFilter.ChangeState( pHtmlElemNext );

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SkipRemainingTextAndGotoNextChunk
//
//  Synopsis:   Move to the next chunk
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::SkipRemainingTextAndGotoNextChunk( STAT_CHUNK *pStat )
{
    ULONG ulBufSize  = TEMP_BUFFER_SIZE;

    //
    // Loop until text in current chunk has been exhausted
    //
    SCODE sc = GetText( &ulBufSize, _aTempBuffer );
    while ( SUCCEEDED(sc) )
    {
        sc = GetText( &ulBufSize, _aTempBuffer );
    }

    sc = GetChunk( pStat );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\htmliflt.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright 1992 - 2000 Microsoft Corporation
//
//  File:       htmliflt.cxx
//
//  Contents:   Html IFilter
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

class CHtmlElement;

#include <eh.h>

#include <htmliflt.hxx>
#include <serstrm.hxx>

#include <bag.hxx>
#include <charhash.hxx>
#include <htmlfilt.hxx>

long gulcInstances = 0;

extern "C" GUID CLSID_HtmlIFilter = {
    0xE0CA5340,
    0x4534,
    0x11CF,
    { 0xB9, 0x52, 0x00, 0xAA, 0x00, 0x51, 0xFE, 0x20 }
};

extern "C" GUID CLSID_HtmlClass = {
    0x6A7A7550,
    0x4535,
    0x11CF,
    { 0xB9, 0x52, 0x00, 0xAA, 0x00, 0x51, 0xFE, 0x20 }
};

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterBase::CHtmlIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//--------------------------------------------------------------------------

CHtmlIFilterBase::CHtmlIFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterBase::~CHtmlIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//--------------------------------------------------------------------------

CHtmlIFilterBase::~CHtmlIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilterBase::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IFilter      = 89BCB740-6119-101A-BCB7-00DD010655AF
    // IID_IPersist     = 0000010c-0000-0000-C000-000000000046
    // IID_IPersistFile = 0000010b-0000-0000-C000-000000000046
    //                          --
    //                           |
    //                           +--- Unique!
    //

    Win4Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Win4Assert( (IID_IFilter.Data1      & 0x000000FF) == 0x40 );
    Win4Assert( (IID_IPersist.Data1     & 0x000000FF) == 0x0c );
    Win4Assert( (IID_IPersistFile.Data1 & 0x000000FF) == 0x0b );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( IID_IFilter == riid )
            pUnkTemp = (IUnknown *)(IFilter *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x0c:
        if ( IID_IPersist == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x0b:
        if ( IID_IPersistFile == riid )
            pUnkTemp = (IUnknown *)(IPersistFile *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CHtmlIFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CHtmlIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::CHtmlIFilterCF
//
//  Synopsis:   Html IFilter class factory constructor
//
//+-------------------------------------------------------------------------

CHtmlIFilterCF::CHtmlIFilterCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::~CHtmlIFilterCF
//
//  Synopsis:   Html IFilter class factory destructor
//
//  History:    1-Jan-1996    SitaramR    Created
//
//--------------------------------------------------------------------------

CHtmlIFilterCF::~CHtmlIFilterCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Win4Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Win4Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( IID_IClassFactory == riid )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CHtmlIFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CHtmlIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::CreateInstance
//
//  Synopsis:   Creates new HtmlIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CHtmlIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        pIUnk = newk(mtNewX, NULL) CHtmlIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    catch(CException& e)
    {
        Win4Assert( 0 == pIUnk );

        htmlDebugOut(( DEB_ERROR,
                       "Exception 0x%x caught in CHtmlIFilterCF::CreateInstance",
                       e.GetErrorCode() ));
        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Html filter class factory
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        if ( cid == CLSID_HtmlIFilter || cid == CLSID_HtmlClass )
            pResult = (IUnknown *) newk(mtNewX, NULL) CHtmlIFilterCF;
        else
            sc = E_NOINTERFACE;

        if ( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release();     // Release extra refcount from QueryInterface
        }
    }
    catch(CException& e)
    {
        if ( pResult )
            pResult->Release();

        htmlDebugOut(( DEB_ERROR,
                       "Exception 0x%x caught in CHtmlIFilterCF::CreateInstance",
                       e.GetErrorCode() ));
        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\htmlscan.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       htmlscan.cxx
//
//  Contents:   Scanner for html files
//
//  Classes:    CHtmlScanner
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlguid.hxx>
#include <charhash.hxx>
#include <htmlfilt.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CToken::IsMatchProperty
//
//  Synopsis:   Does the token's property match the given property ?
//
//  Arguments:  [propSpec]   -- Property to match
//
//--------------------------------------------------------------------------

BOOL CToken::IsMatchProperty( CFullPropSpec& propSpec )
{
    if ( propSpec.IsPropertyPropid()
         && propSpec.GetPropSet() == _guidPropset
         && propSpec.GetPropertyPropid() == _propid )
    {
        return TRUE;
    }
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::CHtmlScanner
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Reference to Html filter
//              [serialStream]   -- Reference to input stream to scan
//
//--------------------------------------------------------------------------

CHtmlScanner::CHtmlScanner( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : _htmlIFilter(htmlIFilter),
      _serialStream(serialStream),
      _uLenTagBuf(TAG_BUFFER_SIZE),
      _cTagCharsRead(0)
{
    _pwcTagBuf = newk(mtNewX, NULL) WCHAR[ TAG_BUFFER_SIZE ];
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::~CHtmlScanner
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CHtmlScanner::~CHtmlScanner()
{
    delete[] _pwcTagBuf;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetBlockOfChars
//
//  Synopsis:   Returns a block of chars upto the size requested by user. If
//              any Html tag is encountered, it stops scanning, and returns the
//              token found.
//
//  Arguments:  [cCharsNeeded]   -- Maximum # chars to scan
//              [awcBuffer]      -- Buffer to fill with scanned chars
//              [cCharsScanned]  -- # chars actually scanned
//              [token]          -- Token found (if any)
//
//--------------------------------------------------------------------------

void CHtmlScanner::GetBlockOfChars( ULONG cCharsNeeded,
                                    WCHAR *awcBuffer,
                                    ULONG& cCharsScanned,
                                    CToken& token )
{
    cCharsScanned = 0;

    while ( cCharsNeeded > 0 )
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
            return;
        }

        WCHAR wch = _serialStream.GetChar();
        if ( wch == L'<' )
        {
            //
            // Html tag encountered
            //
            ScanTag( token );
            return;
        }
        else
        {
            //
            // &lt; and &gt; were mapped to Unicode chars from private use area
            // to avoid collision with '<' and '>' chars in Html tags. Map them
            // back to '<' and '>'.
            //
            if ( wch == PRIVATE_USE_MAPPING_FOR_LT )
                wch = L'<';
            else if ( wch == PRIVATE_USE_MAPPING_FOR_GT )
                wch = L'>';

            awcBuffer[cCharsScanned++] = wch;
            cCharsNeeded--;
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::SkipCharsUntilNextRelevantToken
//
//  Synopsis:   Skips characters in input until EOF or an interesting token
//              is found. The list of properties that were asked to be filtered
//              as part of the IFilter::Init call determines whether a token is
//              interesting or not.
//
//  Arguments:  [fFilterContents]     -- Are contents filtered ?
//              [fFilterProperties]   -- Are properties filtered ?
//              [cAttributes]          -- Count of properties
//              [pAttributes]         -- List of properties to be filtered
//
//--------------------------------------------------------------------------

void CHtmlScanner::SkipCharsUntilNextRelevantToken( CToken& token )
{
    //
    // Loop until we find a stop token or end of file
    //
    for (;;)
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
            return;
        }

        WCHAR wch = _serialStream.GetChar();
        if ( wch == L'<' )
        {
            ScanTag( token );

            if ( token.GetTokenType() == EofToken
                 || _htmlIFilter.IsStopToken( token ) )
            {
                return;
            }
            else
            {
                //
                // Uninteresting tag, hence skip tag
                //
                EatTag();
            }
        }
        else
        {
            //
            // Vanilla text
            //
            if ( _htmlIFilter.FFilterContent() )
            {
                _serialStream.UnGetChar( wch );
                token.SetTokenType( TextToken );
                return;
            }
            else
                EatText();
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ScanTag
//
//  Synopsis:   Scans a Html tag from input
//
//  Arguments:  [token]  -- Token info returned here
//
//--------------------------------------------------------------------------

void CHtmlScanner::ScanTag( CToken& token )
{

    EatBlanks();

    if ( _serialStream.Eof() )
    {
        token.SetTokenType( EofToken );
        return;
    }
    WCHAR wch = _serialStream.GetChar();

    token.SetStartTokenFlag( TRUE );
    if ( wch == L'/' )
    {
        //
        // This is an end tag
        //
        token.SetStartTokenFlag( FALSE );
        EatBlanks();

        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
            return;
        }
        wch = _serialStream.GetChar();
    }

    WCHAR awcTagName[MAX_TAG_LENGTH+1];
    unsigned uLenTag = 0;

    //
    // Scan the tag name into szTagName. We scan MAX_TAG_LENGTH
    // characters only, because anything longer is most probably
    // a bogus tag.
    //
    while ( !iswspace(wch)
            && wch != L'>'
            && uLenTag < MAX_TAG_LENGTH )
    {
        awcTagName[uLenTag++] = wch;

        if ( _serialStream.Eof() )
            break;
        wch = _serialStream.GetChar();
    }
    awcTagName[uLenTag] = 0;

    if ( _serialStream.Eof() )
    {
        token.SetTokenType( EofToken );
        return;
    }
    else if ( wch == L'>' || uLenTag == MAX_TAG_LENGTH )
    {
        //
        // Push char back into input stream because a subsequent GetChar()
        // will be expecting to see the char in the input
        //
        _serialStream.UnGetChar( wch );
    }

    TagNameToToken( awcTagName, token );
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ReadTagIntoBuffer
//
//  Synopsis:   Reads the rest of Html tag into the internal buffer
//
//--------------------------------------------------------------------------

void CHtmlScanner::ReadTagIntoBuffer()
{
    _cTagCharsRead = 0;

    if ( _serialStream.Eof() )
        return;

    WCHAR wch = _serialStream.GetChar();
    while ( wch != L'>' )
    {
        if ( _cTagCharsRead >= _uLenTagBuf )
            GrowTagBuffer();
        Win4Assert( _cTagCharsRead < _uLenTagBuf );

        _pwcTagBuf[_cTagCharsRead++] = wch;

        if ( _serialStream.Eof() )
            return;
        wch = _serialStream.GetChar();
    }
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ScanTagBuffer
//
//  Synopsis:   Scans the internal tag buffer for a given name, and returns the
//              corresponding value
//
//  Arguments:  [awcName]   -- Pattern to match
//              [pwcValue]  -- Start position of value returned here
//              [uLenValue  -- Length of value field
//
//--------------------------------------------------------------------------

void CHtmlScanner::ScanTagBuffer( WCHAR *awcName,
                                  WCHAR * & pwcValue,
                                  unsigned& uLenValue )
{
    unsigned uLenName = wcslen( awcName );

    if ( _cTagCharsRead <= uLenName )
    {
        //
        // Pattern to match is longer than scanned tag
        //
        pwcValue = 0;
        uLenValue = 0;

        return;
    }

    for ( unsigned i=0; i<_cTagCharsRead-uLenName; i++ )
    {
        BOOL fMatch = TRUE;
        for ( unsigned j=0; j<uLenName; j++ )
        {
            //
            // Case insensitive match
            //
            if ( towlower(awcName[j]) != towlower(_pwcTagBuf[i+j]) )
            {
                fMatch = FALSE;
                break;
            }
        }

        if ( fMatch )
        {
            unsigned k = i + uLenName;
            while ( _pwcTagBuf[k] != L'"' && k < _cTagCharsRead )
                k++;

            uLenValue = k - (i + uLenName);
            pwcValue = &_pwcTagBuf[i+uLenName];

            return;
        }
    }

    uLenValue = 0;
    pwcValue = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatTag
//
//  Synopsis:   Skips characters in input until the '>' char, which demarcates
//              the end of the tag
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatTag()
{
    if ( _serialStream.Eof() )
        return;

    WCHAR wch = _serialStream.GetChar();
    while ( wch != L'>' &&  !_serialStream.Eof() )
        wch = _serialStream.GetChar();
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatText
//
//  Synopsis:   Skips characters in input until a '<', ie a tag is encountered
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatText()
{
    if ( _serialStream.Eof() )
        return;

    WCHAR wch = _serialStream.GetChar();
    while ( wch != L'<' && !_serialStream.Eof() )
        wch = _serialStream.GetChar();

    if ( wch == L'<' )
        _serialStream.UnGetChar( wch );
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatBlanks
//
//  Synopsis:   Skips generic white space characters in input
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatBlanks()
{
    if ( _serialStream.Eof() )
        return;

    WCHAR wch = _serialStream.GetChar();
    while ( iswspace(wch) && !_serialStream.Eof() )
        wch = _serialStream.GetChar();

    if ( !iswspace(wch) )
        _serialStream.UnGetChar( wch );
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::TagNameToToken
//
//  Synopsis:   Maps a tag name to token information
//
//  Arguments:  [awcTagName]  -- Tag name to map
//              [token]       -- Token information returned here
//
//--------------------------------------------------------------------------

void CHtmlScanner::TagNameToToken( WCHAR *awcTagName, CToken& token )
{
    //
    // The number of interesting Html tags will be small, hence no need for
    // a table lookup
    //
    switch( awcTagName[0] )
    {
    case L'a':
    case L'A':
        if ( _wcsicmp( awcTagName, L"a" ) == 0 )
        {
            token.SetTokenType( AnchorToken );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HREF );
        }
        else if ( _wcsicmp( awcTagName, L"address" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'b':
    case L'B':
        if ( _wcsicmp( awcTagName, L"br" ) == 0
             || _wcsicmp( awcTagName, L"blockquote" ) == 0 )
        {
            token.SetTokenType( BreakToken );
        }
        else
            token.SetTokenType( GenericToken );

        break;

    case L'd':
    case L'D':
        if ( _wcsicmp( awcTagName, L"dd" ) == 0
             || _wcsicmp( awcTagName, L"dl" ) == 0
             || _wcsicmp( awcTagName, L"dt" ) == 0 )
        {
            token.SetTokenType( BreakToken );
        }
        else
            token.SetTokenType( GenericToken );

        break;

    case L'f':
    case L'F':
        if ( _wcsicmp( awcTagName, L"form" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'h':
    case L'H':
        if ( _wcsicmp( awcTagName, L"h1" ) == 0 )
        {
            token.SetTokenType( Heading1Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_1 );
        }
        else if ( _wcsicmp( awcTagName, L"h2" ) == 0 )
        {
            token.SetTokenType( Heading2Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_2 );
        }
        else if ( _wcsicmp( awcTagName, L"h3" ) == 0 )
        {
            token.SetTokenType( Heading3Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_3 );
        }
        else if ( _wcsicmp( awcTagName, L"h4" ) == 0 )
        {
            token.SetTokenType( Heading4Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_4 );
        }
        else if ( _wcsicmp( awcTagName, L"h5" ) == 0 )
        {
            token.SetTokenType( Heading5Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_5 );
        }
        else if ( _wcsicmp( awcTagName, L"h6" ) == 0 )
        {
            token.SetTokenType( Heading6Token );
            token.SetPropset( CLSID_HtmlInformation );
            token.SetPropid( PID_HEADING_6 );
        }
        else
            token.SetTokenType( GenericToken );

        break;

    case L'i':
    case L'I':
        if ( _wcsicmp( awcTagName, L"input" ) == 0 )
            token.SetTokenType( InputToken );
        else if ( _wcsicmp( awcTagName, L"img" ) == 0 )
            token.SetTokenType( ImageToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'l':
    case L'L':
        if ( _wcsicmp( awcTagName, L"li" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'm':
    case L'M':
        if ( _wcsicmp( awcTagName, L"math" ) == 0 )
            token.SetTokenType( BreakToken );
        else if (  _wcsicmp( awcTagName, L"meta" ) == 0 )
            token.SetTokenType( MetaToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'o':
    case L'O':
        if ( _wcsicmp( awcTagName, L"ol" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'p':
    case L'P':
        if ( _wcsicmp( awcTagName, L"p" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L's':
    case L'S':
        if ( _wcsicmp( awcTagName, L"script" ) == 0 )
            token.SetTokenType( ScriptToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L't':
    case L'T':
        if ( _wcsicmp( awcTagName, L"title" ) == 0 )
        {
            token.SetTokenType( TitleToken );
            token.SetPropset( CLSID_SummaryInformation );
            token.SetPropid( PID_TITLE );
        }
        else if ( _wcsicmp( awcTagName, L"table" ) == 0
                  || _wcsicmp( awcTagName, L"th" ) == 0
                  || _wcsicmp( awcTagName, L"tr" ) == 0
                  || _wcsicmp( awcTagName, L"td" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'u':
    case L'U':
        if ( _wcsicmp( awcTagName, L"ul" ) == 0 )
            token.SetTokenType( BreakToken );
        else
            token.SetTokenType( GenericToken );

        break;

    case L'!':
        if  ( _wcsicmp( awcTagName, L"!--" ) == 0 )
            token.SetTokenType( CommentToken );
        else
            token.SetTokenType( GenericToken );

        break;

    default:
        //
        // It's an uninteresting tag
        //
        token.SetTokenType( GenericToken );
    }
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GrowTagBuffer
//
//  Synopsis:   Grow internal tag buffer to twice its current size
//
//--------------------------------------------------------------------------

void CHtmlScanner::GrowTagBuffer()
{
    WCHAR *pwcNewTagBuf = newk(mtNewX, NULL) WCHAR[2 * _uLenTagBuf];
    RtlCopyMemory( pwcNewTagBuf,
                   _pwcTagBuf,
                   _uLenTagBuf * sizeof(WCHAR) );

    delete[] _pwcTagBuf;
    _uLenTagBuf *= 2;
    _pwcTagBuf = pwcNewTagBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\inpstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       inpstrm.cxx
//
//  Contents:   Memory mapped input stream
//
//  Classes:    CMemoryMappedSerialStream
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlfilt.hxx>
#include <codepage.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::CMemoryMappedInputStream
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CMemoryMappedInputStream::CMemoryMappedInputStream()
    : _bytesReadFromMMBuffer(0),
      _charsReadFromTranslatedBuffer(0),
      _cwcTranslatedBuffer(0),
      _ulCodePage(LocaleToCodepage(GetSystemDefaultLCID())),
      _fUnGotChar(FALSE),
      _wch(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::~CMemoryMappedInputStream
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CMemoryMappedInputStream::~CMemoryMappedInputStream()
{
    if ( _mmStream.Ok() && _mmStreamBuf.Get() != 0 )
        _mmStream.Unmap( _mmStreamBuf );
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::Init
//
//  Synopsis:   Initialize the memory mapped stream
//
//  Arguments:  [pwszFileName] -- File to be mapped
//
//--------------------------------------------------------------------------

void CMemoryMappedInputStream::Init( WCHAR *pwszFileName )
{
    Win4Assert( pwszFileName );

    _bytesReadFromMMBuffer = 0;

    if ( _mmStream.Ok() )
    {
        _mmStreamBuf.Rewind();
        _mmStream.Close();
    }

    _mmStream.Open( pwszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    OPEN_EXISTING );

    if ( _mmStream.Ok() )
    {
        _mmStreamBuf.Init( &_mmStream );
        if ( !_mmStream.isEmpty() )
            _mmStreamBuf.Map( HTML_FILTER_CHUNK_SIZE );
    }
    else
    {
        htmlDebugOut(( DEB_ERROR, "Throwing FILTER_E_ACCESS in CMemoryMappedInputStream::Init\n" ));
        throw( CException( FILTER_E_ACCESS ) );
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::GetChar
//
//  Synopsis:   Read the next consecutive character from the input file
//
//--------------------------------------------------------------------------

WCHAR CMemoryMappedInputStream::GetChar()
{
    if ( !_mmStream.Ok() || !_mmStreamBuf.Get() )
        throw( CException( FILTER_E_ACCESS ) );

    if ( _fUnGotChar )
    {
        _fUnGotChar = FALSE;
        return _wch;
    }

    if ( _charsReadFromTranslatedBuffer == _cwcTranslatedBuffer )
    {
        if ( _bytesReadFromMMBuffer == _mmStreamBuf.Size() )
        {
            if ( _mmStreamBuf.Eof() )
                return WEOF;
    
            //
            // Try to map in next chunk of file
            //
            _mmStreamBuf.Map( HTML_FILTER_CHUNK_SIZE );
            _bytesReadFromMMBuffer = 0;
    
            Win4Assert( _mmStreamBuf.Size() > _bytesReadFromMMBuffer );
        }

        ULONG cChUnread = _mmStreamBuf.Size() - _bytesReadFromMMBuffer;

        //
        // Since, the wide chars are precomposed, assume 1:1 translation mapping
        //
        ULONG cChIn = TRANSLATED_CHAR_BUFFER_LENGTH;
        if ( cChIn > cChUnread )
        {
            //
            // Not enough chars in input
            //
            cChIn = cChUnread;
        }

        ULONG cwcActual = 0;
        do
        {
            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             (char *) _mmStreamBuf.Get() + _bytesReadFromMMBuffer,
                                             cChIn,
                                             _awcTranslatedBuffer,
                                             TRANSLATED_CHAR_BUFFER_LENGTH );
            if ( cwcActual == 0 )
            {
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER && cChIn >= 2 )
                    cChIn /= 2;
                else
                {
                    Win4Assert( !"CMemoryMappedInputStream::GetChar, cannot translate single char" );

                    throw( CException( GetLastError() ) );
                }
            }
        } while( cwcActual == 0 );

        Win4Assert( _bytesReadFromMMBuffer + cChIn <= _mmStreamBuf.Size() );
        Win4Assert( cwcActual <= TRANSLATED_CHAR_BUFFER_LENGTH );

        _bytesReadFromMMBuffer += cChIn;
        _charsReadFromTranslatedBuffer = 0;
        _cwcTranslatedBuffer = cwcActual;
    }

    return _awcTranslatedBuffer[_charsReadFromTranslatedBuffer++];
}




//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::UnGetChar
//
//  Synopsis:   Pushes(logically) a character back into the input stream
//
//  Arguments:  [wch] -- Char to be pushed back
//
//--------------------------------------------------------------------------

void CMemoryMappedInputStream::UnGetChar( WCHAR wch )
{
    //
    // We can unget only one char at a time
    //
    Win4Assert( !_fUnGotChar );

    _fUnGotChar = TRUE;
    _wch = wch;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::Eof
//
//  Synopsis:   Is this the end of input file ?
//
//--------------------------------------------------------------------------

BOOL CMemoryMappedInputStream::Eof()
{
    if ( !_mmStream.Ok() )
        throw( CException( FILTER_E_ACCESS ) );

    if ( _fUnGotChar )
        return FALSE;

    if ( _charsReadFromTranslatedBuffer < _cwcTranslatedBuffer )
        return FALSE;

    if ( _bytesReadFromMMBuffer == _mmStreamBuf.Size() )
        return _mmStreamBuf.Eof();
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\htmlfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       htmlfilt.cxx
//
//  Contents:   Html filter
//
//  Classes:    CHtmlIFilter
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <eh.h>
#include <htmlfilt.hxx>
#include <textelem.hxx>
#include <proptag.hxx>
#include <anchor.hxx>
#include <inputtag.hxx>
#include <start.hxx>
#include <titletag.hxx>
#include <imagetag.hxx>
#include <metatag.hxx>
#include <scriptag.hxx>
#include <htmlguid.hxx>
#include <ntquery.h>
#include <limits.h>
#include <regacc32.hxx>

DECLARE_INFOLEVEL(html)


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::CHtmlIFilter
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CHtmlIFilter::CHtmlIFilter()
    : _pHtmlElement(0),
      _fNonHtmlFile(FALSE),
      _fFilterContent(FALSE),
      _fFilterMetaTag(FALSE),
      _fFilterScriptTag(FALSE),
      _cAttributes(0),
      _pAttributes(0),
      _pwszFileName(0),
      _ulChunkID(0),
      _locale(GetSystemDefaultLCID()),
      _htmlElementBag( COUNT_OF_HTML_ELEMENTS )
{
    //
    // Setup various Html elements
    //
    _htmlElementBag.AddElement( TextToken, newk(mtNewX, NULL) CTextElement( *this, _serialStream ) );

    _htmlElementBag.AddElement( StartOfFileToken, newk(mtNewX, NULL) CStartOfFileElement( *this, _serialStream ) );

    CFullPropSpec psTitle( CLSID_SummaryInformation, PID_TITLE );
    _htmlElementBag.AddElement( TitleToken, newk(mtNewX, NULL) CTitleTag( *this,
                                                                          _serialStream,
                                                                          psTitle,
                                                                          TitleToken ) );

    CFullPropSpec psHeading1( CLSID_HtmlInformation, PID_HEADING_1 );
    _htmlElementBag.AddElement( Heading1Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading1,
                                                                                Heading1Token ) );

    CFullPropSpec psHeading2( CLSID_HtmlInformation, PID_HEADING_2 );
    _htmlElementBag.AddElement( Heading2Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading2,
                                                                                Heading2Token ) );

    CFullPropSpec psHeading3( CLSID_HtmlInformation, PID_HEADING_3 );
    _htmlElementBag.AddElement( Heading3Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading3,
                                                                                Heading3Token ) );

    CFullPropSpec psHeading4( CLSID_HtmlInformation, PID_HEADING_4 );
    _htmlElementBag.AddElement( Heading4Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading4,
                                                                                Heading4Token ) );

    CFullPropSpec psHeading5( CLSID_HtmlInformation, PID_HEADING_5 );
    _htmlElementBag.AddElement( Heading5Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading5,
                                                                                Heading5Token ) );

    CFullPropSpec psHeading6( CLSID_HtmlInformation, PID_HEADING_6 );
    _htmlElementBag.AddElement( Heading6Token, newk(mtNewX, NULL) CPropertyTag( *this,
                                                                                _serialStream,
                                                                                psHeading6,
                                                                                Heading6Token ) );

    _htmlElementBag.AddElement( AnchorToken, newk(mtNewX, NULL) CAnchorTag( *this, _serialStream ) );

    _htmlElementBag.AddElement( InputToken, newk(mtNewX, NULL) CInputTag( *this, _serialStream ) );

    _htmlElementBag.AddElement( ImageToken, newk(mtNewX, NULL) CImageTag( *this, _serialStream ) );

    //
    // Read classid of meta information from registry
    //
    const WCHAR *pszKey = L"system\\currentcontrolset\\control\\HtmlFilter";
    CRegAccess regMetaInfo( HKEY_LOCAL_MACHINE, pszKey );

    const MAX_VALUE_LENGTH = 100;
    WCHAR wszValue[MAX_VALUE_LENGTH];
    _fFilterMetaTag = regMetaInfo.Get( L"MetaTagClsid", wszValue, MAX_VALUE_LENGTH );

    if ( _fFilterMetaTag )
    {
        GUID ClsidMetaInformation;

        StringToClsid( wszValue, ClsidMetaInformation );
        _htmlElementBag.AddElement( MetaToken, newk(mtNewX, NULL) CMetaTag( *this,
                                                                            _serialStream,
                                                                            ClsidMetaInformation ) );
    }

    //
    // Read classid of scripts from registry
    //
    CRegAccess regScriptInfo( HKEY_LOCAL_MACHINE, pszKey );

    _fFilterScriptTag = regScriptInfo.Get( L"ScriptTagClsid", wszValue, MAX_VALUE_LENGTH );

    if ( _fFilterScriptTag )
    {
        GUID ClsidScriptInformation;

        StringToClsid( wszValue, ClsidScriptInformation );
        _htmlElementBag.AddElement( ScriptToken, newk(mtNewX, NULL) CScriptTag( *this,
                                                                                _serialStream,
                                                                                ClsidScriptInformation ) );
    }

    //
    // Set the start state to StartOfFile mode
    //
    _pHtmlElement = _htmlElementBag.QueryElement( StartOfFileToken );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::~CHtmlIFilter
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CHtmlIFilter::~CHtmlIFilter()
{
    delete[] _pAttributes;
    delete[] _pwszFileName;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::BindRegion
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- the region of text to be mapped to a moniker
//              [riid]    -- Interface id
//              [ppunk]   -- the interface
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::BindRegion( FILTERREGION origPos,
                                                  REFIID riid,
                                                  void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_HtmlIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::IsDirty()
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Load( LPCWSTR psszFileName, DWORD dwMode )
{
    if ( _pwszFileName != 0 )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    SCODE sc = S_OK;
    try
    {
        unsigned cLen = wcslen( psszFileName ) + 1;
        _pwszFileName = newk(mtNewX, NULL) WCHAR[cLen];
        wcscpy( _pwszFileName, psszFileName );

        _fNonHtmlFile = IsNonHtmlFile();
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR, "Exception 0x%x caught in CHtmlIFilter::Load", e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Save( LPCWSTR pszFileName, BOOL fRemember )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::SaveCompleted( LPCWSTR pszFileName )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetCurFile( LPWSTR * ppwszFileName )
{
    if ( _pwszFileName == 0 )
        return E_FAIL;

    unsigned cLen = wcslen( _pwszFileName ) + 1;
    *ppwszFileName = (WCHAR *)CoTaskMemAlloc( cLen*sizeof(WCHAR) );

    SCODE sc = S_OK;
    if ( *ppwszFileName )
        wcscpy( *ppwszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::Init
//
//  Synopsis:   Initializes instance of Html filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array pAttributes
//              [pAttributes] -- array of attributes
//              [pFlags]      -- Set to 0 version 1
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * pAttributes,
                                            ULONG * pFlags )
{
    SCODE sc = S_OK;

    *pFlags = 0;  // There are no OLE docfile properties for .htm files.

    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {


        _fFilterContent = FALSE;

        if ( _cAttributes > 0 )
        {
            delete[] _pAttributes;
            _pAttributes = 0;
            _cAttributes = 0;
        }

        if ( cAttributes > 0 )
        {
            //
            // Filter properties specified in pAttributes
            //
            _pAttributes = newk(mtNewX, NULL) CFullPropSpec[cAttributes];
            _cAttributes = cAttributes;

            CFullPropSpec *pAttrib = (CFullPropSpec *) pAttributes;

            for (unsigned i=0; i<cAttributes; i++)
            {
                if ( pAttrib[i].IsPropertyPropid()
                     && pAttrib[i].GetPropertyPropid() == PID_STG_CONTENTS
                     && pAttrib[i].GetPropSet() == CLSID_Storage )
                {
                    _fFilterContent = TRUE;
                }

                _pAttributes[i] = pAttrib[i];
            }
        }
        else if ( grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES )
        {
            //
            // Filter contents and all pseudo-properties
            //
            _fFilterContent = TRUE;

            const COUNT_ATTRIBUTES = 8;
            _pAttributes = newk(mtNewX, NULL) CFullPropSpec[COUNT_ATTRIBUTES];
            _cAttributes = COUNT_ATTRIBUTES;

            _pAttributes[0].SetPropSet( CLSID_SummaryInformation );
            _pAttributes[0].SetProperty( PID_TITLE );

            _pAttributes[1].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[1].SetProperty( PID_HREF );

            _pAttributes[2].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[2].SetProperty( PID_HEADING_1 );

            _pAttributes[3].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[3].SetProperty( PID_HEADING_2 );

            _pAttributes[4].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[4].SetProperty( PID_HEADING_3 );

            _pAttributes[5].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[5].SetProperty( PID_HEADING_4 );

            _pAttributes[6].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[6].SetProperty( PID_HEADING_5 );

            _pAttributes[7].SetPropSet( CLSID_HtmlInformation );
            _pAttributes[7].SetProperty( PID_HEADING_6 );
        }
        else if ( grfFlags == 0 )
        {
            //
            // Filter only contents
            //
            _fFilterContent = TRUE;
        }

        _pHtmlElement = _htmlElementBag.QueryElement( StartOfFileToken );
        _ulChunkID = 0;
        _serialStream.Init( _pwszFileName );
    }
    catch( CException& e)
    {
        htmlDebugOut(( DEB_ERROR,
                       "Exception 0x%x caught in CHtmlIFilter::Init\n",
                       e.GetErrorCode() ));
        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::ChangeState
//
//  Synopsis:   Change the current Html element and hence the parsing algorithm
//
//  Arguments:  [pHtmlElemNewState]  -- New Html element to change to
//
//--------------------------------------------------------------------------

void CHtmlIFilter::ChangeState( CHtmlElement *pHtmlElemNewState )
{
    _pHtmlElement = pHtmlElemNewState;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::QueryElement
//
//  Synopsis:   Return HtmlElement corresponding to given token type
//
//  Arguments:  [eTokenType]  -- token type
//
//--------------------------------------------------------------------------

CHtmlElement *CHtmlIFilter::QueryHtmlElement( HtmlTokenType eTokType )
{
    return _htmlElementBag.QueryElement( eTokType );
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetNextChunkId
//
//  Synopsis:   Return a brand new chunk id
//
//--------------------------------------------------------------------------

ULONG CHtmlIFilter::GetNextChunkId()
{
    Win4Assert( _ulChunkID != ULONG_MAX );

    return ++_ulChunkID;
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetChunk( STAT_CHUNK * pStat )
{
    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_END_OF_CHUNKS;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _pHtmlElement->GetChunk( pStat );
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetChunk\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput )
{
    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_NO_TEXT;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _pHtmlElement->GetText( pcwcOutput, awcOutput );
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetText\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_NO_VALUES;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _pHtmlElement->GetValue( ppPropValue );
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetValue\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::IsStopToken
//
//  Synopsis:   Check if given token is a token that should stop further
//              scanning
//
//  Arguments:  [token]  -- Given token
//
//--------------------------------------------------------------------------

BOOL CHtmlIFilter::IsStopToken( CToken& token )
{
    HtmlTokenType tokType = token.GetTokenType();
    if ( ( tokType == InputToken || tokType == ImageToken )  && _fFilterContent
         || tokType == MetaToken && _fFilterMetaTag
         || tokType == ScriptToken && _fFilterScriptTag )
    {
        return TRUE;
    }

    if ( token.GetTokenType() == GenericToken
         || token.GetTokenType() == BreakToken )
        return FALSE;

    for ( unsigned i=0; i<_cAttributes; i++ )
    {
        if ( token.IsMatchProperty( _pAttributes[i] ) )
            return TRUE;
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::IsNonHtmlFile
//
//  Synopsis:   Check if file being filtered has an extension such as .gif,
//              which means that the file is not an Html file
//
//--------------------------------------------------------------------------

BOOL CHtmlIFilter::IsNonHtmlFile()
{
    WCHAR *pwszExtension;

    for ( int i=wcslen(_pwszFileName)-1; i>=0; i-- )
    {
        if ( _pwszFileName[i] == L'.' )
        {
            pwszExtension = &_pwszFileName[i+1];
            break;
        }
    }

    //
    // No extension, then assume it's an html file
    //
    if ( i < 0 )
        return FALSE;

    switch( pwszExtension[0] )
    {
    case L'a':
    case L'A':
        if ( _wcsicmp( pwszExtension, L"aif" ) == 0
             || _wcsicmp( pwszExtension, L"aifc" ) == 0
             || _wcsicmp( pwszExtension, L"aiff" ) == 0
             || _wcsicmp( pwszExtension, L"au" ) == 0 )
        {
            return TRUE;
        }

        break;

    case L'g':
    case L'G':
        if ( _wcsicmp( pwszExtension, L"gif" ) == 0 )
            return TRUE;

        break;

    case L'j':
    case L'J':
        if ( _wcsicmp( pwszExtension, L"jfif" ) == 0
             || _wcsicmp( pwszExtension, L"jpe" ) == 0
             || _wcsicmp( pwszExtension, L"jpeg" ) == 0
             || _wcsicmp( pwszExtension, L"jpg" ) == 0 )
        {
            return TRUE;
        }

        break;

    case L's':
    case L'S':
        if ( _wcsicmp( pwszExtension, L"snd" ) == 0 )
            return TRUE;

        break;

    case L'x':
    case L'X':
        if ( _wcsicmp( pwszExtension, L"xbm" ) == 0 )
            return TRUE;

        break;

    default:
        return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\mmbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       mmstrm.cxx
//
//  Contents:   Memory Mapped Buffer, Safe ptr to stream
//
//  Classes:    CMmStreamBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pmmstrm.hxx>

CMmStreamBuf::~CMmStreamBuf()
{
    if (_buf && _pStream )
        _pStream->Unmap(*this);
}

SMmStream::~SMmStream()
{
    delete _pStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\main.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1996, Microsoft Corporation.
//
// File:        main.cxx
//
// Contents:    DLL entry point for query.dll
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define _DECL_DLLMAIN 1
#include <process.h>

#include <osv.hxx>

// global function to find OS platform
#define UNINITIALIZED -1
int g_nOSWinNT = UNINITIALIZED;

//+-------------------------------------------------------------------------
//
//  Function:   GetOSVersion
//
//  Synopsis:   Determine OS version
//
//--------------------------------------------------------------------------

void InitOSVersion()
{
    if ( g_nOSWinNT == UNINITIALIZED )
    {
        OSVERSIONINFOA OSVersionInfo;
        OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );

        if ( GetVersionExA( &OSVersionInfo ) )
        {
            g_nOSWinNT = OSVersionInfo.dwPlatformId;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  --
//              [dwReason]   --
//              [lpReserved] --
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason , void * lpReserved )
{
    if ( DLL_PROCESS_ATTACH == dwReason )
    {
        DisableThreadLibraryCalls( (HINSTANCE)hInstance );

        InitOSVersion();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\metatag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       metatag.cxx
//
//  Contents:   Parsing algorithm for meta tag in Html
//
//  Classes:    CMetaTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <metatag.hxx>
#include <htmlguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::CMetaTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//              [clsidMetaInfo]  -- Clsid for meta chunk
//
//--------------------------------------------------------------------------

CMetaTag::CMetaTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream,
                    GUID clsidMetaInfo )
    : CHtmlElement(htmlIFilter, serialStream),
      _clsidMetaInfo(clsidMetaInfo),
      _pwcValueBuf(0),
      _cValueChars(0),
      _eState(FilteringValue)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CMetaTag::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CMetaTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    return FILTER_E_NO_TEXT;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CMetaTag::GetValue( PROPVARIANT **ppPropValue )
{
    switch ( _eState )
    {
    case FilteringValue:
    {
        PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
        if ( pPropVar == 0 )
            return E_OUTOFMEMORY;

        pPropVar->vt = VT_LPWSTR;
        pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( ( _cValueChars + 1 ) * sizeof( WCHAR ) );
        if ( pPropVar->pwszVal == 0 )
        {
            CoTaskMemFree( (void *) pPropVar );
            return E_OUTOFMEMORY;
        }

        RtlCopyMemory( pPropVar->pwszVal, _pwcValueBuf, _cValueChars * sizeof(WCHAR) );
        pPropVar->pwszVal[_cValueChars] = 0;

        *ppPropValue = pPropVar;

        _eState = NoMoreValue;
        return S_OK;
    }

    case NoMoreValue:

        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"CMetaTag::GetValue, unknown state" );
        return E_FAIL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CMetaTag::InitStatChunk( STAT_CHUNK *pStat )
{
    WCHAR *pwcName;
    unsigned cwcName;

    //
    // Read the names field
    //
    _scanner.ReadTagIntoBuffer();
    _scanner.ScanTagBuffer( L"name=\"", pwcName, cwcName );

    if ( cwcName == 0 )
    {
        //
        // Try to read http-equiv instead
        //
        _scanner.ScanTagBuffer( L"http-equiv=\"", pwcName, cwcName );
    }

    if ( cwcName == 0 )
    {
        //
        // Chunk of unknown type
        //
        _cValueChars = 0;
        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = 3;
    }
    else
    {
        _scanner.ScanTagBuffer( L"content=\"", _pwcValueBuf, _cValueChars );

        pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;

        if ( cwcName > MAX_PROPSPEC_STRING_LENGTH )
            cwcName = MAX_PROPSPEC_STRING_LENGTH;     // Truncate to max length permitted

        RtlCopyMemory( _awszPropSpec, pwcName, cwcName * sizeof(WCHAR) );
        _awszPropSpec[cwcName] = 0;

        pStat->attribute.psProperty.lpwstr = _awszPropSpec;
    }

    _eState = FilteringValue;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_VALUE;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->attribute.guidPropSet = _clsidMetaInfo;
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\mmstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 2000 Microsoft Corp.
//
//  File:       mmstrm.cxx
//
//  Contents:   Memory Mapped Stream using win32 API
//
//  Classes:    CMmStream, CMmStreamBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>
#include <osv.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::CMmStream
//
//  Synopsis:   constructor
//
//  Arguments:  [wcsPath] - file path
//
//--------------------------------------------------------------------------

CMmStream::CMmStream ( WCHAR* wcsPath )
    : _hMap(0)
{
    OpenRorW ( wcsPath );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::CMmStream
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------
CMmStream::CMmStream()
        : _hFile(INVALID_HANDLE_VALUE),
          _hMap(0),
          _fWrite(FALSE)
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::~CMmStream
//
//  Synopsis:   destructor
//
//
//--------------------------------------------------------------------------
CMmStream::~CMmStream()
{
    if (Ok())
    {
        if(_hMap )
        {
            CloseHandle(_hMap);
            _hMap = 0;
        }

        CloseHandle ( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::OpenRorW, public
//
//  Synopsis:   Open stream
//
//  Arguments:  [path] - file path
//
//  Notes:      Tries to open read/write, create if necessary.
//              If it fails, try opening read only. If read/write,
//              regions are mapped in COMMON_PAGE_SIZE increments.
//
//--------------------------------------------------------------------------

void CMmStream::OpenRorW ( WCHAR* wcsPath )
{
    // Try read write access (create if possible)

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        _hFile = CreateFile( wcsPath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             0, // security
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             0 ); // template
    }
    else // win95
    {
        // Worst case - size of multibyte == size of Unicode
        int nLen = wcslen( wcsPath ) * 2;
        char *pszPath = new char[nLen];

        if ( pszPath == NULL )
        {
            _hFile = INVALID_HANDLE_VALUE;
        }
        else
        {
            if ( wcstombs( pszPath, wcsPath, nLen ) == -1 )
            {
                _hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                _hFile = CreateFileA( pszPath,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      0, // security
                                      OPEN_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      0 ); // template
            }
            delete [] pszPath;
            pszPath = NULL;
        }
    }

    if ( Ok() )
    {
        _fWrite = TRUE;
    }
    else
    {
        _fWrite = FALSE;
        // Try read only access

        if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
        {
            _hFile = CreateFile( wcsPath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 0, // security
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 0 ); // template
        }
        else // win95
        {
            // Worst case - size of multibyte == size of Unicode
            int nLen = wcslen( wcsPath ) * 2;
            char *pszPath = new char[nLen];

            if ( pszPath == NULL )
            {
                _hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                if ( wcstombs( pszPath, wcsPath, nLen ) == -1 )
                {
                    _hFile = INVALID_HANDLE_VALUE;
                }
                else
                {
                    _hFile = CreateFileA( pszPath,
                                          GENERIC_READ,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          0, // security
                                          OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL,
                                          0 ); // template
                }
                delete [] pszPath;
                pszPath = NULL;
            }
        }
    }

    if (Ok())
    {
        _sizeLow = GetFileSize ( _hFile, &_sizeHigh );

        if (_sizeLow == 0xffffffff && GetLastError() != NO_ERROR)
        {
            Close();
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }


        if (_fWrite )
        {
            CommonPageRound(_sizeLow, _sizeHigh);
        }

        if ( _sizeLow != 0 || _sizeHigh != 0 )
        {
            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
            {
                _hMap = CreateFileMapping( _hFile,
                                           0, // security
                                           _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                           _sizeHigh,
                                           _sizeLow,
                                           0 ); // name
            }
            else // windows 95
            {
                _hMap = CreateFileMappingA( _hFile,
                                            0, // security
                                            _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                            _sizeHigh,
                                            _sizeLow,
                                            0 ); // name
            }

            if (_hMap == NULL)
            {
                Close();
                throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsCreateExisting
//
//  Synopsis:   Tests if the error was a result of trying to create a
//              file that already exists.
//
//  Arguments:  [Error]      --  Error returned by the system.
//              [modeAccess] --  access mode specified to CreateFile.
//              [modeCreate] --  create mode specified to CreateFile.
//
//  Returns:    TRUE if the failure is because of trying to create a "New"
//              file with the same name as the one already existing.
//              FALSE otherwise.
//
//----------------------------------------------------------------------------

BOOL IsCreateExisting( ULONG Error, ULONG modeAccess, ULONG modeCreate )
{
    if ( (Error == ERROR_ALREADY_EXISTS || Error == ERROR_FILE_EXISTS) &&
         (modeAccess & GENERIC_WRITE) &&
         (modeCreate & CREATE_NEW) )
    {
       return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Open, public
//
//  Synopsis:   Open stream
//
//  Arguments:  [path] - file path
//              [modeAccess] -- access mode
//              [modeShare] -- sharing mode
//              [modeCreate] -- create mode
//
//--------------------------------------------------------------------------

void CMmStream::Open(
    const WCHAR* wcsPath,
    ULONG modeAccess,
    ULONG modeShare,
    ULONG modeCreate,
    ULONG modeAttribute)
{
    _fWrite = FALSE;

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        _hFile = CreateFile( wcsPath,
                             modeAccess,
                             modeShare,
                             0, // security
                             modeCreate,
                             modeAttribute,
                             0 ); // template
    }
    else // win95
    {
        // Worst case - size of multibyte == size of Unicode
        int nLen = wcslen( wcsPath ) * 2;
        char *pszPath = new char[nLen];

        if ( pszPath == NULL )
        {
            _hFile = INVALID_HANDLE_VALUE;
        }
        else
        {
            if ( wcstombs( pszPath, wcsPath, nLen ) == -1 )
            {
                _hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                _hFile = CreateFileA( pszPath,
                                      modeAccess,
                                      modeShare,
                                      0, // security
                                      modeCreate,
                                      modeAttribute,
                                      0 ); // template
            }

            delete [] pszPath;
            pszPath = NULL;
        }
    }

    if ( !Ok() )
    {
        //
        // If applicable, delete a zomby and re-create it.
        //
        if ( IsCreateExisting( GetLastError(), modeAccess, modeCreate ) )
        {
            htmlDebugOut(( DEB_ERROR, "CreateNew on %ws - already exists\n",
                         wcsPath ));
            modeCreate &= ~CREATE_NEW;   // Turn off the Create new flag
            modeCreate |= CREATE_ALWAYS; // Enable the CREATE_ALWAYS flag.

            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
            {
                _hFile = CreateFile( wcsPath,
                                     modeAccess,
                                     modeShare,
                                     0,          // security
                                     modeCreate,
                                     FILE_ATTRIBUTE_NORMAL,
                                     0 );        // template
            }
            else // win95
            {
                // Worst case - size of multibyte == size of Unicode
                int nLen = wcslen( wcsPath );
                char *pszPath = new char[nLen];

                if ( pszPath == NULL )
                {
                    _hFile = INVALID_HANDLE_VALUE;
                }
                else
                {
                    if ( wcstombs( pszPath, wcsPath, nLen ) == -1 )
                    {
                        _hFile = INVALID_HANDLE_VALUE;
                    }
                    else
                    {
                        _hFile = CreateFileA( pszPath,
                                              modeAccess,
                                              modeShare,
                                              0,          // security
                                              modeCreate,
                                              FILE_ATTRIBUTE_NORMAL,
                                              0 );        // template
                    }
                    delete [] pszPath;
                    pszPath = NULL;
                }
            }
        }
    }

    if ( Ok() )
    {
        _sizeLow = GetFileSize ( _hFile, &_sizeHigh );

        if (_sizeLow == 0xffffffff && GetLastError() != NO_ERROR)
        {
            Close();
            htmlDebugOut (( DEB_ERROR, "Open stream %ws failed\n", wcsPath ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

        if ( modeAccess & GENERIC_WRITE )
        {
            _fWrite = TRUE;
            CommonPageRound(_sizeLow, _sizeHigh);

            if (_sizeLow == 0 && _sizeHigh == 0)
            {
                if ( SetFilePointer ( _hFile,
                                      COMMON_PAGE_SIZE,
                                      0,
                                      FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
                     GetLastError() != NO_ERROR )
                {
                    Close();
                    htmlDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetFilePointer returned %d\n",
                                 GetLastError() ));
                    throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
                }

                if ( !SetEndOfFile( _hFile ) )
                {
                    Close();
                    htmlDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetEndOfFile returned %d\n",
                                 GetLastError() ));
                    throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
                }
                _sizeLow = COMMON_PAGE_SIZE;
            }
        }

        if ( _sizeLow != 0 || _sizeHigh != 0 )
        {
            if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
            {
                _hMap = CreateFileMapping( _hFile,
                                           0, // security
                                           _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                           _sizeHigh,
                                           _sizeLow,
                                           0 ); // name
            }
            else // win95
            {
                _hMap = CreateFileMappingA( _hFile,
                                            0, // security
                                            _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                            _sizeHigh,
                                            _sizeLow,
                                            0 ); // name
            }

            if (_hMap == NULL)
            {
                Close();
                htmlDebugOut (( DEB_ERROR, "File mapping failed\n" ));
                throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
            }
        }
    }
    else
    {
        htmlDebugOut (( DEB_ITRACE, "Open failed on MM Stream; GetLastError()=0x%x\n",
                      GetLastError() ));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Close, public
//
//  Synopsis:   Create all handles
//
//--------------------------------------------------------------------------

void CMmStream::Close()
{
    if (Ok())
    {
        if(_hMap )
        {
            if ( !CloseHandle(_hMap))
            {
                htmlDebugOut (( DEB_ERROR, "Closing file mapping failed\n" ));
                throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
            }
            _hMap = 0;
        }
        if ( !CloseHandle ( _hFile ))
        {

            htmlDebugOut (( DEB_ERROR, "Closing file handle failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hFile = INVALID_HANDLE_VALUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::SetSize, public
//
//  Synopsis:   Increase the size of the (writable) file
//
//  Arguments:  [storage] -- storage (not used)
//              [newSizeLow]  -- Low 32 bits of filesize
//              [newSizeHigh] -- High 32 bits of filesize
//
//--------------------------------------------------------------------------

void CMmStream::SetSize ( PStorage& storage,
    ULONG newSizeLow, ULONG newSizeHigh )
{
    if (_hMap != 0)
        CloseHandle(_hMap);

    LARGE_INTEGER sizeOld = { _sizeLow, _sizeHigh };
    LARGE_INTEGER sizeNew = { newSizeLow, newSizeHigh };

    if (sizeNew.QuadPart < sizeOld.QuadPart)
    {
        if ( SetFilePointer ( _hFile,
                              newSizeLow,
                              (long *)&newSizeHigh,   
                              FILE_BEGIN ) == INVALID_SET_FILE_POINTER  &&
             GetLastError() != NO_ERROR )
        {
            htmlDebugOut(( DEB_ERROR,
                         "CMmStream::Close -- SetFilePointer returned %d\n",
                         GetLastError() ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

        if ( !SetEndOfFile( _hFile ) )
        {
            htmlDebugOut(( DEB_ERROR,
                         "CMmStream::Close -- SetEndOfFile returned %d\n",
                         GetLastError() ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

    }

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        _hMap = CreateFileMapping( _hFile,
                                   0, // security
                                   PAGE_READWRITE,
                                   newSizeHigh,
                                   newSizeLow,
                                   0 ); // name
    }
    else // win95
    {
        _hMap = CreateFileMappingA( _hFile,
                                    0, // security
                                    PAGE_READWRITE,
                                    newSizeHigh,
                                    newSizeLow,
                                    0 ); // name
    }

    if (_hMap == 0)
        throw ( CException(HRESULT_FROM_WIN32(GetLastError())));

    _sizeLow = newSizeLow;
    _sizeHigh = newSizeHigh;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::MapAll, public
//
//  Synopsis:   Create file mapping
//
//--------------------------------------------------------------------------
void CMmStream::MapAll ( CMmStreamBuf& sbuf )
{
    Win4Assert ( SizeHigh() == 0 );
    Map ( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Map, private
//
//  Synopsis:   Create file mapping
//
//  Arguments:  [cb] -- size of the mapped area
//              [offLow] -- low part of file offset
//              [offHigh] -- high part of file offset
//
//--------------------------------------------------------------------------

void CMmStream::Map ( CMmStreamBuf& sbuf,
                      ULONG cb, ULONG offLow, ULONG offHigh,
                      BOOL
                    )
{
    Win4Assert ( _hMap != 0 );

    if ( !_fWrite )
    {
        //
        // Adjust size to be min( cb, sizeoffile - off )
        //

        LARGE_INTEGER size = { _sizeLow, _sizeHigh };
        LARGE_INTEGER off  = { offLow, offHigh };
        LARGE_INTEGER licb = { cb, 0 };
        LARGE_INTEGER diff;

        diff.QuadPart = size.QuadPart - off.QuadPart;

        if ( diff.QuadPart < licb.QuadPart )
        {
            cb = diff.LowPart;
            htmlDebugOut(( DEB_ITRACE,
                         "CMmStream::Map -- reducing map to 0x%x bytes\n",
                         cb ));
        }
    }

    void* buf = MapViewOfFile (
            _hMap,
            _fWrite? FILE_MAP_WRITE: FILE_MAP_READ,
            offHigh,
            offLow,
            cb );

    if ( 0 == buf )
    {
        htmlDebugOut(( DEB_ERROR,
                     "CMmStream::Map -- MapViewOfFile returned %d\n",
                     GetLastError() ));
        throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
    }

    sbuf.SetBuf( buf );
    sbuf.SetSize ( cb );
    sbuf.SetStream ( this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Unmap, public
//
//  Synopsis:   Unmap the view of file
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------
void CMmStream::Unmap( CMmStreamBuf& sbuf )
{
     if ( !UnmapViewOfFile(sbuf.Get()) )
     {
         htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile returned %d\n",
                      GetLastError() ));
         throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
     }

     sbuf.SetBuf ( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Flush, public
//
//  Synopsis:   Flush the view back to disk
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------

void CMmStream::Flush( CMmStreamBuf& sbuf, ULONG cb )
{
    FlushViewOfFile ( sbuf.Get(), cb );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\inputtag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       inputtag.cxx
//
//  Contents:   Parsing algorithm for input tag in Html
//
//  Classes:    CInputTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <inputtag.hxx>
#include <htmlguid.hxx>
#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Method:     CInputTag::CInputTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CInputTag::CInputTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _pwcValueBuf(0),
      _cValueChars(0),
      _cValueCharsFiltered(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CInputTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CInputTag::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CInputTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CInputTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    ULONG cCharsRemaining = _cValueChars - _cValueCharsFiltered;

    if ( cCharsRemaining == 0 )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       *pcwcOutput * sizeof(WCHAR) );
        _cValueCharsFiltered += *pcwcOutput;

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       cCharsRemaining * sizeof(WCHAR) );
        _cValueCharsFiltered += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

        return FILTER_S_LAST_TEXT;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CInputTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CInputTag::InitStatChunk( STAT_CHUNK *pStat )
{
    _cValueCharsFiltered = 0;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->attribute.guidPropSet = CLSID_Storage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    _scanner.ReadTagIntoBuffer();

    //
    // Check input type
    //
    WCHAR *pwcType;
    unsigned cwcType;
    _scanner.ScanTagBuffer( L"type=\"", pwcType, cwcType );

    if ( cwcType == 6           // 6 == wcslen( L"hidden" )
         && _wcsnicmp( pwcType, L"hidden", 6 ) == 0 )
    {
        //
        // Input is hidden, so don't output value field
        //
        _pwcValueBuf = 0;
        _cValueChars = 0;

        return;
    }

    //
    // Read the value field
    //
    _scanner.ScanTagBuffer( L"value=\"", _pwcValueBuf, _cValueChars );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\mmscbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       mmscbuf.cxx
//
//  Contents:   Memory Mapped Stream buffer for consecutive buffer mapping
//
//  Classes:    CMmStreamConsecBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "mmscbuf.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CMmStreamConsecBuf::CMmStreamConsecBuf()
: _pMmStream(0)
{
    LARGE_INTEGER liOffset = { 0, 0 };
    _liOffset = liOffset;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Map, public
//
//  Synopsis:   Map next consecutive part of file
//
//  Arguments:  [cb] -- size of the mapped area
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Map( ULONG cb )
{
    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    LARGE_INTEGER liNewOffset;
    LARGE_INTEGER liStreamSize={_pMmStream->SizeLow(), _pMmStream->SizeHigh()};

     liNewOffset.QuadPart = cb + _liOffset.QuadPart;

    if ( liNewOffset.QuadPart > liStreamSize.QuadPart )
    {
        cb = (ULONG)(liStreamSize.QuadPart - _liOffset.QuadPart);
        liNewOffset = liStreamSize;
    }

    _pMmStream->Map( *this,
                     cb,
                     _liOffset.LowPart,
                     _liOffset.HighPart );

    _liOffset = liNewOffset;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Init, public
//
//  Synopsis:   Initizializes CMmStreamConsecBuf
//
//  Arguments:  [pMmStream] -- pointer to the CMmStream from which to fill
//                             the buffer
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Init( PMmStream * pMmStream )
{
    _pMmStream = pMmStream;
    LARGE_INTEGER liOffset = { 0, 0 };
    _liOffset = liOffset;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Rewind, public
//
//  Synopsis:   Rewind file to beginning.
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Rewind()
{

    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    _liOffset.LowPart = 0;
    _liOffset.HighPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Eof, public
//
//  Synopsis:   Returns whether end of file has been hit
//
//  Returns:    FALSE if there is still more file to be mapped.  TRUE
//              otherwise.
//
//--------------------------------------------------------------------------

BOOL CMmStreamConsecBuf::Eof()
{
    Win4Assert( 0 != _pMmStream );
    return( ( (ULONG) _liOffset.HighPart == _pMmStream->SizeHigh() ) &&
            ( _liOffset.LowPart == _pMmStream->SizeLow() ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\propspec.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation
//
//  File:       propspec.cxx
//
//  Contents:   C++ wrappers for FULLPROPSPEC
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propspec.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Default constructor
//
//  Effects:    Defines property with null guid and propid 0
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec()
{
    memset( &_guidPropSet, 0, sizeof( _guidPropSet ) );
    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Construct propid based propspec
//
//  Arguments:  [guidPropSet]  -- Property set
//              [pidProperty] -- Property
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( GUID const & guidPropSet, PROPID pidProperty )
        : _guidPropSet( guidPropSet )
{
    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Construct name based propspec
//
//  Arguments:  [guidPropSet] -- Property set
//              [wcsProperty] -- Property
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( GUID const & guidPropSet,
                              WCHAR const * wcsProperty )
        : _guidPropSet( guidPropSet )
{
    _psProperty.ulKind = PRSPEC_PROPID;
    SetProperty( wcsProperty );
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source property spec
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( CFullPropSpec const & src )
        : _guidPropSet( src._guidPropSet )
{
    _psProperty.ulKind = src._psProperty.ulKind;

    if ( _psProperty.ulKind == PRSPEC_LPWSTR )
    {
        if ( src._psProperty.lpwstr )
        {
            _psProperty.ulKind = PRSPEC_PROPID;
            SetProperty( src._psProperty.lpwstr );
        }
        else
            _psProperty.lpwstr = 0;

    }
    else
    {
        _psProperty.propid = src._psProperty.propid;
    }
}

inline void * operator new( size_t size, void * p )
{
    return( p );
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::operator=, public
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [Property] -- Source property
//
//--------------------------------------------------------------------------

CFullPropSpec & CFullPropSpec::operator=( CFullPropSpec const & Property )
{
    //
    // Clean up.
    //

    CFullPropSpec::~CFullPropSpec();

#pragma warning( disable : 4291 )           // unmatched operator new
    new (this) CFullPropSpec( Property );
#pragma warning( default : 4291 )

    return *this;
}


CFullPropSpec::~CFullPropSpec()
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }
}


void CFullPropSpec::SetProperty( PROPID pidProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

BOOL CFullPropSpec::SetProperty( WCHAR const * wcsProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_LPWSTR;

    int len = (wcslen( wcsProperty ) + 1) * sizeof( WCHAR );

    _psProperty.lpwstr = (WCHAR *)CoTaskMemAlloc( len );

    if ( 0 != _psProperty.lpwstr )
    {
        memcpy( _psProperty.lpwstr,
                wcsProperty,
                len );
        return( TRUE );
    }
    else
    {
        _psProperty.lpwstr = 0;
        return( FALSE );
    }
}

int CFullPropSpec::operator==( CFullPropSpec const & prop ) const
{
    if ( memcmp( &prop._guidPropSet,
                 &_guidPropSet,
                 sizeof( _guidPropSet ) ) != 0 ||
         prop._psProperty.ulKind != _psProperty.ulKind )
    {
        return( 0 );
    }

    switch( _psProperty.ulKind )
    {
    case PRSPEC_LPWSTR:
        return( _wcsicmp( GetPropertyName(), prop.GetPropertyName() ) == 0 );
        break;

    case PRSPEC_PROPID:
        return( GetPropertyPropid() == prop.GetPropertyPropid() );
        break;

    default:
        return( 0 );
        break;
    }
}

int CFullPropSpec::operator!=( CFullPropSpec const & prop ) const
{
    if (*this == prop)
        return( 0 );
    else
        return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation
//
//  File:       pch.cxx
//
//  Contents:   Pre-compiled header
//
//--------------------------------------------------------------------------

#include <windows.h>

#include <filter.h>
#include <global.hxx>
#include <filterr.h>
#include <htmlscan.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\register.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       Register.cxx
//
//  Contents:   DllRegisterServer routines
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>

SClassEntry const aHtmlFiltClasses[] =
{
    { L".hhc",  L"hhcfile",       L"HHC file",      L"{7f73b8f6-c19c-11d0-aa66-00c04fc2eddc}", L"HHC file" },
    { L".htm",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".html", L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htx",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".stm",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htw",  L"htmlfile",      L"HTML file",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".asp",  L"asp_auto_file", L"ASP auto file", L"{bd70c020-2d24-11d0-9110-00004c752752}", L"ASP auto file" },
};

SHandlerEntry const HtmlFiltHandler =
{
    L"{eec97550-47a9-11cf-b952-00aa0051fe20}",
    L"HTML Persistent Handler",
    L"{e0ca5340-4534-11cf-b952-00aa0051fe20}",
};

SFilterEntry const HtmlFiltFilter =
{
    L"{e0ca5340-4534-11cf-b952-00aa0051fe20}",
    L"HTML Filter",
    L"HtmlFilt.dll",
    L"Both"
};

DEFINE_DLLREGISTERFILTER( HtmlFiltHandler, HtmlFiltFilter, aHtmlFiltClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\regacc32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation
//
//  File:       RegAcc.hxx
//
//  Contents:   'Simple' registry access
//
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <osv.hxx>
#include <regacc32.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CRegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.
//              [pwcsRegPath] -- Path to node.
//
//--------------------------------------------------------------------------

CRegAccess::CRegAccess( HKEY keyRelative, WCHAR const * pwcsRegPath )
        : _hKey( (HKEY)0xFFFFFFFF ),
          _wcsPath( 0 )
{
    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        RegOpenKey( keyRelative, pwcsRegPath, &_hKey );
    }
    else // win95
    {
        int nPathLen = wcslen( pwcsRegPath ) * 2;  // some multibyte chars are 2 bytes long

        char * pszPath = new char [nPathLen];

        if ( NULL != pszPath )
        {
            wcstombs( pszPath, pwcsRegPath, nPathLen );

            RegOpenKeyA( keyRelative, pszPath, &_hKey );
        }

        delete [] pszPath;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::~CRegAccess, public
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CRegAccess::~CRegAccess()
{
    RegCloseKey( _hKey );
    delete [] _wcsPath;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CRegAccess::Get( WCHAR const * pwcsKey, WCHAR * wcsVal, unsigned cc )
{
    if ( _hKey == (HKEY)0xFFFFFFFF )
        return FALSE;

    DWORD dwType;
    DWORD cb = cc * sizeof(WCHAR);
    wcsVal[0] = 0;

    BOOL fOk;

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        fOk = ( ERROR_SUCCESS == RegQueryValueEx( _hKey,
                                                  pwcsKey,
                                                  0,
                                                  &dwType,
                                                  (BYTE *)wcsVal,
                                                  &cb ) ) &&
              ( wcsVal[0] != 0 );
    }
    else // win95
    {
        // Worst case - size of multibyte == size of Unicode
        int nKeyLen = wcslen( pwcsKey ) * 2;

        char * pszKey = new char [nKeyLen];

        if ( NULL != pszKey )
        {
            char * pszVal = new char [cc*2];

            if ( NULL != pszVal )
            {
                wcstombs( pszKey, pwcsKey, nKeyLen );

                fOk = (ERROR_SUCCESS == RegQueryValueExA( _hKey,
                                                          pszKey,
                                                          0,
                                                          &dwType,
                                                         (BYTE *)pszVal,
                                                         &cb ) );

                mbstowcs( wcsVal, pszVal, cb );     // cb since it will convert fewer when it hits terminator

                delete [] pszVal;
            }
            else
            {
                fOk = FALSE;
            }

            delete [] pszKey;
        }
        else
        {
            fOk = FALSE;
        }
    }

    return fOk;
}



//+-------------------------------------------------------------------------
//
//  Method:     StringToClsid
//
//  Synopsis:   Convert string containing CLSID to CLSID
//
//  Arguments:  [wszClass] -- string containg CLSID
//              [guidClass] -- output guid
//
//--------------------------------------------------------------------------

void StringToClsid( WCHAR *wszClass, GUID& guidClass )
{
    wszClass[9] = 0;
    guidClass.Data1 = wcstoul( &wszClass[1], 0, 16 );
    wszClass[14] = 0;
    guidClass.Data2 = (USHORT)wcstoul( &wszClass[10], 0, 16 );
    wszClass[19] = 0;
    guidClass.Data3 = (USHORT)wcstoul( &wszClass[15], 0, 16 );

    WCHAR wc = wszClass[22];
    wszClass[22] = 0;
    guidClass.Data4[0] = (unsigned char)wcstoul( &wszClass[20], 0, 16 );
    wszClass[22] = wc;
    wszClass[24] = 0;
    guidClass.Data4[1] = (unsigned char)wcstoul( &wszClass[22], 0, 16 );

    for ( int i = 0; i < 6; i++ )
    {
       wc = wszClass[27+i*2];
       wszClass[27+i*2] = 0;
       guidClass.Data4[2+i] = (unsigned char)wcstoul( &wszClass[25+i*2], 0, 16 );
       wszClass[27+i*2] = wc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\proptag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       proptag.cxx
//
//  Contents:   Generic parsing algorithm for property tags, such as title and headings
//
//  Classes:    CPropertyTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proptag.hxx>
#include <htmlguid.hxx>
#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::CPropertyTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]  -- Reference to Html filter
//              [serialStream] -- Reference to input stream
//              [propSpec]     -- Property spec
//              [eTokType]     -- Token corresponding to this property
//
//--------------------------------------------------------------------------

CPropertyTag::CPropertyTag( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream,
                            CFullPropSpec& propSpec,
                            HtmlTokenType eTokType )
    : CHtmlElement(htmlIFilter, serialStream),
      _eState(NoMoreProperty),
      _ulIdContentChunk(0),
      _pwcPropBuf(0),
      _uLenPropBuf(0),
      _cPropChars(0),
      _cPropCharsFiltered(0),
      _propSpec(propSpec),
      _eTokType(eTokType)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::~CPropertyTag
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CPropertyTag::~CPropertyTag()
{
    delete[] _pwcPropBuf;
}




//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::GetChunk( STAT_CHUNK * pStat )
{
    switch ( _eState )
    {
    case FilteringContent:
    case FilteringProperty:
    case FilteringPropertyButContentNotFiltered:
    {
        SCODE sc = SkipRemainingTextAndGotoNextChunk( pStat );

        return sc;
    }

    case NoMoreContent:
        _eState = FilteringProperty;

        pStat->idChunk = _htmlIFilter.GetNextChunkId();
        pStat->locale = _htmlIFilter.GetLocale();
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;
        pStat->flags = CHUNK_TEXT;
        pStat->attribute.guidPropSet = _propSpec.GetPropSet();

        Win4Assert( _propSpec.IsPropertyPropid() );

        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = _propSpec.GetPropertyPropid();
        pStat->idChunkSource = _ulIdContentChunk;
        pStat->breakType = CHUNK_EOS;

        break;

    case NoMoreProperty:
    {
        //
        // Skip over the end property tag
        //
        _scanner.EatTag();

        SCODE sc = SwitchToNextHtmlElement( pStat );

        return sc;
    }

    default:
        Win4Assert( !"Unknown _eState in CPropertyTag::GetChunk" );
        htmlDebugOut(( DEB_ERROR, "CPropertyTag::GetChunk, unkown property tag state: %d\n", _eState ));
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    switch ( _eState )
    {
    case NoMoreContent:
    case NoMoreProperty:
         return FILTER_E_NO_MORE_TEXT;

    case FilteringContent:
    case FilteringPropertyButContentNotFiltered:
    {
        ULONG cCharsRead = 0;
        while ( cCharsRead < *pcwcOutput )
        {
            ULONG cCharsScanned;
            ULONG cCharsNeeded = *pcwcOutput - cCharsRead;
            CToken token;
            _scanner.GetBlockOfChars( cCharsNeeded,
                                      awcBuffer + cCharsRead,
                                      cCharsScanned,
                                      token );

            cCharsRead += cCharsScanned;
            if ( cCharsScanned == cCharsNeeded )
            {
                //
                // We've read the #chars requested by user
                //
                break;
            }

            HtmlTokenType eTokType = token.GetTokenType();
            if ( eTokType == EofToken || eTokType == _eTokType )
            {
                //
                // End of file or end property tag
                //
                if ( _eState == FilteringContent )
                    _eState = NoMoreContent;
                else
                    _eState = NoMoreProperty;

                break;
            }
            else if ( eTokType == BreakToken )
            {
                //
                // Insert a newline char
                //
                Win4Assert( cCharsRead < *pcwcOutput );
                awcBuffer[cCharsRead++] = L'\n';
                _scanner.EatTag();
            }
            else
            {
                //
                // Uninteresting tag, so skip over tag and continue processing
                //
                _scanner.EatTag();
            }
        }

        //
        // Keep a copy of property in our internal buffer
        //
        if ( cCharsRead > 0 )
            ConcatenateProperty( awcBuffer, cCharsRead );

        *pcwcOutput = cCharsRead;

        if ( _eState == NoMoreContent || _eState == NoMoreProperty )
            return FILTER_S_LAST_TEXT;
        else
            return S_OK;

        break;
    }


    case FilteringProperty:
    {
        ULONG cCharsRemaining = _cPropChars - _cPropCharsFiltered;

        if ( cCharsRemaining == 0 )
        {
            _eState = NoMoreProperty;
            return FILTER_E_NO_MORE_TEXT;
        }

        if ( *pcwcOutput < cCharsRemaining )
        {
            RtlCopyMemory( awcBuffer,
                           _pwcPropBuf + _cPropCharsFiltered,
                           *pcwcOutput * sizeof(WCHAR) );
            _cPropCharsFiltered += *pcwcOutput;

            return S_OK;
        }
        else
        {
            RtlCopyMemory( awcBuffer,
                           _pwcPropBuf + _cPropCharsFiltered,
                           cCharsRemaining * sizeof(WCHAR) );
            _cPropCharsFiltered += cCharsRemaining;
            *pcwcOutput = cCharsRemaining;
            _eState = NoMoreProperty;

            return FILTER_S_LAST_TEXT;
        }

        break;
    }

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CPropertyTag::GetText, unknown value of _eState: %d\n",
                       _eState ));
        return S_OK;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK as part of a GetChunk call
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CPropertyTag::InitStatChunk( STAT_CHUNK *pStat )
{
    //
    // Skip over the rest of property tag
    //
    _scanner.EatTag();

    _cPropChars = 0;
    _cPropCharsFiltered = 0;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->breakType = CHUNK_EOS;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    if ( _htmlIFilter.FFilterContent() )
    {
        //
        // Store the idChunk so that it can be retrieved later to set the value of
        // idChunkSource when initializing the pseudo-property
        //
        _ulIdContentChunk = pStat->idChunk;
        pStat->attribute.guidPropSet = CLSID_Storage;
        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
        pStat->idChunkSource = pStat->idChunk;

        _eState = FilteringContent;
    }
    else
    {
        //
        // We've been asked to filter only the pseudo-property, so skip content filtering
        //
        _ulIdContentChunk = 0;
        pStat->attribute.guidPropSet = _propSpec.GetPropSet();

        Win4Assert( _propSpec.IsPropertyPropid() );

        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = _propSpec.GetPropertyPropid();
        pStat->idChunkSource = 0;

        _eState = FilteringPropertyButContentNotFiltered;
    }
 }



 //+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::ConcatenateProperty
//
//  Synopsis:   Append the Property suffix to Property stored in internal buffer
//
//  Arguments:  [awcPropertySuffix] -- Suffix of Property
//              [uLen]           -- Length of Property
//
//--------------------------------------------------------------------------

void CPropertyTag::ConcatenateProperty( WCHAR *awcPropSuffix, unsigned uLen )
{
    //
    // Need to grow Property buffer ?
    //
    if ( _cPropChars + uLen > _uLenPropBuf )
    {
        WCHAR *pwcNewPropBuf = newk(mtNewX, NULL) WCHAR[_cPropChars + uLen + PROP_BUFFER_SLOP];
        RtlCopyMemory( pwcNewPropBuf, _pwcPropBuf, _cPropChars * sizeof(WCHAR) );

        delete[] _pwcPropBuf;
        _uLenPropBuf = _cPropChars + uLen + PROP_BUFFER_SLOP;

        _pwcPropBuf = pwcNewPropBuf;
    }

    RtlCopyMemory( _pwcPropBuf + _cPropChars, awcPropSuffix, uLen * sizeof(WCHAR) );
    _cPropChars += uLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\start.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       start.cxx
//
//  Contents:   Parsing algorithm at the beginning of an Html file
//
//  Classes:    CStartOfFileElement
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <start.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::CStartOfFileElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CStartOfFileElement::CStartOfFileElement( CHtmlIFilter& htmlIFilter,
                                          CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CStartOfFileElement::GetChunk( STAT_CHUNK * pStat )
{
    //
    // This is the first GetChunk call ever, hence setup the correct
    // Html Element
    //
    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CStartOfFileElement::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    //
    // CStartOfFile is used to set up the first chunk correctly, and the first
    // chunk cannot be of type CStartOfFile
    //
    Win4Assert( !"CStartOfFileElement::GetText() call unexpected" );

    return E_FAIL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CStartOfFileElement::InitStatChunk( STAT_CHUNK *pStat )
{
    Win4Assert( !"CStartOfFileElement::InitStatChunk() call unexpected" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\serstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       serstrm.cxx
//
//  Contents:   Serial stream
//
//  Classes:    CSerialStream
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlfilt.hxx>

//
// Special char hash table is static so that there is only one hash table
// per htmlfilt dll
//
CSpecialCharHashTable CSerialStream::_specialCharHash;

//
// aControlCodeMap is the mapping for chars in the control code region (0x80 to 0x9f)
// as mapped by the web browser
//
static WCHAR aControlCodeMap[] = { 0x20,     // space
                                   0x20,     // space
                                   0x2c,     // comma
                                   0x192,    // script f
                                   0x201e,   // low double comma
                                   0x2026,   // horizontal ellipsis
                                   0x2020,   // dagger
                                   0x2021,   // double dagger
                                   0x5e,     // circumflex
                                   0x2030,   // per mille
                                   0x160,    // S haeck
                                   0x2039,   // left guillemet
                                   0x152,    // OE
                                   0x20,     // space
                                   0x20,     // space
                                   0x20,     // space
                                   0x20,     // space
                                   0x2018,   // single turned comma
                                   0x2019,   // single turned comma
                                   0x201c,   // double turned comma
                                   0x201d,   // double turned comma
                                   0x2022,   // bullet
                                   0x2014,   // em dash
                                   0x2015,   // quotation dash
                                   0x2dc,    // tilde
                                   0x2122,   // trademark
                                   0x161,    // s haeck
                                   0x203a,   // right guillemet
                                   0x153,    // oe
                                   0x20,     // space
                                   0x20,     // space
                                   0x178     // y diaresis
                                 };


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::CSerialStream
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CSerialStream::CSerialStream()
    : _wch(0),
      _fUnGotChar(FALSE),
      _cCharsReadAhead(0),
      _pCurChar(_awcReadAheadBuf)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Init
//
//  Synopsis:   Initialize the memory mapped stream
//
//  Arguments:  [pwszFileName] -- File to be mapped
//
//--------------------------------------------------------------------------

void CSerialStream::Init( WCHAR *pwszFileName )
{
    _mmInputStream.Init( pwszFileName );
}



//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::GetChar
//
//  Synopsis:   Read the next Unicode character from the input file, accounting
//              for special chars, chars push backs and read ahead
//
//  Returns:    Next Unicode char
//
//--------------------------------------------------------------------------

WCHAR CSerialStream::GetChar()
{
    //
    // Was a char pushed back into input ?
    //
    if ( _fUnGotChar )
    {
        _fUnGotChar = FALSE;
        return _wch;
    }

    //
    // Are there any chars in our read-ahead buffer ?
    //
    WCHAR wch;
    if ( _pCurChar < _awcReadAheadBuf + _cCharsReadAhead )
    {
        wch = *_pCurChar;
        _pCurChar++;

        return wch;
    }

    if ( _mmInputStream.Eof() )
        return WEOF;

    //
    // Read from input stream
    //
    wch = _mmInputStream.GetChar();
    if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces
        wch = L' ';

    if ( wch == L'&' )
    {
        //
        // Read in the special char until ';' or '&', or EOF, or until _awcReadAhead buffer is full
        //
        _awcReadAheadBuf[0] = wch;
        for ( unsigned i=1; i<MAX_SPECIAL_CHAR_LENGTH; i++)
        {
            if ( _mmInputStream.Eof() )
                break;

            wch = _mmInputStream.GetChar();
            if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces
                wch = L' ';

            _awcReadAheadBuf[i] = wch;
            if ( wch == L';' || wch == L'&' )
                break;
        }

        if ( wch == L';' )
        {
            if ( _awcReadAheadBuf[1] == L'#' && IsUnicodeNumber( &_awcReadAheadBuf[2], i-2, wch ) )
            {
                //
                // Return converted Unicode number, e.g. for &#160, return 160
                //
                return wch;
            }
            else if ( _specialCharHash.Lookup( &_awcReadAheadBuf[1], i-1, wch ) )
            {
                //
                // Corresponding Unicode char found
                //
                return wch;
            }
            else
            {
                _cCharsReadAhead = i+1;
                _pCurChar = &_awcReadAheadBuf[1];

                return L'&';
            }
        }
        else if ( wch == L'&' )
        {
            //
            // For example, &acu&aacute; . So keep &acu in the read ahead buffer,
            // but push the second '&' back into the input stream, so that &aacute;
            // can be recognized as a special char during a subsequent call to GetChar()
            //
            _mmInputStream.UnGetChar( L'&' );
            _cCharsReadAhead = i;
            _pCurChar = &_awcReadAheadBuf[1];

            return L'&';
        }
        else
        {
            _cCharsReadAhead = i;
            _pCurChar = &_awcReadAheadBuf[1];

            return L'&';
        }
    }
    else
        return wch;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::UnGetChar
//
//  Synopsis:   Pushes(logically) a character back into the input stream
//
//  Arguments:  [wch]  -- Char to be pushed back
//
//--------------------------------------------------------------------------

void CSerialStream::UnGetChar( WCHAR wch )
{
    //
    // We can unget only one char at a time
    //
    Win4Assert( ! _fUnGotChar );

    _fUnGotChar = TRUE;
    _wch = wch;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Eof
//
//  Synopsis:   Is this the end of input file ?
//
//--------------------------------------------------------------------------

BOOL CSerialStream::Eof()
{
    if ( _fUnGotChar )
        return FALSE;

    if ( _pCurChar < _awcReadAheadBuf + _cCharsReadAhead )
        return FALSE;

    return _mmInputStream.Eof();
}




//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::IsUnicodeNumber
//
//  Synopsis:   Is the special char a Unicode number ?
//
//  Arguments:  [pwcInputBuf] -- input buffer
//              [uLen]        -- Length of input (not \0 terminated)
//              [wch]         -- Unicode char returned here
//
//  Returns:    True if we've managed to convert to a Unicode number
//
//--------------------------------------------------------------------------

BOOL CSerialStream::IsUnicodeNumber( WCHAR *pwcInputBuf,
                                     unsigned uLen,
                                     WCHAR& wch )
{
    wch = 0;
    for ( unsigned i=0; i<uLen; i++ )
    {
        //
        // Check that the result will be less than max Unicode value, namely 0xffff
        //
        if ( iswdigit( pwcInputBuf[i] )
             && wch < (0xffff - (pwcInputBuf[i]-L'0'))/10 )
        {
            wch = 10 * wch + pwcInputBuf[i] - L'0';
        }
        else
            return FALSE;
    }

    if ( wch >= 0x80 && wch <= 0x9f )
    {
        //
        // Chars in the control code region are mapped by the browser to valid chars
        //

        wch = aControlCodeMap[wch-0x80];
    }

    return ( wch > 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\scriptag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       scripttag.cxx
//
//  Contents:   Parsing algorithm for script tag in Html
//
//  Classes:    CScriptTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <scriptag.hxx>
#include <htmlguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::CScriptTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//              [clsidScriptInfo]  -- Clsid for script chunk
//
//--------------------------------------------------------------------------

CScriptTag::CScriptTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream,
                    GUID clsidScriptInfo )
    : CHtmlElement(htmlIFilter, serialStream),
      _clsidScriptInfo(clsidScriptInfo),
      _eState(NoMoreContent)
{
    _awszPropSpec[0] = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CScriptTag::GetChunk( STAT_CHUNK * pStat )
{
    switch ( _eState )
    {

    case  FilteringContent:
    {
        SCODE sc = SkipRemainingTextAndGotoNextChunk( pStat );

        return sc;
    }

    case NoMoreContent:
    {
            SCODE sc = SwitchToNextHtmlElement( pStat );

            return sc;
    }

    default:
        Win4Assert( !"Unknown _eState in CScriptTag::GetChunk" );
        htmlDebugOut(( DEB_ERROR, "CScriptTag::GetChunk, unkown tag state: %d\n", _eState ));

        return S_OK;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CScriptTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    switch( _eState )
    {
    case NoMoreContent:
        return FILTER_E_NO_MORE_TEXT;

    case FilteringContent:
    {
        ULONG cCharsRead = 0;
        while ( cCharsRead < *pcwcOutput )
        {
            ULONG cCharsScanned;
            ULONG cCharsNeeded = *pcwcOutput - cCharsRead;
            CToken token;
            _scanner.GetBlockOfChars( cCharsNeeded,
                                      awcBuffer + cCharsRead,
                                      cCharsScanned,
                                      token );

            cCharsRead += cCharsScanned;
            if ( cCharsScanned == cCharsNeeded )
            {
                //
                // We've read the #chars requested by user
                //
                break;
            }

            HtmlTokenType eTokType = token.GetTokenType();
            if ( eTokType == EofToken || eTokType == ScriptToken )
            {
                //
                // End of file or end script tag
                //
                _eState = NoMoreContent;

                break;
            }
            else if ( eTokType == BreakToken )
            {
                //
                // Insert a newline char
                //
                Win4Assert( cCharsRead < *pcwcOutput );
                awcBuffer[cCharsRead++] = L'\n';
                _scanner.EatTag();
            }
            else if ( eTokType == CommentToken )
            {
                //
                // Scripts are often enclosed in comments for backward
                // compatibilty, so do nothing
                //
            }
            else
            {
                //
                // Uninteresting tag, so skip over tag and continue processing
                //
                _scanner.EatTag();
            }
        }

        *pcwcOutput = cCharsRead;

        if ( _eState == NoMoreContent )
            return FILTER_S_LAST_TEXT;
        else
            return S_OK;

        break;
    }

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CScriptTag::GetText, unknown value of _eState: %d\n",
                       _eState ));
        return S_OK;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CScriptTag::GetValue( PROPVARIANT **ppPropValue )
{
    return FILTER_E_NO_VALUES;
}


//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CScriptTag::InitStatChunk( STAT_CHUNK *pStat )
{
    WCHAR *pwcLang;
    unsigned cwcLang;

    //
    // Read the Language field
    //
    _scanner.ReadTagIntoBuffer();
    _scanner.ScanTagBuffer( L"language=\"", pwcLang, cwcLang );

    if ( cwcLang == 0 )
    {
        //
        // Use whatever was specified in an earlier script tag, if none, the default is
        // Javascript
        //
        if ( _awszPropSpec[0] == 0 )
            RtlCopyMemory( _awszPropSpec, L"javascript", (wcslen(L"javascript") + 1) * sizeof( WCHAR) );
    }
    else
    {
        if ( cwcLang > MAX_PROPSPEC_STRING_LENGTH )
            cwcLang = MAX_PROPSPEC_STRING_LENGTH;     // Truncate to max length permitted

        RtlCopyMemory( _awszPropSpec, pwcLang, cwcLang * sizeof(WCHAR) );
        _awszPropSpec[cwcLang] = 0;
    }

    _eState = FilteringContent;

    pStat->attribute.guidPropSet = _clsidScriptInfo;
    pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
    pStat->attribute.psProperty.lpwstr = _awszPropSpec;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\textelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       textelem.cxx
//
//  Contents:   Parsing algorithm for vanilla text in Html
//
//  Classes:    CTextElement
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <textelem.hxx>
#include <htmlguid.hxx>
#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::CTextElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CTextElement::CTextElement( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _fNoMoreText(TRUE),
      _eTokTypeNext(GenericToken),
      _idChunk(0),
      _cTextChars(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CTextElement::GetChunk( STAT_CHUNK * pStat )
{
    if ( _serialStream.Eof() )
        return FILTER_E_END_OF_CHUNKS;

    if ( _fNoMoreText )
    {
        //
        // This is the GetChunk call after we've returned FILTER_E_NO_MORE_TEXT
        // for the previous chunk
        //
        CHtmlElement *pHtmlElemNext = _htmlIFilter.QueryHtmlElement( _eTokTypeNext );
        Win4Assert( pHtmlElemNext );
        pHtmlElemNext->InitStatChunk( pStat );
        _htmlIFilter.ChangeState( pHtmlElemNext );
    }
    else
    {
        //
        // GetChunk was called even though we had not returned
        // FILTER_E_NO_MORE_TEXT.
        //
        SCODE sc = SkipRemainingTextAndGotoNextChunk( pStat );

        return sc;
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CTextElement::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    if ( _fNoMoreText || _serialStream.Eof() )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    ULONG cCharsRead = 0;  // count of chars read from input
    while ( cCharsRead < *pcwcOutput )
    {
        CToken token;
        ULONG cCharsScanned;
        ULONG cCharsNeeded = *pcwcOutput - cCharsRead;

        _scanner.GetBlockOfChars( cCharsNeeded,
                                  awcBuffer + cCharsRead,
                                  cCharsScanned,
                                  token );

        cCharsRead += cCharsScanned;
        if ( cCharsScanned == cCharsNeeded )
        {
            //
            // We've read the #chars requested by the user
            //
            break;
        }

        HtmlTokenType eTokType = token.GetTokenType();
        if ( eTokType == EofToken || _htmlIFilter.IsStopToken( token ) )
        {
            //
            // End of file, or we've hit an interesting token
            //
            _fNoMoreText = TRUE;
            _eTokTypeNext = eTokType;         // Need the token type to set up the next chunk

            break;
        }
        else if ( eTokType == BreakToken )
        {
            //
            // Insert a newline char
            //
            Win4Assert( cCharsRead < *pcwcOutput );
            awcBuffer[cCharsRead++] = L'\n';
            _scanner.EatTag();
        }
        else
        {
            //
            // Skip over uninteresting tag and continue processing
            //
            _scanner.EatTag();
        }
    }

    *pcwcOutput = cCharsRead;

    _cTextChars += cCharsRead;

    if ( _fNoMoreText )
        return FILTER_S_LAST_TEXT;
    else
        return S_OK;
}





//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

void CTextElement::InitStatChunk( STAT_CHUNK *pStat )
{
    //
    // There is more text to be returned
    //
    _fNoMoreText = FALSE;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetLocale();
    pStat->attribute.guidPropSet = CLSID_Storage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    _idChunk = pStat->idChunk;
    _cTextChars = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::InitFilterRegion
//
//  Synopsis:   Initializes the filter region corresponding to this chunk
//
//  Arguments:  [idChunkSource]  -- Id of source chunk
//              [cwcStartSource] -- Offset of source text in chunk
//              [cwcLenSource]   -- Length of source text in chunk
//
//--------------------------------------------------------------------------

void CTextElement::InitFilterRegion( ULONG& idChunkSource,
                                     ULONG& cwcStartSource,
                                     ULONG& cwcLenSource )
{
    idChunkSource = _idChunk;
    cwcStartSource = 0;
    cwcLenSource = _cTextChars;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\ifilter\titletag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       titletag.cxx
//
//  Contents:   Parsing algorithm for title tag in Html
//
//  Classes:    CTitleTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <titletag.hxx>
#include <htmlguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::CTitleTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]  -- Reference to Html filter
//              [serialStream] -- Reference to input stream
//              [propSpec]     -- Property spec
//              [eTokType]     -- Token corresponding to this property
//
//--------------------------------------------------------------------------

CTitleTag::CTitleTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream,
                      CFullPropSpec& propSpec,
                      HtmlTokenType eTokType )
    : CPropertyTag(htmlIFilter, serialStream, propSpec, eTokType)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CTitleTag::GetChunk( STAT_CHUNK * pStat )
{
    switch ( _eState )
    {
    case NoMoreProperty:
        _eState = FilteringValueProperty;

        pStat->idChunk = _htmlIFilter.GetNextChunkId();
        pStat->breakType = CHUNK_EOS;
        pStat->flags = CHUNK_VALUE;
        pStat->locale = _htmlIFilter.GetLocale();
        pStat->attribute.guidPropSet = _propSpec.GetPropSet();

        Win4Assert( _propSpec.IsPropertyPropid() );

        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = _propSpec.GetPropertyPropid();
        pStat->idChunkSource = _ulIdContentChunk;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;

        return S_OK;

    case FilteringValueProperty:
    case NoMoreValueProperty:
        //
        // Skip over the end property tag
        //
        _scanner.EatTag();

        return SwitchToNextHtmlElement( pStat );

    default:
        return CPropertyTag::GetChunk( pStat );
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CTitleTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    switch ( _eState )
    {
    case FilteringValueProperty:
    case NoMoreValueProperty:
        return FILTER_E_NO_TEXT;

    default:
        return CPropertyTag::GetText( pcwcOutput, awcBuffer );
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CTitleTag::GetValue( PROPVARIANT **ppPropValue )
{
    switch (_eState)
    {
    case FilteringContent:
    case NoMoreContent:
    case FilteringProperty:
    case FilteringPropertyButContentNotFiltered:
    case NoMoreProperty:
        return FILTER_E_NO_VALUES;

    case FilteringValueProperty:
    {
        ConcatenateProperty( L"\0", 1 );     // Null terminate for SetLPWSTR

        PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
        if ( pPropVar == 0 )
            return E_OUTOFMEMORY;

        pPropVar->vt = VT_LPWSTR;
        int cb = ( wcslen(_pwcPropBuf) + 1 ) * sizeof( WCHAR );
        pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( cb );

        if ( pPropVar->pwszVal == 0 )
        {
            CoTaskMemFree( (void *) pPropVar );
            return E_OUTOFMEMORY;
        }

        RtlCopyMemory( pPropVar->pwszVal, _pwcPropBuf, cb );

        *ppPropValue = pPropVar;

        _eState = NoMoreValueProperty;
        return S_OK;
    }

    case NoMoreValueProperty:
        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CTitleTag::GetValue, unknown value of _eState: %d\n",
                       _eState ));
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\iissearch\is2foot.inc ===
<!-- STANDARD MICROSOFT FOOTER FOR QUERY PAGES -->

<hr width=500 align=left>
<p>
<table border="0" cellpadding="0" cellspacing="0" width="500">
    <tr>
        <!-- IIS GIF -->
       <td>
            <a href="http://www.microsoft.com/windows2000"><img src="win2k.gif" alt="Learn more about Microsoft Windows 2000!"  border="0"></a>
        </td>

        <!-- Microsoft Legal Info -->
        <td align=center>
            <font style="font:arial; font-size: 8pt"> &copy;1997-1999 Microsoft Corporation. All rights reserved.<br></font>
            <a href="http://www.microsoft.com/misc/cpyright.htm"><font style="font:arial; font-size: 6pt">Legal Notices.</font></a>
       </td>

        <!-- Best with IE GIF -->
        <td align=right>
            <a href="http://www.microsoft.com/ie"><img src="IE.GIF" alt="Download Internet Explorer!"  border="0"></a>
        </td>
    </tr>
</table>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\qsample\disptree.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// FILE:     disptree.cxx
//
// PURPOSE:  Displays a command tree, for debugging.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayVariant
//
//  Synopsis:   Displays a PROPVARIANT.  This is not a complete
//              implementation; many VT_ types are not complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayVariant( PROPVARIANT * pVar )
{
    if ( 0 == pVar )
    {
        printf( "NULL" );
        return;
    }

    PROPVARIANT & v = *pVar;

    switch ( v.vt )
    {
        case VT_I4 : printf( "VT_I4 %d", v.lVal ); break;
        case VT_UI1 : printf( "VT_UI1 %d", v.bVal ); break;
        case VT_I2 : printf( "VT_I2 %d", v.iVal ); break;
        case VT_R4 : printf( "VT_R4 %f", v.fltVal ); break;
        case VT_R8 : printf( "VT_R8 %lf", v.dblVal ); break;
        case VT_BOOL : printf( "VT_BOOL %d", v.boolVal ); break;
        case VT_ERROR : printf( "VT_ERROR %#x", v.scode ); break;
        case VT_CY :
        {
            double dbl;
            VarR8FromCy( pVar->cyVal, &dbl );

            printf( "VT_CY %lf", dbl );
            break;
        }
        case VT_DATE : printf( "VT_DATE " ); break;
        case VT_FILETIME : printf( "VT_FILETIME %#I64x ", v.filetime ); break;
        case VT_BSTR : printf( "VT_BSTR '%ws'", v.bstrVal ); break;
        case VT_UNKNOWN : printf( "VT_UNKNOWN " ); break;
        case VT_DISPATCH : printf( "VT_DISPATCH " ); break;
        case VT_BYREF|VT_UI1 : printf( "VT_BYREF|VT_UI1 " ); break;
        case VT_BYREF|VT_I2 : printf( "VT_BYREF|VT_I2 " ); break;
        case VT_BYREF|VT_I4 : printf( "VT_BYREF|VT_I4 " ); break;
        case VT_BYREF|VT_R4 : printf( "VT_BYREF|VT_R4 " ); break;
        case VT_BYREF|VT_R8 : printf( "VT_BYREF|VT_R8 " ); break;
        case VT_BYREF|VT_BOOL : printf( "VT_BYREF|VT_BOOL " ); break;
        case VT_BYREF|VT_ERROR : printf( "VT_BYREF|VT_ERROR " ); break;
        case VT_BYREF|VT_CY : printf( "VT_BYREF|VT_CY " ); break;
        case VT_BYREF|VT_DATE : printf( "VT_BYREF|VT_DATE " ); break;
        case VT_BYREF|VT_BSTR : printf( "VT_BYREF|VT_BSTR " ); break;
        case VT_BYREF|VT_UNKNOWN : printf( "VT_BYREF|VT_UNKNOWN " ); break;
        case VT_BYREF|VT_DISPATCH : printf( "VT_BYREF|VT_DISPATCH " ); break;
        case VT_BYREF|VT_ARRAY : printf( "VT_BYREF|VT_ARRAY " ); break;
        case VT_BYREF|VT_VARIANT : printf( "VT_BYREF|VT_VARIANT " ); break;
        case VT_I1 : printf( "VT_I1 %d", v.bVal ); break;
        case VT_UI2 : printf( "VT_UI2 %u", v.uiVal ); break;
        case VT_UI4 : printf( "VT_UI4 %u", v.ulVal ); break;
        case VT_INT : printf( "VT_INT %d", v.lVal ); break;
        case VT_UINT : printf( "VT_UINT %u", v.ulVal ); break;
        case VT_BYREF|VT_DECIMAL : printf( "VT_BYREF|VT_DECIMAL " ); break;
        case VT_BYREF|VT_I1 : printf( "VT_BYREF|VT_I1 " ); break;
        case VT_BYREF|VT_UI2 : printf( "VT_BYREF|VT_UI2 " ); break;
        case VT_BYREF|VT_UI4 : printf( "VT_BYREF|VT_UI4 " ); break;
        case VT_BYREF|VT_INT : printf( "VT_BYREF|VT_INT " ); break;
        case VT_BYREF|VT_UINT : printf( "VT_BYREF|VT_UINT " ); break;
        case VT_LPSTR : printf( "VT_LPSTR '%s'", v.pszVal ); break;
        case VT_LPWSTR : printf( "VT_LPWSTR '%ws'", v.pwszVal ); break;
        case VT_I8 : printf( "VT_I8 %I64d", v.hVal ); break;
        case VT_UI8 : printf( "VT_I8 %I64u", v.hVal ); break;
        case VT_VECTOR | VT_I1:
            printf( "VT_VECTOR | VT_I1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I2:
            printf( "VT_VECTOR | VT_I2 " );
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I4:
            printf( "VT_VECTOR | VT_I4 " );
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I8:
            printf( "VT_VECTOR | VT_I8 " );
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" );
            break;
        case VT_VECTOR | VT_UI1:
            printf( "VT_VECTOR | VT_UI1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI2:
            printf( "VT_VECTOR | VT_UI2 " );
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI4:
            printf( "VT_VECTOR | VT_UI4 " );
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI8:
            printf( "VT_VECTOR | VT_UI8 " );
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" );
            break;
        case VT_VECTOR | VT_BSTR:
            printf( "VT_VECTOR | VT_BSTR " );
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_LPSTR:
            printf( "VT_VECTOR | VT_LPSTR " );
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%s" );
            break;
        case VT_VECTOR | VT_LPWSTR:
            printf( "VT_VECTOR | VT_LPWSTR " );
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_R4:
            printf( "VT_VECTOR | VT_R4 " );
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" );
            break;
        case VT_VECTOR | VT_R8:
            printf( "VT_VECTOR | VT_R8 " );
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" );
            break;
        default : printf( "unknown vt %#x", v.vt );
    }
} //DisplayVariant

//+-------------------------------------------------------------------------
//
//  Function:   PrintSpace
//
//  Synopsis:   Prints white space.
//
//  Arguments:  [cPlaces] - Number of levels to print
//
//--------------------------------------------------------------------------

void PrintSpace( ULONG cPlaces )
{
    for( ULONG iPlace = 0; iPlace < cPlaces; iPlace++ )
        printf( "  " );
} //PrintSpace

//+-------------------------------------------------------------------------
//
//  Function:   DisplayCommandTree
//
//  Synopsis:   Displays the command tree, useful for debugging.  This is
//              not a complete implementation; many DBVALUEKINDs are not
//              complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayCommandTree(
    DBCOMMANDTREE * pNode,
    ULONG           iLevel )
{
    PrintSpace( iLevel );
    printf( "op: (%d) ", pNode->op );
    switch ( pNode->op )
    {
        case DBOP_scalar_constant : printf( "DBOP_scalar_constant" ); break;
        case DBOP_DEFAULT : printf( "DBOP_DEFAULT" ); break;
        case DBOP_NULL : printf( "DBOP_NULL" ); break;
        case DBOP_bookmark_name : printf( "DBOP_bookmark_name" ); break;
        case DBOP_catalog_name : printf( "DBOP_catalog_name" ); break;
        case DBOP_column_name : printf( "DBOP_column_name" ); break;
        case DBOP_schema_name : printf( "DBOP_schema_name" ); break;
        case DBOP_outall_name : printf( "DBOP_outall_name" ); break;
        case DBOP_qualifier_name : printf( "DBOP_qualifier_name" ); break;
        case DBOP_qualified_column_name : printf( "DBOP_qualified_column_name" ); break;
        case DBOP_table_name : printf( "DBOP_table_name" ); break;
        case DBOP_nested_table_name : printf( "DBOP_nested_table_name" ); break;
        case DBOP_nested_column_name : printf( "DBOP_nested_column_name" ); break;
        case DBOP_row : printf( "DBOP_row" ); break;
        case DBOP_table : printf( "DBOP_table" ); break;
        case DBOP_sort : printf( "DBOP_sort" ); break;
        case DBOP_distinct : printf( "DBOP_distinct" ); break;
        case DBOP_distinct_order_preserving : printf( "DBOP_distinct_order_preserving" ); break;
        case DBOP_alias : printf( "DBOP_alias" ); break;
        case DBOP_cross_join : printf( "DBOP_cross_join" ); break;
        case DBOP_union_join : printf( "DBOP_union_join" ); break;
        case DBOP_inner_join : printf( "DBOP_inner_join" ); break;
        case DBOP_left_semi_join : printf( "DBOP_left_semi_join" ); break;
        case DBOP_right_semi_join : printf( "DBOP_right_semi_join" ); break;
        case DBOP_left_anti_semi_join : printf( "DBOP_left_anti_semi_join" ); break;
        case DBOP_right_anti_semi_join : printf( "DBOP_right_anti_semi_join" ); break;
        case DBOP_left_outer_join : printf( "DBOP_left_outer_join" ); break;
        case DBOP_right_outer_join : printf( "DBOP_right_outer_join" ); break;
        case DBOP_full_outer_join : printf( "DBOP_full_outer_join" ); break;
        case DBOP_natural_join : printf( "DBOP_natural_join" ); break;
        case DBOP_natural_left_outer_join : printf( "DBOP_natural_left_outer_join" ); break;
        case DBOP_natural_right_outer_join : printf( "DBOP_natural_right_outer_join" ); break;
        case DBOP_natural_full_outer_join : printf( "DBOP_natural_full_outer_join" ); break;
        case DBOP_set_intersection : printf( "DBOP_set_intersection" ); break;
        case DBOP_set_union : printf( "DBOP_set_union" ); break;
        case DBOP_set_left_difference : printf( "DBOP_set_left_difference" ); break;
        case DBOP_set_right_difference : printf( "DBOP_set_right_difference" ); break;
        case DBOP_set_anti_difference : printf( "DBOP_set_anti_difference" ); break;
        case DBOP_bag_intersection : printf( "DBOP_bag_intersection" ); break;
        case DBOP_bag_union : printf( "DBOP_bag_union" ); break;
        case DBOP_bag_left_difference : printf( "DBOP_bag_left_difference" ); break;
        case DBOP_bag_right_difference : printf( "DBOP_bag_right_difference" ); break;
        case DBOP_bag_anti_difference : printf( "DBOP_bag_anti_difference" ); break;
        case DBOP_division : printf( "DBOP_division" ); break;
        case DBOP_relative_sampling : printf( "DBOP_relative_sampling" ); break;
        case DBOP_absolute_sampling : printf( "DBOP_absolute_sampling" ); break;
        case DBOP_transitive_closure : printf( "DBOP_transitive_closure" ); break;
        case DBOP_recursive_union : printf( "DBOP_recursive_union" ); break;
        case DBOP_aggregate : printf( "DBOP_aggregate" ); break;
        case DBOP_remote_table : printf( "DBOP_remote_table" ); break;
        case DBOP_select : printf( "DBOP_select" ); break;
        case DBOP_order_preserving_select : printf( "DBOP_order_preserving_select" ); break;
        case DBOP_project : printf( "DBOP_project" ); break;
        case DBOP_project_order_preserving : printf( "DBOP_project_order_preserving" ); break;
        case DBOP_top : printf( "DBOP_top" ); break;
        case DBOP_top_percent : printf( "DBOP_top_percent" ); break;
        case DBOP_top_plus_ties : printf( "DBOP_top_plus_ties" ); break;
        case DBOP_top_percent_plus_ties : printf( "DBOP_top_percent_plus_ties" ); break;
        case DBOP_rank : printf( "DBOP_rank" ); break;
        case DBOP_rank_ties_equally : printf( "DBOP_rank_ties_equally" ); break;
        case DBOP_rank_ties_equally_and_skip : printf( "DBOP_rank_ties_equally_and_skip" ); break;
        case DBOP_navigate : printf( "DBOP_navigate" ); break;
        case DBOP_nesting : printf( "DBOP_nesting" ); break;
        case DBOP_unnesting : printf( "DBOP_unnesting" ); break;
        case DBOP_nested_apply : printf( "DBOP_nested_apply" ); break;
        case DBOP_cross_tab : printf( "DBOP_cross_tab" ); break;
        case DBOP_is_NULL : printf( "DBOP_is_NULL" ); break;
        case DBOP_is_NOT_NULL : printf( "DBOP_is_NOT_NULL" ); break;
        case DBOP_equal : printf( "DBOP_equal" ); break;
        case DBOP_not_equal : printf( "DBOP_not_equal" ); break;
        case DBOP_less : printf( "DBOP_less" ); break;
        case DBOP_less_equal : printf( "DBOP_less_equal" ); break;
        case DBOP_greater : printf( "DBOP_greater" ); break;
        case DBOP_greater_equal : printf( "DBOP_greater_equal" ); break;
        case DBOP_equal_all : printf( "DBOP_equal_all" ); break;
        case DBOP_not_equal_all : printf( "DBOP_not_equal_all" ); break;
        case DBOP_less_all : printf( "DBOP_less_all" ); break;
        case DBOP_less_equal_all : printf( "DBOP_less_equal_all" ); break;
        case DBOP_greater_all : printf( "DBOP_greater_all" ); break;
        case DBOP_greater_equal_all : printf( "DBOP_greater_equal_all" ); break;
        case DBOP_equal_any : printf( "DBOP_equal_any" ); break;
        case DBOP_not_equal_any : printf( "DBOP_not_equal_any" ); break;
        case DBOP_less_any : printf( "DBOP_less_any" ); break;
        case DBOP_less_equal_any : printf( "DBOP_less_equal_any" ); break;
        case DBOP_greater_any : printf( "DBOP_greater_any" ); break;
        case DBOP_greater_equal_any : printf( "DBOP_greater_equal_any" ); break;
        case DBOP_anybits : printf( "DBOP_anybits" ); break;
        case DBOP_allbits : printf( "DBOP_allbits" ); break;
        case DBOP_anybits_any : printf( "DBOP_anybits_any" ); break;
        case DBOP_allbits_any : printf( "DBOP_allbits_any" ); break;
        case DBOP_anybits_all : printf( "DBOP_anybits_all" ); break;
        case DBOP_allbits_all : printf( "DBOP_allbits_all" ); break;
        case DBOP_between : printf( "DBOP_between" ); break;
        case DBOP_between_unordered : printf( "DBOP_between_unordered" ); break;
        case DBOP_match : printf( "DBOP_match" ); break;
        case DBOP_match_unique : printf( "DBOP_match_unique" ); break;
        case DBOP_match_partial : printf( "DBOP_match_partial" ); break;
        case DBOP_match_partial_unique : printf( "DBOP_match_partial_unique" ); break;
        case DBOP_match_full : printf( "DBOP_match_full" ); break;
        case DBOP_match_full_unique : printf( "DBOP_match_full_unique" ); break;
        case DBOP_scalar_parameter : printf( "DBOP_scalar_parameter" ); break;
        case DBOP_scalar_function : printf( "DBOP_scalar_function" ); break;
        case DBOP_plus : printf( "DBOP_plus" ); break;
        case DBOP_minus : printf( "DBOP_minus" ); break;
        case DBOP_times : printf( "DBOP_times" ); break;
        case DBOP_over : printf( "DBOP_over" ); break;
        case DBOP_div : printf( "DBOP_div" ); break;
        case DBOP_modulo : printf( "DBOP_modulo" ); break;
        case DBOP_power : printf( "DBOP_power" ); break;
        case DBOP_like : printf( "DBOP_like" ); break;
        case DBOP_sounds_like : printf( "DBOP_sounds_like" ); break;
        case DBOP_like_any : printf( "DBOP_like_any" ); break;
        case DBOP_like_all : printf( "DBOP_like_all" ); break;
        case DBOP_is_INVALID : printf( "DBOP_is_INVALID" ); break;
        case DBOP_is_TRUE : printf( "DBOP_is_TRUE" ); break;
        case DBOP_is_FALSE : printf( "DBOP_is_FALSE" ); break;
        case DBOP_and : printf( "DBOP_and" ); break;
        case DBOP_or : printf( "DBOP_or" ); break;
        case DBOP_xor : printf( "DBOP_xor" ); break;
        case DBOP_equivalent : printf( "DBOP_equivalent" ); break;
        case DBOP_not : printf( "DBOP_not" ); break;
        case DBOP_implies : printf( "DBOP_implies" ); break;
        case DBOP_overlaps : printf( "DBOP_overlaps" ); break;
        case DBOP_case_condition : printf( "DBOP_case_condition" ); break;
        case DBOP_case_value : printf( "DBOP_case_value" ); break;
        case DBOP_nullif : printf( "DBOP_nullif" ); break;
        case DBOP_cast : printf( "DBOP_cast" ); break;
        case DBOP_coalesce : printf( "DBOP_coalesce" ); break;
        case DBOP_position : printf( "DBOP_position" ); break;
        case DBOP_extract : printf( "DBOP_extract" ); break;
        case DBOP_char_length : printf( "DBOP_char_length" ); break;
        case DBOP_octet_length : printf( "DBOP_octet_length" ); break;
        case DBOP_bit_length : printf( "DBOP_bit_length" ); break;
        case DBOP_substring : printf( "DBOP_substring" ); break;
        case DBOP_upper : printf( "DBOP_upper" ); break;
        case DBOP_lower : printf( "DBOP_lower" ); break;
        case DBOP_trim : printf( "DBOP_trim" ); break;
        case DBOP_translate : printf( "DBOP_translate" ); break;
        case DBOP_convert : printf( "DBOP_convert" ); break;
        case DBOP_string_concat : printf( "DBOP_string_concat" ); break;
        case DBOP_current_date : printf( "DBOP_current_date" ); break;
        case DBOP_current_time : printf( "DBOP_current_time" ); break;
        case DBOP_current_timestamp : printf( "DBOP_current_timestamp" ); break;
        case DBOP_content_select : printf( "DBOP_content_select" ); break;
        case DBOP_content : printf( "DBOP_content" ); break;
        case DBOP_content_freetext : printf( "DBOP_content_freetext" ); break;
        case DBOP_content_proximity : printf( "DBOP_content_proximity" ); break;
        case DBOP_content_vector_or : printf( "DBOP_content_vector_or" ); break;
        case DBOP_delete : printf( "DBOP_delete" ); break;
        case DBOP_update : printf( "DBOP_update" ); break;
        case DBOP_insert : printf( "DBOP_insert" ); break;
        case DBOP_min : printf( "DBOP_min" ); break;
        case DBOP_max : printf( "DBOP_max" ); break;
        case DBOP_count : printf( "DBOP_count" ); break;
        case DBOP_sum : printf( "DBOP_sum" ); break;
        case DBOP_avg : printf( "DBOP_avg" ); break;
        case DBOP_any_sample : printf( "DBOP_any_sample" ); break;
        case DBOP_stddev : printf( "DBOP_stddev" ); break;
        case DBOP_stddev_pop : printf( "DBOP_stddev_pop" ); break;
        case DBOP_var : printf( "DBOP_var" ); break;
        case DBOP_var_pop : printf( "DBOP_var_pop" ); break;
        case DBOP_first : printf( "DBOP_first" ); break;
        case DBOP_last : printf( "DBOP_last" ); break;
        case DBOP_in : printf( "DBOP_in" ); break;
        case DBOP_exists : printf( "DBOP_exists" ); break;
        case DBOP_unique : printf( "DBOP_unique" ); break;
        case DBOP_subset : printf( "DBOP_subset" ); break;
        case DBOP_proper_subset : printf( "DBOP_proper_subset" ); break;
        case DBOP_superset : printf( "DBOP_superset" ); break;
        case DBOP_proper_superset : printf( "DBOP_proper_superset" ); break;
        case DBOP_disjoint : printf( "DBOP_disjoint" ); break;
        case DBOP_pass_through : printf( "DBOP_pass_through" ); break;
        case DBOP_defined_by_GUID : printf( "DBOP_defined_by_GUID" ); break;
        case DBOP_text_command : printf( "DBOP_text_command" ); break;
        case DBOP_SQL_select : printf( "DBOP_SQL_select" ); break;
        case DBOP_prior_command_tree : printf( "DBOP_prior_command_tree" ); break;
        case DBOP_add_columns : printf( "DBOP_add_columns" ); break;
        case DBOP_column_list_anchor : printf( "DBOP_column_list_anchor" ); break;
        case DBOP_column_list_element : printf( "DBOP_column_list_element" ); break;
        case DBOP_command_list_anchor : printf( "DBOP_command_list_anchor" ); break;
        case DBOP_command_list_element : printf( "DBOP_command_list_element" ); break;
        case DBOP_from_list_anchor : printf( "DBOP_from_list_anchor" ); break;
        case DBOP_from_list_element : printf( "DBOP_from_list_element" ); break;
        case DBOP_project_list_anchor : printf( "DBOP_project_list_anchor" ); break;
        case DBOP_project_list_element : printf( "DBOP_project_list_element" ); break;
        case DBOP_row_list_anchor : printf( "DBOP_row_list_anchor" ); break;
        case DBOP_row_list_element : printf( "DBOP_row_list_element" ); break;
        case DBOP_scalar_list_anchor : printf( "DBOP_scalar_list_anchor" ); break;
        case DBOP_scalar_list_element : printf( "DBOP_scalar_list_element" ); break;
        case DBOP_set_list_anchor : printf( "DBOP_set_list_anchor" ); break;
        case DBOP_set_list_element : printf( "DBOP_set_list_element" ); break;
        case DBOP_sort_list_anchor : printf( "DBOP_sort_list_anchor" ); break;
        case DBOP_sort_list_element : printf( "DBOP_sort_list_element" ); break;
        case DBOP_alter_character_set : printf( "DBOP_alter_character_set" ); break;
        case DBOP_alter_collation : printf( "DBOP_alter_collation" ); break;
        case DBOP_alter_domain : printf( "DBOP_alter_domain" ); break;
        case DBOP_alter_index : printf( "DBOP_alter_index" ); break;
        case DBOP_alter_procedure : printf( "DBOP_alter_procedure" ); break;
        case DBOP_alter_schema : printf( "DBOP_alter_schema" ); break;
        case DBOP_alter_table : printf( "DBOP_alter_table" ); break;
        case DBOP_alter_trigger : printf( "DBOP_alter_trigger" ); break;
        case DBOP_alter_view : printf( "DBOP_alter_view" ); break;
        case DBOP_coldef_list_anchor : printf( "DBOP_coldef_list_anchor" ); break;
        case DBOP_coldef_list_element : printf( "DBOP_coldef_list_element" ); break;
        case DBOP_create_assertion : printf( "DBOP_create_assertion" ); break;
        case DBOP_create_character_set : printf( "DBOP_create_character_set" ); break;
        case DBOP_create_collation : printf( "DBOP_create_collation" ); break;
        case DBOP_create_domain : printf( "DBOP_create_domain" ); break;
        case DBOP_create_index : printf( "DBOP_create_index" ); break;
        case DBOP_create_procedure : printf( "DBOP_create_procedure" ); break;
        case DBOP_create_schema : printf( "DBOP_create_schema" ); break;
        case DBOP_create_synonym : printf( "DBOP_create_synonym" ); break;
        case DBOP_create_table : printf( "DBOP_create_table" ); break;
        case DBOP_create_temporary_table : printf( "DBOP_create_temporary_table" ); break;
        case DBOP_create_translation : printf( "DBOP_create_translation" ); break;
        case DBOP_create_trigger : printf( "DBOP_create_trigger" ); break;
        case DBOP_create_view : printf( "DBOP_create_view" ); break;
        case DBOP_drop_assertion : printf( "DBOP_drop_assertion" ); break;
        case DBOP_drop_character_set : printf( "DBOP_drop_character_set" ); break;
        case DBOP_drop_collation : printf( "DBOP_drop_collation" ); break;
        case DBOP_drop_domain : printf( "DBOP_drop_domain" ); break;
        case DBOP_drop_index : printf( "DBOP_drop_index" ); break;
        case DBOP_drop_procedure : printf( "DBOP_drop_procedure" ); break;
        case DBOP_drop_schema : printf( "DBOP_drop_schema" ); break;
        case DBOP_drop_synonym : printf( "DBOP_drop_synonym" ); break;
        case DBOP_drop_table : printf( "DBOP_drop_table" ); break;
        case DBOP_drop_translation : printf( "DBOP_drop_translation" ); break;
        case DBOP_drop_trigger : printf( "DBOP_drop_trigger" ); break;
        case DBOP_drop_view : printf( "DBOP_drop_view" ); break;
        case DBOP_foreign_key : printf( "DBOP_foreign_key" ); break;
        case DBOP_grant_privileges : printf( "DBOP_grant_privileges" ); break;
        case DBOP_index_list_anchor : printf( "DBOP_index_list_anchor" ); break;
        case DBOP_index_list_element : printf( "DBOP_index_list_element" ); break;
        case DBOP_primary_key : printf( "DBOP_primary_key" ); break;
        case DBOP_property_list_anchor : printf( "DBOP_property_list_anchor" ); break;
        case DBOP_property_list_element : printf( "DBOP_property_list_element" ); break;
        case DBOP_referenced_table : printf( "DBOP_referenced_table" ); break;
        case DBOP_rename_object : printf( "DBOP_rename_object" ); break;
        case DBOP_revoke_privileges : printf( "DBOP_revoke_privileges" ); break;
        case DBOP_schema_authorization : printf( "DBOP_schema_authorization" ); break;
        case DBOP_unique_key : printf( "DBOP_unique_key" ); break;
        case DBOP_scope_list_anchor : printf( "DBOP_scope_list_anchor" ); break;
        case DBOP_scope_list_element : printf( "DBOP_scope_list_element" ); break;
        case DBOP_content_table : printf( "DBOP_content_table" ); break;

        default : printf( "unknown DBOP" ); break;
    }

    printf( "\n" );

    PrintSpace( iLevel );
    printf( "wKind: (%d) ", pNode->wKind );
    switch( pNode->wKind )
    {
        case DBVALUEKIND_BYGUID :
        {
            printf( "DBVALUEKIND_BYGUID " );
            break;
        }
        case DBVALUEKIND_COLDESC :
        {
            printf( "DBVALUEKIND_COLDESC " );
            break;
        }
        case DBVALUEKIND_ID :
        {
            printf( "DBVALUEKIND_ID: " );
            if ( 0 == pNode->value.pdbidValue )
                printf( "NULL" );
            else
            {
                DBKIND kind = pNode->value.pdbidValue->eKind;

                if ( DBKIND_GUID        == kind ||
                     DBKIND_GUID_NAME   == kind ||
                     DBKIND_GUID_PROPID == kind )
                {
                    GUID &g = pNode->value.pdbidValue->uGuid.guid;
                    printf( "%8.8x-%4.4x-%4.4x-%2.2x%2.2x-"
                            "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                            g.Data1,g.Data2,g.Data3,g.Data4[0],
                            g.Data4[1],g.Data4[2],g.Data4[3],g.Data4[4],
                            g.Data4[5],g.Data4[6],g.Data4[7] );
                }
                if ( DBKIND_GUID_PROPID == kind ||
                     DBKIND_PROPID      == kind )
                    printf( " %d", pNode->value.pdbidValue->uName.ulPropid );
                if ( DBKIND_GUID_NAME == kind ||
                     DBKIND_NAME      == kind )
                    printf( " '%ws'", pNode->value.pdbidValue->uName.pwszName );
            }
            break;
        }
        case DBVALUEKIND_CONTENT :
        {
            printf( "DBVALUEKIND_CONTENT: " );
            if ( 0 == pNode->value.pdbcntntValue )
                printf( "NULL" );
            else
                printf( "'%ws', method %d, weight %d, lcid %#x",
                        pNode->value.pdbcntntValue->pwszPhrase,
                        pNode->value.pdbcntntValue->dwGenerateMethod,
                        pNode->value.pdbcntntValue->lWeight,
                        pNode->value.pdbcntntValue->lcid );
            break;
        }
        case DBVALUEKIND_CONTENTVECTOR :
        {
            printf( "DBVALUEKIND_CONTENTVECTOR: " );
            DBCONTENTVECTOR *p = pNode->value.pdbcntntvcValue;
            if ( 0 == p )
                printf( "NULL" );
            else
            {
                printf( "method %d, weight %d ",
                         p->dwRankingMethod,
                         p->lWeight );
            }
            break;
        }
        case DBVALUEKIND_GROUPINFO :
        {
            printf( "DBVALUEKIND_GROUPINFO " );
            break;
        }
        case DBVALUEKIND_PARAMETER :
        {
            printf( "DBVALUEKIND_PARAMETER " );
            break;
        }
        case DBVALUEKIND_PROPERTY :
        {
            printf( "DBVALUEKIND_PROPERTY " );
            break;
        }
        case DBVALUEKIND_SETFUNC :
        {
            printf( "DBVALUEKIND_SETFUNC " );
            break;
        }
        case DBVALUEKIND_SORTINFO :
        {
            printf( "DBVALUEKIND_SORTINFO: " );
            if ( 0 == pNode->value.pdbsrtinfValue )
                printf( "NULL" );
            else
                printf( "fDesc %d, lcid %#x",
                        pNode->value.pdbsrtinfValue->fDesc,
                        pNode->value.pdbsrtinfValue->lcid );
            break;
        }
        case DBVALUEKIND_TEXT :
        {
            printf( "DBVALUEKIND_TEXT " );
            break;
        }
        case DBVALUEKIND_COMMAND :
        {
            printf( "DBVALUEKIND_COMMAND " );
            break;
        }
        case DBVALUEKIND_MONIKER :
        {
            printf( "DBVALUEKIND_MONIKER " );
            break;
        }
        case DBVALUEKIND_ROWSET :
        {
            printf( "DBVALUEKIND_ROWSET " );
            break;
        }
        case DBVALUEKIND_LIKE :
        {
            printf( "DBVALUEKIND_LIKE " );
            break;
        }
        case DBVALUEKIND_CONTENTPROXIMITY :
        {
            printf( "DBVALUEKIND_CONTENTPROXIMITY " );
            break;
        }
        case DBVALUEKIND_CONTENTSCOPE :
        {
            printf( "DBVALUEKIND_CONTENTSCOPE " );
            if ( 0 == pNode->value.pdbcntntscpValue )
                printf( "NULL" );
            else
                printf( "dwFlags %#x, pwszElementValue %ws",
                        pNode->value.pdbcntntscpValue->dwFlags,
                        pNode->value.pdbcntntscpValue->pwszElementValue );
            break;
        }
        case DBVALUEKIND_CONTENTTABLE :
        {
            printf( "DBVALUEKIND_CONTENTTABLE " );
            if ( 0 == pNode->value.pdbcntnttblValue )
                printf( "NULL" );
            else
                printf( "machine %ws, catalog %ws",
                        pNode->value.pdbcntnttblValue->pwszMachine,
                        pNode->value.pdbcntnttblValue->pwszCatalog );
            break;
        }
        case DBVALUEKIND_IDISPATCH :
        {
            printf( "DBVALUEKIND_IDISPATCH " );
            break;
        }
        case DBVALUEKIND_IUNKNOWN :
        {
            printf( "DBVALUEKIND_IUNKNOWN " );
            break;
        }
        case DBVALUEKIND_EMPTY :
        {
            printf( "DBVALUEKIND_EMPTY " );
            break;
        }
        case DBVALUEKIND_NULL :
        {
            printf( "DBVALUEKIND_NULL " );
            break;
        }
        case DBVALUEKIND_I2 :
        {
            printf( "DBVALUEKIND_I2: %d", pNode->value.sValue );
            break;
        }
        case DBVALUEKIND_I4 :
        {
            printf( "DBVALUEKIND_I4: %d", pNode->value.lValue );
            break;
        }
        case DBVALUEKIND_R4 :
        {
            printf( "DBVALUEKIND_R4: %f", pNode->value.flValue );
            break;
        }
        case DBVALUEKIND_R8 :
        {
            printf( "DBVALUEKIND_R8: %lf", pNode->value.dblValue );
            break;
        }
        case DBVALUEKIND_CY :
        {
            printf( "DBVALUEKIND_CY " );
            break;
        }
        case DBVALUEKIND_DATE :
        {
            printf( "DBVALUEKIND_DATE " );
            break;
        }
        case DBVALUEKIND_BSTR :
        {
            printf( "DBVALUEKIND_BSTR: '%ws'", pNode->value.pbstrValue );
            break;
        }
        case DBVALUEKIND_ERROR :
        {
            printf( "DBVALUEKIND_ERROR: %d", pNode->value.scodeValue );
            break;
        }
        case DBVALUEKIND_BOOL :
        {
            printf( "DBVALUEKIND_BOOL: %d", pNode->value.fValue );
            break;
        }
        case DBVALUEKIND_VARIANT :
        {
            printf( "DBVALUEKIND_VARIANT " );

            // Indexing Service uses PROPVARIANTs (extended VARIANTs)

            DisplayVariant( (PROPVARIANT *) pNode->value.pvarValue );
            break;
        }
        case DBVALUEKIND_I1 :
        {
            printf( "DBVALUEKIND_I1: %d", pNode->value.schValue );
            break;
        }
        case DBVALUEKIND_UI1 :
        {
            printf( "DBVALUEKIND_UI1: %u", pNode->value.uchValue );
            break;
        }
        case DBVALUEKIND_UI2 :
        {
            printf( "DBVALUEKIND_UI2: %u", pNode->value.usValue );
            break;
        }
        case DBVALUEKIND_UI4 :
        {
            printf( "DBVALUEKIND_UI4: %u", pNode->value.ulValue );
            break;
        }
        case DBVALUEKIND_I8 :
        {
            printf( "DBVALUEKIND_I8: %I64d", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_UI8 :
        {
            printf( "DBVALUEKIND_UI8: %I64u", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_GUID :
        {
            printf( "DBVALUEKIND_GUID " );
            break;
        }
        case DBVALUEKIND_BYTES :
        {
            printf( "DBVALUEKIND_BYTES " );
            break;
        }
        case DBVALUEKIND_STR :
        {
            printf( "DBVALUEKIND_STR: '%s'", pNode->value.pzValue );
            break;
        }
        case DBVALUEKIND_WSTR :
        {
            printf( "DBVALUEKIND_WSTR: '%ws'", pNode->value.pwszValue );
            break;
        }
        case DBVALUEKIND_NUMERIC :
        {
            printf( "DBVALUEKIND_NUMERIC " );
            break;
        }
        case DBVALUEKIND_DBDATE :
        {
            printf( "DBVALUEKIND_DBDATE " );
            break;
        }
        case DBVALUEKIND_DBTIME :
        {
            printf( "DBVALUEKIND_DBTIME " );
            break;
        }
        case DBVALUEKIND_DBTIMESTAMP :
        {
            printf( "DBVALUEKIND_DBTIMESTAMP " );
            break;
        }
        default :
        {
            printf( "unknown DBVALUEKIND " );
            break;
        }
    }

    printf( "\n" );

    if ( pNode->pctFirstChild )
    {
        PrintSpace( iLevel );
        printf( "first child:\n" );
        DisplayCommandTree( pNode->pctFirstChild, iLevel + 1 );
    }

    if ( pNode->pctNextSibling )
    {
        PrintSpace( iLevel );
        printf( "next sibling:\n" );
        DisplayCommandTree( pNode->pctNextSibling, iLevel + 1 );
    }

    if ( 0 == iLevel )
        printf( "\n" );
} //DisplayCommandTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\smpfilt\smpfilt.cxx ===
//+-------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       smpfilt.cxx
//
//  Contents:   Sample filter Implementation for Indexing Service
//
//  Summary:    The sample filter reads unformated text files (with the
//              extension .smp) using the current thread's ANSI code page
//              and outputs UNICODE text for the current locale.
//
//              It accepts as input only single-byte-character text files,
//              and not multibyte-character or UNICODE text files.
//
//  Platform:   Windows 2000
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Include file    Purpose
//
//  windows.h       Win32 declarations
//  filter.h        IFilter interface declarations
//  filterr.h       FACILITY_ITF error definitions for IFilter
//  ntquery.h       Indexing Service declarations
//  filtreg.hxx     DLL registration and unregistration macros
//  smpfilt.hxx     Sample filter declarations
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <filter.h>
#include <filterr.h>
#include <ntquery.h>
#include "filtreg.hxx"
#include "smpfilt.hxx"

//F-------------------------------------------------------------------------
//
//  Function:   GetDefaultCodepage
//
//  Summary:    Returns the codepage associated with the current default
//              locale, or CP_ACP if one can't be found.
//
//  Returns:    Codepage
//
//--------------------------------------------------------------------------

ULONG GetDefaultCodepage()
{
    ULONG codepage;

    int cwc = GetLocaleInfo( GetSystemDefaultLCID(),
                             LOCALE_RETURN_NUMBER |
                                 LOCALE_IDEFAULTANSICODEPAGE,
                             (WCHAR *) &codepage,
                             sizeof ULONG / sizeof WCHAR );

    // If an error occurred, return the Ansi code page

    if ( 0 == cwc )
         return CP_ACP;

    return codepage;
}

//C-------------------------------------------------------------------------
//
//  Class:      CSmpFilter
//
//  Summary:    Implements sample filter class
//
//--------------------------------------------------------------------------

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::CSmpFilter
//
//  Summary:    Class constructor
//
//  Arguments:  void
//
//  Purpose:    Manages global instance count
//
//--------------------------------------------------------------------------

CSmpFilter::CSmpFilter() :
    m_hFile(INVALID_HANDLE_VALUE),
    m_lRefs(1),
    m_pwszFileName(0),
    m_ulBufferLen(0),
    m_ulCharsRead(0),
    m_ulChunkID(1),
    m_fContents(FALSE),
    m_fEof(FALSE),
    m_ulCodePage( GetDefaultCodepage() )
{
    InterlockedIncrement( &g_lInstances );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::~CSmpFilter
//
//  Summary:    Class destructor
//
//  Arguments:  void
//
//  Purpose:    Manages global instance count and file handle
//
//--------------------------------------------------------------------------

CSmpFilter::~CSmpFilter()
{
    delete [] m_pwszFileName;
    if ( INVALID_HANDLE_VALUE != m_hFile )
        CloseHandle( m_hFile );

    InterlockedDecrement( &g_lInstances );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::QueryInterface      (IUnknown::QueryInterface)
//
//  Summary:    Queries for requested interface
//
//  Arguments:  riid
//                  [in] Reference IID of requested interface
//              ppvObject
//                  [out] Address that receives requested interface pointer
//
//  Returns:    S_OK
//                  Interface is supported
//              E_NOINTERFACE
//                  Interface is not supported
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::QueryInterface(
    REFIID riid,
    void  ** ppvObject
)
{
    IUnknown *pUnkTemp = 0;

    if ( IID_IFilter == riid )
        pUnkTemp = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersistFile == riid )
        pUnkTemp = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IPersist == riid )
        pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    *ppvObject = (void  *)pUnkTemp;
    pUnkTemp->AddRef();

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::AddRef              (IUnknown::AddRef)
//
//  Summary:    Increments interface refcount
//
//  Arguments:  void
//
//  Returns:    Value of incremented interface refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSmpFilter::AddRef()
{
    return InterlockedIncrement( &m_lRefs );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::Release             (IUnknown::Release)
//
//  Summary:    Decrements interface refcount, deleting if unreferenced
//
//  Arguments:  void
//
//  Returns:    Value of decremented interface refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSmpFilter::Release()
{
    ULONG ulTmp = InterlockedDecrement( &m_lRefs );

    if ( 0 == ulTmp )
        delete this;

    return ulTmp;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::Init                (IFilter::Init)
//
//  Summary:    Initializes sample filter instance
//
//  Arguments:  grfFlags
//                  [in] Flags for filter behavior
//              cAttributes
//                  [in] Number attributes in array aAttributes
//              aAttributes
//                  [in] Array of requested attribute strings
//              pFlags
//                  [out] Pointer to return flags for additional properties
//
//  Returns:    S_OK
//                  Initialization succeeded
//              E_FAIL
//                  File not previously loaded
//              E_INVALIDARG
//                  Count and contents of attributes do not agree
//              FILTER_E_ACCESS
//                  Unable to access file to be filtered
//              FILTER_E_PASSWORD
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::Init(
    ULONG grfFlags,
    ULONG cAttributes,
    FULLPROPSPEC const * aAttributes,
    ULONG * pFlags
)
{
    // Ignore flags for text canonicalization (text is unformatted)
    // Check for proper attributes request and recognize only "contents"

    if( 0 < cAttributes )
    {
        ULONG ulNumAttr;

        if ( 0 == aAttributes )
            return E_INVALIDARG;

        for ( ulNumAttr = 0 ; ulNumAttr < cAttributes; ulNumAttr++ )
        {
            if ( guidStorage == aAttributes[ulNumAttr].guidPropSet &&
                PID_STG_CONTENTS == aAttributes[ulNumAttr].psProperty.propid )
                break;
        }

        if ( ulNumAttr < cAttributes )
            m_fContents = TRUE;
        else
            m_fContents = FALSE;
    }
    else if ( 0 == grfFlags ||
              (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
        m_fContents = TRUE;
    else
        m_fContents = FALSE;

    m_fEof = FALSE;

    // Open the file previously specified in call to IPersistFile::Load

    if ( 0 != m_pwszFileName )
    {
        if ( INVALID_HANDLE_VALUE != m_hFile )
        {
            CloseHandle( m_hFile );
            m_hFile = INVALID_HANDLE_VALUE;
        }

        m_hFile = CreateFile(
                      m_pwszFileName,
                      GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_DELETE,
                      0,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      0
                  );

        if ( INVALID_HANDLE_VALUE == m_hFile )
            return FILTER_E_ACCESS;
    }
    else
        return E_FAIL;

    // Enumerate OLE properties, since any NTFS file can have them

    *pFlags = IFILTER_FLAGS_OLE_PROPERTIES;

    // Re-initialize

    m_ulChunkID = 1;
    m_ulCharsRead = 0;

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::GetChunk            (IFilter::GetChunk)
//
//  Summary:    Gets the next chunk (text only)
//
//  Note:       GetChunk accepts as input only single-byte-character text
//              files, and not multibyte-character or UNICODE text files.
//
//  Arguments:  ppStat
//                  [out] Pointer to description of current chunk
//  Returns:    S_OK
//                  Chunk was successfully retrieved
//              E_FAIL
//                  Character conversion failed
//              FILTER_E_ACCESS
//                  General access failure occurred
//              FILTER_E_END_OF_CHUNKS
//                  Previous chunk was the last chunk
//              FILTER_E_EMBEDDING_UNAVAILABLE
//                  (not implemented)
//              FILTER_E_LINK_UNAVAILABLE
//                  (not implemented)
//              FILTER_E_PASSWORD
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::GetChunk(
    STAT_CHUNK * pStat
)
{
    if ( INVALID_HANDLE_VALUE == m_hFile )
        return FILTER_E_ACCESS;

    // Read characters from single-byte file
    
    char cszBuffer[TEXT_FILTER_CHUNK_SIZE];

    if ( !ReadFile(
              m_hFile,
              cszBuffer,
              TEXT_FILTER_CHUNK_SIZE,
              &m_ulBufferLen,
              NULL
          ) )
        return FILTER_E_ACCESS;
    else if( 0 == m_ulBufferLen )
        m_fEof = TRUE;

    if ( !m_fContents || m_fEof )
        return FILTER_E_END_OF_CHUNKS;

    // Convert single-byte characters to UNICODE
    //
    // This conversion assumes a one-to-one conversion:
    //     one input single-byte character to
    //     one output multibyte (UNICODE) character
    //
    // This is typically not the general case with multibyte
    // characters, and a general case needs to handle the possible
    // difference of pre- and post-conversion buffer lengths

    if ( !MultiByteToWideChar(
              m_ulCodePage,
              MB_COMPOSITE,
              cszBuffer,
              m_ulBufferLen,
              m_wcsBuffer,
              TEXT_FILTER_CHUNK_SIZE
          ) )
        return E_FAIL;

    // Set chunk description
    
    pStat->idChunk   = m_ulChunkID;
    pStat->breakType = CHUNK_NO_BREAK;
    pStat->flags     = CHUNK_TEXT;
    pStat->locale    = GetSystemDefaultLCID();
    pStat->attribute.guidPropSet       = guidStorage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->idChunkSource  = m_ulChunkID;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource   = 0;

    m_ulCharsRead = 0;
    m_ulChunkID++;

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::GetText             (IFilter::GetText)
//
//  Summary:    Retrieves UNICODE text for index
//
//  Arguments:  pcwcBuffer
//                  [in] Pointer to size of UNICODE buffer
//                  [out] Pointer to count of UNICODE characters returned
//              awcBuffer
//                  [out] Pointer to buffer to receive UNICODE text
//
//  Returns:    S_OK
//                  Text successfully retrieved, but text remains in chunk
//              FILTER_E_NO_MORE_TEXT
//                  All of the text in the current chunk has been returned
//              FILTER_S_LAST_TEXT
//                  Next call to GetText will return FILTER_E_NO_MORE_TEXT
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::GetText(
    ULONG * pcwcBuffer,
    WCHAR * awcBuffer
)
{
    if ( !m_fContents || 0 == m_ulBufferLen )
    {
        *pcwcBuffer = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    // Copy characters in chunk buffer to output UNICODE buffer
    //
    // This copy assumes a one-to-one conversion in GetChunk
    // of input single-byte characters (each 1 byte long)
    // to output UNICODE characters (each 2 bytes long)

    ULONG ulToCopy = min( *pcwcBuffer, m_ulBufferLen - m_ulCharsRead );

    memcpy( awcBuffer, m_wcsBuffer + m_ulCharsRead, 2*ulToCopy );
    m_ulCharsRead += ulToCopy;
    *pcwcBuffer = ulToCopy;

    if ( m_ulBufferLen == m_ulCharsRead )
    {
        m_ulCharsRead = 0;
        m_ulBufferLen = 0;
        return FILTER_S_LAST_TEXT;
    }

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::GetValue            (IFilter::GetValue)
//
//  Summary:    Retrieves properites for index
//
//  Arguments:  ppPropValue
//                  [out] Address that receives pointer to property value
//
//  Returns:    FILTER_E_NO_VALUES
//                  Always
//              FILTER_E_NO_MORE_VALUES
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::GetValue(
    PROPVARIANT ** ppPropValue
)
{
    // Sample filter does not retieve any properties

    return FILTER_E_NO_VALUES;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::BindRegion          (IFilter::BindRegion)
//
//  Summary:    Creates moniker or other interface for indicated text
//
//  Arguments:  origPos
//                  [in] Description of text location and extent
//              riid
//                  [in] Reference IID of specified interface
//              ppunk
//                  [out] Address that receives requested interface pointer
//
//  Returns:    E_NOTIMPL
//                  Always
//              FILTER_W_REGION_CLIPPED
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::BindRegion(
    FILTERREGION origPos,
    REFIID riid,
    void ** ppunk
)
{
    // BindRegion is currently reserved for future use

    return E_NOTIMPL;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::GetClassID          (IPersist::GetClassID)
//
//  Summary:    Retrieves the class id of the filter class
//
//  Arguments:  pClassID
//                  [out] Pointer to the class ID of the filter
//
//  Returns:    S_OK
//                  Always
//              E_FAIL
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::GetClassID(
    CLSID * pClassID
)
{
    *pClassID = CLSID_CSmpFilter;
    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::IsDirty             (IPersistFile::IsDirty)
//
//  Summary:    Checks whether file has changed since last save
//
//  Arguments:  void
//
//  Returns:    S_FALSE
//                  Always
//              S_OK
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::IsDirty()
{
    // File is opened read-only and never changes

    return S_FALSE;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::Load                (IPersistFile::Load)
//
//  Summary:    Opens and initializes the specified file
//
//  Arguments:  pszFileName
//                  [in] Pointer to zero-terminated string
//                       of absolute path of file to open
//              dwMode
//                  [in] Access mode to open the file
//
//  Returns:    S_OK
//                  File was successfully loaded
//              E_OUTOFMEMORY
//                  File could not be loaded due to insufficient memory
//              E_FAIL
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::Load(
    LPCWSTR pszFileName,
    DWORD dwMode
)
{
    // Load just sets the filename for GetChunk to read and ignores the mode

    ULONG ulChars = wcslen( pszFileName ) + 1;
    delete [] m_pwszFileName;

    m_pwszFileName = new WCHAR [ulChars];

    if ( 0 != m_pwszFileName )
        wcscpy( m_pwszFileName, pszFileName );
    else
        return E_OUTOFMEMORY;

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::Save                (IPersistFile::Save)
//
//  Summary:    Saves a copy of the current file being filtered
//
//  Arguments:  pszFileName
//                  [in] Pointer to zero-terminated string of
//                       absolute path of where to save file
//              fRemember
//                  [in] Whether the saved copy is made the current file
//
//  Returns:    E_FAIL
//                  Always
//              S_OK
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::Save(
    LPCWSTR pszFileName,
    BOOL fRemember
)
{
    // File is opened read-only; saving it is an error

    return E_FAIL;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::SaveCompleted      (IPersistFile::SaveCompleted)
//
//  Summary:    Determines whether a file save is completed
//
//  Arguments:  pszFileName
//                  [in] Pointer to zero-terminated string of
//                       absolute path where file was previously saved
//
//  Returns:    S_OK
//                  Always
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::SaveCompleted(
    LPCWSTR pszFileName
)
{
    // File is opened read-only, so "save" is always finished

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilter::GetCurFile          (IPersistFile::GetCurFile)
//
//  Summary:    Returns a copy of the current file name
//
//  Arguments:  ppszFileName
//                  [out] Address to receive pointer to zero-terminated
//                        string for absolute path to current file
//
//  Returns:    S_OK
//                  A valid absolute path was successfully returned
//              S_FALSE
//                  (not implemented)
//              E_OUTOFMEMORY
//                  Operation failed due to insufficient memory
//              E_FAIL
//                  Operation failed due to some reason
//                  other than insufficient memory
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilter::GetCurFile(
    LPWSTR * ppszFileName
)
{
    if ( 0 == m_pwszFileName )
        return E_FAIL;

    ULONG ulChars = wcslen( m_pwszFileName ) + 1;
    *ppszFileName = (WCHAR *)CoTaskMemAlloc( ulChars * sizeof WCHAR );

    if ( 0 != *ppszFileName )
        wcscpy( *ppszFileName, m_pwszFileName );
    else
        return E_OUTOFMEMORY;

    return S_OK;
}

//C-------------------------------------------------------------------------
//
//  Class:      CSmpFilterCF
//
//  Summary:    Implements class factory for sample filter
//
//--------------------------------------------------------------------------

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::CSmpFilterCF
//
//  Summary:    Class factory constructor
//
//  Arguments:  void
//
//  Purpose:    Manages global instance count
//
//--------------------------------------------------------------------------

CSmpFilterCF::CSmpFilterCF() :
    m_lRefs(1)
{
    InterlockedIncrement( &g_lInstances );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::~CSmpFilterCF
//
//  Summary:    Class factory destructor
//
//  Arguments:  void
//
//  Purpose:    Manages global instance count
//
//--------------------------------------------------------------------------

CSmpFilterCF::~CSmpFilterCF()
{
   InterlockedDecrement( &g_lInstances );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::QueryInterface    (IUnknown::QueryInterface)
//
//  Summary:    Queries for requested interface
//
//  Arguments:  riid
//                  [in] Reference IID of requested interface
//              ppvObject
//                  [out] Address that receives requested interface pointer
//
//  Returns:    S_OK
//                  Interface is supported
//              E_NOINTERFACE
//                  Interface is not supported
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilterCF::QueryInterface(
    REFIID riid,
    void  ** ppvObject
)
{
    IUnknown *pUnkTemp;

    if ( IID_IClassFactory == riid )
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        pUnkTemp = (IUnknown *)this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    *ppvObject = (void  *)pUnkTemp;
    pUnkTemp->AddRef();

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::AddRef            (IUknown::AddRef)
//
//  Summary:    Increments interface refcount
//
//  Arguments:  void
//
//  Returns:    Value of incremented interface refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSmpFilterCF::AddRef()
{
   return InterlockedIncrement( &m_lRefs );
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::Release           (IUnknown::Release)
//
//  Summary:    Decrements interface refcount, deleting if unreferenced
//
//  Arguments:  void
//
//  Returns:    Value of decremented refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSmpFilterCF::Release()
{
    ULONG ulTmp = InterlockedDecrement( &m_lRefs );

    if ( 0 == ulTmp )
        delete this;

    return ulTmp;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::CreateInstance (IClassFactory::CreateInstance)
//
//  Summary:    Creates new sample filter object
//
//  Arguments:  pUnkOuter
//                  [in] Pointer to IUnknown interface of aggregating object
//              riid
//                  [in] Reference IID of requested interface
//              ppvObject
//                  [out] Address that receives requested interface pointer
//
//  Returns:    S_OK
//                  Sample filter object was successfully created
//              CLASS_E_NOAGGREGATION
//                  pUnkOuter parameter was non-NULL
//              E_NOINTERFACE
//                  (not implemented)
//              E_OUTOFMEMORY
//                  Sample filter object could not be created
//                  due to insufficient memory
//              E_UNEXPECTED
//                  Unsuccessful due to an unexpected condition
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilterCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject
)
{
    CSmpFilter *pIUnk = 0;

    if ( 0 != pUnkOuter )
        return CLASS_E_NOAGGREGATION;

    pIUnk = new CSmpFilter();

    if ( 0 != pIUnk )
    {
        if ( SUCCEEDED( pIUnk->QueryInterface( riid , ppvObject ) ) )
        {
            // Release extra refcount from QueryInterface

            pIUnk->Release();
        }
        else
        {
            delete pIUnk;
            return E_UNEXPECTED;
        }
    }
    else
        return E_OUTOFMEMORY;

    return S_OK;
}

//M-------------------------------------------------------------------------
//
//  Method:     CSmpFilterCF::LockServer        (IClassFactory::LockServer)
//
//  Summary:    Forces/allows filter class to remain loaded/be unloaded
//
//  Arguments:  fLock
//                  [in] TRUE to lock, FALSE to unlock
//
//  Returns:    S_OK
//                  Always
//              E_FAIL
//                  (not implemented)
//              E_OUTOFMEMORY
//                  (not implemented)
//              E_UNEXPECTED
//                  (not implemented)
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSmpFilterCF::LockServer(
    BOOL fLock
)
{
    if( fLock )
        InterlockedIncrement( &g_lInstances );
    else
        InterlockedDecrement( &g_lInstances );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  DLL:        SmpFilt.dll
//
//  Summary:    Implements Dynamic Link Library functions for sample filter
//
//--------------------------------------------------------------------------

//F-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Summary:    Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  hInstance
//                  [in] Handle to the DLL
//              fdwReason
//                  [in] Reason for calling DLL entry point
//              lpReserved
//                  [in] Details of DLL initialization and cleanup
//
//  Returns:    TRUE
//                  Always
//
//--------------------------------------------------------------------------

extern "C" BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    DWORD     fdwReason,
    LPVOID    lpvReserved
)
{
   if ( DLL_PROCESS_ATTACH == fdwReason )
        DisableThreadLibraryCalls( hInstance );

    return TRUE;
}

//F-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Summary:    Create sample filter class factory object
//
//  Arguments:  cid
//                  [in] Class ID of class that class factory creates
//              iid
//                  [in] Reference IID of requested class factory interface
//              ppvObj
//                  [out] Address that receives requested interface pointer
//
//  Returns:    S_OK
//                  Class factory object was created successfully 
//              CLASS_E_CLASSNOTAVAILABLE
//                  DLL does not support the requested class 
//              E_INVALIDARG
//                  (not implemented)
//              E_OUTOFMEMORY
//                  Insufficient memory to create the class factory object
//              E_UNEXPECTED
//                  Unsuccessful due to an unexpected condition
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj
)
{
    IUnknown *pResult = 0;

    if ( CLSID_CSmpFilter == cid )
        pResult = (IUnknown *) new CSmpFilterCF;
    else
        return CLASS_E_CLASSNOTAVAILABLE;

    if ( 0 != pResult )
    {
        if( SUCCEEDED( pResult->QueryInterface( iid, ppvObj ) ) )
            // Release extra refcount from QueryInterface
            pResult->Release();
        else
        {
            delete pResult;
            return E_UNEXPECTED;
        }
    }
    else
        return E_OUTOFMEMORY;

    return S_OK;
}

//F-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Summary:    Indicates whether it is possible to unload DLL
//
//  Arguments:  void
//
//  Returns:    S_OK
//                  DLL can be unloaded now
//              S_FALSE
//                  DLL must remain loaded 
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow(
    void
)
{
    if ( 0 >= g_lInstances )
        return S_OK;
    else
        return S_FALSE;
}

//F-------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//              DllUnregisterServer
//
//  Summary:    Registers and unregisters DLL server
//
//              The registration procedure uses a set of macros
//              developed for use within the Indexing Service code.
//              The macros are in the included filtreg.hxx.
//
//  Returns:    DllRegisterServer
//                  S_OK
//                      Registration was successful
//                  SELFREG_E_CLASS
//                      Registration was unsuccessful
//                  SELFREG_E_TYPELIB
//                      (not implemented)
//                  E_OUTOFMEMORY
//                      (not implemented)
//                  E_UNEXPECTED
//                      (not implemented)
//              DllUnregisterServer
//                  S_OK
//                      Unregistration was successful
//                  S_FALSE
//                      Unregistration was successful, but other
//                      entries still exist for the DLL's classes
//                  SELFREG_E_CLASS
//                      (not implemented)
//                  SELFREG_E_TYPELIB
//                      (not implemented)
//                  E_OUTOFMEMORY
//                      (not implemented)
//                  E_UNEXPECTED
//                      (not implemented)
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  These structures define the registry keys for the registration process.
//
//--------------------------------------------------------------------------

SClassEntry const asmpClasses[] =
{
    { L".smp",
      L"SmpFilt.Document",
      L"Sample Filter Document",
      L"{8B0E5E72-3C30-11d1-8C0D-00AA00C26CD4}",
      L"Sample Filter Document"
    }
};

SHandlerEntry const smpHandler =
{
    L"{8B0E5E73-3C30-11d1-8C0D-00AA00C26CD4}",
    L"SmpFilt Persistent Handler",
    L"{8B0E5E70-3C30-11d1-8C0D-00AA00C26CD4}"
};

SFilterEntry const smpFilter =
{
    L"{8B0E5E70-3C30-11d1-8C0D-00AA00C26CD4}",
    L"Sample Filter",
    L"smpfilt.dll",
    L"Both"
};

//+-------------------------------------------------------------------------
//
//  This macro defines the registration/unregistration routines for the DLL.
//
//--------------------------------------------------------------------------

DEFINE_DLLREGISTERFILTER( smpHandler, smpFilter, asmpClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\qsample\qsample.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 2001.  All Rights Reserved.
//
// PROGRAM:  qsample.cxx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//           Uses CIMakeICommand and CITextToFullTree helper functions.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE
#define DBINITCONSTANTS

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <ntquery.h>

#include "qsample.hxx"

// This is found in disptree.cxx

extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 );

//+---------------------------------------------------------------------------
//
//  Class:      XBStr
//
//  Purpose:    Smart BSTR class
//
//----------------------------------------------------------------------------

class XBStr
{
public:
    XBStr(BSTR p = 0) : _p( p ) {}
    XBStr ( XBStr & x ): _p( x.Acquire() ) {}
    ~XBStr() { SysFreeString( _p ); }
    BOOL IsNull() const { return ( 0 == _p ); }
    void Set ( BSTR pOleStr ) { _p = pOleStr; }
    BSTR Acquire()
    {
        BSTR pTemp = _p;
        _p = 0;
        return pTemp;
    }
    BSTR GetPointer() const { return _p; }
    void Free() { SysFreeString( Acquire() ); }
private:
    BSTR _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XPtr
//
//  Synopsis:   Template for managing ownership of memory
//
//--------------------------------------------------------------------------

template<class T> class XPtr
{
public:
    XPtr( unsigned c ) : _p(0) { if ( 0 != c ) _p = new T [ c ]; }
    ~XPtr() { Free(); }
    void SetSize( unsigned c ) { Free(); _p = new T [ c ]; }
    void Set ( T * p ) { _p = p; }
    T * Get() const { return _p ; }
    void Free() { delete [] Acquire(); }
    T & operator[]( unsigned i ) { return _p[i]; }
    T const & operator[]( unsigned i ) const { return _p[i]; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() const { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   CResString
//
//  Synopsis:   Class for loading string resources
//
//--------------------------------------------------------------------------

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }
    CResString( UINT strIDS ) { Load( strIDS ); }
    WCHAR const * Get() const { return _awc; }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( 0, strIDS, _awc, sizeof _awc / sizeof WCHAR );
        return ( 0 != _awc[ 0 ] );
    }

private:
    WCHAR _awc[ 200 ];
};

//+-------------------------------------------------------------------------
//
//  Function:   FormatError
//
//  Synopsis:   Formats an error code into a string
//
//  Arguments:  [sc]   - An Indexing Service or Win32 HRESULT
//              [pwc]  - Where to write the error string
//              [cwc]  - Count of characters in pwc
//              [lcid] - Locale for the error string
//
//--------------------------------------------------------------------------

void FormatError(
    SCODE   sc,
    WCHAR * pwc,
    ULONG   cwc,
    LCID    lcid )
{
    // FormatMessage works best when based on thread locale.

    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( lcid );

    // Is this an Indexing Service error?  These errors are in query.dll.

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                          GetModuleHandle( L"query.dll" ),
                          sc,
                          0,
                          pwc,
                          cwc,
                          0 ) )
    {
        // Is this a Win32 error?  These are in kernel32.dll

        const ULONG facWin32 = ( FACILITY_WIN32 << 16 );
        ULONG Win32Error = sc;

        if ( (Win32Error & facWin32) == facWin32 )
            Win32Error &= ~( 0x80000000 | facWin32 );

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle( L"kernel32.dll" ),
                              Win32Error,
                              0,
                              pwc,
                              cwc,
                              0 ) )
        {
            // It's not from Indexing Service or Win32; display a default error

            CResString str( IDS_UNKNOWNERROR );
            wcscpy( pwc, str.Get() );
        }
    }

    // Restore the original thread locale

    SetThreadLocale( SaveLCID );
} //FormatError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Prints an error message from a string resource
//
//  Arguments:  [uiError]     - The error message resource id
//              [pwcArgument] - A string argument for the error message
//              [hr]          - The error code
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

void DisplayError(
    UINT          uiError,
    WCHAR const * pwcArgument,
    HRESULT       hr,
    LCID          lcid )
{
    WCHAR awcError[ 200 ];
    FormatError( hr, awcError, sizeof awcError / sizeof WCHAR, lcid );

    CResString str( uiError );
    wprintf( str.Get(), pwcArgument, hr, awcError );
} //DisplayError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayWin32Error
//
//  Synopsis:   Prints an error message taken from GetLastError()
//
//  Arguments:  [uiError]     - The string resource to use for the error
//              [pwcArgument] - A string argument for the error message
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

HRESULT DisplayWin32Error(
    UINT          uiError,
    WCHAR const * pwcArgument,
    LCID          lcid )
{
    HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
    DisplayError( uiError, pwcArgument, hr, lcid );
    return hr;
} //DisplayWin32Error

void DisplayStat( DWORD dw, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%8d %ws\n", dw, str.Get() );
} //DisplayStat

void DisplayStat( WCHAR const *pwcMsg, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws: %ws\n", str.Get(), pwcMsg );
} //DisplayStat

void DisplayStat( UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws\n", str.Get() );
} //DisplayStat

//+-------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Synopsis:   Finds the best matching codepage given a locale id.
//
//  Arguments:  [lcid]  - Locale to check
//
//  Returns:    The best matching codepage.
//
//--------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    ULONG codepage;

    int cwc = GetLocaleInfo( lcid,
                             LOCALE_RETURN_NUMBER |
                                 LOCALE_IDEFAULTANSICODEPAGE,
                             (WCHAR *) &codepage,
                             sizeof ULONG / sizeof WCHAR );

    // If an error occurred, return the Ansi code page

    if ( 0 == cwc )
         return CP_ACP;

    return codepage;
} //LocaleToCodepage

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.  This is set optionally.
//
//              Both of these properties are unique to Indexing Service's
//              OLE DB implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties(
    ICommand * pICommand,
    BOOL       fForceUseContentIndex )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

    DBPROP aProp[2];

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;

    DBPROPSET aPropSet[1];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = fForceUseContentIndex ? 2 : 1;
    aPropSet[0].guidPropertySet = guidQueryExt;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    return xICommandProperties->SetProperties( 1,          // 1 property set
                                               aPropSet ); // the properties
} //SetCommandProperties

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( vt - VT_ARRAY, *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: wprintf( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: wprintf( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: wprintf( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: wprintf( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: wprintf( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: wprintf( L"%d", *(LONG *)pv ); break;
        case VT_UI8: wprintf( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: wprintf( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: wprintf( L"%f", *(float *)pv ); break;
        case VT_R8: wprintf( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( * (CY *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_BOOL: wprintf( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: wprintf( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            VariantTimeToSystemTime( *(DATE *)pv, &st );
            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            wprintf( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        wprintf( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            wprintf( L"," );

        // Get the element and render it

        void *pv;
        SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            wprintf( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            wprintf( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        wprintf( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : break;
        case VT_NULL : break;
        case VT_I4 : wprintf( L"%10d", v.lVal ); break;
        case VT_UI1 : wprintf( L"%10d", v.bVal ); break;
        case VT_I2 : wprintf( L"%10d", v.iVal ); break;
        case VT_R4 : wprintf( L"%10f", v.fltVal ); break;
        case VT_R8 : wprintf( L"%10lf", v.dblVal ); break;
        case VT_BOOL : wprintf( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : wprintf( L"%10d", v.cVal ); break;
        case VT_UI2 : wprintf( L"%10u", v.uiVal ); break;
        case VT_UI4 : wprintf( L"%10u", v.ulVal ); break;
        case VT_INT : wprintf( L"%10d", v.lVal ); break;
        case VT_UINT : wprintf( L"%10u", v.ulVal ); break;
        case VT_I8 : wprintf( L"%20I64d", v.hVal ); break;
        case VT_UI8 : wprintf( L"%20I64u", v.hVal ); break;
        case VT_ERROR : wprintf( L"%#x", v.scode ); break;
        case VT_LPSTR : wprintf( L"%s", v.pszVal ); break;
        case VT_LPWSTR : wprintf( L"%ws", v.pwszVal ); break;
        case VT_BSTR : wprintf( L"%ws", v.bstrVal ); break;
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( v.cyVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;

            if ( VT_DATE == v.vt )
            {
                VariantTimeToSystemTime( v.date, &st );
            }
            else
            {
                FILETIME ft;
                FileTimeToLocalFileTime( &v.filetime, &ft );
                FileTimeToSystemTime( &ft, &st );
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, "%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, "%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%s" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" ); break;
        default : 
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( v.vt - VT_ARRAY, v.parray );
            else
                wprintf( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from the OLE DB error object.
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller
//                               should release this.
//
//  Returns:    HRESULT for whether the error info was retrieved
//
//-----------------------------------------------------------------------------

HRESULT GetOleDBErrorInfo(
    IUnknown *    pErrSrc,
    REFIID        riid,
    LCID          lcid,
    ERRORINFO *   pErrorInfo,
    IErrorInfo ** ppIErrorInfo )
{
    *ppIErrorInfo = 0;

    // See if an error is available that is of interest to us.

    XInterface<ISupportErrorInfo> xSupportErrorInfo;
    HRESULT hr = pErrSrc->QueryInterface( IID_ISupportErrorInfo,
                                          xSupportErrorInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xSupportErrorInfo->InterfaceSupportsErrorInfo( riid );
    if ( FAILED( hr ) )
        return hr;

    // Get the current error object. Return if none exists.

    XInterface<IErrorInfo> xErrorInfo;
    hr = GetErrorInfo( 0, xErrorInfo.GetPPointer() );
    if ( xErrorInfo.IsNull() )
        return hr;

    // Get the IErrorRecord interface and get the count of errors.

    XInterface<IErrorRecords> xErrorRecords;
    hr = xErrorInfo->QueryInterface( IID_IErrorRecords,
                                     xErrorRecords.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG cErrRecords;
    hr = xErrorRecords->GetRecordCount( &cErrRecords );
    if ( 0 == cErrRecords )
        return hr;

#if 1 // A good way to get the complete error message...

    XInterface<IErrorInfo> xErrorInfoRec;
    ERRORINFO ErrorInfo;
    for ( unsigned i=0; i<cErrRecords; i++ )
    {
        // Get basic error information.

        xErrorRecords->GetBasicErrorInfo( i, &ErrorInfo );

        // Get error description and source through the IErrorInfo interface
        // pointer on a particular record.

        xErrorRecords->GetErrorInfo( i, lcid, xErrorInfoRec.GetPPointer() );

        XBStr bstrDescriptionOfError;
        XBStr bstrSourceOfError;

        BSTR bstrDesc = bstrDescriptionOfError.GetPointer();
        BSTR bstrSrc = bstrSourceOfError.GetPointer();

        xErrorInfoRec->GetDescription( &bstrDesc ); 
        xErrorInfoRec->GetSource( &bstrSrc );

        // At this point, you could call GetCustomErrorObject and query for
        // additional interfaces to determine what else happened.

        wprintf( L"%s (%#x)\n%s\n", bstrDesc, ErrorInfo.hrError, bstrSrc );    
    }
#endif

    // Get basic error information for the most recent error

    ULONG iRecord = cErrRecords - 1;
    hr = xErrorRecords->GetBasicErrorInfo( iRecord, pErrorInfo );
    if ( FAILED( hr ) )
        return hr;

    return xErrorRecords->GetErrorInfo( iRecord, lcid, ppIErrorInfo );
} //GetOleDBErrorInfo

//-----------------------------------------------------------------------------
//
//  Function:   DisplayRowsetStatus
//
//  Synopsis:   Retrieves status information about the rowset and catalog.
//
//  Arguments:  [xIRowset] - Rowset about which information is retrieved.
//
//  Returns:    HRESULT result of retrieving the status
//
//-----------------------------------------------------------------------------

HRESULT DisplayRowsetStatus( XInterface<IRowset> & xIRowset )
{
    XInterface<IRowsetInfo> xIRowsetInfo;
    HRESULT hr = xIRowset->QueryInterface( IID_IRowsetInfo,
                                           xIRowsetInfo.GetQIPointer() );

    if ( SUCCEEDED( hr ) )
    {
        // This rowset property is Indexing-Service specific

        DBPROPID propId = MSIDXSPROP_ROWSETQUERYSTATUS;
        DBPROPIDSET propSet;
        propSet.rgPropertyIDs = &propId;
        propSet.cPropertyIDs = 1;
        const GUID guidRowsetExt = DBPROPSET_MSIDXS_ROWSETEXT;
        propSet.guidPropertySet = guidRowsetExt;
    
        ULONG cPropertySets = 0;
        DBPROPSET * pPropertySets;
    
        hr = xIRowsetInfo->GetProperties( 1,
                                          &propSet,
                                          &cPropertySets,
                                          &pPropertySets );

        if ( SUCCEEDED( hr ) )
        {
            DWORD dwStatus = pPropertySets->rgProperties->vValue.ulVal;

            CoTaskMemFree( pPropertySets->rgProperties );
            CoTaskMemFree( pPropertySets );

            DWORD dwFill = QUERY_FILL_STATUS( dwStatus );

            if ( STAT_ERROR == dwFill )
                DisplayStat( IDS_ROWSET_STAT_ERROR );

            DWORD dwReliability = QUERY_RELIABILITY_STATUS( dwStatus );

            if ( 0 != ( STAT_PARTIAL_SCOPE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_PARTIAL_SCOPE );
            if ( 0 != ( STAT_NOISE_WORDS & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_NOISE_WORDS );
            if ( 0 != ( STAT_CONTENT_OUT_OF_DATE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_OUT_OF_DATE );
            if ( 0 != ( STAT_REFRESH_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_REFRESH_INCOMPLETE );
            if ( 0 != ( STAT_CONTENT_QUERY_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_QUERY_INCOMPLETE );
            if ( 0 != ( STAT_TIME_LIMIT_EXCEEDED & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_TIME_LIMIT_EXCEEDED );
            if ( 0 != ( STAT_SHARING_VIOLATION & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_SHARING_VIOLATION );
        }
    }

    return hr;
} //DisplayRowsetStatus

//+-------------------------------------------------------------------------
//
//  Function:   IssueQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [lcid]                  - Locale for the query
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT IssueQuery(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcQueryRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    LCID          lcid )
{
    // Create an ICommand object.  CIMakeICommand is a shortcut for making an
    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent.

    XInterface<ICommand> xICommand;
    HRESULT hr = CIMakeICommand( xICommand.GetPPointer(),  // result
                                 1,                        // 1 scope
                                 &dwScopeFlags,            // scope flags
                                 &pwcQueryScope,           // scope path
                                 &pwcQueryCatalog,         // catalog
                                 &pwcQueryMachine );       // machine
    if ( FAILED( hr ) )
        return hr;

    // Get a command tree object

    XInterface<ICommandTree> xICommandTree;
    hr = xICommand->QueryInterface( IID_ICommandTree,
                                    xICommandTree.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Create an OLE DB query tree based on query parameters.

    DBCOMMANDTREE * pTree;
    hr = CITextToFullTreeEx( pwcQueryRestriction, // the query itself
                             ulDialect,           // query dialect
                             pwcColumns,          // columns to return
                             pwcSort,             // sort order, may be 0
                             0,                   // reserved
                             &pTree,              // resulting tree
                             0,                   // no custom properties
                             0,                   // no custom properties
                             lcid );              // default locale
    if ( FAILED( hr ) )
        return hr;

    // Limit the maximum number of results if requested by putting a DBOP_top
    // node at the top of the query tree.

    if ( 0 != cMaxHits )
    {
        DBCOMMANDTREE * pTop = (DBCOMMANDTREE *) CoTaskMemAlloc( sizeof DBCOMMANDTREE );
        if ( 0 == pTop )
        {
            xICommandTree->FreeCommandTree( &pTree );
            return E_OUTOFMEMORY;
        }

        memset( pTop, 0, sizeof DBCOMMANDTREE );
        pTop->op = DBOP_top;
        pTop->wKind = DBVALUEKIND_UI4;
        pTop->value.ulValue = cMaxHits;
        pTop->pctFirstChild = pTree;
        pTree = pTop;
    }

    // If directed, display the command tree.

    if ( fDisplayTree )
    {
        wprintf( L"%ws\n", pwcQueryRestriction );
        DisplayCommandTree( pTree );
    }

    // If directed, don't issue the query.  Parsing it was sufficient.

    if ( fNoQuery )
    {
        xICommandTree->FreeCommandTree( &pTree );
        return S_OK;
    }

    // Set the tree in the ICommandTree.  Ownership of the tree is transferred.

    hr = xICommandTree->SetCommandTree( &pTree,
                                        DBCOMMANDREUSE_NONE,
                                        FALSE );
    if ( FAILED( hr ) )
    {
        xICommandTree->FreeCommandTree( &pTree );
        return hr;
    }

    // Set required properties on the ICommand

    hr = SetCommandProperties( xICommand.GetPointer(),
                               fForceUseContentIndex );
    if ( FAILED( hr ) )
        return hr;

    // Execute the query.  The query is complete when Execute() returns.

    XInterface<IRowset> xIRowset;
    hr = xICommand->Execute( 0,            // no aggregating IUnknown
                             IID_IRowset,  // IID for interface to return
                             0,            // no DBPARAMs
                             0,            // no rows affected
                             xIRowset.GetIUPointer() ); // result
    if ( FAILED( hr ) )
    {
        // Get the real error; OLE DB permits few Execute() return codes

        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        HRESULT hr2 = GetOleDBErrorInfo( xICommand.GetPointer(),
                                         IID_ICommand,
                                         lcid,
                                         &ErrorInfo,
                                         xErrorInfo.GetPPointer() );

        // Post IErrorInfo only if we have a valid pointer to it.

        if ( SUCCEEDED( hr2 ) && !xErrorInfo.IsNull() )
            hr = ErrorInfo.hrError;

        return hr;
    }

    // Create an accessor, so data can be retrieved from the rowset.

    XInterface<IAccessor> xIAccessor;
    hr = xIRowset->QueryInterface( IID_IAccessor,
                                   xIAccessor.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Count the number of output columns and make bindings for them.

    ULONG cColumns = 1;
    WCHAR const *pwc = pwcColumns;
    while ( 0 != *pwc )
    {
        if ( L',' == *pwc )
            cColumns++;
        pwc++;
    }

    // Column iOrdinals are parallel with those passed to CiTextToFullTree,
    // so MapColumnIDs isn't necessary.  These binding values for dwPart,
    // dwMemOwner, and wType are the most optimal bindings for Indexing
    // Service.

    XPtr<DBBINDING> xBindings( cColumns );
    if ( xBindings.IsNull() )
        return E_OUTOFMEMORY;

    memset( xBindings.Get(), 0, sizeof DBBINDING * cColumns );

    for ( ULONG i = 0; i < cColumns; i++ )
    {
        xBindings[i].iOrdinal   = 1 + i; // 1-based column number
        xBindings[i].obValue    = i * sizeof( PROPVARIANT * ); // offset
        xBindings[i].dwPart     = DBPART_VALUE; // retrieve value, not status
        xBindings[i].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // provider owned
        xBindings[i].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT *
    }

    HACCESSOR hAccessor;
    hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                     cColumns,           // # of columns
                                     xBindings.Get(),    // columns
                                     0,                  // ignored
                                     &hAccessor,         // result
                                     0 );                // no status
    if ( FAILED( hr ) )
        return hr;

    // Display the results of the query.

    XPtr<PROPVARIANT *> xData( cColumns );
    if ( xData.IsNull() )
        hr = E_OUTOFMEMORY;
    else
    {
        DBCOUNTITEM cRowsSoFar = 0;

        do
        {
            DBCOUNTITEM cRowsReturned = 0;
            const ULONG cRowsAtATime = 20;
            HROW aHRow[cRowsAtATime];
            HROW * pgrHRows = aHRow;
            hr = xIRowset->GetNextRows( 0,              // no chapter
                                        0,              // no rows to skip
                                        cRowsAtATime,   // # rows to get
                                        &cRowsReturned, // # rows returned
                                        &pgrHRows);     // resulting hrows
            if ( FAILED( hr ) )
                break;

            for ( DBCOUNTITEM iRow = 0; iRow < cRowsReturned; iRow++ )
            {
                HRESULT hr2 = xIRowset->GetData( aHRow[iRow],   // hrow being accessed
                                                 hAccessor,     // accessor to use
                                                 xData.Get() ); // resulting data
                if ( FAILED( hr2 ) )
                {
                    hr = hr2;
                    break;
                }

                for ( ULONG iCol = 0; iCol < cColumns; iCol++ )
                {
                    if ( 0 != iCol )
                        wprintf( L"  " );
                    DisplayValue( xData[ iCol ] );
                }

                wprintf( L"\n" );
            }

            // Release the HROWs retrived in GetNextRows

            if ( 0 != cRowsReturned )
            {
                cRowsSoFar += cRowsReturned;
                xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                       aHRow,         // rows to release
                                       0,             // no options
                                       0,             // no refcounts
                                       0 );           // no status
            }

            // Check if all rows are now retrieved.

            if ( DB_S_ENDOFROWSET == hr )
            {
                hr = S_OK; // succeeded, return S_OK from DoQuery
                break;
            }

            // Check if the query aborted because it was too costly.

            if ( DB_S_STOPLIMITREACHED == hr )
            {
                CResString str( IDS_QUERYTIMEDOUT );
                wprintf( L"%ws\n", str.Get() );
                hr = S_OK;
                break;
            }

            if ( FAILED( hr ) )
                break;
        } while ( TRUE );

        if ( !fQuiet )
        {
            CResString str( IDS_QUERYDONE );
            wprintf( str.Get(), cRowsSoFar, pwcQueryRestriction );
        }
    }

    xIAccessor->ReleaseAccessor( hAccessor, 0 );

    // Get query status information

    if ( SUCCEEDED( hr ) && !fQuiet )
        hr = DisplayRowsetStatus( xIRowset );

    return hr;
} //IssueQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Issues a query and displays an error message on failure
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [lcid]                  - Locale for the query
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    WCHAR const * pwcScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    LCID          lcid )
{
    HRESULT hr = IssueQuery( pwcCatalog,
                             pwcMachine,
                             pwcScope,
                             dwScopeFlags,
                             pwcRestriction,
                             pwcColumns,
                             pwcSort,
                             fDisplayTree,
                             fQuiet,
                             fForceUseContentIndex,
                             fNoQuery,
                             ulDialect,
                             cMaxHits,
                             lcid );

    if ( FAILED( hr ) )
        DisplayError( IDS_QUERYFAILED, pwcRestriction, hr, lcid );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQueryFile
//
//  Synopsis:   Issues each query in the specified query file.  A query file
//              is just a text file where each line contains a query.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [lcid]                  - Locale for the query
//              [pwcQueryFile]          - File containing queries, 1 per line
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQueryFile(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    LCID          lcid,
    WCHAR const * pwcQueryFile )
{
    // Open and read the query file

    HANDLE hFile = CreateFile( pwcQueryFile,
                               FILE_GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_DELETE,
                               0,
                               OPEN_EXISTING,
                               0,
                               0 );

    if ( INVALID_HANDLE_VALUE == hFile )
        return DisplayWin32Error( IDS_CANTOPENFILE,
                                  pwcQueryFile,
                                  lcid );

    DWORD cbFile = GetFileSize( hFile, 0 );

    if ( 0xffffffff == cbFile )
        return DisplayWin32Error( IDS_CANTGETFILESIZE,
                                  pwcQueryFile,
                                  lcid );

    // Allocate a buffer for the file

    XPtr<BYTE> xQueries( cbFile + sizeof WCHAR );
    if ( xQueries.IsNull() )
    {
        CloseHandle( hFile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return DisplayWin32Error( IDS_CANTGETMEMORY,
                                  pwcQueryFile,
                                  lcid );
    }

    // Read the file into the buffer

    DWORD cbRead;
    BOOL fRead = ReadFile( hFile, xQueries.Get(), cbFile, &cbRead, 0 );

    CloseHandle( hFile );

    if ( ! fRead )
        return DisplayWin32Error( IDS_CANTREADFROMFILE,
                                  pwcQueryFile,
                                  lcid );

    // Check if the file is Unicode already

    BOOL fUnicode = ( 0xfeff == ( * (WCHAR *) xQueries.Get() ) );

    WCHAR * pwcIn = 0;
    DWORD cwcIn = 0;

    if ( fUnicode )
    {
        pwcIn = (WCHAR *) xQueries.Get();

        // skip past the Unicode marker

        pwcIn++;
        cwcIn = ( cbFile / sizeof WCHAR ) - 1;
    }
    else
    {
        // Convert to Unicode.  Leave a little room for slack.

        DWORD cbTmp = cbFile * sizeof WCHAR + cbFile / 8;
        XPtr<BYTE> xTmp( cbTmp + sizeof WCHAR );
        if ( xTmp.IsNull() )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return DisplayWin32Error( IDS_CANTGETMEMORY,
                                      pwcQueryFile,
                                      lcid );
        }

        cwcIn = MultiByteToWideChar( LocaleToCodepage( lcid ),
                                     0,
                                     (const char *) xQueries.Get(),
                                     cbFile,
                                     (WCHAR *) xTmp.Get(),
                                     cbTmp );
        if ( 0 == cwcIn )
            return DisplayWin32Error( IDS_CANTCONVERTTOUNICODE,
                                      pwcQueryFile,
                                      lcid );

        pwcIn = (WCHAR *) xTmp.Get();
        xQueries.Free();
        xQueries.Set( xTmp.Acquire() );
    }

    // Read each line in the file and issue the query

    pwcIn[ cwcIn ] = 0;
    WCHAR * pwc = pwcIn;

    do
    {
        while ( 0     != *pwcIn &&
                L'\r' != *pwcIn &&
                L'\n' != *pwcIn )
            pwcIn++;

        BOOL fEOF = ( 0 == *pwcIn );

        *pwcIn = 0;

        if ( pwc != pwcIn )
        {
            DoQuery( pwcQueryCatalog,
                     pwcQueryMachine,
                     pwcQueryScope,
                     dwScopeFlags,
                     pwc,
                     pwcColumns,
                     pwcSort,
                     fDisplayTree,
                     fQuiet,
                     fForceUseContentIndex,
                     fNoQuery,
                     ulDialect,
                     cMaxHits,
                     lcid );
            wprintf( L"\n\n" );
        }

        if ( fEOF )
            break;

        pwcIn++;
        while ( '\r' == *pwcIn || '\n' == *pwcIn )
            pwcIn++;
        pwc = pwcIn;
    } while ( TRUE );

    return S_OK;
} //DoQueryFile

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    HRSRC hrc = FindResource( 0, (LPCWSTR) IDR_USAGE, RT_RCDATA );

    if ( 0 != hrc )
    {
        HGLOBAL hg = LoadResource( 0, hrc );

        if ( 0 != hg )
        {
            void * pv = LockResource( hg );

            if ( 0 != pv )
                wprintf( L"%ws\n", pv );
        }
    }

    exit( -1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   LcidFromHttpAcceptLanguage
//
//  Synopsis:   Looks up an LCID given an HTTP Accept Language string
//
//  Arguments:  [pwc] - The string to look up
//
//  Returns:    The matching LCID.
//
//--------------------------------------------------------------------------

LCID LcidFromHttpAcceptLanguage( WCHAR const * pwc )
{
    // Default to the system locale

    if ( 0 == pwc )
        return GetSystemDefaultLCID();

    struct SHttpLocale
    {
        WCHAR const * pwcLanguage;
        LCID          lcid;
        WCHAR const * pwcHttpAcceptLanguage;
        WCHAR const * pwcHttpAcceptLanguageAbbr;
    };

    const struct SHttpLocale aHttpLocale[] =
    {
        L"Afrikaans",                         0x0436, L"af",    L"af",
        L"Albanian",                          0x041c, L"sq",    L"sq",
        L"Arabic(Saudi Arabia)",              0x0401, L"ar-sa", L"arsa",
        L"Arabic(Iraq)",                      0x0801, L"ar-iq", L"ariq",
        L"Arabic(Egypt)",                     0x0C01, L"ar-eg", L"areg",
        L"Arabic(Libya)",                     0x1001, L"ar-ly", L"arly",
        L"Arabic(Algeria)",                   0x1401, L"ar-dz", L"ardz",
        L"Arabic(Morocco)",                   0x1801, L"ar-ma", L"arma",
        L"Arabic(Tunisia)",                   0x1C01, L"ar-tn", L"artn",
        L"Arabic(Oman)",                      0x2001, L"ar-om", L"arom",
        L"Arabic(Yemen)",                     0x2401, L"ar-ye", L"arye",
        L"Arabic(Syria)",                     0x2801, L"ar-sy", L"arsy",
        L"Arabic(Jordan)",                    0x2C01, L"ar-jo", L"arjo",
        L"Arabic(Lebanon)",                   0x3001, L"ar-lb", L"arlb",
        L"Arabic(Kuwait)",                    0x3401, L"ar-kw", L"arkw",
        L"Arabic(U.A.E.)",                    0x3801, L"ar-ae", L"arae",
        L"Arabic(Bahrain)",                   0x3C01, L"ar-bh", L"arbh",
        L"Arabic(Qatar)",                     0x4001, L"ar-qa", L"arqa",
        L"Basque",                            0x042D, L"eu",    L"eu",
        L"Bulgarian",                         0x0402, L"bg",    L"bg",
        L"Belarusian",                        0x0423, L"be",    L"be",
        L"Catalan",                           0x0403, L"ca",    L"ca",
        L"Chinese(Taiwan)",                   0x0404, L"zh-tw", L"zhtw",
        L"Chinese(PRC)",                      0x0804, L"zh-cn", L"zhcn",
        L"Chinese(Hong Kong SAR)",            0x0C04, L"zh-hk", L"zhhk",
        L"Chinese(Singapore)",                0x1004, L"zh-sg", L"zhsg",
        L"Croatian",                          0x041a, L"hr",    L"hr",
        L"Czech",                             0x0405, L"cs",    L"cs",
        L"Danish",                            0x0406, L"da",    L"da",
        L"Dutch(Standard)",                   0x0413, L"nl",    L"nl",
        L"Dutch(Belgian)",                    0x0813, L"nl-be", L"nlbe",
        L"English",                           0x0009, L"en",    L"en",
        L"English(United States)",            0x0409, L"en-us", L"enus",
        L"English(British)",                  0x0809, L"en-gb", L"engb",
        L"English(Australian)",               0x0c09, L"en-au", L"enau",
        L"English(Canadian)",                 0x1009, L"en-ca", L"enca",
        L"English(New Zealand)",              0x1409, L"en-nz", L"ennz",
        L"English(Ireland)",                  0x1809, L"en-ie", L"enie",
        L"English(South Africa)",             0x1c09, L"en-za", L"enza",
        L"English(Jamaica)",                  0x2009, L"en-jm", L"enjm",
        L"English(Caribbean)",                0x2409, L"en",    L"en",
        L"English(Belize)",                   0x2809, L"en-bz", L"enbz",
        L"English(Trinidad)",                 0x2c09, L"en-tt", L"entt",
        L"Estonian",                          0x0425, L"et",    L"et",
        L"Faeroese",                          0x0438, L"fo",    L"fo",
        L"Farsi",                             0x0429, L"fa",    L"fa",
        L"Finnish",                           0x040b, L"fi",    L"fi",
        L"French(Standard)",                  0x040c, L"fr",    L"fr",
        L"French(Belgian)",                   0x080c, L"fr-be", L"frbe",
        L"French(Canadian)",                  0x0c0c, L"fr-ca", L"frca",
        L"French(Swiss)",                     0x100c, L"fr-ch", L"frch",
        L"French(Luxembourg)",                0x140c, L"fr-lu", L"frlu",
        L"Gaelic(Scots)",                     0x043c, L"gd",    L"gd",
        L"Gaelic(Irish)",                     0x083c, L"gd-ie", L"gdie",
        L"German(Standard)",                  0x0407, L"de",    L"de",
        L"German(Swiss)",                     0x0807, L"de-ch", L"dech",
        L"German(Austrian)",                  0x0c07, L"de-at", L"deat",
        L"German(Luxembourg)",                0x1007, L"de-lu", L"delu",
        L"German(Liechtenstein)",             0x1407, L"de-li", L"deli",
        L"Greek",                             0x0408, L"el",    L"el",
        L"Hebrew",                            0x040D, L"he",    L"he",
        L"Hindi",                             0x0439, L"hi",    L"hi",
        L"Hungarian",                         0x040e, L"hu",    L"hu",
        L"Icelandic",                         0x040F, L"is",    L"is",
        L"Indonesian",                        0x0421, L"in",    L"in",
        L"Italian(Standard)",                 0x0410, L"it",    L"it",
        L"Italian(Swiss)",                    0x0810, L"it-ch", L"itch",
        L"Japanese",                          0x0411, L"ja",    L"ja",
        L"Korean",                            0x0412, L"ko",    L"ko",
        L"Korean(Johab)",                     0x0812, L"ko",    L"ko",
        L"Latvian",                           0x0426, L"lv",    L"lv",
        L"Lithuanian",                        0x0427, L"lt",    L"lt",
        L"FYRO Macedonian",                   0x042f, L"mk",    L"mk",
        L"Malaysian",                         0x043e, L"ms",    L"ms",
        L"Maltese",                           0x043a, L"mt",    L"mt",
        L"Norwegian(Bokmal)",                 0x0414, L"no",    L"no",
        L"Norwegian(Nynorsk)",                0x0814, L"no",    L"no",
        L"Polish",                            0x0415, L"pl",    L"pl",
        L"Portuguese(Brazilian)",             0x0416, L"pt-br", L"ptbr",
        L"Portuguese(Standard)",              0x0816, L"pt",    L"pt",
        L"Rhaeto-Romanic",                    0x0417, L"rm",    L"rm",
        L"Romanian",                          0x0418, L"ro",    L"ro",
        L"Romanian(Moldavia)",                0x0818, L"ro-mo", L"romo",
        L"Russian",                           0x0419, L"ru",    L"ru",
        L"Russian(Moldavia)",                 0x0819, L"ru-mo", L"rumo",
        L"Sami(Lappish)",                     0x043b, L"sz",    L"sz",
        L"Serbian(Cyrillic)",                 0x0c1a, L"sr",    L"sr",
        L"Serbian(Latin)",                    0x081a, L"sr",    L"sr",
        L"Slovak",                            0x041b, L"sk",    L"sk",
        L"Slovenian",                         0x0424, L"sl",    L"sl",
        L"Sorbian",                           0x042e, L"sb",    L"sb",
        L"Spanish(Spain - Traditional Sort)", 0x040a, L"es",    L"es",
        L"Spanish(Mexican)",                  0x080a, L"es-mx", L"esmx",
        L"Spanish(Spain - Modern Sort)",      0x0c0a, L"es",    L"es",
        L"Spanish(Guatemala)",                0x100a, L"es-gt", L"esgt",
        L"Spanish(Costa Rica)",               0x140a, L"es-cr", L"escr",
        L"Spanish(Panama)",                   0x180a, L"es-pa", L"espa",
        L"Spanish(Dominican Republic)",       0x1c0a, L"es-do", L"esdo",
        L"Spanish(Venezuela)",                0x200a, L"es-ve", L"esve",
        L"Spanish(Colombia)",                 0x240a, L"es-co", L"esco",
        L"Spanish(Peru)",                     0x280a, L"es-pe", L"espe",
        L"Spanish(Argentina)",                0x2c0a, L"es-ar", L"esar",
        L"Spanish(Ecuador)",                  0x300a, L"es-ec", L"esec",
        L"Spanish(Chile)",                    0x340a, L"es-cl", L"escl",
        L"Spanish(Uruguay)",                  0x380a, L"es-uy", L"esuy",
        L"Spanish(Paraguay)",                 0x3c0a, L"es-py", L"espy",
        L"Spanish(Bolivia)",                  0x400a, L"es-bo", L"esbo",
        L"Spanish(El Salvador)",              0x440a, L"es-sv", L"essv",
        L"Spanish(Honduras)",                 0x480a, L"es-hn", L"eshn",
        L"Spanish(Nicaragua)",                0x4c0a, L"es-ni", L"esni",
        L"Spanish(Puerto Rico)",              0x500a, L"es-pr", L"espr",
        L"Sutu",                              0x0430, L"sx",    L"sx",
        L"Swedish",                           0x041D, L"sv",    L"sv",
        L"Swedish(Finland)",                  0x081d, L"sv-fi", L"svfi",
        L"Thai",                              0x041E, L"th",    L"th",
        L"Tsonga",                            0x0431, L"ts",    L"ts",
        L"Tswana",                            0x0432, L"tn",    L"tn",
        L"Turkish",                           0x041f, L"tr",    L"tr",
        L"Ukrainian",                         0x0422, L"uk",    L"uk",
        L"Urdu",                              0x0420, L"ur",    L"ur",
        L"Venda",                             0x0433, L"ve",    L"ve",
        L"Vietnamese",                        0x042a, L"vi",    L"vi",
        L"Xhosa",                             0x0434, L"xh",    L"xh",
        L"Yiddish",                           0x043d, L"ji",    L"ji",
        L"Zulu",                              0x0435, L"zu",    L"zu",
        L"Neutral", MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), SORT_DEFAULT ), L"neutr", L"neutr",
    };

    const unsigned cHttpLocale = sizeof aHttpLocale / sizeof aHttpLocale[0];

    for ( unsigned i = 0; i < cHttpLocale; i++ )
        if ( !_wcsicmp( aHttpLocale[ i ].pwcHttpAcceptLanguage, pwc ) ||
             !_wcsicmp( aHttpLocale[ i ].pwcHttpAcceptLanguageAbbr, pwc ) )
            return aHttpLocale[ i ].lcid;

    Usage();
    return 0;
} //LcidFromHttpAcceptLanguage

//+-------------------------------------------------------------------------
//
//  Function:   LookupCatalog
//
//  Synopsis:   Looks for a catalog and machine matching the scope
//
//  Arguments:  [pwcScope]   - The scope used to find the catalog
//              [pwcMachine] - Returns the machine name
//              [cwcMachine] - In/Out: Count of characters in pwcMachine
//              [pwcCatalog] - Returns the catalog name
//              [cwcCatalog] - In/Out: Count of characters in pwcCatalog
//              [lcid]       - Locale to use for errors
//
//--------------------------------------------------------------------------

HRESULT LookupCatalog(
    WCHAR const * pwcScope,
    WCHAR *       pwcMachine,
    ULONG &       cwcMachine,
    WCHAR *       pwcCatalog,
    ULONG &       cwcCatalog,
    LCID          lcid )
{
    HRESULT hr = LocateCatalogs( pwcScope,       // scope to lookup
                                 0,              // go with the first match
                                 pwcMachine,     // returns the machine
                                 &cwcMachine,    // buffer size in/out
                                 pwcCatalog,     // returns the catalog
                                 &cwcCatalog );  // buffer size in/out

    if ( FAILED( hr ) || ( S_FALSE == hr ) )
    {
        DisplayError( IDS_CANTFINDCATALOG, pwcScope, hr, lcid );
        hr = E_FAIL;
    }

    return hr;
} //LookupCatalog

//+-------------------------------------------------------------------------
//
//  Function:   NormalizeScope
//
//  Synopsis:   Normalizes a scope and sets scope flags.
//
//  Arguments:  [pwcIn]        - The scope for the query
//              [pwcOut]       - Returns the scope for the query
//              [dwScopeFlags] - Returns the scope flags for the query
//
//--------------------------------------------------------------------------

HRESULT NormalizeScope(
    WCHAR const * pwcIn,
    WCHAR *       pwcOut,
    BOOL          fShallow,
    DWORD &       dwScopeFlags )
{
    if ( wcslen( pwcIn ) >= MAX_PATH )
        return E_INVALIDARG;

    if ( fShallow )
        dwScopeFlags = QUERY_SHALLOW;
    else
        dwScopeFlags = QUERY_DEEP;

    wcscpy( pwcOut, pwcIn );

    // Check if the scope is an IIS virtual scope.

    WCHAR wc = pwcIn[0];

    if ( L'/' == wc )
    {
        // Set the virtual scope flag and flip the slashes.

        dwScopeFlags |= QUERY_VIRTUAL_PATH;
        for ( WCHAR * pwc = pwcOut; *pwc; pwc++ )
            if ( '/' == *pwc )
                *pwc = '\\';
    }
    else if ( ( !( L'\\' == wc && L'\\' == pwcIn[1] ) ) &&
              ( !( L'\\' == wc && 0 == pwcIn[1] ) ) &&
              L':' != pwcIn[1] &&
              0 != wc )
    {
        // Turn the relative path into a full path based on the current dir.

        _wfullpath( pwcOut, pwcIn, MAX_PATH );
    }

    return S_OK;
} //NormalizeScope

//+-------------------------------------------------------------------------
//
//  Function:   DisplayStatus
//
//  Synopsis:   Displays status information about a catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayStatus(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    DisplayStat( pwcMachine, IDS_STAT_MACHINE );
    DisplayStat( pwcCatalog, IDS_STAT_CATALOG );

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        DisplayStat( state.cTotalDocuments, IDS_STAT_TOTALDOCUMENTS );
        DisplayStat( state.cFreshTest, IDS_STAT_FRESHTEST );
        DisplayStat( state.cFilteredDocuments, IDS_STAT_FILTEREDDOCUMENTS );
        DisplayStat( state.cDocuments, IDS_STAT_DOCUMENTS );
        DisplayStat( state.cSecQDocuments, IDS_STAT_SECQDOCUMENTS );
        DisplayStat( state.cUniqueKeys, IDS_STAT_UNIQUEKEYS );
        DisplayStat( state.cWordList, IDS_STAT_WORDLIST );
        DisplayStat( state.cPersistentIndex, IDS_STAT_PERSISTENTINDEX );
        DisplayStat( state.cQueries, IDS_STAT_QUERIES );
        DisplayStat( state.dwIndexSize, IDS_STAT_INDEXSIZE );
        DisplayStat( state.dwPropCacheSize / 1024, IDS_STAT_PROPCACHESIZE );

        DisplayStat( ( state.eState & CI_STATE_SCANNING ) ?
                     state.cPendingScans : 0,
                     IDS_STAT_SCANS );

        const DWORD ALL_CI_MERGE = ( CI_STATE_SHADOW_MERGE |
                                     CI_STATE_ANNEALING_MERGE |
                                     CI_STATE_INDEX_MIGRATION_MERGE |
                                     CI_STATE_MASTER_MERGE |
                                     CI_STATE_MASTER_MERGE_PAUSED );

        if ( 0 != ( ALL_CI_MERGE & state.eState ) )
        {
            UINT idStr;
            if ( state.eState & CI_STATE_SHADOW_MERGE )
                idStr = IDS_STAT_MERGE_SHADOW;
            else if ( state.eState & CI_STATE_ANNEALING_MERGE )
                idStr = IDS_STAT_MERGE_ANNEALING;
            else if ( state.eState & CI_STATE_INDEX_MIGRATION_MERGE )
                idStr = IDS_STAT_MERGE_INDEX_MIGRATION;
            else if ( state.eState & CI_STATE_MASTER_MERGE )
                idStr = IDS_STAT_MERGE_MASTER;
            else
                idStr = IDS_STAT_MERGE_MASTER_PAUSED;

            DisplayStat( state.dwMergeProgress, idStr );
        }

        if ( CI_STATE_READ_ONLY & state.eState )
            DisplayStat( IDS_STAT_READ_ONLY );
        if ( CI_STATE_RECOVERING & state.eState )
            DisplayStat( IDS_STAT_RECOVERING );
        if ( CI_STATE_LOW_MEMORY & state.eState )
            DisplayStat( IDS_STAT_LOW_MEMORY );
        if ( CI_STATE_HIGH_IO & state.eState )
            DisplayStat( IDS_STAT_HIGH_IO );
        if ( CI_STATE_BATTERY_POWER & state.eState )
            DisplayStat( IDS_STAT_BATTERY_POWER );
        if ( CI_STATE_USER_ACTIVE & state.eState )
            DisplayStat( IDS_STAT_USER_ACTIVE );
        if ( CI_STATE_STARTING & state.eState )
            DisplayStat( IDS_STAT_STARTING );
        if ( CI_STATE_READING_USNS & state.eState )
            DisplayStat( IDS_STAT_READING_USNS );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayStatus

//+-------------------------------------------------------------------------
//
//  Function:   DisplayUpToDate
//
//  Synopsis:   Checks if the index is up to date.
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayUpToDate(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        // It's up to date if there are no documents to filter, no scans or
        // usn activity, and the index isn't starting or recovering.

        BOOL fUpToDate = ( ( 0 == state.cDocuments ) &&
                           ( 0 == ( state.eState & CI_STATE_SCANNING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_READING_USNS ) ) &&
                           ( 0 == ( state.eState & CI_STATE_STARTING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_RECOVERING ) ) );

        DisplayStat( fUpToDate ? IDS_STAT_UP_TO_DATE :
                                 IDS_STAT_NOT_UP_TO_DATE );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayUpToDate

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments and
//              issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcCatalog     = 0;         // default: lookup catalog
    WCHAR const * pwcMachine     = L".";      // default: local machine
    WCHAR const * pwcScope       = L"\\";     // default: entire catalog
    WCHAR const * pwcRestriction = 0;         // no default restriction
    WCHAR const * pwcColumns     = L"path";   // default output column(s)
    WCHAR const * pwcSort        = 0;         // no sort is the default
    WCHAR const * pwcQueryFile   = 0;         // no query file specified
    WCHAR const * pwcLocale      = 0;         // default: system locale
    BOOL fDisplayTree            = FALSE;     // don't display the tree
    BOOL fForceUseContentIndex   = TRUE;      // always use the index
    ULONG ulDialect              = 1;         // original query language dialect
    BOOL fQuiet                  = FALSE;     // show the hitcount
    ULONG cMaxHits               = 0;         // default: retrieve all hits
    BOOL fDisplayStatus          = FALSE;     // default: don't show status
    BOOL fDisplayUpToDate        = FALSE;     // default: don't show up to date
    ULONG cRepetitions           = 1;         // # of times to repeat command
    BOOL fShallow                = FALSE;     // default: all subdirectories
    BOOL fNoQuery                = FALSE;     // default: execute query

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( (char) argv[i][1] );

            if ( ':' != argv[i][2] &&
                 'D' != wc &&
                 'J' != wc &&
                 'N' != wc &&
                 'Q' != wc &&
                 'U' != wc &&
                 'T' != wc )
                Usage();

            if ( 'C' == wc )
                pwcCatalog = argv[i] + 3;
            else if ( 'M' == wc )
                pwcMachine = argv[i] + 3;
            else if ( 'P' == wc )
                pwcScope = argv[i] + 3;
            else if ( 'O' == wc )
                pwcColumns = argv[i] + 3;
            else if ( 'S' == wc )
                pwcSort = argv[i] + 3;
            else if ( 'X' == wc )
                cMaxHits = _wtoi( argv[i] + 3 );
            else if ( 'I' == wc )
            {
                if ( 0 != pwcRestriction )
                    Usage();
                pwcQueryFile = argv[i] + 3;
            }
            else if ( 'R' == wc)
            {
                // get the next arg as a number
                cRepetitions = _wtol(argv[i]+3);
            }
            else if ( 'D' == wc )
                fDisplayTree = TRUE;
            else if ( 'J' == wc )
                fShallow = TRUE;
            else if ( 'N' == wc )
                fNoQuery = TRUE;
            else if ( 'Q' == wc )
                fQuiet = TRUE;
            else if ( 'T' == wc )
                fDisplayStatus = TRUE;
            else if ( 'U' == wc )
                fDisplayUpToDate = TRUE;
            else if ( 'E' == wc )
                pwcLocale = argv[i] + 3;
            else if ( 'L' == wc )
            {
                if ( '1' == argv[i][3] )
                    ulDialect = 1;
                else if ( '2' == argv[i][3] )
                    ulDialect = 2;
                else
                    Usage();
            }
            else if ( 'F' == wc )
            {
                if ( '+' == argv[i][3] )
                    fForceUseContentIndex = TRUE;
                else if ( '-' == argv[i][3] )
                    fForceUseContentIndex = FALSE;
                else
                    Usage();
            }
            else
                Usage();
        }
        else if ( 0 != pwcRestriction || 0 != pwcQueryFile )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction, query file, or status request is necessary.

    if ( 0 == pwcRestriction && 0 == pwcQueryFile &&
         !fDisplayStatus && !fDisplayUpToDate)
        Usage();

    // Get the locale identifier to use for the query

    LCID lcid = LcidFromHttpAcceptLanguage( pwcLocale );

    // Normalize relative and virtual scopes

    WCHAR awcScope[ MAX_PATH ];
    DWORD dwScopeFlags;
    HRESULT hr = NormalizeScope( pwcScope, awcScope, fShallow, dwScopeFlags );

    // Initialize OLE

    BOOL fCoInit = FALSE;

    if ( SUCCEEDED( hr ) )
    {
        hr = CoInitialize( 0 );
        if ( SUCCEEDED( hr ) )
            fCoInit = TRUE;
    }

    // If no catalog was specified, infer one based on the scope

    WCHAR awcMachine[ MAX_PATH ], awcCatalog[ MAX_PATH ];

    if ( SUCCEEDED( hr ) && ( 0 == pwcCatalog ) && !fNoQuery )
    {
        ULONG cwcMachine = sizeof awcMachine / sizeof WCHAR;
        ULONG cwcCatalog = sizeof awcCatalog / sizeof WCHAR;
        hr = LookupCatalog( awcScope,
                            awcMachine,
                            cwcMachine,
                            awcCatalog,
                            cwcCatalog,
                            lcid );
        pwcMachine = awcMachine;
        pwcCatalog = awcCatalog;

        // Turn scopes like \\machine into \ now that the lookup is done
        // and we've found a catalog and machine name.

        if ( SUCCEEDED( hr ) &&
             L'\\' == awcScope[0] && L'\\' == awcScope[1] &&
             0 == wcschr( awcScope + 2, L'\\' ) )
            awcScope[1] = 0;
    }

    if ( SUCCEEDED( hr ) )
    {
        for (ULONG j = 0; j < cRepetitions; j++)
        {
            if ( 0 != pwcQueryFile )
                hr = DoQueryFile( fNoQuery ? L"::_noquery" : pwcCatalog,
                                  pwcMachine,
                                  awcScope,
                                  dwScopeFlags,
                                  pwcColumns,
                                  pwcSort,
                                  fDisplayTree,
                                  fQuiet,
                                  fForceUseContentIndex,
                                  fNoQuery,
                                  ulDialect,
                                  cMaxHits,
                                  lcid,
                                  pwcQueryFile );
            else if ( 0 != pwcRestriction )
                hr = DoQuery( fNoQuery ? L"::_noquery" : pwcCatalog,
                              pwcMachine,
                              awcScope,
                              dwScopeFlags,
                              pwcRestriction,
                              pwcColumns,
                              pwcSort,
                              fDisplayTree,
                              fQuiet,
                              fForceUseContentIndex,
                              fNoQuery,
                              ulDialect,
                              cMaxHits,
                              lcid );

            if ( SUCCEEDED( hr ) && fDisplayStatus )
                hr = DisplayStatus( pwcCatalog, pwcMachine, lcid );

            if ( SUCCEEDED( hr ) && fDisplayUpToDate )
                hr = DisplayUpToDate( pwcCatalog, pwcMachine, lcid );
        }
    }

    if ( fCoInit )
        CoUninitialize();

    if ( FAILED( hr ) )
        return -1;

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\cimbmgr_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "cimbmgr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\catcnfg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       CatCnfg.cxx
//
//  Contents:   Support for adding catalogs during setup.
//
//  History:    13-May-1998   KyleP   Added copyright
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <ciregkey.hxx>
#include "catcnfg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::CCatalogConfig
//
//  Synopsis:   Constructor
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

CCatalogConfig::CCatalogConfig(CError & Err) :
    _Err( Err ),
    _cDrive( 0 ),
    _pwszCatalogDrive( 0 ),
    _cIncludedScopes( 0 ), _xaIncludedScopes( 10 ),
    _cExcludedScopes( 0 ), _xaExcludedScopes( 10 )
{
    RtlZeroMemory( _DriveList, sizeof _DriveList );
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::InitDriveList, public
//
//  Synopsis:   Initialize drive list with local drive names, types, and
//              available/free space.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS upon sucess,
//              none zero upon failure.
//
//  History:    6-27-97     mohamedn  created
//              9/10/97     mohamedn  rewritten catalog configuration
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::InitDriveList()
{
    // 26 drive letters * 4 characters per drive + terminating NULL.
    const DWORD dwSize = MAX_DRIVES * CHARS_PER_DRIVE + 1;
    WCHAR       wszListOfAllDrives[ dwSize ];
    unsigned    iDriveNumber   = 0;
    DWORD       dwRetVal       = 0;

    RtlZeroMemory( wszListOfAllDrives, sizeof wszListOfAllDrives );

    dwRetVal = GetLogicalDriveStrings(dwSize, wszListOfAllDrives);
    if ( dwRetVal == 0 ||  dwRetVal > dwSize )
    {
        DWORD dwErr = GetLastError();
        isDebugOut(( "GetLogicalDriveStrings Failed: dwRetVal: %d, GetLastError(): %d\n",
                     dwRetVal, dwErr ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwErr );

        return FALSE;
    }

    for ( WCHAR *pwszTmp = wszListOfAllDrives;
          *pwszTmp;
          pwszTmp += CHARS_PER_DRIVE )
    {
        switch (GetDriveType(pwszTmp))
        {
        case DRIVE_FIXED:         // The disk cannot be removed from the drive.
            break;

        default:
            isDebugOut(( "InitDriveList: Unexpected drive type %d\n",
                         GetDriveType(pwszTmp) ));

        case 0:                 // The drive type cannot be determined.
        case 1:                 // The root directory does not exist.
        case DRIVE_REMOVABLE:   // The media can be removed from the drive.
        case DRIVE_REMOTE:      // The drive is a remote (network) drive.
        case DRIVE_CDROM:       // drive is a CD-ROM drive.
        case DRIVE_RAMDISK:     // The drive is a RAM disk.
            continue;
        }

        _DriveList[iDriveNumber].SetDriveName(pwszTmp);

        if ( ! _DriveList[iDriveNumber].SetDriveInfo( ) )
        {
            continue;
        }
        else
        {
            iDriveNumber++;
        }
    }

    _cDrive = iDriveNumber;

    ReservePageFileData();

    return ( _cDrive > 0 ? TRUE : FALSE );
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::ReservePageFileData, private
//
//  Synopsis:   Reserve unallocated space for page files.
//
//  Arguments:  none
//
//  Returns:    TRUE upon sucess, FALSE upon failure.
//
//  History:    26 Oct 1998    AlanwW    Created
//
//--------------------------------------------------------------------------

const WCHAR wszPagingFileKey[] =
    L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
const WCHAR wszPagingFileValueName[] = L"PagingFiles";

BOOL CCatalogConfig::ReservePageFileData()
{
    WCHAR awcPagingFiles[2000];
    awcPagingFiles[0] = L'\0';

    //
    //  Get the original page file info from
    //  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessonManager
    //
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wszPagingFileKey );

    if ( ! reg.Get( wszPagingFileValueName,
                    awcPagingFiles,
                    sizeof awcPagingFiles/sizeof awcPagingFiles[0] ) )
        return FALSE;

    //
    // Iterate through all paging files, reserve any difference between
    // the max size and currently allocated size.
    //
    WCHAR * pwsz = &awcPagingFiles[0];
    while ( *pwsz )
    {
        WCHAR *pwszPageFile = pwsz;
        pwsz = wcschr(pwsz, L' ');
        if ( ! pwsz )
            break;

        *pwsz++ = L'\0';
        ULONG ulMinAlloc = _wtoi( pwsz );

        WCHAR *pwsz2 = wcschr(pwsz, L' ');

        ULONG ulMaxAlloc = ulMinAlloc + MAXOVERMINFACTOR;
        if ( pwsz2 )
            ulMaxAlloc = _wtoi( pwsz2 );

        while ( *pwsz )
            pwsz++;
        pwsz++;

        CDriveInformation * pDriveInfo = GetDriveInfo( pwszPageFile );
        if ( !pDriveInfo )
            continue;

        //
        //  For some reason, GetFileAttributesEx will get a sharing violation
        //  on an open paging file.  FindFirstFile will work to get the very
        //  same information.
        //
        HANDLE hFind;
        WIN32_FIND_DATA FindData;

        if ( (hFind = FindFirstFile(pwszPageFile, &FindData)) ==
             INVALID_HANDLE_VALUE )
        {
            isDebugOut(( "ReservePageFileData: FindFirstFile %ws failed: %x\n",
                         pwszPageFile,
                         GetLastError() ));
            continue;
        }
        FindClose(hFind);

        ULARGE_INTEGER ullFileSize;
        ullFileSize.LowPart =  FindData.nFileSizeLow;
        ullFileSize.HighPart = FindData.nFileSizeHigh;

        pDriveInfo->ReservePagingData( ulMaxAlloc * ONE_MB,
                                       ullFileSize.QuadPart );
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::GetDriveInfo, public
//
//  Synopsis:   Returns pointer to drive information structure.
//
//  Arguments:  [pwszPath] - path name to be looked up
//
//  Returns:    CDriveInformation* - pointer to drive information; 0 if not found
//
//  History:    29 Oct 1998     AlanW     Created
//
//--------------------------------------------------------------------------

CDriveInformation * CCatalogConfig::GetDriveInfo(WCHAR const * pwszPath)
{
    WCHAR       wcDriveLetter = (WCHAR)toupper( *pwszPath );

    for (unsigned i = 0; i < _cDrive; i++ )
    {
        if (toupper( _DriveList[i].GetDriveLetter() ) == wcDriveLetter )
            return &_DriveList[i];
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::SetDriveInfo, public
//
//  Synopsis:   Obtains drive info
//
//  Arguments:  [none]
//
//  Returns:    TRUE upon success, False upon failure.
//
//  History:    6-27-97        mohamedn  created
//              26 Oct 1998    AlanwW    Enhanced and made a CDriveInfo method.
//
//--------------------------------------------------------------------------

static WCHAR pwszBootFile1[] = L"x:\\NTLDR";                      // x86
static WCHAR pwszBootFile2[] = L"x:\\OS\\WINNT50\\OSLOADER.EXE";  // risc

static WCHAR * apwszBootFiles[] = {
    pwszBootFile1,
    pwszBootFile2,
};


BOOL CDriveInformation::SetDriveInfo()
{
    Win4Assert( 0 != GetDriveLetter() );
    _cbFreeSpace = _cbTotalSpace = _cbReservedSpace = 0;

    ULARGE_INTEGER  cbFreeBytesToCaller;
    ULARGE_INTEGER  cbTotalNumberOfBytes;
    ULARGE_INTEGER  cbTotalNumberOfFreeBytes;

    cbFreeBytesToCaller.QuadPart        = 0;
    cbTotalNumberOfBytes.QuadPart       = 0;
    cbTotalNumberOfFreeBytes.QuadPart   = 0;

    //
    // returns 0 upon failure, none-zero upon success.
    //
    BOOL fSuccess = GetDiskFreeSpaceEx( _wszDriveName,
                                        &cbFreeBytesToCaller,
                                        &cbTotalNumberOfBytes,
                                        &cbTotalNumberOfFreeBytes );
    if (!fSuccess)
    {
         isDebugOut(( "SetDriveInfo: GetDiskFreeSapceEx %ws failed: %x\n",
                      _wszDriveName,
                      GetLastError() ));
         return fSuccess;
    }

    _cbFreeSpace= cbTotalNumberOfFreeBytes.QuadPart;
    _cbTotalSpace= cbTotalNumberOfBytes.QuadPart;

    //
    // Determine if the volume supports security (i.e., if it's NTFS)
    //
    fSuccess = GetVolumeInformationW( _wszDriveName,
                                      0, 0,           // volume name
                                      0,              // volume serial number
                                      0,              // max filename length
                                      &_dwFileSystemFlags,
                                      0, 0 );         // file system name

    if (!fSuccess)
    {
         isDebugOut(( "SetDriveInfo: GetFileSystemInfo failed: %x\n",GetLastError() ));
         return fSuccess;
    }

    for (unsigned i=0; i < NUMELEM( apwszBootFiles ); i++)
    {
        if (Exists(apwszBootFiles[i]))
        {
            _fIsBootDrive = TRUE;
            break;
        }
    }

    return fSuccess;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::Exists, public
//
//  Synopsis:   Determines if a file or directory exists
//
//  Arguments:  [pwszPath]   - path name of the file to check
//
//  Notes:      The [pwszPath] must be a full path name starting with a
//              drive letter.  The drive letter is overwritten by this
//              method.
//
//  Returns:    TRUE if the file exists, FALSE upon failure or non-existance.
//
//  History:    26 Oct 1998     AlanW     Created
//
//--------------------------------------------------------------------------

BOOL CDriveInformation::Exists(WCHAR * pwszPath)
{
    *pwszPath = GetDriveLetter();

    DWORD attr = GetFileAttributes( pwszPath );

    // If we couldn't determine file's attributes, don't consider it found
    // unless the error code indirectly indicates that it exists.

    if ( 0xffffffff == attr )
    {
        isDebugOut(( DEB_TRACE, "Exists: GetFileAttributes( %ws ) Failed: %d\n",
                      pwszPath, GetLastError() ));

        if (GetLastError() == ERROR_SHARING_VIOLATION)
            return TRUE;        // It must exist

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::ConfigureDefaultCatalog
//
//  Synopsis:   Creates a single default catalog if sufficient disk space
//              exists on one drive.
//
//  Arguments:  [wszPrimaryScope] -- Path name of primary indexed directory
//
//  Returns:    TRUE upon success, FALSE upon Failure,
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

static WCHAR wszUpgradeDir[] = L"x:\\$WIN_NT$.~LS";

BOOL CCatalogConfig::ConfigureDefaultCatalog(
    WCHAR const * pwszPrimaryScope )
{
    {
        //
        // Reserve space for a net upgrade of the OS if we're not currently
        // doing one (in which case the space for it will already be in use).
        // Because we will preferably use an NTFS drive for the catalog, try
        // using a FAT drive for the upgrade files.
        //
        int       iUpgradeFiles = -1;
        int       iBestFitForUpgrade = -1;
        ULONGLONG cbBestFitForUpgrade = 0;
        BOOL      fBestFitOnNtfs = FALSE;

        for ( unsigned i = 0 ; i < _cDrive; i++ )
        {
            if ( iUpgradeFiles == -1 && _DriveList[i].Exists( wszUpgradeDir ) )
            {
                iUpgradeFiles = i;
                break;
            }

            ULONGLONG cbAvail = _DriveList[i].GetAvailableSpace();
            if ( cbAvail < MIN_UPGRADE_SPACE )
                continue;

            if ( iBestFitForUpgrade == -1 ||
                 ( cbAvail < cbBestFitForUpgrade && fBestFitOnNtfs ) ||
                 ( ! _DriveList[i].IsNtfs() && fBestFitOnNtfs ) )
            {
                cbBestFitForUpgrade = cbAvail;
                iBestFitForUpgrade = i;
                fBestFitOnNtfs = _DriveList[i].IsNtfs();
            }
        }
        if ( iUpgradeFiles == -1 && iBestFitForUpgrade != -1 )
            _DriveList[iBestFitForUpgrade].AddReservedSpace( MIN_UPGRADE_SPACE );
        else  if ( iUpgradeFiles == -1 )
        {
            isDebugOut(( DEB_TRACE, "Not enough room for net upgrade!\n" ));
            return FALSE;
        }
    }

    //
    //  Determine which drive to put the catalog on.
    //
    int          iBiggestFreeNTFS = -1;
    int          iBiggestFreeFAT  = -1;
    ULONGLONG    cbMaxFreeSpaceOnNTFS = 0;
    ULONGLONG    cbMaxFreeSpaceOnFAT  = 0;

    for ( unsigned i = 0 ; i < _cDrive; i++ )
    {
        if ( _DriveList[i].IsSmallBootPartition() )
            continue;

        int *       piBiggestFree = &iBiggestFreeFAT;
        ULONGLONG * pcbMaxFree = &cbMaxFreeSpaceOnFAT;
        if ( _DriveList[i].IsNtfs() )
        {
            piBiggestFree = &iBiggestFreeNTFS;
            pcbMaxFree = &cbMaxFreeSpaceOnNTFS;
        }

        if ( *pcbMaxFree < _DriveList[i].GetAvailableSpace() )
        {
            *pcbMaxFree = _DriveList[i].GetAvailableSpace();
            *piBiggestFree = i;
        }
    }


    BOOL fAddNtfsDrives = FALSE;
    CDriveInformation * pCatalogDrive = 0;
    double dblCatalogSizeRatio;

    if ( iBiggestFreeNTFS != -1 )
    {
        //
        // There is an NTFS drive on the system; need to put the catalog
        // there.
        //

        pCatalogDrive = &_DriveList[iBiggestFreeNTFS];
        dblCatalogSizeRatio = CATALOG_SIZE_RATIO_NTFS;
        fAddNtfsDrives = TRUE;
    }
    else if ( iBiggestFreeFAT != -1 )
    {
        pCatalogDrive = &_DriveList[iBiggestFreeFAT];
        dblCatalogSizeRatio = CATALOG_SIZE_RATIO_FAT;
        fAddNtfsDrives = FALSE;
    }

    if ( 0 == pCatalogDrive ||
         pCatalogDrive->GetAvailableSpace() < MIN_CATALOG_SPACE )
    {
        isDebugOut(( DEB_TRACE, "Not enough room for minimal catalog!\n" ));
        return FALSE;
    }

    _pwszCatalogDrive = pCatalogDrive->GetDriveName();
    pCatalogDrive->AddReservedSpace( MIN_CATALOG_SPACE );

    //  Add the primary scope directory for the catalog.
    if ( pwszPrimaryScope && *pwszPrimaryScope )
        AddIncludedDir( pwszPrimaryScope );

    //
    // Iterate through the list of drives once or twice, depending on
    // whether all drives are FAT.
    //
    unsigned maxLoop = _cDrive * ( (fAddNtfsDrives == TRUE) + 1);
    for ( i = 0 ; i < maxLoop; i++ )
    {
        // If end of NTFS enumeration, go back around the loop for FAT drives.
        if (i == _cDrive)
            fAddNtfsDrives = FALSE;

        CDriveInformation & DriveToCheck = _DriveList[i % _cDrive];

        if ( DriveToCheck.IsSmallBootPartition() )
            continue;

        if ( DriveToCheck.IsNtfs() != fAddNtfsDrives )
            continue;

        ULONGLONG cbUsed = DriveToCheck.GetUsedSpace();

        cbUsed = (ULONGLONG) ((LONGLONG)cbUsed * dblCatalogSizeRatio);
        if ( cbUsed < pCatalogDrive->GetAvailableSpace() )
        {
            AddIncludedDir( DriveToCheck.GetDriveName() );
            pCatalogDrive->AddReservedSpace( cbUsed );
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::SaveState
//
//  Synopsis:   Saves the state of the catalog configuration in the registry.
//
//  Arguments:  - NONE -
//
//  Returns:    TRUE upon success, FALSE upon Failure,
//
//  History:    19 Nov 1998   AlanW   Created
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::SaveState( )
{
    Win4Assert( 0 != GetName() && 0 != GetLocation() );

    CCatReg  catReg(_Err);

    if ( !catReg.Init( GetName(), GetLocation() ) )
        return FALSE;

    //
    // Add all the included scopes
    //
    WCHAR const * pwszScope;
    for (unsigned i = 0;  pwszScope = GetIncludedScope( i ); i++)
    {
        if ( !catReg.AddScope( pwszScope, L",,5" ) )
        {
            return FALSE;
        }
    }

    //
    // Now add the excluded scopes
    //
    for (i = 0;  pwszScope = GetExcludedScope( i ); i++)
    {
        if ( !catReg.AddScope( pwszScope, L",,4" ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::AddStringToArray, private static
//
//  Synopsis:   Adds a string to an XArray
//
//  Arguments:  [c]    - current count of strings in array
//              [xa]   - the XArray of strings
//              [pwsz] - string to be added
//
//  Returns:    BOOL - FALSE if any problems, TRUE otherwise
//
//  Notes:      Can throw on allocation failures.
//
//  History:    04 Nov 1998   AlanW   Created
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::AddStringToArray(
    ULONG & c,
    XArray<WCHAR const *> & xa,
    WCHAR const * pwsz )
{
    XPtrST<WCHAR> xpwsz;
    if (pwsz)
    {
        WCHAR * pwszCopy = new WCHAR[ wcslen(pwsz) + 1 ];
        xpwsz.Set(pwszCopy);
        wcscpy( pwszCopy, pwsz );
        pwsz = pwszCopy;
    }

    if ( c >= xa.Count() )
        xa.ReSize( c*2 );

    xa[c] = pwsz;
    c++;
    xpwsz.Acquire();
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::Init
//
//  Synopsis:   Initializes catalog registry key configurator
//
//  Arguments:  [ pwszCatName ] -   catalog name
//              [ pwszLocation] -   catalog location
//
//  Returns:    none - throws upon fatal errors.
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

BOOL CCatReg::Init( WCHAR const *pwszCatName, WCHAR const *pwszLocation)
{

    ISAssert( pwszCatName );

    // create a catalog for the drive
    BOOL fExisted = FALSE;
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsSubKey );

    if ( !reg.CreateKey( pwszCatName, fExisted ) )
    {
        DWORD dwErr = GetLastError();
        isDebugOut(( "created catalogs\\%ws subkey Failed: %d\n",
                      pwszCatName, dwErr ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwErr );

        return FALSE;
    }

    isDebugOut(( DEB_TRACE, "created catalogs\\%ws subkey\n", pwszCatName ));

    wcscpy( _wszCatRegSubKey, wcsRegCatalogsSubKey );
    wcscat( _wszCatRegSubKey, L"\\" );
    wcscat( _wszCatRegSubKey, pwszCatName );

    CWin32RegAccess regSystem( reg.GetHKey(), pwszCatName );
    if ( !regSystem.Set( L"Location", pwszLocation ) )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat Location valued:%ws,  %d\n",
                      pwszLocation, dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    if ( !regSystem.Set( wcsIsIndexingW3Roots,        (DWORD) 0 )  ||
         !regSystem.Set( wcsIsIndexingNNTPRoots,      (DWORD) 0 )
       )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat values: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    // Create a "Scopes" key so a watch can be established in cicat
    // It needs no entries.

    if ( !regSystem.CreateKey( wcsCatalogScopes, fExisted ) )
    {
        DWORD dw = GetLastError();
        isDebugOut(( "created scopes subkey Failed: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    //
    // initialize the reg scopes subkey name
    //
    wcscpy( _wszCatScopeRegSubKey, _wszCatRegSubKey );
    wcscat( _wszCatScopeRegSubKey, L"\\" );
    wcscat( _wszCatScopeRegSubKey, wcsCatalogScopes );

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::AddScope
//
//  Synopsis:   Adds a scope for the current catalog
//
//  Arguments:  [ pwszScopeName ]   -  scope name
//              [ pwszScopeAttrib]  -  scope attributes
//
//  Returns:    none - throws upon fatal errors.
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

BOOL CCatReg::AddScope( WCHAR const * pwszScopeName,
                        WCHAR const * pwszScopeAttrib )
{
    CWin32RegAccess regScopes( HKEY_LOCAL_MACHINE, _wszCatScopeRegSubKey );

    if ( !regScopes.Set( pwszScopeName, pwszScopeAttrib ) )
    {
        DWORD dwRetVal = GetLastError();

        isDebugOut(( "Failed to set scope value:\\%ws,  %d\n",
                          pwszScopeName, dwRetVal ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwRetVal );

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::TrackW3Svc, public
//
//  Synopsis:   Configures catalog to be a 'web' catalog.
//
//  Arguments:  [dwInstance] -- WWW Virtual Server instance number
//
//  Returns:    TRUE if setup succeeded.
//
//  History:    13-May-1998   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CCatReg::TrackW3Svc( DWORD dwInstance )
{
    CWin32RegAccess regSystem( HKEY_LOCAL_MACHINE, _wszCatRegSubKey );

    // Fix for 249655. For a web catalog, wcsGenerateCharacterization and 
    // wcsFilterFilesWithUnknownExtensions should be set as follows.

    if ( !regSystem.Set( wcsIsIndexingW3Roots, 1 ) ||
         !regSystem.Set( wcsW3SvcInstance, dwInstance ) ||
         !regSystem.Set( wcsGenerateCharacterization, 1 ) ||
         !regSystem.Set( wcsFilterFilesWithUnknownExtensions, (DWORD)0 ) ||
         !regSystem.Set( wcsMaxCharacterization, 320 ) )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat values: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\isreg_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "isreg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       cnfgreg.hxx
//
//  Contents:   Precompiled header
//
//  History:    09 Jul 1997     mohamedn    Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <loadperf.h>
#include <stdlib.h>
#include <stdio.h>
#include <direct.h>
#include <eh.h>

#include "isdebug.hxx"

#include "setupqry.hxx"

#include "isreg.hxx"
#include "res.h"

#include <tgrow.hxx>
#include <filtreg.hxx>
#include <tsmem.hxx>
#include <dynstack.hxx>
#include <dynarray.hxx>
#include <cimbmgr.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\res.h ===
#define IDD_WIZPAGE                     111
#define IDT_COMPONENT                   1000
#define IDT_PAGETYPE                    1001
#define IDT_COUNT                       1002
#define IDC_STATIC                      -1


#define IDT_CAT_DIR                     1010
#define IDT_HOME_DIR                    1011
#define IDT_SCRIPT_DIR                  1012
#define IDC_CAT_BROWSE                  1013
#define IDC_FRAME_BANNER                1014

#define IDD_DIRPAGE_V1                  112
#define IDD_DIRPAGE_V2                  113
#define IDD_BROWSEDIRECTORY             114

#define IDB_BANNER_W                    200
#define IDB_BANNER_S                    201


#define IS_MSG_COULD_NOT_SET_SECURITY       503
#define IS_MSG_INDEX_SERVER                 505
#define IS_MSG_COULD_NOT_CREATE_DIR         507
#define IS_MSG_COULD_NOT_MODIFY_REGISTRY    508
#define IS_MSG_COULD_NOT_CONFIGURE_CATALOGS 516
#define IS_MSG_INVALID_INF_HANDLE           518
#define IS_MSG_INVALID_OCM_VERSION          519 
#define IS_MSG_ABORT                        520
#define IS_MSG_CALC_DISK_SPACE_FAILED       521
#define IS_MSG_QUEUE_FILE_OPS_FAILED        522
#define IS_MSG_QUEUE_CONFIG_PARAMS_FAILED   523
#define IS_MSG_SetRegBasedOnMachine_FAILED  524
#define IS_MSG_COMPLETE_INSTALLATION_FAILED 525
#define IS_MSG_EXCEPTION_CAUGHT             526
#define IS_MSG_SETUP_INSTALL_FROM_INFSECTION_FAILED 527
#define IS_MSG_SetDllsToRegister_FAILED     528
#define IS_MSG_SetFilterRegistryInfo_FAILED 529
#define IS_MSG_SetDefaultCatalog_FAILED     531
#define IS_MSG_BAD_MACHINE                  532
#define IS_MSG_NEEDED_HARDWARE              533
#define IS_MSG_DRIVE_ENUMERATION_FAILED     534
#define IS_MSG_LoadPerfCounterTextStrings_FAILED 535
#define IS_MSG_UNEXPECTED_PROCESSOR_TYPE    536
#define IS_MSG_CreateService_FAILED         537
#define IS_MSG_DllRegisterServer_FAILED     538
#define IS_MSG_DLL_REGISTRATION_FAILED      539

#define IS_MSG_LINK_SAMPLE_NAME  540
#define IS_MSG_LINK_ADMIN_NAME   541
#define IS_MSG_LINK_MMC_NAME     542
#define IS_MSG_START_MENU_NAME   543
#define IS_MSG_NTOP              544

#define IS_SERVICE_NAME          600
#define IS_SERVICE_DESCRIPTION   601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\setupqry.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       setupqry.cxx
//
//  Contents:   Indexing Service ocmgr installation routines
//
//  Wish-list:  Seek and destroy old webhits.exe files
//              Migrate all existing catalogs + virtual server catalogs
//
//  History:    8-Jan-97 dlee     Created
//              7-7-97   mohamedn changed to work with NT setup.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <xolemem.hxx>
#include "catcnfg.hxx"

DECLARE_INFOLEVEL( is )

#define COPY_FILES_EVEN_IF_INSTALLED

extern "C" ULONG DbgPrint( LPSTR Format, ... );

//
// external exported routines.
//
extern "C"
{
    BOOL WINAPI DllMain( IN HANDLE DllHandle,
                         IN DWORD  Reason,
                         IN LPVOID Reserved );

    DWORD IndexSrv(   IN     LPCWSTR ComponentId,
                      IN     LPCWSTR SubcomponentId,
                      IN     UINT    Function,
                      IN     UINT    Param1,
                      IN OUT PVOID   Param2 );
}

//
// DLL module instance handle
//
HINSTANCE MyModuleHandle;

//
// Utility routines
//
void    GetPreviousISSetupVersion(void);
DWORD   CompleteInstallation(CError &Err);
DWORD   QueueConfigurationParams( HINF hInf,
                                  HSPFILEQ Param2,
                                  WCHAR const * pwszSectionName,
                                  CError &Err );
DWORD   SetDefaultCatalog(CError &Err);
void    UpgradeIS1toIS3(CError & Err);

DWORD   SetFilterRegistryInfo( BOOL fUnRegister,CError &Err );
DWORD   SetDLLsToRegister(CError & Err);
void    ExcludeSpecialLocations( CCatalogConfig & Cat );
void    OcCleanup( CError & Err );
void    SetupW3Svc(CError &Err);
void DeleteNTOPStartMenu();

DWORD   AddPerfData( CError &Err );
DWORD   RemovePerfData(void);
DWORD   LoadCounterAndDelete( WCHAR const * pwcINI,
                              WCHAR const * pwcH,
                              CError &Err );

void    CreateSharedDllRegSubKey(void);
DWORD   AddRefSharedDll( WCHAR const * pwszDllName );
WCHAR * AppendMultiSZString(WCHAR * pwcTo, WCHAR const * pwcFrom );
DWORD   RegisterDll(WCHAR const * pwcDLL, CError &Err );

BOOL    IsSufficientMemory(void);
void    AddCiSvc(CError &Err);
DWORD   RenameCiSvc( SC_HANDLE hSC, CError &Err );
void    StopService( WCHAR const * pwszServiceName );
void    StartService( WCHAR const * pwszServiceName );
void    MyStartService( CServiceHandle & xSC,
                        WCHAR const    * pwcSVC );
BOOL    MyStopService( CServiceHandle & xSC,
                       WCHAR const *    pwcSVC,
                       BOOL  &          fStopped );
void    DeleteService( WCHAR const * pwszServiceName );


DWORD   SetRegBasedOnMachine(CError &Err);
DWORD   SetRegBasedOnArchitecture(CError &Err);
void    GetMachineInfo(BOOL & fLotsOfMem, DWORD & cCPU );

void DeleteShellLink( WCHAR const * pwcGroup,
                      WCHAR const * pwcName );

//
// hardcoded globals, obtained from is30.INF file
//
// [indexsrv]
INT     g_MajorVersion = 3;
INT     g_dwPrevISVersion = 0;
BOOL    g_fNT4_To_NT5_Upgrade = FALSE;
BOOL    g_fIS1x_To_NT5_Upgrade = FALSE;
BOOL    g_fCiSvcWasRunning = FALSE;
BOOL    g_fCiSvcIsRequested = FALSE;
WCHAR   g_awcSystemDir[MAX_PATH];          // system32 directory
WCHAR   g_awcSourcePath[MAX_PATH * 2];     // inf source location.
WCHAR   g_awcIS1Path[MAX_PATH+1];

OCMANAGER_ROUTINES g_HelperRoutines;

//
// globals needed for OCM
//
SETUP_INIT_COMPONENT     gSetupInitComponent;
BOOL    g_fBatchInstall    = FALSE;
BOOL    g_fInstallCancelled = TRUE;  // Similar to aborted, but caused by user cancel, not internal exception
BOOL    g_fInstallAborted  = FALSE;
BOOL    g_fComponentInitialized = FALSE;
BOOL    g_fUnattended      = FALSE;
BOOL    g_fUpgrade         = FALSE;
BOOL    g_fNtGuiMode       = TRUE;
DWORD   g_NtType           = -1;
BOOL    g_fLocallyOpened   = FALSE;

WCHAR   g_awcProfilePath[MAX_PATH];

//
// keep track if we're selected or not selected
//
BOOL        g_fFalseAlready = FALSE;
unsigned    g_cChangeSelection = 0;

//
// frequently used constants
//
const WCHAR wcsIndexsrvSystem[] = L"indexsrv_system";

//
// frequently used registry keys.
//
const WCHAR wcsRegAdminSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex";
const WCHAR wcsRegCatalogsSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs";
const WCHAR wcsRegCatalogsWebSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs\\web";
const WCHAR wcsRegCatalogsWebPropertiesSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs\\web\\properties";
const WCHAR wcsAllowedPaths[] =
    L"System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths";
const WCHAR wcsPreventCisvcParam[] = L"DonotStartCiSvc";
const WCHAR wcsISDefaultCatalogDirectory[] = L"IsapiDefaultCatalogDirectory";

const WCHAR wszRegProfileKey[] =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
const WCHAR wszRegProfileValue[] = L"ProfilesDirectory";
const WCHAR wszProperties[] = L"properties";

//
// Directory name where system catalog will be placed
//

const WCHAR wszSysVolInfoDirectory[] = L"x:\\System Volume Information";

//
// Array of Dlls to register
//
static WCHAR * apwcDlls[] = {
    L"query.dll",
    L"ciadmin.dll",
    L"ixsso.dll",
    L"nlhtml.dll",
    L"offfilt.dll",
    L"ciodm.dll",
    L"infosoft.dll",
    L"mimefilt.dll",
    L"LangWrbk.dll",
};
const int cDlls = NUMELEM( apwcDlls );

static WCHAR * apwcOldDlls[] = {
    L"cifrmwrk.dll",
    L"fsci.dll",
};
const int cOldDlls = NUMELEM( apwcOldDlls );

//
// utility routines
//
BOOL          OpenInfFile(CError & Err);

CError::CError( )
{
    SetupOpenLog(FALSE); /* don't overwrite existing log file */
}

CError::~CError( )
{
    SetupCloseLog();
}

//+-------------------------------------------------------------------------
//
//  Member:    CError::Report
//
//  Synopsis:  reports a message to various destinations
//
//  Arguments: [LogSeverity]  -- message severity
//             [dwErr]        -- The error code
//             [MessageString]-- printf format string for message
//             [...]          -- variable arguments for message params
//
//  Returns:   none. don't throw.
//
//  History:   2-9-98  mohamedn
//
//--------------------------------------------------------------------------

void CError::Report(
    LogSeverity Severity,
    DWORD dwErr,
    WCHAR const * MessageString,
    ...)
{
    WCHAR awcMsgTemp[MAX_PATH * 2];

    awcMsgTemp[0] = _awcMsg[0] = L'\0';

    va_list va;
    va_start(va, MessageString);

    wvsprintf(awcMsgTemp, MessageString, va);

    va_end(va);

    // prepend on Our modules information.
    wsprintf(_awcMsg, L"setupqry: (%#x) %s\r\n", dwErr, awcMsgTemp);

    if ( !SetupLogError(_awcMsg, Severity) )
    {
        isDebugOut(( DEB_ERROR, "SetupLogError Failed: %d\n", GetLastError() ));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   The usual suspect
//
//  Return:     TRUE        - Initialization succeeded
//              FALSE       - Initialization failed
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        WCHAR DllName[MAX_PATH];

        case DLL_PROCESS_ATTACH:

            MyModuleHandle = (HINSTANCE)DllHandle;

            DisableThreadLibraryCalls( MyModuleHandle );

            if (!GetModuleFileName(MyModuleHandle, DllName, MAX_PATH) ||
                !LoadLibrary( DllName ))
            {
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
} //DllMain

//+-------------------------------------------------------------------------
//
//  Function:   IndexSrv
//
//  Synopsis:   Called by the ocmgr when things happen
//
//  Arguments:  ComponentId    -- "indexsrv_system"
//              SubcomponentId -- the .inf section being operated on
//              Function       -- the operation
//              Param1         -- operation paramater
//              Param2         -- operation paramater
//
//  Returns:    Win32 error code (usually), depends on Function
//
//
//--------------------------------------------------------------------------

DWORD IndexSrv(
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2 )
{
    DWORD   dwRetVal = NO_ERROR;

    isDebugOut(( "IndexSrv, Function %d\n", Function ));

    //
    // if we're aborted, do nothing.
    //
    if ( g_fInstallAborted )
        return dwRetVal;

    CError  Err;

    CSmartException xSmartException;

    TRY
    {

        switch(Function)
        {

        case OC_PREINITIALIZE:
            isDebugOut(( "OC_PREINITIALIZE\n" ));

            GetSystemDirectory( g_awcSystemDir,
                                sizeof g_awcSystemDir / sizeof WCHAR );

            return OCFLAG_UNICODE;

            break;

        case OC_SET_LANGUAGE:
            isDebugOut(( "OC_SET_LANGUAGE\n" ));

            //
            // Param1 = low 16 bits specify Win32 LANG
            // Param2 = unused
            //
            // Return code is a boolean indicating whether we think we
            // support the requested language. We remember the language id
            // and say we support the language. A more exact check might involve
            // looking through our resources via EnumResourcesLnguages() for
            // example, or checking our inf to see whether there is a matching
            // or closely matching [strings] section. We don't bother with
            // any of that here.
            //
            // Locate the component and remember the language id for later use.
            //

            return TRUE;


        case OC_INIT_COMPONENT:
            isDebugOut(( "OC_INIT_COMPONENT\n" ));

            isDebugOut(( DEB_TRACE, "init_component: '%ws'\n", ComponentId ));

            if (OCMANAGER_VERSION <= ((PSETUP_INIT_COMPONENT)Param2)->OCManagerVersion)
            {
                ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;
            }
            else
            {
                ISError( IS_MSG_INVALID_OCM_VERSION, Err, LogSevFatalError );

                isDebugOut(( "wrong ocmgr version!\n" ));

                return ERROR_CALL_NOT_IMPLEMENTED;
            }

            if ( g_fInstallAborted )
            {
                ISError( IS_MSG_ABORT, Err, LogSevFatalError );

                dwRetVal = ERROR_CANCELLED;

                break;
            }

            //
            // Param1 = unused
            // Param2 = points to SETUP_INIT_COMPONENT structure
            //
            // Return code is Win32 error indicating outcome.
            // ERROR_CANCELLED means this component's install will be aborted.
            //
            // Even though this call happens once for each component that this
            // dll installs, we really only need to do our thing once.  This is
            // because the data that OCM passes is the same for all calls.
            //

             if (!g_fComponentInitialized)
             {
                 PSETUP_INIT_COMPONENT InitComponent = (PSETUP_INIT_COMPONENT)Param2;
                 g_HelperRoutines = InitComponent->HelperRoutines;

                 CopyMemory( &gSetupInitComponent, (LPVOID)Param2, sizeof(SETUP_INIT_COMPONENT) );

                 g_fUnattended = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) != 0;
                 g_fUpgrade    = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) != 0;
                 g_fNtGuiMode  = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) == 0;
                 g_NtType      = gSetupInitComponent.SetupData.ProductType;

                 isDebugOut(( DEB_TRACE, "g_fUnattended: %d\n", g_fUnattended ));
                 isDebugOut(( DEB_TRACE, "g_fUpgrade:    %d\n", g_fUpgrade ));
                 isDebugOut(( DEB_TRACE, "g_fNtGuiMode:  %d\n", g_fNtGuiMode ));
                 isDebugOut(( DEB_TRACE, "g_NtType:      %d\n", g_NtType ));

                 if (gSetupInitComponent.ComponentInfHandle == NULL)
                 {
                     if ( !OpenInfFile(Err) )
                     {
                         ISError(IS_MSG_INVALID_INF_HANDLE, Err, LogSevFatalError);
                         dwRetVal = ERROR_CANCELLED;
                     }
                     else
                     {
                         g_fComponentInitialized = TRUE;
                         dwRetVal = NO_ERROR;
                     }
                 }

                 //
                 // determine if this an NT4-->NT5 upgrade
                 //

                 GetPreviousISSetupVersion();

                 if ( g_dwPrevISVersion > 0 && g_dwPrevISVersion < g_MajorVersion )
                 {
                     g_fNT4_To_NT5_Upgrade = TRUE;

                     // g_dwPrevIsVersion is 0 if the ContentIndex key doesn't exist

                     if ( 1 == g_dwPrevISVersion )
                         g_fIS1x_To_NT5_Upgrade = TRUE;
                 }
             }
             break;

        case OC_QUERY_STATE:
            isDebugOut(( "OC_QUERY_STATE\n" ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
                return NO_ERROR;

            //
            // We can't return SubcompUseOcManagerDefault if 1.x is installed
            // the ocmgr registry key for index server won't be set if 1.x was
            // installed using the non-ocmgr installation.  In this case, check
            // if the ContentIndex key exists and if so return SubcompOn.
            //

            if ( ( OCSELSTATETYPE_ORIGINAL == Param1 ) && g_fIS1x_To_NT5_Upgrade )
            {
                isDebugOut(( "Upgrading from 1.x to NT 5, turning on IS by default\n" ));
                isDebugOut(( DEB_ITRACE, "Upgrading from 1.x to NT 5, turning on IS by default\n" ));

                dwRetVal = SubcompOn;
            }
            else
                dwRetVal = SubcompUseOcManagerDefault;

            break;

        case OC_REQUEST_PAGES:
            isDebugOut(( "OC_REQUEST_PAGES\n" ));

            return 0;   // no pages
            // break;

        case OC_QUERY_CHANGE_SEL_STATE:
            isDebugOut(( "OC_QUERY_CHANGE_SEL_STATE\n" ));

            isDebugOut(( "queryChangeSelState %#x, %#x, %#x\n", SubcomponentId, Param1, Param2 ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
            {
                return NO_ERROR;
            }

            if ( Param1 == 0 )
            {
                //
                // we're not selected
                //
                if ( 0 == g_cChangeSelection || !g_fFalseAlready )
                {
                    g_cChangeSelection++;
                    g_fFalseAlready = TRUE;
                }

                g_fCiSvcIsRequested = FALSE;
            }
            else
            {
                //
                // we are selected
                //
                if ( 0 == g_cChangeSelection || g_fFalseAlready )
                {
                    g_cChangeSelection++;
                    g_fFalseAlready = FALSE;
                }

                g_fCiSvcIsRequested = TRUE;
            }

            dwRetVal = TRUE;

            break;


        case OC_CALC_DISK_SPACE:
            isDebugOut(( "OC_CALC_DISK_SPACE\n" ));

            //
            // skip, no files are copied.
            //

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "Calc Disk Space Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_CALC_DISK_SPACE_FAILED, Err, LogSevError );
            }

            break;

        case OC_QUEUE_FILE_OPS:
            isDebugOut(( "OC_QUEUE_FILE_OPS\n" ));

            //
            // Param1 = unused
            // Param2 = HSPFILEQ to operate on
            //
            // Return value is Win32 error code indicating outcome.
            //
            // OC Manager calls this routine when it is ready for files to be
            // copied to effect the changes the user requested. The component
            // DLL must figure out whether it is being installed or uninstalled
            // and take appropriate action.
            // For this sample, we look in the private data section for this
            // component/subcomponent pair, and get the name of an uninstall
            // section for the uninstall case.
            //
            // Note that OC Manager calls us once for the *entire* component
            // and then once per subcomponent.
            //

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "Queue File Operations Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_QUEUE_FILE_OPS_FAILED, Err, LogSevError );
            }

            break;

        case OC_QUERY_STEP_COUNT:
            isDebugOut(( "OC_QUERY_STEP_COUNT\n" ));

            //
            // Param1 = unused
            // Param2 = unused
            //
            // Return value is an arbitrary 'step' count or -1 if error.
            //
            // OC Manager calls this routine when it wants to find out how much
            // work the component wants to perform for nonfile operations to
            // install/uninstall a component/subcomponent.
            // It is called once for the *entire* component and then once for
            // each subcomponent in the component.
            //
            // One could get arbitrarily fancy here but we simply return 1 step
            // per subcomponent. We ignore the "entire component" case.
            //
            if ( !SubcomponentId || _wcsicmp( SubcomponentId,wcsIndexsrvSystem ) )
            {
                return NO_ERROR;
            }

            dwRetVal = 1;

            break;

        case OC_ABOUT_TO_COMMIT_QUEUE:
            isDebugOut(( "OC_ABOUT_TO_COMMIT_QUEUE\n" ));

            if ( !SubcomponentId || _wcsicmp( wcsIndexsrvSystem,SubcomponentId ) )
            {
                return NO_ERROR;
            }

            dwRetVal = QueueConfigurationParams( gSetupInitComponent.ComponentInfHandle,
                                                 (HSPFILEQ)  Param2,
                                                 SubcomponentId,
                                                 Err );
            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut((DEB_ERROR,"QueueConfigurationParams Failed: %d\n",dwRetVal ));

                ISError( IS_MSG_QUEUE_CONFIG_PARAMS_FAILED, Err, LogSevError, dwRetVal );

                return ERROR_CANCELLED;
            }

            dwRetVal = SetRegBasedOnMachine(Err);

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "SetRegBasedOnMachine Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_SetRegBasedOnMachine_FAILED, Err, LogSevError, dwRetVal );
            }

            dwRetVal = SetRegBasedOnArchitecture(Err);

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "SetRegBasedOnArchitecture Failed: %d\n", dwRetVal ));

                Err.Report(LogSevError, dwRetVal, L"SetRegBasedOnArchitecture FAILED");
            }

            break;

        case OC_COMPLETE_INSTALLATION:
            isDebugOut(( "OC_COMPLETE_INSTALLATION\n" ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
            {
                return NO_ERROR;
            }

            dwRetVal = CompleteInstallation(Err);
            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "CompleteInstallation Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_COMPLETE_INSTALLATION_FAILED, Err, LogSevError, dwRetVal );

            }

            if ( g_fLocallyOpened &&
                 INVALID_HANDLE_VALUE != gSetupInitComponent.ComponentInfHandle )
            {
                SetupCloseInfFile(gSetupInitComponent.ComponentInfHandle);

                gSetupInitComponent.ComponentInfHandle = INVALID_HANDLE_VALUE;
            }

            g_fInstallCancelled = FALSE;
            break;

        case OC_CLEANUP:
            isDebugOut(( "OC_CLEANUP\n" ));

            //
            // Do last-minute work now that the metabase is installed
            //

            OcCleanup( Err );

            break;

        case OC_QUERY_IMAGE:
            isDebugOut(( "OC_QUERY_IMAGE\n" ));
            //
            // not used
            //
            break;

    default:
            isDebugOut(( "OC_ message ignored\n" ));
            break;
    }

    isDebugOut(( "IndexSrv is returning %d\n", dwRetVal ));

    return dwRetVal;

}
CATCH (CException, e)
{
    isDebugOut(( "install is aborted, error %#x\n", e.GetErrorCode() ));

    g_fInstallAborted = TRUE;

    if ( g_fLocallyOpened &&
         INVALID_HANDLE_VALUE != gSetupInitComponent.ComponentInfHandle )
    {
        SetupCloseInfFile(gSetupInitComponent.ComponentInfHandle);

        gSetupInitComponent.ComponentInfHandle = INVALID_HANDLE_VALUE;
    }

    ISError( IS_MSG_EXCEPTION_CAUGHT, Err, LogSevError, e.GetErrorCode() );

    dwRetVal = e.GetErrorCode();
}
END_CATCH

    return dwRetVal;
}

//+-------------------------------------------------------------------------
//
//  Function:   OcCleanup
//
//  Synopsis:   Finish setup work now that everything else is installed.  It
//              would be better to do this in OC_COMPLETE_INSTALLATION, but
//              there is no guarantee IIS is installed by that point.
//
//  History:    11-3-98      dlee       Created
//
//--------------------------------------------------------------------------

void OcCleanup( CError & Err )
{
    //
    // Add metabase settings if IIS is around
    //

    TRY
    {
        if ( !g_fInstallCancelled )
            SetupW3Svc(Err);
    }
    CATCH( CException, e )
    {
        // If IIS isn't installed then setting up w3svc will fail.  Ignore
        isDebugOut(( "caught %#x adding w3svc stuff\n", e.GetErrorCode() ));
    }
    END_CATCH

    //
    // Start cisvc service if it was running, we're selected, and not in
    // NT setup mode.
    //

    TRY
    {
        if ( ( g_fCiSvcWasRunning  && !g_cChangeSelection ) ||
             ( g_fCiSvcIsRequested && !g_fNtGuiMode && !g_fInstallCancelled )        )
        {
            StartService(L"CiSvc");
        }
    }
    CATCH( CException, e )
    {
        // Don't hose the install if we can't start the service
        isDebugOut(( "caught %#x starting service\n", e.GetErrorCode() ));
    }
    END_CATCH
} //OcCleanup

//+-------------------------------------------------------------------------
//
//  Function:   OpenInfFile
//
//  Synopsis:   opens a handle to setupqry.inf file
//
//  Returns:    True upon success, False upon failure.
//
//  History:   6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

BOOL OpenInfFile(CError & Err)
{
  WCHAR InfPath[MAX_PATH];

  DWORD dwRetVal = GetModuleFileName( MyModuleHandle, InfPath, NUMELEM(InfPath));

  if ( 0 == dwRetVal )
  {
    isDebugOut(( DEB_ERROR, "GetModuleFileName() Failed: %d\n", GetLastError() ));

    return FALSE;
  }

  LPWSTR p = wcsrchr( InfPath, L'\\' );
  if (p)
  {
      wcscpy( p+1, L"setupqry.inf" );

      gSetupInitComponent.ComponentInfHandle = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );

      if (gSetupInitComponent.ComponentInfHandle == INVALID_HANDLE_VALUE)
      {
        isDebugOut(( DEB_ERROR, "SetupOpenInfFile(%ws) Failed: %d\n", InfPath, GetLastError() ));

        return FALSE;
      }
  }
  else
  {
    return FALSE;
  }

  g_fLocallyOpened = TRUE;

  return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   QueueConfigurationParams
//
//  Synopsis:   queue-up an inf section to install
//
//  Returns:    NO_ERROR upon success, win32 error upon failure
//
//  History:   6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

DWORD QueueConfigurationParams( HINF hInf, HSPFILEQ Param2, WCHAR const * pwszSectionName, CError &Err )
{

    BOOL fOk = SetupInstallFromInfSection( 0,
                                           hInf,
                                           pwszSectionName,
                                           SPINST_REGISTRY,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0  );
    if ( !fOk )
    {
        isDebugOut(( DEB_ERROR, "SetupInstallFromInfSection(%ws) Failed: %d\n",
                                 pwszSectionName, GetLastError() ));

        ISError( IS_MSG_SETUP_INSTALL_FROM_INFSECTION_FAILED, Err,
                 LogSevError, GetLastError() );
    }

    return  ( fOk ? NO_ERROR : GetLastError() );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetupW3Svc
//
//  Synopsis:   Setup catalogs and script mappings for IIS
//
//  Arguments:  [Err] -- Error reporting object
//
//  History:    13-May-1998   KyleP   Created
//
//--------------------------------------------------------------------------

void SetupW3Svc(CError &Err)
{
    BOOL fCurrentlyChecked = g_HelperRoutines.QuerySelectionState(
                       g_HelperRoutines.OcManagerContext,
                       wcsIndexsrvSystem,
                       OCSELSTATETYPE_CURRENT );

    isDebugOut(( "currently checked: %d\n", fCurrentlyChecked ));

    TRY
    {
        do
        {
            //
            // Initialize/Uninitialize COM.  Allow any old mode, and allow
            // for the fact that some other broken component may have left
            // COM initialized.
            //

            XCom xcom( TRUE );
            WCHAR awc[MAX_PATH];

            isDebugOut(( "SetupW3Svc\n" ));
            isDebugOut(( "  g_fCiSvcIsRequested: %d\n", g_fCiSvcIsRequested ));
            isDebugOut(( "  g_fNtGuiMode: %d\n", g_fNtGuiMode ));
            isDebugOut(( "  g_cChangeSelection: %d\n", g_cChangeSelection ));
            isDebugOut(( "  g_dwPrevISVersion: %d \n", g_dwPrevISVersion ));
            isDebugOut(( "  g_fUpgrade: %d\n", g_fUpgrade ));

            {
                //
                // Is W3Svc even installed?
                //

                CMetaDataMgr mdMgr( TRUE, W3VRoot );

                //
                // Guess so.  We didn't throw.  Now, add the script mappings if
                // if appropriate:
                //
                // If the checkbox is selected, add scriptmaps if
                //    clean install or
                //    add/remove and they changed the state of the checkbox
                //    upgrade and scriptmaps weren't deleted by hand by the user
                //
                // Delete scriptmaps if
                //    Checkbox is unchecked and there was a change in the selection state
                //
                // Note the state of the checked/unchecked variable g_fCiSvcIsRequested
                // is only valid in add/remove AND if the user has changed the selection.
                // So this code uses fCurrentlyChecked instead.
                //

                if ( ( fCurrentlyChecked ) &&
                     ( g_fNtGuiMode || ( 0 != g_cChangeSelection ) ) )
                {
                    //
                    // IDQ and WEBHITS are always in System32
                    //
    
                    if ( (MAX_PATH - wcslen(g_awcSystemDir)) < 30 )  // DLL won't fit
                        break;
    
                    wcscpy( awc, L".idq," );
                    wcscat( awc, g_awcSystemDir );
    
                    //
                    // Add IDQ if add/remove                        OR
                    //            clean install                     OR
                    //            there is already a scriptmap      OR
                    //            there already is a (possibly old) scriptmap pointing at the expected dll
                    //
                    //
                    // Note: the "IIS lockdown" tool points our scriptmaps at
                    //       404.dll; it doesn't delete them.  I have no idea why.
                    //
                    //
                    // scriptmap flags -- 0x2 is obsolete (apparently)
                    //
                    // #define MD_SCRIPTMAPFLAG_SCRIPT                     0x00000001
                    // #define MD_SCRIPTMAPFLAG_CHECK_PATH_INFO            0x00000004
                    //
                    // Can't check path info for .htw due to null.htw support
                    // 
    
                    wcscat( awc, L"\\idq.dll,7,GET,HEAD,POST" );
                    if ( ( !g_fNtGuiMode ) ||
                         ( g_fNtGuiMode && !g_fUpgrade ) ||
                         ( 0 == g_dwPrevISVersion ) ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".idq", L"idq.dll" ) ) ) 
                        mdMgr.AddScriptMap( awc );
    
                    //
                    // Add IDA if add/remove or there is already a valid scriptmap
                    //
    
                    awc[3] = L'a';
                    if ( ( !g_fNtGuiMode ) ||
                         ( g_fNtGuiMode && !g_fUpgrade ) ||
                         ( 0 == g_dwPrevISVersion ) ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".ida", L"idq.dll" ) ) ) 
                        mdMgr.AddScriptMap( awc );
    
                    //
                    // Add HTW if add/remove or there is already a valid scriptmap
                    //
    
                    wcscpy( awc, L".htw," );
                    wcscat( awc, g_awcSystemDir );
                    wcscat( awc, L"\\webhits.dll,3,GET,HEAD,POST" );
    
                    if ( ( !g_fNtGuiMode ) ||
                         ( g_fNtGuiMode && !g_fUpgrade ) ||
                         ( 0 == g_dwPrevISVersion ) ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".htw", L"webhits.dll" ) ) ) 
                        mdMgr.AddScriptMap( awc );
    
                    //
                    // Add IS script maps as in-process.  Always do this.
                    //
    
                    wcscpy( awc, g_awcSystemDir );
                    wcscat( awc, L"\\idq.dll" );
                    mdMgr.AddInProcessIsapiApp( awc );
    
                    //
                    // By default, run this OOP.  The user can run in IP if they need to
                    // webhit files on remote virtual roots.
                    //

                    #if 0
                        wcscpy( awc, g_awcSystemDir );
                        wcscat( awc, L"\\webhits.dll" );
                        mdMgr.AddInProcessIsapiApp( awc );
                    #endif
                }

                if ( ( !fCurrentlyChecked ) && ( 0 != g_cChangeSelection ) )
                {
                    mdMgr.RemoveScriptMap( L".idq" );
                    mdMgr.RemoveScriptMap( L".ida" );
                    mdMgr.RemoveScriptMap( L".htw" );
                }

                //
                // Make sure it makes it out to disk
                //

                mdMgr.Flush();
            }

            //
            // Only create a web catalog if everything looks like a new install...
            //

            BOOL fNew = FALSE;

            TRY
            {
                CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsWebSubKey );

                if ( reg.Ok() )
                {
                    WCHAR   wcsSubKeyName[MAX_PATH+1];
                    DWORD   cwcName = sizeof wcsSubKeyName / sizeof WCHAR;

                    if ( reg.Enum( wcsSubKeyName, cwcName ) )
                    {
                        // There is at least one subkey
                        do 
                        {
                            //
                            // if there is a subkey other than properties, 
                            // we're not createing a new web catalog
                            //
                            if ( 0 != _wcsicmp( wcsSubKeyName, wszProperties ) )
                            {
                                fNew = FALSE;
                                break;
                            }  
                            else
                                 fNew = TRUE;

                        } while ( reg.Enum( wcsSubKeyName, cwcName ) );
                    }
                    else
                        fNew = TRUE;
                }
                else 
                    fNew = TRUE;
            }
            CATCH( CException, e )
            {
                fNew = TRUE;
            }
            END_CATCH

            if ( !fNew )
                break;

            //
            // Must look like a default install...
            //

            CMetaDataMgr mdMgrDefaultServer( FALSE, W3VRoot, 1 );
            mdMgrDefaultServer.GetVRoot( L"/", awc );

            unsigned ccRoot = wcslen(awc) - 8;  // <path> - "\wwwroot"

            if ( 0 != _wcsicmp( awc + ccRoot, L"\\wwwroot" ) )
                break;

            awc[ccRoot] = 0;

            //
            // Add a web catalog.
            //

            CCatReg CatReg(Err);
            CatReg.Init( L"Web", awc );
            CatReg.TrackW3Svc();

            //
            // set ISAPIDefaultCatalogDirectory to Web
            //

            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

            if ( !reg.Set( wcsISDefaultCatalogDirectory, L"Web" ) )
            {
                ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err,
                         LogSevWarning, GetLastError() );
                return;
            }
        } while(FALSE);

        isDebugOut(( "successfully added w3svc stuff\n" ));
    }
    CATCH( CException, e )
    {
        isDebugOut(( "caught %x in SetupW3Svc\n", e.GetErrorCode() ));
    }
    END_CATCH
}

//+-------------------------------------------------------------------------
//
//  Function:   CompleteInstallation
//
//  Synopsis:   called by NT setup to cofigure Index server for operation.
//
//  Returns:    SCODE, S_OK upon success, other values upon failure
//
//  History:    6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

DWORD CompleteInstallation(CError &Err)
{
    SCODE sc          = S_OK;
    DWORD dwRetVal    = 0;
    DWORD dwLastError = 0;

    //MessageBox(NULL, L"BREAK HERE", NULL, MB_OK);

    TRY
    {

       //
       // Delete the "DonotStartCiSvc" registry parameter
       //

       CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
       reg.Remove(wcsPreventCisvcParam);

       dwRetVal = SetDLLsToRegister (Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetDllsToRegister Failed: %d", dwRetVal ));

            ISError( IS_MSG_SetDllsToRegister_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       dwRetVal = SetFilterRegistryInfo(FALSE, Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetFilterRegistryInfo Failed: %d", dwRetVal ));

            ISError( IS_MSG_SetFilterRegistryInfo_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       dwRetVal = AddPerfData(Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "AddPerfData Failed: %d\n",dwRetVal));

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       //
       // stop cisvc
       //

       StopService(L"cisvc");

       //
       // Upgrade 1.1 to 3.0 if needed.  Must happen *before* AddCiSvc().
       //

       UpgradeIS1toIS3(Err);

       //
       // Delete the NTOP start menu items IS created
       //

       DeleteNTOPStartMenu();

       //
       // configure catalogs
       //

       dwRetVal = SetDefaultCatalog(Err);

       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetDefaultCatalog Failed: %d\n",dwRetVal));

            ISError( IS_MSG_SetDefaultCatalog_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       //
       // if selection count is odd (user changed the selection),
       // delete the service to create a new one.  Also delete and
       // re-create if we're upgrading IS 1.x.
       //

       if ( ( !g_fUpgrade && ( g_cChangeSelection & 0x1 ) ) ||
            1 == g_dwPrevISVersion )
            DeleteService(L"cisvc");

       //
       // add the service
       //

       AddCiSvc(Err);
    }
    CATCH( CException, e )
    {
       isDebugOut(( DEB_ERROR, "Caught Exception in CompleteInstallation: %d\n",e.GetErrorCode() ));

       ISError( IS_MSG_EXCEPTION_CAUGHT, Err, LogSevError, e.GetErrorCode() );

       sc = e.GetErrorCode();
       isDebugOut(( "Caught Exception in CompleteInstallation: %#x\n", sc ));

    }
    END_CATCH

    return sc;

} //CompleteInstallation

//+-------------------------------------------------------------------------
//
//  Function:   UpgradeIS1toIS3
//
//  Synopsis:   sets ISapiDefaultCatalogDirectory param if we're upgrading
//              from 1.0 or 1.1 to 3.0
//
//  Returns:    none.
//
//  History:    01-May-1998      mohamedn        created
//              05-Sep-1998      KyleP           Start service on upgrade
//
//  Notes:      This *must* be called before AddCisvc, since the decision
//              about whether to start the service may be changed in
//              this function.
//
//--------------------------------------------------------------------------

void UpgradeIS1toIS3(CError &Err)
{
    if (  !g_fNT4_To_NT5_Upgrade  ||  g_dwPrevISVersion >= 2 )
    {
        return;
    }

    g_awcIS1Path[0] = L'\0';

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

        reg.Get( wcsISDefaultCatalogDirectory, g_awcIS1Path, NUMELEM( g_awcIS1Path ) );

        if ( 0 == wcslen(g_awcIS1Path) || g_awcIS1Path[1] != L':' )
        {
            //
            // nothing to do.
            //
            g_awcIS1Path[0] = L'\0';
            return;
        }
    }

    //
    // The 'Catalogs' key needs to be created.
    //

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
        BOOL fExisted;

        if ( !reg.CreateKey( L"Catalogs", fExisted ) )
        {
            DWORD dw = GetLastError();

            isDebugOut(( DEB_ERROR, "created catalogs subkey Failed: %d\n", dw ));

            ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, Err , LogSevFatalError, dw );

            return;
        }
    }

    //
    // create the web catalog
    //

    CCatReg CatReg(Err);

    CatReg.Init( L"Web", g_awcIS1Path );
    CatReg.TrackW3Svc();

    //
    // set ISAPIDefaultCatalogDirectory to Web
    //

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
    if ( !reg.Set( wcsISDefaultCatalogDirectory, L"Web" ) )
    {
        ISError(IS_MSG_COULD_NOT_MODIFY_REGISTRY , Err, LogSevWarning, GetLastError() );

        return;
    }

    //
    // CI was running before the upgrade, so make sure it is running after
    // the upgrade as well.
    //

    g_fCiSvcIsRequested = TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetPreviousISSetupVersion
//
//  Synopsis:   gets version of previous installed IS, if any.
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    10-16-97    mohamedn    created
//
//--------------------------------------------------------------------------

void GetPreviousISSetupVersion(void)
{
    HKEY  hKey   = 0;
    DWORD dwType = 0;
    DWORD dwVal  = 0;
    DWORD cb     = sizeof DWORD;

    //
    // If it's not an upgrade, don't try to get the previous version as someone is
    // now writing contentindex\DoNotStartCisvc to the registry so we would
    // otherwise assume it's an upgrade without this check.
    //

    if ( !g_fUpgrade )
        return;

    LONG lRetVal = RegOpenKeyEx( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey, 0, KEY_READ, &hKey );

    if ( ERROR_SUCCESS == lRetVal )
    {
        lRetVal = RegQueryValueEx( hKey,
                                   L"MajorVersion",
                                   0,
                                   &dwType,
                                   (BYTE *)&dwVal,
                                   &cb );
        if ( ERROR_SUCCESS == lRetVal )
            g_dwPrevISVersion = dwVal;
        else
            g_dwPrevISVersion = 1;  // We didn't write this key in V1.

        RegCloseKey( hKey );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:  SetDefaultCatalog
//
//  Synopsis:  Configures IS catalog for indexing local file system based on
//             available disk space.
//
//  Arguments: none
//
//  Returns:   ErrorSuccess upon success, error value upon failure.
//
//  History:   9-10-97  mohamedn
//
//--------------------------------------------------------------------------

DWORD SetDefaultCatalog(CError &Err)
{
    BOOL     fExisted;
    DWORD    dwRetVal = NO_ERROR;

    if ( !IsSufficientMemory() )
    {
        ISError( IS_MSG_BAD_MACHINE, Err, LogSevError );

        ISError( IS_MSG_NEEDED_HARDWARE, Err, LogSevError );

        return ERROR_SUCCESS;
    }

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

        if (!reg.CreateKey( L"Catalogs", fExisted ) )
        {
            DWORD dw = GetLastError();

            isDebugOut(( DEB_ERROR, "created catalogs subkey Failed: %d\n", dw ));

            ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, Err , LogSevFatalError, dw );

            return dw;
        }
    }

    //
    // return if Catalogs key exists, don't overwrite existing configuration
    //
    if ( fExisted && !g_fNT4_To_NT5_Upgrade )
    {
        return ERROR_SUCCESS;
    }

    //
    // Find the default profile path (Usually %windir%\Profiles)
    //

    CWin32RegAccess regProfileKey( HKEY_LOCAL_MACHINE, wszRegProfileKey );

    g_awcProfilePath[0] = L'\0';
    WCHAR wcTemp[MAX_PATH+1];

    if ( regProfileKey.Get( wszRegProfileValue, wcTemp, NUMELEM(wcTemp) ) )
    {
        unsigned ccTemp2 = ExpandEnvironmentStrings( wcTemp,
                                                   g_awcProfilePath,
                                                   NUMELEM(g_awcProfilePath) );
    }

    CCatalogConfig   Cat(Err);
    Cat.SetName( L"System" );

    if ( !Cat.InitDriveList() )
    {
        ISError( IS_MSG_DRIVE_ENUMERATION_FAILED, Err, LogSevError, GetLastError() );

        return ERROR_INSTALL_FAILURE;
    }

    BOOL bRetVal = Cat.ConfigureDefaultCatalog( g_awcProfilePath );

    if (bRetVal)
    {
        //
        // add paths to exclude indexing IE temp files.
        //
        ExcludeSpecialLocations( Cat );

        //
        // Set the catalog location
        wcsncpy(wcTemp, wszSysVolInfoDirectory, sizeof wcTemp / sizeof WCHAR);
        wcTemp[ (sizeof wcTemp / sizeof WCHAR) - 1 ] = 0;
        wcTemp[0] = *(Cat.GetCatalogDrive());
        Cat.SetLocation( wcTemp );

        // NOTE:  The catalog path will be created when first accessed by
        //        CClientDocStore.

        Cat.SaveState();
    }

    return ( bRetVal ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDLLsToRegister
//
//  Synopsis:   Sets the "DLLsToRegister" value in the registry
//
//  History:    19-Jun-97       t-elainc        Created
//
//--------------------------------------------------------------------------

DWORD SetDLLsToRegister(CError &Err)
{
    WCHAR * apwc2[cDlls];
    unsigned cwcTotal = 1;

    // store full pathnames in array 2

    for (int i = 0; i < cDlls; i++)
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( apwcDlls[i] );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR filepath[MAX_PATH];
        wcscpy(filepath, g_awcSystemDir );
        wcscat(filepath,  L"\\" );
        wcscat(filepath, apwcDlls[i] );

        cwcTotal += ( cwc + 1 );

        apwc2[i] = new WCHAR[MAX_PATH];
        wcscpy(apwc2[i], filepath);
    }

    WCHAR * apwc2Old[cOldDlls];

    // store full old pathnames in array 2

    for (i = 0; i < cOldDlls; i++)
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( apwcOldDlls[i] );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR filepath[MAX_PATH];
        wcscpy(filepath, g_awcSystemDir );
        wcscat(filepath,  L"\\" );
        wcscat(filepath, apwcOldDlls[i] );

        apwc2Old[i] = new WCHAR[MAX_PATH];
        wcscpy(apwc2Old[i], filepath);
    }

    if ( cwcTotal >= 4096 )
        return 0;

    unsigned cwcRemaining = 4096 - cwcTotal;

    WCHAR awc[4096];   //buffer for new list
    WCHAR *pwc = awc;  //pointer to list
    *pwc = 0;          //set first slot in array to null

    // put our dlls in the beginning

    for (int i = 0; i < cDlls; i++)
        pwc = AppendMultiSZString(pwc, apwc2[i]);
    
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

    {
        WCHAR awcOld[4096]; //the old buffer list of files to register
        if ( reg.Get( L"DLLsToRegister",
                      awcOld,
                      sizeof awcOld / sizeof WCHAR ) )
        {
            WCHAR *p = awcOld;
            while ( 0 != *p )
            {
                // Leave dlls not in our list -- 3rd party dlls

                BOOL fFound = FALSE;
                for ( int i = 0; i < cDlls; i++ )
                {
                    if (!_wcsicmp(p, apwc2[i]) )
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                // Remove old dlls from the list (fsci & cifrmwrk)

                if ( !fFound )
                {
                    for ( int i = 0; i < cOldDlls; i++ )
                    {
                        if (!_wcsicmp(p, apwc2Old[i]) )
                        {
                            fFound = TRUE;
                            break;
                        }
                    }
                }

                if (!fFound)
                {
                    cwcTotal += ( wcslen( p ) + 1 );

                    if ( cwcTotal >= 4096 )
                        return 0;

                    pwc = AppendMultiSZString(pwc, p);
                }

                p += ( wcslen(p) + 1 );
            }
        }

        *pwc++ = 0;
    }

    for (int j = 0; j < cDlls; j++)
        delete apwc2[j];

    for (j = 0; j < cOldDlls; j++)
        delete apwc2Old[j];

    if ( !reg.SetMultiSZ( L"DLLsToRegister",
                          awc,
                          (ULONG)(pwc-awc) * sizeof WCHAR ) )
    {
        DWORD dw = GetLastError();
        ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err, LogSevFatalError, dw );
        return dw;
    }

    return NO_ERROR;
} //SetDLLsToRegister

//+-------------------------------------------------------------------------
//
//  Function:   AppendMultiSZString
//
//  Synopsis:   Copies one string to another.
//
//  Returns:    Pointer to one wchar beyond the end of the copy
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

WCHAR * AppendMultiSZString(
    WCHAR *       pwcTo,
    WCHAR const * pwcFrom )
{
    isDebugOut((DEB_TRACE, "language or dll installed: '%ws'\n", pwcFrom ));

    unsigned x = wcslen( pwcFrom );
    wcscpy( pwcTo, pwcFrom );
    return pwcTo + x + 1;
} //AppendMultiSZString

//+-------------------------------------------------------------------------
//
//  Function:   ExcludeSpecialLocations, private
//
//  Synopsis:   Writes profile-based exclude scopes into the registry
//
//  Arguments:  none
//
//  History:    28-Aug-1998   KyleP    Created
//
//--------------------------------------------------------------------------

WCHAR const wszRegShellSpecialPathsKey[] =
    L".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

WCHAR const * const awszRegShellSpecialPathsValue[] = {
    L"AppData",
    L"Local Settings"
};

WCHAR const wszUserProfile[] = L"%USERPROFILE%";

void ExcludeSpecialLocations( CCatalogConfig & Cat )
{
    //
    // First, find the default profile path (Usually %windir%\Profiles)
    //

    WCHAR wcTemp[MAX_PATH+1];

    if ( g_awcProfilePath[0] )
    {
        WCHAR wcTemp2[MAX_PATH+1];
        wcsncpy( wcTemp2, g_awcProfilePath, sizeof wcTemp2 / sizeof WCHAR );
        wcTemp2[ (sizeof wcTemp2 / sizeof WCHAR) - 1 ] = 0;
        unsigned ccTemp2 = wcslen( wcTemp2 );

        //
        // Append the wildcard, for user profile directory
        //

        wcscpy( wcTemp2 + ccTemp2, L"\\*\\" );
        ccTemp2 += 3;

        //
        // Go through and look for special shell paths, which just happen
        // to include all our special cases too.
        //

        CWin32RegAccess regShellSpecialPathsKey( HKEY_USERS, wszRegShellSpecialPathsKey );

        for ( unsigned i = 0;
              i < NUMELEM(awszRegShellSpecialPathsValue);
              i++ )
        {
            if ( regShellSpecialPathsKey.Get( awszRegShellSpecialPathsValue[i],
                                              wcTemp, NUMELEM(wcTemp), FALSE) )
            {
                if ( RtlEqualMemory( wszUserProfile, wcTemp,
                                     sizeof(wszUserProfile) - sizeof(WCHAR) ) )
                {
                    wcscpy( wcTemp2 + ccTemp2, wcTemp + NUMELEM(wszUserProfile) );
                    wcscpy( wcTemp, wcTemp2 );
                }
                
                if ( wcschr( wcTemp, L'%' ) != 0 )
                {
                    WCHAR wcTemp3[MAX_PATH+1];
                    unsigned ccTemp3 = ExpandEnvironmentStrings(
                                                                wcTemp,
                                                                wcTemp3,
                                                                NUMELEM(wcTemp3) );
                    if ( 0 != ccTemp3 )
                        wcscpy( wcTemp, wcTemp3 );
                }

                wcscat( wcTemp, L"\\*" );
                isDebugOut(( DEB_TRACE, "Exclude: %ws\n", wcTemp ));

                Cat.AddExcludedDirOrPattern( wcTemp );
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   AddPerfData
//
//  Synopsis:   Runs unlodctr and lodctr on Index Server perf data
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD AddPerfData(CError &Err)
{
    // add counters if installing

    DWORD dwError = NO_ERROR;

    // remove existing counters (if they exist)

    RemovePerfData();

    isDebugOut((DEB_TRACE, "Installing perf data\n" ));

    dwError = LoadCounterAndDelete( L"perfci.ini", L"perfci.h", Err );

    if ( ERROR_SUCCESS == dwError )
    {
        dwError = LoadCounterAndDelete( L"perffilt.ini", L"perffilt.h", Err );

        if ( ERROR_SUCCESS == dwError )
        {
            dwError = LoadCounterAndDelete( L"perfwci.ini", L"perfwci.h", Err );
        }
    }

    return NO_ERROR; // Ignore failures return dwError;
} //AddPerfData

//+-------------------------------------------------------------------------
//
//  Function:   LoadCounterAndDelete
//
//  Synopsis:   Loads perf counters for a .ini and a .h, then deletes
//              the files.  Assumes the files are in system32.
//
//  Arguments:  [pwcINI] -- Name w/o path of .ini file.
//              [pwcH]   -- Name w/o path of .h file.
//
//  History:    30-Jan-97 dlee     Created
//              23-May-97 KyleP    Use LoadPerfCounterTextStrings API
//
//--------------------------------------------------------------------------

DWORD LoadCounterAndDelete(
    WCHAR const * pwcINI,
    WCHAR const * pwcH,
    CError &Err)
{
    unsigned cwc = wcslen( L"lodctr " ) + wcslen( g_awcSystemDir ) + 1 + wcslen( pwcINI );

    if ( cwc >= MAX_PATH )
        return 0;

    WCHAR awc[MAX_PATH];

    WCHAR const awcLodctr[] = L"lodctr ";

    wcscpy( awc, awcLodctr );
    wcscat( awc, g_awcSystemDir );
    wcscat( awc, L"\\" );
    wcscat( awc, pwcINI );

    DWORD dwError = (DWORD)LoadPerfCounterTextStrings( awc,       // .INI file
                                                       TRUE );    // Quiet mode

    if ( ERROR_SUCCESS != dwError )
    {
        isDebugOut(( DEB_ERROR, "Error %d from LoadPerfCounterTextStrings %ws\n", dwError, awc ));
        isDebugOut(( "Error %d from LoadPerfCounterTextStrings %ws\n", dwError, awc ));

        ISError( IS_MSG_LoadPerfCounterTextStrings_FAILED, Err, LogSevError, dwError );

        return dwError;
    }

    return dwError;
} //LoadCounterAndDelete

//+-------------------------------------------------------------------------
//
//  Function:   RemovePerfData
//
//  Synopsis:   Runs unlodctr and lodctr on Index Server perf data
//
//  History:    08-Jan-97 dlee     Created
//              23-May-97 KyleP    Use UnloadPerfCounterTextStrings API
//
//--------------------------------------------------------------------------

DWORD RemovePerfData()
{
    // remove existing counters (if they exist )

    DWORD dw0 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ContentIndex",  // Key
                                                     TRUE );           // Quiet mode

    DWORD dw1 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ContentFilter", // Key
                                                     TRUE );           // Quiet mode

    DWORD dw2 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ISAPISearch",   // Key
                                                     TRUE );           // Quiet mode

    if ( NO_ERROR != dw0 )
    {
        isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ContentIndex failed with 0x%x\n", dw0));
        return dw0;
    }
    else if ( NO_ERROR != dw1 )
    {
        isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ContentFilter failed with 0x%x\n", dw1));
        return dw1;
    }
    else
    {
        if ( NO_ERROR != dw2 )
        {
            isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ISAPISearch failed with 0x%x\n", dw0));
        }
        return dw2;
    }
} //RemovePerfData


//+-------------------------------------------------------------------------
//
//  Function:   IsSufficientMemory
//
//  Synopsis:   Determines available physical memory
//
//  Arguments:  none
//
//  Returns:    TRUE  if physical memory > required phys. memory
//              FALSE otherwise.
//
//  History:    6-27-97     mohamedn  created
//
//--------------------------------------------------------------------------

BOOL IsSufficientMemory(void)
{
    // 32MB RAM.machine, taking into account up to 1M used by the system.
    const ULONGLONG MIN_PHYSICAL_MEMORY = 30*ONE_MB;

    MEMORYSTATUSEX memoryStatus;

    RtlZeroMemory(&memoryStatus, sizeof memoryStatus );

    memoryStatus.dwLength = sizeof memoryStatus;

    GlobalMemoryStatusEx(&memoryStatus);

    return ( MIN_PHYSICAL_MEMORY <= memoryStatus.ullTotalPhys );
}

//+-------------------------------------------------------------------------
//
//  Function:   AddCiSvc
//
//  Synopsis:   Creates the cisvc service
//
//  Arguments:  [Err] -- The error object to update
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void AddCiSvc(CError &Err)
{
    DWORD dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_CREATE_SERVICE );

    CServiceHandle xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ITRACE, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    WCHAR wszServiceDependencyList[MAX_PATH];

    RtlZeroMemory(wszServiceDependencyList, MAX_PATH * sizeof WCHAR );

    wcscpy( wszServiceDependencyList, L"RPCSS" );

    WCHAR wszServicePath[300];

    unsigned cwc = wcslen( g_awcSystemDir ) + wcslen( L"\\cisvc.exe" );

    if ( cwc >= ( sizeof wszServicePath / sizeof WCHAR ) )
        return;

    wcscpy(wszServicePath, g_awcSystemDir );
    wcscat(wszServicePath, L"\\cisvc.exe" );

    do
    {
        dwLastError = 0;

        CResString strSvcDisplayName(IS_SERVICE_NAME);

        SC_HANDLE hNewSC = CreateService( hSC,           // handle to SCM database
                             TEXT("cisvc"),              // pointer to name of service to start
                             strSvcDisplayName.Get(),    // pointer to display name
                             SERVICE_ALL_ACCESS,         // type of access to service
                             SERVICE_WIN32_SHARE_PROCESS, // type of service
                             g_fCiSvcIsRequested ?
                                 SERVICE_AUTO_START :
                                 SERVICE_DISABLED,       // when to start service
                             SERVICE_ERROR_NORMAL,       // severity if service fails to start
                             wszServicePath,
                             NULL,                       // pointer to name of load ordering group
                             NULL,                       // pointer to variable to get tag identifier
                             wszServiceDependencyList,   // pointer to array of dependency names
                             NULL,                       // pointer to account name of service
                             NULL                        // pointer to password for service account
                           );

        CServiceHandle xService( hNewSC );

        if ( 0 == hNewSC )
        {
            dwLastError = GetLastError();

            if ( ERROR_SERVICE_EXISTS == dwLastError )
                dwLastError = RenameCiSvc( hSC, Err );
            else if ( ERROR_SERVICE_MARKED_FOR_DELETE != dwLastError )
            {
                isDebugOut(( DEB_ERROR, "CreateService() Failed: %x\n", dwLastError ));

                ISError( IS_MSG_CreateService_FAILED, Err, LogSevError, dwLastError );

                THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
            }
        }
        else
        {
            xService.Free();

            // We added the service, now set the description.

            RenameCiSvc( hSC, Err );
        }
    } while ( ERROR_SERVICE_MARKED_FOR_DELETE == dwLastError );
} //AddCiSvc

//+-------------------------------------------------------------------------
//
//  Function:   RenameCiSvc
//
//  Synopsis:   Renames the cisvc service to "Indexing Service".
//
//  History:    05-Sep-1998   KyleP     Created
//
//--------------------------------------------------------------------------

DWORD RenameCiSvc( SC_HANDLE hSC, CError &Err)
{
    DWORD     dwLastError = 0;

    SC_HANDLE hCisvc = OpenService( hSC, L"cisvc", SERVICE_CHANGE_CONFIG );

    CServiceHandle xhCisvc( hCisvc );

    if( 0 == hCisvc )
    {
        dwLastError = GetLastError();
        isDebugOut(( DEB_ERROR, "OpenService(cisvc) Failed: 0x%x\n", dwLastError ));
        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    CResString strSvcDisplayName(IS_SERVICE_NAME);

    if ( !ChangeServiceConfig( hCisvc,               // handle to service
                               SERVICE_NO_CHANGE,    // type of service
                               SERVICE_NO_CHANGE,    // when to start service
                               SERVICE_NO_CHANGE,    // severity if service fails to start
                               0,                    // pointer to service binary file name
                               0,                    // pointer to load ordering group name
                               0,                    // pointer to variable to get tag identifier
                               0,                    // pointer to array of dependency names
                               0,                    // pointer to account name of service
                               0,                    // pointer to password for service account
                               strSvcDisplayName.Get() ) )   // pointer to display name);
    {
        dwLastError = GetLastError();
    }

    SERVICE_DESCRIPTION sd;
    CResString strSvcDescription(IS_SERVICE_DESCRIPTION);
    sd.lpDescription = (WCHAR *)strSvcDescription.Get();

    if ( !ChangeServiceConfig2( hCisvc,
                                SERVICE_CONFIG_DESCRIPTION,
                                (LPVOID)&sd
                              )
       )
        dwLastError = GetLastError();

    return dwLastError;
}

//+-------------------------------------------------------------------------
//
//  Function:   StopService
//
//  Synopsis:   stops service by name
//
//  Arguments:  pwszServiceName  - name of service to stop.
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void StopService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    //
    // stop cisvc
    //
    BOOL fStopped = FALSE;

    if ( !MyStopService( xhSC, pwszServiceName, fStopped ) && !fStopped )
    {
        //
        // don't throw here
        //
        isDebugOut(( DEB_ERROR, "Failed to stop cisvc service" ));
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   StartService
//
//  Synopsis:   start service by name
//
//  Arguments:  pwszServiceName  - name of service to stop.
//
//  Returns:    none
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void StartService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", GetLastError() ));
    }
    else
    {
        //
        // start cisvc
        //
        MyStartService( xhSC, pwszServiceName );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyStartService
//
//  Synopsis:   Starts a given service
//
//  Arguments:  xSC         -- the service control manager
//              pwcService  -- name of the service to start
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void MyStartService(
    CServiceHandle & xSC,
    WCHAR const *    pwcService )
{
    CServiceHandle xSVC( OpenService( xSC.Get(),
                                      pwcService,
                                      SERVICE_START |
                                      GENERIC_READ | GENERIC_WRITE ) );
    if ( 0 != xSVC.Get() )
    {
        if ( !StartService( xSVC.Get(), 0, 0 ) )
        {
            isDebugOut(( DEB_ERROR, "Failed to start '%ws': %d\n", pwcService, GetLastError() ));
        }
    }

} //MyStartService

//+-------------------------------------------------------------------------
//
//  Function:   IsSvcRunning
//
//  Synopsis:   Determines if a service is running
//
//  Arguments:  xSC      -- the service control manager
//
//  Returns:    TRUE if the service is running, FALSE otherwise
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL IsSvcRunning( CServiceHandle &x )
{
    SERVICE_STATUS svcStatus;
    if ( QueryServiceStatus( x.Get(), &svcStatus ) )
        return SERVICE_STOP_PENDING == svcStatus.dwCurrentState ||
               SERVICE_RUNNING == svcStatus.dwCurrentState ||
               SERVICE_PAUSED == svcStatus.dwCurrentState;

    return FALSE;
} //IsSvcRunning

//+-------------------------------------------------------------------------
//
//  Function:   MyStopService
//
//  Synopsis:   Stops a given service
//
//  Arguments:  xSC      -- the service control manager
//              pwcSVC   -- name of the service to stop
//
//  Returns:    TRUE if the service was stopped
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL MyStopService(
    CServiceHandle & xSC,
    WCHAR const *    pwcSVC,
    BOOL &           fStopped )
{
    fStopped = FALSE;
    BOOL fOK = TRUE;

    CServiceHandle xSVC( OpenService( xSC.Get(),
                                      pwcSVC,
                                      SERVICE_STOP |
                                      GENERIC_READ | GENERIC_WRITE ) );
    if ( 0 != xSVC.Get() )
    {
        SERVICE_STATUS svcStatus;
        if ( IsSvcRunning( xSVC ) )
        {
            g_fCiSvcWasRunning = TRUE;

            if ( ControlService( xSVC.Get(),
                                 SERVICE_CONTROL_STOP,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && IsSvcRunning( xSVC ); i++ )
                {
                    isDebugOut(( DEB_ITRACE, "sleeping waiting for service '%ws' to stop\n", pwcSVC ));
                    Sleep( 1000 );
                }

                if ( IsSvcRunning( xSVC ) )
                {
                    THROW( CException( E_FAIL ) );
                }

                isDebugOut(( DEB_TRACE, "stopped service '%ws'\n", pwcSVC ));
                fStopped = TRUE;
            }
            else
            {
                DWORD dw = GetLastError();
                isDebugOut(( DEB_ERROR, "can't stop service '%ws', error %d\n", pwcSVC, dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
} //MyStopService

//+-------------------------------------------------------------------------
//
//  Function:   DeleteService
//
//  Synopsis:   deletes a service by name
//
//  Arguments:  pwszServiceName - name of service to delete
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void DeleteService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    SC_HANDLE hCiSvc = OpenService( hSC, pwszServiceName, DELETE );

    CServiceHandle xhCiSvc( hCiSvc );

    if ( 0 == hCiSvc )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenService(Cisvc for delete) Failed: %x\n", dwLastError ));

    }
    else if ( !DeleteService(hCiSvc) )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "DeleteService(Cisvc) Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ISError
//
//  Synopsis:   Reports a non-recoverable Index Server Install error
//
//  Arguments:  id  -- resource identifier for the error string
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void ISError( UINT id, CError &Err, LogSeverity Severity, DWORD dwErr )
{
    CResString msg( id );
    CResString title( IS_MSG_INDEX_SERVER );

    Err.Report( Severity, dwErr, msg.Get() );

    if ( LogSevFatalError == Severity )
    {
        isDebugOut(( "ISError, error %#x abort install: '%ws'\n",
                     dwErr, msg.Get() ));

        isDebugOut(( DEB_ERROR, "ISError, error %#x abort install: '%ws'\n",
                     dwErr, msg.Get() ));

        g_fInstallAborted = TRUE;
    }

} //ISError

//+-------------------------------------------------------------------------
//
//  Function:   Exec
//
//  Synopsis:   Runs an app and waits for it to complete
//
//  History:    8-Jan-97 dlee     Created from cistp.dll code
//
//--------------------------------------------------------------------------

void Exec(
    WCHAR * pwc )
{
    isDebugOut(( "exec: '%ws'\n", pwc ));

    STARTUPINFO si;
    RtlZeroMemory( &si, sizeof si );

    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    PROCESS_INFORMATION pi;

    if ( CreateProcess( 0,      // pointer to name of executable module
                        pwc,    // pointer to command line string
                        0,      // pointer to process security attributes
                        0,      // pointer to thread security attributes
                        FALSE,  // handle inheritance flag
                        0,      // creation flags
                        0,      // pointer to new environment block
                        0,      // pointer to current directory name
                        &si,    // pointer to STARTUPINFO
                        &pi ) ) // pointer to PROCESS_INFORMATION
    {
        WaitForSingleObject( pi.hProcess, 0xFFFFFFFF );
    }
} //Exec

//+-------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Synopsis:   Calls DllRegisterServer on a given dll
//
//  Returns:    Win32 error code
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD RegisterDll(WCHAR const * pwcDLL, CError &Err )
{
    DWORD dwErr = NO_ERROR;

    // All Index Server dlls are currently in system32

    TRY
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( pwcDLL );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR awcPath[ MAX_PATH ];
        wcscpy( awcPath, g_awcSystemDir );
        wcscat( awcPath, L"\\" );
        wcscat( awcPath, pwcDLL );

        HINSTANCE hDll = LoadLibraryEx( awcPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

        if( 0 != hDll )
        {
            SCODE (STDAPICALLTYPE *pfnDllRegisterServer)();
            pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
                GetProcAddress(hDll, "DllRegisterServer");

            if ( 0 != pfnDllRegisterServer )
            {
                SCODE sc = (*pfnDllRegisterServer)();
                if ( S_OK != sc )
                {
                    isDebugOut(( DEB_ERROR, "dllregister server '%ws' failed 0x%x\n",
                                             awcPath, sc));

                    ISError(IS_MSG_DllRegisterServer_FAILED ,Err, LogSevError, sc );

                    // no way to map a scode to a win32 error

                    dwErr = sc; // kylep suggested this would be valuable.
                }
            }
            else
                dwErr = GetLastError();

            FreeLibrary( hDll );
        }
        else
        {
            dwErr = GetLastError();
        }

        isDebugOut((DEB_TRACE, "result of registering '%ws': %d\n", awcPath, dwErr ));

#ifdef _WIN64

        //
        // Register the 32 bit version of the DLL
        //

        WCHAR awcSysWow64[ MAX_PATH ];

        cwc = GetSystemWow64Directory( awcSysWow64, sizeof awcSysWow64 / sizeof WCHAR );

        if ( 0 == cwc )
            return GetLastError();

        if ( L'\\' != awcSysWow64[ cwc - 1 ] )
        {
            awcSysWow64[ cwc++ ] = '\\';
            awcSysWow64[ cwc ] = 0;
        }

        WCHAR awcCmd[ MAX_PATH * 2 ];

        wcscpy( awcCmd, awcSysWow64 );
        wcscat( awcCmd, L"regsvr32 /s " );

        wcscat( awcCmd, awcSysWow64 );
        wcscat( awcCmd, pwcDLL );

        Exec( awcCmd );

#endif //_WIN64

    }
    CATCH( CException, e )
    {
        // ignore, since it's probably the new html filter

        isDebugOut(( "caught %#x registering '%ws'\n",
                     e.GetErrorCode(),
                     pwcDLL ));
    }
    END_CATCH

    return dwErr; // used to return 0 to avoid returning error!
} //RegisterDll

//+-------------------------------------------------------------------------
//
//  Function:   UnregisterDll
//
//  Synopsis:   Calls DllUnregisterServer on a given dll
//
//  Returns:    Win32 error code
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD UnregisterDll(
    WCHAR const * pwcDLL )
{
    UINT uiOld = SetErrorMode( SEM_NOOPENFILEERRORBOX |
                               SEM_FAILCRITICALERRORS );

    TRY
    {
        // All Index Server dlls are currently in system32

        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( pwcDLL );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR awcPath[ MAX_PATH ];

        wcscpy( awcPath, g_awcSystemDir );
        wcscat( awcPath, L"\\" );
        wcscat( awcPath, pwcDLL );

        // don't display popups if a dll can't be loaded when trying to
        // unregister.

        DWORD dwErr = NO_ERROR;

        HINSTANCE hDll = LoadLibraryEx( awcPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

        if( 0 != hDll )
        {
            SCODE (STDAPICALLTYPE *pfnDllUnregisterServer)();
            pfnDllUnregisterServer = (HRESULT (STDAPICALLTYPE *)())
                GetProcAddress(hDll, "DllUnregisterServer");

            if ( 0 != pfnDllUnregisterServer )
            {
                SCODE sc = (*pfnDllUnregisterServer)();
                if ( S_OK != sc )
                    dwErr = ERROR_INVALID_FUNCTION;
            }
            else
                dwErr = GetLastError();

            FreeLibrary( hDll );
        }
        else
        {
            dwErr = GetLastError();
        }

        isDebugOut((DEB_TRACE, "result of unregistering '%ws': %d\n", awcPath, dwErr ));
    }
    CATCH( CException, e )
    {
        // ignore, since it's probably the new html filter
    }
    END_CATCH

    SetErrorMode( uiOld );

    return 0; // explicitly ignore unregister errors
} //UnregisterDll

//+-------------------------------------------------------------------------
//
//  Function:   SetFilterRegistryInfo
//
//  Synopsis:   Installs registry info for Index Server filters
//
//  Returns:    Win32 error code
//
//  History:    8-Jan-97 dlee       Created
//              7-01-97  mohamedn   cleanedup for IS3.0 with NT5.0 setup.
//
//--------------------------------------------------------------------------

DWORD SetFilterRegistryInfo( BOOL fUnRegister, CError &Err )
{
    if ( fUnRegister )
    {
        // try to unregister old dlls

        UnregisterDll( L"query.dll" );
        UnregisterDll( L"htmlfilt.dll" );
        UnregisterDll( L"nlfilt.dll" );
        UnregisterDll( L"sccifilt.dll" );
        UnregisterDll( L"ciadmin.dll" );

        UnregisterDll( L"cifrmwrk.dll" );
        UnregisterDll( L"fsci.dll" );
        UnregisterDll( L"OffFilt.dll" );

        UnregisterDll( L"ixsso.dll" );
        UnregisterDll( L"ciodm.dll" );
        UnregisterDll( L"infosoft.dll" );
        UnregisterDll( L"mimefilt.dll" );
        UnregisterDll( L"LangWrBk.dll" );
    }
    else
    {
        // call the .dlls to have them registered

        for ( unsigned i = 0; i < cDlls; i++ )
        {
            DWORD dwErr = RegisterDll( apwcDlls[i], Err );
            if ( NO_ERROR != dwErr )
            {
                isDebugOut(( DEB_ERROR, "Failed to register(%ws): error code: %d\n",
                             apwcDlls[i], dwErr ));

                ISError(IS_MSG_DLL_REGISTRATION_FAILED , Err, LogSevError, dwErr );

                return dwErr;
            }
        }
    }

    return NO_ERROR;
} //SetFilterregistryInfo

//+-------------------------------------------------------------------------
//
//  Function:   SetRegBasedOnMachine
//
//  Synopsis:   Sets Index Server registry tuning paramaters based on the
//              capabilities of the machine.  Uninstall is .inf-based.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD SetRegBasedOnMachine(CError &Err)
{
    if ( 0 == gSetupInitComponent.ComponentInfHandle )
    {
        ISError( IS_MSG_INVALID_INF_HANDLE, Err, LogSevError );

        return NO_ERROR;
    }

    WCHAR * pwcInf = 0;
    BOOL    fServer = FALSE;

    switch(g_NtType)
    {
        case PRODUCT_SERVER_STANDALONE:
        case PRODUCT_SERVER_PRIMARY:
        case PRODUCT_SERVER_SECONDARY:
             {
                BOOL fLotsOfMem;
                DWORD cCpu;
                GetMachineInfo( fLotsOfMem, cCpu );

                if ( fLotsOfMem )
                {
                    if ( 1 == cCpu )
                        pwcInf = L"IndexSrv_Large";
                    else if ( 2 == cCpu )
                        pwcInf = L"IndexSrv_LargeMP2";
                    else
                        pwcInf = L"IndexSrv_LargeMPMany";
                }
                else
                {
                    if ( 1 == cCpu )
                        pwcInf = L"IndexSrv_Small";
                    else
                        pwcInf = L"IndexSrv_SmallMP2";
                }
             }

             fServer = TRUE;

             break;

        case PRODUCT_WORKSTATION:
        default:
             pwcInf = L"IndexSrv_Workstation";
    }

    if ( !SetupInstallFromInfSection( 0,
                                      gSetupInitComponent.ComponentInfHandle,
                                      pwcInf,
                                      SPINST_REGISTRY,
                                      0, 0, 0, 0, 0, 0, 0 ) )
        return GetLastError();

    // If a server, allow catalogs key to be read-only visible
    // to the world.  See KB Q155363

    // Note: In Win2k, the professional version requires this as well,
    // so I commented out the fServer check.

    //    if ( fServer )

    {
        CWin32RegAccess regAllowed( HKEY_LOCAL_MACHINE, wcsAllowedPaths );
        WCHAR awcValue[ 8192 ];

        if ( regAllowed.Get( L"Machine",
                             awcValue,
                             sizeof awcValue / sizeof WCHAR ) )
        {
            // don't re-add it if it already exists

            BOOL fFound = FALSE;
            WCHAR *p = awcValue;
            while ( 0 != *p )
            {
                if ( !_wcsicmp( p, wcsRegAdminSubKey ) )
                {
                    fFound = TRUE;
                    break;
                }
                while ( 0 != *p )
                    p++;
                p++;
            }

            if ( !fFound )
            {
                wcscpy( p, wcsRegAdminSubKey );
                p += ( 1 + wcslen( wcsRegAdminSubKey ) );
                *p++ = 0;

                if ( !regAllowed.SetMultiSZ( L"Machine",
                                             awcValue,
                                             (ULONG)(p-awcValue) * sizeof WCHAR ) )
                {
                    DWORD dw = GetLastError();
                    ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err, LogSevFatalError, dw );
                    return dw;
                }
            }
        }
    }

    return NO_ERROR;
} //SetRegBasedOnMachine


//+-------------------------------------------------------------------------
//
//  Function:   SetRegBasedOnArchitecture
//
//  Synopsis:   Sets Index Server registry tuning paramaters based on the
//              architecture.  Uninstall is .inf-based.
//
//  History:    24-Feb-98     KrishnaN     Created
//
//--------------------------------------------------------------------------

DWORD SetRegBasedOnArchitecture(CError &Err)
{
    if ( 0 == gSetupInitComponent.ComponentInfHandle )
    {
        Err.Report(LogSevError,0,L"Couldn't set registry based on architecture, Invalid Inf Handle");

        return NO_ERROR;
    }

    WCHAR * pwcInf = 0;

    #if defined (_X86_)
        pwcInf = L"IndexSrv_X86";
    #else
        pwcInf = L"IndexSrv_RISC";
    #endif

    if ( !SetupInstallFromInfSection( 0,
                                      gSetupInitComponent.ComponentInfHandle,
                                      pwcInf,
                                      SPINST_REGISTRY,
                                      0, 0, 0, 0, 0, 0, 0 ) )
        return GetLastError();

    return NO_ERROR;
} //SetRegBasedOnArchitecture

//+-------------------------------------------------------------------------
//
//  Function:   GetMachineInfo
//
//  Synopsis:   Retrieves stats about the machine
//
//  Arguments:  fLotsOfMem  -- returns TRUE if the machine has "lots" of mem
//              cCPU        -- returns a count of CPUs
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void GetMachineInfo(
    BOOL  & fLotsOfMem,
    DWORD & cCPU )
{
    SYSTEM_INFO si;
    GetSystemInfo( &si );
    cCPU = si.dwNumberOfProcessors;

    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof( memStatus );
    GlobalMemoryStatusEx( &memStatus );
    fLotsOfMem = ( memStatus.ullTotalPhys >= 64000000 );
} //GetMachineInfo

//+-------------------------------------------------------------------------
//
//  Function:   isLogString
//
//  Synopsis:   Logs the string to %windir%\setupqry.log
//
//  Arguments:  pc  -- ansi string
//
//  History:    11-Nov-98 dlee     Created
//
//--------------------------------------------------------------------------

BOOL g_fCalledYet = FALSE;

void isLogString( const char * pc )
{
    WCHAR awc[ MAX_PATH ];
    UINT ui = GetWindowsDirectory( awc, sizeof awc / sizeof WCHAR );

    if ( 0 == ui )
        return;

    wcscat( awc, L"\\setupqry.log" );

    WCHAR const * pwcOpen = L"a";

    if ( !g_fCalledYet )
    {
        g_fCalledYet = TRUE;
        pwcOpen = L"w";
    }

    FILE *fp = _wfopen( awc, pwcOpen );

    if ( 0 != fp )
    {
        fprintf( fp, "%s", pc );
        fclose( fp );
    }
} //isLogString

//+-------------------------------------------------------------------------
//
//  Function:   SystemExceptionTranslator
//
//  Synopsis:   Translates system exceptions into C++ exceptions
//
//  History:    1-Dec-98 dlee     Copied from query.dll's version
//
//--------------------------------------------------------------------------

void _cdecl SystemExceptionTranslator(
    unsigned int                 uiWhat,
    struct _EXCEPTION_POINTERS * pexcept )
{
    throw CException( uiWhat );
} //SystemExceptionTranslator

//+-------------------------------------------------------------------------
//
//  Function:   DeleteNTOPStartMenu
//
//  Synopsis:   Deletes start menu items created by IS in the NTOP
//
//  History:    6-Jan-99 dlee     Created
//
//--------------------------------------------------------------------------

void DeleteNTOPStartMenu()
{
    //
    // Ignore all failures here -- it's ok if the link don't exist
    //

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE,
                         L"software\\microsoft\\windows\\currentversion\\explorer\\shell folders" );

    WCHAR awc[MAX_PATH];

    if ( reg.Get( L"common programs",
                  awc,
                  MAX_PATH ) )
    {
        //
        // Build the directory where the links are located
        //

        wcscat( awc, L"\\" );

        CResString strNTOP( IS_MSG_NTOP );
        wcscat( awc, strNTOP.Get() );

        wcscat( awc, L"\\" );

        CResString strMIS( IS_MSG_START_MENU_NAME );
        wcscat( awc, strMIS.Get() );

        isDebugOut(( "NTOP start menu location: '%ws'\n", awc ));

        //
        // Delete the links
        //

        CResString strSample( IS_MSG_LINK_SAMPLE_NAME );
        DeleteShellLink( awc, strSample.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strSample.Get() ));

        CResString strAdmin( IS_MSG_LINK_ADMIN_NAME );
        DeleteShellLink( awc, strAdmin.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strAdmin.Get() ));

        CResString strMMC( IS_MSG_LINK_MMC_NAME );
        DeleteShellLink( awc, strMMC.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strMMC.Get() ));

        //
        // Note: when the last item is deleted, DeleteShellLink deletes
        // the directory
        //
    }
} //DeleteNTOPStartMenu
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\autobloc.h ===
//-----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For ODBC Providers 
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module AUTOBLOC.H | CAutoBlock object implementation.
//
// @rev 1 | 02-27-95 | EricJ    | Created
// @rev 2 | 06-30-95 | EricJ    | Added autoduck comments (maybe too many?)
// @rev 3 | 07-02-96 | EricJ    | Removed debug code; doesn't work on WIN95 or RISC.
//-----------------------------------------------------------------------------

#ifndef __AUTOBLOC_H_
#define __AUTOBLOC_H_

//-----------------------------------------------------------------------------
// @class CAutoBlock | Auto blocking / synchronization.
//
// This C++ object allows blocking of critical sections.
// The constructor/destructor automatically Enter and Leave
// correctly, to ensure that each call is correctly paired.
// This ensures correct operation for exception handling
// and for multiple returns.
//
// @ex Here's example usage. |
//
//  void test2()
//  {
//      CAutoBlock ab( &g_Crit1 );
//  
//      // Do some work here...
//      // Destructor cleans up
//  }
//  
//  void test3()
//  {
//      CAutoBlock ab( &g_Crit2 );
//  
//      //...do some work -- we are blocked here...
//  
//      ab.UnBlock();
//  
//      //...do some work -- we are not blocked here...
//      //...destructor does nothing...
//  }
//
// @devnote
// If you want to enter the same critical section again,
// just use another CAutoBlock.  
//
// Note that since the storage is auto (not static or dynamic 
// via `new`), this goes onto the stack.  Thus the overhead of 
// this class is almost exactly the same as explictly calling 
// EnterCriticalSection / LeaveCriticalSection.
//-----------------------------------------------------------------------------

class DBEXPORT CAutoBlock {
public:     //@access public functions
    CAutoBlock( CRITICAL_SECTION *pCrit );  //@cmember CTOR.  Begins blocking.
    ~CAutoBlock();                          //@cmember DTOR.  Ends blocking.
    void UnBlock();                         //@cmember Ends blocking.
private:    //@access private data
    CRITICAL_SECTION *m_pCrit;              //@cmember The critical section.
};


//-----------------------------------------------------------------------------
// Inline functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// @mfunc Constructor.
// Begins blocking.  Does EnterCriticalSection, so you can put at 
// beginning of function, or in the middle of the function, 
// or inside some scoped {}.
//-----------------------------------------------------------------------------------

inline CAutoBlock::CAutoBlock( 
    CRITICAL_SECTION *pCrit )   //@parm IN | The critical section.
{
    // It is OK to pass a NULL ptr to this routine.  It is a NOOP.
    // Note that passing NULL to EnterCriticalSection blows up.

    if (0 != pCrit )
        ::EnterCriticalSection( pCrit );
    m_pCrit = pCrit;
}


//-----------------------------------------------------------------------------
// @mfunc Destructor.
// Ends blocking.  Does LeaveCriticalSection, unless you called UnBlock(),
// in which case it's a NOOP.
//-----------------------------------------------------------------------------------

inline CAutoBlock::~CAutoBlock()
{
    if ( 0 != m_pCrit )
        ::LeaveCriticalSection( m_pCrit );
}


//-----------------------------------------------------------------------------
// @mfunc
// Ends blocking explicitly.  Thereafter, the destructor does nothing.
//-----------------------------------------------------------------------------------

inline void CAutoBlock::UnBlock()
{
    // Clear the critical-section member,
    // so that the destructor doesn't do anything.

    if ( 0 != m_pCrit )
        ::LeaveCriticalSection( m_pCrit );
    m_pCrit = 0;
}


//-----------------------------------------------------------------------------
// @class CAutoBlock2 | Auto blocking / synchronization.
// This class requires each critical section to be assigned a level.
// Critical Sections can be called only in a low-to-high order, within a thread.
// Otherwise the chance for deadlock exists.
//-----------------------------------------------------------------------------

// ifdef this out for now, so it doesn't introduce another global var.
#ifdef NOTREADY

class DBEXPORT CAutoBlock2 {
public:     //@access public functions
    CAutoBlock2( CRITICAL_SECTION *pCrit, DWORD dwLevel );  //@cmember CTOR.  Begins blocking.
    ~CAutoBlock2();                         //@cmember DTOR.  Ends blocking.
    void UnBlock();                         //@cmember Ends blocking.
private:    //@access private data
    CRITICAL_SECTION *m_pCriticalSection;   //@cmember The critical section.
    DEBUGCODE( DWORD m_dwLevel; )           //@cmember Level of this critical section.
};

// There can be 32 levels, 0...31.
// They can only be used in low --> high order.
enum CritLevels {
    CRITLEV_DATASOURCE,
    CRITLEV_SESSION,
    CRITLEV_COMMAND,
    CRITLEV_ROWSET,
};


// We need a global var for the TLS index.
// @todo EJ 2-jun-96: Fake it for now; until this is integrated.
static DWORD g_dwTlsIndexCS = TLS_OUT_OF_INDEXES;


inline CAutoBlock2::CAutoBlock2( CRITICAL_SECTION *pCriticalSection, DWORD dwLevel )
{
#ifdef DEBUG
    DWORD dwExistLevel;
    assert( 0 <= dwLevel && dwLevel <= 31);
    assert(g_dwTlsIndexCS != TLS_OUT_OF_INDEXES);
    dwExistLevel = (DWORD) TlsGetValue(g_dwTlsIndexCS);
    // Disallow calls to lower levels than we currently have.
    // Allow calls to same level.
    assert(dwExistLevel > (DWORD) (1<<(dwLevel+1)) - 1);
    dwExistLevel |= 1<<dwLevel;
    TlsSetValue(g_dwTlsIndexCS, (LPVOID) dwExistLevel);
    m_dwLevel = dwLevel;
#endif

    m_pCriticalSection = pCriticalSection;
    if ( 0 != pCriticalSection )
        ::EnterCriticalSection( pCriticalSection );
}


inline CAutoBlock2::~CAutoBlock2()
{
#ifdef DEBUG
    DWORD dwExistLevel;
    dwExistLevel = (DWORD) TlsGetValue(g_dwTlsIndexCS);
    dwExistLevel &= ~ (1<<m_dwLevel);
    TlsSetValue(g_dwTlsIndexCS, (LPVOID) dwExistLevel);
#endif

    if ( 0 != m_pCriticalSection )
        ::LeaveCriticalSection( m_pCriticalSection );
}


inline void CAutoBlock2::UnBlock()
{
    // Clear the critical-section member,
    // so that the destructor doesn't do anything.

    if ( 0 != m_pCriticalSection )
        ::LeaveCriticalSection( m_pCriticalSection );
    m_pCriticalSection = 0;
}

#endif  // NOTREADY

#endif // __AUTOBLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\shlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       shlink.cxx
//
//  Contents:   Utility stuff for shell links
//
//  History:    10-Sep-97 dlee     Created mostly from IIS setup code
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tchar.h>
#include <shlobj.h>
#include <oleguid.h>

BOOL DoesFileExist(LPCTSTR szFile)
{
    return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

BOOL IsDirEmpty( WCHAR const * pwcDir )
{
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    WCHAR awc[ MAX_PATH ];

    unsigned cwc = wcslen( pwcDir ) + 4;

    if ( cwc >= MAX_PATH )
        return TRUE;

    wcscpy( awc, pwcDir );
    wcscat( awc, L"\\*.*" );

    hFind = FindFirstFile( awc, &FindData );
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }

    FindClose (hFind );

    return fReturn;
} //IsDirEmpty


//+-------------------------------------------------------------------------
//
//  Function:   CreateShellDirectoryTree
//
//  Synopsis:   Creates as many directories as is necessary
//
//  Arguments:  pwc -- the directory to create
//
//  Returns:    Win32 Error Code
//
//  Notes:      Directories are created up to the last backslash
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD CreateShellDirectoryTree( WCHAR const *pwcIn )
{
    WCHAR awc[MAX_PATH];
    WCHAR * pwc = awc;

    if ( wcslen( pwcIn ) >= ( MAX_PATH - 5 ) )
        return ERROR_INVALID_PARAMETER;

    wcscpy( pwc, pwcIn );

    unsigned cwc = wcslen( pwc );
    if ( (cwc > 0) &&
         (cwc < ((sizeof awc / sizeof WCHAR) - 1)) &&
         (pwc[cwc-1] != L'\\') ) {

        wcscat( pwc, L"\\" );
    }

    WCHAR *pwcStart = pwc;

    if ( *pwc == L'\\' && *(pwc+1) == L'\\' )
    {
        pwc += 2;

        // get past machine name

        while ( *pwc && *pwc != '\\' )
            pwc++;

        // get past slash

        if ( *pwc )
            pwc++;

        // get past share name

        while ( *pwc && *pwc != '\\' )
            pwc++;
    }
    else if ( *(pwc+1) == L':' )
        pwc += 2;

    // get to the first directory name

    while ( *pwc == L'\\' )
        pwc++;

    while ( *pwc )
    {
        if ( *pwc == L'\\' )
        {
            *pwc = 0;

            if (! CreateDirectory( pwcStart, 0 ) )

            {
                DWORD dw = GetLastError();
                if ( ERROR_ALREADY_EXISTS != dw )
                    return dw;
            }

            *pwc = L'\\';
        }

        pwc++;
    }

    return NO_ERROR;
} //CreateShellDirectoryTree

HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex)
{
    HRESULT hres;
    IShellLink* pShellLink;

    //CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance( CLSID_ShellLink,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IShellLink,
                             (LPVOID*)&pShellLink );
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;

       // Set the path to the shortcut target, and add the description.
       pShellLink->SetPath(lpszProgram);
       pShellLink->SetArguments(lpszArgs);
       pShellLink->SetWorkingDirectory(lpszDir);
       pShellLink->SetIconLocation(lpszIconPath, iIconIndex);

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);

       if (SUCCEEDED(hres))
       {
          WCHAR wsz[MAX_PATH];

          lstrcpyn(wsz, lpszLink, sizeof wsz / sizeof WCHAR);

          // Save the link by calling IPersistFile::Save.
          hres = pPersistFile->Save(wsz, TRUE);

          pPersistFile->Release();
       }

       pShellLink->Release();
    }
    else
    {
        isDebugOut(( "createlink can't create instance: 0x%x\n", hres ));
        isDebugOut(( "!!!likely some k2 partner component left OLE "
                     "initialized in an incompatible state!!!\n" ));
    }
    return hres;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    //
    // Don't try to delete what doesn't exist
    //

    if ( !DoesFileExist( lpszShortcut ) )
    {
        isDebugOut(( "deletelink: '%ws' doesn't exist\n", lpszShortcut ));
        return TRUE;
    }

    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    lstrcpyn(szFile, lpszShortcut, sizeof szFile / sizeof TCHAR);

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.pFrom = szFile;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
    SHFileOperation(&fos);

    return TRUE;
}

void AddShellLink(
    WCHAR const * pwcGroupPath,
    WCHAR const * pwcName,
    WCHAR const * pwcProgram,
    WCHAR const * pwcArgs )
{
    if ( !DoesFileExist( pwcGroupPath ) )
    {
        CreateShellDirectoryTree( pwcGroupPath );
        SHChangeNotify( SHCNE_MKDIR, SHCNF_PATH, pwcGroupPath, 0 );
    }

    unsigned cwc = wcslen( pwcGroupPath ) + 1 + wcslen( pwcName ) + wcslen( L".lnk" );

    if ( cwc >= MAX_PATH )
        return;

    WCHAR awcPath[ MAX_PATH ];
    wcscpy( awcPath, pwcGroupPath );
    wcscat( awcPath, L"\\" );
    wcscat( awcPath, pwcName );
    wcscat( awcPath, L".lnk" );

    MyCreateLink( pwcProgram, pwcArgs, awcPath, 0, 0, 0 );
} //AddShellLink

void DeleteShellLink(
    WCHAR const * pwcGroupPath,
    WCHAR const * pwcName )
{
    unsigned cwc = wcslen( pwcGroupPath ) + 1 + wcslen( pwcName ) + wcslen( L".lnk" );

    if ( cwc >= MAX_PATH )
        return;

    WCHAR awcPath[ MAX_PATH ];
    wcscpy( awcPath, pwcGroupPath );
    wcscat( awcPath, L"\\" );
    wcscat( awcPath, pwcName );
    wcscat( awcPath, L".lnk" );

    MyDeleteLink( awcPath );

    if ( IsDirEmpty( pwcGroupPath ) )
    {
        RemoveDirectory( pwcGroupPath );
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pwcGroupPath, 0);
    }
} //DeleteShellLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\setupqry\tcatcnfg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//  File:       tcatcnfg.cxx
//
//  Contents:   Test program for catalog configuration
//
//  History:    24 Nov 1998     AlanW   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "catcnfg.hxx"

WCHAR   g_awcProfilePath[MAX_PATH];

const WCHAR wszRegProfileKey[] =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
const WCHAR wszRegProfileValue[] = L"ProfilesDirectory";

//
// DLL module instance handle
//
HINSTANCE MyModuleHandle = (HINSTANCE)INVALID_HANDLE_VALUE;

ULONG isInfoLevel;

inline ULONG MB( ULONGLONG cb )
{
    const ONE_MB = (1024*1024);

    return (ULONG) ((cb+ONE_MB/2) / ONE_MB);
}

void PrintDriveInfo( CCatalogConfig & CatConfig );
void ExcludeSpecialLocations( CCatalogConfig & Cat );

WCHAR g_awcSystemDir[MAX_PATH];

__cdecl main()
{
    CError Err;

    GetSystemDirectory( g_awcSystemDir,
                        sizeof g_awcSystemDir / sizeof WCHAR );
    CCatalogConfig CatConfig(Err);

    CatConfig.InitDriveList();
    //printf("\nBefore pagefile reservation:\n" );
    //PrintDriveInfo( CatConfig );

    //CatConfig.ReservePageFileData();

    printf("\nBefore catalog configuration:\n" );
    PrintDriveInfo( CatConfig );

    //
    // Find the default profile path (Usually %windir%\Profiles)
    //

    CWin32RegAccess regProfileKey( HKEY_LOCAL_MACHINE, wszRegProfileKey );

    g_awcProfilePath[0] = L'\0';
    WCHAR wcTemp[MAX_PATH+1];

    if ( regProfileKey.Get( wszRegProfileValue, wcTemp, NUMELEM(wcTemp) ) )
    {
        unsigned ccTemp2 = ExpandEnvironmentStrings( wcTemp,
                                                   g_awcProfilePath,
                                                   NUMELEM(g_awcProfilePath) );
    }

    CatConfig.ConfigureDefaultCatalog(g_awcProfilePath);
    ExcludeSpecialLocations( CatConfig );

    printf("\nAfter catalog configuration:\n" );
    PrintDriveInfo( CatConfig );

    printf("\nCatalog drive:\n\t%ws\n", CatConfig.GetCatalogDrive());

    WCHAR const * pwszScope;
    for (unsigned i = 0;  pwszScope = CatConfig.GetIncludedScope( i ); i++)
    {
        if ( 0 == i )
            printf("\nIncluded scopes:\n");
        printf("\t%ws\n", pwszScope );
    }

    for (i = 0;  pwszScope = CatConfig.GetExcludedScope( i ); i++)
    {
        if ( 0 == i )
            printf("\nExcluded scopes:\n");
        printf("\t%ws\n", pwszScope );
    }

    return 0;
}

void PrintDriveInfo( CCatalogConfig & CatConfig )
{
    printf("Drive\tFree MB Resv MB Tot. MB\n");

    CDriveInformation const * pDriveInfo = 0;
    for ( unsigned i=0; 
          pDriveInfo = CatConfig.GetDriveInfo(i);
          i++ )
    {
        printf("%s\t%7d\t%7d\t%7d",
                pDriveInfo->GetDriveName(),
                MB(pDriveInfo->GetAvailableSpace()),
                MB(pDriveInfo->GetReservedSpace()),
                MB(pDriveInfo->GetTotalSpace()) );

        if ( pDriveInfo->IsNtfs() )
            printf(" NTFS");
        else if ( !pDriveInfo->IsBootDrive() )
            printf(" FAT");

        if ( pDriveInfo->IsSystemDrive() )
            printf(" SystemDrive");
        if ( pDriveInfo->IsBootDrive() )
            printf(" BootDrive");

        //if ( pDriveInfo->IsNtfs() )
        //    printf(" SupportsSecurity");
        //if ( pDriveInfo->SupportsCompression() )
        //    printf(" SupportsCompression");
        if ( pDriveInfo->HasPageFile() )
            printf(" PageFile");

        printf("\n");
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   ISError
//
//  Synopsis:   Reports a non-recoverable Index Server Install error
//
//  Arguments:  id  -- resource identifier for the error string
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void ISError( UINT id, CError &Err, LogSeverity Severity )
{
//    CResString msg( id );
//    CResString title( IS_MSG_INDEX_SERVER );

    Err.Report( Severity, L"Error 0x%08x\n", id );

    if ( LogSevFatalError == Severity )
    {
        //isDebugOut(( "ISError, abort install: '%ws'\n", msg.Get() ));
        //g_fInstallAborted = TRUE;
        exit( 1 );
    }

} //ISError


CError::CError( )
{
}

CError::~CError( )
{
}

void CError::Report( LogSeverity Severity, WCHAR const * MessageString, ...)
{
    va_list va;
    va_start(va, MessageString);

    wvsprintf(_awcMsg, MessageString, va);

    va_end(va);

    wprintf(L"setupqry: %s\r\n", _awcMsg);
}


//+-------------------------------------------------------------------------
//
//  Function:   ExcludeSpecialLocations, private
//
//  Synopsis:   Writes profile-based exclude scopes into the registry
//
//  Arguments:  none
//
//  History:    28-Aug-1998   KyleP    Created
//
//--------------------------------------------------------------------------

WCHAR const wszRegShellSpecialPathsKey[] =
    L".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

WCHAR const * const awszRegShellSpecialPathsValue[] = {
    L"AppData",
    L"Cache",
    L"Local Settings"
};

WCHAR const wszUserProfile[] = L"%USERPROFILE%";

void ExcludeSpecialLocations( CCatalogConfig & Cat )
{
//    CWin32RegAccess regScopes( HKEY_LOCAL_MACHINE, wcsRegSystemScopesSubKey );

    //
    // First, find the default profile path (Usually %windir%\Profiles)
    //

    WCHAR wcTemp[MAX_PATH+1];

    if ( g_awcProfilePath[0] )
    {
        WCHAR wcTemp2[MAX_PATH+1];
        wcscpy( wcTemp2, g_awcProfilePath );
        unsigned ccTemp2 = wcslen( wcTemp2 );

        //
        // Append the wildcard, for user profile directory
        //

        wcscpy( wcTemp2 + ccTemp2, L"\\*\\" );
        ccTemp2 += 3;

        //
        // Go through and look for special shell paths, which just happen
        // to include all our special cases too.
        //

        CWin32RegAccess regShellSpecialPathsKey( HKEY_USERS, wszRegShellSpecialPathsKey );

        for ( unsigned i = 0;
              i < NUMELEM(awszRegShellSpecialPathsValue);
              i++ )
        {
            if ( regShellSpecialPathsKey.Get( awszRegShellSpecialPathsValue[i],
                                              wcTemp, NUMELEM(wcTemp) ) )
            {
                if ( RtlEqualMemory( wszUserProfile, wcTemp, sizeof(wszUserProfile) - sizeof(WCHAR) ) )
                {
                        wcscpy( wcTemp2 + ccTemp2, wcTemp + NUMELEM(wszUserProfile) );
                        wcscpy( wcTemp, wcTemp2 );
                }
                else if ( wcschr( wcTemp, L'%' ) != 0 )
                {
                    WCHAR wcTemp3[MAX_PATH+1];
                    unsigned ccTemp3 = ExpandEnvironmentStrings(
                                               wcTemp,
                                               wcTemp3,
                                               NUMELEM(wcTemp3) );
                    if ( 0 != ccTemp3 )
                        wcscpy( wcTemp, wcTemp3 );
                }

                wcscat( wcTemp, L"\\*" );
                isDebugOut(( "Exclude: %ws\n", wcTemp ));

                Cat.AddExcludedDirOrPattern( wcTemp );
            }
        }
    }
}

#if 0

//+-------------------------------------------------------------------------
//
//  Function:   ExcludeSpecialLocations, private
//
//  Synopsis:   Writes profile-based exclude scopes into the registry
//
//  Arguments:  none
//
//  History:    28-Aug-1998   KyleP    Created
//
//--------------------------------------------------------------------------

WCHAR const wszRegProfileKey[] =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
WCHAR const wszRegProfileValue[] = L"ProfilesDirectory";

WCHAR const wszRegShellSpecialPathsKey[] =
    L".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

WCHAR const * const awszRegShellSpecialPathsValue[] = {
    L"AppData",
    L"Cache",
    L"Local Settings"
};

WCHAR const wszUserProfile[] = L"%USERPROFILE%";

void ExcludeSpecialLocations( CCatalogConfig & Cat )
{
//    CWin32RegAccess regScopes( HKEY_LOCAL_MACHINE, wcsRegSystemScopesSubKey );

    //
    // First, find the default profile path (Usually %windir%\Profiles)
    //

    CWin32RegAccess regProfileKey( HKEY_LOCAL_MACHINE, wszRegProfileKey );

    WCHAR wcTemp[MAX_PATH+1];

    if ( regProfileKey.Get( wszRegProfileValue, wcTemp, NUMELEM(wcTemp) ) )
    {
        WCHAR wcTemp2[MAX_PATH+1];
        unsigned ccTemp2 = ExpandEnvironmentStrings( wcTemp, wcTemp2, NUMELEM(wcTemp2) );

        if ( 0 != ccTemp2 )
        {
            //
            // Append the wildcard, for user profile directory
            //

            ccTemp2--;		// don't include null terminator
            wcscpy( wcTemp2 + ccTemp2, L"\\*\\" );
            ccTemp2 += 3;

            //
            // Go through and look for special shell paths, which just happen
            // to include all our special cases too.
            //

            CWin32RegAccess regShellSpecialPathsKey( HKEY_USERS, wszRegShellSpecialPathsKey );

            for ( unsigned i = 0;
                  i < NUMELEM(awszRegShellSpecialPathsValue);
                  i++ )
            {
                if ( regShellSpecialPathsKey.Get( awszRegShellSpecialPathsValue[i], wcTemp, NUMELEM(wcTemp) ) )
                {
                    if ( RtlEqualMemory( wszUserProfile, wcTemp, sizeof(wszUserProfile) - sizeof(WCHAR) ) )
                    {
                        wcscpy( wcTemp2 + ccTemp2, wcTemp + NUMELEM(wszUserProfile) );
                        wcscpy( wcTemp, wcTemp2 );
                    }
                    else if ( wcschr( wcTemp, L'%' ) != 0 )
                    {
                        WCHAR wcTemp3[MAX_PATH+1];
                        unsigned ccTemp3 = ExpandEnvironmentStrings( wcTemp, wcTemp3, NUMELEM(wcTemp3) );
                        if ( 0 != ccTemp3 )
                            wcscpy( wcTemp, wcTemp3 );
                    }

                    wcscat( wcTemp, L"\\*" );
                    isDebugOut(( "Exclude: %ws\n", wcTemp ));

                    Cat.AddExcludedDirOrPattern( wcTemp );
                }
            }
        }
    }
}
#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\bison.cpp ===
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#pragma hdrstop
#include <malloc.h>

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */


#ifdef YYDEBUG
# ifndef YYDBFLG
#  define YYDBFLG                               (yydebug)
# endif
# define yyprintf                               if (YYDBFLG) YYPRINT
#else
# define yyprintf
#endif

#ifndef YYPRINT
#ifdef UNICODE
# define YYPRINT                                wprintf
#else
# define YYPRINT                                printf
#endif
#endif

#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif

#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        return(ResultFromScode(S_OK))
#define YYABORT(sc)     {EmptyValueStack(); return(ResultFromScode(sc));}
#define YYERROR         goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)

#define YYTERROR        1
#define YYERRCODE       256


/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

//turn off warning about 'this' in base member initialization
#pragma warning (disable : 4355)
YYPARSER::YYPARSER(
        CImpIParserSession* pParserSession, 
        CImpIParserTreeProperties* pParserTreeProperties
        ) : m_yylex(this)
#pragma warning (default : 4355)
        {
                //Allocate yys, yyv if necessary
                ResetParser();
                m_pIPSession = pParserSession;
                m_pIPTProperties = pParserTreeProperties;
        }

YYPARSER::~YYPARSER()
        {
        //Deallocate yys, yyv if allocated
        }


void YYPARSER::ResetParser()
        {
        yystate = 0;
        yyerrstatus = 0;
        yynerrs = 0;

        /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

        yyssp = yyss-1;
        yyvsp = yyvs;

        YYAPI_TOKENNAME = YYEMPTY;      // Cause a token to be read.
        }


#pragma warning(disable:102)
HRESULT YYPARSER::Parse(YYPARSEPROTO)
        {
        yychar1 = 0;            /*  lookahead token as an internal (translated) token number */

        yyss = yyssa;           /*  refer to the stacks thru separate pointers */
        yyvs = yyvsa;           /*  to allow yyoverflow to reallocate them elsewhere */

        yystacksize = YYINITDEPTH;



#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Starting parse\n"));
#endif

        yystate = 0;
        yyerrstatus = 0;
        yynerrs = 0;
        YYAPI_TOKENNAME = YYEMPTY;              /* Cause a token to be read.  */

        /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

        yyssp = yyss-1;
        yyvsp = yyvs;

        // Push a new state, which is found in  yystate  . 
        // In all cases, when you get here, the value and location stacks
        // have just been pushed. so pushing a state here evens the stacks.
yynewstate:
        *++yyssp = yystate;

        if (yyssp >= yyss + yystacksize - 1)
                {
                // Give user a chance to reallocate the stack
                // Use copies of these so that the &'s don't force the real ones into memory. */
                YYSTYPE *yyvs1 = yyvs;
                short *yyss1 = yyss;

                // Get the current used size of the three stacks, in elements.  */
                int size = (int)(yyssp - yyss + 1);

#ifdef yyoverflow
                // Each stack pointer address is followed by the size of
                // the data in use in that stack, in bytes.
                yyoverflow("parser stack overflow",
                                        &yyss1, size * sizeof (*yyssp),
                                        &yyvs1, size * sizeof (*yyvsp),
                                        &yystacksize);

                yyss = yyss1; yyvs = yyvs1;
#else // no yyoverflow
      // Extend the stack our own way.
                if (yystacksize >= YYMAXDEPTH)
                        {
                        m_pIPTProperties->SetErrorHResult(E_FAIL, MONSQL_PARSE_STACK_OVERFLOW);
                        return ResultFromScode(E_FAIL);
                        }
                yystacksize *= 2;
                if (yystacksize > YYMAXDEPTH)
                        yystacksize = YYMAXDEPTH;
                yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
                memcpy ((TCHAR *)yyss, (TCHAR *)yyss1, size * sizeof (*yyssp));
                yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
                memcpy ((TCHAR *)yyvs, (TCHAR *)yyvs1, size * sizeof (*yyvsp));
#endif /* no yyoverflow */

                yyssp = yyss + size - 1;
                yyvsp = yyvs + size - 1;

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Stack size increased to %d\n"), yystacksize);
#endif

                if (yyssp >= yyss + yystacksize - 1)
                        YYABORT(E_FAIL);
                }

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Entering state %d\n"), yystate);
#endif

        goto yybackup;



yybackup:

        // Do appropriate processing given the current state.
        // Read a lookahead token if we need one and don't already have one.

        // First try to decide what to do without reference to lookahead token.

        yyn = yypact[yystate];
        if (yyn == YYFLAG)
                goto yydefault;

        // Not known => get a lookahead token if don't already have one.

        // YYAPI_TOKENNAME is either YYEMPTY or YYEOF or a valid token in external form.

        if (YYAPI_TOKENNAME == YYEMPTY)
                {
#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Reading a token\n"));
#endif
                YYAPI_VALUENAME = NULL; 
                try
                        {
                        YYAPI_TOKENNAME = YYLEX(&YYAPI_VALUENAME);
                        }
                catch (HRESULT hr)
                        {
                        switch(hr)
                                {
                        case E_OUTOFMEMORY:
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT(E_OUTOFMEMORY);
                        
                        default:
                                YYABORT(E_FAIL);
                                }
                        }
                }

        // Convert token to internal form (in yychar1) for indexing tables with

        if (YYAPI_TOKENNAME <= 0)               /* This means end of input. */
                {
                yychar1 = 0;
                YYAPI_TOKENNAME = YYEOF;                /* Don't call YYLEX any more */

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Now at end of input: state %2d\n"), yystate);
#endif
                }
        else
                {
                yychar1 = YYTRANSLATE(YYAPI_TOKENNAME);

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Next token is %s (%d)\n"), yytname[yychar1], YYAPI_TOKENNAME);
#endif
                }

        yyn += yychar1;
        if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
                goto yydefault;

        yyn = yytable[yyn];

        // yyn is what to do for this token type in this state.
        // Negative => reduce, -yyn is rule number.
        // Positive => shift, yyn is new state.
        // New state is final state => don't bother to shift,
        // just return success.
        // 0, or most negative number => error.  */

        if (yyn < 0)
                {
                if (yyn == YYFLAG)
                        goto yyerrlab;
                yyn = -yyn;
                goto yyreduce;
                }
        else if (yyn == 0)
                goto yyerrlab;

        if (yyn == YYFINAL)
                YYACCEPT;

        // Shift the lookahead token.

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Shifting token %s (%d), "), yytname[yychar1], YYAPI_TOKENNAME);
#endif

        // Discard the token being shifted unless it is eof.
        if (YYAPI_TOKENNAME != YYEOF)
                YYAPI_TOKENNAME = YYEMPTY;

        *++yyvsp = yylval;
        yylval = NULL;

        // count tokens shifted since error; after three, turn off error status.
        if (yyerrstatus)
                yyerrstatus--;

        yystate = (short)yyn;
        goto yynewstate;


        // Do the default action for the current state.
yydefault:
        yyn = yydefact[yystate];
        if (yyn == 0)
                goto yyerrlab;

        // Do a reduction.  yyn is the number of a rule to reduce with.
yyreduce:
        yylen = yyr2[yyn];
        if (yylen > 0)
                yyval = yyvsp[1-yylen]; // implement default value of the action

#ifdef YYDEBUG
        if (yydebug)
                {
                int i;
                Trace(TEXT("Reducing via rule %d (line %d), "), yyn, yyrline[yyn]);

                // Print the symbols being reduced, and their result.
                for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
                        Trace(TEXT("%s "), yytname[yyrhs[i]]);
                Trace(TEXT(" -> %s\n"), yytname[yyr1[yyn]]);
                }
#endif

$   /* the action file gets copied in in place of this dollarsign */
#line 498 "bison.simple"

        yyvsp -= yylen;
        yyssp -= yylen;

#ifdef YYDEBUG
        if (yydebug)
                {
                short *ssp1 = yyss - 1;
                Trace(TEXT("state stack now"));
                while (ssp1 != yyssp)
                        Trace(TEXT(" %d"), *++ssp1);
                Trace(TEXT("\n"), *++ssp1);
                }
#endif

        *++yyvsp = yyval;


        // Now "shift" the result of the reduction.
        // Determine what state that goes to,
        // based on the state we popped back to
        // and the rule number reduced by.

        yyn = yyr1[yyn];

        yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
        if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
                yystate = yytable[yystate];
        else
                yystate = yydefgoto[yyn - YYNTBASE];

        goto yynewstate;


yyerrlab:   // here on detecting error
        if (yylval)
                {
                DeleteDBQT(yylval);
                yylval = NULL;
                }

        if (!yyerrstatus) // If not already recovering from an error, report this error.
                {
                    ++yynerrs;

#ifdef YYERROR_VERBOSE
                    yyn = yypact[yystate];

                    if ( yyn > YYFLAG && yyn < YYLAST )
                    {
                        int size = 0;
                        int x, count;

                        count = 0;
                        // Start X at -yyn if nec to avoid negative indexes in yycheck.
                        for ( x = (yyn < 0 ? -yyn : 0); 
                              x < (sizeof(yytname) / sizeof(TCHAR *)) &&  ( (x + yyn) < sizeof(yycheck) / sizeof(short)); 
                              x++ )
                        {
                            if ( yycheck[x + yyn] == x ) 
                            {
                                size += (wcslen(yytname[x]) + 3) * sizeof(TCHAR);
                                count++;
                            }
                        }

                        XPtrST<WCHAR> xMsg( new WCHAR[size] );
                        
                        wcscpy(xMsg.GetPointer(), L"");

                        m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                        if ( wcslen((YY_CHAR*)m_yylex.YYText()) )
                            m_pIPTProperties->SetErrorToken( (YY_CHAR*)m_yylex.YYText() );
                        else
                            m_pIPTProperties->SetErrorToken(L"<end of input>");

                        if (count < 10)
                        {
                            count = 0;
                            for ( x = (yyn < 0 ? -yyn : 0);
                                  x < (sizeof(yytname) / sizeof(TCHAR *)) &&  ( (x + yyn) < sizeof(yycheck) / sizeof(short)); 
                                  x++ )
                            {    
                                if (yycheck[x + yyn] == x)
                                {
                                    if (count > 0)
                                        wcscat( xMsg.GetPointer(), L", " );
                                    wcscat(xMsg.GetPointer(), yytname[x]);
                                    count++;
                                }
                            }
                            m_pIPTProperties->SetErrorToken( xMsg.GetPointer() );
                        }

                xMsg.Free();
                }
      else
#endif /* YYERROR_VERBOSE */
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
        }
        goto yyerrlab1;



yyerrlab1:   // here on error raised explicitly by an action 

        if (yyerrstatus == 3)
                {       // if just tried and failed to reuse lookahead token after an error, discard it.
                        // return failure if at end of input
                if (YYAPI_TOKENNAME == YYEOF)
                        YYABORT(DB_E_ERRORSINCOMMAND);

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Discarding token %s (%d).\n"), yytname[yychar1], YYAPI_TOKENNAME);
#endif
                YYAPI_TOKENNAME = YYEMPTY;
                }

        // Else will try to reuse lookahead token after shifting the error token.
        yyerrstatus = 3;                // Each real token shifted decrements this
        goto yyerrhandle;


yyerrdefault:   // current state does not do anything special for the error token.
yyerrpop:               // pop the current state because it cannot handle the error token 

        if (yyssp == yyss)
                YYABORT(E_FAIL);

        if (NULL != *yyvsp)
                {
                DeleteDBQT(*yyvsp);
                }
        yyvsp--;
        yystate = *--yyssp;

#ifdef YYDEBUG
        if (yydebug)
                {
                short *ssp1 = yyss - 1;
                Trace(TEXT("Error: state stack now"));
                while (ssp1 != yyssp)
                        Trace(TEXT(" %d"), *++ssp1);
                Trace(TEXT("\n"));
                }
#endif


yyerrhandle:
        yyn = yypact[yystate];
        if (yyn == YYFLAG)
                goto yyerrdefault;

        yyn += YYTERROR;
        if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
                goto yyerrdefault;

        yyn = yytable[yyn];
        if (yyn < 0)
                {
                if (yyn == YYFLAG)
                        goto yyerrpop;
                yyn = -yyn;
                goto yyreduce;
                }
        else if (yyn == 0)
                goto yyerrpop;

        if (yyn == YYFINAL)
                YYACCEPT;

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Shifting error token, "));
#endif

        *++yyvsp = yylval;

        yystate = (short)yyn;
        goto yynewstate;
        }


#pragma warning(default:102)


#ifdef YYDUMP
void YYPARSER::DumpYYS()
        {
        short stackindex;

        yyprintf(TEXT("short yys[%d] {\n"), YYMAXDEPTH);
        for (stackindex = 0; stackindex < YYMAXDEPTH; stackindex++)
                {
                if (stackindex)
                        yyprintf(TEXT(", %s"), stackindex % 10 ? TEXT("\0") : TEXT("\n"));
                yyprintf(TEXT("%6d"), yys[stackindex]);
                }
        yyprintf(TEXT("\n};\n"));
        }

void YYPARSER::DumpYYV()
        {
        short valindex;

        yyprintf(TEXT("YYSTYPE yyv[%d] {\n"), YYMAXDEPTH);
        for (valindex = 0; valindex < YYMAXDEPTH; valindex++)
                {
                if (valindex)
                        yyprintf(TEXT(", %s"), valindex % 5 ? TEXT("\0") : TEXT("\n"));
                yyprintf(TEXT("%#*x"), 3+sizeof(YYSTYPE), yyv[valindex]);
                }
        yyprintf(TEXT("\n};\n"));
        }
#endif


int YYPARSER::NoOfErrors()
        {
        return yynerrs;
        }


int YYPARSER::ErrRecoveryState()
        {
        return yyerrflag;
        }


void YYPARSER::ClearErrRecoveryState()
        {
        yyerrflag = 0;
        }


YYAPI_TOKENTYPE YYPARSER::GetCurrentToken()
        {
        return YYAPI_TOKENNAME;
        }


void YYPARSER::SetCurrentToken(YYAPI_TOKENTYPE newToken)
        {
        YYAPI_TOKENNAME = newToken;
        }



void YYPARSER::Trace(TCHAR *message)
        {
#ifdef YYDEBUG
        yyprintf(message);
#endif
        }

void YYPARSER::Trace(TCHAR *message, const TCHAR *tokname, short state /*= 0*/)
        {
#ifdef YYDEBUG
        yyprintf(message, tokname, state);
#endif
        }

void YYPARSER::Trace(TCHAR *message, int state, short tostate /*= 0*/, short token /*= 0*/)
        {
#ifdef YYDEBUG
        yyprintf(message, state, tostate, token);
#endif
        }


void YYPARSER::yySetBuffer(short iBuffer, YY_CHAR *szValue)
        {
        if (iBuffer >= 0 && iBuffer < maxYYBuffer)
                rgpszYYBuffer[iBuffer] = szValue;
        }


YY_CHAR *YYPARSER::yyGetBuffer(short iBuffer)
        {
        if (iBuffer >= 0 && iBuffer < maxYYBuffer)
                return rgpszYYBuffer[iBuffer];
        else
                return (YY_CHAR *)NULL;
        }


void YYPARSER::yyprimebuffer(YY_CHAR *pszBuffer)
        {
        m_yylex.yyprimebuffer(pszBuffer);
        }


void YYPARSER::yyprimelexer(int eToken)
        {
        m_yylex.yyprimelexer(eToken);
        }

void YYPARSER::EmptyValueStack()
        {
        if ((*yyvsp != yylval) && (NULL != yylval))
                DeleteDBQT(yylval);

        while (yyvsp != yyvsa)
                {
                if (NULL != *yyvsp)
                        DeleteDBQT(*yyvsp);
                yyvsp--;
                }
//@TODO RE-ACTIVATE
// note:  This was only done to empty any scope arrays
//      m_pIPSession->SetScopeProperties(m_pICommand);
        if (m_pIPTProperties->GetContainsColumn())
                DeleteDBQT(m_pIPTProperties->GetContainsColumn());

        m_pIPTProperties->SetContainsColumn(NULL);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\colname.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module colname.cpp |
//
//  Contains utility functions for maintaining property lists (symbol table?)
//
// @rev   0 | 12-Feb-97 | v-charca      | Created
//        1 | 24-Oct-98 | danleg        | cleanup
//
#pragma hdrstop
#include "msidxtr.h"

const BYTE randomNumbers[] =
    {   // Pseudorandom Permutation of the Integers 0 through 255: CACM 33 6 p678
      1,  87,  49,  12, 176, 178, 102, 166, 121, 193,   6,  84, 249, 230,  44, 163,
     14, 197, 213, 181, 161,  85, 218,  80,  64, 239,  24, 226, 236, 142,  38, 200,
    110, 177, 104, 103, 141, 253, 255,  50,  77, 101,  81,  18,  45,  96,  31, 222,
     25, 107, 190,  70,  86, 237, 240,  34,  72, 242,  20, 214, 244, 227, 149, 235,
     97, 234,  57,  22,  60, 250,  82, 175, 208,   5, 127, 199, 111,  62, 135, 248,
    174, 169, 211,  58,  66, 154, 106, 195, 245, 171,  17, 187, 182, 179,   0, 243,
    132,  56, 148,  75, 128, 133, 158, 100, 130, 126,  91,  13, 153, 246, 216, 219,
    119,  68, 223,  78,  83,  88, 201,  99, 122,  11,  92,  32, 136, 114,  52,  10,
    138,  30,  48, 183, 156,  35,  61,  26, 143,  74, 251,  94, 129, 162,  63, 152,
    170,   7, 115, 167, 241, 206,   3, 150,  55,  59, 151, 220,  90,  53,  23, 131,
    125, 173,  15, 238,  79,  95,  89,  16, 105, 137, 225, 224, 217, 160,  37, 123,
    118,  73,   2, 157,  46, 116,   9, 145, 134, 228, 207, 212, 202, 215,  69, 229,
     27, 188,  67, 124, 168, 252,  42,   4,  29, 108,  21, 247,  19, 205,  39, 203,
    233,  40, 186, 147, 198, 192, 155,  33, 164, 191,  98, 204, 165, 180, 117,  76,
    140,  36, 210, 172,  41,  54, 159,   8, 185, 232, 113, 196, 231,  47, 146, 120,
     51,  65,  28, 144, 254, 221,  93, 189, 194, 139, 112,  43,  71, 109, 184, 209
    };



//-----------------------------------------------------------------------------
//  @mfunc Constructor
//
//  @side No designed side effects.
//
//-----------------------------------------------------------------------------
CPropertyList::CPropertyList(
    CPropertyList** ppGlobalPropertyList    // in | caller's property list
    ) : m_aBucket( 47 ),                    // number of hash buckets (PRIME!)
        m_cMaxBucket( 47 ),
        m_ppGlobalPropertyList( ppGlobalPropertyList )
{
    RtlZeroMemory( m_aBucket.Get(), m_aBucket.SizeOf() );
}

//-----------------------------------------------------------------------------
// @mfunc Constructor
//
// @side No designed side effects.
//
//-----------------------------------------------------------------------------
CPropertyList::~CPropertyList()
{
    // delete the hash table
    for (int i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = m_aBucket[i];
        tagHASHENTRY*   pNextHashEntry = NULL;
        while (NULL != pHashEntry)
        {
            delete [] pHashEntry->wcsFriendlyName;
            if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                delete [] pHashEntry->dbCol.uName.pwszName;
            pNextHashEntry = pHashEntry->pNextHashEntry;
            delete [] pHashEntry;
            pHashEntry = pNextHashEntry;
        }
    }
}


/* Hashing function described in                   */
/* "Fast Hashing of Variable-Length Text Strings," */
/* by Peter K. Pearson, CACM, June 1990.           */


inline UINT CPropertyList::GetHashValue(
    LPWSTR wszPropertyName          //@parm IN | character string to hash
    )
{
    int iHash  = 0;
    char *szPropertyName = (char*) wszPropertyName;
    int cwch = wcslen(wszPropertyName)*2;
    for (int i=0; i<cwch; i++)
        iHash ^= randomNumbers[*szPropertyName++];
    return iHash % m_cMaxBucket;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to create a property table to be used in a CITextToSelectTree call
// (passthrough query).  The global and local properties need to be stuffed
// into a nice contiguous array.
//
// @side None
// @rdesc CIPROPERTYDEF*
//-----------------------------------------------------------------------------
CIPROPERTYDEF* CPropertyList::GetPropertyTable(
    UINT *  pcSize      // @parm out | size of property table
    )
{
    *pcSize = 0;
    for (int i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = (*m_ppGlobalPropertyList)->m_aBucket[i];
        while (NULL != pHashEntry)
        {
            pHashEntry = pHashEntry->pNextHashEntry;
            (*pcSize)++;
        }
    }

    for (i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = m_aBucket[i];
        while (NULL != pHashEntry)
        {
            pHashEntry = pHashEntry->pNextHashEntry;
            (*pcSize)++;
        }
    }

    XArray<CIPROPERTYDEF> xCiPropTable( *pcSize );

    TRY
    {
        RtlZeroMemory( xCiPropTable.Get(), xCiPropTable.SizeOf() );

        *pcSize = 0;
        for ( i=0; i<m_cMaxBucket; i++ )
        {
            tagHASHENTRY*   pHashEntry = (*m_ppGlobalPropertyList)->m_aBucket[i];
            while ( NULL != pHashEntry )
            {
                xCiPropTable[*pcSize].wcsFriendlyName = CopyString( pHashEntry->wcsFriendlyName );
                xCiPropTable[*pcSize].dbType          = pHashEntry->dbType;
                xCiPropTable[*pcSize].dbCol           = pHashEntry->dbCol;

                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = CopyString( pHashEntry->dbCol.uName.pwszName );
                else
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = pHashEntry->dbCol.uName.pwszName;

                pHashEntry = pHashEntry->pNextHashEntry;
                (*pcSize)++;
            }
        }

        for (i=0; i<m_cMaxBucket; i++)
        {
            tagHASHENTRY*   pHashEntry = m_aBucket[i];
            while (NULL != pHashEntry)
            {
                xCiPropTable[*pcSize].wcsFriendlyName = CopyString( pHashEntry->wcsFriendlyName );
                xCiPropTable[*pcSize].dbType          = pHashEntry->dbType;
                xCiPropTable[*pcSize].dbCol           = pHashEntry->dbCol;

                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = CopyString( pHashEntry->dbCol.uName.pwszName );
                else
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = pHashEntry->dbCol.uName.pwszName;

                pHashEntry = pHashEntry->pNextHashEntry;
                (*pcSize)++;
            }
        }
    }
    CATCH( CException, e )
    {
        // free the table
        
        for ( unsigned i=0; i<xCiPropTable.Count(); i++ )
        {
            delete [] xCiPropTable[i].wcsFriendlyName;
            if ( DBKIND_GUID_NAME == xCiPropTable[i].dbCol.eKind )
                delete [] xCiPropTable[i].dbCol.uName.pwszName;
        }

        RETHROW();
    }
    END_CATCH

    return xCiPropTable.Acquire();
}


//-----------------------------------------------------------------------------
// @mfunc
//
// Method to delete a property table used in a CITextToSelectTree call
// (passthrough query).  
//
// @side None
// @rdesc HRESULT
//-----------------------------------------------------------------------------
void CPropertyList::DeletePropertyTable(
    CIPROPERTYDEF*  pCiPropTable,       // @parm in | property table to be deleted
    UINT            cSize               // @parm in | size of property table
    )
{
    for ( UINT i=0; i<cSize; i++ )
    {
        delete [] pCiPropTable[i].wcsFriendlyName;
        if ( DBKIND_GUID_NAME == pCiPropTable[i].dbCol.eKind )
            delete [] pCiPropTable[i].dbCol.uName.pwszName;
    }
    delete pCiPropTable;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc CIPROPERDEF*
//-----------------------------------------------------------------------------
HASHENTRY *CPropertyList::FindPropertyEntry(
    LPWSTR  wszPropertyName,
    UINT    *puHashValue
    )
{
    HASHENTRY *pHashEntry = NULL;

    *puHashValue = GetHashValue(wszPropertyName);
    for (pHashEntry = m_aBucket[*puHashValue]; pHashEntry; pHashEntry = pHashEntry->pNextHashEntry)
    {
        if ( (*puHashValue==pHashEntry->wHashValue) &&
             (_wcsicmp(wszPropertyName, pHashEntry->wcsFriendlyName)==0) )
            return pHashEntry;
    }
    return NULL;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc CIPROPERDEF*
//-----------------------------------------------------------------------------
HASHENTRY *CPropertyList::GetPropertyEntry(
    LPWSTR  wszPropertyName,
    UINT    *puHashValue
    )
{
    HASHENTRY *pHashEntry = NULL;

    if ( 0 != m_ppGlobalPropertyList && 0 != *m_ppGlobalPropertyList )
    {
        pHashEntry = (*m_ppGlobalPropertyList)->FindPropertyEntry( wszPropertyName, puHashValue );
        if ( 0 != pHashEntry )
            return pHashEntry;
    }

    pHashEntry = FindPropertyEntry( wszPropertyName, puHashValue );
    return pHashEntry;
}


//--------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc HRESULT
//      S_OK            successfull operation
//      E_FAIL          property isn't defined
//      E_INVALIDARG    ppct or pdbType was null
//      E_OUTOFMEMORY   just what it says
//--------------------------------------------------------------------
HRESULT CPropertyList::LookUpPropertyName(
    LPWSTR          wszPropertyName,    // @parm IN
    DBCOMMANDTREE** ppct,               // @parm OUT
    DBTYPE*         pdbType             // @parm OUT
    )
{
    UINT        uHashValue;
    if ( 0 == ppct || 0 == pdbType)
        return E_INVALIDARG;

    HASHENTRY   *pHashEntry = GetPropertyEntry(wszPropertyName, &uHashValue);
    if ( 0 != pHashEntry )
    {
            *pdbType = (DBTYPE)pHashEntry->dbType;
            *ppct = PctCreateNode(DBOP_column_name, DBVALUEKIND_ID, NULL);
            if ( 0 != *ppct )
            {
                (*ppct)->value.pdbidValue->eKind = pHashEntry->dbCol.eKind;
                (*ppct)->value.pdbidValue->uGuid.guid = pHashEntry->dbCol.uGuid.guid;
                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                    (*ppct)->value.pdbidValue->uName.pwszName = CoTaskStrDup( pHashEntry->dbCol.uName.pwszName );
                else
                {
                    Assert( DBKIND_GUID_PROPID == pHashEntry->dbCol.eKind );
                    (*ppct)->value.pdbidValue->uName.pwszName = pHashEntry->dbCol.uName.pwszName;
                }
                return S_OK;
            }
            else
                return E_OUTOFMEMORY;
    }
    else
        return E_FAIL;
}


//-----------------------------------------------------------------------------
// @func SetPropertyEntry
//
// Insert the specified property into the symbol table.
// If it is already there, redefine its value.
//
// @rdesc HRESULT
// @flag  S_OK          | ok
// @flag  E_OUTOFMEMORY | out of memory
//-----------------------------------------------------------------------------
HRESULT CPropertyList::SetPropertyEntry(
    LPWSTR  wcsFriendlyName,        // @parm IN | name of property
    DWORD   dbType,                 // @parm IN | dbtype of property
    GUID    guid,                   // @parm IN | GUID defining the property
    DBKIND  eKind,                  // @parm IN | type of PropId (currently GUID_NAME or GUID_PROPID)
    LPWSTR  pwszPropName,           // @parm IN | either a name or propid
    BOOL    fGlobal )               // @parm IN | TRUE if global definition; FALSE if local
{
    SCODE sc = S_OK;

    TRY
    {
        UINT uhash=0;
        HASHENTRY* pHashEntry = GetPropertyEntry(wcsFriendlyName, &uhash);

        if ( 0 != pHashEntry )
        {
            // Redefining a user defined property.
            // Delete the old property definition.
            if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
            {
                XPtrST<WCHAR> xName( CopyString(pwszPropName) );
                delete [] pHashEntry->dbCol.uName.pwszName;
                pHashEntry->dbCol.uName.pwszName = xName.Acquire();
            }

            pHashEntry->dbType           = dbType;
            pHashEntry->dbCol.uGuid.guid = guid;
            pHashEntry->dbCol.eKind      = eKind;
        }
        else
        {
            XPtr<HASHENTRY> xHashEntry( new HASHENTRY );
            xHashEntry->wHashValue = uhash;
            XPtrST<WCHAR> xName( CopyString(wcsFriendlyName) );
            xHashEntry->dbType           = dbType;
            xHashEntry->dbCol.uGuid.guid = guid;
            xHashEntry->dbCol.eKind      = eKind;

            if ( DBKIND_GUID_NAME == eKind )
                xHashEntry->dbCol.uName.pwszName = CopyString( pwszPropName );
            else
                xHashEntry->dbCol.uName.pwszName = pwszPropName;

            xHashEntry->wcsFriendlyName = xName.Acquire();

            xHashEntry->pNextHashEntry = m_aBucket[uhash];  // Add to head of singly-linked list
            m_aBucket[uhash] = xHashEntry.Acquire();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
} // SetPropertyEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\colname.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module colname.h |
//
//      Contains utility functions for maintaining property lists (symbol table?)
//
// @rev   0 | 12-Feb-97 | v-charca              | Created
//        1 | 24-Oct-98 | danleg                | cleanup
//

#ifndef __PROPERTYLIST_INCL__
#define __PROPERTYLIST_INCL__


//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline WCHAR * CopyString( WCHAR const * pwc )
{
    unsigned c = wcslen( pwc ) + 1;
    WCHAR *pwcNew = new WCHAR[c];
    RtlCopyMemory( pwcNew, pwc, c * sizeof WCHAR );
    return pwcNew;
}

//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline LPWSTR CoTaskStrDup
    (
    const WCHAR *   pwszOrig,
    UINT            cLen
    )
{
    UINT cBytes = (cLen+1) * sizeof WCHAR;
    WCHAR* pwszCopy = (WCHAR *) CoTaskMemAlloc( cBytes );
    if ( 0 != pwszCopy )
        RtlCopyMemory( pwszCopy, pwszOrig, cBytes );
    return pwszCopy;
}


//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline LPWSTR CoTaskStrDup
    (
    const WCHAR * pwszOrig
    )
{
    return CoTaskStrDup( pwszOrig, wcslen(pwszOrig) );
}



//--------------------------------------------------------------------
typedef struct tagHASHENTRY
    {
    LPWSTR          wcsFriendlyName;
    UINT            wHashValue;
    DWORD           dbType;
    DBID            dbCol;
    tagHASHENTRY*   pNextHashEntry;
    } HASHENTRY;

class CPropertyList
{
public: //@access public functions
    CPropertyList(CPropertyList** ppGlobalPropertyList);
    ~CPropertyList();

    HRESULT LookUpPropertyName( LPWSTR          wszPropertyName, 
                                DBCOMMANDTREE** ppct, 
                                DBTYPE*         pdbType );

    HRESULT SetPropertyEntry  ( LPWSTR  pwszFriendlyName,
                                DWORD   dbType, 
                                GUID    guidPropset,
                                DBKIND  eKind, 
                                LPWSTR  pwszPropName,
                                BOOL    fGlobal );

    CIPROPERTYDEF* GetPropertyTable( UINT* pcSize );

    void DeletePropertyTable( CIPROPERTYDEF* pCiPropTable, 
                              UINT cSize );

protected: //@access protected functions
    HASHENTRY* FindPropertyEntry( LPWSTR wszPropertyName, 
                                  UINT *puHashValue );

    HASHENTRY* GetPropertyEntry( LPWSTR wszPropertyName, 
                                 UINT *puHashValue );

    inline UINT GetHashValue( LPWSTR wszPropertyName );

protected: //@access protected data
    XArray<HASHENTRY*>      m_aBucket;                  // Array of pointers to hash buckets
    int                     m_cMaxBucket;               // Number of hash buckets (PRIME!)
    CPropertyList**         m_ppGlobalPropertyList;     // Pointer to the global property list
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\headers.cpp ===
//-----------------------------------------------------------------------------------
// Microsoft Monarch Parser
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module HEADERS.CPP | precompiled headers module
//
// @rev 1 | 10-17-97 | Briants | Created
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop
#include "msidxtr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\flexcpp.h ===
// $Header: /Monarch/src/msidxtr/flexcpp.h 10    8/01/97 2:17p A-charca $

// FlexLexer.h -- define interfaces for lexical analyzer classes generated
//        by flex

// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

// This file defines FlexLexer, an abstract class which specifies the
// external interface provided to flex C++ lexer objects, and YYLEXER,
// which defines a particular lexer class.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each YYLEXER to some other xxFlexLexer.  You then
// include <FlexLexer.h> in your other sources once per lexer class:
//
//  #undef YYLEXER
//  #define YYLEXER xxFlexLexer
//  #include <FlexLexer.h>
//
//  #undef YYLEXER
//  #define YYLEXER zzFlexLexer
//  #include <FlexLexer.h>
//  ...

#ifndef __FLEX_LEXER_H
// Never included before - need to define base class.
#define __FLEX_LEXER_H

#ifndef YY_CHAR
#define YY_CHAR TCHAR
#endif

#ifdef UNICODE
# define strdup _wcsdup
# define strlen wcslen
# define atol   _wtol
inline double strtof(wchar_t *s) { char tmp[255]; wcstombs(tmp, s, 255); return atof(tmp); }
#else
# define strdup _strdup
# define strlen strlen
# define atol   atol
# define strtof atof
#endif


// extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

class FlexLexer {
public:
//  virtual ~FlexLexer() = 0;

    const YY_CHAR* YYText() { return yytext; }
    int YYLeng()        { return yyleng; }

    virtual void
        yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
    virtual struct yy_buffer_state*
        yy_create_buffer( int size ) = 0;
    virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
    virtual void yyrestart( ) = 0;

    virtual int yylex(YYSTYPE *yylval) = 0;

    int lineno() const      { return yylineno; }

    int debug() const       { return yy_flex_debug; }
    void set_debug( int flag )  { yy_flex_debug = flag; }

protected:
    YY_CHAR* yytext;
    int yyleng;
    int yylineno;       // only maintained if you use %option yylineno
    int yy_flex_debug;  // only has effect with -d or "%option debug"
};

// }
#endif

#if defined(YYLEXER) || ! defined(yyFlexLexerOnce)
// Either this is the first time through (yyFlexLexerOnce not defined),
// or this is a repeated include to define a different flavor of
// YYLEXER, as discussed in the flex man page.
#define yyFlexLexerOnce

class YYPARSER; // forward declaration

class YYLEXER : public FlexLexer {
public:
    YYLEXER();
    virtual ~YYLEXER();

    void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
    struct yy_buffer_state* yy_create_buffer( int size );
    void yy_delete_buffer( struct yy_buffer_state* b );
    void yyrestart( );

    int yylex(YYSTYPE *yylval);

    void yyprimebuffer(YY_CHAR *pszBuffer);
    int yybufferinput(YY_CHAR *pszBuffer, int cMax);

    void yyprimelexer(int eToken);

protected:
    virtual int LexerInput( YY_CHAR* buf, int max_size );
    virtual void LexerOutput( const YY_CHAR* buf, int size );
    virtual void LexerError( const YY_CHAR* msg );
#ifdef DEBUG
    virtual void LexerTrace(const YY_CHAR* buf, int size, int tknNum);
#endif

    void yyunput( int c, YY_CHAR* buf_ptr );
    int yyinput();

    void ResetLexer();
    void CreateTknValue(YYSTYPE *ppqt, short tknNum, YY_CHAR wch = L'\0', BOOL fQuote = FALSE);
    void yy_load_buffer_state();
    void yy_init_buffer( struct yy_buffer_state* b );
    void yy_flush_buffer( struct yy_buffer_state* b );

    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int* yy_start_stack;

    void yy_push_state( int new_state );
    void yy_pop_state();
    int yy_top_state();

    yy_state_type yy_get_previous_state();
    yy_state_type yy_try_NUL_trans( yy_state_type current_state );
    int yy_get_next_buffer();

    struct yy_buffer_state* yy_current_buffer;

    // yy_hold_char holds the character lost when yytext is formed.
    YY_CHAR yy_hold_char;

    // Number of characters read into yy_ch_buf.
    int yy_n_chars;

    // Points to current character in buffer.
    YY_CHAR* yy_c_buf_p;
    YY_CHAR *pCurBuffer, *pszInputBuffer;
    int cInputBuffer;

    int yy_init;        // whether we need to initialize
    int yy_start;       // start state number
    int yyprimetoken;   // priming token

    // Flag which is used to allow yywrap()'s to do buffer switches
    // instead of setting up a fresh yyin.  A bit of a hack ...
    int yy_did_buffer_switch_on_eof;

    // The following are not always needed, but may be depending
    // on use of certain flex features (like REJECT or yymore()).

    yy_state_type yy_last_accepting_state;
    YY_CHAR* yy_last_accepting_cpos;

    yy_state_type* yy_state_buf;
    yy_state_type* yy_state_ptr;

    YY_CHAR* yy_full_match;
    int* yy_full_state;
    int yy_full_lp;

    int yy_lp;
    int yy_looking_for_trail_begin;

    int yy_more_flag;
    int yy_more_len;
    int yy_more_offset;
    int yy_prev_more_offset;
#ifdef DEBUG
    int tkndebug;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sdk\iissearch\adovbs.inc ===
<%
'--------------------------------------------------------------------
' Microsoft ADO
'
' (c) 1996 Microsoft Corporation.  All Rights Reserved.
'
'
'
' ADO constants include file for VBScript
'
'--------------------------------------------------------------------

'---- CursorTypeEnum Values ----
Const adOpenForwardOnly = 0
Const adOpenKeyset = 1
Const adOpenDynamic = 2
Const adOpenStatic = 3

'---- CursorOptionEnum Values ----
Const adHoldRecords = &H00000100
Const adMovePrevious = &H00000200
Const adAddNew = &H01000400
Const adDelete = &H01000800
Const adUpdate = &H01008000
Const adBookmark = &H00002000
Const adApproxPosition = &H00004000
Const adUpdateBatch = &H00010000
Const adResync = &H00020000
Const adNotify = &H00040000

'---- LockTypeEnum Values ----
Const adLockReadOnly = 1
Const adLockPessimistic = 2
Const adLockOptimistic = 3
Const adLockBatchOptimistic = 4

'---- ExecuteOptionEnum Values ----
Const adRunAsync = &H00000010

'---- ObjectStateEnum Values ----
Const adStateClosed = &H00000000
Const adStateOpen = &H00000001
Const adStateConnecting = &H00000002
Const adStateExecuting = &H00000004

'---- CursorLocationEnum Values ----
Const adUseNone = 1
Const adUseServer = 2
Const adUseClient = 3
Const adUseClientBatch = 3

'---- DataTypeEnum Values ----
Const adEmpty = 0
Const adTinyInt = 16
Const adSmallInt = 2
Const adInteger = 3
Const adBigInt = 20
Const adUnsignedTinyInt = 17
Const adUnsignedSmallInt = 18
Const adUnsignedInt = 19
Const adUnsignedBigInt = 21
Const adSingle = 4
Const adDouble = 5
Const adCurrency = 6
Const adDecimal = 14
Const adNumeric = 131
Const adBoolean = 11
Const adError = 10
Const adUserDefined = 132
Const adVariant = 12
Const adIDispatch = 9
Const adIUnknown = 13
Const adGUID = 72
Const adDate = 7
Const adDBDate = 133
Const adDBTime = 134
Const adDBTimeStamp = 135
Const adBSTR = 8
Const adChar = 129
Const adVarChar = 200
Const adLongVarChar = 201
Const adWChar = 130
Const adVarWChar = 202
Const adLongVarWChar = 203
Const adBinary = 128
Const adVarBinary = 204
Const adLongVarBinary = 205

'---- FieldAttributeEnum Values ----
Const adFldMayDefer = &H00000002
Const adFldUpdatable = &H00000004
Const adFldUnknownUpdatable = &H00000008
Const adFldFixed = &H00000010
Const adFldIsNullable = &H00000020
Const adFldMayBeNull = &H00000040
Const adFldLong = &H00000080
Const adFldRowID = &H00000100
Const adFldRowVersion = &H00000200
Const adFldCacheDeferred = &H00001000

'---- EditModeEnum Values ----
Const adEditNone = &H0000
Const adEditInProgress = &H0001
Const adEditAdd = &H0002

'---- RecordStatusEnum Values ----
Const adRecOK = &H0000000
Const adRecNew = &H0000001
Const adRecModified = &H0000002
Const adRecDeleted = &H0000004
Const adRecUnmodified = &H0000008
Const adRecInvalid = &H0000010
Const adRecMultipleChanges = &H0000040
Const adRecPendingChanges = &H0000080
Const adRecCanceled = &H0000100
Const adRecCantRelease = &H0000400
Const adRecConcurrencyViolation = &H0000800
Const adRecIntegrityViolation = &H0001000
Const adRecMaxChangesExceeded = &H0002000
Const adRecObjectOpen = &H0004000
Const adRecOutOfMemory = &H0008000
Const adRecPermissionDenied = &H0010000
Const adRecSchemaViolation = &H0020000
Const adRecDBDeleted = &H0040000

'---- GetRowsOptionEnum Values ----
Const adGetRowsRest = -1

'---- PositionEnum Values ----
Const adPosUnknown = -1
Const adPosBOF = -2
Const adPosEOF = -3

'---- enum Values ----
Const adBookmarkCurrent = 0
Const adBookmarkFirst = 1
Const adBookmarkLast = 2

'---- MarshalOptionsEnum Values ----
Const adMarshalAll = 0
Const adMarshalModifiedOnly = 1

'---- AffectEnum Values ----
Const adAffectCurrent = 1
Const adAffectGroup = 2
Const adAffectAll = 3

'---- FilterGroupEnum Values ----
Const adFilterNone = 0
Const adFilterPendingRecords = 1
Const adFilterAffectedRecords = 2
Const adFilterFetchedRecords = 3
Const adFilterPredicate = 4

'---- SearchDirection Values ----
Const adSearchForward = 0
Const adSearchBackward = 1

'---- ConnectPromptEnum Values ----
Const adPromptAlways = 1
Const adPromptComplete = 2
Const adPromptCompleteRequired = 3
Const adPromptNever = 4

'---- ConnectModeEnum Values ----
Const adModeUnknown = 0
Const adModeRead = 1
Const adModeWrite = 2
Const adModeReadWrite = 3
Const adModeShareDenyRead = 4
Const adModeShareDenyWrite = 8
Const adModeShareExclusive = &Hc
Const adModeShareDenyNone = &H10

'---- IsolationLevelEnum Values ----
Const adXactUnspecified = &Hffffffff
Const adXactChaos = &H00000010
Const adXactReadUncommitted = &H00000100
Const adXactBrowse = &H00000100
Const adXactCursorStability = &H00001000
Const adXactReadCommitted = &H00001000
Const adXactRepeatableRead = &H00010000
Const adXactSerializable = &H00100000
Const adXactIsolated = &H00100000

'---- XactAttributeEnum Values ----
Const adXactCommitRetaining = &H00020000
Const adXactAbortRetaining = &H00040000

'---- PropertyAttributesEnum Values ----
Const adPropNotSupported = &H0000
Const adPropRequired = &H0001
Const adPropOptional = &H0002
Const adPropRead = &H0200
Const adPropWrite = &H0400

'---- ErrorValueEnum Values ----
Const adErrInvalidArgument = &Hbb9
Const adErrNoCurrentRecord = &Hbcd
Const adErrIllegalOperation = &Hc93
Const adErrInTransaction = &Hcae
Const adErrFeatureNotAvailable = &Hcb3
Const adErrItemNotFound = &Hcc1
Const adErrObjectInCollection = &Hd27
Const adErrObjectNotSet = &Hd5c
Const adErrDataConversion = &Hd5d
Const adErrObjectClosed = &He78
Const adErrObjectOpen = &He79
Const adErrProviderNotFound = &He7a
Const adErrBoundToCommand = &He7b
Const adErrInvalidParamInfo = &He7c
Const adErrInvalidConnection = &He7d
Const adErrStillExecuting = &He7f
Const adErrStillConnecting = &He81

'---- ParameterAttributesEnum Values ----
Const adParamSigned = &H0010
Const adParamNullable = &H0040
Const adParamLong = &H0080

'---- ParameterDirectionEnum Values ----
Const adParamUnknown = &H0000
Const adParamInput = &H0001
Const adParamOutput = &H0002
Const adParamInputOutput = &H0003
Const adParamReturnValue = &H0004

'---- CommandTypeEnum Values ----
Const adCmdUnknown = &H0008
Const adCmdText = &H0001
Const adCmdTable = &H0002
Const adCmdStoredProc = &H0004

'---- SchemaEnum Values ----
Const adSchemaProviderSpecific = -1
Const adSchemaAsserts = 0
Const adSchemaCatalogs = 1
Const adSchemaCharacterSets = 2
Const adSchemaCollations = 3
Const adSchemaColumns = 4
Const adSchemaCheckConstraints = 5
Const adSchemaConstraintColumnUsage = 6
Const adSchemaConstraintTableUsage = 7
Const adSchemaKeyColumnUsage = 8
Const adSchemaReferentialContraints = 9
Const adSchemaTableConstraints = 10
Const adSchemaColumnsDomainUsage = 11
Const adSchemaIndexes = 12
Const adSchemaColumnPrivileges = 13
Const adSchemaTablePrivileges = 14
Const adSchemaUsagePrivileges = 15
Const adSchemaProcedures = 16
Const adSchemaSchemata = 17
Const adSchemaSQLLanguages = 18
Const adSchemaStatistics = 19
Const adSchemaTables = 20
Const adSchemaTranslations = 21
Const adSchemaProviderTypes = 22
Const adSchemaViews = 23
Const adSchemaViewColumnUsage = 24
Const adSchemaViewTableUsage = 25
Const adSchemaProcedureParameters = 26
Const adSchemaForeignKeys = 27
Const adSchemaPrimaryKeys = 28
Const adSchemaProcedureColumns = 29
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\iparser.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE DB iparser object
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module iparser.CPP | IParser object implementation
//
//
#pragma hdrstop
#include    "msidxtr.h"


// CImpIParser::CImpIParser ---------------------------------------------------
//
// @mfunc Constructor
//
CImpIParser::CImpIParser()
{
    m_cRef                = 1;
    m_pGlobalPropertyList = 0;
    m_pGlobalViewList     = 0;
}

// CImpIParser::~CImpIParser --------------------------------------------------
//
// @mfunc Destructor
//
CImpIParser::~CImpIParser()
{
    delete m_pGlobalPropertyList;
    delete m_pGlobalViewList;
}

//-----------------------------------------------------------------------------
// @func CImpIParser::CreateSession 
//
// Creates a unique session within the parser.  This session is required to keep
// the views and properties in their correct lifetimes.
//
// @rdesc HRESULT
//      S_OK                      - IParserSession created
//      DB_E_DIALECTNOTSUPPOERTED - Specified dialect was not supported
//      E_OUTOFMEMORY             - low on resources
//      E_FAIL                    - unexpected error
//      E_INVALIDARG              - pGuidDialect, pIParserVerify, pIColMapCreator, 
//                                  or ppIParserSession was a NULL pointer 
//                                  (DEBUG ONLY). 
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParser::CreateSession(
    const GUID *            pGuidDialect,       // in | dialect for this session
    LPCWSTR                 pwszMachine,        // in | provider's current machine
    IParserVerify *         pIParserVerify,     // in | ptr to ParserVerify
    IColumnMapperCreator *  pIColMapCreator,
    IParserSession **       ppIParserSession )  // out | a unique parser session
{
    SCODE sc = S_OK;

#ifdef DEBUG
    if ( 0 == ppIParserSession || 0 == pIParserVerify ||
         0 == pIColMapCreator ||  0 == pGuidDialect)
        sc = E_INVALIDARG;
    else
#endif
    {
        TRANSLATE_EXCEPTIONS;
        TRY
        {
            if ( 0 != ppIParserSession )
                *ppIParserSession = 0;

            // Check Dialect

            if ( DBGUID_MSSQLTEXT == *pGuidDialect || DBGUID_MSSQLJAWS == *pGuidDialect )
            {
                XPtr<CViewList> xpGlobalViewList;
                if ( 0 == m_pGlobalViewList )
                    xpGlobalViewList.Set( new CViewList() );

                XInterface<CImpIParserSession> 
                    xpIParserSession( new CImpIParserSession( pGuidDialect,
                                                              pIParserVerify,
                                                              pIColMapCreator,
                                                              xpGlobalViewList.GetPointer() ) );

                XPtr<CPropertyList> xpGlobalPropertyList;

                sc = xpIParserSession->FInit( pwszMachine,
                                              &m_pGlobalPropertyList );
                if ( FAILED(sc) )
                    xpIParserSession.Free();
                else
                {
                    if ( 0 == m_pGlobalPropertyList )
                        xpGlobalPropertyList.Set( new CPropertyList(NULL) );
                }

                delete m_pGlobalViewList;
                m_pGlobalViewList = xpGlobalViewList.Acquire();
                delete m_pGlobalPropertyList;
                m_pGlobalPropertyList = xpGlobalPropertyList.Acquire();
                *ppIParserSession = xpIParserSession.Acquire();
            }
            else
                sc = DB_E_DIALECTNOTSUPPORTED;
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH
        UNTRANSLATE_EXCEPTIONS;
    }
    return sc;
}




//-----------------------------------------------------------------------------
// @func CImpIParser::QueryInterface 
//
// @mfunc Returns a pointer to a specified interface. Callers use 
// QueryInterface to determine which interfaces the called object 
// supports. 
//
// @rdesc HResult indicating the status of the method
// @flag S_OK | Interface is supported and ppvObject is set.
// @flag E_NOINTERFACE | Interface is not supported by the object
// @flag E_INVALIDARG | One or more arguments are invalid. 
//-----------------------------------------------------------------------------

STDMETHODIMP CImpIParser::QueryInterface(
    REFIID  riid,           //@parm IN | Interface ID of the interface being queried for. 
    LPVOID* ppv )           //@parm OUT | Pointer to interface that was instantiated      
{
    if ( 0 == ppv )
        return ResultFromScode(E_INVALIDARG);

    //  This is the non-delegating IUnknown implementation
    if ( (riid == IID_IParser) ||
         (riid == IID_IUnknown) )
        *ppv = (LPVOID)this;
    else
        *ppv = 0;

    //  If we're going to return an interface, AddRef it first
    if ( 0 != *ppv )
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
}


//-----------------------------------------------------------------------------
// CImpIParser::AddRef 
//
// @mfunc Increments a persistence count for the object.
//
// @rdesc Reference count after operation.
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CImpIParser::AddRef()
{
    return InterlockedIncrement((long *) &m_cRef);
}


//-----------------------------------------------------------------------------
// CImpIParser::Release 
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CImpIParser::Release()
{
    Assert(m_cRef > 0);

    ULONG cRef= InterlockedDecrement( (long *) &m_cRef );
    if ( 0 == cRef )
    {
        TRACE("IParser refcount=0, now deleting.\n");

        delete this;
        return 0;
    }

    TRACE("IParser refcount=%d after Release().\n", cRef);
    return cRef;
}


//-----------------------------------------------------------------------------
// @func MakeIParser
//
// Creates an IParser
//
// @rdesc HRESULT
//    S_OK if successful; Error code otherwise
//-----------------------------------------------------------------------------
HRESULT __stdcall MakeIParser(
    IParser** ppIParser )
{
    SCODE sc = S_OK;

    if ( 0 == ppIParser )
        sc = E_INVALIDARG;
    else
    {
        TRANSLATE_EXCEPTIONS;
        TRY
        {
            XInterface<CImpIParser> xpIParser( new CImpIParser() );
            *ppIParser = xpIParser.Acquire();
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH
        UNTRANSLATE_EXCEPTIONS;
    }
    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\iparser.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module IPARSER.H | IParser base object and contained interface
// definitions
//
//
#ifndef _IPARSER_H_
#define _IPARSER_H_

// Includes ------------------------------------------------------------------


//----------------------------------------------------------------------------
// @class IParser | 
// CoType Object
//
class CImpIParser : public IParser
    {
    private: //@access private member data
        LONG            m_cRef;
        CViewList*      m_pGlobalViewList;
        CPropertyList*  m_pGlobalPropertyList;

    public: //@access public
        CImpIParser();
        ~CImpIParser();

        //@cmember Request an Interface
        STDMETHODIMP            QueryInterface(REFIID, LPVOID *);
        //@cmember Increments the Reference count
        STDMETHODIMP_(ULONG)    AddRef(void);
        //@cmember Decrements the Reference count
        STDMETHODIMP_(ULONG)    Release(void);

        //@cmember CreateSession method
        STDMETHODIMP CreateSession
                    (
                    const GUID*         pGuidDialect,   // in | dialect for this session
                    LPCWSTR             pwszMachine,    // in | provider's current machine
                    IParserVerify*      pIPVerify,      // in | unknown part of ParserInput
                    IColumnMapperCreator*   pIColMapCreator,
                    IParserSession**    ppIParserSession// out | a unique session of the parser
                    );
    };  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\iparsess.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE DB Parser object
// (C) Copyright Microsoft Corporation, 1997 - 1999.
//
// @doc
//
// @module IParserSession.CPP | IParserSession object implementation
//
//
#pragma hdrstop
#include "msidxtr.h"
#include <ciexcpt.hxx>

// CViewData::CViewData ------------------------------------
//
// @mfunc Constructor
//
CViewData::CViewData() :
    m_pwszViewName( 0 ),
    m_pwszCatalogName( 0 ),
    m_pctProjectList( 0 ),
    m_pCScopeData( 0 )
{
}


// CViewData::CViewData ------------------------------------
//
// @mfunc Destructor
//
CViewData::~CViewData()
{
    delete [] m_pwszViewName;
    delete [] m_pwszCatalogName;

    DeleteDBQT(m_pctProjectList);
    if ( 0 != m_pCScopeData )
        m_pCScopeData->Release();
}


// CViewList::CViewList ------------------------------------
//
// @mfunc Constructor
//
CViewList::CViewList() :
        m_pViewData( 0 )
{
}

// CViewList::~CViewList -----------------------------------
//
// @mfunc Destructor
//
CViewList::~CViewList()
{
    CViewData* pViewData = m_pViewData;
    CViewData* pNextViewData = NULL;
    while( NULL != pViewData )
        {
        pNextViewData = pViewData->m_pNextView;
        delete pViewData;
        pViewData = pNextViewData;
        }
}

// CImpIParserSession::CImpIParserSession ------------------------------------
//
// @mfunc Constructor
//
CImpIParserSession::CImpIParserSession(
    const GUID*             pGuidDialect,       // in | dialect for this session
    IParserVerify*          pIPVerify,          // in |
    IColumnMapperCreator*   pIColMapCreator,    // in |
    CViewList*              pGlobalViewList ) : // in |
            m_pLocalViewList( 0 )
{
    assert( pGuidDialect && pIPVerify && pIColMapCreator );

    m_cRef                      = 1;

    m_lcid                      = LOCALE_SYSTEM_DEFAULT;
    m_dwRankingMethod           = VECTOR_RANK_JACCARD;

    m_pwszCatalog               = NULL;
    m_pwszMachine               = NULL;

    m_pGlobalViewList           = pGlobalViewList;
    m_globalDefinitions         = FALSE;

    m_pColumnMapper             = NULL;
    m_pCPropertyList            = NULL;

    InitializeCriticalSection( &m_csSession );

    m_pIPVerify = pIPVerify;
    m_pIPVerify->AddRef();

    m_pIColMapCreator = pIColMapCreator;
    m_pIColMapCreator->AddRef();

    m_GuidDialect = *pGuidDialect;

    if ( DBGUID_MSSQLTEXT == m_GuidDialect )
        m_dwSQLDialect = DBDIALECT_MSSQLTEXT;
    else if ( DBGUID_MSSQLJAWS == m_GuidDialect )
        m_dwSQLDialect = DBDIALECT_MSSQLJAWS;
    else
        assert( DBGUID_MSSQLTEXT == m_GuidDialect || DBGUID_MSSQLJAWS == m_GuidDialect );
}


// CImpIParserSession::~CImpIParserSession -----------------------------------
//
// @mfunc Destructor
//
CImpIParserSession::~CImpIParserSession()
{
    if( 0 != m_pIPVerify )
        m_pIPVerify->Release();

    if( 0 != m_pIColMapCreator )
        m_pIColMapCreator->Release();

    delete [] m_pwszCatalog;
    delete [] m_pwszMachine;

    delete m_pCPropertyList;
    delete m_pLocalViewList;

    DeleteCriticalSection( &m_csSession );
}


//-----------------------------------------------------------------------------
// @mfunc FInit
//
// Initialize member vars that could potentially fail.
//
//-----------------------------------------------------------------------------
HRESULT CImpIParserSession::FInit(
    LPCWSTR         pwszMachine,            // in | provider's current machine
    CPropertyList** ppGlobalPropertyList )  // in | caller's property list
{
    assert( 0 == m_pCPropertyList );
    assert( 0 != pwszMachine && 0 == m_pwszMachine );

    SCODE sc = S_OK;
    TRY
    {
        XPtrST<WCHAR> xMachine( CopyString(pwszMachine) );
        XPtr<CPropertyList> xpPropertyList( new CPropertyList(ppGlobalPropertyList) );
        XPtr<CViewList> xpLocalViewList( new CViewList() );

        Win4Assert( 0 == m_pCPropertyList );
        m_pCPropertyList = xpPropertyList.Acquire();

        Win4Assert( 0 == m_pLocalViewList );
        m_pLocalViewList = xpLocalViewList.Acquire();

        m_pwszMachine = xMachine.Acquire();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CImpIParserSession::QueryInterface ----------------------------------
//
// @mfunc Returns a pointer to a specified interface. Callers use
// QueryInterface to determine which interfaces the called object
// supports.
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Interface is supported and ppvObject is set.
//      @flag E_NOINTERFACE | Interface is not supported by the object
//      @flag E_INVALIDARG | One or more arguments are invalid.
//
STDMETHODIMP CImpIParserSession::QueryInterface(
    REFIID   riid,              //@parm IN | Interface ID of the interface being queried for.
    LPVOID * ppv )              //@parm OUT | Pointer to interface that was instantiated
{
    if( 0 == ppv )
        return ResultFromScode(E_INVALIDARG);

    if( (riid == IID_IUnknown) ||
        (riid == IID_IParserSession) )
        *ppv = (LPVOID)this;
    else
        *ppv = 0;


    //  If we're going to return an interface, AddRef it first
    if( 0 != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


// CImpIParserSession::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserSession::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CImpIParserSession::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserSession::Release (void)
{
    assert( m_cRef > 0 );

    ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


//-----------------------------------------------------------------------------
// @func CImpIParserSession::ToTree
//
// Transform a given text command to a valid command tree
//
// @rdesc HRESULT
//      S_OK           - Text was translated into DBCOMMANDTREE
//      DB_S_NORESULTS - CREATE VIEW or SET PROPERTY or batched set of
//                       these parsed successfully.  NOTE:  *ppTree and
//                       *ppPTProperties will be null.
//      E_OUTOFMEMORY  - low on resources
//      E_FAIL         - unexpected error
//      E_INVALIDARG   - pcwszText, ppCommandTree, or ppPTProperties
//                       was a NULL pointer.
//-----------------------------------------------------------------------------

STDMETHODIMP CImpIParserSession::ToTree(
    LCID                    lcid,
    LPCWSTR                 pcwszText,
    DBCOMMANDTREE**         ppCommandTree,
    IParserTreeProperties** ppPTProperties )
{
    HRESULT                     hr = S_OK;
    IColumnMapper*              pIColumnMapper = NULL;


    assert(pcwszText && ppCommandTree && ppPTProperties);

    if ( 0 == pcwszText || 0 == ppCommandTree || 0 == ppPTProperties )
        hr = ResultFromScode(E_INVALIDARG);
    else
    {
        *ppCommandTree = 0;
        *ppPTProperties = 0;

        CAutoBlock cab( &m_csSession );

        // Clear some member variables for this pass through the parser
        SetLCID( lcid );
        SetGlobalDefinition( FALSE );

        // Attempt to get the interface for accessing the built-in properties
        // This is done on each call to the parser in case different commands
        // use a different catalog, which is part of the
        // GetColumnMapper parameter list.
        if( SUCCEEDED(hr = m_pIColMapCreator->GetColumnMapper(LOCAL_MACHINE,
                                                    GetDefaultCatalog(),
                                                    &pIColumnMapper)) )
        {
            SetColumnMapperPtr(pIColumnMapper);
        }
        else
        {
            goto ParseErr;
        }

        try
        {
            XInterface<CImpIParserTreeProperties> xpPTProps;

            xpPTProps.Set( new CImpIParserTreeProperties() );

            hr = xpPTProps->FInit(GetDefaultCatalog(), GetDefaultMachine());
            if (FAILED(hr) )
                THROW( CException(hr) );

            MSSQLLexer  Lexer;
            MSSQLParser Parser(this, xpPTProps.GetPointer(), Lexer);

            // callee needs this to post parser errors when Parse() fails
            *ppPTProperties = xpPTProps.Acquire();

            Parser.yyprimebuffer( (LPWSTR)pcwszText );
            Parser.ResetParser();

#ifdef DEBUG
            Parser.yydebug = getenv("YYDEBUG") ? 1 : 0;
#endif
            // Actually parse the text producing a tree
            hr = Parser.Parse();
            if ( FAILED(hr) )
                goto ParseErr;

            // return the DBCOMMANDTREE
            *ppCommandTree = Parser.GetParseTree();

#ifdef DEBUG
            if (getenv("PRINTTREE"))
            {
                if ( *ppCommandTree )
                {
                    cout << "OLE DB Command Tree" << endl;
                    cout << pcwszText << endl << **ppCommandTree << endl << endl;

                    // Retrieve CiRestriction
                    VARIANT vVal;
                    VariantInit(&vVal);
                    if( SUCCEEDED((*ppPTProperties)->GetProperties(PTPROPS_CIRESTRICTION, &vVal)) )
                        if( V_BSTR(&vVal) )
                            cout << "CiRestriction: " << (LPWSTR)V_BSTR(&vVal) << endl;
                    VariantClear(&vVal);
                }
            }
#endif
            if ( 0 == *ppCommandTree )
            {
                hr = ResultFromScode(DB_S_NORESULT);

                // Spec states that this should be NULL when DB_S_NORESULTs is returned.
                (*ppPTProperties)->Release();
                *ppPTProperties = 0;
                goto ParseErr;
            }
        }
        catch( CException e )
        {
#ifdef DEBUG
            if (getenv("PRINTTREE"))
                cout << "At catch(...)!!!!!!!!!!!!!" << endl;
#endif
            hr = e.GetErrorCode();
        }
        catch(...)
        {
            hr = E_FAIL;
        }

ParseErr:

        pIColumnMapper = GetColumnMapperPtr();
        if ( 0 != pIColumnMapper )
        {
            pIColumnMapper->Release();
            pIColumnMapper = NULL;
            SetColumnMapperPtr(NULL);
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
// @func CImpIParserSession::FreeTree
//
// Free memory associated with a given command tree.
//
// @rdesc HRESULT
//      S_OK - command tree released
//      E_FAIL - tree could not be freed
//      E_INVALIDARG - ppTree was a NULL pointer
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParserSession::FreeTree(
    DBCOMMANDTREE** ppTree )
{
    SCODE sc = S_OK;

    if ( 0 == ppTree )
        sc = E_INVALIDARG;
    else
    {
        if ( 0 != *ppTree )
            DeleteDBQT( *ppTree );  // todo:  put error returns on DeleteDBQT

        *ppTree = 0;
    }

    return sc;
}

//-----------------------------------------------------------------------------
// @func CImpIParserSession::SetCatalog
//
// Establish the current catalog for this parser session.
//
// @rdesc HRESULT
//      S_OK - method successful
//      E_OUTOFMEMORY - low on resources
//      E_FAIL - unexpected error
//      E_INVALIDARG - pcwszCatalog was a NULL pointer (DEBUG ONLY)
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParserSession::SetCatalog(
    LPCWSTR pcwszCatalog )
{
    SCODE sc = S_OK;

    if ( 0 == pcwszCatalog )
        return E_INVALIDARG;

    TRY
    {
        XPtrST<WCHAR> xCatalog( CopyString(pcwszCatalog) );

        delete [] m_pwszCatalog;
        m_pwszCatalog = xCatalog.Acquire();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//--------------------------------------------------------------------
// @func Locate a view, if defined, in the view list
//
// @rdesc HRESULT
//
CViewData* CViewList::FindViewDefinition(
    LPWSTR          pwszViewName,     // @parm IN | name of view being defined
    LPWSTR          pwszCatalogName ) // @parm IN | name of catalog view is to be defined in
{
    CViewData* pViewData = m_pViewData;
    while (NULL != pViewData)
    {
        if ( 0 == _wcsicmp(pViewData->m_pwszViewName, pwszViewName) )
        {
            // pwszCatalogName will be null for built-in views which match all catalogs
            if ( 0 == pViewData->m_pwszCatalogName )
                break;
            if ( 0 == _wcsicmp(pViewData->m_pwszCatalogName, pwszCatalogName) )
                break;
        }
        pViewData = pViewData->m_pNextView;
    }
    return pViewData;
}


//--------------------------------------------------------------------
// @func Stores the information from a temporary view
//
// @rdesc S_OK          | Valid
//        E_INVALIDARG  | Attempt to redefine a view in the specified catalog
//        E_OUTOFMEMORY | Error result from HrQeTreeCopy or CopyScopeDataToView
//
HRESULT CViewList::SetViewDefinition(
    CImpIParserSession*         pIParsSess,     // @parm IN | IParserSession interface
    CImpIParserTreeProperties*  pIPTProps,      // @parm IN | IParserTreeProperties interface
    LPWSTR                      pwszViewName,   // @parm IN | name of view being defined
    LPWSTR                      pwszCatalogName,// @parm IN | name of catalog view is to be defined in
    DBCOMMANDTREE*              pctProjectList )// @parm IN | project list for the selected columns
{
    SCODE sc = S_OK;

    {
        CViewData* pViewData = FindViewDefinition( pwszViewName, pwszCatalogName );
        if( 0 != pViewData )     // this view already defined
            return E_INVALIDARG;
    }

    TRY
    {
        XPtr<CViewData> xpViewData( new CViewData() );
        xpViewData->m_pwszViewName = CopyString( pwszViewName );

        if ( 0 != pwszCatalogName )
            xpViewData->m_pwszCatalogName = CopyString( pwszCatalogName );

        sc = HrQeTreeCopy( &(xpViewData->m_pctProjectList),
                           pctProjectList );

        if ( SUCCEEDED(sc) )
        {
            //Save pointer to ScopeData object and up the refcount for our use.
            xpViewData->m_pCScopeData = pIPTProps->GetScopeDataPtr();
            xpViewData->m_pCScopeData->AddRef();

            sc = pIPTProps->CreateNewScopeDataObject( pIParsSess->GetDefaultMachine() );
            if( SUCCEEDED(sc) )
            {
                //@DEVNOTE: Anything added before the next two lines should
                // go through the error_exit routine.  WHY?  Because we haven't
                // added this node to our linked list until the next 2 lines.
                xpViewData->m_pNextView = m_pViewData;
                m_pViewData = xpViewData.Acquire();
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//--------------------------------------------------------------------
// @func Deletes the information for a temporary view.
//
// @rdesc HRESULT
//
HRESULT CViewList::DropViewDefinition(
    LPWSTR  pwszViewName,       // @parm IN | name of view being defined
    LPWSTR  pwszCatalogName )   // @parm IN | name of catalog view is defined in
{
    CViewData* pViewData = m_pViewData;
    CViewData* pPrevViewData = NULL;

    while (NULL != pViewData)
    {
        if ( 0 == _wcsicmp(pViewData->m_pwszViewName, pwszViewName) )
        {
            // pwszCatalogName will be null for built-in views which match all catalogs
            if ( 0 == pViewData->m_pwszCatalogName )
                break;
            if ( 0 == _wcsicmp(pViewData->m_pwszCatalogName, pwszCatalogName) )
                break;
        }
        pPrevViewData = pViewData;
        pViewData = pViewData->m_pNextView;
    }

    if ( 0 == pViewData )
        return E_FAIL;

    // unlink the view
    if ( 0 != pPrevViewData )
        pPrevViewData->m_pNextView = pViewData->m_pNextView;
    else
        m_pViewData = pViewData->m_pNextView;

    delete pViewData;

    return S_OK;
}




//--------------------------------------------------------------------
// @func Retrieves the information from a temporary view.
//       This returns a DBCOMMANDTREE for use as a project list
//      in the query specification.  The scope information is
//      stored in the compiler envirnment scope data.
//
// @rdesc DBCOMMANDTREE*
//      NULL                    | view not defined
//      DBOP_catalog_name       | verify catalog failed
//      DBOP_project_list_anchor| success
//
DBCOMMANDTREE* CViewList::GetViewDefinition(
    CImpIParserTreeProperties* pIPTProps,
    LPWSTR  pwszViewName,                   // @parm IN | name of view being defined
    LPWSTR  pwszCatalogName )               // @parm IN | name of catalog view is defined in
{
    DBCOMMANDTREE* pct = 0;

    CViewData* pViewData = FindViewDefinition( pwszViewName, pwszCatalogName );
    if( 0 != pViewData )
    {
        // Take the pointer to the scope data stored in the view definition and
        // AddRef the object so we have ownership rights in our current PTProps.
        pIPTProps->ReplaceScopeDataPtr( pViewData->m_pCScopeData );

        SCODE sc = HrQeTreeCopy( &pct, pViewData->m_pctProjectList );
        if ( FAILED(sc) )
            pct = 0;
    }

    return pct;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\iparsess.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module PARSER.H | IParserSession object
// definitions
//
//
#ifndef _IPARSERSESSION_H_
#define _IPARSERSESSION_H_



//----------------------------------------------------------------------------
// @class CViewData
//
class CViewData
{
    public: //@access public functions
        CViewData();
        ~CViewData();
        LPWSTR          m_pwszViewName;
        LPWSTR          m_pwszCatalogName;
        DBCOMMANDTREE*  m_pctProjectList;
        CScopeData*     m_pCScopeData;  
        CViewData*      m_pNextView;
};

//----------------------------------------------------------------------------
// @class CViewList
//
class CViewList
{
    public: //@access public functions
        CViewList();
        ~CViewList();

        HRESULT DropViewDefinition( LPWSTR pwszViewName,
                                    LPWSTR pwszCatalogName );

        HRESULT SetViewDefinition( CImpIParserSession* pIParsSess,
                                   CImpIParserTreeProperties* pIPTProps,
                                   LPWSTR pwszViewName,
                                   LPWSTR pwszCatalogName,
                                   DBCOMMANDTREE* pctSelectList );

        DBCOMMANDTREE* GetViewDefinition( CImpIParserTreeProperties* pIPTProps,
                                          LPWSTR pwszViewName,
                                          LPWSTR pwszCatalogName );

    private: //@access private data
        CViewData* FindViewDefinition( LPWSTR pwszViewName, 
                                       LPWSTR pwszCatalogName );

    protected: //@access protected data
        CViewData*  m_pViewData;
};

//----------------------------------------------------------------------------
// @class CImpIParserSession 
//
class CImpIParserSession : public IParserSession
    {
    private: //@access private member data
        LONG            m_cRef;
        LCID            m_lcid;
        DWORD           m_dwRankingMethod;

        GUID            m_GuidDialect;      // dialect for this session
        LPWSTR          m_pwszMachine;      // provider's current machine
        IParserVerify*  m_pIPVerify;        // unknown part of ParserInput

        CViewList*      m_pLocalViewList;
        CViewList*      m_pGlobalViewList;
        LPWSTR          m_pwszCatalog;
        DWORD           m_dwSQLDialect;
        BOOL            m_globalDefinitions;
        IColumnMapperCreator*   m_pIColMapCreator;

        // Critical Section for syncronizing access to session data.
        CRITICAL_SECTION    m_csSession;
        IColumnMapper*      m_pColumnMapper;

    public: //@access public data 
        CPropertyList*  m_pCPropertyList;       // User defined property list

    public:         //@access public
        CImpIParserSession( const GUID* pGuidDialect,   
                            IParserVerify* pIPVerify,
                            IColumnMapperCreator* pIColMapCreator,
                            CViewList* pGlobalViewList);
        ~CImpIParserSession();

        HRESULT         FInit(LPCWSTR pwszMachine, CPropertyList** ppGlobalPropertyList);
        
        STDMETHODIMP    QueryInterface(
                        REFIID riid, LPVOID* ppVoid);
        STDMETHODIMP_(ULONG) Release (void);
        STDMETHODIMP_(ULONG) AddRef (void);

        //@cmember ToTree method
        STDMETHODIMP    ToTree
                        (
                        LCID                    lcid,   
                        LPCWSTR                 pcwszText,
                        DBCOMMANDTREE**         ppCommandTree,
                        IParserTreeProperties** ppPTProperties
                        );

        STDMETHODIMP    FreeTree
                        (
                        DBCOMMANDTREE** ppTree
                        );

        STDMETHODIMP    SetCatalog
                        (
                        LPCWSTR pcwszCatalog
                        );

    public: //@access public functions
        inline IParserVerify*   GetIPVerifyPtr()
            { return m_pIPVerify; }

        inline IColumnMapper*   GetColumnMapperPtr()
            { return m_pColumnMapper; }

        inline void             SetColumnMapperPtr(IColumnMapper* pCMapper)
            { m_pColumnMapper = pCMapper; }

        inline LCID             GetLCID()
            { return m_lcid; }

        inline void             SetLCID(LCID lcid)
            { m_lcid = lcid; }

        inline DWORD            GetRankingMethod()
            { return m_dwRankingMethod; }

        inline void             SetRankingMethod(DWORD dwRankingMethod)
            { m_dwRankingMethod = dwRankingMethod; }

        inline DWORD            GetSQLDialect()
            { return m_dwSQLDialect; }

        inline LPWSTR           GetDefaultCatalog()
            { return m_pwszCatalog; }

        inline LPWSTR           GetDefaultMachine()
            { return m_pwszMachine; }

        inline void             SetGlobalDefinition(BOOL fGlobal)
            { m_globalDefinitions = fGlobal; }

        inline BOOL             GetGlobalDefinition()
            { return m_globalDefinitions; }

        inline CViewList*       GetLocalViewList()
            { return m_pLocalViewList; }


        inline CViewList*       GetGlobalViewList()
            { return m_pGlobalViewList; }

    private: //@access private functions
        CImpIParserSession() {};
    };

enum DBDIALECTENUM
        {
        DBDIALECT_UNKNOWN   = 0,
        DBDIALECT_MSSQLTEXT = 1,
        DBDIALECT_MSSQLJAWS = 2
        };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    makefile.inc.

!ENDIF

mssqllex.cpp: ms-sql.l ms-sql.y flexcpp.h flexcpp.skl mssqltab.h
    @ech Build_Status Generating mssqllex.cpp... ;
    -attrib -r mssqllex.cpp 2>nul
    -del mssqllex.cpp 2>nul
    flex -Sflexcpp.skl -i -+ -B -L -omssqllex.cpp ms-sql.l

mssqltab.cpp mssqltab.h: ms-sql.y
    @ech Build_Status Generating mssqltab.cpp... ;
    kbyacc -f sql -d -l -b ms-sql -c CYYBase "(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex)" ms-sql.y
    -attrib -r mssqltab.cpp 2>nul
    -attrib -r mssqltab.h 2>nul
    -del mssqltab.cpp
    -del mssqltab.h
    -ren ms-sql.tab.c mssqltab.cpp
    -ren ms-sql.tab.h mssqltab.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\mssql.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Query
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module mssql.h | 
//
// Contains utility functions for constructing, debugging and manipulating DNA query trees.
//
// @devnote Must include:
//
// @rev   0 | 01-Aug-95 | mikeu     | Created
//

#ifndef _MSSQL_H_INC
#define _MSSQL_H_INC
//#include  "colname.h"

//package is in use
#define YYAPI_PACKAGE                  1                        // package is in use
#define YYAPI_TOKENNAME                yychar                   
#define YYAPI_TOKENTYPE                int                      
#define YYAPI_TOKENEME(t)              (t)                      
#define YYAPI_TOKENNONE                -2                       
//# define YYAPI_TOKENSTR              yyGetTokenStr            /
//yyitos is defined by yacc. does correct thing for unicode or ansi
#define YYAPI_TOKENSTR(t)              (yyitos(t,yyitoa,10))    // string representation of the token
#define YYAPI_VALUENAME                yylval   
#define YYAPI_VALUETYPE                DBCOMMANDTREE *
#define YYAPI_VALUEOF(v)               v             
#define YYAPI_CALLAFTERYYLEX(t)                      
#define YYNEAR                                       
#define YYPASCAL                                     
#define YYSTATIC    static                           
#define YYLEX                           m_yylex.yylex
#define YYPARSEPROTO                            
#define YYSTYPE                         DBCOMMANDTREE *                   
#undef YYPARSER
#define YYPARSER                        MSSQLParser
#undef YYLEXER
#define YYLEXER                         MSSQLLexer
#undef  YY_CHAR 
#define YY_CHAR                         TCHAR

#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif




#define MONSQL_PARSE_ERROR                  1
#define MONSQL_CITEXTTOSELECTTREE_FAILED    MONSQL_PARSE_ERROR+1
#define MONSQL_PARSE_STACK_OVERFLOW         MONSQL_CITEXTTOSELECTTREE_FAILED+1
#define MONSQL_CANNOT_BACKUP_PARSER         MONSQL_PARSE_STACK_OVERFLOW+1
#define MONSQL_SEMI_COLON                   MONSQL_CANNOT_BACKUP_PARSER+1
#define MONSQL_ORDINAL_OUT_OF_RANGE         MONSQL_SEMI_COLON+1
#define MONSQL_VIEW_NOT_DEFINED             MONSQL_ORDINAL_OUT_OF_RANGE+1
#define MONSQL_BUILTIN_VIEW                 MONSQL_VIEW_NOT_DEFINED+1
#define MONSQL_COLUMN_NOT_DEFINED           MONSQL_BUILTIN_VIEW+1
#define MONSQL_OUT_OF_MEMORY                MONSQL_COLUMN_NOT_DEFINED+1
#define MONSQL_SELECT_STAR                  MONSQL_OUT_OF_MEMORY+1
#define MONSQL_OR_NOT                       MONSQL_SELECT_STAR+1
#define MONSQL_CANNOT_CONVERT               MONSQL_OR_NOT+1
#define MONSQL_OUT_OF_RANGE                 MONSQL_CANNOT_CONVERT+1
#define MONSQL_RELATIVE_INTERVAL            MONSQL_OUT_OF_RANGE+1
#define MONSQL_NOT_COLUMN_OF_VIEW           MONSQL_RELATIVE_INTERVAL+1
#define MONSQL_BUILTIN_PROPERTY             MONSQL_NOT_COLUMN_OF_VIEW+1
#define MONSQL_WEIGHT_OUT_OF_RANGE          MONSQL_BUILTIN_PROPERTY+1
#define MONSQL_MATCH_STRING                 MONSQL_WEIGHT_OUT_OF_RANGE+1
#define MONSQL_PROPERTY_NAME_IN_VIEW        MONSQL_MATCH_STRING+1
#define MONSQL_VIEW_ALREADY_DEFINED         MONSQL_PROPERTY_NAME_IN_VIEW+1
#define MONSQL_INVALID_CATALOG              MONSQL_VIEW_ALREADY_DEFINED+1



#endif /* _MSSQL_H_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\msidxtr.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// module       msidxtr.h | Standard includes for msidxtr project.
//
//
// rev  0 | 3-4-97              | v-charca              | Created
#ifndef _MSIDXTR_H_
#define _MSIDXTR_H_

//      Don't include everything from windows.h, but always bring in OLE 2 support
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
#if !defined(INC_OLE2)
#define INC_OLE2
#endif

// Note that we need both of these.
#if !defined(UNICODE)
#define  UNICODE        // Enable WIN32 API.
#endif
#if !defined(_UNICODE)
#define _UNICODE        // Enable runtime library routines.
#endif

#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG
#endif

#ifndef NUMELEM
#define NUMELEM(p1) (sizeof(p1) / sizeof(*(p1)))
#endif

#if (CIDBG == 1)
// Assert defined to Win4Assert in cidebnot.h
// #define Assert Win4Assert
#define assert(x) \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))
#define TRACE
#else
#define assert(x)
#define TRACE
#endif

// #define OLEDBVER 0x0250
#include <windows.h>
#include <limits.h>             // needed by cstring.cpp
#include <oaidl.h>
#include <stdio.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledberr.h>
//#include <assert.h>
#define DBEXPORT
#include "autobloc.h"
#ifdef DEBUG
#include <iostream.h>
#include <iomanip.h>
#endif
#include <ntquery.h>
#include <fsciclnt.h>
#include <query.h>
#include <ciintf.h>
#include <ciplist.hxx>

#ifdef DEBUG
#define YYDEBUG 1
#endif

//#include <cidebnot.h>
//#include <ciexcpt.hxx>

#include <smart.hxx>
#include <tsmem.hxx>

#include "yybase.hxx"
#include "mparser.h"
#include "colname.h"
#include "mssql.h"
#include "flexcpp.h"
#include "mssqltab.h"
#include "treeutil.h"
#include "PTProps.h"
#include "IParSess.h"
#include "IParser.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\mssqllex.cpp ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#include <pch.cxx>
#pragma hdrstop

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5



/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifndef YY_CHAR
#define YY_CHAR TCHAR
#endif

#ifdef __cplusplus

#include <tchar.h>
#include <stdlib.h>
        // class istream;

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed YY_CHAR to an unsigned
 * integer for use as an array index.  If the signed YY_CHAR is negative,
 * we want to instead treat it as an 8-bit unsigned YY_CHAR, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (YY_CHAR) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 32767       // UNDONE:  Should really just take the input from the bstr passed in

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *      if ( condition_holds )
 *              yyless( 5 );
 *      else
 *              do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
        {
        // istream* yy_input_file;

        YY_CHAR *yy_ch_buf;             /* input buffer */
        YY_CHAR *yy_buf_pos;            /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2
        };


/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer



static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

#define yytext_ptr yytext


/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 97
#define YY_END_OF_BUFFER 98
static yyconst short int yy_accept[406] =
    {   0,
        0,    0,    0,    0,   78,   78,    0,    0,    0,    0,
        0,    0,    0,    0,   98,   57,   39,   39,   57,   57,
       57,   57,   57,   57,   52,   45,   45,   57,   57,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   62,   61,   61,   62,
       58,   59,   78,   77,   77,   79,   78,   76,   78,   78,
       78,   78,   82,   81,   81,   80,   92,   89,   89,   92,
       90,   91,   92,   92,   92,   92,   92,   96,   93,   93,
       96,   95,   97,   97,   63,   39,   51,    0,   43,    0,
       41,    0,   44,   45,   45,   47,    0,   53,   46,   46,

        0,    0,   49,   50,   48,   40,   40,   40,   40,    5,
       40,   40,   40,   40,   40,   40,   40,   15,   40,   40,
       40,   40,   22,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   61,    0,   60,   59,   78,
        0,   77,    0,    0,    0,   78,    0,   75,    0,   78,
       78,   78,   78,   78,   78,   81,   89,    0,   83,    0,
        0,    0,   87,    0,   93,    0,   94,    0,   64,   63,
        0,   42,   41,    0,   47,   54,    0,    0,   46,    0,
       46,   45,    1,    2,    3,   40,    6,   40,   40,   40,
       40,   40,   40,   40,   40,    0,   40,   40,   19,   40,

       40,   40,   40,   40,   40,   40,   30,   40,   40,   40,
       40,   40,   40,   40,   40,    0,    0,    0,    0,    0,
       75,    0,   78,   78,   74,   78,   78,   78,   78,    0,
       84,    0,    0,    0,    0,   65,   64,   42,    0,    0,
        0,   46,   40,    7,   40,   40,   10,   11,   40,   40,
       14,    0,   17,   40,    0,   21,   40,   40,   40,   40,
       40,   40,   31,   40,   33,   34,   40,   40,   37,   40,
        0,    0,    0,   71,    0,   74,   78,   78,   78,   78,
        0,    0,    0,   65,    0,    0,    4,   40,   40,   12,
       40,    0,   40,    0,   40,   40,   40,   40,   40,   28,

       40,   32,   35,   40,   38,   66,   69,   70,   78,   78,
       78,   78,    0,    0,    0,    0,    0,   40,    8,   40,
       16,   40,    0,    0,   40,   40,   26,   40,   29,   40,
       67,   78,   78,   73,    0,    0,    0,    0,   55,   40,
       40,   18,    0,    0,   40,   40,   40,   36,   72,   68,
        0,    0,    0,   56,    9,   13,   20,   23,   40,   40,
       40,    0,    0,    0,   40,   40,   40,    0,    0,    0,
       40,   40,   27,    0,    0,    0,   24,   40,    0,    0,
        0,   25,    0,    0,    0,    0,    0,    0,   85,    0,
        0,    0,    0,    0,    0,    0,   88,    0,    0,    0,

        0,    0,    0,   86,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
       10,   11,   12,    7,   13,   14,    1,   15,   16,   16,
       16,   16,   16,   16,   16,   16,   16,    1,    1,   17,
       18,   19,    1,    1,   21,   22,   23,   24,   25,   26,
       27,   28,   29,   30,   31,   32,   33,   34,   35,   36,
       30,   37,   38,   39,   40,   41,   42,   43,   44,   30,
        7,    1,    7,    1,   20,    1,   21,   22,   23,   24,

       25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
       35,   36,   30,   37,   38,   39,   40,   41,   42,   43,
       44,   30,    1,    7,    1,    7,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[45] =
    {   0,
        1,    2,    3,    2,    1,    4,    2,    1,    2,    2,
        1,    1,    1,    1,    5,    5,    1,    1,    1,    6,
        7,    7,    7,    7,    7,    7,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8
    } ;

static yyconst short int yy_base[431] =
    {   0,
        0,    0,   44,    0,   87,  128,   96,   98,  169,  206,
      101,  112,  244,    0,  812,  813,  106,  116,  793,  805,
      803,  800,  105,  110,  125,  130,  133,  109,  789,  127,
        0,  131,  125,  132,  768,  776,  783,  140,  766,  139,
      781,  160,  161,  767,  771,  771,  813,  140,  184,  793,
      813,    0,  789,  189,  198,  813,  287,  788,  191,  194,
      159,  181,  813,  210,  215,  813,  813,  218,  232,  790,
      813,  813,  762,  768,  749,  765,  762,  813,  234,  236,
      784,  813,  813,  782,    0,  240,  813,  782,  781,    0,
        0,  777,  776,  285,  288,    0,  290,  276,  292,  296,

      303,    0,  813,  813,  813,    0,  751,  285,  745,  758,
      742,  745,  753,  739,  741,  743,   77,  320,  743,  734,
      733,  739,  746,  731,  733,  733,  731,  124,  732,  742,
      723,  726,  295,  736,  735,  328,  754,  753,    0,  749,
      748,  330,  721,  300,  717,  364,  217,  176,  329,  374,
      745,  319,  188,  328,  312,  336,  340,  747,  746,  718,
      724,  725,  813,  726,  343,  741,  740,    0,    0,    0,
      739,    0,    0,  735,    0,  704,  718,  340,  332,  343,
      345,    0,    0,    0,    0,  719,    0,  700,  699,  716,
      713,  699,  696,  708,  699,  360,  706,  707,  384,  697,

      703,  689,  690,  694,  688,  698,    0,  697,  689,  695,
      694,  683,  683,  674,  678,  709,  689,  691,  672,  386,
      705,  385,  395,  405,  362,  383,  384,  400,  403,  704,
      813,  672,  675,  674,  700,    0,    0,    0,  681,  668,
      403,  408,  658,    0,  680,  661,    0,    0,  674,  659,
        0,  662,    0,  668,  423,    0,  658,  655,  325,  660,
      667,  668,    0,  665,    0,    0,  655,  653,    0,  662,
      425,  649,  429,  431,  390,  680,  180,  413,  421,  429,
      433,  644,  651,    0,  647,  645,    0,  651,  654,    0,
      653,  638,  651,  646,  436,  646,  636,  648,  646,    0,

      631,    0,    0,  627,    0,  438,  813,  440,  436,  437,
      438,  440,  447,  644,  632,  630,  640,  630,    0,  620,
      813,  624,  630,  451,  623,  620,    0,  619,    0,  623,
      629,  372,  444,  625,  589,  586,  568,  578,  813,  557,
      548,    0,  554,  534,  532,  511,  522,    0,  541,  534,
      485,  456,  460,  813,    0,    0,  813,  813,  465,  470,
      467,  460,  462,  464,  472,  477,  473,  471,  470,  457,
      465,  459,    0,  454,  469,  468,    0,  463,  449,  448,
      443,    0,  461,  458,  455,  445,  448,  438,  813,  466,
      436,  468,  439,  410,  361,  356,  813,  252,  215,  177,

      139,  113,   61,  813,  813,  507,  515,  523,  531,  539,
      544,  552,  556,  564,  568,  576,  584,  592,  600,  605,
      609,  611,  615,  623,  627,  634,  636,  640,  644,  648
    } ;

static yyconst short int yy_def[431] =
    {   0,
      405,    1,  405,    3,  406,  406,  407,  407,  408,  408,
      409,  409,  405,   13,  405,  405,  405,  405,  405,  410,
      411,  412,  405,  405,  405,  405,  405,  405,  405,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  405,  405,  405,  414,
      405,  415,  416,  405,  405,  405,  417,  405,  416,  416,
      416,  416,  405,  405,  405,  405,  405,  405,  405,  418,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      419,  405,  405,  420,  421,  405,  405,  410,  405,  422,
      423,  412,  405,  405,  405,  424,  405,  405,  405,  405,

      405,  425,  405,  405,  405,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  405,  414,  405,  415,  416,
      405,  405,  405,  405,  405,  417,  426,  416,  426,  417,
      416,  416,  416,  416,  416,  405,  405,  418,  405,  405,
      405,  405,  405,  405,  405,  419,  405,  427,  428,  421,
      410,  429,  423,  412,  424,  405,  405,  405,  405,  405,
      405,  425,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  405,  413,  413,  413,  413,

      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  414,  405,  405,  405,  405,
      405,  426,  417,  417,  416,  416,  416,  416,  416,  418,
      405,  405,  405,  405,  419,  430,  428,  429,  405,  405,
      405,  405,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  405,  413,  413,  405,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      405,  405,  405,  405,  426,  405,  416,  416,  416,  416,
      405,  405,  405,  430,  405,  405,  413,  413,  413,  413,
      413,  405,  413,  405,  413,  413,  413,  413,  413,  413,

      413,  413,  413,  413,  413,  405,  405,  405,  416,  416,
      416,  416,  405,  405,  405,  405,  405,  413,  413,  413,
      405,  413,  405,  405,  413,  413,  413,  413,  413,  413,
      416,  416,  416,  416,  405,  405,  405,  405,  405,  413,
      413,  413,  405,  405,  413,  413,  413,  413,  416,  416,
      405,  405,  405,  405,  413,  413,  405,  405,  413,  413,
      413,  405,  405,  405,  413,  413,  413,  405,  405,  405,
      413,  413,  413,  405,  405,  405,  413,  413,  405,  405,
      405,  413,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,

      405,  405,  405,  405,    0,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405
    } ;

static yyconst short int yy_nxt[858] =
    {   0,
       16,   17,   18,   19,   20,   21,   16,   22,   16,   16,
       16,   23,   24,   25,   26,   27,   28,   16,   29,   16,
       30,   31,   32,   33,   31,   34,   31,   31,   35,   31,
       31,   36,   37,   38,   39,   40,   41,   42,   43,   44,
       45,   46,   31,   31,   47,   48,   49,   47,   50,   47,
       47,   51,   47,   47,   47,   47,   47,   47,   47,   47,
       47,   47,   47,   47,   52,   52,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   54,   55,
       56,   57,  404,   56,   58,   56,   56,   64,   65,   64,

       65,  194,   79,   80,   66,   81,   66,   86,   86,   59,
       82,  195,   60,   79,   80,   61,   81,   86,   86,   94,
       95,   82,   96,   97,   94,   95,  103,  104,   62,   54,
       55,   56,   57,  403,   56,   58,   56,   56,   98,   99,
       99,  136,  136,  100,   95,   95,  100,   95,   95,  114,
       59,  111,  116,   60,  101,  206,   61,  101,  107,  124,
      108,  115,  207,  109,  110,  112,  141,  113,  117,   62,
       68,   69,  102,   70,  121,  125,  402,   71,   72,  122,
      223,  130,  127,  141,  128,  136,  136,  141,  141,   73,
      142,  142,   74,   75,  129,  141,  154,  131,  141,  142,

      142,  141,  309,   76,  132,  155,   77,   68,   69,  143,
       70,  156,  156,  401,   71,   72,  156,  156,  143,  157,
      157,  221,  144,  145,  227,  152,   73,  222,  153,   74,
       75,  144,  145,  157,  157,  165,  165,  165,  165,  400,
       76,   86,   86,   77,   83,   83,   83,   83,   83,   84,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   85,   85,   85,   85,  147,  176,
      147,  148,  399,  147,  149,  147,  147,  150,  100,   95,

       95,  100,   95,   95,   99,   99,   99,   99,  184,  101,
      179,  179,  101,  177,  180,  180,  178,  181,  181,  141,
      101,  196,  196,  212,  218,  213,  141,  102,  185,  136,
      136,  142,  142,  221,  219,  141,  224,  156,  156,  222,
      229,  157,  157,  226,  165,  165,  179,  179,  228,  297,
      143,  241,  241,  298,  242,  242,  101,  181,  181,  181,
      181,  196,  196,  144,  145,  147,  223,  147,  148,  141,
      147,  149,  147,  147,  150,  147,  398,  147,  225,  141,
      147,  149,  147,  147,  150,  255,  255,  274,  274,  276,
      141,  141,  397,  252,  221,  222,  147,  349,  147,  148,

      222,  147,  149,  147,  147,  150,  147,  141,  147,  148,
      141,  147,  149,  147,  147,  150,  278,  242,  242,  277,
      141,  279,  242,  242,  255,  255,  306,  306,  141,  280,
      308,  308,  274,  274,  313,  313,  141,  324,  324,  306,
      306,  308,  308,  141,  141,  141,  396,  141,  313,  313,
      310,  141,  324,  324,  294,  311,  312,  363,  363,  395,
      331,  364,  364,  363,  363,  364,  364,  392,  392,  392,
      392,  332,  344,  393,  391,  390,  389,  333,  334,  388,
      387,  386,  350,  385,  384,  335,  383,  382,  381,  380,
      379,  378,  377,  376,  375,  374,  373,  372,  371,  369,

      368,  367,  370,  366,  365,  362,  394,   53,   53,   53,
       53,   53,   53,   53,   53,   63,   63,   63,   63,   63,
       63,   63,   63,   67,   67,   67,   67,   67,   67,   67,
       67,   78,   78,   78,   78,   78,   78,   78,   78,   88,
       88,  141,   88,   88,   88,   88,   88,   91,  141,  361,
       91,   91,   92,   92,  360,   92,   92,   92,   92,   92,
      106,  106,  106,  106,  137,  137,  359,  137,  137,  137,
      137,  137,  139,  139,  139,  139,  140,  358,  357,  140,
      140,  140,  140,  140,  146,  146,  356,  146,  146,  146,
      146,  146,  158,  158,  355,  158,  158,  158,  158,  158,

      166,  166,  354,  166,  166,  166,  166,  166,  169,  353,
      352,  169,  169,  170,  170,  170,  170,  172,  172,  173,
      173,  173,  173,  175,  175,  351,  175,  175,  175,  175,
      175,  182,  141,  182,  147,  147,  141,  147,  147,  147,
      147,  147,  236,  236,  237,  237,  237,  237,  238,  238,
      238,  238,  284,  284,  284,  284,  348,  347,  346,  345,
      343,  342,  341,  340,  339,  338,  337,  336,  330,  329,
      328,  327,  326,  325,  323,  322,  321,  320,  319,  318,
      317,  316,  315,  314,  275,  307,  305,  304,  303,  302,
      301,  300,  299,  296,  295,  293,  292,  291,  290,  289,

      288,  287,  286,  285,  167,  283,  282,  281,  159,  275,
      273,  272,  271,  138,  270,  269,  268,  267,  266,  265,
      264,  263,  262,  261,  260,  259,  258,  257,  256,  254,
      253,  251,  250,  249,  248,  247,  246,  245,  244,  243,
      240,  239,   93,   89,  235,  167,  234,  233,  232,  231,
      230,  159,  141,  220,  217,  151,  141,  216,  138,  215,
      214,  211,  210,  209,  208,  205,  204,  203,  202,  201,
      200,  199,  198,  197,  193,  192,  191,  190,  189,  188,
      187,  186,  183,  174,   93,  171,   89,  168,  167,  164,
      163,  162,  161,  160,  159,  151,  141,  138,  135,  134,

      133,  126,  123,  120,  119,  118,  105,   93,   90,   89,
       87,  405,   15,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405
    } ;

static yyconst short int yy_chk[858] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    5,    5,
        5,    5,  403,    5,    5,    5,    5,    7,    7,    8,

        8,  117,   11,   11,    7,   11,    8,   17,   17,    5,
       11,  117,    5,   12,   12,    5,   12,   18,   18,   23,
       23,   12,   24,   24,   24,   24,   28,   28,    5,    6,
        6,    6,    6,  402,    6,    6,    6,    6,   25,   25,
       25,   48,   48,   26,   26,   26,   27,   27,   27,   33,
        6,   32,   34,    6,   26,  128,    6,   27,   30,   40,
       30,   33,  128,   30,   30,   32,   61,   32,   34,    6,
        9,    9,   26,    9,   38,   40,  401,    9,    9,   38,
      148,   43,   42,  148,   42,   49,   49,  277,   62,    9,
       54,   54,    9,    9,   42,  153,   61,   43,   59,   55,

       55,   60,  277,    9,   43,   62,    9,   10,   10,   54,
       10,   64,   64,  400,   10,   10,   65,   65,   55,   68,
       68,  147,   54,   54,  153,   59,   10,  147,   60,   10,
       10,   55,   55,   69,   69,   79,   79,   80,   80,  399,
       10,   86,   86,   10,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   57,   98,
       57,   57,  398,   57,   57,   57,   57,   57,   94,   94,

       94,   95,   95,   95,   97,   97,   99,   99,  108,   94,
      100,  100,   95,   98,  101,  101,   99,  101,  101,  155,
      100,  118,  118,  133,  144,  133,  152,   94,  108,  136,
      136,  142,  142,  149,  144,  154,  149,  156,  156,  149,
      155,  157,  157,  152,  165,  165,  179,  179,  154,  259,
      142,  178,  178,  259,  178,  178,  179,  180,  180,  181,
      181,  196,  196,  142,  142,  146,  225,  146,  146,  225,
      146,  146,  146,  146,  146,  150,  396,  150,  150,  332,
      150,  150,  150,  150,  150,  199,  199,  220,  220,  222,
      226,  227,  395,  196,  275,  222,  223,  332,  223,  223,

      275,  223,  223,  223,  223,  223,  224,  228,  224,  224,
      229,  224,  224,  224,  224,  224,  227,  241,  241,  226,
      278,  228,  242,  242,  255,  255,  271,  271,  279,  229,
      273,  273,  274,  274,  281,  281,  280,  295,  295,  306,
      306,  308,  308,  309,  310,  311,  394,  312,  313,  313,
      278,  333,  324,  324,  255,  279,  280,  352,  352,  393,
      309,  353,  353,  363,  363,  364,  364,  390,  390,  392,
      392,  310,  324,  391,  388,  387,  386,  311,  312,  385,
      384,  383,  333,  381,  380,  313,  379,  378,  376,  375,
      374,  372,  371,  370,  369,  368,  367,  366,  365,  363,

      362,  361,  364,  360,  359,  351,  392,  406,  406,  406,
      406,  406,  406,  406,  406,  407,  407,  407,  407,  407,
      407,  407,  407,  408,  408,  408,  408,  408,  408,  408,
      408,  409,  409,  409,  409,  409,  409,  409,  409,  410,
      410,  350,  410,  410,  410,  410,  410,  411,  349,  347,
      411,  411,  412,  412,  346,  412,  412,  412,  412,  412,
      413,  413,  413,  413,  414,  414,  345,  414,  414,  414,
      414,  414,  415,  415,  415,  415,  416,  344,  343,  416,
      416,  416,  416,  416,  417,  417,  341,  417,  417,  417,
      417,  417,  418,  418,  340,  418,  418,  418,  418,  418,

      419,  419,  338,  419,  419,  419,  419,  419,  420,  337,
      336,  420,  420,  421,  421,  421,  421,  422,  422,  423,
      423,  423,  423,  424,  424,  335,  424,  424,  424,  424,
      424,  425,  334,  425,  426,  426,  331,  426,  426,  426,
      426,  426,  427,  427,  428,  428,  428,  428,  429,  429,
      429,  429,  430,  430,  430,  430,  330,  328,  326,  325,
      323,  322,  320,  318,  317,  316,  315,  314,  304,  301,
      299,  298,  297,  296,  294,  293,  292,  291,  289,  288,
      286,  285,  283,  282,  276,  272,  270,  268,  267,  264,
      262,  261,  260,  258,  257,  254,  252,  250,  249,  246,

      245,  243,  240,  239,  235,  234,  233,  232,  230,  221,
      219,  218,  217,  216,  215,  214,  213,  212,  211,  210,
      209,  208,  206,  205,  204,  203,  202,  201,  200,  198,
      197,  195,  194,  193,  192,  191,  190,  189,  188,  186,
      177,  176,  174,  171,  167,  166,  164,  162,  161,  160,
      159,  158,  151,  145,  143,  141,  140,  138,  137,  135,
      134,  132,  131,  130,  129,  127,  126,  125,  124,  123,
      122,  121,  120,  119,  116,  115,  114,  113,  112,  111,
      110,  109,  107,   93,   92,   89,   88,   84,   81,   77,
       76,   75,   74,   73,   70,   58,   53,   50,   46,   45,

       44,   41,   39,   37,   36,   35,   29,   22,   21,   20,
       19,   15,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#define INITIAL 0
//--------------------------------------------------------------------
// Microsoft Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// @doc OPTIONAL EXTRACTION CODES
//
// @module  ms-sql.l |
//          LEX tokenizer script
//
// @devnotes none
//
// @rev 0 | 04-Feb-97 | v-charca  | Created
//

/**
** NOTE : when adding a new token (XXX) modify the following:
**      1.) Add %token _XXX to sql.y
**      2.) Add lexeme pattern to sql.l stating whether the token returns a TOKEN
**          or a VALUE.  If the token returns a value a node will need to be created to
**          contain the value information. Therefore the VALUE macro will also need to
**          specify a valid VARIANT type for the value.
**/


#include "msidxtr.h"

#ifdef DEBUG
# define YYTRACE(tknNum) LexerTrace(yytext, yyleng, tknNum);
#else
# define YYTRACE(tknNum)
#endif


#define TOKEN(tknNum) YYTRACE(tknNum) return(tknNum);

#define VALUE(tknNum)                   \
    {                                   \
    YYTRACE(tknNum)                     \
    CreateTknValue(yylval, tknNum);     \
    return tknNum;                      \
    }

#define STRING_VALUE(tknNum, wch, fQuote)           \
    {                                               \
    YYTRACE(tknNum)                                 \
    CreateTknValue(yylval, tknNum, wch, fQuote);    \
    return tknNum;                                  \
    }

#define ID_VALUE(tknNum, wch)               \
    {                                       \
    YYTRACE(tknNum)                         \
    CreateTknValue(yylval, tknNum, wch);    \
    return _ID;                             \
    }

/*
** Make Lex read from a block of data
**    buffer is the character buffer,
**    result is a variable to store the number of chars read
**    ms is the size of the buffer
*/
#undef YY_INPUT
#define YY_INPUT(b, r, ms) (r = yybufferinput(b, ms))

//--------------------------------------------------------------------------------------------
// @func Makes a new copy of UNICODE string.  Filters out double quotes
// @side Allocates enough bytes to hold string
// @rdesc Pointer to new UNICODE string

LPWSTR PwszDupFilter(
    LPWSTR  pwszOrig,
    WCHAR   wch )
{
    LPWSTR pwszCopy = (LPWSTR)CoTaskMemAlloc( (wcslen(pwszOrig)+2)*sizeof(WCHAR) );
    if ( 0 != pwszCopy )
    {
        LPWSTR pwsz = pwszCopy;
        while ( 0 != *pwszOrig )
        {
            if ( *(pwszOrig+1) && *(pwszOrig+1) == *pwszOrig && wch == *pwszOrig )
                pwszOrig++;
            else
                *pwsz++ = *pwszOrig++;
        }
        *pwsz = L'\0';
    }

    return pwszCopy;
}

//--------------------------------------------------------------------------------------------
//      YYLEXER::CreateTknValue
//      Creates a QUERYTREE node structure which is passed to the YACC value stack.
//      This routines uses the TokenInfo map to determine which opids to create for
//      the given string.
//
//
void YYLEXER::CreateTknValue(
    YYSTYPE *ppct,
    short tknNum,
    YY_CHAR wch,
    BOOL fQuote )
{
    // Note that values containing variants can only be CONSTANTS or ID's
    // SHOULD BE DONE BY valType
    switch ( tknNum )
    {
        case _ID:
        case _TEMPVIEW:
            {
                // Assume table_name for now.  Might have to correct this when I
                // see the context in the parser.
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_WSTR)) )
                    throw(E_OUTOFMEMORY);

                (*ppct)->op    = DBOP_table_name;
                (*ppct)->wKind = DBVALUEKIND_WSTR;
                (*ppct)->value.pwszValue = CoTaskStrDup(yytext_ptr);
                if( 0 == (*ppct)->value.pwszValue )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }
                _wcsupr((*ppct)->value.pwszValue);
                break;
            }

        case _DELIMITED_ID:
            {
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_WSTR)) )
                    throw(E_OUTOFMEMORY);

                (*ppct)->op    = DBOP_table_name;
                (*ppct)->wKind = DBVALUEKIND_WSTR;
                // Strip quotes on delimited identifier
                yytext_ptr[wcslen(yytext_ptr)-1] = L'\0';
                (*ppct)->value.pwszValue = PwszDupFilter(yytext_ptr+1, wch);
                if( 0 == (*ppct)->value.pwszValue )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }
                break;
            }

        case _URL:
        case _STRING:
        case _PREFIX_STRING:
            {
                // NOTE:  This is really a PROPVARIANT node, but there is no DBVALUEKIND for PROPVARIANT.
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                    throw(E_OUTOFMEMORY);

                LPWSTR pwsz = yytext_ptr;
                LPWSTR pwszCopy = PwszDupFilter(pwsz, wch);

                if ( 0 == pwszCopy )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }

                LPWSTR pwszTemp = pwszCopy;
                // Strip quotes on literals or
                if ( fQuote && (*pwszCopy == L'\"' || *pwszCopy == L'\'') )
                {
                    pwszCopy++;
                    Assert(pwszCopy[wcslen(pwszCopy)-1] == L'\"' || pwszCopy[wcslen(pwszCopy)-1] == L'\'');
                    pwszCopy[wcslen(pwszCopy)-1] = L'\0';
                }

                ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( pwszCopy );
                CoTaskMemFree( pwszTemp );  // throw away temporary before testing for out of memory
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
                if( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
                {
                    DeleteDBQT( *ppct );
                    *ppct = 0;
                    throw(E_OUTOFMEMORY);
                }
            }
            break;

        case _INTNUM:
            if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                throw(E_OUTOFMEMORY);

            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( yytext_ptr );
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
            if ( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
            {
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(E_OUTOFMEMORY);
            }

            (*ppct)->hrError = PropVariantChangeTypeI64( (PROPVARIANT*)(*ppct)->value.pvValue );
            if ( FAILED((*ppct)->hrError) )
            {
                HRESULT hr = (*ppct)->hrError;
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(hr);
            }
            break;

        case _REALNUM:
            if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                throw(E_OUTOFMEMORY);

            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( yytext_ptr );
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
            if ( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
            {
                DeleteDBQT( *ppct );
                *ppct = NULL;
                throw(E_OUTOFMEMORY);
            }

            (*ppct)->hrError = VariantChangeTypeEx( (*ppct)->value.pvarValue,  // convert in place
                                                    (*ppct)->value.pvarValue,
                                                    LOCALE_SYSTEM_DEFAULT,
                                                    0,
                                                    VT_R8 );
            if ( FAILED((*ppct)->hrError) )
            {
                HRESULT hr = (*ppct)->hrError;
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(hr);
            }
            break;

        default:
            Assert( !"Unkown token value" );
    }
}


#define contains 1

#define cntntsrch 2

#define scope0 3

#define scope1 4

#define scope2 5

#define view 6


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
 int yyywrap YY_PROTO(( void )) {return 1;}
#else
extern int yyywrap YY_PROTO(( void ));
#endif
#endif


#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( YY_CHAR *, yyconst YY_CHAR *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst YY_CHAR * ));
#endif

#ifndef YY_NO_INPUT
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE (8192 / sizeof(TCHAR))
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( (result = LexerInput( (YY_CHAR *) buf, max_size )) < 0 ) \
                /*YY_FATAL_ERROR( L"input in flex scanner failed" );*/
                throw(E_FAIL);
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int YYLEXER::yylex(YYSTYPE *yylval)
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp, *yy_bp;
        register int yy_act;




/***
 *** Reserved words in every context
 ***/


        if ( yy_init )
                {
                yy_init = 0;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yy_start )
                        yy_start = 1;   /* first start state */

                if ( ! yy_current_buffer )
                        yy_current_buffer =
                                yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

                yy_load_buffer_state();

                if (yyprimetoken)
                        {
                        int yysavetoken = yyprimetoken;
                        yyprimetoken = 0;
                        return yysavetoken;
                        }
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
                yy_cp = yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = 1; if (256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 406 )
					yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 405 );
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

                YY_DO_BEFORE_ACTION;


do_action:      /* This label is used only to access EOF actions. */


                switch ( yy_act )
        { /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
{ TOKEN(_ALL);                      }
	YY_BREAK
case 2:
YY_RULE_SETUP
{ TOKEN(_AND);                      }
	YY_BREAK
case 3:
YY_RULE_SETUP
{ TOKEN(_ANY);                      }
	YY_BREAK
case 4:
YY_RULE_SETUP
{ TOKEN(_ARRAY);                    }
	YY_BREAK
case 5:
YY_RULE_SETUP
{ TOKEN(_AS);                       }
	YY_BREAK
case 6:
YY_RULE_SETUP
{ TOKEN(_ASC);                      }
	YY_BREAK
case 7:
YY_RULE_SETUP
{ TOKEN(_CAST);                     }
	YY_BREAK
case 8:
YY_RULE_SETUP
{ TOKEN(_CREATE);                   }
	YY_BREAK
case 9:
YY_RULE_SETUP
{ BEGIN contains;TOKEN(_CONTAINS);  }
	YY_BREAK
case 10:
YY_RULE_SETUP
{ TOKEN(_DESC);                     }
	YY_BREAK
case 11:
YY_RULE_SETUP
{ TOKEN(_DROP);                     }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ TOKEN(_FALSE);                    }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ TOKEN(_FREETEXT);                 }
	YY_BREAK
case 14:
YY_RULE_SETUP
{ TOKEN(_FROM);                     }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ TOKEN(_IS);                       }
	YY_BREAK
case 16:
YY_RULE_SETUP
{ TOKEN(_IS_NOT);                   }
	YY_BREAK
case 17:
YY_RULE_SETUP
{ TOKEN(_LIKE);                     }
	YY_BREAK
case 18:
YY_RULE_SETUP
{ TOKEN(_MATCHES);                  }
	YY_BREAK
case 19:
YY_RULE_SETUP
{ TOKEN(_NOT);                      }
	YY_BREAK
case 20:
YY_RULE_SETUP
{ TOKEN(_NOT_LIKE);                 }
	YY_BREAK
case 21:
YY_RULE_SETUP
{ TOKEN(_NULL);                     }
	YY_BREAK
case 22:
YY_RULE_SETUP
{ TOKEN(_OR);                       }
	YY_BREAK
case 23:
YY_RULE_SETUP
{ TOKEN(_ORDER_BY);                 }
	YY_BREAK
case 24:
YY_RULE_SETUP
{ TOKEN(_PASSTHROUGH);              }
	YY_BREAK
case 25:
YY_RULE_SETUP
{ TOKEN(_PROPERTYNAME);             }
	YY_BREAK
case 26:
YY_RULE_SETUP
{ TOKEN(_PROPID);                   }
	YY_BREAK
case 27:
YY_RULE_SETUP
{ TOKEN(_RANKMETHOD);               }
	YY_BREAK
case 28:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_SCOPE);      }
	YY_BREAK
case 29:
YY_RULE_SETUP
{ TOKEN(_SELECT);                   }
	YY_BREAK
case 30:
YY_RULE_SETUP
{ TOKEN(_SET);                      }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ TOKEN(_SOME);                     }
	YY_BREAK
case 32:
YY_RULE_SETUP
{ TOKEN(_TABLE);                    }
	YY_BREAK
case 33:
YY_RULE_SETUP
{ TOKEN(_TRUE);                     }
	YY_BREAK
case 34:
YY_RULE_SETUP
{ TOKEN(_TYPE);                     }
	YY_BREAK
case 35:
YY_RULE_SETUP
{ TOKEN(_UNION);                    }
	YY_BREAK
case 36:
YY_RULE_SETUP
{ TOKEN(_UNKNOWN);                  }
	YY_BREAK
case 37:
YY_RULE_SETUP
{ TOKEN(_VIEW);                     }
	YY_BREAK
case 38:
YY_RULE_SETUP
{ TOKEN(_WHERE);                    }
	YY_BREAK
case 39:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 40:
YY_RULE_SETUP
{ VALUE(_ID);                       }
	YY_BREAK
case 41:
YY_RULE_SETUP
{ VALUE(_TEMPVIEW);                 }
	YY_BREAK
case 42:
YY_RULE_SETUP
{ VALUE(_TEMPVIEW);                 }
	YY_BREAK
case 43:
YY_RULE_SETUP
{ ID_VALUE(_DELIMITED_ID, L'"');        }
	YY_BREAK
case 44:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', TRUE);}
	YY_BREAK
case 45:
YY_RULE_SETUP
{ VALUE(_INTNUM);                   }
	YY_BREAK
case 46:
YY_RULE_SETUP
{ VALUE(_REALNUM);                  }
	YY_BREAK
case 47:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 48:
YY_RULE_SETUP
{ TOKEN(_GE);                       }
	YY_BREAK
case 49:
YY_RULE_SETUP
{ TOKEN(_LE);                       }
	YY_BREAK
case 50:
YY_RULE_SETUP
{ TOKEN(_NE);                       }
	YY_BREAK
case 51:
YY_RULE_SETUP
{ TOKEN(_NE);                       }
	YY_BREAK
case 52:
YY_RULE_SETUP
{ TOKEN(_DOT);                      }
	YY_BREAK
case 53:
YY_RULE_SETUP
{ BEGIN view; TOKEN(_DOTDOT);       }
	YY_BREAK
case 54:
YY_RULE_SETUP
{ BEGIN view; TOKEN(_DOTDOTDOT);    }
	YY_BREAK
case 55:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_DOTDOT_SCOPE);}
	YY_BREAK
case 56:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_DOTDOTDOT_SCOPE);}
	YY_BREAK
case 57:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0]; }
	YY_BREAK

/***
 *** A <contains predicate> has been started.  The only things we should see are:
 ***    (                   - matched by .
 ***    <column reference>  - matched by {id} or "{br_id}"
 ***    ,                   - matched by .
 ***    '                   - matched by \'.  Also switch to content search state (cntnsrch).
 ***/

case 58:
YY_RULE_SETUP
{ BEGIN cntntsrch;YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 59:
YY_RULE_SETUP
{ VALUE(_ID);                       }
	YY_BREAK
case 60:
YY_RULE_SETUP
{ ID_VALUE(_DELIMITED_ID, L'"');        }
	YY_BREAK
case 61:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 62:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** The only things we should see are:
 ***    <global view name>  - matched by {id}
 ***    _TEMPVIEW           - matched by \#{id} or \#\#{id}
 ***/

case 63:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_ID);        }
	YY_BREAK
case 64:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_TEMPVIEW);  }
	YY_BREAK
case 65:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_TEMPVIEW);  }
	YY_BREAK

/***
 *** A <content search condition> has been started.  There are several keywords we can see here.
 *** We are also looking for a quoted string, a prefix string, or a simple term.  We are taken
 *** back to the initial state by a single quote (').
 ***/

case 66:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_AND);         }
	YY_BREAK
case 67:
YY_RULE_SETUP
{ TOKEN(_COERCE);                   }
	YY_BREAK
case 68:
YY_RULE_SETUP
{ TOKEN(_ISABOUT);                  }
	YY_BREAK
case 69:
YY_RULE_SETUP
{ TOKEN(_NEAR);                     }
	YY_BREAK
case 70:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_NOT);         }
	YY_BREAK
case 71:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_OR);          }
	YY_BREAK
case 72:
YY_RULE_SETUP
{ TOKEN(_FORMSOF);                  }
	YY_BREAK
case 73:
YY_RULE_SETUP
{ TOKEN(_WEIGHT);                   }
	YY_BREAK
case 74:
YY_RULE_SETUP
{ STRING_VALUE(_PREFIX_STRING, L'\'', TRUE);}
	YY_BREAK
case 75:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', TRUE);}
	YY_BREAK
case 76:
YY_RULE_SETUP
{ BEGIN INITIAL; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 77:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 78:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', FALSE)}
	YY_BREAK
case 79:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** A <from clause> has been started.  We've already seen the keyword SCOPE, so this
 *** is not a FROM <view name>.  We're just looking for a ( now to put us into the
 *** next state (scope1).
 ***    (                   - matched by \(.  Also switch to scope1 state.
 ***/

case 80:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 81:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 82:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** We're in the middle of a <from clause>.  We've seen FROM SCOPE(, so now we need to recognize
 *** the various scope definitions that we might see here.  The two important things to recognize
 *** are:
 ***    (                   - matched by \(.  Also switch to scope2 state to match parens.
 ***    )                   - matched by \).  Also switch to the initial (finished <from clause>).
 ***/

case 83:
YY_RULE_SETUP
{ STRING_VALUE(_URL, L'"', TRUE);   }
	YY_BREAK
case 84:
YY_RULE_SETUP
{ TOKEN(_ALL);                      }
	YY_BREAK
case 85:
YY_RULE_SETUP
{ TOKEN(_DEEP_TRAVERSAL);           }
	YY_BREAK
case 86:
YY_RULE_SETUP
{ TOKEN(_EXCLUDE_SEARCH_TRAVERSAL);}
	YY_BREAK
case 87:
YY_RULE_SETUP
{ TOKEN(_OF);                       }
	YY_BREAK
case 88:
YY_RULE_SETUP
{ TOKEN(_SHALLOW_TRAVERSAL);        }
	YY_BREAK
case 89:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 90:
YY_RULE_SETUP
{ BEGIN scope2; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 91:
YY_RULE_SETUP
{ BEGIN INITIAL; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 92:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** We're still in the middle of a <from clause>.  So far we've seen:
 ***    FROM SCOPE( ... (
 *** We need to find a ')' to finish out the element we're working on:
 ***    )                   - matched by \).  Also switch back to scope1 state.
 ***/

case 93:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 94:
YY_RULE_SETUP
{ STRING_VALUE(_URL, L'"', TRUE);  }
	YY_BREAK
case 95:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 96:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 97:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(contains):
case YY_STATE_EOF(cntntsrch):
case YY_STATE_EOF(scope0):
case YY_STATE_EOF(scope1):
case YY_STATE_EOF(scope2):
case YY_STATE_EOF(view):
	yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB YY_CHAR. */
                int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between yy_current_buffer and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yy_n_chars = yy_current_buffer->yy_n_chars;
                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer() )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yy_did_buffer_switch_on_eof = 0;

                                if ( yyywrap() )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yy_c_buf_p =
                                        yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yy_c_buf_p =
                                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                /* YY_FATAL_ERROR(L"fatal flex scanner internal error--no action found" );*/
                throw(E_FAIL);
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of yylex */

YYLEXER::YYLEXER()
        {
        yy_c_buf_p = 0;
        yy_init = 1;
        yy_start = 0;
        yyprimetoken = 0;
        yy_flex_debug = 0;
        yylineno = 1;   // this will only get updated if %option yylineno

        yy_did_buffer_switch_on_eof = 0;

        yy_looking_for_trail_begin = 0;
        yy_more_flag = 0;
        yy_more_len = 0;
        yy_more_offset = yy_prev_more_offset = 0;

        yy_start_stack_ptr = yy_start_stack_depth = 0;
        yy_start_stack = 0;

        yy_current_buffer = 0;

#ifdef YY_USES_REJECT
        yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
        yy_state_buf = 0;
#endif

        pszInputBuffer = pCurBuffer = (YY_CHAR *)NULL;
        cInputBuffer = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNDEBUG") ? 1 : 0;
#endif
        }

YYLEXER::~YYLEXER()
        {
        delete yy_state_buf;
        yy_delete_buffer( yy_current_buffer );
        }

#ifdef YY_INTERACTIVE
int YYLEXER::LexerInput( YY_CHAR* buf, int /* max_size */ )
#else
int YYLEXER::LexerInput( YY_CHAR* buf, int max_size )
#endif
        {
        return 0;
        }

void YYLEXER::LexerOutput( const YY_CHAR* buf, int size )
        {
        /*
        for (int i=0; i<size; i++)
                yyout->put(char(buf[i]));

        (void) yyout->put('\n');
        */
        }


#ifdef DEBUG
void YYLEXER::LexerTrace(const YY_CHAR* buf, int size, int tknNum)
        {
        if (tkndebug > 0)
                {
                cout << ">> Lexing Token : ";
                for (int i=0; i<size; i++)
                        cout << char(buf[i]);
                cout << " (" << tknNum << ")"<< endl;
                }
        }
#endif


void YYLEXER::ResetLexer()
        {
        yy_init = 1;
        yy_start = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNTRACE") ? 1 : 0;
#endif
        }

int YYLEXER::yybufferinput(YY_CHAR *pszBuffer, int cMax)
        {
        int n = min(cMax, cInputBuffer - (int) (pCurBuffer - pszInputBuffer));

        if (n > 0)
                {
                memcpy(pszBuffer, pCurBuffer, n * sizeof(TCHAR));
                pCurBuffer += n;
                }
        return n;
        }

void YYLEXER::yyprimebuffer(YY_CHAR *pszBuffer)
        {
//      if (NULL != pszInputBuffer)
//              CoTaskMemFree(pszInputBuffer);

//      pszInputBuffer = pCurBuffer = strdup(pszBuffer);
        pszInputBuffer = pCurBuffer = pszBuffer;
        cInputBuffer = strlen(pszInputBuffer);

        ResetLexer();
        }

void YYLEXER::yyprimelexer(int eToken)
        {
        yyprimetoken = eToken;
        }

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */

int YYLEXER::yy_get_next_buffer()
        {
        register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
        register YY_CHAR *source = yytext_ptr;
        register int number_to_move, i;
        int ret_val;

        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
                /* YY_FATAL_ERROR(L"fatal flex scanner internal error--end of buffer missed" ); */
                throw(E_FAIL);

        if ( yy_current_buffer->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                yy_current_buffer->yy_n_chars = yy_n_chars = 0;

        else
                {
                int num_to_read =
                        yy_current_buffer->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
                        /*YY_FATAL_ERROR(L"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );*/
                        throw(E_OUTOFMEMORY);
#else

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = yy_current_buffer;

                        int yy_c_buf_p_offset =
                                (int) (yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (YY_CHAR *)
                                        /* Include room in for 2 EOB chars. */
                                        yy_flex_realloc( (void *) b->yy_ch_buf,
                                                         b->yy_buf_size + 2 );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                /*YY_FATAL_ERROR(L"fatal error - scanner input buffer overflow");*/
                                throw(E_FAIL);

                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = yy_current_buffer->yy_buf_size -
                                                number_to_move - 1;
#endif
                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                        yy_n_chars, num_to_read );

                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        if ( yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        yy_current_buffer->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        yy_n_chars += number_to_move;
        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

        return ret_val;
        }


/* yy_get_previous_state - get the state just before the EOB YY_CHAR was reached */

yy_state_type YYLEXER::yy_get_previous_state()
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp;

	yy_current_state = yy_start;

        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
                {
		register YY_CHAR yy_c = 1; if (0!= *yy_cp && 256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 406 )
				yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
        }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YYLEXER::yy_try_NUL_trans( yy_state_type yy_current_state )
        {
        register int yy_is_jam;
	register YY_CHAR *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 406 )
			yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 405);

        return yy_is_jam ? 0 : yy_current_state;
        }


void YYLEXER::yyunput( int c, register YY_CHAR* yy_bp )
        {
        register YY_CHAR *yy_cp = yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yy_hold_char;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                register int number_to_move = yy_n_chars + 2;
                register YY_CHAR *dest = &yy_current_buffer->yy_ch_buf[
                                        yy_current_buffer->yy_buf_size + 2];
                register YY_CHAR *source =
                                &yy_current_buffer->yy_ch_buf[number_to_move];

                while ( source > yy_current_buffer->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                yy_current_buffer->yy_n_chars =
                        yy_n_chars = yy_current_buffer->yy_buf_size;

                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                        /*YY_FATAL_ERROR( L"flex scanner push-back overflow" );*/
                        throw(E_FAIL);
                }

        *--yy_cp = (YY_CHAR) c;


        yytext_ptr = yy_bp;
        yy_hold_char = *yy_cp;
        yy_c_buf_p = yy_cp;
        }


int YYLEXER::yyinput()
        {
        int c;

        *yy_c_buf_p = yy_hold_char;

        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        /* This was really a NUL. */
                        *yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = (int)(yy_c_buf_p - yytext_ptr);
                        ++yy_c_buf_p;

                        switch ( yy_get_next_buffer() )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( );

                                        /* fall through */

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yyywrap() )
                                                return EOF;

                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yy_c_buf_p = yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(YY_CHAR *) yy_c_buf_p;    /* cast for 8-bit YY_CHAR's */
        *yy_c_buf_p = '\0';     /* preserve yytext */
        yy_hold_char = *++yy_c_buf_p;


        return c;
        }


void YYLEXER::yyrestart( )
        {
        if ( ! yy_current_buffer )
                yy_current_buffer = yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

        yy_init_buffer( yy_current_buffer );
        yy_load_buffer_state();
        }


void YYLEXER::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        {
        if ( yy_current_buffer == new_buffer )
                return;

        if ( yy_current_buffer )
                {
                /* Flush out information for old buffer. */
                *yy_c_buf_p = yy_hold_char;
                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        yy_current_buffer = new_buffer;
        yy_load_buffer_state();

        /* We don't actually know whether we did this switch during
         * EOF (yyywrap()) processing, but the only time this flag
         * is looked at is after yyywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yy_did_buffer_switch_on_eof = 1;
        }


void YYLEXER::yy_load_buffer_state()
        {
        yy_n_chars = yy_current_buffer->yy_n_chars;
        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        yy_hold_char = *yy_c_buf_p;
        }


YY_BUFFER_STATE YYLEXER::yy_create_buffer( int size )
        {
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        if ( ! b )
                /*YY_FATAL_ERROR( L"out of dynamic memory in yy_create_buffer()" );*/
                throw(E_OUTOFMEMORY);

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (YY_CHAR *) yy_flex_alloc( b->yy_buf_size + 2 );
        if ( ! b->yy_ch_buf )
                /*YY_FATAL_ERROR( L"out of dynamic memory in yy_create_buffer()" );*/
                throw(E_OUTOFMEMORY);

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b );

        return b;
        }


void YYLEXER::yy_delete_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        if ( b == yy_current_buffer )
                yy_current_buffer = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yy_flex_free( (void *) b->yy_ch_buf );

        yy_flex_free( (void *) b );
        }


extern "C" int isatty YY_PROTO(( int ));
void YYLEXER::yy_init_buffer( YY_BUFFER_STATE b )

        {
        yy_flush_buffer( b );

        b->yy_fill_buffer = 1;

        b->yy_is_interactive = 0;
        }


void YYLEXER::yy_flush_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == yy_current_buffer )
                yy_load_buffer_state();
        }


#ifndef YY_NO_SCAN_BUFFER
#endif


#ifndef YY_NO_SCAN_STRING
#endif


#ifndef YY_NO_SCAN_BYTES
#endif


#ifndef YY_NO_PUSH_STATE
void YYLEXER::yy_push_state( int new_state )
        {
        if ( yy_start_stack_ptr >= yy_start_stack_depth )
                {
                yy_size_t new_size;

                yy_start_stack_depth += YY_START_STACK_INCR;
                new_size = yy_start_stack_depth * sizeof( int );

                if ( ! yy_start_stack )
                        yy_start_stack = (int *) yy_flex_alloc( new_size );

                else
                        yy_start_stack = (int *) yy_flex_realloc(
                                        (void *) yy_start_stack, new_size );

                if ( ! yy_start_stack )
                        /*YY_FATAL_ERROR(L"out of memory expanding start-condition stack" );*/
                        throw(E_OUTOFMEMORY);
                }

        yy_start_stack[yy_start_stack_ptr++] = YY_START;

        BEGIN(new_state);
        }
#endif


#ifndef YY_NO_POP_STATE
void YYLEXER::yy_pop_state()
        {
        if ( --yy_start_stack_ptr < 0 )
                /*YY_FATAL_ERROR( L"start-condition stack underflow" );*/
                throw(E_FAIL);

        BEGIN(yy_start_stack[yy_start_stack_ptr]);
        }
#endif


#ifndef YY_NO_TOP_STATE
int YYLEXER::yy_top_state()
        {
        return yy_start_stack[yy_start_stack_ptr - 1];
        }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif


void YYLEXER::LexerError( yyconst YY_CHAR msg[] )
        {
/* ******************************** Don't really want to do this ************************************
        // UNDONE:  3/28/97  This needs to pass the error message back to yacc (or
        //                      store it in the error area itself!
        for (unsigned int i=0; i<wcslen(msg); i++)
                cerr << char(msg[i]);
        cerr << endl;
        exit( YY_EXIT_FAILURE );
   ******************************** Don't really want to do this ************************************ */
        }


/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( YY_CHAR *s1, yyconst YY_CHAR *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
YY_CHAR *s1;
yyconst YY_CHAR *s2;
int n;
#endif
        {
        register int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
        }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst YY_CHAR *s )
#else
static int yy_flex_strlen( s )
yyconst YY_CHAR *s;
#endif
        {
        register int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
        }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
        {
        return (void *) malloc( size );
        }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
        {
        /* The cast to (YY_CHAR *) in the following accommodates both
         * implementations that use YY_CHAR* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
        return (void *) realloc( (YY_CHAR *) ptr, size );
        }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
        {
        free( ptr );
        }


#if YY_MAIN
int main()
        {
        yylex();
        return 0;
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\mssqltab.cpp ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
//--------------------------------------------------------------------
// Microsoft Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// @doc OPTIONAL EXTRACTION CODES
//
// @module  MS-sql.y |
//          Monarch SQL YACC Script
//
// @devnote none
//
// @rev 0 | 04-Feb-97 | v-charca | Created
//
/* 3.4  Object identifier for Database Language SQL */
#pragma hdrstop
#pragma optimize("g", off)

#include    "msidxtr.h"

EXTERN_C const IID IID_IColumnMapperCreator;

#define VAL_AND_CCH_MINUS_NULL(p1) (p1), ((sizeof(p1) / sizeof(*(p1))) - 1)

#ifdef YYDEBUG
#define YYTRACE(a,b,c) wprintf(L"** %s[%s%s] ** \n", a, b, c);
#else
#define YYTRACE(a,b,c)
#endif

#ifdef DEBUG
#define AssertReq(x)    Assert(x != NULL)
#else
#define AssertReq(x)
#endif



#define DEFAULTWEIGHT   1000

typedef struct tagDBTYPENAMETABLE
    {
    LPWSTR  pwszDBTypeName;
    DBTYPE  dbType;
    } DBTYPENAMETABLE;

//                            J   F   M   A   M   J   J   A   S   O   N   D
const short LeapDays[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
const short Days[12]     = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

#define IsLeapYear(yrs) (                       \
    (((yrs) % 400 == 0) ||                      \
     ((yrs) % 100 != 0) && ((yrs) % 4 == 0)) ?  \
        TRUE                                    \
    :                                           \
        FALSE                                   \
    )

#define DaysInMonth(YEAR,MONTH) (   \
    IsLeapYear(YEAR) ?              \
        LeapDays[(MONTH)]  :        \
        Days[(MONTH)]               \
    )

//-----------------------------------------------------------------------------
// @func GetDBTypeFromStr
//
// This function takes a TypeName as input, and returns the DBTYPE of the string
//
// @rdesc DBTYPE
//-----------------------------------------------------------------------------
DBTYPE GetDBTypeFromStr(
    LPWSTR  pwszDBTypeName )     // @parm IN
{
    DBTYPE dbType = DBTYPE_EMPTY;
    if ( 9 <= wcslen(pwszDBTypeName) )
        switch ( pwszDBTypeName[7] )
        {
        case L'U':
        case L'u':
            if (10 == wcslen(pwszDBTypeName))
                switch ( pwszDBTypeName[9])
                {
                    case L'1':
                        if (0 == _wcsicmp(L"DBTYPE_UI1", pwszDBTypeName))
                            dbType = DBTYPE_UI1;
                        break;

                    case L'2':
                        if (0 == _wcsicmp(L"DBTYPE_UI2", pwszDBTypeName))
                            dbType = DBTYPE_UI2;
                        break;

                    case L'4':
                        if (0 == _wcsicmp(L"DBTYPE_UI4", pwszDBTypeName))
                            dbType = DBTYPE_UI4;
                        break;

                    case L'8':
                        if (0 == _wcsicmp(L"DBTYPE_UI8", pwszDBTypeName))
                            dbType = DBTYPE_UI8;
                        break;

                    default:
                        break;
                }
            break;

        case L'I':
        case L'i':
            switch ( pwszDBTypeName[8] )
            {
                case L'1':
                    if ( 0 == _wcsicmp(L"DBTYPE_I1", pwszDBTypeName) )
                        dbType = DBTYPE_I1;
                    break;

                case L'2':
                    if ( 0 == _wcsicmp(L"DBTYPE_I2", pwszDBTypeName) )
                        dbType = DBTYPE_I2;
                    break;

                case L'4':
                    if ( 0 == _wcsicmp(L"DBTYPE_I4", pwszDBTypeName) )
                        dbType = DBTYPE_I4;
                    break;

                case L'8':
                    if ( 0 == _wcsicmp(L"DBTYPE_I8", pwszDBTy