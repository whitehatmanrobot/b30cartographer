lloc((void **)&pb, cb));
            
            CopyMemory(pb, pInfo->pszDef, cb);
            
            switch (pVar->vt)
            {
                case VT_LPSTR:
                    pVar->pszVal = (LPSTR)pb;
                    break;

                case VT_LPWSTR:
                    pVar->pwszVal = (LPWSTR)pb;
                    break;

                case VT_BLOB:
                    pVar->blob.cbSize = cb;
                    pVar->blob.pBlobData = pb;
                    break;
            }
        }
        else
            // Since this happens quite often, don't trace it.
            hr = E_NO_DEFAULT_VALUE;
    }

    pb = NULL;
exit:

    MemFree(pb);
    return(hr);
}

STDMETHODIMP COptionBucket::GetPropertyInfo(PROPID id, PROPINFO *pPropInfo, DWORD dwReserved)
{
    LPCOPTIONINFO   pInfo;
    HRESULT         hr = S_OK;
    LPBYTE          pb;
    DWORD           cb;
    
    if (pPropInfo == NULL || pPropInfo->cbSize < sizeof(PROPINFO))
        IF_FAILEXIT(hr = E_INVALIDARG);
    
#pragma prefast(disable:11, "noise")
    pPropInfo->uMin = 0;
    pPropInfo->uMax = 0;
#pragma prefast(enable:11, "noise")

    
    pInfo = GetOptionInfo(MAKEPROPSTRING(id));
    if (NULL == pInfo)
        IF_FAILEXIT(hr = E_PROP_NOT_FOUND);

#pragma prefast(disable:11, "noise")
    pPropInfo->vt = pInfo->vt;
    
    switch (pPropInfo->vt)
    {
        case VT_LPSTR:
        case VT_LPWSTR:
            pPropInfo->cchMax = pInfo->dwMax;
            break;

        case VT_UI4:
            pPropInfo->uMin = pInfo->dwMin;
            pPropInfo->uMax = pInfo->dwMax;
            break;
    }
#pragma prefast(enable:11, "noise")    
exit:
    return(hr);
}

LPSTR DupPath(LPCSTR sz, LPCSTR szSubDir)
{
    LPSTR szT = NULL;
    
    if (MemAlloc((void **)&szT, MAX_PATH))
    {
        lstrcpy(szT, sz);
        if (szSubDir != NULL)
            PathAppend(szT, szSubDir);
    }
    else
        TraceResult(E_OUTOFMEMORY);
    
    return(szT);
}

STDMETHODIMP COptionBucket::Initialize(LPCOPTBCKTINIT pInit)
{
    int     i;
    HRESULT hr = S_OK;
    
    Assert(pInit != NULL);
    Assert(pInit->rgInfo != NULL);
    Assert(pInit->cInfo > 0);
    Assert(pInit->pszRegKeyBase != NULL);
    Assert(pInit->cszRegKey <= CKEYMAX);
    Assert(pInit->hkey != NULL);
    
    Assert(m_pProp == NULL);
    
    m_rgInfo = pInit->rgInfo;
    m_cInfo = pInit->cInfo;
    
#ifdef DEBUG
    for (i = 0; i < m_cInfo - 1; i++)
    {
        Assert(m_rgInfo[i].id < m_rgInfo[i + 1].id);
    }
#endif // DEBUG
    
    m_hkey = pInit->hkey;
    
    IF_NULLEXIT(m_pszRegKeyBase = PszDup(pInit->pszRegKeyBase));
    
    Assert(m_cpszRegKey == 0);
    if (pInit->cszRegKey == 0)
    {
        IF_NULLEXIT(m_rgpszRegKey[0] = PszDup(m_pszRegKeyBase));
        m_cpszRegKey = 1;
    }
    else
    {
        for (i = 0; i < pInit->cszRegKey; i++)
        {
            IF_NULLEXIT(m_rgpszRegKey[i] = DupPath(m_pszRegKeyBase, pInit->rgpszRegSubKey[i]));
            m_cpszRegKey++;
        }
    }
    
    IF_NULLEXIT(m_pProp = new CPropertyBucket);

exit:
    return hr;
}

LPCOPTIONINFO COptionBucket::GetOptionInfo(LPCSTR pszProp)
{
    int left, right, x;
    LPCOPTIONINFO pInfo;
    PROPID id;
    
    Assert(pszProp != NULL);
    Assert(IsPropId(pszProp));
    
    id = SzToPropId(pszProp);
    
    left = 0;
    right = m_cInfo - 1;
    do
    {
        x = (left + right) / 2;
        pInfo = &m_rgInfo[x];
        
        if (id == pInfo->id)
            return(pInfo);
        else if (id < pInfo->id)
            right = x - 1;
        else
            left = x + 1;
    }
    while (right >= left);
    
    return(NULL);
}

STDMETHODIMP COptionBucket::SetNotification(IOptionBucketNotify *pNotify)
{
    if (m_pNotify != NULL)
    {
        m_pNotify->Release();
        m_pNotify = NULL;
    }
    
    if (pNotify != NULL)
    {
        m_pNotify = pNotify;
        pNotify->AddRef();
    }
    
    return(S_OK);
}

STDMETHODIMP COptionBucket::EnableNotification(BOOL fEnable)
{
    Assert(m_fNotify != fEnable);
    m_fNotify = fEnable;
    
    if (m_fNotify && m_pNotify && m_idNotify != 0)
    {
        m_pNotify->DoNotification((IOptionBucketEx *)this, 0, m_idNotify);
        m_idNotify = 0;
    }
    
    return(S_OK);
}

// WARNING!!! This function doesn't handle getting values that are unicode.
STDMETHODIMP_(LONG) COptionBucket::GetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD *ptype, LPBYTE pb, DWORD *pcb)
{
    char szKey[MAX_PATH];
    LONG lRet;
    
    Assert(ptype != NULL);
    Assert(szValue != NULL);
    Assert(pcb != NULL);
    
    if (szSubKey != NULL)
    {
        lstrcpy(szKey, m_pszRegKeyBase);
        PathAppend(szKey, szSubKey);
        szSubKey = szKey;
    }
    else
    {
        szSubKey = m_pszRegKeyBase;
    }
    
    lRet = SHGetValue(m_hkey, szSubKey, szValue, ptype, pb, pcb);
    
    return(lRet);
}

// WARNING!!! This function doesn't handle setting values that are unicode.
STDMETHODIMP_(LONG) COptionBucket::SetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD type, LPBYTE pb, DWORD cb)
{
    char szKey[MAX_PATH];
    LONG lRet;
    
    Assert(szValue != NULL);
    
    if (szSubKey != NULL)
    {
        lstrcpy(szKey, m_pszRegKeyBase);
        PathAppend(szKey, szSubKey);
        szSubKey = szKey;
    }
    else
    {
        szSubKey = m_pszRegKeyBase;
    }
    
    if (pb == NULL)
    {
        Assert(cb == 0);
        lRet = SHDeleteValue(m_hkey, szSubKey, szValue);
    }
    else
    {
        Assert(cb > 0);
        lRet = SHSetValue(m_hkey, szSubKey, szValue, type, pb, cb);
    }
    
    return(lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\passdlg.cpp ===
// =====================================================================================
// P A S S D L G . C P P
// Written by Steven J. Bailey 1/26/96
// =====================================================================================
#include "pch.hxx"
#include "passdlg.h"
#include "xpcomm.h"
#include "imnact.h"
#include "imnxport.h"
#include "demand.h"


// =====================================================================================
// Prototypes
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify);
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam);

// =====================================================================================
// HrGetPassword
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo)
{
    // Locals
    HRESULT             hr = S_OK;

    // Check Params
    AssertSz (lpPassInfo, "NULL Parameter");
    AssertSz (lpPassInfo->szTitle && lpPassInfo->lpszPassword && lpPassInfo->lpszAccount && lpPassInfo->lpszServer &&
              (lpPassInfo->fRememberPassword == TRUE || lpPassInfo->fRememberPassword == FALSE), "PassInfo struct was not inited correctly.");

    // Display Dialog Box
    INT nResult = (INT) DialogBoxParam (g_hLocRes, MAKEINTRESOURCE (iddPassword), hwndParent, PasswordDlgProc, (LPARAM)lpPassInfo);
    if (nResult == IDCANCEL)
        hr = S_FALSE;

    // Done
    return hr;
}

// =====================================================================================
// PasswordDlgProc
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG (hwndDlg, WM_INITDIALOG, PasswordDlgProc_OnInitDialog);
		HANDLE_MSG (hwndDlg, WM_COMMAND,    PasswordDlgProc_OnCommand);
	}

	return 0;
}

// =====================================================================================
// OnInitDialog
// =====================================================================================
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
    // Locals
    LPPASSINFO          lpPassInfo = NULL;
    TCHAR               szServer[CCHMAX_ACCOUNT_NAME];

	// Center
	CenterDialog (hwndDlg);

    // Make foreground
    SetForegroundWindow (hwndDlg);

    // Get Pass info struct
    lpPassInfo = (LPPASSINFO)lParam;
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        return 0;
    }

    SetWndThisPtr (hwndDlg, lpPassInfo);

    // Set Window Title
    SetWindowText (hwndDlg, lpPassInfo->szTitle);

	// Default
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->cbMaxAccount);
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->cbMaxPassword);

    // Set Defaults
    PszEscapeMenuStringA(lpPassInfo->lpszServer, szServer, sizeof(szServer) / sizeof(TCHAR));
    Edit_SetText (GetDlgItem (hwndDlg, IDS_SERVER), szServer);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword);
    CheckDlgButton (hwndDlg, IDCH_REMEMBER, lpPassInfo->fRememberPassword);
    if (lpPassInfo->fAlwaysPromptPassword)
        EnableWindow(GetDlgItem(hwndDlg, IDCH_REMEMBER), FALSE);

    // Set Focus
    if (!FIsStringEmpty(lpPassInfo->lpszAccount))
        SetFocus (GetDlgItem (hwndDlg, IDE_PASSWORD));

    // Done
	return FALSE;
}

// =====================================================================================
// OnCommand
// =====================================================================================
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
		HANDLE_COMMAND(hwndDlg, IDCANCEL, hwndCtl, codeNotify, PasswordDlgProc_OnCancel);		
		HANDLE_COMMAND(hwndDlg, IDOK, hwndCtl, codeNotify, PasswordDlgProc_OnOk);		
	}
	return;
}

// =====================================================================================
// OnCancel
// =====================================================================================
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
	EndDialog (hwndDlg, IDCANCEL);
}

// =====================================================================================
// OnOk
// =====================================================================================
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
    // Locals
    LPPASSINFO lpPassInfo = NULL;

    lpPassInfo = (LPPASSINFO)GetWndThisPtr (hwndDlg);
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        EndDialog (hwndDlg, IDOK);
        return;
    }

    Edit_GetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount, lpPassInfo->cbMaxAccount);
    Edit_GetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword, lpPassInfo->cbMaxPassword);
    lpPassInfo->fRememberPassword = IsDlgButtonChecked (hwndDlg, IDCH_REMEMBER);

    EndDialog (hwndDlg, IDOK);
}



//***************************************************************************
// Function: PromptUserForPassword
//
// Purpose:
//   This function prompts the user with a password dialog and returns the
// results to the caller.
//
// Arguments:
//   LPINETSERVER pInetServer [in/out] - provides default values for username
//     and password, and allows us to save password to account if user asks us
//     to. User-supplied username and password are saved to this structure
//     for return to the caller.
//   HWND hwnd [in] - parent hwnd to be used for password dialog.
//
// Returns:
//   TRUE if user pressed "OK" on dialog, FALSE if user pressed "CANCEL".
//***************************************************************************
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd)
{
    PASSINFO pi;
    HRESULT hrResult;
    BOOL bReturn;

    Assert(NULL != hwnd);

    // Initialize variables
    hrResult = S_OK;
    bReturn = FALSE;

    // Setup PassInfo Struct
    ZeroMemory (&pi, sizeof (PASSINFO));
    pi.lpszAccount = pInetServer->szUserName;
    pi.cbMaxAccount = sizeof(pInetServer->szUserName);
    pi.lpszPassword = pInetServer->szPassword;
    pi.cbMaxPassword = sizeof(pInetServer->szPassword);
    pi.lpszServer = pInetServer->szAccount;
    pi.fRememberPassword = !ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    pi.fAlwaysPromptPassword = ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    AthLoadString(idsImapLogon, pi.szTitle, ARRAYSIZE(pi.szTitle));

    // Prompt for password
    hrResult = HrGetPassword (hwnd, &pi);
    if (S_OK == hrResult) {
        IImnAccount *pAcct;

        // Cache the password for this session
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);

        // User wishes to proceed. Save account and password info
        hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pInetServer->szAccount, &pAcct);
        if (SUCCEEDED(hrResult)) {
            // I'll ignore error results here, since not much we can do about 'em
            pAcct->SetPropSz(AP_IMAP_USERNAME, pInetServer->szUserName);
            if (pi.fRememberPassword)
                pAcct->SetPropSz(AP_IMAP_PASSWORD, pInetServer->szPassword);
            else
                pAcct->SetProp(AP_IMAP_PASSWORD, NULL, 0);

            pAcct->SaveChanges();
            pAcct->Release();
        }

        bReturn = TRUE;
    }

    Assert(SUCCEEDED(hrResult));
    return bReturn;
} // PromptUserForPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\outbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     outbar.cpp
//
//  PURPOSE:    Implements the Outlook Bar
//

#include "pch.hxx"
#include "resource.h"
#include "outbar.h"
#include "goptions.h"
#include "ourguid.h"
#include <inpobj.h>
#include <browser.h>
#include <notify.h>
#include <strconst.h>
#include <thormsgs.h>
#include <shlwapi.h>
#include "shlwapip.h" 
#include "storutil.h"
#include "menures.h"
#include "menuutil.h"
#include "dragdrop.h"
#include "newfldr.h"
#include "finder.h"
#include "instance.h"

ASSERTDATA

#define IDC_FRAME       100
#define IDC_PAGER       101
#define IDC_TOOLBAR     102


#define HT_ENTER        1
#define HT_OVER         2
#define HT_LEAVE        3

// Special HitTest results
#define IBHT_SOURCE     (-32768)
#define IBHT_BACKGROUND (-32767)
#define IBHT_PAGER      (-32766)


////////////////////////////////////////////////////////////////////////
//
//  Prototypes
//
////////////////////////////////////////////////////////////////////////

HRESULT OutlookBar_LoadSettings(BAR_PERSIST_INFO **ppPersist);
HRESULT OutlookBar_SaveSettings(BAR_PERSIST_INFO *pPersist, DWORD cbData);

extern DWORD CUnread(FOLDERINFO *pfi);

////////////////////////////////////////////////////////////////////////
//
//  Module Data
//
////////////////////////////////////////////////////////////////////////

static const TCHAR s_szOutBarWndClass[] = TEXT("Outlook Express Outlook Bar");
static const TCHAR s_szOutBarFrameClass[] = TEXT("Outlook Express Outlook Bar Frame");
static const TCHAR c_szOutBarNotifyName[] = TEXT("Outlook Express Outlook Bar Notify");

////////////////////////////////////////////////////////////////////////
//
//  Constructors, Destructors, and other initialization stuff
//
////////////////////////////////////////////////////////////////////////

COutBar::COutBar()
{
    m_cRef = 1;
    m_hwndParent = NULL;
    m_hwnd = NULL;
    m_hwndFrame = NULL;
    m_hwndPager = NULL;
    m_hwndTools = NULL;
    m_ptbSite = NULL;
    m_fShow = FALSE;
    m_pBrowser = NULL;
    m_pStNotify = NULL;
    m_idCommand = 0;
    m_fResizing = FALSE;
    m_idSel = -1;

    // load the width from resource
    m_cxWidth = 70;
    TCHAR szBuffer[64];
    if (AthLoadString(idsMaxOutbarBtnWidth, szBuffer, ARRAYSIZE(szBuffer)))
    {
        m_cxWidth = StrToInt(szBuffer);
        if (m_cxWidth == 0)
            m_cxWidth = 70;
    }

    m_fLarge = TRUE;
    m_himlLarge = NULL;
    m_himlSmall = NULL;
    m_pOutBarNotify = NULL;

    m_pDataObject = NULL;
    m_grfKeyState = 0;
    m_dwEffectCur = DROPEFFECT_NONE;
    m_idCur = -1;
    m_pTargetCur = NULL;
    m_idDropHilite = 0;
    m_fInsertMark = FALSE;
    m_fOnce = TRUE;
}

COutBar::~COutBar()
{
    Assert(NULL == m_pStNotify);
    if (m_hwnd)
        DestroyWindow(m_hwnd);

    if (m_himlLarge)
        ImageList_Destroy(m_himlLarge);

    if (m_himlSmall)
        ImageList_Destroy(m_himlSmall);

    SafeRelease(m_pDataObject);
}

HRESULT COutBar::HrInit(LPSHELLFOLDER psf, IAthenaBrowser *psb)
{
    HRESULT hr;

    m_pBrowser = psb;

    hr = CreateNotify(&m_pStNotify);
    if (FAILED(hr))
        return(hr);
    return m_pStNotify->Initialize((TCHAR *)c_szMailFolderNotify);
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT COutBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IDockingWindow) ||
        IsEqualIID(riid, IID_IDatabaseNotify))
    {
        *ppvObj = (void*)(IDockingWindow*)this;
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (void*)(IObjectWithSite*)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG COutBar::AddRef()
{
    return ++m_cRef;
}

ULONG COutBar::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT COutBar::GetWindow(HWND * lphwnd)
{
    *lphwnd = m_hwnd;
    return (*lphwnd ? S_OK : E_FAIL);
}

HRESULT COutBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


//
//  FUNCTION:   COutBar::ShowDW()
//
//  PURPOSE:    Causes the bar to be displayed.  If it has not yet been
//              created, we do that here too.
//
//  PARAMETERS: 
//      [in] fShow - TRUE to make the bar visible, FALSE to hide.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT COutBar::ShowDW(BOOL fShow)
{
    // Make sure we have a site pointer first
    if (!m_ptbSite)
    {
        AssertSz(0, _T("COutBar::ShowDW() - Can't show without calling SetSite() first."));
        return E_FAIL; 
    }

    // Decide if we need to create a new window or show a currently existing
    // window    
    if (!m_hwnd)
    {
        WNDCLASSEX  wc;

        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szOutBarWndClass, &wc))
        {
            // We need to register the outlook bar class 
            wc.style            = 0;
            wc.lpfnWndProc      = COutBar::OutBarWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            wc.hCursor          = LoadCursor(NULL, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szOutBarWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;

            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
                return E_FAIL;

            // Also need to register the frame class
            wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
            wc.lpfnWndProc      = COutBar::ExtFrameWndProc;
            wc.lpszClassName    = s_szOutBarFrameClass;
            wc.hbrBackground    = (HBRUSH)(COLOR_3DSHADOW + 1);

            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
                return E_FAIL;
        }

        // Get the handle of the parent window
        if (FAILED(m_ptbSite->GetWindow(&m_hwndParent)))
            return E_FAIL;

        // Create the window
        m_hwnd = CreateWindowEx(0, s_szOutBarWndClass, NULL, WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
            0, 0, 0, 0, m_hwndParent, NULL, g_hInst, (LPVOID) this);
        if (!m_hwnd)
        {
            AssertSz(0, _T("COutBar::ShowDW() - Failed to create window."));
            return E_FAIL;
        }

        if (FAILED(_CreateToolbar()))
            return E_FAIL;
    }

    // Show or hide the window and resize the parent windows accordingly
    m_fShow = fShow;
    ResizeBorderDW(NULL, NULL, FALSE);
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);

    // Do notifications
    if (SUCCEEDED(CreateNotify(&m_pOutBarNotify)))
    {
        if (SUCCEEDED(m_pOutBarNotify->Initialize(c_szOutBarNotifyName)))
        {
            m_pOutBarNotify->Register(m_hwnd, g_hwndInit, FALSE);
        }
    }

    // Drag Drop
    RegisterDragDrop(m_hwndTools, this);

    g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this);

    return S_OK;
}


//
//  FUNCTION:   COutBar::CloseDW()
//
//  PURPOSE:    Destroys the bar and cleans up.
//
HRESULT COutBar::CloseDW(DWORD dwReserved)
{
    // Save our settings
    _SaveSettings();

    RevokeDragDrop(m_hwndTools);

    g_pStore->UnregisterNotify((IDatabaseNotify *) this);
    
    // Release
    if (m_pOutBarNotify != NULL)
    {
        if (m_hwnd != NULL)
            m_pOutBarNotify->Unregister(m_hwnd);
        m_pOutBarNotify->Release();
        m_pOutBarNotify = NULL;
    }

    // Release our notification interface
    if (m_pStNotify != NULL)
    {
        if (m_hwnd != NULL)
            m_pStNotify->Unregister(m_hwnd);
        m_pStNotify->Release();
        m_pStNotify = NULL;
    }

    // Clean up the toolbar and other child windows
    if (m_hwnd)
    {
        if (m_hwndTools)
            _EmptyToolbar(FALSE);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    return S_OK;
}


//
//  FUNCTION:   COutBar::ResizeBorderDW()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      LPCRECT prcBorder
//      IUnknown *punkToolbarSite
//      BOOL fReserved
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT COutBar::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkToolbarSite, BOOL fReserved)
{
    RECT rcRequest = { 0, 0, 0, 0 };
    RECT rcFrame;

    if (!m_ptbSite)
    {
        AssertSz(0, _T("COutBar::ResizeBorderDW() - Can't resize without calling SetSite() first."));
        return E_FAIL; 
    }

    if (m_fShow)
    {
        RECT rcBorder;

        if (!prcBorder)
        {
            // Find out how big our parent's border space is
            m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
        }

        // Figure out how much border space to ask the site for
        GetWindowRect(m_hwndFrame, &rcFrame);
        rcFrame.right = min(m_cxWidth - GetSystemMetrics(SM_CXFRAME) + 1, 
                            prcBorder->right - prcBorder->left);
        rcRequest.left = min(m_cxWidth, prcBorder->right - prcBorder->left - 32);


        // Set our new window position
        SetWindowPos(m_hwndFrame, NULL, 0, 0,
                     rcFrame.right, prcBorder->bottom - prcBorder->top, 
                     SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
        SetWindowPos(m_hwnd, NULL, prcBorder->left, prcBorder->top,  
                     rcRequest.left, prcBorder->bottom - prcBorder->top, 
                     SWP_NOACTIVATE | SWP_NOZORDER);
    }

    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);     
    
    return S_OK;
}


//
//  FUNCTION:   COutBar::SetSite()
//
//  PURPOSE:    Set's a site pointer for the class
//
HRESULT COutBar::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_ptbSite)
    {
        m_ptbSite->Release();
        m_ptbSite = NULL;
    }

    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)
    {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, (void **)&m_ptbSite)))
            return E_FAIL;
    }

    return S_OK;    
}


HRESULT COutBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

//
//  FUNCTION:   COutBar::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE COutBar::DragEnter(IDataObject* pDataObject, 
                                             DWORD grfKeyState, 
                                             POINTL pt, DWORD* pdwEffect)
{
    FORMATETC fe;
    POINT     ptTemp = {pt.x, pt.y};

    // Initialize our state
    SafeRelease(m_pDataObject);

    // Hold on to this new object
    m_pDataObject = pDataObject;
    m_pDataObject->AddRef();

    // The big question here is whether or not this data object is an OE folder
    // or is it something else.
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    m_fDropShortcut = SUCCEEDED(m_pDataObject->QueryGetData(&fe));

    if (!m_fDropShortcut)
    {
        SETDefFormatEtc(fe, CF_OESHORTCUT, TYMED_HGLOBAL);
        m_fDropShortcut = SUCCEEDED(m_pDataObject->QueryGetData(&fe));
    }

    if (m_fDropShortcut)
    {
        m_fDropShortcut = _IsTempNewsgroup(m_pDataObject);
    }

    DOUTL(32, "COutBar::DragEnter() - Data is %s shortcut", m_fDropShortcut ? "a" : "not a");

    // Hang on to this little gem
    m_grfKeyState = grfKeyState;

    // Initialize some other stuff
    m_idCur = -1;
    Assert(m_pTargetCur == NULL);
    m_tbim.iButton = -1;
    m_tbim.dwFlags = 0;

    // Set the default return value here
    m_dwEffectCur = *pdwEffect = DROPEFFECT_NONE;

    // Update the highlight point
    _UpdateDragDropHilite(&ptTemp);

    return (S_OK);
}

int COutBar::_GetItemFromPoint(POINT pt)
{
    int      iPos;
    TBBUTTON tb;

    // Figure out which button this is over
    ScreenToClient(m_hwndTools, &pt);
    iPos = ToolBar_HitTest(m_hwndTools, &pt);

    // If this is over a button, convert that button position to a command
    if (iPos >= 0)
    {
        ToolBar_GetButton(m_hwndTools, iPos, &tb);

        return (tb.idCommand);
    }

    return (-1);
}


void COutBar::_UpdateDragDropHilite(LPPOINT ppt)
{
    TBINSERTMARK tbim;
    int          iPos;

    // If this is a shortcut we do one thing, if it's anything else we do another
    if (m_fDropShortcut)
    {
        if (m_fInsertMark)
        {
            tbim.iButton = -1;
            tbim.dwFlags = 0;
            ToolBar_SetInsertMark(m_hwndTools, &tbim);
            m_fInsertMark = FALSE;
        }

        if (ppt)
        {
            ScreenToClient(m_hwndTools, ppt);
            ToolBar_InsertMarkHitTest(m_hwndTools, ppt, &tbim);
            ToolBar_SetInsertMark(m_hwndTools, &tbim);
            m_fInsertMark = TRUE;
        }
    }
    else
    {
        // Remove any previous marks
        if (m_idDropHilite)
        {
            ToolBar_MarkButton(m_hwndTools, m_idDropHilite, FALSE);
            m_idDropHilite = 0;
        }
        
        // Hilite the new button
        if (ppt)
        {
            // First check to see if we're over a button or in between
            m_idDropHilite = _GetItemFromPoint(*ppt);
            ToolBar_MarkButton(m_hwndTools, m_idDropHilite, TRUE);
        
#ifdef DEBUG
            FOLDERINFO rInfo;
            FOLDERID   idFolder;

            idFolder = _FolderIdFromCmd(m_idDropHilite);
            if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &rInfo)))
            {
                DOUTL(32, "COutBar::_UpdateDragDropHilite() - Hiliting %s", rInfo.pszName);
                g_pStore->FreeRecord(&rInfo);
            }
#endif
        }
    }
}


FOLDERID COutBar::_FolderIdFromCmd(int idCmd)
{
    TBBUTTON tbb;
    int iPos;

    iPos = (int) SendMessage(m_hwndTools, TB_COMMANDTOINDEX, idCmd, 0);
    ToolBar_GetButton(m_hwndTools, iPos, &tbb);
    return ((FOLDERID) tbb.dwData);
}


//
//  FUNCTION:   COutBar::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE COutBar::DragOver(DWORD grfKeyState, POINTL pt, 
                                            DWORD* pdwEffect)
{
    DWORD   idCur;
    HRESULT hr = E_FAIL;

    // If we don't have a data object from DragEnter, bail
    if (NULL == m_pDataObject)
        return (S_OK);

    // If this is a shortcut we do one thing, if it's anything else we do another
    if (m_fDropShortcut)
    {

        TBINSERTMARK tbim;
        POINT ptTemp = {pt.x, pt.y};
        ScreenToClient(m_hwndTools, &ptTemp);
        ToolBar_InsertMarkHitTest(m_hwndTools, &ptTemp, &tbim);

        if (tbim.iButton != m_tbim.iButton || tbim.dwFlags != m_tbim.dwFlags)
        {
            m_tbim = tbim;
            ptTemp.x = pt.x;
            ptTemp.y = pt.y;
            _UpdateDragDropHilite(&ptTemp);

        }

        if (DROPEFFECT_LINK & *pdwEffect)
            *pdwEffect = DROPEFFECT_LINK;
        else
            *pdwEffect = DROPEFFECT_MOVE;

        return (S_OK);
    }
    else
    {
        // Figure out which item we're over
        POINT ptTemp = {pt.x, pt.y};
        if (-1 == (idCur = _GetItemFromPoint(ptTemp)))
        {
            DOUTL(32, "COutBar::DragOver() - _GetItemFromPoint() returns -1.");
        }

        DOUTL(32, "COutBar::DragOver() - m_idCur = %d, id = %d", m_idCur, idCur);

        // If we're over a new button, then get the drop target for that button
        if (m_idCur != idCur)
        {
            // Release any previous drop target, if any.
            SafeRelease(m_pTargetCur);

            // Update our current object marker
            m_idCur = idCur;

            // Assume error
            m_dwEffectCur = DROPEFFECT_NONE;

            // Update the UI
            _UpdateDragDropHilite(&ptTemp);

            // If we're over a button
            if (m_idCur != -1)
            {
                FOLDERID id = _FolderIdFromCmd(m_idCur);
            
                // Create the drop target object
                m_pTargetCur = new CDropTarget();
                if (m_pTargetCur)
                {
                    hr = m_pTargetCur->Initialize(m_hwnd, id);
                }

                // If we have an initialized drop target, call DragEnter()
                if (SUCCEEDED(hr) && m_pTargetCur)
                {
                    hr = m_pTargetCur->DragEnter(m_pDataObject, grfKeyState, pt, pdwEffect);
                    m_dwEffectCur = *pdwEffect;
                }
            }
            else
            {
                m_dwEffectCur = DROPEFFECT_NONE;
            }
        }
        else
        {
            // No target change, but did the key state change?
            if ((m_grfKeyState != grfKeyState) && m_pTargetCur)
            {
                m_dwEffectCur = *pdwEffect;
                hr = m_pTargetCur->DragOver(grfKeyState, pt, &m_dwEffectCur);
            }
            else
            {
                hr = S_OK;
            }
        }

        *pdwEffect = m_dwEffectCur;
        m_grfKeyState = grfKeyState;
    }


    return (hr);
}
   

//
//  FUNCTION:   COutBar::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT STDMETHODCALLTYPE COutBar::DragLeave(void)
{
    SafeRelease(m_pDataObject);
    SafeRelease(m_pTargetCur);

    _UpdateDragDropHilite(NULL);
    return (S_OK);
}


//
//  FUNCTION:   COutBar::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we 
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.  If this is a copy or move, then
//              we go ahead and update the store.  Otherwise, we bring up
//              a send note with the object attached.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT STDMETHODCALLTYPE COutBar::Drop(IDataObject* pDataObject, 
                                        DWORD grfKeyState, POINTL pt, 
                                        DWORD* pdwEffect)
{
    HRESULT hr = E_FAIL;

    Assert(m_pDataObject == pDataObject);

    if (m_fDropShortcut)
    {
        hr = _AddShortcut(pDataObject);
    }
    else
    {
        if (m_pTargetCur)
        {
            hr = m_pTargetCur->Drop(pDataObject, grfKeyState, pt, pdwEffect);
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
            hr = S_OK;
        }
    }

    _UpdateDragDropHilite(NULL);

    SafeRelease(m_pTargetCur);
    SafeRelease(m_pDataObject);

    return (hr);
}


HRESULT COutBar::_AddShortcut(IDataObject *pObject)
{
    FORMATETC       fe;
    STGMEDIUM       stm;
    FOLDERID       *pidFolder;
    HRESULT         hr = E_UNEXPECTED;
    TBINSERTMARK    tbim;

    if (!pObject)
        return (E_INVALIDARG);

    // Get the data from the data object
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (SUCCEEDED(pObject->GetData(&fe, &stm)))
    {
        pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

        ToolBar_GetInsertMark(m_hwndTools, &tbim);
        _InsertButton(tbim.iButton + tbim.dwFlags, *pidFolder);
        _SaveSettings();
        _EmptyToolbar(TRUE);
        _FillToolbar();
        
        m_pOutBarNotify->Lock(m_hwnd);
        m_pOutBarNotify->DoNotification(WM_RELOADSHORTCUTS, 0, 0, SNF_POSTMSG);
        m_pOutBarNotify->Unlock();
    
        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }
    else
    {
        SETDefFormatEtc(fe, CF_OESHORTCUT, TYMED_HGLOBAL);
        if (SUCCEEDED(pObject->GetData(&fe, &stm)))
        {
            UINT *piPosOld = (UINT *) GlobalLock(stm.hGlobal);
            UINT iPosNew;
            ToolBar_GetInsertMark(m_hwndTools, &tbim);

            iPosNew = tbim.iButton;
            if (tbim.dwFlags & TBIMHT_AFTER)
                iPosNew++;

            TBBUTTON tbb;
            ToolBar_GetButton(m_hwndTools, *piPosOld, &tbb);
            SendMessage(m_hwndTools, TB_INSERTBUTTON, iPosNew, (LPARAM)&tbb);

            if (iPosNew < *piPosOld)
                (*piPosOld)++;
            SendMessage(m_hwndTools, TB_DELETEBUTTON, *piPosOld, 0);

            _SaveSettings();
            _EmptyToolbar(TRUE);
            _FillToolbar();

            m_pOutBarNotify->Lock(m_hwnd);
            m_pOutBarNotify->DoNotification(WM_RELOADSHORTCUTS, 0, 0, SNF_POSTMSG);
            m_pOutBarNotify->Unlock();
    
            GlobalUnlock(stm.hGlobal);
            ReleaseStgMedium(&stm);
        }
    }

    return (hr);
}


HRESULT STDMETHODCALLTYPE COutBar::QueryContinueDrag(BOOL fEscapePressed, 
                                                         DWORD grfKeyState)
    {
    if (fEscapePressed)
        return (DRAGDROP_S_CANCEL);

    if (grfKeyState & MK_RBUTTON)
        return (DRAGDROP_S_CANCEL);
    
    if (!(grfKeyState & MK_LBUTTON))
        return (DRAGDROP_S_DROP);
    
    return (S_OK);    
    }
    
    
HRESULT STDMETHODCALLTYPE COutBar::GiveFeedback(DWORD dwEffect)
    {
    return (DRAGDROP_S_USEDEFAULTCURSORS);
    }

LRESULT CALLBACK COutBar::OutBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COutBar *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (COutBar *) LPCREATESTRUCT(lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
    {
        pThis = (COutBar *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    Assert(pThis);
    return pThis->WndProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CALLBACK COutBar::ExtFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COutBar *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (COutBar *) LPCREATESTRUCT(lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
    {
        pThis = (COutBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    Assert(pThis);
    return pThis->FrameWndProc(hwnd, uMsg, wParam, lParam);
}


LRESULT COutBar::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,   OnLButtonUp);

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
        {
            SendMessage(m_hwndPager, msg, wParam, lParam);
            SendMessage(m_hwndTools, msg, wParam, lParam);
            ResizeBorderDW(NULL, NULL, FALSE);
            return (0);
        }

        case WM_RELOADSHORTCUTS:
        {
            _EmptyToolbar(TRUE);
            _FillToolbar();
            return (0);
        }
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}


LRESULT COutBar::FrameWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_NOTIFY,          Frame_OnNotify);
        HANDLE_MSG(hwnd, WM_SIZE,            Frame_OnSize);
        HANDLE_MSG(hwnd, WM_COMMAND,         Frame_OnCommand);
        HANDLE_MSG(hwnd, WM_NCDESTROY,       Frame_OnNCDestroy);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void COutBar::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    if (!m_fResizing)
    {
        SetCapture(hwnd);
        m_fResizing = TRUE;
    }
}

void COutBar::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT   pt = { x, y };
    RECT    rcClient;

    if (m_fResizing)
    {
        if (pt.x > 32)
        {
            GetClientRect(m_hwndParent, &rcClient);
            m_cxWidth = min(pt.x, rcClient.right - 32);
            ResizeBorderDW(0, 0, FALSE);
        }
    }
}

void COutBar::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    if (m_fResizing)
    {
        ReleaseCapture();
        m_fResizing = FALSE;
    }
}

void COutBar::Frame_OnNCDestroy(HWND hwnd)
{
    SetWindowLong(hwnd, GWLP_USERDATA, NULL);
    m_hwndFrame = m_hwndPager = m_hwndTools = NULL;
}

void COutBar::Frame_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    // When we get resized, we resize our children and update the toolbar button width
    if (m_hwndPager)
    {
        SetWindowPos(m_hwndPager, NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
        SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, MAKELONG(cx, cx));
    }
}

void COutBar::Frame_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    int             iPos;
    TBBUTTONINFO    tbbi;

    if (id < ID_FIRST)
    {
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_LPARAM;
        iPos = (int) SendMessage(m_hwndTools, TB_GETBUTTONINFO, (WPARAM) id, (LPARAM)&tbbi);

        if (iPos >= 0)
            m_pBrowser->BrowseObject((FOLDERID) tbbi.lParam, 0);
    }
}

LRESULT COutBar::Frame_OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr)
{
    if (pnmhdr->code <= PGN_FIRST && pnmhdr->code >= PGN_LAST)
        return SendMessage(m_hwndTools, WM_NOTIFY, 0, (LPARAM) pnmhdr);

    switch (pnmhdr->code)
    {
        case NM_CUSTOMDRAW:
        {
            NMCUSTOMDRAW *pnmcd = (NMCUSTOMDRAW*) pnmhdr;
            
            if (pnmcd->dwDrawStage == CDDS_PREPAINT)
                return CDRF_NOTIFYITEMDRAW;

            if (pnmcd->dwDrawStage == CDDS_ITEMPREPAINT)
            {
                NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
                ptbcd->clrText = GetSysColor(COLOR_WINDOW);
                return CDRF_NEWFONT;
            }
        }
        break;

        case NM_RCLICK:
        {
            if (pnmhdr->hwndFrom == m_hwndTools)
            {
                DWORD dwPos = GetMessagePos();
                _OnContextMenu(GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));
                return 1;
            }
        }

        case TBN_DRAGOUT:
        {
            NMTOOLBAR *pnmtb = (NMTOOLBAR *) pnmhdr;
            DWORD      dwEffect = DROPEFFECT_NONE;
            UINT       id = ToolBar_CommandToIndex(m_hwndTools, pnmtb->iItem);

            // Create a new data object
            CShortcutDataObject *pDataObj = new CShortcutDataObject(id);
            if (pDataObj)
            {
                DoDragDrop(pDataObj, (IDropSource *) this, DROPEFFECT_MOVE, &dwEffect);
                pDataObj->Release();
            }

            return 0;
        }
    }

    return (FALSE);
}


HRESULT COutBar::_CreateToolbar()
{
    HIMAGELIST      himl, himlOld;
    LRESULT         lButtonSize;
    RECT            rc;
    int             iButtonWidth = 70;
    TCHAR           szName[CCHMAX_STRINGRES];

    // Create the frame window
    m_hwndFrame = CreateWindowEx(WS_EX_CLIENTEDGE, s_szOutBarFrameClass, NULL,
                                 WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                 0, 0, 0, 0, m_hwnd, (HMENU) IDC_FRAME, g_hInst, this);
    if (!m_hwndFrame)
        return E_FAIL;

    // Create the pager
    m_hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL, 
                                 WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | PGS_VERT | PGS_DRAGNDROP,
                                 0, 0, 0, 0, m_hwndFrame, (HMENU) IDC_PAGER, g_hInst, NULL);
    if (!m_hwndPager)
        return E_FAIL;

    ZeroMemory(szName, ARRAYSIZE(szName));
    LoadString(g_hLocRes, idsOutlookBar, szName, ARRAYSIZE(szName));

    // Create the toolbar
    m_hwndTools = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, szName, 
                                 WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | 
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN  | CCS_NORESIZE | CCS_VERT,
                                 0, 0, 0, 0, m_hwndPager, (HMENU) IDC_TOOLBAR, g_hInst, NULL);
    if (!m_hwndTools)
        return E_FAIL;

    // This tells the toolbar what version we are
    SendMessage(m_hwndTools, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    _FillToolbar(); 
    _SetButtonStyle(!m_fLarge);

    SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, MAKELONG(0, m_cxWidth));

    m_pStNotify->Register(m_hwnd, g_hwndInit, FALSE);
    SendMessage(m_hwndPager, PGM_SETCHILD, 0, (LPARAM)m_hwndTools);

    // Let's try this
    COLORSCHEME cs;
    cs.dwSize = sizeof(COLORSCHEME);
    cs.clrBtnHighlight = GetSysColor(COLOR_3DFACE);
    cs.clrBtnShadow = GetSysColor(COLOR_WINDOWFRAME);

    SendMessage(m_hwndTools, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);

    return S_OK;
}

void COutBar::_FillToolbar()
{
    if (FAILED(_LoadSettings()))
        _CreateDefaultButtons();
    SendMessage(m_hwndPager, PGM_RECALCSIZE, 0, 0L);
}

void COutBar::_EmptyToolbar(BOOL fDelete)
{
    if (fDelete)
        while (SendMessage(m_hwndTools, TB_DELETEBUTTON, 0, 0))
            ;
}

BOOL COutBar::_FindButton(int *piBtn, LPITEMIDLIST pidl)
{
    BOOL        fFound = FALSE;
#if 0
        int         iBtn, cBtn, iCmp;
    TBBUTTON    tbb;

    Assert(pidl);

    cBtn = (int)SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0L);

    // skip the root, so start at index 1
    for (iBtn = 1; iBtn < cBtn; iBtn++)
    {
        if (SendMessage(m_hwndTools, TB_GETBUTTON, iBtn, (LPARAM)&tbb))
        {
            Assert(tbb.dwData);
            iCmp = ShortFromResult(m_pShellFolder->CompareIDs(0, pidl, (LPITEMIDLIST)(tbb.dwData)));
            if (iCmp <= 0)
            {
                fFound = (iCmp == 0);    
                break;
            }
        }
    }
    *piBtn = iBtn;
#endif
    return fFound;
}

BOOL COutBar::_InsertButton(int index, FOLDERINFO *pInfo)
{
    TBBUTTON tbb;
    TCHAR    szName[2 * MAX_PATH];
    LPTSTR   pszFree = NULL;
    BOOL     fRet;

    tbb.fsState     = TBSTATE_ENABLED | TBSTATE_WRAP;
    tbb.fsStyle     = TBSTYLE_BUTTON | TBSTYLE_NOPREFIX;
    tbb.idCommand   = m_idCommand++;
    tbb.dwData      = (DWORD_PTR) pInfo->idFolder;
    tbb.iBitmap     = GetFolderIcon(pInfo);
    tbb.iString     = (INT_PTR) pInfo->pszName;

    if (pInfo->cUnread)
    {
        if (lstrlen(pInfo->pszName) + 13 < ARRAYSIZE(szName))
            tbb.iString = (INT_PTR)szName;
        else
        {
            if (!MemAlloc((LPVOID*) &pszFree, (lstrlen(pInfo->pszName) + 14) * sizeof(TCHAR)))
                return FALSE;
            tbb.iString = (INT_PTR)pszFree;
        }
        wsprintf((LPTSTR)tbb.iString, "%s (%d)", pInfo->pszName, CUnread(pInfo));
    }

    // Check to see if we're inserting at the end
    if (index == -1)
    {
        index = ToolBar_ButtonCount(m_hwndTools);
    }

    // insert the root
    fRet = (BOOL)SendMessage(m_hwndTools, TB_INSERTBUTTON, index, (LPARAM)&tbb);
    SafeMemFree(pszFree);
    return fRet;
}

BOOL COutBar::_InsertButton(int iIndex, FOLDERID id)
{
    FOLDERINFO rInfo = {0};

    if (SUCCEEDED(g_pStore->GetFolderInfo(id, &rInfo)))
    {
        _InsertButton(iIndex, &rInfo);
        g_pStore->FreeRecord(&rInfo);
    }

    return (TRUE);
}

BOOL COutBar::_DeleteButton(int iBtn)
{
    TBBUTTON tbb;

    if (SendMessage(m_hwndTools, TB_GETBUTTON, iBtn, (LPARAM)&tbb))
    {
        if (SendMessage(m_hwndTools, TB_DELETEBUTTON, iBtn, 0L))
        {
            _SaveSettings();
            m_pOutBarNotify->Lock(m_hwnd);
            m_pOutBarNotify->DoNotification(WM_RELOADSHORTCUTS, 0, 0, SNF_POSTMSG);
            m_pOutBarNotify->Unlock();
            return (TRUE);
        }
    }
    return FALSE;
}

BOOL COutBar::_UpdateButton(int iBtn, LPITEMIDLIST pidl)
{
#if 0
        TBBUTTON        tbb;
    TBBUTTONINFO    tbbi;
    TCHAR           szName[2 * MAX_PATH];
    LPTSTR          pszFree = NULL;
    BOOL            fRet = FALSE;

    if (SendMessage(m_hwndTools, TB_GETBUTTON, iBtn, (LPARAM)&tbb))
    {
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_TEXT | TBIF_IMAGE | TBIF_LPARAM;
        tbbi.iImage = FIDL_ICONID(pidl);
        tbbi.lParam = (DWORD)pidl;
        if (FIDL_UNREAD(pidl))
        {
            if (lstrlen(FIDL_NAME(pidl)) + 13 < ARRAYSIZE(szName))
                tbbi.pszText = szName;
            else
            {
                if (!MemAlloc((LPVOID*)&pszFree, (lstrlen(FIDL_NAME(pidl)) + 14) * sizeof(TCHAR)))
                    return FALSE;
                tbbi.pszText = pszFree;
            }
            wsprintf(tbbi.pszText, "%s (%d)", FIDL_NAME(pidl), FIDL_UNREAD(pidl));
        }
        else
            tbbi.pszText = FIDL_NAME(pidl);
        fRet = SendMessage(m_hwndTools, TB_SETBUTTONINFO, (WPARAM)tbb.idCommand, (LPARAM)&tbbi);
        if (tbb.dwData)
            PidlFree((LPITEMIDLIST)(tbb.dwData));
        if (pszFree)
            MemFree(pszFree);
    }
    return fRet;
#endif 
    return 0;
}

#if 0
void COutBar::_OnFolderNotify(FOLDERNOTIFY *pnotify)
{
    LPITEMIDLIST pidl;
    int          iBtn;
    BOOL         fRecalc = FALSE;

    Assert(pnotify != NULL);
    Assert(pnotify->pidlNew != NULL);

    switch (pnotify->msg)
    {
    case NEW_FOLDER:
        // only insert if it is a root level pidl
        if (0 == NEXTID(pnotify->pidlNew)->mkid.cb)
        {
            // check for dups and figure out where to insert
            if (!FindButton(&iBtn, pnotify->pidlNew))
            {
                if (pidl = PidlDupIdList(pnotify->pidlNew))
                    fRecalc = InsertButton(iBtn, pidl);
            }
        }
        break ;

    case DELETE_FOLDER:
        // only look for it if it is a root level pidl
        if (0 == NEXTID(pnotify->pidlNew)->mkid.cb)
        {
            if (FindButton(&iBtn, pnotify->pidlNew))
                fRecalc = DeleteButton(iBtn);
        }
        break ;

    case RENAME_FOLDER:
    case MOVE_FOLDER:
        // only look for it if it is a root level pidl
        if (0 == NEXTID(pnotify->pidlOld)->mkid.cb)
        {
            if (FindButton(&iBtn, pnotify->pidlOld))
                fRecalc = DeleteButton(iBtn);
        }
        // only insert if it is a root level pidl
        if (0 == NEXTID(pnotify->pidlNew)->mkid.cb)
        {
            // check for dups and figure out where to insert
            if (!FindButton(&iBtn, pnotify->pidlNew))
            {
                if (pidl = PidlDupIdList(pnotify->pidlNew))
                    fRecalc = InsertButton(iBtn, pidl);
            }
        }
        break ;

    case UNREAD_CHANGE:
    case UPDATEFLAG_CHANGE:
        // only look for it if it is a root level pidl
        if (0 == NEXTID(pnotify->pidlNew)->mkid.cb)
        {
            // check for dups and figure out where to insert
            if (FindButton(&iBtn, pnotify->pidlNew))
            {
                if (pidl = PidlDupIdList(pnotify->pidlNew))
                    UpdateButton(iBtn, pidl);
            }
        }
        break ;

    case IMAPFLAG_CHANGE:
        // don't care
        break ;

    case FOLDER_PROPS_CHANGED:
        //Don't care
        break ;
    default:
        AssertSz(FALSE, "Unhandled CFolderCache notification!");
        break;
    }

    if (fRecalc)
        SendMessage(m_hwndPager, PGM_RECALCSIZE, 0, 0L);

}

#endif

//
//  FUNCTION:   COutBar::_OnContextMenu
//
//  PURPOSE:    If the WM_CONTEXTMENU message is generated from the keyboard
//              then figure out a pos to invoke the menu.  Then dispatch the
//              request to the handler.
//
//  PARAMETERS:
//      hwnd      - Handle of the view window.
//      hwndClick - Handle of the window the user clicked in.
//      x, y      - Position of the mouse click in screen coordinates.
//
void COutBar::_OnContextMenu(int x, int y)
{
    HRESULT             hr;
    HMENU               hMenu;
    int                 id = 0;
    int                 i;
    POINT               pt = { x, y };
    TBBUTTON            tbb;

    // Figure out where the click was
    ScreenToClient(m_hwndTools, &pt);
    i = ToolBar_HitTest(m_hwndTools, &pt);

    // If the click was on a button, then bring up the item context menu
    if (i >= 0)
    {
        // Get the button info
        SendMessage(m_hwndTools, TB_GETBUTTON, i, (LPARAM) &tbb);

        // Load the context menu
        hMenu = LoadPopupMenu(IDR_OUTLOOKBAR_ITEM_POPUP);
        if (!hMenu)
            return;

        // Mark the button
        SendMessage(m_hwndTools, TB_SETSTATE, (WPARAM)tbb.idCommand, (LPARAM)(TBSTATE_ENABLED | TBSTATE_WRAP | TBSTATE_MARKED));
        m_idSel = tbb.idCommand;

        // If this is the deleted items folder, add the "empty" menu item
        TBBUTTONINFO    tbbi;

        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_LPARAM;
        if (-1 != SendMessage(m_hwndTools, TB_GETBUTTONINFO, (WPARAM) m_idSel, (LPARAM)&tbbi))
        {
            FOLDERINFO rInfo;

            if (SUCCEEDED(g_pStore->GetFolderInfo((FOLDERID) tbbi.lParam, &rInfo)))
            {
                if (rInfo.tySpecial != FOLDER_DELETED)
                {
                    DeleteMenu(hMenu, ID_EMPTY_WASTEBASKET, MF_BYCOMMAND);
                }

                g_pStore->FreeRecord(&rInfo);
            }
        }

        // Do the enable-disable thing
        MenuUtil_EnablePopupMenu(hMenu, this);

        // Display the context menu
        id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
                              x, y, m_hwnd, NULL);

        // Unmark the button
        SendMessage(m_hwndTools, TB_SETSTATE, (WPARAM)tbb.idCommand, (LPARAM)(TBSTATE_ENABLED | TBSTATE_WRAP));

        // See if the user chose a menu item
        if (id != 0)
        {
            Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        m_idSel = -1;

        // Clean this up
        DestroyMenu(hMenu);
    }

    // Else if the click was in the empty space, show the bar context menu
    else
    {
        // Load the context menu
        hMenu = LoadPopupMenu(IDR_OUTLOOKBAR_POPUP);
        if (!hMenu)
            return;

        // Do the enable-disable thing
        MenuUtil_EnablePopupMenu(hMenu, this);

        // Display the context menu
        id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
                              x, y, m_hwnd, NULL);

        // See if the user chose a menu item
        if (id != 0)
        {
            Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        // Clean this up
        DestroyMenu(hMenu);
    }

}


HRESULT COutBar::_CreateDefaultButtons()
{
    IEnumerateFolders *pEnum = NULL;
    FOLDERINFO         rFolder;
    UINT               iIndex = 0;
    FOLDERID           idFolderDefault;

    // Figure out the default server first
    if (FAILED(GetDefaultServerId(ACCT_MAIL, &idFolderDefault)))
        idFolderDefault = FOLDERID_LOCAL_STORE;


    if (!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        // Inbox first
        if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idFolderDefault, FOLDER_INBOX, &rFolder)))
        {
            _InsertButton(iIndex++, &rFolder);
            g_pStore->FreeRecord(&rFolder);
        }
    }
    // Outbox
    if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_OUTBOX, &rFolder)))
    {
        _InsertButton(iIndex++, &rFolder);
        g_pStore->FreeRecord(&rFolder);
    }

    // Sent Items
    if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idFolderDefault, FOLDER_SENT, &rFolder)))
    {
        _InsertButton(iIndex++, &rFolder);
        g_pStore->FreeRecord(&rFolder);
    }

    // Deleted
    if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_DELETED, &rFolder)))
    {
        _InsertButton(iIndex++, &rFolder);
        g_pStore->FreeRecord(&rFolder);
    }

    // Drafts
    if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idFolderDefault, FOLDER_DRAFT, &rFolder)))
    {
        _InsertButton(iIndex++, &rFolder);
        g_pStore->FreeRecord(&rFolder);
    }

    // Save at this point so everyone will be in sync
    _SaveSettings();

    return (S_OK);
}


HRESULT COutBar::_LoadSettings(void)
{
    BAR_PERSIST_INFO *pPersist = NULL;
    HRESULT           hr = E_FAIL;
    DWORD             iIndex = 0;
    FOLDERINFO        rInfo;
    UINT              i;

    // Load the settings
    if (FAILED(hr = OutlookBar_LoadSettings(&pPersist)))
        goto exit;

    // Load the bar from the saved folder ID's
    for (i = 0; i < pPersist->cItems; i++)
    {
        // Get the folder info for this folder
        if (SUCCEEDED(g_pStore->GetFolderInfo(pPersist->rgFolders[i], &rInfo)))
        {
            if (_InsertButton(iIndex, &rInfo))
                iIndex++;

            g_pStore->FreeRecord(&rInfo);
        }
    }

    // If the bar is empty, and the user didn't save it empty, use the defaults
    if (iIndex == 0 && pPersist->cItems)
        hr = E_FAIL;
    else
        hr = S_OK;

    // Also restore the width while we're at it
    if (pPersist->cxWidth >= 28)
    {
        m_cxWidth = pPersist->cxWidth;
    }

    if (m_fOnce)
    {
        m_fLarge = !pPersist->fSmall;
        m_fOnce = FALSE;
    }    

exit:
    SafeMemFree(pPersist);

    return (hr);
}


HRESULT COutBar::_SaveSettings(void)
{
    BAR_PERSIST_INFO *pPersist = NULL;
    DWORD             cbData;
    DWORD             iIndex = 0;
    FOLDERINFO        rInfo;
    UINT              i;
    DWORD             cButtons;
    TBBUTTON          tbb;
    RECT              rcClient;

    // Get the count of buttons from the outlook bar
    cButtons = (DWORD) SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0);

    // Allocate a persist info struct big enough for everything
    cbData = sizeof(BAR_PERSIST_INFO) + ((cButtons - 1) * sizeof(FOLDERID));
    if (!MemAlloc((LPVOID *) &pPersist, cbData))
        return (E_OUTOFMEMORY);

    // Fill in the persist info
    pPersist->dwVersion = GetOutlookBarVersion();
    pPersist->cItems = cButtons;
    pPersist->fSmall = !m_fLarge;
    pPersist->ftSaved.dwHighDateTime = 0;
    pPersist->ftSaved.dwLowDateTime = 0;    

    GetClientRect(m_hwnd, &rcClient);
    pPersist->cxWidth = rcClient.right;

    // Loop through the buttons on the toolbar and get the info from each
    for (i = 0; i < cButtons; i++)
    {
        SendMessage(m_hwndTools, TB_GETBUTTON, i, (LPARAM) &tbb);
        pPersist->rgFolders[i] = (FOLDERID) tbb.dwData;
    }

    // Now open the registry and save the blob
    AthUserSetValue(NULL, GetRegKey(), REG_BINARY, (const LPBYTE) pPersist, cbData);
    
    // Free up the struct
    SafeMemFree(pPersist);

    return (S_OK);
}

HRESULT COutBar::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    BOOL        fSpecial = FALSE;
    BOOL        fServer = FALSE;
    BOOL        fRoot = FALSE;
    BOOL        fNews = FALSE;
    BOOL        fIMAP = FALSE;
    FOLDERINFO  rFolder = {0};
    FOLDERID    idFolder = FOLDERID_INVALID;

    if (m_idSel != -1)
    {
        // Get the ID of the folder that is selected
        TBBUTTONINFO    tbbi;

        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_LPARAM;
        if (-1 == SendMessage(m_hwndTools, TB_GETBUTTONINFO, (WPARAM) m_idSel, (LPARAM)&tbbi))
            return (E_UNEXPECTED);

        // Get the Folder Info
        idFolder = (FOLDERID) tbbi.lParam;
        if (FAILED(g_pStore->GetFolderInfo(idFolder, &rFolder)))
            return (E_UNEXPECTED);

        // Break some of this down for readability
        fSpecial = rFolder.tySpecial != FOLDER_NOTSPECIAL;
        fServer = rFolder.dwFlags & FOLDER_SERVER;
        fRoot = FOLDERID_ROOT == idFolder;
        fNews = rFolder.tyFolder == FOLDER_NEWS;
        fIMAP = rFolder.tyFolder == FOLDER_IMAP;
    }

    // Loop through the commands in the prgCmds array looking for ones that haven't been handled
    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN_FOLDER:
                case ID_REMOVE_SHORTCUT:
                case ID_NEW_SHORTCUT:
                case ID_HIDE:
                case ID_FIND_MESSAGE:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_LARGE_ICONS:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    if (m_fLarge)
                        prgCmds[i].cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_SMALL_ICONS:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    if (!m_fLarge)
                        prgCmds[i].cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_RENAME_SHORTCUT:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_PROPERTIES:
                {
                    Assert(idFolder != FOLDERID_INVALID);

                    prgCmds[i].cmdf |= OLECMDF_SUPPORTED;

                    // Everything except the root and the personal folders node
                    if (!fRoot && ((fServer && (fNews || fIMAP)) || !fServer))
                        prgCmds[i].cmdf |= OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    break;
                }

                case ID_EMPTY_WASTEBASKET:
                {
                    if (rFolder.cMessages > 0 || FHasChildren(&rFolder, SUBSCRIBED))
                        prgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;
                    break;
                }
            }
        }
    }

    g_pStore->FreeRecord(&rFolder);
    return (S_OK);
}


HRESULT COutBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TBBUTTONINFO    tbbi = { 0 };
    FOLDERID        id = FOLDERID_INVALID;
    int             iPos = -1;

    // Get the ID of the folder that was selected
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM;
    tbbi.lParam = 0;
    if (-1 != (iPos = (int) SendMessage(m_hwndTools, TB_GETBUTTONINFO, m_idSel, (LPARAM) &tbbi)))
    {
        id = (FOLDERID) tbbi.lParam;
    }

    switch (nCmdID)
    {
        case ID_OPEN_FOLDER:
        {
            if (id != FOLDERID_INVALID)
                m_pBrowser->BrowseObject((FOLDERID) tbbi.lParam, 0);

            return (S_OK);
        }

        case ID_REMOVE_SHORTCUT:
        {
            _DeleteButton(iPos);
            return (S_OK);
        }

        case ID_RENAME_SHORTCUT:
            break;

        case ID_PROPERTIES:
        {
            if (id != FOLDERID_INVALID)
                MenuUtil_OnProperties(m_hwndParent, id);
            
            return (S_OK);
        }

        case ID_LARGE_ICONS:
        case ID_SMALL_ICONS:
        {
            _SetButtonStyle(nCmdID == ID_SMALL_ICONS);
            return (S_OK);
        }

        case ID_NEW_SHORTCUT:
        {
            FOLDERID idFolderDest;
            HRESULT  hr;

            hr = SelectFolderDialog(m_hwnd, SFD_SELECTFOLDER, FOLDERID_ROOT, 
                                    FD_NONEWFOLDERS, (LPCTSTR) idsNewShortcutTitle,
                                    (LPCTSTR) idsNewShortcutCaption, &idFolderDest);
            if (SUCCEEDED(hr))
            {
                OutlookBar_AddShortcut(idFolderDest);
            }

            return (S_OK);
        }

        case ID_HIDE:
        {
            if (m_pBrowser)
            {
                m_pBrowser->SetViewLayout(DISPID_MSGVIEW_OUTLOOK_BAR, LAYOUT_POS_NA, FALSE, 0, 0);
            }

            return (S_OK);
        }

        case ID_EMPTY_WASTEBASKET:
        {
            if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsWarnEmptyDeletedItems),
                NULL, MB_YESNO | MB_DEFBUTTON2) == IDYES)
            {
                EmptyFolder(m_hwnd, id);
            }
            return (S_OK);
        }

        case ID_FIND_MESSAGE:
        {
            DoFindMsg(id, 0);
            return (S_OK);
        }
    }

    return (OLECMDERR_E_NOTSUPPORTED);
}


BOOL COutBar::_SetButtonStyle(BOOL fSmall)
{
    LONG lStyle;
    SIZE s1, s2;

    // Get the current style
    lStyle = (LONG) SendMessage(m_hwndTools, TB_GETSTYLE, 0, 0);
    
    // Make sure we have the right image list loaded
    if (fSmall && !m_himlSmall)
    {
        // Load the image list for the toolbar
        m_himlSmall = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
        if (!m_himlSmall)
            return FALSE;
    }

    if (!fSmall && !m_himlLarge)
    {
        // Load the image list for the toolbar
        m_himlLarge = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
        if (!m_himlLarge)
            return FALSE;
    }

    // Get the size
    RECT rc;
    GetClientRect(m_hwndTools, &rc);

    NMPGCALCSIZE nm;
    nm.hdr.code = PGN_CALCSIZE;
    nm.dwFlag = PGF_CALCHEIGHT;
    nm.iWidth = 0;
    nm.iHeight = 0;

    SendMessage(m_hwndTools, WM_NOTIFY, 0, (LPARAM) &nm);

    // Now swap styles
    if (fSmall)
    {
        lStyle |= TBSTYLE_LIST;
        SendMessage(m_hwndTools, TB_SETSTYLE, 0, lStyle);
        SendMessage(m_hwndTools, TB_SETBITMAPSIZE, 0, MAKELONG(16, 16));
        SendMessage(m_hwndTools, TB_SETIMAGELIST, 0, (LPARAM) m_himlSmall);
        SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, 1, 0L);
        SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, MAKELONG(rc.right, rc.right));
    }
    else
    {
        lStyle &= ~TBSTYLE_LIST;
        SendMessage(m_hwndTools, TB_SETSTYLE, 0, lStyle);        
        SendMessage(m_hwndTools, TB_SETIMAGELIST, 0, (LPARAM) m_himlLarge);
        SendMessage(m_hwndTools, TB_SETBITMAPSIZE, 0, MAKELONG(32, 32));
        SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, 2, 0L);
        SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, MAKELONG(rc.right, rc.right));
    }

    PostMessage(m_hwndPager, PGM_RECALCSIZE, 0, 0L);
    InvalidateRect(m_hwndTools, NULL, TRUE);
    m_fLarge = !fSmall;
    
    return (TRUE);
}


HRESULT OutlookBar_AddShortcut(FOLDERID idFolder)
{
    HRESULT           hr;
    BAR_PERSIST_INFO *pPersist = NULL;
    DWORD             cbData = 0;
    INotify          *pNotify = NULL;

    // Load the current settings out of the registry.  If it fails, that means
    // we've never saved our settings before.  
    if (SUCCEEDED(hr = OutlookBar_LoadSettings(&pPersist)))
    {        
        // Get the size of the current struct and add room for a new folder
        cbData = sizeof(BAR_PERSIST_INFO) + (pPersist->cItems * sizeof(FOLDERID));

        // Realloc the structure
        if (MemRealloc((LPVOID *) &pPersist, cbData))
        {
            // Add our new button to the end
            pPersist->rgFolders[pPersist->cItems] = idFolder;
            pPersist->cItems++;

            // Save the new settings out
            if (SUCCEEDED(OutlookBar_SaveSettings(pPersist, cbData)))
            {
                // Send notifications
                if (SUCCEEDED(CreateNotify(&pNotify)))
                {
                    if (SUCCEEDED(pNotify->Initialize(c_szOutBarNotifyName)))
                    {
                        pNotify->Lock(NULL);
                        pNotify->DoNotification(WM_RELOADSHORTCUTS, 0, 0, SNF_POSTMSG);
                        pNotify->Unlock();
                    }

                    pNotify->Release();
                }
            }
        }

        SafeMemFree(pPersist);
    }

    return (hr);
}


HRESULT OutlookBar_LoadSettings(BAR_PERSIST_INFO **ppPersist)
{
    HKEY              hKey = 0;
    LONG              lResult;
    DWORD             dwType;
    BAR_PERSIST_INFO *pPersist = NULL;
    DWORD             cbData;
    HRESULT           hr = E_FAIL;

    if (!ppPersist)
        return (E_INVALIDARG);

    // Get the reg key for this user
    if (ERROR_SUCCESS != AthUserOpenKey(NULL, KEY_READ, &hKey))
        return (hr);

    // Get the size of the blob in the registry
    lResult = RegQueryValueEx(hKey, COutBar::GetRegKey(), 0, &dwType, NULL, &cbData);
    if (ERROR_SUCCESS != lResult)
        goto exit;
    
    // Allocate a buffer for the blob in the registry
    if (!MemAlloc((LPVOID *) &pPersist, cbData + 1))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Now get the data from the registry    
    lResult = RegQueryValueEx(hKey, COutBar::GetRegKey(), 0, &dwType, (LPBYTE) pPersist, &cbData);
    if (ERROR_SUCCESS != lResult)
        goto exit;

    // Check to see if this version matches our version
    if (pPersist->dwVersion != COutBar::GetOutlookBarVersion())
        goto exit;

    // Check to see if the saved time is valid
    // $REVIEW - How?

    // Double check that the size is correct
    if (cbData != (sizeof(BAR_PERSIST_INFO) + ((pPersist->cItems - 1) * sizeof(FOLDERID))))
        goto exit;

    hr = S_OK;

exit:
    if (hKey)
        RegCloseKey(hKey);

    if (FAILED(hr))
        SafeMemFree(pPersist);

    *ppPersist = pPersist;
    return (hr);
}


HRESULT OutlookBar_SaveSettings(BAR_PERSIST_INFO *pPersist, DWORD cbData)
{
    // Open the registry and save the blob
    AthUserSetValue(NULL, COutBar::GetRegKey(), REG_BINARY, (const LPBYTE) pPersist, cbData);

    return (S_OK);
}


HRESULT COutBar::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB)
{
    TRANSACTIONTYPE     tyTransaction;
    ORDINALLIST         Ordinals;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    DWORD               cButtons;
    TBBUTTON            tbb;
    TCHAR               szName[2 * MAX_PATH];
    LPTSTR              pszFree = NULL;
    BOOL                fChanged;
    INDEXORDINAL        iIndex;
    TBBUTTONINFO        tbbi;
    int                 iButton;

    if (!IsWindow(m_hwnd))
        return (S_OK);

    // Get the number of buttons on our bar
    cButtons = (DWORD) SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0);

    // Walk through the notifications
    while (hTransaction)
    {
        // Get Transact
        if (FAILED(pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals)))
            break;

        // Delete
        if (TRANSACTION_DELETE == tyTransaction)
        {
            for (iButton = cButtons - 1; iButton >= 0; iButton--)
            {
                // Get the button information
                ToolBar_GetButton(m_hwndTools, iButton, &tbb);

                // If the ID of this button matches the ID that changed
                if ((FOLDERID) tbb.dwData == Folder1.idFolder)
                {
                    // Blow it away
                    SendMessage(m_hwndTools, TB_DELETEBUTTON, iButton, 0);
                }
            }
        }
        
        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Loop through all our buttons since we might have dupes
            for (iButton = cButtons - 1; iButton >= 0; iButton--)
            {
                fChanged = FALSE;
            
                // Get the button information
                ToolBar_GetButton(m_hwndTools, iButton, &tbb);

                // If the ID of this button matches the ID that changed
                if ((FOLDERID) tbb.dwData == Folder1.idFolder)
                {                    
                    tbbi.cbSize = sizeof(TBBUTTONINFO);
                    tbbi.dwMask = TBIF_TEXT | TBIF_IMAGE;
                    tbbi.pszText = szName;
                    tbbi.cchText = ARRAYSIZE(szName);

                    ToolBar_GetButtonInfo(m_hwndTools, tbb.idCommand, &tbbi);

                    // Unread Change || Folder Renamed
                    if (Folder1.cUnread != Folder2.cUnread || 
                        lstrcmp(Folder1.pszName, Folder2.pszName) != 0)
                    {
                        if (Folder2.cUnread)
                        {
                            if (lstrlen(Folder2.pszName) + 13 < ARRAYSIZE(szName))
                                tbbi.pszText = szName;
                            else
                            {
                                if (!MemAlloc((LPVOID*) &pszFree, (lstrlen(Folder2.pszName) + 14) * sizeof(TCHAR)))
                                    return FALSE;
                                tbbi.pszText = pszFree;
                            }
                            wsprintf(tbbi.pszText, "%s (%d)", Folder2.pszName, CUnread(&Folder2));
                        }
                        else
                        {
                            tbbi.pszText = Folder2.pszName;
                        }

                        fChanged = TRUE;
                    }

                    // synchronize state changed ?
                    if ((0 == (Folder1.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL))) ^
                        (0 == (Folder2.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL))))
                    {
                        tbbi.iImage = GetFolderIcon(&Folder2);
                        fChanged = TRUE;
                    }

                    if (ISFLAGSET(Folder1.dwFlags, FOLDER_SUBSCRIBED) != ISFLAGSET(Folder2.dwFlags, FOLDER_SUBSCRIBED))
                    {
                        if (ISFLAGSET(Folder2.dwFlags, FOLDER_SUBSCRIBED))
                        {
                            tbbi.iImage = GetFolderIcon(&Folder2);
                            fChanged = TRUE;
                        }
                        else
                        {
                            SendMessage(m_hwndTools, TB_DELETEBUTTON, iButton, 0);
                            fChanged = FALSE;
                        }
                    }
                }

                if (fChanged)
                {
                    ToolBar_SetButtonInfo(m_hwndTools, tbb.idCommand, &tbbi);
                }
                SafeMemFree(pszFree);
            }
        }
    }

    pDB->FreeRecord(&Folder1);
    pDB->FreeRecord(&Folder2);

    return (S_OK);
}

BOOL COutBar::_IsTempNewsgroup(IDataObject *pObject)
{
    FORMATETC       fe;
    STGMEDIUM       stm;
    FOLDERID       *pidFolder;
    FOLDERINFO      rInfo;
    BOOL            fReturn = TRUE;

    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (SUCCEEDED(pObject->GetData(&fe, &stm)))
    {
        pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

        if (SUCCEEDED(g_pStore->GetFolderInfo(*pidFolder, &rInfo)))
        {
            if ((rInfo.tySpecial == FOLDER_NOTSPECIAL) && 
                (rInfo.tyFolder == FOLDER_NEWS) &&
                (0 == (rInfo.dwFlags & FOLDER_SUBSCRIBED)))
            {
                fReturn = FALSE;
            }

            g_pStore->FreeRecord(&rInfo);
        }

        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }

    return (fReturn);
}

LPCTSTR  COutBar::GetRegKey()
{
    LPCTSTR      retval;

    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        retval = c_szRegOutlookBarNewsOnly;
    }
    else
    {
        retval = c_szRegOutlookBar;
    }

    return retval;
}

DWORD   COutBar::GetOutlookBarVersion()
{
    DWORD   retval;

    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        retval = OUTLOOK_BAR_NEWSONLY_VERSION;
    }
    else
    {
        retval = OUTLOOK_BAR_VERSION;
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\passdlg.h ===
// =====================================================================================
// P A S S D L G . C P P
// =====================================================================================
#ifndef __PASSDLG_H
#define __PASSDLG_H

// =====================================================================================
// Resource Ids
// =====================================================================================
#define IDS_SERVER                      1000    
#define IDE_PASSWORD                    1001
#define IDS_MESSAGE                     1003
#define IDCH_REMEMBER                   1004
#define IDC_STATIC                      -1
#define IDE_ACCOUNT                     1008

typedef struct tagPASSINFO
{
    TCHAR           szTitle[50];
    LPTSTR          lpszPassword;
    ULONG           cbMaxPassword;
    LPTSTR          lpszAccount;
    ULONG           cbMaxAccount;
    LPTSTR          lpszServer;
    BOOL            fRememberPassword;
    DWORD           fAlwaysPromptPassword;
} PASSINFO, *LPPASSINFO;


// Forward Declarations
typedef struct INETSERVER *LPINETSERVER;

// =====================================================================================
// Prototypes
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo);
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd);

#endif // __PASSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\password.h ===
// ========================================================================
// Password Handling API
// ========================================================================
#ifndef __PASSWORD_H
#define __PASSWORD_H

HRESULT HrLoadPassword (HKEY hReg, LPTSTR lpszRegKey, LPTSTR lpszPass, ULONG *pcbPass);
HRESULT HrSavePassword (HKEY hReg, LPTSTR lpszRegKey, LPTSTR lpszPass, ULONG cbPass);

#endif __PASSWORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\outbar.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     outbar.h
//
//  PURPOSE:    Defines the class that implements the Outlook Bar
//


#pragma once


interface IAthenaBrowser;
interface INotify;
typedef struct tagFOLDERNOTIFY FOLDERNOTIFY;
class CDropTarget;

/////////////////////////////////////////////////////////////////////////////
//
// Types 
//

#define OUTLOOK_BAR_VERSION             0x0001
#define OUTLOOK_BAR_NEWSONLY_VERSION    0X0001

typedef struct tagBAR_PERSIST_INFO 
{
    DWORD       dwVersion;
    DWORD       cxWidth;
    BOOL        fSmall;
    DWORD       cItems;
    FILETIME    ftSaved;
    FOLDERID    rgFolders[1];
} BAR_PERSIST_INFO;


HRESULT OutlookBar_AddShortcut(FOLDERID idFolder);


/////////////////////////////////////////////////////////////////////////////
// class COutBar
//
class COutBar : public IDockingWindow, 
                public IObjectWithSite, 
                public IOleCommandTarget,
                public IDropTarget,
                public IDropSource,
                public IDatabaseNotify
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    COutBar();
    ~COutBar();

    HRESULT HrInit(LPSHELLFOLDER psf, IAthenaBrowser *psb);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IOleWindow
    //
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow
    //
    STDMETHODIMP ShowDW(BOOL fShow);
    STDMETHODIMP CloseDW(DWORD dwReserved);
    STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite,
                                BOOL fReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite
    //
    STDMETHODIMP SetSite(IUnknown* punkSite);
    STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                             OLECMDTEXT *pCmdText); 
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                      VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // IDropTarget
    //
    STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                           POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState,
                      POINTL pt, DWORD* pdwEffect);

    /////////////////////////////////////////////////////////////////////////
    // IDropSource
    //
    STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHODIMP GiveFeedback(DWORD dwEffect);

    /////////////////////////////////////////////////////////////////////////
    // IDatabaseNotify
    //
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    //News only mode
    static LPCTSTR  GetRegKey();
    static DWORD    GetOutlookBarVersion();

    /////////////////////////////////////////////////////////////////////////
    // Window Procedure Goo
    //
protected:
    static LRESULT CALLBACK OutBarWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ExtFrameWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    LRESULT FrameWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    // Main window Handlers
    void OnDestroy(HWND hwnd);
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);

    // Frame Window
    void    Frame_OnNCDestroy(HWND hwnd);
    void    Frame_OnSize(HWND hwnd, UINT state, int cx, int cy);
    void    Frame_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT Frame_OnNotify(HWND hwnd, int idFrom, NMHDR *pnmhdr);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    HRESULT _CreateToolbar();
    void    _FillToolbar();    
    void    _EmptyToolbar(BOOL fDelete);
    BOOL    _FindButton(int *piBtn, LPITEMIDLIST pidl);
    BOOL    _InsertButton(int iBtn, FOLDERINFO *pInfo);
    BOOL    _InsertButton(int iBtn, FOLDERID id);
    BOOL    _DeleteButton(int iBtn);
    BOOL    _UpdateButton(int iBtn, LPITEMIDLIST pidl);
    void    _OnFolderNotify(FOLDERNOTIFY *pnotify);
    void    _OnContextMenu(int x, int y);

    HRESULT _CreateDefaultButtons(void);
    HRESULT _LoadSettings(void);
    HRESULT _SaveSettings(void);
    BOOL    _SetButtonStyle(BOOL fSmall);

    HRESULT _AddShortcut(IDataObject *pObject);
    void    _UpdateDragDropHilite(LPPOINT ppt);
    int     _GetItemFromPoint(POINT pt);
    FOLDERID _FolderIdFromCmd(int idCmd);
    BOOL    _IsTempNewsgroup(IDataObject *pDataObject);

    /////////////////////////////////////////////////////////////////////////
    // Member Variables
    //
protected:
    ULONG               m_cRef;             // Reference Count

    // Groovy window handles
    HWND                m_hwndParent;       // Parent window handle
    HWND                m_hwnd;             // Main window handle
    HWND                m_hwndFrame;        // Inner window handle
    HWND                m_hwndPager;        // Pager window handle
    HWND                m_hwndTools;        // Toolbar window handle

    // Lovely interface pointers
    IAthenaBrowser     *m_pBrowser;         // Browser pointer
    IDockingWindowSite *m_ptbSite;          // Site pointer
    INotify            *m_pStNotify;        // Notification interface
    INotify            *m_pOutBarNotify;    // Outlook Bar notification interface

    // State
    BOOL                m_fShow;            // TRUE if we're visible
    BOOL                m_fLarge;           // TRUE if we're showing large icons
    BOOL                m_fResizing;        // TRUE if we're in the process of resizing
    int                 m_idCommand;        // Number of buttons on the button bar
    int                 m_idSel;            // ID of the item that is selected when a context menu is visible.
    int                 m_cxWidth;          // Width of our window
    BOOL                m_fOnce;            // TRUE until we call _LoadSettings the first time

    // Images
    HIMAGELIST          m_himlLarge;        // Large folder image list
    HIMAGELIST          m_himlSmall;        // Small folder image list

    // Drag Drop Stuff
    IDataObject        *m_pDataObject;      // What's being dragged over us
    DWORD               m_grfKeyState;      // Keyboard state last time we checked
    DWORD               m_dwEffectCur;      // Current drop effect
    DWORD               m_idCur;            // Currently selected button
    CDropTarget        *m_pTargetCur;       // Current drop target pointer
    DWORD               m_idDropHilite;     // Currently selected drop area
    TBINSERTMARK        m_tbim;
    BOOL                m_fInsertMark;      // TRUE if we've drawn an insertion mark
    BOOL                m_fDropShortcut;    // TRUE if the data object over us contains CF_OEFOLDER
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\propbckt.cpp ===
#include <pch.hxx>
#include <shlwapi.h>
#include "xpcomm.h"
#include "propbckt.h"

void FreePropVariant(LPPROPVARIANT pProp);
HRESULT DupPropVariant(LPPROPVARIANT pPropDst, LPCPROPVARIANT pPropSrc, BOOL fFree);
HRESULT InsertPropNode(LPCSTR pszProp, int iProp, PROPNODE **ppNode, int *pcNode, int *pcNodeBuf);

MSOEACCTAPI CreatePropertyBucket(IPropertyBucket **ppPropBckt)
{
    CPropertyBucket *pBckt;
    
    Assert(ppPropBckt != NULL);
    
    pBckt = new CPropertyBucket;
    
    *ppPropBckt = (IPropertyBucket *)pBckt;
    
    return(pBckt == NULL ? E_OUTOFMEMORY : S_OK);
}

CPropertyBucket::CPropertyBucket(void)
{
    m_cRef = 1;
    InitializeCriticalSection(&m_cs);
    
    m_pNodeId = NULL;
    m_cNodeId = 0;
    m_cNodeIdBuf = 0;
    
    m_pNodeSz = NULL;
    m_cNodeSz = 0;
    m_cNodeSzBuf = 0;
    
    m_pProp = 0;
    m_cProp = 0;
    m_cPropBuf = 0;
}

CPropertyBucket::~CPropertyBucket(void)
{
    int i;
    PROPNODE *pNode;
    LPPROPVARIANT pProp;
    
    DeleteCriticalSection(&m_cs);
    
    if (m_pNodeId != NULL)
        MemFree(m_pNodeId);
    
    if (m_pNodeSz != NULL)
    {
        for (i = 0, pNode = m_pNodeSz; i < m_cNodeSz; i++, pNode++)
        {
            Assert(pNode->psz != NULL);
            MemFree(pNode->psz);
        }
        
        MemFree(m_pNodeSz);
    }
    
    if (m_pProp != NULL)
    {
        for (i = 0, pProp = m_pProp; i < m_cProp; i++, pProp++)
            FreePropVariant(pProp);
        
        MemFree(m_pProp);
    }
}

STDMETHODIMP CPropertyBucket::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if (IID_IPropertyBucket == riid)
    {
        *ppv = (IPropertyBucket *)this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CPropertyBucket::AddRef(void)
{
    return((ULONG)InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) CPropertyBucket::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return((ULONG)cRef);
}

LPPROPVARIANT CPropertyBucket::GetPropVariant(LPCSTR pszProp)
{
    BOOL fSz;
    PROPID id;
    PROPNODE *pNode, *pNodeT;
    int x, left, right, d, cNode;
    
    Assert(pszProp != NULL);
    
    fSz = !IsPropId(pszProp);
    if (fSz)
    {
        pNode = m_pNodeSz;
        cNode = m_cNodeSz;
    }
    else
    {
        id = SzToPropId(pszProp);
        
        pNode = m_pNodeId;
        cNode = m_cNodeId;
    }
    
    if (pNode != NULL)
    {
        Assert(cNode > 0);
        
        left = 0;
        right = cNode - 1;
        do
        {
            x = (left + right) / 2;
            Assert(x >= 0);
            Assert(x < cNode);
            
            pNodeT = &pNode[x];
            
            d = fSz ? lstrcmp(pszProp, pNodeT->psz) : (id - pNodeT->id);
            
            if (d == 0)
            {
                Assert(pNodeT->iProp < m_cProp);
                return(&m_pProp[pNodeT->iProp]);
            }
            else if (d < 0)
            {
                right = x - 1;
            }
            else
            {
                left = x + 1;
            }
        }
        while (right >= left);
    }
    
    return(NULL);
}

// TODO: move to msoert
void FreePropVariant(LPPROPVARIANT pProp)
{
    Assert(pProp != NULL);
    
    switch (pProp->vt)
    {
        // Since pProp is a union, this MemFree will work for all
        case VT_LPSTR:
        case VT_LPWSTR:
        case VT_CLSID:
        case VT_CF:
            if (pProp->pszVal != NULL)
                MemFree(pProp->pszVal);
            break;

        case VT_BSTR:
            if (pProp->bstrVal != NULL)
                SysFreeString(pProp->bstrVal);
            break;
            
        case VT_BLOB:
            if (pProp->blob.pBlobData != NULL)
                MemFree(pProp->blob.pBlobData);
            break;
        
        case VT_STREAM:
            if (pProp->pStream != NULL)
                pProp->pStream->Release();
            break;
        
        case VT_STORAGE:
            if (pProp->pStorage != NULL)
                pProp->pStorage->Release();
            break;
    }
}

// TODO: move to msoert
HRESULT DupPropVariant(LPPROPVARIANT pPropDst, LPCPROPVARIANT pPropSrc, BOOL fFree)
{
    HRESULT hr = S_OK;
    LPSTR   psz = NULL;
    LPWSTR  pwsz = NULL;
    LPBYTE pb;

    hr = S_OK;

    switch (pPropSrc->vt)
    {
        case VT_LPSTR:
            if (pPropSrc->pszVal != NULL)
            {
                IF_NULLEXIT(psz = PszDupA(pPropSrc->pszVal));
                if (fFree)
                    FreePropVariant(pPropDst);
                pPropDst->pszVal = psz;
            }
            else
            {
                if (fFree)
                    FreePropVariant(pPropDst);
                pPropDst->pszVal = NULL;
            }
            break;
        
        case VT_LPWSTR:
            if (pPropSrc->pwszVal != NULL)
            {
                IF_NULLEXIT(pwsz = PszDupW(pPropSrc->pwszVal));
                if (fFree)
                    FreePropVariant(pPropDst);
                pPropDst->pwszVal = pwsz;
            }
            else
            {
                if (fFree)
                    FreePropVariant(pPropDst);
                pPropDst->pwszVal = NULL;
            }
            break;
        
        case VT_BLOB:
            if (pPropSrc->blob.pBlobData != NULL)
            {
                Assert(pPropSrc->blob.cbSize > 0);
                IF_NULLEXIT(MemAlloc((void **)&pb, pPropSrc->blob.cbSize));
                if (fFree)
                    FreePropVariant(pPropDst);
            
                CopyMemory(pb, pPropSrc->blob.pBlobData, pPropSrc->blob.cbSize);
                pPropDst->blob.pBlobData = pb;
                pPropDst->blob.cbSize = pPropSrc->blob.cbSize;
            }
            else
            {
                if (fFree)
                    FreePropVariant(pPropDst);
            
                Assert(pPropSrc->blob.cbSize == 0);
                pPropDst->blob.cbSize = 0;
                pPropDst->blob.pBlobData = NULL;
            }
            break;
        
        case VT_UI1:
            pPropDst->bVal = pPropSrc->bVal;
            break;
        
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            Assert(sizeof(pPropDst->uiVal) >= sizeof(pPropDst->boolVal));
            pPropDst->uiVal = pPropSrc->uiVal;
            break;
        
        case VT_I4:
        case VT_UI4:
        case VT_ERROR:
        case VT_R4:
            Assert(sizeof(pPropDst->ulVal) >= sizeof(pPropDst->scode));
            Assert(sizeof(pPropDst->ulVal) >= sizeof(pPropDst->fltVal));
            pPropDst->ulVal = pPropSrc->ulVal;
            break;
        
        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            Assert(sizeof(pPropDst->uhVal) >= sizeof(pPropDst->dblVal));
            Assert(sizeof(pPropDst->uhVal) >= sizeof(pPropDst->cyVal));
            Assert(sizeof(pPropDst->uhVal) >= sizeof(pPropDst->date));
            Assert(sizeof(pPropDst->uhVal) >= sizeof(pPropDst->filetime));
            pPropDst->uhVal = pPropSrc->uhVal;
            break;
        
        default:
            AssertSz(FALSE, "nyi");
            IF_FAILEXIT(hr = E_FAIL);
            break;
    }
    
exit:
    if (SUCCEEDED(hr))
        pPropDst->vt = pPropSrc->vt;
    
    return(hr);
}

HRESULT ComparePropVariant(LPPROPVARIANT pProp1, LPCPROPVARIANT pProp2)
{
    HRESULT hr;
    BYTE *pb1, *pb2;
    ULONG i;
    
    hr = S_OK;
    
    if (pProp1->vt == pProp2->vt)
    {
        switch (pProp1->vt)
        {
            case VT_LPSTR:
                if (0 == lstrcmp(pProp1->pszVal, pProp2->pszVal))
                    hr = S_NO_CHANGE;
                break;
            
            case VT_LPWSTR:
                if (0 == StrCmpW(pProp1->pwszVal, pProp2->pwszVal))
                    hr = S_NO_CHANGE;
                break;
            
            case VT_BLOB:
                if (pProp1->blob.cbSize == pProp2->blob.cbSize)
                {
                    pb1 = pProp1->blob.pBlobData;
                    pb2 = pProp2->blob.pBlobData;
                    if (pb1 == NULL)
                    {
                        Assert(pb2 == NULL);
                        hr = S_NO_CHANGE;
                    }
                    else
                    {
                        Assert(pb2 != NULL);
                        for (i = 0; i < pProp1->blob.cbSize; i++)
                        {
                            if (*pb1 != *pb2)
                                break;
                            pb1++;
                            pb2++;
                        }
                        if (i == pProp1->blob.cbSize)
                            hr = S_NO_CHANGE;
                    }
                }
                break;
            
            case VT_UI4:
                if (pProp1->ulVal == pProp2->ulVal)
                    hr = S_NO_CHANGE;
                break;
            
            default:
                break;
        }
    }
    
    return(hr);
}

STDMETHODIMP CPropertyBucket::GetProperty(LPCSTR pszProp, LPPROPVARIANT pVar, DWORD dwReserved)
{
    HRESULT hr;
    LPPROPVARIANT pProp;
    
    if (pszProp == NULL ||
        pVar == NULL ||
        dwReserved != 0)
        return(E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    
    pProp = GetPropVariant(pszProp);
    if (pProp != NULL)
        hr = DupPropVariant(pVar, pProp, FALSE);
    else
        hr = E_PROP_NOT_FOUND;
    
    LeaveCriticalSection(&m_cs);
    
    return(hr);
}

#define CALLOCPROP  32
#define CALLOCNODE  16

STDMETHODIMP CPropertyBucket::SetProperty(LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwReserved)
{
    HRESULT hr = S_OK;
    LPPROPVARIANT pProp;
    UINT cAlloc;
    PROPNODE *pNode;
    
    if (pszProp == NULL || pVar == NULL || dwReserved != 0)
        return TraceResult(E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    
    pProp = GetPropVariant(pszProp);
    if (pProp != NULL)
    {
        if (pProp->vt != pVar->vt)
        {
            hr = E_INVALID_PROP_TYPE;
        }
        else
        {
            hr = ComparePropVariant(pProp, pVar);
            if (hr != S_NO_CHANGE)
                IF_FAILEXIT(hr = DupPropVariant(pProp, pVar, TRUE));
        }
    }
    else
    {
        if (m_cProp == m_cPropBuf)
        {
            cAlloc = m_cPropBuf + CALLOCPROP;
            IF_NULLEXIT(MemRealloc((void **)&m_pProp, sizeof(PROPVARIANT) * cAlloc));
            
            m_cPropBuf = cAlloc;
            ZeroMemory(&m_pProp[m_cProp], sizeof(PROPVARIANT) * CALLOCPROP);
        }
        
        pProp = &m_pProp[m_cProp];
        IF_FAILEXIT(hr = DupPropVariant(pProp, pVar, FALSE));

        if (IsPropId(pszProp))
            hr = InsertPropNode(pszProp, m_cProp, &m_pNodeId, &m_cNodeId, &m_cNodeIdBuf);
        else
            hr = InsertPropNode(pszProp, m_cProp, &m_pNodeSz, &m_cNodeSz, &m_cNodeSzBuf);
        
        m_cProp++;
    }

exit:
    LeaveCriticalSection(&m_cs);
    
    return(hr);
}

HRESULT InsertPropNode(LPCSTR pszProp, int iProp, PROPNODE **ppNode, int *pcNode, int *pcNodeBuf)
{
    int         iNode, cAlloc, d;
    BOOL        fSz;
    LPSTR       psz;
    PROPNODE   *pNodeT;
    HRESULT     hr = S_OK;
    
    if (*pcNode == *pcNodeBuf)
    {
        cAlloc = *pcNodeBuf + CALLOCNODE;
        IF_NULLEXIT(MemRealloc((void **)ppNode, sizeof(PROPNODE) * cAlloc));
        
        *pcNodeBuf = cAlloc;
        ZeroMemory(&(*ppNode)[*pcNode], sizeof(PROPNODE) * CALLOCNODE);
    }
    
    if (fSz = !IsPropId(pszProp))
    {
        IF_NULLEXIT(psz = StringDup(pszProp));
    }
    else
    {
        psz = (LPSTR)pszProp;
    }

    pNodeT = *ppNode;
    for (iNode = 0; iNode < *pcNode; iNode++)
    {
        d = fSz ? lstrcmp(pszProp, pNodeT->psz) : (PtrToUlong(pszProp) - pNodeT->id);
        Assert(d != 0);
        
        if (d < 0)
            break;
        
        pNodeT++;
    }
    
    cAlloc = *pcNode - iNode;
    if (cAlloc > 0)
        MoveMemory(pNodeT + 1, pNodeT, cAlloc * sizeof(PROPNODE));
    pNodeT->psz = psz;
    pNodeT->iProp = iProp;
    (*pcNode)++;

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\propbckt.h ===
#ifndef _INC_PROPBCKT_H
#define _INC_PROPBCKT_H

#include <msoeprop.h>

typedef struct tagPROPNODE
    {
    union
        {
        LPSTR psz;
        PROPID id;
        };
    int iProp;
    } PROPNODE;

#define IsPropId(_psz)      (0 == (0xffff0000 & (DWORD)PtrToUlong(_psz)))
#define SzToPropId(_psz)    ((PROPID)PtrToUlong(_psz))

class CPropertyBucket : public IPropertyBucket
    {
    public:
        // ----------------------------------------------------------------------------
        // Construction
        // ----------------------------------------------------------------------------
        CPropertyBucket(void);
        ~CPropertyBucket(void);

        // -------------------------------------------------------------------
        // IUnknown Members
        // -------------------------------------------------------------------
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // -------------------------------------------------------------------
        // IPropertyBucket Members
        // -------------------------------------------------------------------
        STDMETHODIMP GetProperty(LPCSTR pszProp, LPPROPVARIANT pVar, DWORD dwReserved);
        STDMETHODIMP SetProperty(LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwReserved);

    private:
        LONG                m_cRef;
        CRITICAL_SECTION    m_cs;

        PROPNODE           *m_pNodeId;
        int                 m_cNodeId;
        int                 m_cNodeIdBuf;

        PROPNODE           *m_pNodeSz;
        int                 m_cNodeSz;
        int                 m_cNodeSzBuf;

        LPPROPVARIANT       m_pProp;
        int                 m_cProp;
        int                 m_cPropBuf;

        LPPROPVARIANT GetPropVariant(LPCSTR pszProp);
    };

#endif // _INC_PROPBCKT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\rasapi.h ===
// ==================================================================================================================
// R A S A P I . H
// ==================================================================================================================
#ifndef __RASAPI_H
#define __RASAPI_H

// ==================================================================================================================
// Depends On
// ==================================================================================================================
#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>

// ==================================================================================================================
// API Typedefs
// ==================================================================================================================
typedef DWORD (APIENTRY *RASDIALPROC)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASENUMENTRIESPROC)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROC)(UINT, LPTSTR, DWORD);
typedef DWORD (APIENTRY *RASHANGUPPROC)(HRASCONN);
typedef DWORD (APIENTRY *RASSETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD (APIENTRY *RASGETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL*);
typedef DWORD (APIENTRY *RASCREATEPHONEBOOKENTRYPROC)(HWND, LPTSTR);
typedef DWORD (APIENTRY *RASEDITPHONEBOOKENTRYPROC)(HWND, LPTSTR, LPTSTR);                                                    

typedef BOOL  (APIENTRY *RASDIALDLGPROC)(LPSTR, LPSTR, LPSTR, LPRASDIALDLG);

// =================================================================================
// RAS Connection Handler
// =================================================================================
#define MAX_RAS_ERROR           256

class CRas
{
private:
    ULONG           m_cRef;
    BOOL            m_fIStartedRas;
    DWORD           m_iConnectType;
    TCHAR           m_szConnectName[RAS_MaxEntryName + 1];
    TCHAR           m_szCurrentConnectName[RAS_MaxEntryName + 1];
    HRASCONN        m_hRasConn;
    BOOL            m_fForceHangup;
    RASDIALPARAMS   m_rdp;
    BOOL            m_fSavePassword;
    BOOL            m_fShutdown;

private:
    // ----------------------------------------------------------
    // RAS Async Dial Progress Dialog
    // ----------------------------------------------------------
    HRESULT HrStartRasDial(HWND hwndParent);
    static BOOL CALLBACK RasProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError);
    static BOOL CALLBACK RasLogonDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT HrRasLogon(HWND hwndParent, BOOL fForcePrompt);
    UINT UnPromptCloseConn(HWND hwnd);
    static BOOL CALLBACK RasCloseConnDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL FLogonRetry(HWND hwnd, LPTSTR pszCancel);

public:
    // ----------------------------------------------------------
    // Construction and Destruction
    // ----------------------------------------------------------
    CRas();
    ~CRas();

    // ----------------------------------------------------------
    // Ref Counting of course
    // ----------------------------------------------------------
    ULONG AddRef(VOID);
    ULONG Release(VOID);

    // ----------------------------------------------------------
    // Before you try to connect !!!
    // ----------------------------------------------------------
    VOID SetConnectInfo(DWORD iConnectType, LPTSTR pszConnectName);

    // ----------------------------------------------------------
    // Connect using ConnectInfo
    // ----------------------------------------------------------
    HRESULT HrConnect(HWND hwnd);

    // ----------------------------------------------------------
    // Disconnect
    // ----------------------------------------------------------
    VOID Disconnect(HWND hwnd, BOOL fShutdown);

    // ----------------------------------------------------------
    // Are we actually using a RAS connection
    // ----------------------------------------------------------
    BOOL FUsingRAS(VOID);
    
    // ----------------------------------------------------------
    // Name of the current connection
    // ----------------------------------------------------------
    LPTSTR GetCurrentConnectionName() { return m_szCurrentConnectName; }
};

// =================================================================================
// Prototypes
// =================================================================================
CRas *LpCreateRasObject(VOID);
VOID RasInit(VOID);
VOID RasDeinit(VOID);
VOID FillRasCombo(HWND hwndCtl, BOOL fUpdateOnly);
DWORD EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName);
DWORD CreatePhonebookEntry(HWND hwnd);

#endif // _RASAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\rasapi.cpp ===
// =====================================================================================
// R A S A P I . C P P
// =====================================================================================
#include "pch.hxx"
#include "rasapi.h"
#include "connect.h"
#include "resource.h"
#include "error.h"
#include "strconst.h"
#include "xpcomm.h"
#include "rasdlgsp.h"
#include "goptions.h"

// =====================================================================================
// Ras Dial Function Pointers
// =====================================================================================
static CRITICAL_SECTION            g_rCritSec;
static HINSTANCE                   g_hInstRas=NULL;
static HINSTANCE                   g_hInstRasDlg=NULL;
static RASDIALPROC                 g_pRasDial=NULL;
static RASENUMCONNECTIONSPROC      g_pRasEnumConnections=NULL;
static RASENUMENTRIESPROC          g_pRasEnumEntries=NULL;
static RASGETCONNECTSTATUSPROC     g_pRasGetConnectStatus=NULL;
static RASGETERRORSTRINGPROC       g_pRasGetErrorString=NULL;
static RASHANGUPPROC               g_pRasHangup=NULL;
static RASSETENTRYDIALPARAMSPROC   g_pRasSetEntryDialParams=NULL;
static RASGETENTRYDIALPARAMSPROC   g_pRasGetEntryDialParams=NULL;
static RASCREATEPHONEBOOKENTRYPROC g_pRasCreatePhonebookEntry=NULL;
static RASEDITPHONEBOOKENTRYPROC   g_pRasEditPhonebookEntry=NULL;
static RASDIALDLGPROC              g_pRasDialDlg=NULL;

// =====================================================================================
// Make our code look prettier
// =====================================================================================
#undef RasDial
#undef RasEnumConnections
#undef RasEnumEntries
#undef RasGetConnectStatus
#undef RasGetErrorString
#undef RasHangup
#undef RasSetEntryDialParams
#undef RasGetEntryDialParams
#undef RasCreatePhonebookEntry
#undef RasEditPhonebookEntry
#undef RasDialDlg

#define RasDial                    (*g_pRasDial)
#define RasEnumConnections         (*g_pRasEnumConnections)
#define RasEnumEntries             (*g_pRasEnumEntries)
#define RasGetConnectStatus        (*g_pRasGetConnectStatus)
#define RasGetErrorString          (*g_pRasGetErrorString)
#define RasHangup                  (*g_pRasHangup)
#define RasSetEntryDialParams      (*g_pRasSetEntryDialParams)
#define RasGetEntryDialParams      (*g_pRasGetEntryDialParams)
#define RasCreatePhonebookEntry    (*g_pRasCreatePhonebookEntry)
#define RasEditPhonebookEntry      (*g_pRasEditPhonebookEntry)
#define RasDialDlg                 (*g_pRasDialDlg)

#define DEF_HANGUP_WAIT            10 // Seconds

static const TCHAR s_szRasDlgDll[] = "RASDLG.DLL";
#ifdef UNICODE
static const TCHAR s_szRasDialDlg[] = "RasDialDlgW";
#else
static const TCHAR s_szRasDialDlg[] = "RasDialDlgA";
#endif

// =====================================================================================
// Cool little RAS Utilities
// =====================================================================================
HRESULT HrVerifyRasLoaded(VOID);
BOOL FEnumerateConnections(LPRASCONN *ppRasConn, ULONG *pcConnections);
BOOL FFindConnection(LPTSTR lpszEntry, LPHRASCONN phRasConn);
BOOL FRasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds);
HRESULT HrRasError(HWND hwnd, HRESULT hrRasError, DWORD dwRasDial);
VOID CombinedRasError(HWND hwnd, UINT unids, LPTSTR pszRasError, DWORD dwRasError);

extern BOOL FIsPlatformWinNT();

// =====================================================================================
// LpCreateRasObject
// =====================================================================================
CRas *LpCreateRasObject(VOID)
{
    CRas *pRas = new CRas;
    return pRas;
}

// =====================================================================================
// RasInit
// =====================================================================================
VOID RasInit(VOID)
{
    InitializeCriticalSection(&g_rCritSec);
}

// =====================================================================================
// RasDeinit
// =====================================================================================
VOID RasDeinit(VOID)
{
    if(g_hInstRas)
    {
        EnterCriticalSection(&g_rCritSec);
        g_pRasEnumConnections=NULL;
        g_pRasEnumEntries=NULL;
        g_pRasGetConnectStatus=NULL;
        g_pRasGetErrorString=NULL;
        g_pRasHangup=NULL;
        g_pRasSetEntryDialParams=NULL;
        g_pRasGetEntryDialParams=NULL;
        g_pRasCreatePhonebookEntry=NULL;
        g_pRasEditPhonebookEntry=NULL;
        FreeLibrary(g_hInstRas);
        g_hInstRas=NULL;
        LeaveCriticalSection(&g_rCritSec);
    }
    if(g_hInstRasDlg)
    {
        EnterCriticalSection(&g_rCritSec);
        g_pRasDialDlg=NULL;
        FreeLibrary(g_hInstRasDlg);
        g_hInstRasDlg=NULL;
        LeaveCriticalSection(&g_rCritSec);
    }
    DeleteCriticalSection(&g_rCritSec);
}

// =====================================================================================
// CRas::CRas
// =====================================================================================
CRas::CRas()
{
    DOUT("CRas::CRas");
    m_cRef = 1;
    m_fIStartedRas = FALSE;
    m_iConnectType = 0;
    *m_szConnectName = _T('\0');
    *m_szCurrentConnectName = _T('\0');
    m_hRasConn = NULL;
    m_fForceHangup = FALSE;
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    m_fSavePassword = FALSE;
    m_fShutdown = FALSE;
}

// =====================================================================================
// CRas::~CRas
// =====================================================================================
CRas::~CRas()
{
    DOUT("CRas::~CRas");
}

// =====================================================================================
// CRas::AddRef
// =====================================================================================
ULONG CRas::AddRef(VOID)
{
    DOUT("CRas::AddRef %lx ==> %d", this, m_cRef+1);
    return ++m_cRef;
}

// =====================================================================================
// CRas::Release
// =====================================================================================
ULONG CRas::Release(VOID)
{
    DOUT("CRas::Release %lx ==> %d", this, m_cRef-1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// =====================================================================================
// CRas::FUsingRAS
// =====================================================================================
BOOL CRas::FUsingRAS(VOID)
{
    return m_iConnectType == iConnectRAS ? TRUE : FALSE;
}

// =====================================================================================
// CRas::SetConnectInfo
// =====================================================================================
VOID CRas::SetConnectInfo(DWORD iConnectType, LPTSTR pszConnectName)
{
    // Changing connection, drop current ?
    if (m_iConnectType == iConnectRAS && iConnectType != iConnectRAS)
        Disconnect(NULL, FALSE);
    
    // Save Connection Data
    lstrcpyn (m_szConnectName, pszConnectName, RAS_MaxEntryName+1);
    m_iConnectType = iConnectType;

    // Not using RAS
    if (m_iConnectType != iConnectRAS)
        return;
}

// =====================================================================================
// CRas::HrConnect
// =====================================================================================
HRESULT CRas::HrConnect(HWND hwnd)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRASCONN       pRasConn=NULL;
    ULONG           cConnections;

    // Not using RAS
    if (m_iConnectType != iConnectRAS)
        goto exit;

    // Not inited
    hr = HrVerifyRasLoaded();
    if (FAILED(hr))
    {
        HrRasError(hwnd, hr, 0);
        TRAPHR(hr);
        goto exit;
    }

    // Get Current RAS Connection
    FEnumerateConnections(&pRasConn, &cConnections);

    // Connections ?
    if (cConnections)
    {
        m_hRasConn = pRasConn[0].hrasconn;
        lstrcpy(m_szCurrentConnectName, pRasConn[0].szEntryName);
    }
    else
    {
        m_fIStartedRas = FALSE;
        m_hRasConn = NULL;
        *m_szCurrentConnectName = _T('\0');
    }

    // If RAS Connection present, is it equal to suggested
    if (m_hRasConn)
    {
        // Current connection is what I want ?
        if (lstrcmpi(m_szCurrentConnectName, m_szConnectName) == 0)
            goto exit;

        // Otherwise, if we didn't start the RAS connection...
        else if (m_fIStartedRas == FALSE)
        {
            // Get option fo handling current connection
            UINT unAnswer = UnPromptCloseConn(hwnd);

            // Cancel ?
            if (IDCANCEL == unAnswer)
            {
                hr = TRAPHR(hrUserCancel);
                goto exit;
            }

            // Close Current ?
            else if (idrgDialNew == unAnswer)
            {
                m_fForceHangup = TRUE;
                Disconnect(NULL, FALSE);
                m_fForceHangup = FALSE;
            }

            // Otherwise, use current ?
            else if (idrgUseCurrent == unAnswer)
                goto exit;

            // Problems
            else
                Assert(FALSE);
        }

        // Otherwise, I started the connection, so close it
        else if (m_fIStartedRas == TRUE)
            Disconnect(NULL, FALSE);
    }

    // We probably shouldn't have a connection handle at this point
    Assert(m_hRasConn == NULL);

    // Dial the connection
    CHECKHR(hr = HrStartRasDial(hwnd));

    // If Synchronous -- Woo - hoo were connected and we started the connection
    m_fIStartedRas = TRUE;
    lstrcpy(m_szCurrentConnectName, m_szConnectName);

exit:
    // Cleanup
    SafeMemFree(pRasConn);

    // Done
    return hr;
}

// =====================================================================================
// CRas::UnPromptCloseConn
// =====================================================================================
UINT CRas::UnPromptCloseConn(HWND hwnd)
{
    return DialogBoxParam(g_hLocRes, MAKEINTRESOURCE (iddRasCloseConn), hwnd, (DLGPROC)RasCloseConnDlgProc, (LPARAM)this);
}

// =====================================================================================
// CRas::RasCloseConnDlgProc
// =====================================================================================
BOOL CALLBACK CRas::RasCloseConnDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CRas        *pRas=NULL;
    TCHAR       szRes[255],
                szMsg[255+RAS_MaxEntryName+1];

    switch(uMsg)
    {
    case WM_INITDIALOG:
        // Get lparam
        pRas = (CRas *)lParam;
        if (!pRas)
        {
            Assert (FALSE);
            EndDialog(hwnd, E_FAIL);
            return 1;
        }

        // Center
        CenterDialog(hwnd);

        // Set Text
        GetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szRes, sizeof(szRes)/sizeof(TCHAR));
        wsprintf(szMsg, szRes, pRas->m_szCurrentConnectName);
        SetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szMsg);

        // Set control
        GetWindowText(GetDlgItem(hwnd, idrgDialNew), szRes, sizeof(szRes)/sizeof(TCHAR));
        wsprintf(szMsg, szRes, pRas->m_szConnectName);
        SetWindowText(GetDlgItem(hwnd, idrgDialNew), szMsg);

        // Set Default
        CheckDlgButton(hwnd, idrgDialNew, TRUE);
        return 1;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDOK:
            EndDialog(hwnd, IsDlgButtonChecked(hwnd, idrgDialNew) ? idrgDialNew : idrgUseCurrent);
            return 1;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;
        }
    }
    return 0;
}

// =====================================================================================
// CRas::HrRasLogon
// =====================================================================================
HRESULT CRas::HrRasLogon(HWND hwnd, BOOL fForcePrompt)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwRasError;

    // Do we need to prompt for logon information first ?
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    m_rdp.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(m_rdp.szEntryName, m_szConnectName);

    // Get params
    dwRasError = RasGetEntryDialParams(NULL, &m_rdp, &m_fSavePassword);
    if (dwRasError)
    {
        HrRasError(hwnd, hrGetDialParamsFailed, dwRasError);
        hr = TRAPHR(hrGetDialParamsFailed);
        goto exit;
    }

    if (g_pRasDialDlg)
    {
        // RasDialDlg will take it from here
        goto exit;
    }

    // Do we need to get password / account information
    if (fForcePrompt || 
        m_fSavePassword == FALSE ||
        FIsStringEmpty(m_rdp.szUserName) || 
        FIsStringEmpty(m_rdp.szPassword))
    {
        // RAS Logon
        hr = DialogBoxParam (g_hLocRes, MAKEINTRESOURCE (iddRasLogon), hwnd, (DLGPROC)RasLogonDlgProc, (LPARAM)this);
        if (hr == hrUserCancel)
        {
            HrRasError(hwnd, hrUserCancel, 0);
            hr = hrUserCancel;
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}

// =====================================================================================
// CRas::RasLogonDlgProc
// =====================================================================================
BOOL CALLBACK CRas::RasLogonDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    TCHAR           sz[255],
                    szText[255+RAS_MaxEntryName+1];
    CRas           *pRas = (CRas *)GetWndThisPtr(hwnd);
    DWORD           dwRasError;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get lparam
        pRas = (CRas *)lParam;
        if (!pRas)
        {
            Assert (FALSE);
            EndDialog(hwnd, E_FAIL);
            return 1;
        }

        // Center the window
        CenterDialog (hwnd);

        // Get Window Title
        GetWindowText(hwnd, sz, sizeof(sz));
        wsprintf(szText, sz, pRas->m_szConnectName);
        SetWindowText(hwnd, szText);

        // Word Default
        AthLoadString(idsDefault, sz, sizeof(sz));
        
        // Set Fields
        Edit_LimitText(GetDlgItem(hwnd, ideUserName), UNLEN);
        Edit_LimitText(GetDlgItem(hwnd, idePassword), PWLEN);
        //Edit_LimitText(GetDlgItem(hwnd, ideDomain), DNLEN);
        Edit_LimitText(GetDlgItem(hwnd, idePhone), RAS_MaxPhoneNumber);
        
        SetDlgItemText(hwnd, ideUserName, pRas->m_rdp.szUserName);
        SetDlgItemText(hwnd, idePassword, pRas->m_rdp.szPassword);

/*
        if (FIsStringEmpty(pRas->m_rdp.szDomain))
            SetDlgItemText(hwnd, ideDomain, sz);
        else
            SetDlgItemText(hwnd, ideDomain, pRas->m_rdp.szDomain);
*/

        if (FIsStringEmpty(pRas->m_rdp.szPhoneNumber))
            SetDlgItemText(hwnd, idePhone, sz);
        else
            SetDlgItemText(hwnd, idePhone, pRas->m_rdp.szPhoneNumber);

        CheckDlgButton(hwnd, idchSavePassword, pRas->m_fSavePassword);

        // Save pRas
        SetWndThisPtr (hwnd, pRas);
        return 1;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case idbEditConnection:
            EditPhonebookEntry(hwnd, pRas->m_szConnectName);
            return 1;

        case IDCANCEL:
            EndDialog(hwnd, hrUserCancel);
            return 1;

        case IDOK:
            AthLoadString(idsDefault, sz, sizeof(sz));

            // Set Fields
            GetDlgItemText(hwnd, ideUserName, pRas->m_rdp.szUserName, UNLEN+1);
            GetDlgItemText(hwnd, idePassword, pRas->m_rdp.szPassword, PWLEN+1);

/*
            GetDlgItemText(hwnd, ideDomain, pRas->m_rdp.szDomain, DNLEN+1);
            if (lstrcmp(pRas->m_rdp.szDomain, sz) == 0)
                *pRas->m_rdp.szDomain = _T('\0');
*/
            
            GetDlgItemText(hwnd, idePhone, pRas->m_rdp.szPhoneNumber, RAS_MaxPhoneNumber+1);
            if (lstrcmp(pRas->m_rdp.szPhoneNumber, sz) == 0)
                *pRas->m_rdp.szPhoneNumber = _T('\0');
            
            pRas->m_fSavePassword = IsDlgButtonChecked(hwnd, idchSavePassword);

            // Save Dial Parameters
            dwRasError = RasSetEntryDialParams(NULL, &pRas->m_rdp, !pRas->m_fSavePassword);
            if (dwRasError)
            {
                HrRasError(hwnd, hrSetDialParamsFailed, dwRasError);
                return 1;
            }
            EndDialog(hwnd, S_OK);
            return 1;
        }
        break;

    case WM_DESTROY:
        SetWndThisPtr (hwnd, NULL);
        break;
    }
    return 0;
}

// =====================================================================================
// CRas::HrShowRasDialError
// =====================================================================================
HRESULT CRas::HrStartRasDial(HWND hwndParent)
{
    // Locals
    HRESULT         hr=S_OK;

    // Logon first ?
    CHECKHR (hr = HrRasLogon(hwndParent, FALSE));

    if (g_pRasDialDlg)
    {
        RASDIALDLG rdd = {0};
        BOOL       fRet;

        rdd.dwSize = sizeof(rdd);
        rdd.hwndOwner = hwndParent;

#if (WINVER >= 0x401)
        rdd.dwSubEntry = m_rdp.dwSubEntry;
#else
        rdd.dwSubEntry = 0;
#endif

        fRet = RasDialDlg(NULL, m_rdp.szEntryName, lstrlen(m_rdp.szPhoneNumber) ? m_rdp.szPhoneNumber : NULL, &rdd);
        if (!fRet)
        {
            hr = E_FAIL;
        }    
    }
    else
    {
        // Done
        hr = DialogBoxParam (g_hLocRes, MAKEINTRESOURCE (iddRasProgress), hwndParent, (DLGPROC)RasProgressDlgProc, (LPARAM)this);
    }

exit:
    // Done
    return hr;
}

// =====================================================================================
// CRas::RasProgressDlgProc
// =====================================================================================
BOOL CALLBACK CRas::RasProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    TCHAR           szText[255+RAS_MaxEntryName+1],
                    sz[255];
    CRas           *pRas = (CRas *)GetWndThisPtr(hwnd);
    static TCHAR    s_szCancel[40];
    static UINT     s_unRasEventMsg=0;
    static BOOL     s_fDetails=FALSE;
    static RECT     s_rcDialog;
    static BOOL     s_fAuthStarted=FALSE;
    DWORD           dwRasError,
                    cyDetails;
    RASCONNSTATUS   rcs;
    RECT            rcDetails,
                    rcDlg;
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get lparam
        pRas = (CRas *)lParam;
        if (!pRas)
        {
            Assert (FALSE);
            EndDialog(hwnd, E_FAIL);
            return 1;
        }

        // Save this pointer
        SetWndThisPtr (hwnd, pRas);

        // Save Original Size of the dialog
        GetWindowRect (hwnd, &s_rcDialog);

        // Details enabled
        s_fDetails = DwGetOption(OPT_RASCONNDETAILS);

        // Hide details drop down
        if (s_fDetails == FALSE)
        {
            // Hid
            GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);

            // Height of details
            cyDetails = s_rcDialog.bottom - rcDetails.top;
    
            // Re-size
            MoveWindow (hwnd, s_rcDialog.left, 
                              s_rcDialog.top, 
                              s_rcDialog.right - s_rcDialog.left, 
                              s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                              FALSE);
        }
        else
        {
            AthLoadString (idsHideDetails, sz, sizeof (sz));
            SetWindowText (GetDlgItem (hwnd, idbDet), sz);
        }

        // Get registered RAS event message id
        s_unRasEventMsg = RegisterWindowMessageA(RASDIALEVENT);
        if (s_unRasEventMsg == 0)
            s_unRasEventMsg = WM_RASDIALEVENT;

        // Center the window
        CenterDialog (hwnd);

        // Get Window Title
        GetWindowText(hwnd, sz, sizeof(sz));
        wsprintf(szText, sz, pRas->m_szConnectName);
        SetWindowText(hwnd, szText);

        // Dialog Xxxxxxx.....
        AthLoadString(idsRas_Dialing, sz, sizeof(sz)/sizeof(TCHAR));
        wsprintf(szText, sz, pRas->m_rdp.szPhoneNumber);
        SetWindowText(GetDlgItem(hwnd, ideProgress), szText);

        // Get Cancel Text
        GetWindowText(GetDlgItem(hwnd, IDCANCEL), s_szCancel, sizeof(s_szCancel));

        // Give the list box and hscroll
        SendMessage(GetDlgItem(hwnd, idlbDetails), LB_SETHORIZONTALEXTENT, 600, 0);

        // Dial the connection
        pRas->m_hRasConn = NULL;
        dwRasError = RasDial(NULL, NULL, &pRas->m_rdp, 0xFFFFFFFF, hwnd, &pRas->m_hRasConn);
        if (dwRasError)
        {
            pRas->FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
            if (!pRas->FLogonRetry(hwnd, s_szCancel))
            {
                SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                return 1;
            }
        }
        return 1;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            SetDwOption(OPT_RASCONNDETAILS, s_fDetails);
            EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
            if (pRas)
                pRas->FailedRasDial(hwnd, hrUserCancel, 0);
            EndDialog(hwnd, hrUserCancel);
            return 1;

        case idbDet:
            // Get current location of the dialog
            GetWindowRect (hwnd, &rcDlg);

            // If currently hidden
            if (s_fDetails == FALSE)
            {
                // Re-size
                MoveWindow (hwnd, rcDlg.left, 
                                  rcDlg.top, 
                                  s_rcDialog.right - s_rcDialog.left, 
                                  s_rcDialog.bottom - s_rcDialog.top,
                                  TRUE);

                AthLoadString (idsHideDetails, sz, sizeof (sz));
                SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                s_fDetails = TRUE;
            }

            else
            {
                // Size of details
                GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);
                cyDetails = rcDlg.bottom - rcDetails.top;
                MoveWindow (hwnd, rcDlg.left, 
                                  rcDlg.top, 
                                  s_rcDialog.right - s_rcDialog.left, 
                                  s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                                  TRUE);

                AthLoadString (idsShowDetails, sz, sizeof (sz));
                SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                s_fDetails = FALSE;
            }
            break;
        }
        break;

    case WM_DESTROY:
        SetWndThisPtr (hwnd, NULL);
        break;

    default:
        if (!pRas)
            break;

        if (uMsg == s_unRasEventMsg)
        {
            HWND hwndLB = GetDlgItem(hwnd, idlbDetails);

            // Error ?
            if (lParam)
            {
                // Disconnected
                AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                ListBox_AddString(hwndLB, sz);

                // Log Error
                TCHAR szRasError[512];
                if (RasGetErrorString(lParam, szRasError, sizeof(szRasError)) == 0)
                {
                    TCHAR szError[512 + 255];
                    AthLoadString(idsErrorText, sz, sizeof(sz));
                    wsprintf(szError, "%s %d: %s", sz, lParam, szRasError);
                    ListBox_AddString(hwndLB, szError);
                }

                // Select last item
                SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);

                // Show Error
                pRas->FailedRasDial(hwnd, hrRasDialFailure, lParam);

                // Re logon
                if (!pRas->FLogonRetry(hwnd, s_szCancel))
                {
                    SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                    return 1;
                }
            }

            // Otherwise, process RAS event
            else
            {
                switch(wParam)
                {
                case RASCS_OpenPort:
                    AthLoadString(idsRASCS_OpenPort, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_PortOpened:
                    AthLoadString(idsRASCS_PortOpened, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_ConnectDevice:
                    rcs.dwSize = sizeof(RASCONNSTATUS);                    
                    if (pRas->m_hRasConn && RasGetConnectStatus(pRas->m_hRasConn, &rcs) == 0)
                    {
                        AthLoadString(idsRASCS_ConnectDevice, sz, sizeof(sz)/sizeof(TCHAR));
                        wsprintf(szText, sz, rcs.szDeviceName, rcs.szDeviceType);
                        ListBox_AddString(hwndLB, szText);
                    }
                    break;

                case RASCS_DeviceConnected:
                    rcs.dwSize = sizeof(RASCONNSTATUS);                    
                    if (pRas->m_hRasConn && RasGetConnectStatus(pRas->m_hRasConn, &rcs) == 0)
                    {
                        AthLoadString(idsRASCS_DeviceConnected, sz, sizeof(sz)/sizeof(TCHAR));
                        wsprintf(szText, sz, rcs.szDeviceName, rcs.szDeviceType);
                        ListBox_AddString(hwndLB, szText);
                    }
                    break;

                case RASCS_AllDevicesConnected:
                    AthLoadString(idsRASCS_AllDevicesConnected, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_Authenticate:
                    if (s_fAuthStarted == FALSE)
                    {
                        AthLoadString(idsRas_Authentication, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        ListBox_AddString(hwndLB, sz);
                        s_fAuthStarted = TRUE;
                    }
                    break;

                case RASCS_AuthNotify:
                    rcs.dwSize = sizeof(RASCONNSTATUS);                    
                    if (pRas->m_hRasConn && RasGetConnectStatus(pRas->m_hRasConn, &rcs) == 0)
                    {
                        AthLoadString(idsRASCS_AuthNotify, sz, sizeof(sz)/sizeof(TCHAR));
                        wsprintf(szText, sz, rcs.dwError);
                        ListBox_AddString(hwndLB, szText);
                        if (rcs.dwError)
                        {
                            pRas->FailedRasDial(hwnd, hrRasDialFailure, rcs.dwError);
                            if (!pRas->FLogonRetry(hwnd, s_szCancel))
                            {
                                SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                                return 1;
                            }
                        }
                    }
                    break;

                case RASCS_AuthRetry:
                    AthLoadString(idsRASCS_AuthRetry, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_AuthCallback:
                    AthLoadString(idsRASCS_AuthCallback, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_AuthChangePassword:
                    AthLoadString(idsRASCS_AuthChangePassword, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_AuthProject:
                    AthLoadString(idsRASCS_AuthProject, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_AuthLinkSpeed:
                    AthLoadString(idsRASCS_AuthLinkSpeed, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_AuthAck:
                    AthLoadString(idsRASCS_AuthAck, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_ReAuthenticate:
                    AthLoadString(idsRas_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                    AthLoadString(idsRASCS_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_PrepareForCallback:
                    AthLoadString(idsRASCS_PrepareForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_WaitForModemReset:
                    AthLoadString(idsRASCS_WaitForModemReset, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_WaitForCallback:
                    AthLoadString(idsRASCS_WaitForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_Projected:
                    AthLoadString(idsRASCS_Projected, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);
                    break;

                case RASCS_Disconnected:
                    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                    ListBox_AddString(hwndLB, sz);
                    pRas->FailedRasDial(hwnd, hrRasDialFailure, 0);
                    if (!pRas->FLogonRetry(hwnd, s_szCancel))
                    {
                        SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                        return 1;
                    }
                    break;

                case RASCS_Connected:
                    SetDwOption(OPT_RASCONNDETAILS, s_fDetails);
                    AthLoadString(idsRASCS_Connected, sz, sizeof(sz)/sizeof(TCHAR));
                    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                    ListBox_AddString(hwndLB, sz);
                    EndDialog(hwnd, S_OK);
                    break;
                }

                // Select last lb item
                SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);
            }
            return 1;
        }
        break;
    }

    // Done
    return 0;
}

// =====================================================================================
// CRas::FLogonRetry
// =====================================================================================
BOOL CRas::FLogonRetry(HWND hwnd, LPTSTR pszCancel)
{
    // Locals
    DWORD       dwRasError;

    // Reset Cancel button
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), pszCancel);

    // Empty the listbox
    ListBox_ResetContent(GetDlgItem(hwnd, idlbDetails));

    while(1)
    {
        // If failed...
        if (FAILED(HrRasLogon(hwnd, TRUE)))
            return FALSE;

        // Dial the connection
        m_hRasConn = NULL;
        dwRasError = RasDial(NULL, NULL, &m_rdp, 0xFFFFFFFF, hwnd, &m_hRasConn);
        if (dwRasError)
        {
            FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
            continue;
        }

        // Success
        break;
    }

    // Done
    return TRUE;
}

// =====================================================================================
// CRas::FailedRasDial
// =====================================================================================
VOID CRas::FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError)
{
    // Locals
    TCHAR           sz[255];

    // Hangup the connection
    if (m_hRasConn)
        FRasHangupAndWait(m_hRasConn, DEF_HANGUP_WAIT);

    // Disconnected
    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);

    // Save dwRasError
    HrRasError(hwnd, hrRasError, dwRasError);

    // NULL it
    m_hRasConn = NULL;

    // Change dialog button to OK
    AthLoadString(idsOK, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), sz);
}

// =====================================================================================
// CRas::Disconnect
// =====================================================================================
VOID CRas::Disconnect(HWND hwnd, BOOL fShutdown)
{
    // If not using RAS, who give a crap
    if (m_iConnectType != iConnectRAS)
    {
        Assert(m_hRasConn == NULL);
        Assert(m_fIStartedRas == FALSE);
        goto exit;
    }

    // Do we have a RAS connection
    if (m_hRasConn && (m_fIStartedRas || m_fForceHangup))
    {
        // Locals
        TCHAR szRes[255];
        TCHAR szMsg[255];
        INT   nAnswer=IDYES;

        // If Shutdown, lets prompt the user
        if (fShutdown)
        {
            // Remember were shuting down
            m_fShutdown = TRUE;

            // Prompt
            AthLoadString(idsRasPromptDisconnect, szRes, sizeof(szRes)/sizeof(TCHAR));
            wsprintf(szMsg, szRes, m_szCurrentConnectName);

            // Prompt shutdown ?
            nAnswer = AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, 0, MB_YESNO | MB_ICONEXCLAMATION );
        }
        else
            AssertSz(m_fShutdown == FALSE, "Disconnect better not have been called with fShutdown = TRUE, and then FALSE");

        // Hangup
        if (nAnswer == IDYES)
        {
            FRasHangupAndWait(m_hRasConn, DEF_HANGUP_WAIT);
            m_hRasConn = NULL;
            m_fIStartedRas = FALSE;
            *m_szCurrentConnectName = _T('\0');
        }
    }

    // Otherwise, reset state
    else
    {
        // Leave current connection informtaion
        m_hRasConn = NULL;
        m_fIStartedRas = FALSE;
    }

exit:
    // Done
    return;
}

// ****************************************************************************************
// Simple RAS Utility Functions
// ****************************************************************************************

// =====================================================================================
// HrVerifyRasLoaded
// =====================================================================================
HRESULT HrVerifyRasLoaded(VOID)
{
    // Locals
    UINT uOldErrorMode;

    // Protected
    EnterCriticalSection(&g_rCritSec);

    // If dll is loaded, lets verify all of my function pointers
    if (!g_hInstRas)
    {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        g_hInstRas = LoadLibrary(szRasDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!g_hInstRas)
            goto failure;

        // Did we load it
        g_pRasDial = (RASDIALPROC)GetProcAddress(g_hInstRas, szRasDial);
        g_pRasEnumConnections = (RASENUMCONNECTIONSPROC)GetProcAddress(g_hInstRas, szRasEnumConnections);                    
        g_pRasEnumEntries = (RASENUMENTRIESPROC)GetProcAddress(g_hInstRas, szRasEnumEntries);                    
        g_pRasGetConnectStatus = (RASGETCONNECTSTATUSPROC)GetProcAddress(g_hInstRas, szRasGetConnectStatus);                    
        g_pRasGetErrorString = (RASGETERRORSTRINGPROC)GetProcAddress(g_hInstRas, szRasGetErrorString);                    
        g_pRasHangup = (RASHANGUPPROC)GetProcAddress(g_hInstRas, szRasHangup);                    
        g_pRasSetEntryDialParams = (RASSETENTRYDIALPARAMSPROC)GetProcAddress(g_hInstRas, szRasSetEntryDialParams);                    
        g_pRasGetEntryDialParams = (RASGETENTRYDIALPARAMSPROC)GetProcAddress(g_hInstRas, szRasGetEntryDialParams);
        g_pRasCreatePhonebookEntry = (RASCREATEPHONEBOOKENTRYPROC)GetProcAddress(g_hInstRas, szRasCreatePhonebookEntry);    
        g_pRasEditPhonebookEntry = (RASEDITPHONEBOOKENTRYPROC)GetProcAddress(g_hInstRas, szRasEditPhonebookEntry);    
    }

    if (!g_hInstRasDlg && FIsPlatformWinNT())
    {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        g_hInstRasDlg = LoadLibrary(s_szRasDlgDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!g_hInstRasDlg)
            goto failure;

        g_pRasDialDlg = (RASDIALDLGPROC)GetProcAddress(g_hInstRasDlg, s_szRasDialDlg);

        if (!g_pRasDialDlg)
            goto failure;
    }

    // Make sure all functions have been loaded
    if (g_pRasDial                      &&
        g_pRasEnumConnections           &&
        g_pRasEnumEntries               &&
        g_pRasGetConnectStatus          &&
        g_pRasGetErrorString            &&
        g_pRasHangup                    &&
        g_pRasSetEntryDialParams        &&
        g_pRasGetEntryDialParams        &&
        g_pRasCreatePhonebookEntry      &&
        g_pRasEditPhonebookEntry)
    {
        // Protected
        LeaveCriticalSection(&g_rCritSec);

        // Success
        return S_OK;
    }

failure:
    // Protected
    LeaveCriticalSection(&g_rCritSec);

    // Otherwise, were hosed
    return TRAPHR(hrRasInitFailure);
}

// =====================================================================================
// CombinedRasError
// =====================================================================================
VOID CombinedRasError(HWND hwnd, UINT unids, LPTSTR pszRasError, DWORD dwRasError)
{
    // Locals
    TCHAR           szRes[255],
                    sz[30];
    LPTSTR          pszError=NULL;

    // Load string
    AthLoadString(unids, szRes, sizeof(szRes));

    // Allocate memory for errors
    pszError = SzStrAlloc(lstrlen(szRes) + lstrlen(pszRasError) + 100);

    // Out of Memory ?
    if (!pszError)
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), szRes, 0, MB_OK | MB_ICONSTOP);

    // Build Error message
    else
    {
        AthLoadString(idsErrorText, sz, sizeof(sz));
        wsprintf(pszError, "%s\n\n%s %d: %s", szRes, sz, dwRasError, pszRasError);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), pszError, 0, MB_OK | MB_ICONSTOP);
        MemFree(pszError);
    }
}

// =====================================================================================
// HrRasError
// =====================================================================================
HRESULT HrRasError(HWND hwnd, HRESULT hrRasError, DWORD dwRasError)
{
    // Locals
    TCHAR       szRasError[256];
    BOOL        fRasError=FALSE;

    // No Error
    if (SUCCEEDED(hrRasError))
        return hrRasError;

    // Look up RAS error
    if (dwRasError)
    {
        if (RasGetErrorString(dwRasError, szRasError, sizeof(szRasError)) == 0)
            fRasError = TRUE;
        else
            *szRasError = _T('\0');
    }

    // General Error
    switch(hrRasError)
    {
    case hrUserCancel:
        break;

    case hrMemory:
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
        break;

    case hrRasInitFailure:
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasInitFailure), 0, MB_OK | MB_ICONSTOP);
        break;

    case hrRasDialFailure:
        if (fRasError)
            CombinedRasError(hwnd, HR_CODE(hrRasDialFailure), szRasError, dwRasError);
        else
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasDialFailure), 0, MB_OK | MB_ICONSTOP);
        break;

    case hrRasServerNotFound:
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasServerNotFound), 0, MB_OK | MB_ICONSTOP);
        break;

    case hrGetDialParamsFailed:
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrGetDialParamsFailed), 0, MB_OK | MB_ICONSTOP);
        break;

    case E_FAIL:
    default:
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsRasErrorGeneral), 0, MB_OK | MB_ICONSTOP);
        break;
    }

    // Done
    return hrRasError;
}

// =====================================================================================
// FEnumerateConnections
// =====================================================================================
BOOL FEnumerateConnections(LPRASCONN *ppRasConn, ULONG *pcConnections)
{
    // Locals
    DWORD       dw, 
                dwSize;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(ppRasConn && pcConnections);

    // Make sure RAS is loaded
    if (FAILED(HrVerifyRasLoaded()))
        goto exit;

    // Init
    *ppRasConn = NULL;
    *pcConnections = 0;

    // Sizeof my buffer
    dwSize = sizeof(RASCONN);

    // Allocate enough for 1 ras connection info object
    if (!MemAlloc((LPVOID *)ppRasConn, dwSize))
    {
        TRAPHR(hrMemory);
        goto exit;
    }

    // Buffer size
    (*ppRasConn)->dwSize = dwSize;

    // Enumerate ras connections
    dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);

    // Not enough memory ?
    if (dw == ERROR_BUFFER_TOO_SMALL)
    {
        // Reallocate
        if (!MemRealloc((LPVOID *)ppRasConn, dwSize))
        {
            TRAPHR(hrMemory);
            goto exit;
        }

        // Call enumerate again
        *pcConnections = 0;
        (*ppRasConn)->dwSize = sizeof(RASCONN);
        dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);
    }

    // If still failed
    if (dw)
    {
        AssertSz(FALSE, "RasEnumConnections failed");
        goto exit;
    }

    // Success
    fResult = TRUE;

exit:
    // Done
    return fResult;
}

// =====================================================================================
// FFindConnection
// =====================================================================================
BOOL FFindConnection(LPTSTR lpszEntry, LPHRASCONN phRasConn)
{
    // Locals
    ULONG       cConnections,
                i;
    LPRASCONN   pRasConn=NULL;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(lpszEntry && phRasConn);

    // Make sure RAS is loaded
    if (FAILED(HrVerifyRasLoaded()))
        goto exit;

    // Init
    *phRasConn = NULL;

    // Enumerate Connections
    if (!FEnumerateConnections(&pRasConn, &cConnections))
        goto exit;

    // If still failed
    for (i=0; i<cConnections; i++)
    {
        if (lstrcmpi(pRasConn[i].szEntryName, lpszEntry) == 0)
        {
            *phRasConn = pRasConn[i].hrasconn;
            fResult = TRUE;
            goto exit;
        }
    }

exit:
    // Cleanup
    SafeMemFree(pRasConn);

    // Done
    return fResult;
}

// ==================================================================================================================
// FRasHangupAndWait
// ==================================================================================================================
BOOL FRasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds)
{
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();

    // Check Params
    if (!hRasConn)
        return 0;

    // Make sure RAS is loaded
    if (FAILED (HrVerifyRasLoaded()))
        return FALSE;

    // Call Ras hangup
    if (RasHangup(hRasConn))
        return FALSE;

    // Wait for connection to really close
    while (RasGetConnectStatus(hRasConn, &rcs) == 0)
    {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
    }

    // Wait 1/2 seconds for modem to reset
    Sleep(500);

    // Done
    return TRUE;
}

// ==================================================================================================================
// FillRasCombo
// ==================================================================================================================
VOID FillRasCombo(HWND hwndCtl, BOOL fUpdateOnly)
{
    LPRASENTRYNAME lprasentry=NULL;
    DWORD dwSize;
    DWORD cEntries;
    DWORD dwError;

    // Make sure RAS is loaded
    if (FAILED (HrVerifyRasLoaded()))
        return;

    if (!fUpdateOnly)
        SendMessage(hwndCtl, CB_RESETCONTENT,0,0);
    
    dwSize = sizeof(RASENTRYNAME);
    if (!MemAlloc((LPVOID*) &lprasentry, dwSize))
        return;
        
    lprasentry->dwSize = sizeof(RASENTRYNAME);
    cEntries = 0;
    dwError = RasEnumEntries(NULL, NULL, lprasentry, &dwSize, &cEntries);
    if (dwError == ERROR_BUFFER_TOO_SMALL)
        {
        MemFree(lprasentry);
        MemAlloc((LPVOID*) &lprasentry, dwSize);
        lprasentry->dwSize = sizeof(RASENTRYNAME);
        cEntries = 0;
        dwError = RasEnumEntries(NULL, NULL, lprasentry, &dwSize, &cEntries);        
        }

    if (dwError)
        goto error;
        
    while(cEntries)
        {
        if (!fUpdateOnly)
            SendMessage(hwndCtl, CB_ADDSTRING, 0, 
                        (LPARAM)(lprasentry[cEntries-1].szEntryName));
        else
            {
            if (ComboBox_FindStringExact(hwndCtl, 0, 
                                         lprasentry[cEntries - 1].szEntryName) < 0)
                {
                int iSel = ComboBox_AddString(hwndCtl, 
                                              lprasentry[cEntries - 1].szEntryName);
                Assert(iSel >= 0);
                ComboBox_SetCurSel(hwndCtl, iSel);
                }
            }
            
        cEntries--;
        }

error:    
    MemFree(lprasentry);
}

// ==================================================================================================================
// EditPhoneBookEntry
// ==================================================================================================================
DWORD EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName)
{
    if (FAILED(HrVerifyRasLoaded()))
        return (DWORD)E_FAIL;

    return RasEditPhonebookEntry(hwnd, NULL, pszEntryName);
}

// ==================================================================================================================
// CreatePhonebookEntry
// ==================================================================================================================
DWORD CreatePhonebookEntry(HWND hwnd)
{
    if (FAILED(HrVerifyRasLoaded()))
        return (DWORD)E_FAIL;

    return RasCreatePhonebookEntry(hwnd, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\regutil.h ===
#ifndef _INC_REGUTIL_H
#define _INC_REGUTIL_H

#ifdef WIN16
EXTERN_C {
#endif
HRESULT WINAPI  SetDefaultNewsHandler(DWORD dwFlags);
HRESULT WINAPI  SetDefaultMailHandler(DWORD dwFlags); // dwFlags is unused, just to be consistent with SetDefaultNewsHandler()
BOOL    WINAPI  FIsDefaultNewsConfiged(DWORD dwFlags);    
BOOL    WINAPI  FIsDefaultMailConfiged(void);    
#ifdef WIN16
}
#endif

BOOL GetAthenaRegPath(TCHAR *szAthenaDll, DWORD cch);
//BOOL GetExePath(LPCTSTR szExe, TCHAR *szPath, DWORD cch, BOOL fDirOnly);

#define RESTORE_MAIL    0x0001
#define RESTORE_NEWS    0x0002

#define DEFAULT_MAIL        1
#define DEFAULT_NEWS        2
#define DEFAULT_NEWSONLY    4
#define DEFAULT_OUTNEWS     8
#define DEFAULT_UI          16
#define DEFAULT_DONTFORCE   32
#define DEFAULT_SETUPMODE   64

#define NOT_HANDLED     -1
#define HANDLED_OTHER   0
#define HANDLED_URLDLL  1
#define HANDLED_OLD     2
#define HANDLED_CURR    3
#define HANDLED_OUTLOOK 4

int DefaultClientSet(LPCTSTR pszClient);

void SetDefaultClient(LPCTSTR pszClient, LPCTSTR pszProduct);

HRESULT ISetDefaultMailHandler(LPCTSTR pszProduct, DWORD dwFlags);
HRESULT ISetDefaultNewsHandler(LPCTSTR pszProduct, DWORD dwFlags);

BOOL    SetRegValue (BOOL bVal,BOOL bMessageBox);
BOOL    GetRegValue();
BOOL    FValidClient(LPCTSTR pszClient, LPCTSTR pszProduct);

HRESULT GetCLSIDFromSubKey(HKEY hKey, LPSTR rgchBuf, ULONG *pcbBuf);

#endif // _INC_REGUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\reutil.cpp ===
//*************************************************
//     r e u t i l . c p p
//
//      Purpose:
//          implements calls to Richedit controls
//
//      Owner:
//          dhaws
//
//      History:
//          March 1999: Created
//*************************************************

#include "pch.hxx"
#include "reutil.h"
#include "richole.h"
#include "richedit.h"
#include "textserv.h"
#include "shlwapip.h"
#include "mirror.h"
#include "strconst.h"
#include <demand.h>     // must be last!

static HINSTANCE    g_hRichEditDll = NULL;
static DWORD        g_dwRicheditVer = 0;

// @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
static BOOL         g_fSpecialRTLRichedit = FALSE;

// Keep these around for future reference
static const CHAR g_szRE10[] = "RichEdit";
static const CHAR g_szRE20[] = "RichEdit20A";
static const WCHAR g_wszRE10[] = L"RichEdit";
static const WCHAR g_wszRE20[] = L"RichEdit20W";

BOOL FInitRichEdit(BOOL fInit)
{
    if(fInit)
    {
        if(!g_hRichEditDll)
        {
            g_hRichEditDll = LoadLibrary("RICHED20.DLL");
            if (g_hRichEditDll)
            {
                TCHAR               szPath[MAX_PATH], 
                                    szGet[MAX_PATH];
                BOOL                fSucceeded = FALSE;
                DWORD               dwVerInfoSize = 0, 
                                    dwVerHnd = 0,
                                    dwProdNum = 0,
                                    dwMajNum = 0,
                                    dwMinNum = 0;
                LPSTR               lpInfo = NULL, 
                                    lpVersion = NULL;
                LPWORD              lpwTrans;
                UINT                uLen;
                HKEY                hkey;
                DWORD               dw=0, 
                                    cb;

                if (GetModuleFileName(g_hRichEditDll, szPath, ARRAYSIZE(szPath)))
                {
                    dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd);
                    if (dwVerInfoSize)
                    {
                        lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize);
                        if (lpInfo)
                        {
                            if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, lpInfo))
                            {
                                if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) && 
                                    uLen >= (2 * sizeof(WORD)))
                                {
                                    // set up buffer for calls to VerQueryValue()
                                    wsprintf(szGet, "\\StringFileInfo\\%04X%04X\\FileVersion", lpwTrans[0], lpwTrans[1]);
                                    if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                    {
                                        while (('.' != *lpVersion) && (',' != *lpVersion) && (0 != *lpVersion))
                                        {
                                            dwProdNum *= 10;
                                            dwProdNum += (*lpVersion++ - '0');
                                        }

                                        if (5 == dwProdNum)
                                        {
                                            if (('.' == *lpVersion) || (',' == *lpVersion))
                                                lpVersion++;
                                            while (('.' != *lpVersion) && (',' != *lpVersion) && (0 != *lpVersion))
                                            {
                                                dwMajNum *= 10;
                                                dwMajNum += (*lpVersion++ - '0');
                                            }
                                            g_dwRicheditVer = (dwMajNum >= 30) ? 3 : 2;

                                            // @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
                                            if ((2 == g_dwRicheditVer) && (0 != *lpVersion))
                                            {
                                                // Check to see if we have turned on the magic key to disable this stuff
                                                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegRoot, 0, KEY_QUERY_VALUE, &hkey))
                                                {
                                                    cb = sizeof(dw);
                                                    RegQueryValueEx(hkey, c_szRegRTLRichEditHACK, 0, NULL, (LPBYTE)&dw, &cb);
                                                    RegCloseKey(hkey);
                                                }

                                                // If we didn't find the key, or it is 0, then check to see if we are
                                                // dealing with those special richedits
                                                if (0 == dw)
                                                {
                                                    if (('.' == *lpVersion) || (',' == *lpVersion))
                                                        lpVersion++;
                                                    while (('.' != *lpVersion) && (',' != *lpVersion) && (0 != *lpVersion))
                                                    {
                                                        dwMinNum *= 10;
                                                        dwMinNum += (*lpVersion++ - '0');
                                                    }
                                                    g_fSpecialRTLRichedit = (dwMinNum >= 330);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // Treat this as richedit version 3.0
                                            Assert(5 < dwProdNum);
                                            g_dwRicheditVer = 3;
                                        }
                                        fSucceeded = TRUE;
                                    }
                                }
                            }
                            GlobalFree((HGLOBAL)lpInfo);
                        }
                    }
                }

                if (!fSucceeded)
                {
                    FreeLibrary(g_hRichEditDll);
                    g_hRichEditDll=NULL;
                }
            }
        }

        if(!g_hRichEditDll)
        {
            g_hRichEditDll=LoadLibrary("RICHED32.DLL");
            g_dwRicheditVer = 1;
        }

        if(!g_hRichEditDll)
            AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrLoadingHtmlEdit), NULL, MB_OK);
        
        return (BOOL)(0 != g_hRichEditDll);
    }
    else
    {
        if(g_hRichEditDll)
            FreeLibrary(g_hRichEditDll);
        g_hRichEditDll=NULL;
        g_dwRicheditVer = 0;
        return TRUE;
    }
}

LPCSTR GetREClassStringA(void)
{
    switch (g_dwRicheditVer)
    {
        case 1:
            return g_szRE10;

        case 2:
        case 3:
            return g_szRE20;

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            return NULL;
    }
}

LPCWSTR GetREClassStringW(void)
{
    switch (g_dwRicheditVer)
    {
        case 1:
            return g_wszRE10;

        case 2:
        case 3:
            return g_wszRE20;

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            return NULL;
    }
}

typedef struct tagHWNDORDERSTRUCT {
    HWND    hwndTemplate;
    HWND    hwndRichEdit;
    HWND   *phwnd;
} HWNDORDERSTRUCT;

BOOL CALLBACK CountChildrenProc(HWND hwnd, LPARAM lParam)
{
    DWORD *pcCount = (DWORD*)lParam;
    (*pcCount)++;
    return TRUE;
}

// This function basically will take the order of the hwnds on the dialog
// and store that order in the prder->phwnd variable so that we can maintain
// the taborder on the dialog windows. The only special case we have to do
// is with the template. In the case of the template, we need to substitute
// in the richedit into the order.
BOOL CALLBACK BuildOrderProc(HWND hwnd, LPARAM lParam)
{
    HWNDORDERSTRUCT *pOrder = (HWNDORDERSTRUCT*)lParam;

    if (hwnd == pOrder->hwndTemplate)
        *pOrder->phwnd = pOrder->hwndRichEdit;
    else
        *pOrder->phwnd = hwnd;

    pOrder->phwnd++;

    return TRUE;
}

HWND CreateREInDialogA(HWND hwndParent, int iID)
{
    HWND            hwndTemplate = GetDlgItem(hwndParent, idredtTemplate);
    RECT            rcTemplate;
    int             width, 
                    height;
    HWND            hwndNewRE = 0;
    DWORD           cCount = 0;
    HWNDORDERSTRUCT hos;

    CHAR szTitle[CCHMAX_STRINGRES]; 

    Assert(IsWindow(hwndParent));
    Assert(iID);
    AssertSz(IsWindow(hwndTemplate), "Must have a template control for this to work.");

    *szTitle = 0;
    ShowWindow(hwndTemplate, SW_HIDE);
    GetWindowText(hwndTemplate, szTitle, ARRAYSIZE(szTitle));

    // Get location of place holder so we can create the richedit over it
    GetWindowRect(hwndTemplate, &rcTemplate);

    // Map Screen coordinates to dialog coordinates
    MapWindowPoints(NULL, hwndParent, (LPPOINT)&rcTemplate, 2);

    width = rcTemplate.right - rcTemplate.left;
    height = rcTemplate.bottom - rcTemplate.top;

    hwndNewRE = CreateWindow(GetREClassStringA(), 
                             szTitle, 
                             ES_MULTILINE|ES_READONLY|ES_SAVESEL|ES_AUTOVSCROLL|
                             WS_BORDER|WS_VSCROLL|WS_TABSTOP|WS_CHILD,
                             rcTemplate.left, rcTemplate.top, width, height,
                             hwndParent, 
                             (HMENU)IntToPtr(iID),
                             g_hInst, NULL);

    // Count number of child windows in the dialog
    if (EnumChildWindows(hwndParent, CountChildrenProc, (LPARAM)&cCount))
    {
        HWND *phwnd = (HWND*)ZeroAllocate(cCount*sizeof(HWND));

        if (phwnd)
        {
            hos.hwndRichEdit = hwndNewRE;
            hos.hwndTemplate = hwndTemplate;
            hos.phwnd = phwnd;

            // Create ordered list of dialog children hwnds.
            if (EnumChildWindows(hwndParent, BuildOrderProc, (LPARAM)&hos))
            {
                cCount--;

                // So this next section is basically going to reparent all the
                // controls in the order setup in the phwnd array. By setting 
                // the parent of the window, we basically set the taborder of that
                // item to be the first in line. That is why we reparent the controls
                // in reverse order.
                HWND *pCurr = &phwnd[cCount];
                while(cCount)
                {
                    SetParent(*pCurr, SetParent(*pCurr, NULL));
                    pCurr--;
                    cCount--;
                }
            }
            MemFree(phwnd);
        }
    }

    return hwndNewRE;
}

LONG RichEditNormalizeCharPos(HWND hwnd, LONG lByte, LPCSTR pszText)
{
    LPWSTR      pwszText = NULL;
    LPSTR       pszConv = NULL;
    LONG        cch;
    HRESULT     hr = S_OK;

    //on anything other than richedit 1, we're already normalized
    if(1!=g_dwRicheditVer) return lByte;

    if(NULL == pszText)
    {
        cch = GetWindowTextLengthWrapW(hwnd);
    
        if (0 == cch)
            return 0;
    
        cch += 1; // for a null
        if (lByte >= cch)
            return cch;
    
        IF_NULLEXIT(MemAlloc((LPVOID*) &pwszText, cch * sizeof(WCHAR)));
        *pwszText = '\0';

        GetRichEditText(hwnd, pwszText, cch, FALSE, NULL);
        IF_NULLEXIT((pszConv = PszToANSI(CP_ACP, pwszText)));
        pszText = pszConv;
    }

    cch = 0;
    while(lByte > 0) // lByte is zero-based
    {
        cch++;

        if (IsDBCSLeadByte(*pszText)){
            pszText++;
            lByte--;
        }
        
        pszText++;
        lByte--;
    }

exit:
    MemFree(pwszText);
    MemFree(pszConv);
    return FAILED(hr)?0:cch;
}

LONG GetRichEditTextLen(HWND hwnd)
{
    switch (g_dwRicheditVer)
    {
        // we always want to return the number of chars; riched 1 will always return
        // the number of bytes; we need to convert...
        case 1:
        {
            LPWSTR      pwszText = NULL;
            DWORD       cch;

            cch = GetWindowTextLengthWrapW(hwnd);
            if (0 == cch)
                return 0;

            cch += 1; // for a null
            if (!MemAlloc((LPVOID*) &pwszText, cch * sizeof(WCHAR)))
                return 0;
            *pwszText = '\0';

            GetRichEditText(hwnd, pwszText, cch, FALSE, NULL);
            
            cch = lstrlenW(pwszText);
            MemFree(pwszText);

            return cch;
        }

        case 2:
        case 3:
        {
            GETTEXTLENGTHEX rTxtStruct;

            if (!hwnd)
                return 0;

            rTxtStruct.flags = GTL_DEFAULT;
            rTxtStruct.codepage = CP_UNICODE;

            return (LONG) SendMessage(hwnd, EM_GETTEXTLENGTHEX, (WPARAM)&rTxtStruct, 0);
        }

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            return 0;
    }
}

DWORD GetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD cchNumChars, BOOL fSelection, ITextDocument *pDoc)
{
    switch (g_dwRicheditVer)
    {
        case 1:
        {
            if (fSelection)
                return (DWORD)SendMessageWrapW(hwnd, EM_GETSELTEXT, 0, (LPARAM)pwchBuff);
            else
                return GetWindowTextWrapW(hwnd, pwchBuff, cchNumChars);
        }

        case 2:
        case 3:
        {
            DWORD cchLen = 0;
            if (!hwnd || !cchNumChars)
                return 0;

            Assert(pwchBuff);

            *pwchBuff = 0;

            if (!fSelection)
            {
                GETTEXTEX rTxtStruct;

                rTxtStruct.cb = cchNumChars * sizeof(WCHAR);
                rTxtStruct.flags = GT_DEFAULT;
                rTxtStruct.codepage = CP_UNICODE;

                cchLen = (DWORD) SendMessage(hwnd, EM_GETTEXTEX, (WPARAM)&rTxtStruct, (LPARAM)pwchBuff);
            }
            else
            {
                // There is no way to get a selection of UNICODE
                // without going through TOM
                ITextSelection *pSelRange = NULL;
                ITextDocument  *pDocToFree = NULL;
                BSTR            bstr = NULL;

                if (!pDoc)
                {
                    LPRICHEDITOLE   preole = NULL;
                    LRESULT result = SendMessage(hwnd, EM_GETOLEINTERFACE, NULL, (LPARAM)&preole);
                    Assert(result);
                    Assert(preole);

                    HRESULT hr = preole->QueryInterface(IID_ITextDocument, (LPVOID*)&pDocToFree);
                    ReleaseObj(preole);
                    TraceResult(hr);
                    if (FAILED(hr))
                        return 0;

                    pDoc = pDocToFree;

                }

                if (SUCCEEDED(pDoc->GetSelection(&pSelRange)))
                {
                    if (SUCCEEDED(pSelRange->GetText(&bstr)) && bstr)
                    {
                        cchLen = SysStringLen(bstr);
                        if (cchLen > 0)
                        {
                            if (cchLen < cchNumChars)
                                StrCpyW(pwchBuff, bstr);
                            else
                                cchLen = 0;

                        }
                        SysFreeString(bstr);
                    }
                    ReleaseObj(pSelRange);
                }
                ReleaseObj(pDocToFree);
            }
            return cchLen;
        }

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            return 0;
    }
}

void SetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplaceSel, ITextDocument *pDoc, BOOL fReadOnly)
{
    if (!hwnd)
        return;

    switch (g_dwRicheditVer)
    {
        case 1:
        {
            if (fReplaceSel)
                SendMessageWrapW(hwnd, EM_REPLACESEL, 0, (LPARAM)pwchBuff);
            else
                SetWindowTextWrapW(hwnd, pwchBuff);
            break;
        }

        case 2:
        {
            ITextServices  *pService = NULL;
            ITextDocument  *pDocToFree = NULL;

            if (!pDoc)
            {
                LPRICHEDITOLE   preole = NULL;
                LRESULT result = SendMessage(hwnd, EM_GETOLEINTERFACE, NULL, (LPARAM)&preole);
                Assert(result);
                Assert(preole);

                HRESULT hr = preole->QueryInterface(IID_ITextDocument, (LPVOID*)&pDocToFree);
                ReleaseObj(preole);
                TraceResult(hr);
                if (FAILED(hr))
                    return;

                pDoc = pDocToFree;

            }

            if (FAILED(pDoc->QueryInterface(IID_ITextServices, (LPVOID*)&pService)))
                return;

            if (!fReplaceSel)
            {
                // TxSetText is documented as a LPCTSTR, but RichEdit always
                // compiles with UNICODE turned on, so we are OK here.
                pService->TxSetText(pwchBuff);
            }
            else
            {
                HRESULT         hr;
                ITextSelection *pSelRange = NULL;
                BSTR            bstr = SysAllocString(pwchBuff);

                hr = pDoc->GetSelection(&pSelRange);
                
                if (SUCCEEDED(hr) && pSelRange)
                {
                    if (fReadOnly)
                        pService->OnTxPropertyBitsChange(TXTBIT_READONLY, 0);

                    // If we are readonly, SetText will fail if we don't do the TXTBIT setting
                    hr = pSelRange->SetText(bstr);
                    if (FAILED(hr))
                        TraceResult(hr);

                    // Richedit 2.0 doesn't always collapse to the end of the selection.
                    pSelRange->Collapse(tomEnd);

                    if (fReadOnly)
                        pService->OnTxPropertyBitsChange(TXTBIT_READONLY, TXTBIT_READONLY);

                    pSelRange->Release();
                }
                else
                    TraceResult(hr);

                SysFreeString(bstr);
            }
            ReleaseObj(pDocToFree);
            pService->Release();
            break;
        }

        case 3:
        {
            // pwchBuff can be NULL. NULL means that we are clearing the field.
            SETTEXTEX rTxtStruct;

            rTxtStruct.flags = fReplaceSel ? ST_SELECTION : ST_DEFAULT;
            rTxtStruct.codepage = CP_UNICODE;

            // EM_SETTEXTEX will fail with RichEdit 2.0.
            SendMessage(hwnd, EM_SETTEXTEX, (WPARAM)&rTxtStruct, (LPARAM)pwchBuff);
            break;
        }

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            break;
    }
}

void SetFontOnRichEdit(HWND hwnd, HFONT hfont)
{
    switch (g_dwRicheditVer)
    {
        case 1:
        case 3:
        {
            CHARFORMAT      cf;
            if (SUCCEEDED(FontToCharformat(hfont, &cf)))
            {
                SideAssert(FALSE != SendMessage(hwnd, EM_SETCHARFORMAT, (WPARAM) 0, (LPARAM) &cf));
            }
            break;
        }

        case 2:
            SideAssert(FALSE != SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE, 0)));
            break;

        default:
            AssertSz(FALSE, "Bad Richedit Version");
            break;
    }
}

///////////////////////////////////////////////////////////////////////////////
//  RichEditExSetSel
//
// Raid 79304.  Rich Edit Control version 1.0 does not handle
// the EM_EXSETSEL message correctly for text with DBCS characters.  It sets
// the selection range based on bytes on not double byte characters.  
///////////////////////////////////////////////////////////////////////////////
LRESULT RichEditExSetSel(HWND hwnd, CHARRANGE *pchrg)
{
    // We only need to deal with this on richedit 1 or we aren't selecting entire text
    Assert(pchrg);

    if ((1 == g_dwRicheditVer) && (-1 != pchrg->cpMax))
    {
        LRESULT     lResult = 0;
        LPWSTR      pwszText = NULL;
        LPSTR       pszConv = NULL, pszText = NULL;
        CHARRANGE   chrg={0};
        CHARRANGE   chrgIn;
        DWORD       cch, cDBCSBefore = 0, cDBCSIn = 0;

        chrgIn = *pchrg;

        // Get the text string for this control
        cch = GetRichEditTextLen(hwnd) + 1;
        if (0 == cch)
            return lResult;
        if (!MemAlloc((LPVOID*) &pwszText, cch * sizeof(WCHAR)))
            return lResult;
        *pwszText = '\0';

        // Richedit 1.0 will never have a pDoc, so don't pass one in
        GetRichEditText(hwnd, pwszText, cch, FALSE, NULL);
        pszConv = PszToANSI(CP_ACP, pwszText);
        pszText = pszConv;
        SafeMemFree(pwszText);
        if (!pszText)
        {
            Assert(0);
            return lResult;
        }

        // Compute the BYTE range based on DBCS characters
        if (chrgIn.cpMax >= chrgIn.cpMin)
        {
            chrgIn.cpMax -= chrgIn.cpMin;

            // Look for DBCS chars before selection
            while ((chrgIn.cpMin > 0) && *pszText)
            {
                if ( IsDBCSLeadByte(*pszText) )
                {
                    cDBCSBefore++;
                    pszText += 2;
                }
                else
                {
                    pszText++;
                }
                
                chrgIn.cpMin--;
            }
            
            // Look for DBCS chars in selection
            while ((chrgIn.cpMax > 0) && *pszText)
            {
                if ( IsDBCSLeadByte(*pszText) )
                {
                    cDBCSIn++;
                    pszText += 2;
                }
                else
                {
                    pszText++;
                }

                chrgIn.cpMax--;
            }

            chrg.cpMin = pchrg->cpMin + cDBCSBefore;
            chrg.cpMax = pchrg->cpMax + cDBCSBefore + cDBCSIn;
        }
        MemFree(pszConv);

        lResult = SendMessageA(hwnd, EM_EXSETSEL, 0, (LPARAM)&chrg);

        return lResult;
    }
    else
        return SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)pchrg);
}

LRESULT RichEditExGetSel(HWND hwnd, CHARRANGE *pchrg)
{   
    LRESULT     lResult;
    LPWSTR      pwszText = NULL;
    LPSTR       pszText = NULL;
    LONG        cch;
    HRESULT     hr;

    Assert(pchrg);

    // We only need to deal with this on richedit 1 
    if (1 == g_dwRicheditVer)
    {
        lResult = SendMessageA(hwnd, EM_EXGETSEL, 0, (LPARAM)pchrg);

        cch = GetWindowTextLengthWrapW(hwnd);

        if (0 == cch)
            goto exit;

        IF_NULLEXIT(MemAlloc((LPVOID*) &pwszText, cch * sizeof(WCHAR)));
        *pwszText = '\0';

        GetRichEditText(hwnd, pwszText, cch, FALSE, NULL);
        IF_NULLEXIT((pszText = PszToANSI(CP_ACP, pwszText)));
        
        pchrg->cpMin = RichEditNormalizeCharPos(hwnd, pchrg->cpMin, pszText);
        pchrg->cpMax = RichEditNormalizeCharPos(hwnd, pchrg->cpMax, pszText);
    }
    else
        lResult = SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)pchrg);

exit:
    MemFree(pszText);
    MemFree(pwszText);
    return lResult;
}

// ***************************
// RichEditProtectENChange
//
//  hwnd        = richedit to be protected
//  pdwOldMask  = when fProtect, will return the original mask for the richedit
//                when !fProtect, will be passing in the new mask for the richedit
//                The new value should be the one that was passed back when first called
//  fProtect    = Are we starting the protection or ending it
// 
// Notes:    
//
// This function is to protect the possiblity of a re-entrant notificition
// while processing an EN_CHANGE message within richedit. It turns out that
// all richedits except for ver3 that shipped with Office 2k will protect against
// this themselves. 
//
// This call should always be used in pairs with the first passing TRUE and the
// second passing in false. At this point, is only used to Protect the EN_CHANGE
// notification that is sent to the richedit.
//
// BUGBUG: It might be beneficial at some future date to make the granularity
// of these richedit issues more fine to handle cases like this where most
// v3 richedits handle this correctly.
void RichEditProtectENChange(HWND hwnd, DWORD *pdwOldMask, BOOL fProtect)
{
    Assert(IsWindow(hwnd));
    Assert(pdwOldMask);

    if (3 == g_dwRicheditVer)
    {
        DWORD dwMask = *pdwOldMask;
        if (fProtect)
        {
            dwMask = (DWORD) SendMessage(hwnd, EM_GETEVENTMASK, 0, 0);
            SendMessage(hwnd, EM_SETEVENTMASK, 0, dwMask & (~ENM_CHANGE));
            *pdwOldMask = dwMask;
        }
        else
            SendMessage(hwnd, EM_SETEVENTMASK, 0, dwMask);
    }
}

// @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
void RichEditRTLMirroring(HWND hwndHeader, BOOL fSubject, LONG *plExtendFlags, BOOL fPreRECreation)
{
    if (!g_fSpecialRTLRichedit)
    {
        if (fPreRECreation)
        {
            // a-msadek; RichEdit have a lot of problems with mirroring
            // let's disable mirroring for this child and rather 'simulate' it
            if (IS_WINDOW_RTL_MIRRORED(hwndHeader))
            {
                DISABLE_LAYOUT_INHERITANCE(hwndHeader);
                *plExtendFlags |= WS_EX_LEFTSCROLLBAR |WS_EX_RIGHT;
                if (fSubject)
                {
                    *plExtendFlags |= WS_EX_RTLREADING;
                }    
            }
        }
        else
        {
            if (IS_WINDOW_RTL_MIRRORED(hwndHeader))
            {                                
                ENABLE_LAYOUT_INHERITANCE(hwndHeader);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\reutil.h ===
#pragma once

#include "wtypes.h"
#include "tom.h"

// NOTES:
//
// Here is a list of items that have been found while investigating richedit
// problems with different versions, but were never implemented because we didn't
// need them in the code. Hopefully, this list will expand so someone in the future
// will be able to use any and all info we have found regarding richedit versions
// where we didn't need to write a wrapper.
// 
// 1- EM_GETCHARFORMAT passing in a false is suppose to return the default charformat
//      for the richedit. This works on all versions, except v1. V1 returns a
//      charformat with the mask set to 0.
//
// 2- TOM (Text Object Model) wasn't implemented in v1.
// 
// 3- With richedit 1 and 2, the thumb doesn't show up in the scroll bar if the 
//      richedit isn't big enough to show a certain size. This is why the max
//      number of rows for the multi-line richedits in the header is set to 4. For
//      the default fonts, 3 rows aren't big enough to show the thumb.
//
// Add more if not handled in the functions below.



BOOL FInitRichEdit(BOOL fInit);

LPCSTR GetREClassStringA(void);
LPCWSTR GetREClassStringW(void);

HWND CreateREInDialogA(HWND hwndParent, int iID);

LONG RichEditNormalizeCharPos(HWND hwnd, LONG lByte, LPCSTR pszText);

LONG GetRichEditTextLen(HWND hwnd);

void SetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplaceSel, ITextDocument *pDoc, BOOL fReadOnly);
DWORD GetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD cchNumChars, BOOL fSelection, ITextDocument *pDoc);

void SetFontOnRichEdit(HWND hwnd, HFONT hfont);

LRESULT RichEditExSetSel(HWND hwnd, CHARRANGE *pchrg);
LRESULT RichEditExGetSel(HWND hwnd, CHARRANGE *pchrg);

void RichEditProtectENChange(HWND hwnd, DWORD *pdwOldMask, BOOL fProtect);

// @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
void RichEditRTLMirroring(HWND hwndHeader, BOOL fSubject, LONG *plExtendFlags, BOOL fPreRECreation);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\regutil.cpp ===
#include "pch.hxx"

#include <regutil.h>
#ifndef THOR_SETUP
#include <strconst.h>
#include "shared.h"
#else
#include "strings.h"
#include "util.h"
#endif
#include <ourguid.h>
#include <resource.h>

#ifndef THOR_SETUP
#include <shlwapi.h>
#include "shlwapip.h" 
#define strstr                  StrStr
#define RegDeleteKeyRecursive   SHDeleteKey
#endif // THOR_SETUP
#include "demand.h"

typedef HINSTANCE (STDAPICALLTYPE FGETCOMPONENTPATH)();
typedef FGETCOMPONENTPATH *LPFGETCOMPONENTPATH;
typedef HINSTANCE (STDAPICALLTYPE FIXMAPI)();
typedef FIXMAPI *LPFIXMAPI;

BOOL IsXPSP1OrLater()
{
    BOOL fResult = FALSE;
    
    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
    {
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        {
            if (osvi.dwMajorVersion > 5)
            {
                fResult = TRUE;
            }
            else if (osvi.dwMajorVersion == 5)
            {
                if (osvi.dwMinorVersion > 1)
                {
                    fResult = TRUE;
                }
                else if (osvi.dwMinorVersion == 1)
                {
                    if (osvi.dwBuildNumber > 2600)
                    {
                        fResult = TRUE;
                    }
                    else if (osvi.dwBuildNumber == 2600)
                    {                                
                        HKEY hkey;

                        //  HIVESFT.INF and UPDATE.INF set this for service packs:
                        //  HKLM,SYSTEM\CurrentControlSet\Control\Windows,"CSDVersion",0x10001,0x100
                        
                        LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows"), 0, KEY_QUERY_VALUE, &hkey);

                        if (ERROR_SUCCESS == lResult)
                        {
                            DWORD dwValue;
                            DWORD cbValue = sizeof(dwValue);
                            DWORD dwType;

                            lResult = RegQueryValueEx(hkey, TEXT("CSDVersion"), NULL, &dwType, (LPBYTE)&dwValue, &cbValue);

                            if ((ERROR_SUCCESS == lResult) && (REG_DWORD == dwType) && (dwValue >= 0x100))
                            {
                                fResult = TRUE;
                            }
                            
                            RegCloseKey(hkey);
                        }
                    }
                }
            }
        }
    }

    return fResult;
}


// ********* Tests

// Looks in the registry at a value placed there by msoe.dll's selfreg
BOOL GetAthenaRegPath(TCHAR *szAthenaDll, DWORD cch)
{
    BOOL    fRet;
    HKEY    hkey;
    TCHAR   szPath[MAX_PATH], szExpanded[MAX_PATH];
    DWORD   dwType, cb;
    LPTSTR  psz;
    
    szPath[0] = '\0';
    fRet = FALSE;
    
    wsprintf(szExpanded, c_szProtocolPath, c_szMail, c_szMOE);
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szExpanded, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szPath);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegDllPath, 0, &dwType, (LPBYTE)szPath, &cb) && cb)
        {
            // Remove %values% if needed
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szPath;
            
            lstrcpyn(szAthenaDll, psz, cch);
            fRet = TRUE;
        }
        RegCloseKey(hkey);
    }
    
    return(fRet);
}


#ifdef THOR_SETUP
BOOL GetExePath(LPCTSTR szExe, TCHAR *szPath, DWORD cch, BOOL fDirOnly)
{
    BOOL fRet;
    HKEY hkey;
    DWORD dwType, cb;
    TCHAR sz[MAX_PATH], szT[MAX_PATH];
    
    Assert(szExe != NULL);
    Assert(szPath != NULL);
    
    fRet = FALSE;
    
    wsprintf(sz, c_szPathFileFmt, c_szAppPaths, szExe);
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szT);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, fDirOnly ? c_szRegPath : NULL, 0, &dwType, (LPBYTE)szT, &cb) && cb)
        {
            if (dwType == REG_EXPAND_SZ)
            {
                cb = ExpandEnvironmentStrings(szT, szPath, cch);
                if (cb != 0 && cb <= cch)
                    fRet = TRUE;
            }
            else
            {
                Assert(dwType == REG_SZ);
                lstrcpy(szPath, szT);
                fRet = TRUE;
            }
        }
        
        RegCloseKey(hkey);
    }
    
    return(fRet);
}
#endif


HRESULT GetCLSIDFromSubKey(HKEY hKey, LPSTR rgchBuf, ULONG *pcbBuf)
{
    HKEY    hKeyCLSID;
    DWORD   dwType;
    HRESULT hr=E_FAIL;
    
    // Lets open they server key
    if (RegOpenKeyEx(hKey, c_szCLSID, 0, KEY_READ, &hKeyCLSID) == ERROR_SUCCESS)
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKeyCLSID, NULL, 0, &dwType, (LPBYTE)rgchBuf, pcbBuf) && *pcbBuf)
            hr = S_OK;
        RegCloseKey(hKeyCLSID);
    }    
    
    return hr;
}


//  FUNCTION:   FAssocsOK()
//
//  PURPOSE:    Checks to see if our file-type associations are in place
//
// Returns:
BOOL FAssocsOK(LPCTSTR pszClient, LPCTSTR pszProduct)
{
    HKEY hkeyProtocols;
    HKEY hkeyRealProt;
    HKEY hkeyAppsProt;
    TCHAR szProtPath[MAX_PATH];
    TCHAR szRealPath[MAX_PATH];
    TCHAR szAppPath [MAX_PATH];
    TCHAR szTemp    [MAX_PATH];
    DWORD dwIndex = 0;
    DWORD cb;
    DWORD cbMaxProtocolLen;
    DWORD dwType, dwType2;
    LPTSTR pszURL;
    BOOL fNoProbs = TRUE;
    
    // Open up the corresponding protocols key
    wsprintf(szProtPath, c_szProtocolPath, pszClient, pszProduct);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szProtPath, 0, KEY_READ, &hkeyProtocols))
    {
        // Figure out the longest protocol name
        if (ERROR_SUCCESS == RegQueryInfoKey(hkeyProtocols, NULL, NULL, NULL, NULL, 
                                             &cbMaxProtocolLen, NULL, NULL, NULL, NULL, NULL, NULL))

        {
            // Allow for "\Shell\Open\Command" whose length is 19 + 1 for NT's RegQueryInfoKey
            cbMaxProtocolLen += 20;

            // Allocate buffer for string
            if (MemAlloc((LPVOID*)&pszURL, cbMaxProtocolLen * sizeof(TCHAR)))
            {
                // Enumerate the protocol subkeys
                cb = cbMaxProtocolLen;
                while (fNoProbs && ERROR_SUCCESS == RegEnumKeyEx(hkeyProtocols, dwIndex++, pszURL, &cb, NULL, NULL, NULL, NULL))
                {
                    fNoProbs = FALSE;
                    
                    lstrcpy(&pszURL[cb], c_szRegOpen);
                    // Open up the real protocol\shell\open\command  key
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszURL, 0, KEY_READ, &hkeyRealProt))
                    {
                        // Open up app's protocol\shell\open\command key
                        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyProtocols, pszURL, 0, KEY_READ, &hkeyAppsProt))
                        {
                            // Grab the current registered handler
                            cb = ARRAYSIZE(szRealPath);
                            if (ERROR_SUCCESS == RegQueryValueEx(hkeyRealProt, NULL, 0, &dwType, (LPBYTE)szRealPath, &cb))
                            {
                                // Grab the App's Path
                                cb = ARRAYSIZE(szAppPath);
                                if (ERROR_SUCCESS == RegQueryValueEx(hkeyAppsProt, NULL, 0, &dwType2, (LPBYTE)szAppPath, &cb))
                                {
                                    if (REG_EXPAND_SZ == dwType2)
                                    {
                                        ExpandEnvironmentStrings(szAppPath, szTemp, ARRAYSIZE(szTemp));
                                        lstrcpy(szAppPath, szTemp);
                                    }

                                    if (REG_EXPAND_SZ == dwType)
                                    {
                                        ExpandEnvironmentStrings(szRealPath, szTemp, ARRAYSIZE(szTemp));
                                        lstrcpy(szRealPath, szTemp);
                                    }

                                    // Do a simple case insensitive comparison
                                    if (!lstrcmpi(szAppPath, szRealPath))
                                        fNoProbs = TRUE;
                                }
                            }
                            RegCloseKey(hkeyAppsProt);
                        }
                        RegCloseKey(hkeyRealProt);
                    }
                
                    // Reset cb
                    cb = cbMaxProtocolLen;
                }
                MemFree(pszURL);
            }
        }
        RegCloseKey(hkeyProtocols);
    }

    return (fNoProbs);
    
}


//  FUNCTION:   FExchangeServerInstalled()
//
//  PURPOSE:    Checks to see if Exchange Server is installed
//
//  Based on code provided by msmith from OL
//
BOOL FExchangeServerInstalled()
{
    HKEY hkeyServices;
    BOOL fInstalled = FALSE;
    
    // Get HKLM\Software\Microsoft\Exchange\Setup registry key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,  c_szExchangeSetup, 0, KEY_READ, &hkeyServices))
    {
        // Does Services registry value exist?
        fInstalled = ERROR_SUCCESS == RegQueryValueEx(hkeyServices, c_szServices, NULL, NULL, NULL, NULL);
        
        RegCloseKey(hkeyServices);
    }
    
    return (fInstalled);
}


//  FUNCTION:   FMapiStub()
//
//  PURPOSE:    Checks to see if the mapi32.dll is Outlook's
//
//  Based on code provided by Msmith@exchange.microsoft.com
//
// Return Value: TRUE - all is well
// *pdw = Failure type if Return value is FALSE:
// 1 = No mapi32.dll
// 2 = Different mapi32.dll
//
BOOL FMapiStub(DWORD *pdw)
{
    HINSTANCE hMapiStub;
    TCHAR     szSystemPath[MAX_PATH];
    TCHAR     szMapiPath[MAX_PATH];
    BOOL      fMapiStub = FALSE;

    Assert(pdw);

    *pdw = 0;    
    
    // If Exchange server is installed, their stub is in place, so leave it be
    if (FExchangeServerInstalled())
        return TRUE;
    
    // Build a path to mapi32.dll
    GetSystemDirectory(szSystemPath, ARRAYSIZE(szSystemPath));
    MakeFilePath(szSystemPath, c_szMAPIDLL, c_szEmpty, szMapiPath, ARRAYSIZE(szMapiPath));

    hMapiStub = LoadLibrary(szMapiPath);
    if (hMapiStub)
    {
        fMapiStub = NULL != (LPFGETCOMPONENTPATH)GetProcAddress(hMapiStub, TEXT("FGetComponentPath")); // STRING_OK   Msmith
        if (!fMapiStub)
            *pdw = 2;
        FreeLibrary(hMapiStub);
    }
    else
        *pdw = 1;
    
    return fMapiStub;
}


BOOL FValidClient(LPCTSTR pszClient, LPCTSTR pszProduct)
{
    TCHAR szBuffer[MAX_PATH];
    HKEY hkey2;
    BOOL fValid = FALSE;
    
    wsprintf(szBuffer, c_szRegPathSpecificClient, pszClient, pszProduct);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_QUERY_VALUE, &hkey2))
    {
        RegCloseKey(hkey2);
        fValid = TRUE;
    }
    
    return fValid;
}


int DefaultClientSet(LPCTSTR pszClient)
{
    int iRet;
    TCHAR sz[MAX_PATH], sz2[MAX_PATH];
    HKEY hkey, hkeyT;
    DWORD dwType, cb;
    
    iRet = NOT_HANDLED;
    
    wsprintf(sz, c_szPathFileFmt, c_szRegPathClients, pszClient);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, NULL, NULL, &dwType, (LPBYTE)&sz, &cb))
        {
            
            // Sanity check - is the current client even valid?
            wsprintf(sz2, c_szRegPathSpecificClient, pszClient, sz);
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz2, 0, KEY_QUERY_VALUE, &hkeyT))
            {
                RegCloseKey(hkeyT);
                
                if (0 == lstrcmpi(c_szMOE, sz))
                    iRet = HANDLED_CURR;
                else if (0 == lstrcmpi(c_szIMN, sz))
                    iRet = NOT_HANDLED;
                else if (0 == lstrcmpi(c_szOutlook, sz))
                    iRet = HANDLED_OUTLOOK;
                else if (0 == lstrcmpi(c_szNT, sz))
                    iRet = NOT_HANDLED;
                else if (*sz != 0)
                    iRet = HANDLED_OTHER;
            }
        }
        RegCloseKey(hkey);
    }
    
    return(iRet);
}


//
//  FUNCTION:   FIsDefaultNewsConfiged()
//
//  PURPOSE:    Determines if Athena is currently the default news handler.
//
BOOL WINAPI FIsDefaultNewsConfiged(DWORD dwFlags)
{
    BOOL fRet;
    
    if (0 == (dwFlags & DEFAULT_OUTNEWS))
        fRet = (HANDLED_CURR == DefaultClientSet(c_szNews)) && FAssocsOK(c_szNews, c_szMOE);
    else
        fRet = (HANDLED_OUTLOOK == DefaultClientSet(c_szNews)) && FAssocsOK(c_szNews, c_szOutlook);
    
    return(fRet);
}


//
//  FUNCTION:   FIsDefaultMailConfiged()
//
//  PURPOSE:    Determines if Athena is currently the default mail handler.
//
BOOL WINAPI FIsDefaultMailConfiged()
{
    DWORD dwTemp;
    return (HANDLED_CURR == DefaultClientSet(c_szMail) && FAssocsOK(c_szMail, c_szMOE) && FMapiStub(&dwTemp));
}


// ********* Actions
                    
// Set up the URL with our handler
BOOL AddUrlHandler(LPCTSTR pszURL, LPCTSTR pszClient, LPCTSTR pszProduct, DWORD dwFlags)
{
    HKEY hKey, hKeyProt;
    TCHAR szBuffer[MAX_PATH], szBuffer1[MAX_PATH];
    DWORD dwDisp, cb;
    BOOL fCreate = TRUE;

    // Try to detect if this URL is set or not...
    if (dwFlags & DEFAULT_DONTFORCE)
    {
        DWORD dwLen = lstrlen(pszURL);
        LPTSTR pszTemp;

        // 20 = 19 (length of "\Shell\Open\Command") + 1 for NULL
        if (MemAlloc((LPVOID*)&pszTemp, dwLen+20))
        {
            lstrcpy(pszTemp, pszURL);
            lstrcpy(&pszTemp[dwLen], c_szRegOpen);

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszTemp, 0, KEY_READ, &hKey))
            {
                cb = sizeof(szBuffer);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, 0, NULL, (LPBYTE)szBuffer, &cb))
                {
                    // Special case URL.DLL and MAILNEWS.DLL as okay to overwrite
                    if (!strstr(szBuffer, c_szUrlDll) && !strstr(szBuffer, c_szMailNewsDllOld))
                        fCreate = FALSE;
                }
                RegCloseKey(hKey);
            }

            MemFree(pszTemp);
        }
    }

    // Clear out any old info about this URL
    if (fCreate)
    {
        RegDeleteKeyRecursive(HKEY_CLASSES_ROOT, pszURL);
    
        // Figure out the source for the info
        wsprintf(szBuffer1, c_szProtocolPath, pszClient, pszProduct);
        wsprintf(szBuffer, c_szPathFileFmt, szBuffer1, pszURL);
    
        // Copy the info to its new location
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKeyProt))
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, pszURL, 0,
                NULL, REG_OPTION_NON_VOLATILE,
                KEY_WRITE, NULL, &hKey, &dwDisp))
            {
                CopyRegistry(hKeyProt, hKey);
                RegCloseKey(hKey);
            }
        
            RegCloseKey(hKeyProt);
        }
    }
    
    return(TRUE);
}


void SetDefaultClient(LPCTSTR pszClient, LPCTSTR pszProduct, DWORD dwFlags)
{
    TCHAR sz[MAX_PATH];
    HKEY hkey;
    DWORD dwDisp;
    BOOL fOK = TRUE;

    if (DEFAULT_DONTFORCE & dwFlags)
    {
        if (NOT_HANDLED != DefaultClientSet(pszClient))
            fOK = FALSE;
    }

    if (fOK)
    {
        wsprintf(sz, c_szPathFileFmt, c_szRegPathClients, pszClient);
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, sz,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE, NULL, &hkey, &dwDisp))
        {
            RegSetValueEx(hkey, NULL, 0, REG_SZ, (LPBYTE)pszProduct,
                (lstrlen(pszProduct) + 1) * sizeof(TCHAR));

#ifndef THOR_SETUP
            // Bug 32136 in IE6 database
            SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)sz);
#endif // THOR_SETUP
            RegCloseKey(hkey);
        }
    }
}


// Make sure MAPI32.dll is really Outlook's MAPISTUB
BOOL EnsureMAPIStub(DWORD dwFlags)
{
    BOOL fOK = FALSE;
    DWORD dwReason, dwReason2;
    HINSTANCE hMapiStub;
    TCHAR szSystemPath[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    LPFGETCOMPONENTPATH pfnFixMAPI;
    HKEY hkeyRunOnce;
    BOOL fUI = dwFlags & DEFAULT_UI;

    // Is the mapistub already in place?
    if (FMapiStub(&dwReason))
    {
        fOK = TRUE;
        goto exit;
    }

    switch (dwReason)
    {
    case 0:
        AssertSz(FALSE, "EnsureMAPIStub failed for no reason.");
        goto exit;
    
    case 1: // NonExistent
    case 2: // Different
        // Should be able to just load mapistub and FixMAPI

        // Build a path to mapistub.dll
        GetSystemDirectory(szSystemPath, ARRAYSIZE(szSystemPath));
        MakeFilePath(szSystemPath, c_szMAPIStub, c_szEmpty, szPath, ARRAYSIZE(szPath));

        // Try to load
        hMapiStub = LoadLibrary(szPath);
        if (hMapiStub)
        {
            // Look for the FixMAPI function
            pfnFixMAPI = (LPFIXMAPI)GetProcAddress(hMapiStub, TEXT("FixMAPI"));
            if (pfnFixMAPI)
            {
                // Found the entry point, run it
                pfnFixMAPI();
                
                // Did that fix mapi32?
                if (!FMapiStub(&dwReason2))
                {
                    // No, maybe the old one was in use...
                    if (2 == dwReason)
                    {
                        // Add a runonce entry for fixmapi
                        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szMAPIRunOnce, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                            KEY_WRITE, NULL, &hkeyRunOnce, &dwReason))
                        {
                            // 12 = (11 + 1) where 11 is length of fixmapi.exe + 1 for the null
                            if (ERROR_SUCCESS == RegSetValueEx(hkeyRunOnce, c_szMAPIRunOnceEntry, 0, REG_SZ, (LPBYTE)c_szFixMAPI, 12 * sizeof(TCHAR)))
                            {
#ifndef THOR_SETUP
                                // Tell the user to reboot
                                if (fUI)
                                    AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsSimpleMAPI), MAKEINTRESOURCEW(idsMAPISTUBNeedsReboot), NULL, MB_OK);
#endif

                                // Probable success
                                fOK = TRUE;
                            }
                            RegCloseKey(hkeyRunOnce);
                        }
                    }
                    else 
                    {
#ifndef THOR_SETUP
                        if (fUI)
                            AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsSimpleMAPI), MAKEINTRESOURCEW(idsMAPISTUBFailed), NULL, MB_OK);
#endif
                    }
                }
                else 
                    // Success!
                    fOK = TRUE;
            }
            // Eek, where is FixMAPI?            
            else 
            {
#ifndef THOR_SETUP
                if (fUI)
                    AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsSimpleMAPI), MAKEINTRESOURCEW(idsMAPISTUBMissingExport), NULL, MB_OK);
#endif
            }
            
            FreeLibrary(hMapiStub);
        }
        else
        {
            // Dll missing or unloadable
#ifndef THOR_SETUP            
            if (fUI)
                AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsSimpleMAPI), MAKEINTRESOURCEW(idsMAPISTUBNoLoad), NULL, MB_OK);
#endif
        }
        break;

    default:
        AssertSz(FALSE, "EnsureMAPIStub returned an unknown failure.  Bailing");
        goto exit;
    }
    

exit:
    return fOK;
}


// Change the Default News handler
HRESULT ISetDefaultNewsHandler(LPCTSTR pszProduct, DWORD dwFlags)
{
    AddUrlHandler(c_szURLNews,  c_szNews, pszProduct, dwFlags);
    AddUrlHandler(c_szURLNNTP,  c_szNews, pszProduct, dwFlags);
    AddUrlHandler(c_szURLSnews, c_szNews, pszProduct, dwFlags);
    
    SetDefaultClient(c_szNews, pszProduct, dwFlags);
    
    return (S_OK);
}


// Change the Default Mail handler 
HRESULT ISetDefaultMailHandler(LPCTSTR pszProduct, DWORD dwFlags)
{
    // May change default handler to owner of mapi32.dll
    EnsureMAPIStub(dwFlags);

    AddUrlHandler(c_szURLMailTo, c_szMail, pszProduct, dwFlags);

    if ((dwFlags & DEFAULT_SETUPMODE) && IsXPSP1OrLater())
    {
        //  running setup50.exe on XPSP1 or later, let OE Access handle it from here.
    }
    else
    {
        //  Non setup50.exe case (like "would you like to make OE your default mail client?")
        //  or we're running downlevel -- go ahead and do it.
        
        SetDefaultClient(c_szMail, pszProduct, dwFlags);
    }

    return (S_OK);
}


//
//  FUNCTION:   SetDefaultMailHandler()
//
//  PURPOSE:    Adds the keys to the registry to make Athena the user's
//              default mail reader.
//
//  RETURN VALUE:
//      HRESULT
//
// ATTENZIONE! if you change the parameters for this function, make sure
// that you make the proper change to athena\msoeacct\silent.cpp (it calls
// this via GetProcAddress)
HRESULT WINAPI SetDefaultMailHandler(DWORD dwFlags)
{
    return ISetDefaultMailHandler(c_szMOE, dwFlags | DEFAULT_MAIL);
}


//
//  FUNCTION:   SetDefaultNewsHandler()
//
//  PURPOSE:    Adds the keys to the registry to make Athena the user's
//              default news reader.
//
//  RETURN VALUE:
//      HRESULT
//
// ATTENZIONE! if you change the parameters for this function, make sure
// that you make the proper change to athena\msoeacct\silent.cpp (it calls
// this via GetProcAddress)
HRESULT WINAPI SetDefaultNewsHandler(DWORD dwFlags)
{
    if (dwFlags & DEFAULT_OUTNEWS)
        return ISetDefaultNewsHandler(c_szOutlook, dwFlags);
    else
        return ISetDefaultNewsHandler(c_szMOE, dwFlags | DEFAULT_NEWS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\safepnt.h ===
#ifndef __SAFEPNT_H__
#define __SAFEPNT_H__

#ifndef ASSERT
#define ASSERT(X)
#endif

void CALLBACK FreeSRowSet(LPSRowSet prs);

#if defined(_MAC)
#include <macdefs.h>

class CSpTdxMemory
    : virtual public CTdxMemory
{
};
#define CLASS_NEW   : virtual public CSpTdxMemory
#else
#define CLASS_NEW
#endif

// safe pointer header file. snarfed from Cairo. The macro
// SAFE_INTERFACE_PTR takes a single parameter (vs. two of original) of
// type Interface, i.e. IMessage and generates a class SpInterface for it
// i.e. SpIMessage which can be used in place of IMessage *. If you use this
// header, AND place your locals correctly you don't need to release anything.
//
// with the void operator =, you can assign a NULL (0) pointer. This prevents
// the destructor releasing the object. sort of Transfer to void.
//
// owner: muzok

#if defined(WIN32)
template <class Interface> class TSafeIPtr
{
    Interface *         m_pi;

public:
    TSafeIPtr(void) { m_pi = NULL; }
    TSafeIPtr(Interface * pi) { m_pi = pi; }
    ~TSafeIPtr(void) { if (m_pi != NULL) m_pi->Release(); }

    void        Transfer(Interface ** ppi) { *ppi = m_pi; m_pi = NULL; }
    operator    Interface *() { return m_pi; }
    Interface * operator ->() { return m_pi; }
    Interface&  operator *() { return *m_pi; }
    Interface** operator &() { return &m_pi; }
    void        operator =(Interface * pi) { m_pi = pi; }
    void        operator =(TSafeIPtr& i) { m_pi = i.m_pi; m_pi->AddRef(); }

    BOOL        FIsValid(void) const { return m_pi != NULL; }
    void        Release(void) {
        if (m_pi != NULL) { m_pi->Release(); m_pi = NULL; }}
};

#define SAFE_INTERFACE_PTR(a) typedef TSafeIPtr<a> Sp##a;
#else  // !WIN32
#define SAFE_INTERFACE_PTR(Interface)                                         \
class Sp##Interface CLASS_NEW                                                 \
{                                                                             \
public:                                                                       \
    inline Sp##Interface(Interface* p):m_p(p) { if (0 != m_p) m_p->AddRef(); }\
    inline Sp##Interface(void) { m_p = NULL; }                                \
    inline ~Sp##Interface() { if (0 != m_p) m_p->Release(); }                 \
    inline void Transfer(Interface** p) { *p = m_p; m_p = 0; }                \
    inline operator Interface *() { return m_p; }                             \
    inline Interface* operator ->() { return m_p; }                           \
    inline Interface& operator *() { return *m_p; }                           \
    inline Interface** operator &() { return &m_p; }                          \
    inline void operator =(Interface* pv) { m_p = pv; }                       \
    inline void operator =(Sp##Interface & v) { m_p = v.m_p; m_p->AddRef();}  \
    inline BOOL FIsValid(void) const { return m_p != NULL; }                  \
    inline void Release(void) { if (0 != m_p) {m_p->Release(); m_p = NULL; }  \
                                  return; }                                   \
private:                                                                      \
    inline Sp##Interface(const Sp##Interface &) {;}                           \
    Interface* m_p;                                                           \
}
#endif // WIN32

#if defined(MAPIDEFS_H)
SAFE_INTERFACE_PTR(IABContainer);
SAFE_INTERFACE_PTR(IAddrBook);
SAFE_INTERFACE_PTR(IAttach);
SAFE_INTERFACE_PTR(IDistList);
SAFE_INTERFACE_PTR(IMailUser);
SAFE_INTERFACE_PTR(IMAPIAdviseSink);
SAFE_INTERFACE_PTR(IMAPIContainer);
SAFE_INTERFACE_PTR(IMAPIFolder);
SAFE_INTERFACE_PTR(IMAPIProp);
SAFE_INTERFACE_PTR(IMAPISession);
SAFE_INTERFACE_PTR(IMAPIStatus);
SAFE_INTERFACE_PTR(IMAPITable);
SAFE_INTERFACE_PTR(IMessage);
SAFE_INTERFACE_PTR(IMsgStore);
SAFE_INTERFACE_PTR(IProfSect);
SAFE_INTERFACE_PTR(IPropData);
SAFE_INTERFACE_PTR(ITableData);
#endif // defined(MAPIDEFS_H)

#if defined(MAPIFORM_H)
SAFE_INTERFACE_PTR(IMAPIForm);
SAFE_INTERFACE_PTR(IMAPIFormContainer);
SAFE_INTERFACE_PTR(IMAPIFormFactory);
SAFE_INTERFACE_PTR(IMAPIFormInfo);
SAFE_INTERFACE_PTR(IMAPIFormMgr);
SAFE_INTERFACE_PTR(IMAPIMessageSite);
SAFE_INTERFACE_PTR(IMAPIViewContext);
SAFE_INTERFACE_PTR(IPersistMessage);
#endif // defined(MAPIFORM_H)

#if defined (VLB_MIN)
SAFE_INTERFACE_PTR(IVlbEnum);
#endif // defined(VLB_MIN)

#if defined(__objidl_h__) || defined(_STORAGE_H_)
SAFE_INTERFACE_PTR(IStorage);
SAFE_INTERFACE_PTR(IStream);
SAFE_INTERFACE_PTR(IMalloc);
SAFE_INTERFACE_PTR(ILockBytes);
SAFE_INTERFACE_PTR(IEnumSTATSTG);
SAFE_INTERFACE_PTR(IClassFactory);
SAFE_INTERFACE_PTR(IUnknown);
#endif // defined(__objidl_h__)

#if defined(MAPIDEFS_H)
#define SAFE_MAPI_ARRAY(MAPIBuffer)                                         \
class Sp##MAPIBuffer                                                        \
    CLASS_NEW                                                               \
{                                                                           \
public:                                                                     \
    inline Sp##MAPIBuffer(MAPIBuffer* p):m_p(p) { ; }                       \
    inline Sp##MAPIBuffer(void) { m_p = 0; }                                \
    inline ~Sp##MAPIBuffer() { MAPIFreeBuffer((LPVOID)m_p); }               \
    inline void Transfer(MAPIBuffer** p) { *p = m_p; m_p = 0; }             \
    inline operator MAPIBuffer *()        { return m_p; }                   \
    inline MAPIBuffer* operator ->()    { return m_p; }                     \
    inline MAPIBuffer& operator *()        { return *m_p; }                 \
    inline MAPIBuffer** operator &()    { return &m_p; }                    \
    inline void operator =(MAPIBuffer* pv) { ASSERT(0 == pv); m_p = pv; }   \
    inline void Release(void) { MAPIFreeBuffer((LPVOID)m_p); m_p=NULL; }    \
private:                                                                    \
    inline void operator =(Sp##MAPIBuffer &) {;}                            \
    inline Sp##MAPIBuffer(const Sp##MAPIBuffer &) {;}                       \
    MAPIBuffer* m_p;                                                        \
}

SAFE_MAPI_ARRAY(SPropValue);
SAFE_MAPI_ARRAY(SPropTagArray);

#if defined(WIN32)
template <class ptrtype> class TSafeMAPIPtr
{
    ptrtype *   m_p;

public:
    TSafeMAPIPtr(void)          { m_p = NULL; }
    TSafeMAPIPtr(ptrtype * p)   { m_p = p; }
    ~TSafeMAPIPtr(void)         { MAPIFreeBuffer((LPVOID) m_p);}

    void        Transfer(ptrtype ** pp) { *pp = m_p; m_p = NULL; }
    operator ptrtype *()                { return m_p; }
    ptrtype ** operator &()             { return &m_p; }
    void        operator =(ptrtype * p) { m_p = p; }
};

typedef TSafeMAPIPtr<VOID> SpMAPIVOID;
typedef TSafeMAPIPtr<ENTRYID> SpMAPIENTRYID;

#else  // !WIN32
#define SAFE_MAPI_PTR(TYPE)                                             \
class SpMAPI##TYPE CLASS_NEW                                            \
{                                                                       \
public:                                                                 \
    inline SpMAPI##TYPE(TYPE* p)         {m_p = p; }                    \
    inline SpMAPI##TYPE(void)            { m_p = 0; }                   \
    inline ~SpMAPI##TYPE()              { MAPIFreeBuffer((LPVOID)m_p); } \
    inline void Transfer(TYPE** p)      { *p = m_p; m_p = 0; }          \
    inline operator TYPE *()            { return m_p; }                 \
    inline TYPE** operator &()          { return &m_p; }                \
    inline void operator =(TYPE* pv)    { ASSERT((0 == pv) || (m_p == 0)); m_p = pv; } \
private:                                                                \
    inline void operator =(SpMAPI##TYPE &) {;}                          \
    inline SpMAPI##TYPE(const SpMAPI##TYPE &) {;}                       \
    TYPE* m_p;                                                          \
};

SAFE_MAPI_PTR(VOID)
SAFE_MAPI_PTR(ENTRYID)
#endif // WIN32

#if 0
template <class Set> class TSafeSet
{
    Set *       m_p;
public:
    TSafeSet(Set * p) { m_p = p; }
    TSafeSet(void) { m_p = NULL; }
    ~TSafeSet(void) { FreeSRowSet((LPSRowSet) m_p); }

    void        Release(void) { FreeSRowSet((LPSRowSet) m_p); m_p = NULL; }
    void        Transfer(Set ** pp) { *pp = m_p; m_p = NULL; }
    SPropValue * GetProp(int iRow, int iCol) {
        return &(m_p->aRow[iRow].lpProps[iCol]);
    }

    operator    Set *()         { return m_p; }
    Set *       operator ->()   { return m_p; }
    Set&        operator *()    { return *m_p; }
    Set **      operator &()    { return &m_p; }
    void        operator =(Set * p) { ASSERT(NULL == p); m_p = p; }
};

typedef TSafeSet<SRowSet> SpSRowSet;
typedef TSafeSet<ADRLIST> Sp_ADRLIST;

#else  // !WIN32
class SpSRowSet CLASS_NEW
{
public:
    inline SpSRowSet(SRowSet* p) : m_p(p) {;}
    inline SpSRowSet(void) { m_p = 0; }
    inline ~SpSRowSet() { FreeSRowSet(m_p); }
    inline void Transfer(SRowSet** p) { *p = m_p; m_p = 0; }

    inline operator SRowSet *()        { return m_p; }
    inline SRowSet* operator ->()    { return m_p; }
    inline SRowSet& operator *()        { return *m_p; }
    inline SRowSet** operator &()    { return &m_p; }
    inline void operator =(SRowSet* pv)    { ASSERT(0 == pv); m_p = pv; }
    inline SPropValue * GetProp(int iRow, int iCol) { return &(m_p->aRow[iRow].lpProps[iCol]); }

private:
    inline void operator =(SpSRowSet &) {;}
    inline SpSRowSet(const SpSRowSet&) {;}
    SRowSet* m_p;
};

class Sp_ADRLIST
{
public:
    inline Sp_ADRLIST(_ADRLIST* p) : m_p(p) {;}
    inline Sp_ADRLIST(void) { m_p = 0; }
    inline ~Sp_ADRLIST() { FreeProws((SRowSet *) m_p); }
    inline void Release(void) { FreeProws((SRowSet *) m_p); m_p = NULL; }
    inline void Transfer(_ADRLIST** p) { *p = m_p; m_p = 0; }

    inline operator _ADRLIST *()        { return m_p; }
    inline _ADRLIST* operator ->()    { return m_p; }
    inline _ADRLIST& operator *()        { return *m_p; }
    inline _ADRLIST** operator &()    { return &m_p; }
    inline void operator =(_ADRLIST* pv)    { ASSERT(0 == pv); m_p = pv; }
    inline SPropValue * GetProp(int iRow, int iCol) { return &(m_p->aEntries[iRow].rgPropVals[iCol]); }

private:
    inline void operator =(Sp_ADRLIST &) {;}
    inline Sp_ADRLIST(const Sp_ADRLIST&) {;}
    _ADRLIST* m_p;
};
#endif // WIN32
#endif defined(MAPIDEFS_H)

#ifndef _MAC
#define SAFE_MEM_PTR(TYPE)                                        \
class Sp##TYPE                                                    \
    CLASS_NEW                                                     \
{                                                                 \
public:                                                           \
    inline Sp##TYPE(TYPE* p) : m_p(p) { ; }                       \
    inline Sp##TYPE(void) { m_p = NULL; }                         \
    inline ~Sp##TYPE(void) { delete [] m_p; }                     \
    inline void Transfer(TYPE** p) { *p = m_p; m_p = 0; }         \
                                                                  \
    inline TYPE* operator ++() { return ++m_p; }                  \
    inline TYPE* operator ++(int) { return m_p++; }               \
    inline TYPE* operator --() { return --m_p; }                  \
    inline TYPE* operator --(int) { return m_p--; }               \
    inline operator TYPE*() { return m_p; }                       \
    inline TYPE& operator *() { return *m_p; }                    \
    inline TYPE** operator &() { return &m_p; }                   \
    inline void operator =(TYPE* p) { m_p = p; }                  \
private:                                                          \
    inline void operator =(Sp##TYPE &) {;}                        \
    inline Sp##TYPE(const Sp##TYPE&) {;}                          \
    TYPE* m_p;                                                    \
}
#else   // _MAC
#define SAFE_MEM_PTR(TYPE)                                        \
class Sp##TYPE                                                    \
    CLASS_NEW                                                     \
{                                                                 \
public:                                                           \
    inline Sp##TYPE(TYPE* p) : m_p(p) { ; }                       \
    inline Sp##TYPE(void) { m_p = NULL; }                         \
    inline ~Sp##TYPE(void) { TdxMacFree(m_p); }                   \
    inline void Transfer(TYPE** p) { *p = m_p; m_p = 0; }         \
                                                                  \
    inline TYPE* operator ++() { return ++m_p; }                  \
    inline TYPE* operator ++(int) { return m_p++; }               \
    inline TYPE* operator --() { return --m_p; }                  \
    inline TYPE* operator --(int) { return m_p--; }               \
    inline operator TYPE*() { return m_p; }                       \
    inline TYPE& operator *() { return *m_p; }                    \
    inline TYPE** operator &() { return &m_p; }                   \
    inline void operator =(TYPE* p) { m_p = p; }                  \
private:                                                          \
    inline void operator =(Sp##TYPE &) {;}                        \
    inline Sp##TYPE(const Sp##TYPE&) {;}                          \
    TYPE* m_p;                                                    \
}
#endif  // _MAC

SAFE_MEM_PTR(TCHAR);
SAFE_MEM_PTR(int);
SAFE_MEM_PTR(ULONG);
SAFE_MEM_PTR(BYTE);
#ifdef WIN16
typedef char OLECHAR;
#endif // WIN16
SAFE_MEM_PTR(OLECHAR);
SAFE_MEM_PTR(GUID);

class SppTCHAR  CLASS_NEW
{
public:
    inline SppTCHAR(TCHAR** p) : m_p(p) { ; }
    inline ~SppTCHAR()                { delete [] m_p; }
    inline void Transfer(TCHAR*** p) { *p = m_p; m_p = 0; }

    inline TCHAR** operator ++()        { return ++m_p; }
    inline TCHAR** operator ++(int)    { return m_p++; }
    inline TCHAR** operator --()        { return --m_p; }
    inline TCHAR** operator --(int)    { return m_p--; }
    inline operator TCHAR**()            { return m_p; }
    inline TCHAR*& operator *()        { return *m_p; }
    inline TCHAR*** operator &()        { return &m_p; }
    inline void operator =(TCHAR** p)    { m_p = p; }
private:
    inline void operator =(SppTCHAR* &) {;}
    inline SppTCHAR(const SppTCHAR*&) {;}
    TCHAR** m_p;
};

/////////////////////////////////////////////////////////////////////////

#if 0
#ifdef WIN32
template <class handle, fnDelete> class TSafeHandle
{
    handle      m_h;
public:
    TSafeHandle(void)           { m_h = NULL; }
    ~TSafeHandle(void)          { fnDelete(m_h); }
};

#define SAFE_HANDLE(a, b) typedef TSafeHandle<a, b> Sp##a;

SAFE_HANLE(HCRYPTHASH, CryptDestroyHash)
#endif // WIN32
#endif // 0

#endif // __SAFEPNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\seclabel.h ===
/*
**	s e c l a b e l. h
**	
**	Purpose: Security labels interface
**
**  Ported from O2K fed release by YST 
**	
**	Copyright (C) Microsoft Corp. 1996-1999
*/

#ifndef __SECLABEL_H
#define __SECLABEL_H

#ifdef SMIME_V3
#include "SMimePol.h"
#include "safepnt.h"

#ifdef YST
extern const CHAR  c_szDefaultPolicyOid[];
extern const WCHAR c_wszEmpty[];
extern const WCHAR c_wszPolicyNone[];
#endif // YST

extern CRYPT_DECODE_PARA SecLabelDecode;
extern CRYPT_ENCODE_PARA SecLabelEncode;

#define MAX_SECURITY_POLICIES_CACHED     4

typedef struct _SMIME_SECURITY_POLICY {
    BOOL      fDefault;            // TRUE if this is the default ssp.
    BOOL      fValid;              // True if this struct contains valid data.
    
    CHAR      szPolicyOid[MAX_OID_LENGTH];    // Oid for policy module. 
    WCHAR     wszPolicyName[MAX_POLICY_NAME]; // Display Name for policy.
    CHAR      szDllPath[MAX_PATH];            // security policy Dll name & path.
    CHAR      szFuncName[MAX_FUNC_NAME];      // Entry func name.
    DWORD     dwOtherInfo;                    // other policy info. 
    DWORD     dwUsage;             // just count of # of accesses.
    HINSTANCE hinstDll;            // handle to module(if loaded) or NULL.
    PFNGetSMimePolicy pfnGetSMimePolicy;   // valid fn ptr or NULL.
    IUnknown *punk;                // valid interface pointer to the policy object.
    
} SMIME_SECURITY_POLICY, *PSMIME_SECURITY_POLICY;

// Useful Macros 
#define DimensionOf(_array)        (sizeof(_array) / sizeof((_array)[0]))
// #define fFalse                     FALSE
// #define fTrue                      TRUE


// Useful safe pointers
SAFE_INTERFACE_PTR(ISMimePolicySimpleEdit);
SAFE_INTERFACE_PTR(ISMimePolicyFullEdit);
SAFE_INTERFACE_PTR(ISMimePolicyCheckAccess);
SAFE_INTERFACE_PTR(ISMimePolicyLabelInfo);
SAFE_INTERFACE_PTR(ISMimePolicyValidateSend);

// Function prototypes.
// Is Policy RegInfo Loaded, Load/Unload it.
BOOL    FLoadedPolicyRegInfo();
BOOL    FPresentPolicyRegInfo();
HRESULT HrLoadPolicyRegInfo(DWORD dwFlags);
HRESULT HrUnloadPolicyRegInfo(DWORD dwFlags);
HRESULT HrReloadPolicyRegInfo(DWORD dwFlags);

// Find policy, is policy loaded, load/unload policy, ensure policy loaded.
BOOL    FFindPolicy(LPSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp);
BOOL    FIsPolicyLoaded(PSMIME_SECURITY_POLICY pSsp);
HRESULT HrUnloadPolicy(PSMIME_SECURITY_POLICY pSsp);
HRESULT HrLoadPolicy(PSMIME_SECURITY_POLICY pSsp);
HRESULT HrEnsurePolicyLoaded(PSMIME_SECURITY_POLICY pSsp);
HRESULT HrGetPolicy(LPSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp);
HRESULT HrGetPolicyFlags(LPSTR szPolicyOid, LPDWORD pdwFlags) ;
HRESULT HrQueryPolicyInterface(DWORD dwFlags, LPCSTR szPolicyOid, REFIID riid, LPVOID * ppv);

//
// Security label dlgproc, utility fns etc.
//
HRESULT HrGetLabelFromData(PSMIME_SECURITY_LABEL *pplabel, LPCSTR szPolicyOid, 
            DWORD fHasClassification, DWORD dwClassification, LPCWSTR wszPrivacyMark,
            DWORD cCategories, CRYPT_ATTRIBUTE_TYPE_VALUE *rgCategories);
HRESULT HrSetLabel(HWND hwndDlg, INT idcPolicyModule, INT idcClassification,
            INT idcPrivacyMark, INT idcConfigure, 
            PSMIME_SECURITY_POLICY pSsp, PSMIME_SECURITY_LABEL pssl);
BOOL SecurityLabelsOnInitDialog(HWND hwndDlg, PSMIME_SECURITY_LABEL plabel,
            INT idcPolicyModule, INT idcClassification, 
            INT idcPrivacyMark, INT idcConfigure);
HRESULT HrUpdateLabel(HWND hwndDlg, INT idcPolicyModule,
            INT idcClassification, INT idcPrivacyMark,
            INT idcConfigure, PSMIME_SECURITY_LABEL *pplabel);
BOOL OnChangePolicy(HWND hwndDlg, LONG_PTR iEntry, INT idcPolicyModule,
            INT idcClassification, INT idcPrivacyMark,
            INT idcConfigure, PSMIME_SECURITY_LABEL *pplabel);
INT_PTR CALLBACK SecurityLabelsDlgProc(HWND hwndDlg, UINT msg, 
             WPARAM wParam, LPARAM lParam);

HRESULT HrValidateLabelOnSend(PSMIME_SECURITY_LABEL plabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertSign,
                              ULONG ccertRecip, PCCERT_CONTEXT *rgccertRecip);

HRESULT HrValidateLabelRecipCert(PSMIME_SECURITY_LABEL plabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertRecip);

DWORD DetermineCertUsageWithLabel(PCCERT_CONTEXT pccert, 
        PSMIME_SECURITY_LABEL pLabel);

BOOL FCompareLabels(PSMIME_SECURITY_LABEL plabel1, PSMIME_SECURITY_LABEL plabel2);

HRESULT HrGetDefaultLabel(PSMIME_SECURITY_LABEL *pplabel);
HRESULT HrGetOELabel(PSMIME_SECURITY_LABEL *pplabel);
HRESULT HrSetOELabel(PSMIME_SECURITY_LABEL plabel);

#endif // SMIME_V3
#endif // __SECLABEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\sechtml.h ===
/*
**  s e c h t m l . h
**   
**  History
**      4/22/97: (t-erikne) Created.
**   
**  Copyright (C) Microsoft Corp. 1997.
*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SECHTML_H
#define __SECHTML_H

typedef struct SECSTATEtag SECSTATE;

HRESULT HrOutputSecurityScript(LPSTREAM *ppstm, SECSTATE *pSecState, BOOL fDisableCheckbox);
HRESULT HrOutputSecureReceipt(LPSTREAM *ppstm, TCHAR * pszSubject, TCHAR * pszFrom, FILETIME * pftSentTime, FILETIME * pftSigningTime, SECSTATE *pSecState);
HRESULT HrOutputErrSecReceipt(LPSTREAM *ppstm, HRESULT hrError, SECSTATE *pSecState);
HRESULT HrOutputUserSecureReceipt(LPSTREAM *ppstm, IMimeMessage *pMsg);

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\seclabel.cpp ===
/*
**	s e c l a b e l. c p p
**	
**	Purpose: Security labels interface
**
**  Ported from O2K fed release by YST 
**	
**	Copyright (C) Microsoft Corp. 1996-1999
*/
#include "pch.hxx"
#include "ipab.h"
#include "secutil.h"
#include "wchar.h"
#include "goptions.h"
#include "SecLabel.h"
#include "mailnews.h"
#include "shlwapip.h" 
#include "util.h"
#include "demand.h"

// #include "_digsigx.h"
// #include "..\_secext\SecExt.h"

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {5073B6B4-AA66-11d2-9841-0060B0EC2DF3}
EXTERN_C const GUID DECLSPEC_SELECTANY IID_ISMimePolicySimpleEdit ={0x5073b6b4, 0xaa66, 0x11d2, { 0x98, 0x41, 0x0, 0x60, 0xb0, 0xec, 0x2d, 0xf3} };

// {5073B6B5-AA66-11d2-9841-0060B0EC2DF3}
EXTERN_C const GUID DECLSPEC_SELECTANY IID_ISMimePolicyFullEdit = {0x5073b6b5, 0xaa66, 0x11d2, { 0x98, 0x41, 0x0, 0x60, 0xb0, 0xec, 0x2d, 0xf3} };

// {5073B6B6-AA66-11d2-9841-0060B0EC2DF3}
EXTERN_C const GUID DECLSPEC_SELECTANY  IID_ISMimePolicyCheckAccess = {0x5073b6b6, 0xaa66, 0x11d2, { 0x98, 0x41, 0x0, 0x60, 0xb0, 0xec, 0x2d, 0xf3} };

// {5073B6B7-AA66-11d2-9841-0060B0EC2DF3}
EXTERN_C const GUID DECLSPEC_SELECTANY IID_ISMimePolicyLabelInfo = {0x5073b6b7, 0xaa66, 0x11d2, { 0x98, 0x41, 0x0, 0x60, 0xb0, 0xec, 0x2d, 0xf3} };

// {5073B6B8-AA66-11d2-9841-0060B0EC2DF3}
EXTERN_C const GUID DECLSPEC_SELECTANY IID_ISMimePolicyValidateSend = {0x5073b6b8, 0xaa66, 0x11d2, { 0x98, 0x41, 0x0, 0x60, 0xb0, 0xec, 0x2d, 0xf3} };

//
// constant local data.
//

//$ M00Bug : GautamV Use the CryptoReg helper Api's to get the base crypto regkey.
const TCHAR c_szSecurityPoliciesRegKey[] = 
           TEXT("Software\\Microsoft\\Cryptography\\OID\\EncodingType 1\\SMIMESecurityLabel");
const TCHAR c_szSecurityPolicyDllPath[]    = TEXT("DllPath");    // string.
const WCHAR c_wszSecurityPolicyCommonName[] = L"CommonName";    // string
const TCHAR c_szSecurityPolicyFuncName[]   = TEXT("FuncName");   // string.
const TCHAR c_szSecurityPolicyOtherInfo[]  = TEXT("OtherInfo");  // dword
const TCHAR SzRegSecurity[] = "Software\\Microsoft\\Office\\9.0\\Outlook\\Security";

// other constant strings. 
const CHAR  c_szDefaultPolicyOid[] = "default";             // The default policy 
static const WCHAR c_PolwszEmpty[] = L"";                             //
const WCHAR c_wszPolicyNone[] = L"<None>";                  //$ M00BUG: GautamV. This needs to be localized.

#define KEY_USAGE_SIGNING       (CERT_DIGITAL_SIGNATURE_KEY_USAGE|CERT_NON_REPUDIATION_KEY_USAGE)
#define KEY_USAGE_ENCRYPTION    (CERT_KEY_ENCIPHERMENT_KEY_USAGE|CERT_KEY_AGREEMENT_KEY_USAGE)
#define KEY_USAGE_SIGNENCRYPT   (KEY_USAGE_SIGNING|KEY_USAGE_ENCRYPTION)

//
// static local data.
//

// The cached information about the security policies. 
enum EPolicyRegInfoState {
    ePolicyRegInfoNOTLOADED = 0,
    ePolicyRegInfoPRESENT = 1,
    ePolicyRegInfoABSENT = 2
};


const static HELPMAP g_rgCtxSecLabel[] = 
{
    {IDC_POLICY_COMBO,          IDH_SECURITY_POLICY_MODULE},
    {IDC_CLASSIF_COMB,          IDH_SECURITY_CLASSIFICATION},
    {IDC_PRIVACY_EDIT,          IDH_SECURITY_PRIVACY},
    {IDC_CONFIGURE,             IDH_SECURITY_CONFIGURE},
    {IDC_STATIC,                IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};


static EPolicyRegInfoState     s_ePolicyRegInfoState = ePolicyRegInfoNOTLOADED;
static SMIME_SECURITY_POLICY  *s_rgSsp = NULL; // array of Ssp's.
static ULONG                   s_cSsp  = 0;


// local fn prototypes.  
VOID    _IncrPolicyUsage(PSMIME_SECURITY_POLICY pSsp);
HRESULT _HrFindLeastUsedPolicy(PSMIME_SECURITY_POLICY *ppSsp);
HRESULT _EnsureNewPolicyLoadable();
BOOL    _FLoadedPolicyRegInfo();
// BOOL    _FPresentPolicyRegInfo();
HRESULT _HrEnsurePolicyRegInfoLoaded(DWORD dwFlags);
HRESULT _HrLoadPolicyRegInfo(DWORD dwFlags);
HRESULT _HrReloadPolicyRegInfo(DWORD dwFlags);

BOOL    _FFindPolicy(LPCSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp);
BOOL    _FIsPolicyLoaded(PSMIME_SECURITY_POLICY pSsp);
HRESULT _HrUnloadPolicy(PSMIME_SECURITY_POLICY pSsp);
HRESULT _HrLoadPolicy(PSMIME_SECURITY_POLICY pSsp);
HRESULT _HrEnsurePolicyLoaded(PSMIME_SECURITY_POLICY pSsp);
HRESULT _HrGetPolicy(LPCSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp);

 //  Registry access functions

 const int       QRV_Suppress_HKLM = 1;
 const int       QRV_Suppress_HKCU = 2;
 HRESULT HrQueryRegValue(DWORD dwFlags, LPSTR szRegKey, LPDWORD pdwType,
                         LPBYTE * ppbData, LPDWORD  pcbData, DWORD dwDefaultType,
                         LPBYTE pbDefault, DWORD cbDefault);


HRESULT CategoriesToBinary(PSMIME_SECURITY_LABEL plabel, BYTE * *ppArray, int *cbSize);
HRESULT BinaryToCategories(CRYPT_ATTRIBUTE_TYPE_VALUE ** ppCategories, DWORD *cCat, BYTE * pArray);

//
// Increase the usage count of the given policy.
//
VOID _IncrPolicyUsage(PSMIME_SECURITY_POLICY pSsp) 
{
    if (!FPresentPolicyRegInfo())                 return;
    
    if ((pSsp->dwUsage + 1) < pSsp->dwUsage) {
         // prevent overflow.
        Assert(s_rgSsp);   
        for (ULONG iSsp = 0; iSsp<s_cSsp; iSsp++) {
            s_rgSsp[iSsp].dwUsage /= 2;    // Just halve each usage count. 
        }    
    }
    
    pSsp->dwUsage ++;
}


//
// Find the least used policy.
//
HRESULT _HrFindLeastUsedPolicy(PSMIME_SECURITY_POLICY *ppSsp) 
{
    ULONG                  iSsp;
    HRESULT                hr = E_FAIL;
    PSMIME_SECURITY_POLICY pSspFound = NULL;

    // validate i/p params.
    if (NULL == ppSsp) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *ppSsp = NULL;

    // find the least used policy.
    for (iSsp=0; iSsp < s_cSsp; iSsp++) {
        if (_FIsPolicyLoaded(& (s_rgSsp[iSsp]) )) {
            // if we haven't found a ssp earlier, 
            // OR if this one is less used that the currently found one.
            if ((NULL == pSspFound) || 
                (s_rgSsp[iSsp].dwUsage < pSspFound->dwUsage)) {
                pSspFound = & (s_rgSsp[iSsp]);
            }            
        }
    }

    // have we found the result.
    if (NULL == pSspFound) {
        hr = E_FAIL;
        goto Error;
    }

    // success.
    *ppSsp = pSspFound;
    hr = S_OK;

// Exit:
Error:
    return hr;
}



//
// Unloads one or more policies from memory and ensures that there 
// is room for a new policy to be loaded. 
//
HRESULT _EnsureNewPolicyLoadable()
{
    ULONG     cSspLoaded = 0;
    HRESULT   hr = E_FAIL;
    ULONG     iSsp;

    // count the number of policies loaded into memory.
    for (iSsp=0; iSsp < s_cSsp; iSsp++) {
        if (_FIsPolicyLoaded( &(s_rgSsp[iSsp]) )) {
            cSspLoaded ++;
        }
    }

    // If we have room for one more policy, then we don't need to do anything.
    if (cSspLoaded < MAX_SECURITY_POLICIES_CACHED) {
        hr = S_OK;
        goto Exit;
    }

    // Assert that this isn't a "bad" condition, but we will handle it anyway.
    Assert(cSspLoaded == MAX_SECURITY_POLICIES_CACHED);

    // unload one or more policies.
    while (cSspLoaded >= MAX_SECURITY_POLICIES_CACHED) {
        PSMIME_SECURITY_POLICY pSsp = NULL;        
        if (FAILED(_HrFindLeastUsedPolicy(&pSsp))) {
            goto Error;
        }
        if (FAILED(_HrUnloadPolicy(pSsp))) {
            goto Error;
        }
        cSspLoaded --;
    }

    // success.
    hr = S_OK;

Exit:
    return hr;
    
Error:
    AssertSz(FALSE, "_EnsureNewPolicyLoadable failed");
    goto Exit;
}


//
// Return true if the info about the installed policies 
// has been read in from the windows registry.
//
BOOL _FLoadedPolicyRegInfo() 
{
    return ( ! ( ePolicyRegInfoNOTLOADED == s_ePolicyRegInfoState ) );    
}




//
// Ensure that the policy registration info has been read in.
//
HRESULT _HrEnsurePolicyRegInfoLoaded(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    if ( !_FLoadedPolicyRegInfo() )    hr = _HrLoadPolicyRegInfo(dwFlags);
    return hr;
}


//
// Are any policies installed(registered) ?
//
BOOL FPresentPolicyRegInfo()
{
    HRESULT hr = S_OK;
    BOOL    fRegistered = FALSE;
    
    // No label support without SMIME3 bits
    if(!IsSMIME3Supported())
        return FALSE;

    hr = _HrEnsurePolicyRegInfoLoaded(0);
    if (SUCCEEDED(hr)) {
        fRegistered = (ePolicyRegInfoPRESENT == s_ePolicyRegInfoState);
        Assert(!fRegistered || s_rgSsp); // ie ((registered_policies) => (NULL!=s_rgSsp)).
    }
    return fRegistered;
}



//
// Internal function.
// Load Policy Registration information.
//
// Returns:
//    S_OK or E_FAIL.
// 
// The format of the security policy registration info is assumed to be:
// HKLM\Software\Microsoft\Cryptography\SMIME\SecurityPolicies\
//    szPolicyOid_1
//       DLLPATH  REG_SZ
//       CommonName  REG_SZ
//       FuncName    REG_SZ
//       OtherInfo   REG_SZ
//    szPolicyOid_2
//    Default
//    ...
//    
//
HRESULT _HrLoadPolicyRegInfo(DWORD dwFlags) 
{
    HRESULT hr   = E_FAIL;
    LONG    lRes = 0;
    HKEY    hkey = NULL;
    HKEY    hkeySub  = NULL;
    ULONG   cb = 0;
    LPBYTE  pb = NULL;
    DWORD   cSubKeys = 0;
    ULONG   iSubKey  = 0;

    if (_FLoadedPolicyRegInfo()) {
        AssertSz(FALSE, "PolicyRegInfo is already loaded");
        hr = S_OK;
        goto Cleanup;
    }
    
    // Open the security policies key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecurityPoliciesRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // we couldn't open the regkey, bail out.
        hr = E_FAIL;
        goto Error;
    }

    // find the number of security policies. (ie number of subkeys).
    lRes = RegQueryInfoKey(hkey, NULL, NULL, NULL, &cSubKeys, 
                           NULL, NULL, NULL, NULL, NULL, NULL, NULL); 
    if ( (ERROR_SUCCESS != lRes) || (0 == cSubKeys) ) {
        // we counldn't get num of subkeys, or there are no subkeys.
        hr = E_FAIL;
        goto Error;
    }

    // Allocate enough memory to retrieve and store info about
    // the registered security policies. 
    cb = sizeof(SMIME_SECURITY_POLICY) *  cSubKeys;
    pb = (LPBYTE) malloc(cb);
    if (NULL == pb) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    memset(pb, 0, cb); // initialize the whole blob to zeros.
    Assert(NULL == s_rgSsp);
    s_rgSsp = (PSMIME_SECURITY_POLICY) pb;
    s_cSsp = 0;

    //
    // Enumerate over the subkeys and retrieve reqd info.
    //
    for (iSubKey=0; iSubKey<cSubKeys; iSubKey++) {

        ULONG   cbData;
        DWORD   dwType;
        TCHAR    szPolicyOid[MAX_OID_LENGTH];
        TCHAR    szDllPath[MAX_PATH];
        TCHAR    szExpanded[MAX_PATH];
        TCHAR    szFuncName[MAX_FUNC_NAME];
        WCHAR   wszPolicyName[MAX_POLICY_NAME];
        DWORD   dwOtherInfo;
        
        // release previously opened subkeys.
        if (NULL != hkeySub) {
            RegCloseKey(hkeySub);
            hkeySub = NULL;
        }
        
        // Get the subkey name. (ie policy oid).
        lRes = RegEnumKey(hkey, iSubKey, szPolicyOid, DimensionOf(szPolicyOid));
        if (ERROR_SUCCESS != lRes) {
            goto NextSsp;
        }
        szPolicyOid[ DimensionOf(szPolicyOid) - 1 ] = '\0';
        
        // Open the subkey. (ie the policy subkey).
        lRes = RegOpenKeyEx(hkey, szPolicyOid, 0, KEY_READ, &hkeySub); 
        if (ERROR_SUCCESS != lRes) {
            goto NextSsp;
        }

        //
        // query the szOid policy values. 
        // 

        // get the path to the policy dll.
        cbData = sizeof(szDllPath);
        lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyDllPath, NULL, 
                               &dwType, (LPBYTE)szDllPath, &cbData);
        if (ERROR_SUCCESS != lRes) {
            goto NextSsp;
        }
        else if (REG_EXPAND_SZ == dwType)
        {
            ExpandEnvironmentStrings(szDllPath, szExpanded, ARRAYSIZE(szExpanded));
            lstrcpy(szDllPath, szExpanded);
        }
        else
            szDllPath[ DimensionOf(szDllPath) - 1 ] = '\0';
        
        // get the common name.
        cbData = DimensionOf(wszPolicyName);
        lRes = RegQueryValueExWrapW(hkeySub, c_wszSecurityPolicyCommonName, NULL, 
                                &dwType, (LPBYTE)wszPolicyName, &cbData);

        if (ERROR_SUCCESS != lRes) {
            goto NextSsp;
        }

        wszPolicyName[ DimensionOf(wszPolicyName) - 1 ] = '\0';

        // get the entry func name.
        cbData = sizeof(szFuncName);
        lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyFuncName, NULL, 
                               &dwType, (LPBYTE)szFuncName, &cbData);
        if (ERROR_SUCCESS != lRes) {
            goto NextSsp; 
        }
        szFuncName[ DimensionOf(szFuncName) - 1] = '\0';
        
        // get other policy info.
        cbData = sizeof(dwOtherInfo);
        lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyOtherInfo, NULL, 
                               &dwType, (LPBYTE)&dwOtherInfo, &cbData);
        if (ERROR_SUCCESS != lRes) {
            dwOtherInfo = 0; // ignore the absence of this value. 
        }


        //
        // Great: we were able to open subkey, and get all required info. 
        // Now we store all the info we retrieved.
        //
        s_rgSsp[s_cSsp].fValid = TRUE;
        s_rgSsp[s_cSsp].fDefault = (0 == lstrcmpi(c_szDefaultPolicyOid, szPolicyOid));
        strcpy(s_rgSsp[s_cSsp].szPolicyOid, szPolicyOid);
        wcscpy(s_rgSsp[s_cSsp].wszPolicyName, wszPolicyName);
        strcpy(s_rgSsp[s_cSsp].szDllPath, szDllPath);
        s_rgSsp[s_cSsp].dwOtherInfo = dwOtherInfo;
        s_rgSsp[s_cSsp].dwUsage = 0;
        s_rgSsp[s_cSsp].hinstDll = NULL;
        strcpy(s_rgSsp[s_cSsp].szFuncName, szFuncName);
        s_rgSsp[s_cSsp].punk = NULL;
        s_cSsp++;
        continue;
        
NextSsp:
        AssertSz(FALSE, "Ignoring incorrectly registered Ssp"); 
    }



    // success.
    if (0 == s_cSsp) {
        AssertSz(FALSE, "There isn't even one correctly registered Ssp");
        goto Error;
    }
    s_ePolicyRegInfoState = ePolicyRegInfoPRESENT;
    hr = S_OK;
    
    goto Cleanup;

Error:
    // Any error is treated as if no security policies are registered.
    s_ePolicyRegInfoState = ePolicyRegInfoABSENT;
    free(pb); //ie free(s_rgSsp); 
    s_cSsp = 0;
    s_rgSsp = NULL;
    
    
Cleanup:
    if (NULL != hkeySub) RegCloseKey(hkeySub);
    if (NULL != hkey)    RegCloseKey(hkey);
    return hr;
}




//
// Unload Policy Registration Information.
//
HRESULT HrUnloadPolicyRegInfo(DWORD dwFlags)
{
    HRESULT hr   = S_OK;
    ULONG   iSsp;

    // If the policy reg info isn't loaded
    if ( ! _FLoadedPolicyRegInfo() )  {
        return S_OK;
    }
    
    // unload all policy modules.
    if (FPresentPolicyRegInfo()) {
        Assert(s_rgSsp && s_cSsp);
        for (iSsp=0; iSsp<s_cSsp; iSsp++) {
            SideAssert(SUCCEEDED(_HrUnloadPolicy(&s_rgSsp[iSsp])));        
            // if this fails, we don't have to abort. 
        }
    }

    // free memory, reset cache info and exit.
    free(s_rgSsp);
    s_rgSsp = NULL;
    s_ePolicyRegInfoState = ePolicyRegInfoNOTLOADED;
    s_cSsp = 0;

    hr = S_OK;    
    return hr;
}

//
// Reload all the policy registration information.
//
HRESULT _HrReloadPolicyRegInfo(DWORD dwFlags) 
{
    HRESULT hr = S_OK;

    hr = HrUnloadPolicyRegInfo(dwFlags);
    Assert(SUCCEEDED(hr));
    if (SUCCEEDED(hr)) {
        hr = _HrLoadPolicyRegInfo(dwFlags);
    }
    
    return hr;
}




//
// Find a given policy, and return its reg info struct.
//
// Input: 
//    szPolicyOid [in]
//    ppSsp       [out]
//
// Output:
//    TRUE/FALSE. (if true, *ppSsp contains the reqd info).
//
BOOL _FFindPolicy(LPCSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp)
{
    BOOL    fFound = FALSE;
    HRESULT hr = E_FAIL;
    ULONG   iSsp;

    // Validate i/p params and init o/p params.
    if ( (NULL == szPolicyOid) || (NULL == ppSsp) ) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *ppSsp = NULL;

    // Load the info from the registry if reqd.
    hr = _HrEnsurePolicyRegInfoLoaded(0);
    if (FAILED(hr)) {
        goto Error;
    }    

    // If we haven any installed policies, search for the one we want.
    if (FPresentPolicyRegInfo()) {
        for (iSsp=0; iSsp<s_cSsp; iSsp++) {
            if (0 == lstrcmpi(s_rgSsp[iSsp].szPolicyOid, szPolicyOid)) {
                // found the policy.
                *ppSsp = & (s_rgSsp[iSsp]);
                fFound = TRUE;
                break;
            }
        }
    }
    
Error:
// Cleanup:
    return fFound;
}


//
// Finds out if a given policy module is loaded.
// 
// Input: pSsp [in].
// Output: true/false if policy is loaded or notloaded.
//
BOOL _FIsPolicyLoaded(PSMIME_SECURITY_POLICY pSsp)
{
    BOOL    fIsLoaded = FALSE;
    HRESULT hr = E_FAIL;

    // validate i/p params.
    if (NULL == pSsp) {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Find out if hinstDll, pfn, and punk are loaded and ok.
    if ( (NULL != pSsp->hinstDll) && 
         (NULL != pSsp->pfnGetSMimePolicy) && 
         (NULL != pSsp->punk) ) {
        fIsLoaded = TRUE;
    }
    
Error:
    return fIsLoaded;
}


//
// Unload a specified policy.
//
// Input : pSsp
// Output: hr.
// 
HRESULT _HrUnloadPolicy(PSMIME_SECURITY_POLICY pSsp) 
{
    HRESULT hr;

    // validate i/p params.
    if (NULL == pSsp) {
        hr = E_INVALIDARG;
        goto Error;
    }

    // release the object.
    if (NULL != pSsp->punk) {
        if (! IsBadReadPtr(pSsp->punk, sizeof(IUnknown)) ) {
            pSsp->punk->Release();
        }
        pSsp->punk = NULL;
    }

    // forget the proc address.
    if (NULL != pSsp->pfnGetSMimePolicy) {
        pSsp->pfnGetSMimePolicy = NULL;
    }

    // unload the library.
    if (NULL != pSsp->hinstDll) {
        FreeLibrary(pSsp->hinstDll);
        // there's no point in aborting to error here.
        pSsp->hinstDll = NULL;
    }
    hr = S_OK;
    
Error:
    return hr;
}


//
// (Force) Load a specified policy. 
// 
// Input: pSsp
// Output: hr
//
HRESULT _HrLoadPolicy(PSMIME_SECURITY_POLICY pSsp) 
{
    HRESULT hr  = E_FAIL;
    
    // validate i/p params.
    if (NULL == pSsp) {
        hr = E_INVALIDARG;
        goto Error;
    }  

    // Unload any partial info we might have. 
    SideAssert(SUCCEEDED(_HrUnloadPolicy(pSsp)));


    // Unload policies (if reqd) to make room for the new one.
    hr = _EnsureNewPolicyLoadable();
    if (FAILED(hr)) {
        goto Error;
    }
   
    // Load the dll, get its proc address and get the interface ptr.
    Assert(NULL != pSsp->szDllPath);
    pSsp->hinstDll = LoadLibraryEx(pSsp->szDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (NULL == pSsp->hinstDll) {
        hr = E_FAIL;
        goto Error;
    }

    Assert(NULL != pSsp->szFuncName);
    pSsp->pfnGetSMimePolicy = (PFNGetSMimePolicy) 
                  GetProcAddress(pSsp->hinstDll, pSsp->szFuncName);
    if (NULL == pSsp->pfnGetSMimePolicy) {
        hr = E_FAIL;
        goto Error;
    }
    
    //$ M00BUG: GautamV.   Need to pass in an appropriate lcid.
    hr = (pSsp->pfnGetSMimePolicy) (0, pSsp->szPolicyOid, GetACP(), 
                                    IID_IUnknown, &(pSsp->punk) );
    if (FAILED(hr)) {
        goto Error;
    }
    if (NULL == pSsp->punk) {
        hr = E_FAIL;
        goto Error;
    }

    // Success.
    hr = S_OK;
    goto Cleanup;
    

Error:
    // unload the policy module (since we may have partially loaded it).
    SideAssert(SUCCEEDED(_HrUnloadPolicy(pSsp)));
    
Cleanup:
    return hr;
}


//
// Ensure that the given policy is loaded. 
// Input:  pSsp
// Output: pSsp
// 
HRESULT _HrEnsurePolicyLoaded(PSMIME_SECURITY_POLICY pSsp) 
{
    HRESULT hr = E_FAIL;
    
    // validate i/p params.
    if (NULL == pSsp) {
        hr = E_INVALIDARG;
        goto Error;
    }

    // if it is already loaded, then we are done. 
    if (_FIsPolicyLoaded(pSsp)) {
        hr = S_OK;
        goto Cleanup;
    }

    // else, load the policy.
    hr = _HrLoadPolicy(pSsp);
    if (FAILED(hr)) {
        goto Error;
    }
    
    Assert(_FIsPolicyLoaded(pSsp));
    hr = S_OK;
    goto Cleanup;

    
Error:
Cleanup:
    return hr;
}



//
// Given a oid, find it, ensure that it is loaded and 
// return the structure contain its registration info.
//
// Returns:
//   S_OK and a valid pSsp
//   OR E_INVALIDARG, E_FAIL, etc. 
//
HRESULT _HrGetPolicy(LPCSTR szPolicyOid, PSMIME_SECURITY_POLICY *ppSsp)
{
    HRESULT hr = E_FAIL;
    PSMIME_SECURITY_POLICY pSsp = NULL;

    // Validate i/p params and initialize o/p params.
    if ( (NULL == szPolicyOid) || (NULL == ppSsp) ) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *ppSsp = NULL;
    
    // Load all the registration information for all installed policies. 
    hr = _HrEnsurePolicyRegInfoLoaded(0);
    if (FAILED(hr)) {
        goto Error;
    }

    // find the policy we want.
    if (! _FFindPolicy(szPolicyOid, &pSsp)) {
        hr = NTE_NOT_FOUND;
        goto Error; // not found.
    }
    
    // If needed, load the policy. 
    hr = _HrEnsurePolicyLoaded(pSsp);
    if (FAILED(hr)) {
        goto Error;
    }

    // success
    *ppSsp = pSsp;
    
    // We increment the usage count, each time someone "gets" a policy.
    _IncrPolicyUsage(pSsp);
    
    hr = S_OK;
    
Error:
    return hr;
// Cleanup:
}



//
// SecurityPolicy  -   QI clone.
// Given a policy oid, finds and loads it, does a 
// qi and returns the reqd interface to the policy module.
//
HRESULT HrQueryPolicyInterface(DWORD dwFlags, LPCSTR szPolicyOid, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_FAIL;
    
    PSMIME_SECURITY_POLICY pSsp = NULL;

    // Validate i/p params, initialize o/p params.
    if ((NULL == szPolicyOid) || (NULL == ppv)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *ppv = NULL;

    // Get the policy.
    hr = _HrGetPolicy(szPolicyOid, &pSsp);
    if (FAILED(hr)) {
        goto Error;
    }
    
    Assert(NULL != pSsp->punk);
    hr = pSsp->punk->QueryInterface(riid, ppv);
    
    // fall through to Error.


// Cleanup:
Error:
    return hr;
}




//
// The allocators we pass in to the Crypto Api's.
//
LPVOID WINAPI SecLabelAlloc(size_t cbSize)
{
    return SecPolicyAlloc(cbSize);
}

VOID WINAPI SecLabelFree(LPVOID pv)
{
    SecPolicyFree(pv);
}
CRYPT_DECODE_PARA       SecLabelDecode = {
    sizeof(SecLabelDecode), SecLabelAlloc, SecLabelFree
};
CRYPT_ENCODE_PARA       SecLabelEncode = {
    sizeof(SecLabelEncode), SecLabelAlloc, SecLabelFree
};


//
// Decode and allocate a label.
//
HRESULT HrDecodeAndAllocLabel(LPBYTE pbLabel, DWORD cbLabel, PSMIME_SECURITY_LABEL *pplabel, DWORD *pcbLabel)
{
    BOOL        f;
    
    f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label, pbLabel, cbLabel,
                            CRYPT_ENCODE_ALLOC_FLAG, &SecLabelDecode, 
                            pplabel, pcbLabel); 
    if (!f) {
        return E_FAIL; // HrCryptError();
    }

    return S_OK;
}

//
// Encode and Allocate a label.
//
HRESULT HrEncodeAndAllocLabel(const PSMIME_SECURITY_LABEL plabel, BYTE ** ppbLabel, DWORD * pcbLabel)
{
    BOOL        f;

    f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label, plabel,
                            CRYPT_ENCODE_ALLOC_FLAG, &SecLabelEncode, 
                            ppbLabel, pcbLabel);
    if (!f) {
        return E_FAIL; // HrCryptError();
    }

    return S_OK;
}





// HrDupLabel
// Duplicate a given label.
//
// Parameters:
//    plabel  [in]
//    pplabel [out]
//
// Returns:
//    on success, returns S_OK with a valid label *pplabelOut.
//    else returns failure code, (as well as frees *pplabelOut).
//
HRESULT HrDupLabel(PSMIME_SECURITY_LABEL *pplabelOut, const PSMIME_SECURITY_LABEL plabelIn)
{
    HRESULT hr = E_FAIL;
    ULONG   cbLabel  = 0;
    LPBYTE  pbLabel = NULL;
    ULONG   cbLabel2 = 0;
    PSMIME_SECURITY_LABEL plabel = NULL;    

    // validate i/p parameters.
    if ((NULL == plabelIn) || (NULL == pplabelOut)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    SecPolicyFree(*pplabelOut);

    // encode it.
    hr = HrEncodeAndAllocLabel(plabelIn, &pbLabel, &cbLabel);
    if (FAILED(hr)) {
        goto Error;
    }
    Assert( (NULL != pbLabel) && (0 < cbLabel) );

    // decode it.
    hr = HrDecodeAndAllocLabel(pbLabel, cbLabel, &plabel, &cbLabel2);
    if (FAILED(hr)) {
        goto Error;
    }
    Assert( (NULL != plabel) && (0 < cbLabel2) );

    // succcess.
    *pplabelOut = plabel;
    hr = S_OK;
    
Exit:
    SecLabelEncode.pfnFree(pbLabel);
    return hr;
Error:
    SecLabelDecode.pfnFree(plabel);
    goto Exit;
}


// FSafeCompareString
//    Given two strings, compare them and return TRUE if they are equivalent
//    (safe for NULL pointers)
//
// Parameters:
//    pwz1 - wide string 1
//    pwz2 - wide string 2
//
// Returns:
//    TRUE if the strings are equivalent
//    FALSE otherwise
//
BOOL FSafeCompareStringW(LPCWSTR pwz1, LPCWSTR pwz2)
{
    if (pwz1 == pwz2) {
        return TRUE;
    }
    else if ((NULL == pwz1)||(NULL == pwz2)) {
        return FALSE;
    }

    return (0 == wcscmp(pwz1, pwz2));
}

BOOL FSafeCompareStringA(LPCSTR psz1, LPCSTR psz2)
{
    if (psz1 == psz2) {
        return TRUE;
    }
    else if ((NULL == psz1)||(NULL == psz2)) {
        return FALSE;
    }

    return (0 == strcmp(psz1, psz2));
}


// FCompareLabels
//  Given the label, return TRUE if the labels are equivalent
//
// Parameters:
//    plabel1 [in]
//    plabel2 [in]
//
// Returns:
//    TRUE if the labels are equivalent
//    FALSE otherwise
//
BOOL FCompareLabels(PSMIME_SECURITY_LABEL plabel1, PSMIME_SECURITY_LABEL plabel2)
{
    BOOL        fEqual = FALSE;
    UINT        i;

    if (plabel1 == plabel2) {
        fEqual = TRUE;
        goto Exit;
    }

    if ((NULL == plabel1)||(NULL == plabel2)) {
        goto Exit;
    }

    if ((plabel1->fHasClassification != plabel2->fHasClassification)||
        (plabel1->dwClassification != plabel2->dwClassification)||
        (plabel1->cCategories != plabel2->cCategories)) {
        goto Exit;
    }

    if (!FSafeCompareStringA(plabel1->pszObjIdSecurityPolicy, 
                            plabel2->pszObjIdSecurityPolicy)||
        !FSafeCompareStringW(plabel1->wszPrivacyMark, plabel2->wszPrivacyMark)) {
        goto Exit;
    }

    //$M00REVIEW: What if the categories are in different order???
    for (i=0; i<plabel1->cCategories; ++i) {
        if ((plabel1->rgCategories[i].Value.cbData != 
             plabel2->rgCategories[i].Value.cbData)||
            (0 != memcmp(plabel1->rgCategories[i].Value.pbData, 
                         plabel2->rgCategories[i].Value.pbData,
                         plabel2->rgCategories[i].Value.cbData))) {
            goto Exit;
        }
    }

    fEqual = TRUE;

Exit:
    return fEqual;
}


// HrGetLabelFromData
// Given the label data, allocate and store the info in a label struct.
//
// Parameters:
//    pplabel [out]
//    others  [in]
//
// Returns:
//    on success, returns S_OK with a valid label *pplabel.
//    else returns failure code, (as well as frees *pplabel).
//
HRESULT HrGetLabelFromData(PSMIME_SECURITY_LABEL *pplabel, LPCSTR szPolicyOid, 
            DWORD fHasClassification, DWORD dwClassification, LPCWSTR wszPrivacyMark,
            DWORD cCategories, CRYPT_ATTRIBUTE_TYPE_VALUE *rgCategories)
{
    HRESULT hr = E_FAIL;
    SMIME_SECURITY_LABEL label = {0};
    PSMIME_SECURITY_LABEL plabel = NULL;
        

    // validate i/p parameters.
    if ((NULL == pplabel) || (NULL == szPolicyOid)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    SecPolicyFree(*pplabel);

    // set up our temporary label structure.
    label.pszObjIdSecurityPolicy = const_cast<LPSTR> (szPolicyOid);
    label.fHasClassification     = fHasClassification;
    if (fHasClassification) {
        label.dwClassification   = dwClassification;
    }
    label.wszPrivacyMark         = const_cast<LPWSTR> (wszPrivacyMark);
    label.cCategories            = cCategories;
    if (label.cCategories) {
        label.rgCategories       = rgCategories;
    }

    // dupe and get a contiguous label structure.
    hr = HrDupLabel(&plabel, &label);
    if (FAILED(hr)) {
        goto Error;
    }

    // success. set return value.
    *pplabel = plabel;
    hr = S_OK;
    
Exit:
    return hr;
Error:
    SecPolicyFree(plabel);
    goto Exit;
}




//
// Utility fn to  "Select NO label".
//
// Input:  hwndDlg, idc's of controls.
// Output: hr
//
HRESULT HrSetLabelNone(HWND hwndDlg, INT idcPolicyModule, INT idcClassification,
                  INT idcPrivacyMark, INT idcConfigure)
{
    HRESULT hr = E_FAIL;
    LONG_PTR iEntry;

    // Make sure the policy Module name is <none> and that it is selected. 

    // First try to select the <none> policy module.
    iEntry =  SendDlgItemMessageW(hwndDlg, idcPolicyModule,
                   CB_SELECTSTRING, (WPARAM) (-1), 
                   (LPARAM) (c_wszPolicyNone));
    if (CB_ERR == iEntry) {
        // Otherwise, add the <none>policy module and select it.
        iEntry = SendDlgItemMessageW(hwndDlg, idcPolicyModule, 
                                     CB_ADDSTRING, (WPARAM) 0, 
                                     (LPARAM) c_wszPolicyNone);
        Assert(NULL == SendDlgItemMessage(hwndDlg, idcPolicyModule, CB_GETITEMDATA, iEntry, 0));
        iEntry =  SendDlgItemMessageW(hwndDlg, idcPolicyModule,
                       CB_SETCURSEL, (WPARAM) iEntry, 0);
        Assert(CB_ERR != iEntry);
    }
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)iEntry);

    // Reset and disable the other controls.
    SendDlgItemMessage(hwndDlg, idcClassification, CB_RESETCONTENT, 0, 0);
    EnableWindow(GetDlgItem(hwndDlg, idcClassification), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, idcClassification+1), FALSE);
    SetDlgItemTextW(hwndDlg, idcPrivacyMark, c_PolwszEmpty);
    EnableWindow(GetDlgItem(hwndDlg, idcPrivacyMark), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, idcPrivacyMark+1), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, idcConfigure), FALSE);
    hr = S_OK;
    
    return hr;
}


//
// Select a label in the dlg.
// 
// Given pssl, sets that label.
// Given pSsp, sets that policy's default info.
// If neither is given, sets label to none.
// 
// Input:
//    hwndDlg, idc's of the various controls  [in].
//    pSsp   [in, optional]  smime security policy.
//    plabel [in, optional]  security label.
//
// Returns:
//    returns either S_OK or an error code.
//
HRESULT HrSetLabel(HWND hwndDlg, INT idcPolicyModule, INT idcClassification,
                   INT idcPrivacyMark, INT idcConfigure, 
                   PSMIME_SECURITY_POLICY pSsp, PSMIME_SECURITY_LABEL plabel)
{
    HRESULT   hr = E_FAIL;
    ULONG     iClassification;
    LONG_PTR  iEntry;
    LPCWSTR    wszT = NULL;
    DWORD     dwPolicyFlags = 0;
    ULONG     cClassifications = 0;
    LPWSTR   *pwszClassifications = NULL;
    LPDWORD   pdwClassifications = NULL;
    DWORD     dwDefaultClassification = 0;
    DWORD     dwT = 0;
    WCHAR    *pwchPrivacyMark = NULL;
    BOOL     fPrivMarkReadOnly = FALSE;
    SpISMimePolicySimpleEdit spspse = NULL;
    

    // Validate the i/p parameters.
    if ( ! IsWindow(hwndDlg) ) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // If we are neither given a policy nor a ssl, set the label to <none>.
    if ((NULL == pSsp) && (NULL == plabel)) {
        hr = S_OK;
        goto Error;
    }

    // if given a label, but not a policy, try to locate & load the policy.
    if ((NULL == pSsp) && (NULL != plabel)) {
        if (NULL != plabel->pszObjIdSecurityPolicy) {
            hr = _HrGetPolicy(plabel->pszObjIdSecurityPolicy, &pSsp);
            // if unable to locate/load the policy, set the label to <none>
            if (FAILED(hr)) {
                goto PolicyNotFoundError;
            }
        }
        else {
            hr = S_OK;
            goto Error;
        }
    }
    
    // ensure that the policy is loaded.
    hr = _HrEnsurePolicyLoaded(pSsp);
    if (FAILED(hr)) {
        goto PolicyNotFoundError;
    }
    
    Assert(_FIsPolicyLoaded(pSsp) && pSsp->punk);
    hr = pSsp->punk->QueryInterface(IID_ISMimePolicySimpleEdit, 
                                    (LPVOID *) & spspse);
    if (FAILED(hr)) {
        goto PolicyNotFoundError;
    }

    // get the policy flags
    hr = spspse->GetPolicyInfo(0, &dwPolicyFlags);
    if (FAILED(hr)) {
        goto PolicyError;
    }

    // get the classification information.
    hr = spspse->GetClassifications(0, &cClassifications, &pwszClassifications,
                                    &pdwClassifications, 
                                    &dwDefaultClassification);
    if (FAILED(hr)) {
        goto PolicyError;    
    }

    // get the default policy info.
    hr = spspse->GetDefaultPolicyInfo(0, &dwT, &pwchPrivacyMark);
    if (FAILED(hr)) {
        goto PolicyError;
    }
    Assert(dwT == dwDefaultClassification);

    // initialize the classification and privacy strings.    
    Assert((NULL == plabel) || (plabel->fHasClassification)); // UI currently doesn't allow one to not specify one.
    SendDlgItemMessage(hwndDlg, idcClassification, CB_RESETCONTENT, 0, 0);
    for (iClassification=0; iClassification<cClassifications; iClassification++) {
        // add the classification strings to the listbox.
        iEntry = SendDlgItemMessageW(hwndDlg, idcClassification, CB_ADDSTRING,
                                     (WPARAM) 0, 
                                     (LPARAM) pwszClassifications[iClassification]);
        if ((CB_ERR == iEntry) || (CB_ERRSPACE == iEntry)) {
            AssertSz(FALSE, "Unable to add classification string");
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        SendDlgItemMessageW(hwndDlg, idcClassification, CB_SETITEMDATA,
                           iEntry, (LPARAM) pdwClassifications[iClassification]);
        // If this classification is the one in the label, remember it.
        if ((NULL != plabel) && 
            (pdwClassifications[iClassification] == plabel->dwClassification)) {
            wszT = pwszClassifications[iClassification];
        }
        // if needed, pick up the default classification string.
        if ((NULL == wszT) && (pdwClassifications[iClassification] == dwDefaultClassification)) {
            wszT = pwszClassifications[iClassification];
        }
    }
    if (NULL == wszT) {
        Assert(FALSE);
        wszT = pwszClassifications[0];
    }
    // select the classification specified in the security label or the default one.
    Assert(wszT != NULL);
    iEntry =  SendDlgItemMessageW(hwndDlg, idcClassification, CB_SELECTSTRING,
                                 (WPARAM) ((int) -1), (LPARAM) wszT);
    Assert(CB_ERR != iEntry);

    // Set the privacy mark string.
    // if given label has one, use it, else if policy provided one, use it, 
    wszT = const_cast<LPWSTR>(c_PolwszEmpty);    
    if (NULL != plabel) {
        if (NULL != plabel->wszPrivacyMark) {
            wszT = plabel->wszPrivacyMark;
        }
    }
    else if (NULL != pwchPrivacyMark) {
        wszT = pwchPrivacyMark;
    }
    
    SendDlgItemMessageW(hwndDlg, idcPrivacyMark, WM_SETTEXT, 0, 
                        (LPARAM)(LPWSTR)wszT);

#if 0
    iEntry = SelectCBItemWithData(hwndDlg, idcPolicyModule, (DWORD) pSsp);
    iEntry = SendDlgItemMessageW(hwndDlg, idcPolicyModule, CB_SELECTSTRING,
                                 (WPARAM) ((int) -1),  (LPARAM) pSsp);
    AssertSz(CB_ERR != iEntry, "Hey why is this policy module missing from the listbox");

#else
    iEntry = SendDlgItemMessageW(hwndDlg, idcPolicyModule,
                                        CB_SELECTSTRING, 
                                        (WPARAM) (-1), 
                                        (LPARAM) pSsp->wszPolicyName);
    AssertSz(CB_ERR != iEntry, "Hey why is this policy module missing from the listbox");
//    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, iEntry);

#endif 

    // enable the controls.
    EnableWindow(GetDlgItem(hwndDlg, idcPolicyModule), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, idcClassification), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, idcClassification+1), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, idcPrivacyMark), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, idcPrivacyMark+1), TRUE);
    // the configure button is enabled if the policy module supports adv config.
    EnableWindow(GetDlgItem(hwndDlg, idcConfigure), 
                 (dwPolicyFlags & SMIME_POLICY_MODULE_SUPPORTS_ADV_CONFIG));

    // Set the privacy mark as read-only if the policy says so.
    if (dwPolicyFlags & SMIME_POLICY_MODULE_PRIVACYMARK_READONLY) {
        fPrivMarkReadOnly = TRUE; 
    }
    SendDlgItemMessage(hwndDlg, idcPrivacyMark, EM_SETREADONLY, 
                       (WPARAM) fPrivMarkReadOnly, 0);

    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, iEntry);
    hr = S_OK;
    // fall through to Exit;

Exit:
    SecPolicyFree(pwszClassifications);
    SecPolicyFree(pdwClassifications);
    SecPolicyFree(pwchPrivacyMark);
    return hr;


Error:
    // Set <none> as the security label.
    SideAssert(SUCCEEDED(HrSetLabelNone(hwndDlg, idcPolicyModule, 
                            idcClassification, idcPrivacyMark, idcConfigure)));
    goto Exit;
    
PolicyError:
    AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                MAKEINTRESOURCEW(idsSecPolicyErr), NULL, MB_OK | MB_ICONSTOP);
    goto Error;
    
PolicyNotFoundError:
    AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                MAKEINTRESOURCEW(idsSecPolicyNotFound), NULL, MB_OK | MB_ICONSTOP);
    goto Error;
}




//
// Initialize the Security Labels info.
// Input:
//    hwndDlg, idc's of controls. [in]
//    LPSEditSecLabelHelper.      [in].
// Returns: TRUE/FALSE
// 
BOOL SecurityLabelsOnInitDialog(HWND hwndDlg, PSMIME_SECURITY_LABEL plabel,
                                INT idcPolicyModule, INT idcClassification, 
                                INT idcPrivacyMark, INT idcConfigure) 
{
    BOOL    fRet = FALSE;
    HRESULT hr = E_FAIL;
    PSMIME_SECURITY_POLICY   pSsp = NULL;
    ULONG   iSsp;
    LONG_PTR    iEntry;

    // Validate i/p params.
    if ( ! IsWindow(hwndDlg) ) {
        fRet = FALSE;
        hr = E_INVALIDARG;
        goto Error;
    }

    SendDlgItemMessage(hwndDlg, idcPrivacyMark, EM_LIMITTEXT, 
                       (WPARAM)(MAX_PRIVACYMARK_LENGTH-1), 0);

    // Check if any policies are registered. 
    if (! FPresentPolicyRegInfo()) {
        // Just set label to none and return.
        hr = S_OK;
        fRet = TRUE;
        goto SetLabelNone; 
    }
    
    // Load the common names in the policy module listbox. 
    Assert(s_cSsp && s_rgSsp);
    for (iSsp=0; iSsp<s_cSsp; iSsp++) {
        // Add the policy module string to the lbox. (skip the default policy).
        if (0 == lstrcmpi(s_rgSsp[iSsp].szPolicyOid, c_szDefaultPolicyOid)) {
            continue;
        }
        iEntry = SendDlgItemMessageW(hwndDlg, idcPolicyModule, 
                                     CB_ADDSTRING, (WPARAM) 0, 
                                     (LPARAM) s_rgSsp[iSsp].wszPolicyName);
        Assert(iEntry != CB_ERR);
        SendDlgItemMessage(hwndDlg, idcPolicyModule, CB_SETITEMDATA,
                           (WPARAM) iEntry, (LPARAM) &s_rgSsp[iSsp]);
    }

    // If we already have a label in the security profile.
    // then try to initialize that policy and that label.
    if ((NULL != plabel) && (NULL != plabel->pszObjIdSecurityPolicy)) {

        // Next 3 lines for O2KFed
        // Set the label if the function fails it sets the label to None so ignore return
        hr = HrSetLabel(hwndDlg, idcPolicyModule, idcClassification,
                        idcPrivacyMark, idcConfigure, pSsp, plabel);
        if (FAILED(hr)) {
            goto Error;
        }
    }
    else {
        // if we aren't given a label to initialize with, then set <none>
        fRet = TRUE;
        goto SetLabelNone;
    }
    fRet = TRUE;
    goto Cleanup;
    
Error:
SetLabelNone:
    hr = HrSetLabelNone(hwndDlg, idcPolicyModule, idcClassification,
                        idcPrivacyMark, idcConfigure);
    Assert(SUCCEEDED(hr));
    
Cleanup:
    return fRet;
}


//
// Given a null-terminated wide string, returns TRUE if it 
// consists of only white wchars.
//
BOOL FIsWhiteStringW(LPWSTR wsz)
{
    BOOL    fRet = TRUE;

    if (NULL != wsz) {
        while (*wsz) {
            if (! iswspace(*wsz) ) {
                fRet = FALSE;
                break;
            }
            wsz++;
        }
    }
    return fRet;
}



//
// HrUpdateLabel
//
// Input:
//    hwndDlg, idc's of various controls. [in]
//    PSMIME_SECURITY_LABEL *pplabel       [in/out].
//
// Updates pplabel with the information in the seclabel dlg.
// 
HRESULT HrUpdateLabel(HWND hwndDlg, INT idcPolicyModule,
            INT idcClassification, INT idcPrivacyMark,
            INT idcConfigure, PSMIME_SECURITY_LABEL *pplabel) 
{
    HRESULT hr = E_FAIL;
    LONG_PTR    iEntry = 0;
    LONG    cwchT = 0;
    WCHAR   rgwchPrivacyMark[MAX_PRIVACYMARK_LENGTH];
    PSMIME_SECURITY_LABEL plabelT = NULL;
    PSMIME_SECURITY_POLICY pSsp = NULL;
    BOOL    fPolicyNotChanged = FALSE;
    LPSTR   szPolicyOid = NULL;
    DWORD   fHasClassification = FALSE;
    DWORD   dwClassification = 0;
    LPWSTR  wszPrivacyMark = NULL;

    
    // validate i/p params.
    if ( ! (hwndDlg && idcPolicyModule && idcClassification && 
            idcPrivacyMark && idcConfigure && pplabel) ) {
        AssertSz(FALSE, "HrUpdateLabel : Invalid args.");
        hr = E_INVALIDARG;
        goto Error;
    }
    if (NULL != *pplabel) {
        hr = HrDupLabel(&plabelT, *pplabel);
        if (FAILED(hr)) {
            goto Error;
        }
    }
    SecPolicyFree(*pplabel);
    

    // Update with the new information.
    // Get the policy and retrieve its oid.
    iEntry = SendMessage(GetDlgItem(hwndDlg, idcPolicyModule),
                         CB_GETCURSEL, 0, 0);
    if (iEntry == CB_ERR) {
        AssertSz(FALSE, "HrUpdateLabel : No label selected");
        goto Error;
    }
    pSsp = (PSMIME_SECURITY_POLICY) 
           SendDlgItemMessage(hwndDlg, idcPolicyModule, 
                 CB_GETITEMDATA, iEntry, 0);


    
    if (NULL == pSsp) {
        hr = S_OK;
        goto Exit;
    }

    if (NULL == pSsp->szPolicyOid) {
        AssertSz(FALSE, "HrUpdateLabel : Invalid policy oid");
        hr = E_FAIL;
        goto Error;
    }
    
    szPolicyOid = pSsp->szPolicyOid;
    // set the classification.
    iEntry = SendMessage(GetDlgItem(hwndDlg, idcClassification),
                         CB_GETCURSEL, 0, 0);
    if (CB_ERR != iEntry) {
        dwClassification = (DWORD) SendDlgItemMessage(hwndDlg, 
                    idcClassification, CB_GETITEMDATA, iEntry, 0);
        fHasClassification = TRUE;
    }

    // set the privacy mark.
    cwchT = GetDlgItemTextW(hwndDlg, idcPrivacyMark, 
                            rgwchPrivacyMark, DimensionOf(rgwchPrivacyMark) - 1);
    rgwchPrivacyMark[DimensionOf(rgwchPrivacyMark) - 1] = '\0'; // null terminate the string.
    if ((0 < cwchT) && !FIsWhiteStringW(rgwchPrivacyMark)) {
        wszPrivacyMark = rgwchPrivacyMark;
    }

    if ( (NULL != plabelT) && (NULL != plabelT->pszObjIdSecurityPolicy) ) {
        fPolicyNotChanged = (0 == lstrcmpi(plabelT->pszObjIdSecurityPolicy, szPolicyOid));
    }
    
    hr = HrGetLabelFromData(pplabel, szPolicyOid, fHasClassification, 
               dwClassification, wszPrivacyMark, 
               (fPolicyNotChanged ? plabelT->cCategories  : 0), 
               (fPolicyNotChanged ? plabelT->rgCategories : NULL) );
                         
    if (FAILED(hr)) {
        goto Error;
    }

    hr = S_OK;
    // fall through to Exit.
    
Exit:
    SecLabelDecode.pfnFree(plabelT);
    return hr;

Error:
    SecPolicyFree(*pplabel);
    goto Exit;
}





//
// OnChangePolicy. 
//
// Input:
//    hwndDlg. idc's for various controls.    [in]
//    iEntry.  index of newly selected policy [in]
//    PSMIME_SECURITY_LABEL     pplabel       [in/out]
//
// 
//
BOOL OnChangePolicy(HWND hwndDlg, LONG_PTR iEntry, INT idcPolicyModule,
        INT idcClassification, INT idcPrivacyMark,
        INT idcConfigure, PSMIME_SECURITY_LABEL *pplabel) 
{
    BOOL    fRet = FALSE;
    HRESULT hr = E_FAIL;
    PSMIME_SECURITY_POLICY pSsp = NULL;

    // validate i/p params.
    if (! (hwndDlg && idcPolicyModule && idcClassification && 
           idcPrivacyMark && idcConfigure && pplabel) ) {
        AssertSz(FALSE, "OnChangePolicy : Invalid args");
        hr = E_INVALIDARG;
        goto Error;
    }
    
    pSsp = (PSMIME_SECURITY_POLICY) SendDlgItemMessage(hwndDlg, 
                        idcPolicyModule, CB_GETITEMDATA, iEntry, 0);

    hr = HrSetLabel(hwndDlg, idcPolicyModule, idcClassification,
                    idcPrivacyMark, idcConfigure, pSsp, NULL);
    if (FAILED(hr)) {
        goto Error;
    }

    // update the label. 
    hr = HrUpdateLabel(hwndDlg, idcPolicyModule, idcClassification,
                       idcPrivacyMark, idcConfigure, pplabel);
    if (FAILED(hr)) {
        goto Error;
    }
    
    hr = S_OK; 
    // fall through to exit;
    
Exit:
    return fRet;
    
Error:
    SecPolicyFree(*pplabel);
    goto Exit;
}


//
// Security Labels Dialog Proc.
// 
// IN/OUT    pplabel.
// 
// Note: The caller is responsible for freeing the *pplabel. 
//
INT_PTR CALLBACK SecurityLabelsDlgProc(HWND hwndDlg, UINT msg, 
                                    WPARAM wParam, LPARAM lParam)
{
    HRESULT                hr;
    LONG_PTR               iEntry;
    LONG_PTR               iPrevEntry;

    PSMIME_SECURITY_LABEL *pplabel;

    
    switch ( msg) {
    case WM_INITDIALOG:
        // Remember the pselh we were handed.
        pplabel = (PSMIME_SECURITY_LABEL *) lParam;
        Assert(NULL !=pplabel);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pplabel);
        CenterDialog(hwndDlg);
        return SecurityLabelsOnInitDialog(hwndDlg, *pplabel,
                   IDC_POLICY_COMBO /*IDC_SL_POLICYMODULE*/, IDC_CLASSIF_COMB/* IDC_SL_CLASSIFICATION*/,
                   IDC_PRIVACY_EDIT/*IDC_SL_PRIVACYMARK*/, IDC_CONFIGURE/*IDC_SL_CONFIGURE*/);        
        break;
        
    case WM_COMMAND:
        pplabel = (PSMIME_SECURITY_LABEL *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        Assert(NULL != pplabel);
        switch (LOWORD(wParam)) {
        case IDC_POLICY_COMBO:

            switch (HIWORD(wParam)) {
            case CBN_SELENDOK:
            case CBN_SELCHANGE:
                iEntry = SendMessage(GetDlgItem(hwndDlg, IDC_POLICY_COMBO),
                                     CB_GETCURSEL, 0, 0);
                iPrevEntry = GetWindowLongPtr(hwndDlg, GWLP_USERDATA);    
                if ((iEntry != CB_ERR) && (iEntry != iPrevEntry)) {
                    return OnChangePolicy(hwndDlg, iEntry, IDC_POLICY_COMBO,
                                          IDC_CLASSIF_COMB, IDC_PRIVACY_EDIT,
                                          IDC_CONFIGURE, pplabel);
                }
                break;
            default:
                return FALSE;
                break;
            }
            
            break;
        case IDC_CONFIGURE:
            if ((NULL != *pplabel) && (NULL != (*pplabel)->pszObjIdSecurityPolicy)) {
                SpISMimePolicyFullEdit spspfe;                
                hr = HrQueryPolicyInterface(0, (*pplabel)->pszObjIdSecurityPolicy,
                                            IID_ISMimePolicyFullEdit, 
                                            (LPVOID *) &spspfe);
                if (SUCCEEDED(hr)) {
                    hr = spspfe->DoAdvancedEdit(0, hwndDlg, pplabel);
                    if (SUCCEEDED(hr)) {
                        Assert(NULL != *pplabel);
                        hr = HrSetLabel(hwndDlg, IDC_POLICY_COMBO, 
                                        IDC_CLASSIF_COMB, IDC_PRIVACY_EDIT,
                                        IDC_CONFIGURE, NULL, *pplabel);
                        Assert(SUCCEEDED(hr));
                    }
                }
            }
            break;
        case IDC_CLASSIF_COMB:
            break;
        case IDC_PRIVACY_EDIT:
            break;
        case IDOK:       
            hr = HrUpdateLabel(hwndDlg, IDC_POLICY_COMBO,
                    IDC_CLASSIF_COMB, IDC_PRIVACY_EDIT,
                    IDC_CONFIGURE, pplabel);
            EndDialog(hwndDlg, IDOK);
            break;        
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;
        default:
            return FALSE;
            break;
        }
        break;
        
    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxSecLabel);
        break;

    default:
        return FALSE;
        break;
    }
    
    return TRUE;
}


/////////////////////////////////
// Misc Label Utility fns.
/////////////////////////////////

//
// "Stringize" a given security label.
// Note: The caller must free the returned buffer pwszLabel with SecPolicyFree().
//
HRESULT HrGetStringizedLabel(PSMIME_SECURITY_LABEL plabel, LPWSTR *pwszLabel) 
{
    HRESULT     hr = E_FAIL;
    
    SpISMimePolicyLabelInfo  spspli;

    if ((NULL == plabel) || (NULL == pwszLabel) || (NULL == plabel->pszObjIdSecurityPolicy)) {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyLabelInfo,
                              (LPVOID *) &spspli);
    if (FAILED(hr) || !(spspli)) {
        goto Error;
    }

    // Get the stringized label.
    hr = spspli->GetStringizedLabel(0, plabel, pwszLabel);     
    if (FAILED(hr)) {
        goto Error;
    }
    // fall through to ExitHere.

ExitHere:
    return hr;

Error:
    goto ExitHere;
}

// mbcs version of above fn.
HRESULT HrGetStringizedLabelA(PSMIME_SECURITY_LABEL plabel, LPSTR *pszLabel) 
{
    HRESULT hr;
    LPSTR   pchLabel = NULL;
    LPWSTR  pwchLabel = NULL;
    int     cch, cchT;

    // validate i/p params.
    if ((NULL == plabel) || (NULL == pszLabel)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *pszLabel = NULL;

    // get the wide-stringized label.
    hr = HrGetStringizedLabel(plabel, &pwchLabel);
    if (FAILED(hr)) {
        goto Error;
    }

    // conver to an mbcs string.
    cch = WideCharToMultiByte(CP_ACP, 0, pwchLabel, -1, NULL, 0, NULL, NULL); 
    if (0 == cch) {
        hr = E_FAIL;
        goto Error;
    }
    
    pchLabel = (LPSTR) SecPolicyAlloc(cch);
    if (NULL == pchLabel) {
        hr = E_OUTOFMEMORY;                
        goto Error;
    }            

    cchT = WideCharToMultiByte(CP_ACP, 0, pwchLabel, -1, pchLabel, cch, NULL, NULL); 
    Assert(cch == cchT);
    if (0 == cchT) {
        Assert(FALSE);
        hr = E_FAIL;
        goto Error;
    }

    // success.
    *pszLabel = pchLabel;
    hr = S_OK;
    
ExitHere:
    SecPolicyFree(pwchLabel);
    return hr;

Error:
    SecPolicyFree(pchLabel);
    goto ExitHere;
}


//
// Given a policy oid, return its policy flags.
//
HRESULT HrGetPolicyFlags(LPSTR szPolicyOid, LPDWORD pdwFlags) 
{   
    HRESULT     hr = S_OK;
    DWORD       dwFlags;    
    SpISMimePolicySimpleEdit    spspse;

    // validate i/p parameters.
    if ((NULL == szPolicyOid) || (NULL == pdwFlags)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    *pdwFlags = 0;

    // Get the reqd interface.
    hr = HrQueryPolicyInterface(0, szPolicyOid, IID_ISMimePolicySimpleEdit,
                              (LPVOID *) &spspse);
    if (FAILED(hr) || !(spspse)) {
        goto Error;
    }

    // Get the policy flags.
    hr = spspse->GetPolicyInfo(0, &dwFlags);
    if (FAILED(hr)) {
        goto Error;
    }

    // success, set return values.
    *pdwFlags = dwFlags;

Exit:
    return hr;
    
Error:
    goto Exit;
}




//
// "Validate" a given security label and sender cert on Edit.
// The pplabel MAY be modified by the security policy.
//
HRESULT HrValidateLabelOnEdit(PSMIME_SECURITY_LABEL *pplabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertSign, PCCERT_CONTEXT pccertKeyEx)
{
    HRESULT   hr = E_FAIL;
    DWORD     dwFlags = 0;
    SpISMimePolicySimpleEdit    spspse;
    SpISMimePolicyValidateSend  spspvs;
    
    // Validate i/p parameters.
    if ((NULL == pplabel) || (NULL == hwndParent) ||
        (NULL == pccertSign) || (NULL == pccertKeyEx)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    if (NULL == *pplabel) {
        hr = S_OK;
        goto Exit;
    }

    // Find out if the policy requires sender/recipient cert validation.
    hr = HrQueryPolicyInterface(0, (*pplabel)->pszObjIdSecurityPolicy, 
                                IID_ISMimePolicySimpleEdit, (LPVOID *) &spspse);
    if (FAILED(hr) || !(spspse)) {
        goto Error;
    }


    // Query the policy to see if the label is valid.
    hr = spspse->IsLabelValid(0, hwndParent, pplabel);
    if (FAILED(hr) || (NULL == *pplabel)) {
        goto Error;
    }

    // get the policy flags.
    hr = HrGetPolicyFlags((*pplabel)->pszObjIdSecurityPolicy, &dwFlags);
    if (FAILED(hr)) {
        goto Error;
    }

    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, (*pplabel)->pszObjIdSecurityPolicy, IID_ISMimePolicyValidateSend,
                              (LPVOID *) &spspvs);
    if (FAILED(hr) || !(spspvs)) {
        goto Error;
    }
    

    // verify that the signing cert is allowed by the security policy.
    if ((dwFlags & SMIME_POLICY_MODULE_VALIDATE_SENDER) && (NULL != pccertSign)) {
        hr = spspvs->IsValidLabelSignerCert(0, hwndParent, *pplabel, pccertSign);
        if (FAILED(hr)) {
            goto Error;
        }
    }

    // verify that the recipient certs are allowed by the security policy.
    if ( (dwFlags & SMIME_POLICY_MODULE_VALIDATE_RECIPIENT) && 
         (NULL != pccertKeyEx) ) {

        //$ M00Bug: 
        // ValidateRecipient && !pccertKeyEx should probably be an error.
        
        hr = spspvs->IsValidLabelRecipientCert(0, hwndParent, *pplabel, pccertKeyEx);
        if (FAILED(hr)) {
            goto Error;
        }
    }

    // success. fall through to exit.
    
    
Exit:    
Error:    
    return hr;
}







//
// "Validate" a given security label and recipient cert.
//
HRESULT HrValidateLabelRecipCert(PSMIME_SECURITY_LABEL plabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertRecip) 
{
    HRESULT     hr = S_OK;
    DWORD       dwFlags;
    SpISMimePolicyValidateSend  spspvs;

    // Validate i/p parameters.
    if ((NULL == plabel) || (NULL == pccertRecip)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    
    // get the policy flags.
    hr = HrGetPolicyFlags(plabel->pszObjIdSecurityPolicy, &dwFlags);
    if (FAILED(hr)) {
        goto Error;
    }

    // see if we need to validate sender.
    if (! (dwFlags & SMIME_POLICY_MODULE_VALIDATE_RECIPIENT) ) {
        // No Recipient validation is required.
        hr = S_OK;
        goto ExitHere;
    }
    
    
    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyValidateSend,
                              (LPVOID *) &spspvs);
    if (FAILED(hr) || !(spspvs)) {
        goto Error;
    }


    // verify that the recipient certs are allowed by the security policy.
    hr = spspvs->IsValidLabelRecipientCert(0, hwndParent, plabel, pccertRecip);
    if (FAILED(hr)) {
        goto Error;
    }
    
    // fall through to ExitHere.

ExitHere:
    return hr;

Error:
    goto ExitHere;
}



//
// "Validate" a given security label and signer cert.
//
HRESULT HrValidateLabelSignerCert(PSMIME_SECURITY_LABEL plabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertSigner) 
{
    HRESULT     hr = S_OK;
    DWORD       dwFlags;
    SpISMimePolicyValidateSend  spspvs;

    // Validate i/p parameters.
    if ((NULL == plabel) || (NULL == pccertSigner)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    
    // get the policy flags.
    hr = HrGetPolicyFlags(plabel->pszObjIdSecurityPolicy, &dwFlags);
    if (FAILED(hr)) {
        goto Error;
    }

    // see if we need to validate sender.
    if (! (dwFlags & SMIME_POLICY_MODULE_VALIDATE_SENDER) ) {
        // No Recipient validation is required.
        hr = S_OK;
        goto ExitHere;
    }
    
    
    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyValidateSend,
                              (LPVOID *) &spspvs);
    if (FAILED(hr) || !(spspvs)) {
        goto Error;
    }


    // verify that the signer certs are allowed by the security policy.
    hr = spspvs->IsValidLabelSignerCert(0, hwndParent, plabel, pccertSigner);
    if (FAILED(hr)) {
        goto Error;
    }
    
    // fall through to ExitHere.

ExitHere:
    return hr;

Error:
    goto ExitHere;
}





//
// "Validate" a given security label and certs.
//
HRESULT HrValidateLabelOnSend(PSMIME_SECURITY_LABEL plabel, HWND hwndParent, 
                              PCCERT_CONTEXT pccertSign,
                              ULONG ccertRecip, PCCERT_CONTEXT *rgccertRecip) 
{
    HRESULT     hr = S_OK;
    DWORD       dwFlags;
    ULONG       icert;
    SpISMimePolicyValidateSend  spspvs;

    // Validate i/p parameters.
    if ((NULL == plabel) || (NULL == pccertSign)) {
        hr = E_INVALIDARG;
        goto Error;
    }
    
    // get the policy flags.
    hr = HrGetPolicyFlags(plabel->pszObjIdSecurityPolicy, &dwFlags);
    if (FAILED(hr)) {
        goto Error;
    }

    // see if we need to validate sender and/or recipient(s).
    if (! (dwFlags & 
           (SMIME_POLICY_MODULE_VALIDATE_SENDER | SMIME_POLICY_MODULE_VALIDATE_RECIPIENT)) ) {
        // No Sender/Recipient validation is required.
        hr = S_OK;
        goto ExitHere;
    }
    
    
    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyValidateSend,
                              (LPVOID *) &spspvs);
    if (FAILED(hr) || !(spspvs)) {
        goto Error;
    }
    

    // verify that the signing cert is allowed by the security policy.
    if ((dwFlags & SMIME_POLICY_MODULE_VALIDATE_SENDER) && (NULL != pccertSign)) {
        hr = spspvs->IsValidLabelSignerCert(0, hwndParent, plabel, pccertSign);
        if (FAILED(hr)) {
            goto Error;
        }
    }

    // verify that the recipient certs are allowed by the security policy.
    if ( (dwFlags & SMIME_POLICY_MODULE_VALIDATE_RECIPIENT) && 
         (0 < ccertRecip) && (NULL != rgccertRecip) ) {
        for (icert=0; icert<ccertRecip; icert++) {
            hr = spspvs->IsValidLabelRecipientCert(0, hwndParent, plabel, rgccertRecip[icert]);
            if (FAILED(hr)) {
                goto Error;
            }
        }
    }
    
    // fall through to ExitHere.

ExitHere:
    return hr;

Error:
    goto ExitHere;
}


//
// Does the admin force a security label on all S/MIME signed messages?
//
BOOL FForceSecurityLabel(void)
{
    enum EForceLabel { 
        FORCELABEL_UNINIT = 0, 
        FORCELABEL_YES = 1,
        FORCELABEL_NO  = 2 };
    
    static EForceLabel eForceLabel = FORCELABEL_UNINIT;  // uninitialized.
    
    if (!IsSMIME3Supported()) {
        return FALSE;       
    }
    
    if (eForceLabel == FORCELABEL_UNINIT) {
        DWORD  dwDefault = 0;
        DWORD  dwForceLabel = 0;
        DWORD  dwType;
        LPBYTE pb = (LPBYTE) &dwForceLabel;
        ULONG  cb = sizeof(dwForceLabel);
        static const CHAR SzForceSecurityLabel[] = "ForceSecurityLabel";
    
        // Get our Admin key and check if we should enable Fed Features.

        if (FAILED(HrQueryRegValue(0, (LPSTR) SzForceSecurityLabel, &dwType,
                                   &pb, &cb, REG_DWORD, (LPBYTE) &dwDefault, 
                                   sizeof(dwDefault))) ||
            (dwType != REG_DWORD) ) {
            dwForceLabel = dwDefault;
        }

        if (dwForceLabel != 0) {
            eForceLabel = FORCELABEL_YES;
        }
        else {
            eForceLabel = FORCELABEL_NO;
        }
    }

    return (eForceLabel == FORCELABEL_YES);
}

//
// Get the label we are forced to us by the admin
//
HRESULT HrGetForcedSecurityLabel(PSMIME_SECURITY_LABEL* ppLabel)
{
    ULONG                   cb = 0;
    DWORD                   dwType;
    HRESULT                 hr = S_OK;
    LPBYTE                  pbLabel = NULL;
    PSMIME_SECURITY_LABEL   pLabel = NULL;
    static const CHAR       SzForceSecurityLabelX[] = "ForceSecurityLabelX";

    *ppLabel = NULL;
    if (FForceSecurityLabel()) {
    
        hr = HrQueryRegValue(0, (LPSTR) SzForceSecurityLabelX, &dwType,
                             &pbLabel, &cb, REG_BINARY, NULL, 0);
        if (SUCCEEDED(hr) && (dwType == REG_BINARY)) {
            DWORD cbLabel = 0;
            hr = HrDecodeAndAllocLabel(pbLabel, cb, 
                                       &pLabel, &cbLabel);
            if (SUCCEEDED(hr)) {
                *ppLabel = pLabel;
                pLabel = NULL;
            }
        }
        
    }
    if (pbLabel != NULL) free(pbLabel);
    SecPolicyFree(pLabel);
    return hr;
}

// Given a label, load its policy and show the read-only
// label info dialog.
HRESULT HrDisplayLabelInfo(HWND hwndParent, PSMIME_SECURITY_LABEL plabel)
{
    HRESULT hr = E_FAIL;
    SpISMimePolicyLabelInfo spspli;

    // validate i/p params.
    if ((NULL == plabel) || (NULL == plabel->pszObjIdSecurityPolicy)) {
        hr = E_INVALIDARG;
        goto Error;
    }

    // load the policy and get the reqd interface.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, 
                      IID_ISMimePolicyLabelInfo, (LPVOID *) &spspli);
    if (FAILED(hr)) {
        // the policy OR the reqd intf wasn't found.
        goto Error;
    }

    // Display the label-info dlg.
    hr = spspli->DisplayAdvancedLabelProperties(0, hwndParent, plabel);
    if (FAILED(hr)) {
        goto Error;
    }

    // success.
    hr = S_OK;
    
Exit:    
    return hr;
Error:
    goto Exit;
}


DWORD DetermineCertUsageWithLabel(PCCERT_CONTEXT pccert, PSMIME_SECURITY_LABEL pLabel)
{
    DWORD   dwUsage = 0;
    HRESULT hr;

    Assert(NULL != pccert);
    Assert(NULL != pLabel);

    hr = HrGetCertKeyUsage(pccert, &dwUsage);
    if (S_OK != hr) {
        goto Exit;
    }
    if (0 != (KEY_USAGE_SIGNING & dwUsage)) {
        hr = HrValidateLabelSignerCert(pLabel, NULL, pccert);
        if (FAILED(hr)) {
            dwUsage &= (~KEY_USAGE_SIGNING);
        }
    }

    if (0 != (KEY_USAGE_ENCRYPTION & dwUsage)) {
        hr = HrValidateLabelRecipCert(pLabel, NULL, pccert);
        if (FAILED(hr)) {
            dwUsage &= (~KEY_USAGE_ENCRYPTION);
        }
    }

Exit:
    return dwUsage;
}

// Create default label, if it's not exist 

HRESULT HrGetDefaultLabel(PSMIME_SECURITY_LABEL *pplabel)
{
    SpISMimePolicySimpleEdit spspse = NULL;
    WCHAR    *pwchPrivacyMark = NULL;

    DWORD     dwT = 0;


    // Load the info from the registry if reqd.
    HRESULT hr = _HrEnsurePolicyRegInfoLoaded(0);
    if (FAILED(hr)) {
        goto Error;
    }    

    // If we haven any installed policies, search for the one we want.
    if (FPresentPolicyRegInfo()) 
    {
        if(s_cSsp > 0)
        {
            // if it is already loaded, then we are done. 
            hr = HrQueryPolicyInterface(0, s_rgSsp[0].szPolicyOid, IID_ISMimePolicySimpleEdit, 
                                    (LPVOID *) & spspse);

            if (FAILED(hr)) 
            {
                goto Error;
            }
    
            hr = spspse->GetDefaultPolicyInfo(0, &dwT, &pwchPrivacyMark);

            if (FAILED(hr)) 
            {
                goto Error;
            }

            hr = HrGetLabelFromData(pplabel, 
                                    s_rgSsp[0].szPolicyOid, 
                                    TRUE,               // fHasClassification, 
                                    dwT,                // dwClassification, 
                                    pwchPrivacyMark,    // wszPrivacyMark, 
                                    0, NULL);

        }
    }

Error:
// Cleanup:
    if(pwchPrivacyMark)
        SecPolicyFree(pwchPrivacyMark);

#ifdef YST          // We don't need to relase spspse, because we use SpISMIME...(ATL does ecerything)
    if(spspse)
    {
        spspse->Release();
    }
#endif //YST

    return hr;
}

// Check label in registry, is not exist then return default label
HRESULT HrGetOELabel(PSMIME_SECURITY_LABEL *pplabel)
{
    HRESULT     hr = E_FAIL;
    LPWSTR   pwchPolicyName     = NULL;
    LPWSTR   pwchPrivacyMark    = NULL;
    LPBYTE   pbCategory       = NULL;
    CRYPT_ATTRIBUTE_TYPE_VALUE *pCategories = NULL;
    DWORD    cCat =0;

    DWORD    dwSize;
    TCHAR    *pchPolicyName = NULL;
    DWORD    dwT = 0;

    if(NULL == pplabel)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    dwSize = DwGetOption(OPT_POLICYNAME_SIZE);
    // if policy name is not set
    if(dwSize <= 0)
        return(HrGetDefaultLabel(pplabel));

    if(!MemAlloc((LPVOID *)&pchPolicyName, dwSize + 1))
        return(HrGetDefaultLabel(pplabel));

    if( GetOption(OPT_POLICYNAME_DATA, pchPolicyName, dwSize) != dwSize)
    {
        hr  = HrGetDefaultLabel(pplabel);
        goto Error;
    }
    
    // get privacy mark
    dwSize = DwGetOption(OPT_PRIVACYMARK_SIZE);
    if(dwSize > 0)
    {
        if(MemAlloc((LPVOID *)&pwchPrivacyMark, (dwSize * sizeof(WCHAR)) + 1))
            GetOption(OPT_PRIVACYMARK_DATA, pwchPrivacyMark, (dwSize * sizeof(WCHAR)));
    }

    // get category
    dwSize = DwGetOption(OPT_CATEGORY_SIZE);
    if(dwSize > 0)
    {
        if(MemAlloc((LPVOID *)&pbCategory, (dwSize * sizeof(BYTE))))
        {
            if(GetOption(OPT_CATEGORY_DATA, pbCategory, (dwSize * sizeof(BYTE))))
            {
                hr = BinaryToCategories(&pCategories, &cCat, pbCategory);
                if(FAILED(hr))
                    goto Error;
            }
        }
    }

    // get classification
    dwSize = DwGetOption(OPT_HAS_CLASSIFICAT);
    if(dwSize > 0)
            dwT = DwGetOption(OPT_CLASSIFICAT_DATA);

    hr = HrGetLabelFromData(pplabel, 
            pchPolicyName, 
            dwSize,             // fHasClassification, 
            dwT,                // dwClassification, 
            pwchPrivacyMark,    // wszPrivacyMark, 
            cCat, 
            pCategories);


Error:

    if(cCat > 0)
    {
        UINT i;
        for(i = 0; i < cCat; i++)
        {
            MemFree(pCategories[i].pszObjId);
            MemFree(pCategories[i].Value.pbData);
        }
        MemFree(pCategories);
    }

    MemFree(pwchPrivacyMark);
    MemFree(pbCategory);    
    MemFree(pchPolicyName);
    return hr;

}

// Save label in registry
HRESULT HrSetOELabel(PSMIME_SECURITY_LABEL plabel)
{
    HRESULT     hr = E_FAIL;
    LPWSTR   pwchPolicyName = NULL;
    LPWSTR   pwchClassification = NULL;
    LPWSTR   pwchPrivacyMark    = NULL;
    LPWSTR   pwchCategory       = NULL;
    DWORD    dwSize;
    BYTE    *pArray = NULL;
    int Size = 0;

    SpISMimePolicyLabelInfo  spspli;

    if ((NULL == plabel) || (NULL == plabel->pszObjIdSecurityPolicy)) 
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Get the required interface to the policy module.
    hr = HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyLabelInfo,
                              (LPVOID *) &spspli);
    if (FAILED(hr) || !(spspli)) 
    {
        goto Error;
    }

    // get label as strings
    hr = spspli->GetLabelAsStrings(0, plabel, &pwchPolicyName, &pwchClassification, &pwchPrivacyMark, &pwchCategory);
    if (FAILED(hr))
        goto Error;

    // save Policy name
    if(pwchPolicyName == NULL)
    {
        Assert(FALSE);
        goto Error;

    }

    dwSize = lstrlen(plabel->pszObjIdSecurityPolicy) + 1;
    SetDwOption(OPT_POLICYNAME_SIZE, dwSize, NULL, 0);
    SetOption(OPT_POLICYNAME_DATA, plabel->pszObjIdSecurityPolicy, dwSize, NULL, 0);


    // Save Classification
    SetDwOption(OPT_HAS_CLASSIFICAT, plabel->fHasClassification, NULL, 0);
    if(plabel->fHasClassification)
        SetDwOption(OPT_CLASSIFICAT_DATA, plabel->dwClassification, NULL, 0);

    // Save Privacy mark
    dwSize = pwchPrivacyMark ? (wcslen(pwchPrivacyMark) + 1) : 0;
    SetDwOption(OPT_PRIVACYMARK_SIZE, dwSize, NULL, 0);
    if(dwSize)
        SetOption(OPT_PRIVACYMARK_DATA, pwchPrivacyMark, dwSize*sizeof(WCHAR), NULL, 0);

    // Save Category
    hr = CategoriesToBinary(plabel, &pArray, &Size);
    if(FAILED(hr))
        goto Error;
    SetDwOption(OPT_CATEGORY_SIZE, Size, NULL, 0);
    if(Size)
        SetOption(OPT_CATEGORY_DATA, pArray, Size*sizeof(BYTE), NULL, 0);

Error:
    MemFree(pArray);
    SecPolicyFree(pwchPolicyName);
    SecPolicyFree(pwchClassification);
    SecPolicyFree(pwchPrivacyMark);
    SecPolicyFree(pwchCategory);    
    return hr;
}


////    QueryRegistry
//
//  Description:
//      This is a common function which should be used to get information from the
//      registry in most cases.  It will look in both the HLKM and HKCU registries
//      as requested.
//
//   M00TODO -- Should check for errors and distinguish between denied and 
//      non-existance.
//

HRESULT HrQueryRegValue(DWORD dwFlags, LPSTR szRegKey, LPDWORD pdwType, 
                        LPBYTE * ppbData, LPDWORD  pcbData, DWORD dwDefaultType,
                        LPBYTE pbDefault, DWORD cbDefault)
{
    DWORD       cbData;
    HKEY        hKey;
    DWORD       l;
    LPBYTE      pbData;
    
    //
    //  Start by getting the Local Machine first if possible
    //

    if (!(dwFlags & QRV_Suppress_HKLM)) {
        //
        //  Open the key if it exists
        //
        
        l = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SzRegSecurity, 0, KEY_QUERY_VALUE,
                         &hKey);

        //
        //  If we succeed in opening the key, then we will look for the value
        //
        
        if (l == ERROR_SUCCESS) {
            //
            //  If they passed in a size, then we use that as the size, otherwise
            //  we need to find the size of the object to be used
            //
            
            if ((pcbData != NULL) && (*pcbData != 0)) {
                cbData = *pcbData;
                pbData = *ppbData;
            }
            else {
                cbData = 0;
                pbData = NULL;
            }

            //
            //  Query for the actual value.
            //
            
            l = RegQueryValueEx(hKey, szRegKey, NULL, pdwType, pbData, &cbData);

            //
            // On success -- return the value
            //
            
            if (l == ERROR_SUCCESS) {
                if ((pcbData == NULL) || (*pcbData == 0)) {
                    pbData = (LPBYTE) malloc(cbData);
                    if (pbData == NULL) {
                        RegCloseKey(hKey);
                        return E_OUTOFMEMORY;
                    }
                
                    l = RegQueryValueEx(hKey, szRegKey, NULL, pdwType, pbData, &cbData);
                    RegCloseKey(hKey);
                    if (l == ERROR_SUCCESS) {
                        if (pcbData != NULL) {
                            *pcbData = cbData;
                        }
                        *ppbData = pbData;
                        return S_OK;
                    }
                    free(pbData);
                    return 0x80070000 | l;
                }
                if (pcbData != NULL) {
                    *pcbData = cbData;
                }
                RegCloseKey(hKey);
                return S_OK;
            }
            else if (l != ERROR_FILE_NOT_FOUND) {
                RegCloseKey(hKey);
                return 0x80070000 | l;
            }
            
            RegCloseKey(hKey);
        }

        //
        //  If we failed to open the key for some reason other than non-presence,
        //      return that error
        //
        
        else if (l != ERROR_FILE_NOT_FOUND) {
            return 0x80070000 | l;
        }

        //
        //  Not found error -- try the next registry object
        //
    }

    //
    //  Start by getting the Local Machine first if possible
    //

    if (!(dwFlags & QRV_Suppress_HKCU)) {
        //
        //  Open the key if it exists
        //
        
        l = RegOpenKeyEx(HKEY_CURRENT_USER, SzRegSecurity, 0, KEY_QUERY_VALUE, &hKey);

        //
        //  If we succeed in opening the key, then we will look for the value
        //
        
        if (l == ERROR_SUCCESS) {
            //
            //  If they passed in a size, then we use that as the size, otherwise
            //  we need to find the size of the object to be used
            //
            
            if ((pcbData != NULL) && (*pcbData != 0)) {
                cbData = *pcbData;
                pbData = *ppbData;
            }
            else {
                cbData = 0;
                pbData = NULL;
            }

            //
            //  Query for the actual value.
            //
            
            l = RegQueryValueEx(hKey, szRegKey, NULL, pdwType, pbData, &cbData);

            //
            // On success -- return the value
            //
            
            if (l == ERROR_SUCCESS) {
                if ((pcbData == NULL) || (*pcbData == 0)) {
                    pbData = (LPBYTE) malloc(cbData);
                    if (pbData == NULL) {
                        RegCloseKey(hKey);
                        return E_OUTOFMEMORY;
                    }
                
                    l = RegQueryValueEx(hKey, szRegKey, NULL, pdwType, pbData, &cbData);
                    RegCloseKey(hKey);
                    if (l == ERROR_SUCCESS) {
                        if (pcbData != NULL) {
                            *pcbData = cbData;
                        }
                        *ppbData = pbData;
                        return S_OK;
                    }
                    free(pbData);
                    return 0x80070000 | l;
                }
                if (pcbData != NULL) {
                    *pcbData = cbData;
                }
                RegCloseKey(hKey);
                return S_OK;
            }
            else if (l != ERROR_FILE_NOT_FOUND) {
                RegCloseKey(hKey);
                return 0x80070000 | l;
            }
            
            RegCloseKey(hKey);
        }

        //
        //  If we failed to open the key for some reason other than non-presence,
        //      return that error
        //
        
        else if (l != ERROR_FILE_NOT_FOUND) {
            return 0x80070000 | l;
        }

        //
        //  Not found error -- try the next registry object
        //
    }

    //
    //  No value found, return the default value if it is present
    //

    if (pbDefault == NULL) {
        return 0x80070000 | ERROR_FILE_NOT_FOUND;   // Not found
    }

    if ((pcbData != NULL) && (*pcbData != 0) && (cbDefault > *pcbData)) {
        return 0x80070000 | ERROR_MORE_DATA;
    }

    if ((pcbData != NULL) && (*pcbData == 0)) {
        *ppbData = (LPBYTE) malloc(cbDefault);
        if (*ppbData == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    memcpy(*ppbData, pbDefault, cbDefault);
    if (pcbData != NULL) *pcbData = cbDefault;
    if (pdwType != NULL) *pdwType =  dwDefaultType;
    return S_OK;
}

HRESULT CategoriesToBinary(PSMIME_SECURITY_LABEL plabel, BYTE * *ppArray, int *cbSize)
{
    HRESULT hr = S_OK;
    int i = 0;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pcatv = NULL;
    LPBYTE pv = NULL;
    int size;

    // pArray = NULL;
    *cbSize = 0;

    if(plabel->cCategories == 0)
        return S_OK;

    // Find size of memory that we need
    size = sizeof(int);
    for (i = 0; i < ((int) plabel->cCategories); i++) 
    {
        pcatv = & (plabel->rgCategories[i]);
        size += sizeof(int);
        size += lstrlen(pcatv->pszObjId) + 1;
        size += sizeof(DWORD);
        size += pcatv->Value.cbData;
    }

    Assert(size > sizeof(int));

    // allocate the required memory.
    if(!MemAlloc((LPVOID *)ppArray, size*sizeof(BYTE)))
        return E_OUTOFMEMORY;

    *cbSize = size;

    // construct array
    pv = *ppArray;

    memcpy(pv, &(plabel->cCategories), sizeof(DWORD));
    pv += sizeof(DWORD);
    for (i = 0; i < ((int) plabel->cCategories); i++) 
    {
        pcatv = & (plabel->rgCategories[i]);
        size = lstrlen(pcatv->pszObjId);
        memcpy(pv, &size, sizeof(int));    
        pv += sizeof(int);
        memcpy(pv, pcatv->pszObjId, size);
        pv += size;
        memcpy(pv, &(pcatv->Value.cbData), sizeof(DWORD));    
        pv += sizeof(DWORD);
        memcpy(pv, pcatv->Value.pbData, pcatv->Value.cbData);
        pv += pcatv->Value.cbData;
    }
    return(S_OK);
}   

HRESULT BinaryToCategories(CRYPT_ATTRIBUTE_TYPE_VALUE ** ppCategories, DWORD *cCat, BYTE * pArray)
{
    HRESULT hr = S_OK;
    int i = 0;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pcatv = NULL;
    LPBYTE pv = pArray;
    int size;
    DWORD dwVal = 0;


    // Number of elements in array
    memcpy(&dwVal, pv, sizeof(DWORD));
    pv += sizeof(DWORD);

    Assert(dwVal > 0);

    // Allocate memory for array of categories

    if(!MemAlloc((LPVOID *)ppCategories, dwVal*sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE)))
        return E_OUTOFMEMORY;

    *cCat = dwVal;

    // construct array
    for (i = 0; i < ((int) *cCat); i++) 
    {
        pcatv = &((*ppCategories)[i]);
        // pszObjId is ANSI string
        memcpy(&size, pv, sizeof(int));
        pv += sizeof(int);
        if(!MemAlloc((LPVOID *)&(pcatv->pszObjId), size*sizeof(CHAR)+1))
            return E_OUTOFMEMORY;
        memcpy(pcatv->pszObjId, pv, size);
        pcatv->pszObjId[size] = '\0';   
        pv += size;

        // Value
        memcpy(&dwVal, pv, sizeof(DWORD));    
        pv += sizeof(DWORD);
        pcatv->Value.cbData = dwVal;

        if(!MemAlloc((LPVOID *)&(pcatv->Value.pbData), dwVal*sizeof(BYTE)))
            return E_OUTOFMEMORY;

        memcpy(pcatv->Value.pbData, pv, dwVal);
        pv += dwVal;
    }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\serverq.cpp ===
/*
 *    s e r v e r q . c p p 
 *
 *    Purpose:  
 *        Implements IMessageServer wrapper for queuing operations to 
 *        IMessageServer object.
 *
 *      This object knows how to pack stack data for an IMessageServer method
 *      call into a queue so that the call can be reissued when the server is
 *      free. It maintains a small listen window so that is can post async
 *      messages to itself to allow completion of the next task
 *
 *    Owner:
 *        brettm.
 *
 *  History:
 *      June 1998: Created
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */

#include "pch.hxx"
#include "instance.h"
#include "storutil.h"
#include "serverq.h"

static TCHAR    c_szServerQListenWnd[] = "OE ServerQWnd";

#define SQW_NEXTTASK        (WM_USER + 1)

/*
 * Notes:
 *
 * the queueing is a little odd. For every method, we immediatley throw it in 
 * the queue. If the server is not busy then we post a message to ourselves to
 * dequeue the task. We do this as if we passed-thru when the server is not busy
 * then we never get to hook the IStoreCallback to watch for completion, so we
 * never know when to queue the next task.
 *
 */

CServerQ::CServerQ()
{
    m_cRef = 1;
    m_pServer = NULL;
    m_pTaskQueue = NULL;
    m_pLastQueueTask = NULL;
    m_hwnd = NULL;
    m_pCurrentCallback = NULL;
    m_pCurrentTask = NULL;
    m_cRefConnection = 0;
#ifdef DEBUG
    m_DBG_pArgDataLast = 0;
#endif
}

CServerQ::~CServerQ()
{
    SafeRelease(m_pServer);
    _Flush(TRUE);
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);
}

// IUnknown Members
HRESULT CServerQ::QueryInterface(REFIID iid, LPVOID *ppvObject)
{
    HRESULT hr=E_NOINTERFACE;

    TraceCall("CServerQ::QueryInterface");

    if (ppvObject == NULL)
        return TraceResult(E_INVALIDARG);

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid)
        *ppvObject = (IMessageServer *)this;
    else if (IID_IMessageServer == iid)
        *ppvObject = (IMessageServer *)this;
    else if (IID_IServiceProvider == iid)
        *ppvObject = (IServiceProvider *)this;
    else if (IID_IStoreCallback == iid)
        *ppvObject = (IStoreCallback *)this;

    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }

    return hr;
}

ULONG CServerQ::AddRef()
{
    return ++m_cRef;

}

ULONG CServerQ::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT CServerQ::Init(IMessageServer *pServerInner)
{
    HRESULT     hr=S_OK;
    WNDCLASS    wc;

    TraceCall("CServerQ::Init");
    
    Assert(m_pServer == NULL);

    if (!pServerInner)
        return TraceResult(E_INVALIDARG);

    if (!GetClassInfo(g_hInst, c_szServerQListenWnd, &wc))
    {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        
        wc.lpfnWndProc   = (WNDPROC)CServerQ::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = NULL;
        wc.lpszClassName = c_szServerQListenWnd;
        wc.hbrBackground = NULL;
        wc.style = 0;

        if (!RegisterClass(&wc))
            return TraceResult(E_OUTOFMEMORY);
    }

    m_hwnd=CreateWindow(c_szServerQListenWnd, 
                        NULL, WS_OVERLAPPED,
                        0, 0, 0, 0,
                        NULL, NULL,
                        g_hInst,
                        (LPVOID)this);
    if (!m_hwnd)
        return TraceResult(E_OUTOFMEMORY);

#ifdef DEBUG
    // debug timer
    SetTimer(m_hwnd, 0, 10000, NULL);
#endif
    ReplaceInterface(m_pServer, pServerInner);
    return S_OK;
}


// IMessageServer Methods
HRESULT CServerQ::Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder)
{
    return m_pServer->Initialize(pStore, idStoreRoot, pFolder, idFolder);
}

HRESULT CServerQ::ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder)
{
    return m_pServer->ResetFolder(pFolder, idFolder);
}

HRESULT CServerQ::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    return m_pServer->SetIdleCallback(pDefaultCallback);
}


HRESULT CServerQ::SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_SYNC_FOLDER, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->dwSyncFlags = dwFlags;
        pArg->cHeaders = cHeaders;
        return E_PENDING;
    }
    return TraceResult(hr);
}

HRESULT CServerQ::GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback)
{
    ARGUMENT_DATA       *pArg,
                        *pTask;
    HRESULT             hr;
    STOREOPERATIONINFO  soi;
    BOOL                fFound=FALSE;
    ULONG               l;

    // if we have tasks in our queue, looks for a get message task with the same id
    // if we find one, add this callback to the list and return STORE_S_ALREADYPENDING
    // to indicate that the pStream passed in will NOT be written to, and the caller
    // should get the message from the cache when his complete is called
    
    // make sure that the current task's next ptr points to the task queue
    // also make sure there is no task queue if there are no pending tasks
    Assert (m_pCurrentTask == NULL && m_pTaskQueue==NULL ||
            m_pCurrentTask->pNext == m_pTaskQueue);

    pTask = m_pCurrentTask;

    // let's look for a pending request for this message
    while (pTask)
    {
        if (pTask->sot == SOT_GET_MESSAGE && pTask->idMessage == idMessage)
        {
            if (pCallback)
            {
                // cruise thro' the callback list. If this IStoreCallback is already 
                // registered for this message, then don't add it otherwise it will
                // get multiple notifications
                if (pTask->pCallback == pCallback)
                    fFound = TRUE;
                else
                    for (l = 0; l < pTask->cOtherCallbacks; l++)
                        if (pTask->rgpOtherCallback[l] == pCallback)
                        {
                            fFound = TRUE;
                            break;
                        }

                if (!fFound)
                {
                    if (!MemRealloc((LPVOID *)&pTask->rgpOtherCallback,
                        sizeof(IStoreCallback *) * (pTask->cOtherCallbacks+1)))
                    {
                        hr = TraceResult(E_OUTOFMEMORY);
                        goto exit;
                    }
            
                    pTask->rgpOtherCallback[pTask->cOtherCallbacks++] = pCallback;
                    pCallback->AddRef();

                    if (pTask == m_pCurrentTask)
                    {
                        // if this task if the current task, then the OnBegin call has already
                        // been called. We fake the OnBegin to provide message id on get message start
                        soi.cbSize = sizeof(STOREOPERATIONINFO);
                        soi.idMessage = idMessage;
                        pCallback->OnBegin(SOT_GET_MESSAGE, &soi, NULL);
                    }                
                }
            }
            hr = STORE_S_ALREADYPENDING;
            goto exit;  // found
        }
        pTask = pTask->pNext;
    }
    
    // not already queued, let's add it.
    hr = _AddToQueue(SOT_GET_MESSAGE, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idMessage = idMessage;
        
        return E_PENDING;
    }

exit:
    return hr;
}

HRESULT CServerQ::PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_PUT_MESSAGE, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        pArg->dwMsgFlags = dwFlags;

        if (NULL != pftReceived)
        {
            pArg->ftReceived = *pftReceived;
            pArg->pftReceived = &pArg->ftReceived;
        }
        else
            pArg->pftReceived = NULL;
    
        if (NULL != pStream)
        {
            pArg->pPutStream = pStream;
            pStream->AddRef();
        }
        
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::CopyMessages(IMessageFolder *pDestFldr, COPYMESSAGEFLAGS dwOptions, 
    LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_COPYMOVE_MESSAGE, pCallback, pList, pFlags, NULL, &pArg);
    if (!FAILED(hr))
    {
        if (pArg->pDestFldr = pDestFldr)
            pDestFldr->AddRef();

        pArg->dwCopyOptions = dwOptions;
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, 
    IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;

    Assert(NULL == pList || pList->cMsgs > 0);

    hr = _AddToQueue(SOT_DELETING_MESSAGES, pCallback, pList, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->dwDeleteOptions = dwOptions;
        return E_PENDING;
    }
    return TraceResult(hr);
}

HRESULT CServerQ::SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags,
    IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg=0;
    HRESULT         hr;

    Assert(NULL == pList || pList->cMsgs > 0);

    hr = _AddToQueue(SOT_SET_MESSAGEFLAGS, pCallback, pList, pFlags, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->dwSetFlags = dwFlags;
        return E_PENDING;
    }
    return TraceResult(hr);
}

HRESULT CServerQ::SynchronizeStore(FOLDERID idParent, DWORD dwFlags, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_SYNCING_STORE, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idParent = idParent;
        pArg->dwFlags = dwFlags;
        return E_PENDING;
    }
    return TraceResult(hr);
}

HRESULT CServerQ::CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg=0;
    HRESULT         hr;

    hr = _AddToQueue(SOT_CREATE_FOLDER, pCallback, NULL, NULL, pszName, &pArg);
    if (!FAILED(hr))
    {
        pArg->idParent = idParent;
        pArg->tySpecial = tySpecial;
        pArg->dwFldrFlags = dwFlags;
        return E_PENDING;
    }
    return TraceResult(hr);
}

HRESULT CServerQ::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_MOVE_FOLDER, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        pArg->idParentNew = idParentNew;
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg=0;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_RENAME_FOLDER, pCallback, NULL, NULL, pszName, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        return E_PENDING;
    }
    
    return TraceResult(hr);
}

HRESULT CServerQ::DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;

    hr = _AddToQueue(SOT_DELETE_FOLDER, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        pArg->dwDelFldrFlags = dwFlags;
        return E_PENDING;
    }

    return TraceResult(hr);
}


HRESULT CServerQ::SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_SUBSCRIBE_FOLDER, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        pArg->fSubscribe = fSubscribe;
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    hr = _AddToQueue(SOT_UPDATE_FOLDER, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr;
            
    Assert(pSysTime != NULL);

    hr = _AddToQueue(SOT_GET_NEW_GROUPS, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->sysTime = *pSysTime;
        return E_PENDING;
    }

    return TraceResult(hr);
}

HRESULT CServerQ::GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback)
{
    ARGUMENT_DATA  *pArg;
    HRESULT         hr;

    hr = _AddToQueue(SOT_GET_WATCH_INFO, pCallback, NULL, NULL, NULL, &pArg);
    if (!FAILED(hr))
    {
        pArg->idFolder = idFolder;
        return (E_PENDING);
    }

    return TraceResult(hr);
}

HRESULT CServerQ::Close(DWORD dwFlags)
{
    HRESULT     hr=S_OK;

    if (m_cRefConnection != 0 && dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        // some-body else has a connection ref on the server object.
        // let's ignore the hands-off close
        return STORE_S_IN_USE;
    }

    if (m_pServer)
        hr = m_pServer->Close(dwFlags);

    // make sure we flush any pending ops
    _Flush(FALSE);
    return hr;
}

HRESULT CServerQ::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    TraceInfoTag(TAG_SERVERQ, _MSG("CServerQ::OnBegin[sot='%s', pTask->sot='%s']", sotToSz(tyOperation), sotToSz(m_pCurrentTask->sot)));


    IxpAssert (m_pCurrentTask);

    if (m_pCurrentTask &&
        m_pCurrentTask->sot == SOT_GET_MESSAGE)
    {
        // multiplex
        for (ULONG ul=0; ul < m_pCurrentTask->cOtherCallbacks; ul++)
            m_pCurrentTask->rgpOtherCallback[ul]->OnBegin(tyOperation, pOpInfo, pCancel);
    }

    return m_pCurrentCallback ? m_pCurrentCallback->OnBegin(tyOperation, pOpInfo, pCancel) : S_OK;
}

HRESULT CServerQ::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    IxpAssert (m_pCurrentTask);

    if (m_pCurrentTask && 
        m_pCurrentTask->sot == SOT_GET_MESSAGE)
    {
        // multiplex
        for (ULONG ul=0; ul < m_pCurrentTask->cOtherCallbacks; ul++)
            m_pCurrentTask->rgpOtherCallback[ul]->OnProgress(tyOperation, dwCurrent, dwMax, pszStatus);
    }

    return m_pCurrentCallback ? m_pCurrentCallback->OnProgress(tyOperation, dwCurrent, dwMax, pszStatus) : S_OK;
}

HRESULT CServerQ::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    return m_pCurrentCallback ? m_pCurrentCallback->OnTimeout(pServer, pdwTimeout, ixpServerType) : S_OK;
}

HRESULT CServerQ::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return m_pCurrentCallback ? m_pCurrentCallback->CanConnect(pszAccountId, dwFlags) : S_OK;
}

HRESULT CServerQ::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    return m_pCurrentCallback ? m_pCurrentCallback->OnLogonPrompt(pServer, ixpServerType) : S_OK;
}

HRESULT CServerQ::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT     hr;

    TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::OnComplete[sot='%s', pTask->sot='%s']", sotToSz(tyOperation), sotToSz(m_pCurrentTask ? m_pCurrentTask->sot : SOT_INVALID)));

    IxpAssert (m_pCurrentTask);

    // multiplex
    if (m_pCurrentTask && 
        m_pCurrentTask->sot == SOT_GET_MESSAGE)
    {
        for (ULONG ul=0; ul < m_pCurrentTask->cOtherCallbacks; ul++)
            m_pCurrentTask->rgpOtherCallback[ul]->OnComplete(tyOperation, hrComplete, pOpInfo, pErrorInfo);
    }

    if ((hrComplete == HR_E_OFFLINE) || (hrComplete == HR_E_USER_CANCEL_CONNECT))
    {
        switch (m_pCurrentTask->sot)
        {
            case SOT_CREATE_FOLDER:
                hrComplete = HR_E_OFFLINE_FOLDER_CREATE;
                break;

            case SOT_MOVE_FOLDER:
                hrComplete = HR_E_OFFLINE_FOLDER_MOVE;
                break;

            case SOT_DELETE_FOLDER:
                hrComplete = HR_E_OFFLINE_FOLDER_DELETE;
                break;

            case SOT_RENAME_FOLDER:
                hrComplete = HR_E_OFFLINE_FOLDER_RENAME;
                break;
        }
    }

    hr = m_pCurrentCallback ? m_pCurrentCallback->OnComplete(tyOperation, hrComplete, pOpInfo, pErrorInfo) : S_OK;

    // if the operation failed due to a connection error (or user-cancel) then flush the queue
    // if the sync-folder operation failed, then ALWAYS flush the queue
    if (FAILED(hrComplete) &&  
        ((hrComplete == STORE_E_OPERATION_CANCELED) ||
        (pErrorInfo &&
        pErrorInfo->dwFlags & SE_FLAG_FLUSHALL)))
    {
        _Flush(FALSE);
    }

    if (m_pCurrentTask && m_pCurrentTask->sot == tyOperation)
        _StartNextTask();   // operation complete, start the next task

    return hr;
}


STDMETHODIMP CServerQ::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    return m_pServer->GetServerMessageFlags(pFlags);
}


HRESULT CServerQ::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    return m_pCurrentCallback ? m_pCurrentCallback->OnPrompt(hrError, pszText, pszCaption, uType, piUserResponse) : E_NOTIMPL;
}

HRESULT CServerQ::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    return m_pCurrentCallback ? m_pCurrentCallback->GetParentWindow(dwReserved, phwndParent) : E_NOTIMPL;
}


LRESULT CServerQ::ExtWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CServerQ    *pServer = (CServerQ *)GetWndThisPtr(hwnd);

    switch (uMsg)
    {
        case WM_CREATE:
            SetWndThisPtrOnCreate(hwnd, lParam);
            break;
        
#ifdef DEBUG
        case WM_TIMER:
            if (pServer->m_DBG_pArgDataLast && 
                pServer->m_DBG_pArgDataLast == pServer->m_pCurrentTask)
            {
                // if current-task is the same every 10 seconds, the print a warning message
                TraceInfo("WARNING: serverq processing same task for > 10 seconds");
                pServer->_DBG_DumpQueue();
                // beeping here is very hostile to httpmail. httpmail needs
                // lots and lots of time to download mail headers. this gives
                // our uses an opportunity to meditate on the many wonders of our new
                // protocol.
                //MessageBeep((UINT)-1);
            }
            else
                pServer->m_DBG_pArgDataLast = pServer->m_pCurrentTask;

            break;
#endif
        case SQW_NEXTTASK:
            pServer->_OnNextTask();
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


/*
 *  Function : _AddToQueue
 *
 *  Purpose :  Adds an element to the tail of the queue and returns the allocated blob
 *  
 *  The only arguments on IMessageServer that need allocation to duplicate are 
 *  message list and adjust flags. I roll these arguments into one function AddToQueue
 *  so that there is less code-gen for the error condition case, and if AddToQueue succeeds
 *  there should be no futher failing operations - so noone calling this should need to 
 *  clean up the argdata and/or de-queue the failed addition
 *
 */

HRESULT CServerQ::_AddToQueue(  STOREOPERATIONTYPE  sot, 
                                IStoreCallback     *pCallback, 
                                LPMESSAGEIDLIST     pList, 
                                LPADJUSTFLAGS       pFlags, 
                                LPCSTR              pszName, 
                                ARGUMENT_DATA      **ppNewArgData)
{
    HRESULT         hr;
    ARGUMENT_DATA   *pArgData=0;

    TraceCall("CServerQ::_AddToQueue");
    TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::_AddToQueue (sot='%s')", sotToSz(sot)));

    Assert (ppNewArgData);

    if (!MemAlloc((LPVOID *)&pArgData, sizeof(ARGUMENT_DATA)))
    {
        return TraceResult(E_OUTOFMEMORY);
    }

    ZeroMemory((LPVOID *)pArgData, sizeof(ARGUMENT_DATA));
    
    if (pList)
    {
        hr = CloneMessageIDList(pList, &pArgData->pList);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto error;
        }
    }

    if (pFlags)
    {
        hr = CloneAdjustFlags(pFlags, &pArgData->pFlags);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto error;
        }
    }

    if (pszName)
    {
        pArgData->pszName = PszDupA(pszName);
        if (!pArgData->pszName)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
    }

    if (pArgData->pCallback = pCallback)
        pCallback->AddRef();

    pArgData->sot = sot;

    if (m_pLastQueueTask)
        m_pLastQueueTask->pNext = pArgData;

    m_pLastQueueTask = pArgData;
        
    if (!m_pTaskQueue)
    {
        m_pTaskQueue = pArgData;

        // if there are no pending tasks, then start the next task
        if (!m_pCurrentTask)
            _StartNextTask();

    }
    *ppNewArgData = pArgData;

    return S_OK;

error:
    _FreeArgumentData(pArgData);
    return hr;
}



HRESULT CServerQ::_OnNextTask()
{
    HRESULT     hr;
    
    TraceCall("CServerQ::_OnNextTask");

    AssertSz(m_pCurrentTask, "How did we get here without a pending task?");

    TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::_OnNextTask [ sot ='%s']", sotToSz(m_pCurrentTask->sot)));

    switch (m_pCurrentTask->sot)
    {
        case SOT_SYNC_FOLDER:
            hr = m_pServer->SynchronizeFolder(m_pCurrentTask->dwSyncFlags,
                m_pCurrentTask->cHeaders, (IStoreCallback *)this);
            break;

        case SOT_GET_MESSAGE:
            // TODO: add getmsg chaining here
            hr = m_pServer->GetMessage(m_pCurrentTask->idMessage, (IStoreCallback *)this);
            break;

        case SOT_PUT_MESSAGE:
            hr = m_pServer->PutMessage(m_pCurrentTask->idFolder,
                m_pCurrentTask->dwMsgFlags,
                m_pCurrentTask->pftReceived,
                m_pCurrentTask->pPutStream, (IStoreCallback *)this);
            break;

        case SOT_COPYMOVE_MESSAGE:
            hr = m_pServer->CopyMessages(m_pCurrentTask->pDestFldr,
                m_pCurrentTask->dwCopyOptions,
                m_pCurrentTask->pList, m_pCurrentTask->pFlags, (IStoreCallback *)this);
            break;
    
        case SOT_DELETING_MESSAGES:
            hr = m_pServer->DeleteMessages(m_pCurrentTask->dwDeleteOptions,
                m_pCurrentTask->pList, (IStoreCallback *)this);
            break;

        case SOT_SET_MESSAGEFLAGS:
            hr = m_pServer->SetMessageFlags(m_pCurrentTask->pList, m_pCurrentTask->pFlags, 
                m_pCurrentTask->dwSetFlags, (IStoreCallback *)this);
            break;
        
        case SOT_SYNCING_STORE:
            hr = m_pServer->SynchronizeStore(m_pCurrentTask->idParent,
                m_pCurrentTask->dwFlags, (IStoreCallback *)this);
            break;

        case SOT_CREATE_FOLDER:
            hr = m_pServer->CreateFolder(m_pCurrentTask->idParent,
                m_pCurrentTask->tySpecial,
                m_pCurrentTask->pszName, m_pCurrentTask->dwFldrFlags,
                (IStoreCallback *)this);
            break;

        case SOT_MOVE_FOLDER:
            hr = m_pServer->MoveFolder(m_pCurrentTask->idFolder,
                m_pCurrentTask->idParentNew, (IStoreCallback *)this);
            break;

        case SOT_RENAME_FOLDER:
            hr = m_pServer->RenameFolder(m_pCurrentTask->idFolder,
                m_pCurrentTask->pszName, (IStoreCallback *)this);
            break;

        case SOT_DELETE_FOLDER:
            hr = m_pServer->DeleteFolder(m_pCurrentTask->idFolder,
                m_pCurrentTask->dwDelFldrFlags, (IStoreCallback *)this);
            break;

        case SOT_SUBSCRIBE_FOLDER:
            hr = m_pServer->SubscribeToFolder(m_pCurrentTask->idFolder,
                m_pCurrentTask->fSubscribe, (IStoreCallback *)this);
            break;

        case SOT_UPDATE_FOLDER:
            hr = m_pServer->GetFolderCounts(m_pCurrentTask->idFolder,
                (IStoreCallback *)this);
            break;

        case SOT_GET_NEW_GROUPS:
            hr = m_pServer->GetNewGroups(&m_pCurrentTask->sysTime,
                (IStoreCallback *)this);
            break;

        case SOT_GET_WATCH_INFO:
            hr = m_pServer->GetWatchedInfo(m_pCurrentTask->idFolder,
                (IStoreCallback *)this);
            break;

        case SOT_GET_ADURL:
            hr = m_pServer->GetAdBarUrl((IStoreCallback *)this);
            break;
    
        case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            hr = m_pServer->GetMinPollingInterval((IStoreCallback*)this);
            break;

        default:
            AssertSz(0, "Bad ArgData type");
    }

    if (hr != E_PENDING)
    {
        // if the operation did not return E_PENDING, then it is not completing ASYNC
        // if this is true, then we need to take care of the callback reporting here are
        // we have already returned E_PENDING when we put this dude in the queue
        STOREERROR rError;
        STOREERROR *pError=0;
        
        TCHAR      szBuf[CCHMAX_STRINGRES];

        TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::Operation failed to go ASYNC - propagating error. sot='%s', hr=0x%x", sotToSz(m_pCurrentTask->sot), hr));

        if (hr != S_OK)
        {
            ZeroMemory((LPVOID)&rError, sizeof(STOREERROR));
            rError.hrResult = hr;
            LoadString(g_hLocRes, idsGenericError, szBuf, ARRAYSIZE(szBuf));
            rError.pszDetails = szBuf;
            pError = &rError;
        }
        
        // $TODO: need to add richer error reporting here.
        if (m_pCurrentCallback)
        {
            m_pCurrentCallback->OnBegin(m_pCurrentTask->sot, NULL, NULL);
            m_pCurrentCallback->OnComplete(m_pCurrentTask->sot, hr, NULL, pError);
        }
        
        if (m_pCurrentTask)
            _StartNextTask();   // operation complete, start the next task
    }
    return S_OK;
}


HRESULT CServerQ::_FreeArgumentData(ARGUMENT_DATA *pArgData)
{
    ULONG   ul;

    if (!pArgData)
        return S_OK;

    switch (pArgData->sot)
    {
        case SOT_SYNC_FOLDER:
            break;

        case SOT_GET_MESSAGE:
            for (ul = 0; ul < pArgData->cOtherCallbacks; ul++)
                ReleaseObj(pArgData->rgpOtherCallback[ul]);

            SafeMemFree(pArgData->rgpOtherCallback);
            pArgData->cOtherCallbacks = 0;
            break;

        case SOT_PUT_MESSAGE:
            ReleaseObj(pArgData->pPutStream);
            break;

        case SOT_COPYMOVE_MESSAGE:
            ReleaseObj(pArgData->pDestFldr);
            SafeMemFree(pArgData->pList);
            SafeMemFree(pArgData->pFlags);
            break;
    
        case SOT_DELETING_MESSAGES:
            SafeMemFree(pArgData->pList);
            break;

        case SOT_SET_MESSAGEFLAGS:
            SafeMemFree(pArgData->pList);
            SafeMemFree(pArgData->pFlags);
            break;
        
        case SOT_SYNCING_STORE:
            break;

        case SOT_CREATE_FOLDER:
            if (pArgData->pszName)
                MemFree((LPSTR)pArgData->pszName);
            break;

        case SOT_MOVE_FOLDER:
            break;

        case SOT_RENAME_FOLDER:
            if (pArgData->pszName)
                MemFree((LPSTR)pArgData->pszName);
            break;

        case SOT_DELETE_FOLDER:
            break;

        case SOT_SUBSCRIBE_FOLDER:
            break;

        case SOT_UPDATE_FOLDER:
            break;

        case SOT_GET_NEW_GROUPS:
            break;

        case SOT_GET_WATCH_INFO:
            break;

        case SOT_GET_ADURL:
        case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            break;

        default:
            AssertSz(0, "Bad ArgData type");
    }

    ReleaseObj(pArgData->pCallback);
    MemFree(pArgData);
    return S_OK;
}





HRESULT CreateServerQueue(IMessageServer *pServerInner, IMessageServer **ppServer)
{
    CServerQ    *pQueue=0;
    HRESULT     hr;

    pQueue = new CServerQ();
    if (!pQueue)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hr = pQueue->Init(pServerInner);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    *ppServer = (IMessageServer *)pQueue;
    pQueue=0;

exit:
    ReleaseObj(pQueue);
    return hr;
}


HRESULT CServerQ::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (SID_MessageServer == guidService)
    {
        HRESULT hrResult;

        // CServerQ is a IMessageServer, too! Try to satisfy the incoming request ourselves
        hrResult = QueryInterface(riid, ppvObject);
        if (SUCCEEDED(hrResult))
            return hrResult;

        // Oh well, we can't provide this interface. Ask our server object.
        if (m_pServer != NULL)
            return m_pServer->QueryInterface(riid, ppvObject);
    }

    return E_NOINTERFACE;
}

HRESULT CServerQ::_StartNextTask()
{
    HRESULT     hr;
    
    TraceCall("CServerQ::_StartNextTask");

    // clear the current task and dequeue the next one
    // we post a message to ourselves to start the operation
    // so that our stack is clean.

    _FreeArgumentData(m_pCurrentTask);
    m_pCurrentTask = NULL;
    m_pCurrentCallback = NULL;

    if (!m_pTaskQueue)    // no more tasks
    {
        TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::_StartNextTask - no tasks left"));
        m_pLastQueueTask = NULL;
        return S_OK;
    }

    m_pCurrentTask = m_pTaskQueue;
    m_pTaskQueue = m_pTaskQueue->pNext;
    m_pCurrentCallback = m_pCurrentTask->pCallback;
    PostMessage(m_hwnd, SQW_NEXTTASK, 0, 0);
    return S_OK;
}


HRESULT CServerQ::_Flush(BOOL fFlushCurrent)
{
    ARGUMENT_DATA       *pArgData,
                        *pArgDataFree;
    STOREERROR          rError;
    STOREOPERATIONINFO  soi;
    STOREOPERATIONINFO  *psoi=NULL;

    TraceCall("CServerQ::_Flush");

    ZeroMemory((LPVOID)&rError, sizeof(STOREERROR));
    rError.hrResult = STORE_E_OPERATION_CANCELED;

    // cancel the current operation, if so requested
    if (fFlushCurrent && 
       m_pCurrentCallback && 
       m_pCurrentTask)
    {
        m_pCurrentCallback->OnComplete(m_pCurrentTask->sot, STORE_E_OPERATION_CANCELED, NULL, &rError);
        _FreeArgumentData(m_pCurrentTask);
        m_pCurrentTask = NULL;
        m_pCurrentCallback = NULL;
    }

    m_pLastQueueTask = NULL;
    // flush any queued ops
    pArgData = m_pTaskQueue;
    while (pArgData)
    {
        TraceInfoTag(TAG_SERVERQ,_MSG("CServerQ::Flushing Task: '%s'", sotToSz(pArgData->sot)));

        // send an OnComplete to all of the callbacks in the queue to cancel the operation
        if (pArgData->sot == SOT_GET_MESSAGE)
        {
            // if a GetMessage, besure to pass back the message-id on the flush so that
            // the view knows which message is getting flushed
            soi.cbSize = sizeof(STOREOPERATIONINFO);
            soi.idMessage = pArgData->idMessage;
            psoi = &soi;

            for (ULONG ul=0; ul < pArgData->cOtherCallbacks; ul++)
            {
                Assert (pArgData->rgpOtherCallback[ul]);

                pArgData->rgpOtherCallback[ul]->OnBegin(pArgData->sot, psoi, NULL);
                pArgData->rgpOtherCallback[ul]->OnComplete(pArgData->sot, STORE_E_OPERATION_CANCELED, NULL, &rError);
            }
        }

        if (pArgData->pCallback)
        {
            pArgData->pCallback->OnBegin(pArgData->sot, psoi, NULL);
            pArgData->pCallback->OnComplete(pArgData->sot, STORE_E_OPERATION_CANCELED, NULL, &rError);
        }

        pArgDataFree = pArgData;
        pArgData = pArgData->pNext;
        _FreeArgumentData(pArgDataFree);
    }
    m_pTaskQueue = NULL;
    return S_OK;
}


 
HRESULT CServerQ::ConnectionAddRef()
{
    m_cRefConnection++;
    return S_OK;
}

HRESULT CServerQ::ConnectionRelease()
{
    if (m_cRefConnection == 0)
        return E_UNEXPECTED;

    m_cRefConnection--;
    return S_OK;
}



#ifdef DEBUG
HRESULT CServerQ::_DBG_DumpQueue()
{
    ARGUMENT_DATA   *pTask;

    TraceInfo("ServerQ pending tasks:");
    pTask = m_pCurrentTask;
    while (pTask)
    {
        TraceInfo(_MSG("\tsot=%s", sotToSz(pTask->sot)));
        pTask = pTask->pNext;
    }
    return S_OK;
}
#endif

HRESULT CServerQ::GetAdBarUrl(IStoreCallback   *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr = S_OK;
            
    IF_FAILEXIT(hr = _AddToQueue(SOT_GET_ADURL, pCallback, NULL, NULL, NULL, &pArg));
    
exit:
    return hr;    
}

HRESULT CServerQ::GetMinPollingInterval(IStoreCallback   *pCallback)
{
    ARGUMENT_DATA   *pArg;
    HRESULT         hr = S_OK;
            
    IF_FAILEXIT(hr = _AddToQueue(SOT_GET_HTTP_MINPOLLINGINTERVAL, pCallback, NULL, NULL, NULL, &pArg));
    
exit:
    return hr;    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\sigs.h ===
#ifndef _INC_SIGS_H
#define _INC_SIGS_H

#include <imnact.h>

#define SIG_ID                  1
#define SIG_NAME                2
#define SIG_FILE                3
#define SIG_TEXT                4
#define SIG_TYPE                5

#define MAXSIGTEXT              1024
#define MAXSIGNAME              32
#define MAXSIGID                CCHMAX_SIGNATURE

typedef struct tagSIGBUCKET
    {
    char szID[MAXSIGID];
    IOptionBucket *pBckt;
    } SIGBUCKET;

class CSignatureManager
    {
    public:
        // ----------------------------------------------------------------------------
        // Construction
        // ----------------------------------------------------------------------------
        CSignatureManager(HKEY hkey, LPCSTR pszRegKeyRoot);
        ~CSignatureManager(void);

        ULONG AddRef(void);
        ULONG Release(void);

        // -------------------------------------------------------------------
        // CSignatureManager Members
        // -------------------------------------------------------------------
        HRESULT GetSignature(LPCSTR szID, IOptionBucket **ppBckt);
        HRESULT GetSignatureCount(int *pcSig);
        HRESULT EnumSignatures(int index, IOptionBucket **ppBckt);
        
        HRESULT CreateSignature(IOptionBucket **ppBckt);
        HRESULT DeleteSignature(LPCSTR szID);
        
        HRESULT GetDefaultSignature(LPSTR szID);
        HRESULT SetDefaultSignature(LPCSTR szID);

    private:
        LONG                m_cRef;
        BOOL                m_fInit;

        HKEY                m_hkey;
        char                m_szRegRoot[MAX_PATH];

        char                m_szDefSigID[MAXSIGID];
        SIGBUCKET           *m_pBckt;
        int                 m_cBckt;
        int                 m_cBcktBuf;

        HRESULT Initialize(void);
        HRESULT GetBucket(SIGBUCKET *pSigBckt);
    };

extern CSignatureManager *g_pSigMgr;

HRESULT InitSignatureManager(HKEY hkey, LPCSTR szRegRoot);
HRESULT DeinitSignatureManager(void);

INT_PTR CALLBACK SigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT FillSignatureMenu(HMENU hmenu, LPCSTR szAcct);
HRESULT GetSigFromCmd(int id, char *szID);
HRESULT InitSigPopupMenu(HMENU hmenu, LPCSTR szAcct);
void DeinitSigPopupMenu(HWND hwnd);

#endif // _INC_SIGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\secutil.h ===
/*
**	s e c u t i l . h
**	
**	Purpose: helper functions for message security
**
**  Owner:   t-erikne
**  Created: 1/10/97
**	
**	Copyright (C) Microsoft Corp. 1997.
*/

#ifndef __SECUTIL_H
#define __SECUTIL_H

/////////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include <mimeole.h>
#include <wab.h>
class CWabal;
class CSecMsgService;
interface IBodyObj;
interface IBodyObj2;
typedef CWabal *LPWABAL;
typedef struct tagADRINFO ADRINFO;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
interface IImnAccount;
interface IHeaderSite;

/////////////////////////////////////////////////////////////////////////////
//
// Structures
//

/*  SECSTATE structure
**
**  type    - security type
**  user_validity - user set validity bits
**  ro_msg_validity - mimeole set validity/trust bits
**  fHaveCert - TRUE if there is a cert in the message
**  szSignerEmail - points to email address of signer
**  szSenderEmail - points to email address of sender
*/
struct SECSTATEtag
{
    ULONG   type;
    ULONG   user_validity;
    ULONG   ro_msg_validity;
    BOOL    fHaveCert;
    LPTSTR  szSignerEmail;
    LPTSTR  szSenderEmail;
};
typedef struct SECSTATEtag SECSTATE;

// Structure for send resource ID to 
// signing certificate error dialog 
typedef struct tagErrIds
{
    UINT    idsText1;
    UINT    idsText2;
} ERRIDS;

typedef struct tagCertErrParam
{
    BOOL    fForceEncryption;
    IMimeAddressTable *pAdrTable;
} CERTERRPARAM;


/*  ALG_LIST/ALG_NODE struct
**
**  aid     - CAPI algorithm id
**  dwBits  - number of bits in the algorithm
**  szName  - text name of algorithm
*/
struct ALG_LISTtag;
typedef struct ALG_LISTtag {
    ALG_ID  aid;
    DWORD   dwBits;
    char    szName[20];
    ALG_LISTtag *next;
    } ALG_LIST, ALG_NODE;


extern CRYPT_ENCODE_PARA       CryptEncodeAlloc;
extern CRYPT_DECODE_PARA       CryptDecodeAlloc;

/////////////////////////////////////////////////////////////////////////////
//
// Definitions
//

// in use                           0x xxx  xx
#define ATHSEC_TRUSTED              0x00000000
#define ATHSEC_NOTRUSTNOTTRUSTED    0X00000001
#define ATHSEC_NOTRUSTUNKNOWN       0X00000002
#define ATHSEC_TRUSTSTATEMASK       0x000000ff
// these are ordered as the idsWrnSecurityTrust* in resource.h
// change these, change them
#define ATHSEC_NOTRUSTWRONGADDR     0X00010000
#define ATHSEC_NOTRUSTREVOKED       0x00020000
#define ATHSEC_NOTRUSTOTHER         0X00040000
#define ATHSEC_NOTRUSTREVFAIL       0x00080000
#define ATHSEC_NUMVALIDITYBITS      3           // update this if you add one
#define ATHSEC_TRUSTREASONMASK      0x0fff0000

// Flags for HrAddCertToWabContact & HrAddCertToWab
#define WFF_SHOWUI                  0x00000001      // we are allowed to show UI
#define WFF_CREATE                  0x00000010      // we are allowed to create an entry if not found


/////////////////////////////////////////////////////////////////////////////
//
// Constants
//

extern const BYTE c_RC2_40_ALGORITHM_ID[];
extern const ULONG cbRC2_40_ALGORITHM_ID;

/////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//

BOOL IsSecure(DWORD dwMST);
BOOL IsSecure(LPMIMEMESSAGE pMsg, const HBODY hBodyToCheck = HBODY_ROOT);
BOOL IsSigned(LPMIMEMESSAGE pMsg, BOOL fIncludeDescendents);
BOOL IsSigned(LPMIMEMESSAGE pMsg, const HBODY hBodyToCheck, BOOL fIncludeDescendents);
BOOL IsSigned(DWORD dwMST);
BOOL IsSignTrusted(SECSTATE *pSecState);
BOOL IsEncrypted(LPMIMEMESSAGE pMsg, BOOL fIncludeDescendents);
BOOL IsEncrypted(LPMIMEMESSAGE pMsg, const HBODY hBodyToCheck, BOOL fIncludeDescendents);
BOOL IsEncrypted(DWORD dwMST);
BOOL IsEncryptionOK(SECSTATE *pSecState);

HRESULT CommonUI_ViewSigningProperties(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg, UINT nStartPage);
HRESULT CommonUI_ViewSigningCertificate(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);
HRESULT CommonUI_ViewSigningCertificateTrust(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);

HRESULT HrHaveAnyMyCerts(void);

HRESULT HrGetThumbprint(LPWABAL lpWabal, ADRINFO *pAdrInfo, THUMBBLOB *pThumbprint, BLOB * pSymCaps, FILETIME * pSigningTime);

DWORD   DwGetSecurityOfMessage(LPMIMEMESSAGE pMsg, const HBODY hBodyToCheck = HBODY_ROOT);
HRESULT HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType);

#ifdef SMIME_V3
BOOL FNameInList(LPSTR szAddr, DWORD cReceiptFromList, CERT_NAME_BLOB *rgReceiptFromList);
HRESULT SendSecureMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail, IHeaderSite *pHeaderSite);
#else
HRESULT SendSecureMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail);
#endif // SMIME_V3

DWORD   DwGenerateTrustedChain(HWND hwnd, IMimeMessage *pMsg, PCCERT_CONTEXT pcCertToTest, DWORD dwIgnore, BOOL fFullSearch, DWORD *pcChain, PCCERT_CONTEXT **prgChain);

HRESULT HrGetSecurityState(LPMIMEMESSAGE, SECSTATE *, HBODY *phBody);
VOID CleanupSECSTATE(SECSTATE *psecstate);
HRESULT HandleSecurity(HWND hwndOwner, LPMIMEMESSAGE);

HRESULT LoadResourceToHTMLStream(LPCTSTR szResName, IStream **ppstm);

HRESULT HrGetMyCerts(PCCERT_CONTEXT ** pprgcc, ULONG * pccc);
void FreeCertArray(PCCERT_CONTEXT * rgcc, ULONG ccc);
HRESULT GetSigningCert(IMimeMessage * pMsg, PCCERT_CONTEXT * ppcSigningCert, THUMBBLOB * ptbSigner, BLOB * pblSymCaps, FILETIME * pftSigningTime);
HRESULT GetSignerEncryptionCert(IMimeMessage * pMsg, PCCERT_CONTEXT * ppcEncryptCert,
                                THUMBBLOB * ptbEncrypt, BLOB * pblSymCaps,
                                FILETIME * pftSigningTime);
HRESULT HrSaveCACerts(HCERTSTORE hcCA, HCERTSTORE hcMsg);

BOOL IsThumbprintInMVPBin(SPropValue spv, THUMBBLOB * lpThumbprint, ULONG * lpIndex, BLOB * pblSymCaps,
  FILETIME * lpftSigningTime, BOOL * lpfDefault);
HRESULT HrAddSenderCertToWab(HWND hwnd, LPMIMEMESSAGE pMsg, LPWABAL lpWabal, THUMBBLOB *pSenderThumbprint,
  BLOB *pblSymCaps, FILETIME ftSigningTime, DWORD dwFlags);
HRESULT HrAddCertToWab(HWND hwnd, LPWABAL lpWabal, THUMBBLOB *pThumbprint,
  PCCERT_CONTEXT pcCertContext, LPWSTR lpwszEmailAddress, LPWSTR lpwszDisplayName, BLOB *pblSymCaps,
  FILETIME ftSigningTime, DWORD dwFlags);
ULONG GetHighestEncryptionStrength(void);
HRESULT HrGetHighestSymcaps(LPBYTE * ppbSymcap, LPULONG cbSymcap);

HRESULT ShowSecurityPopup(HWND hwnd, DWORD cmdID, POINT *pPoint, IMimeMessage *pMsg);
void ShowDigitalIDs(HWND hWnd);
BOOL CheckCDPinCert(LPMIMEMESSAGE pMsg);
BOOL CheckCDPinCert(PCCERT_CONTEXT pcCertToTest);

HRESULT HrGetLabelString(LPMIMEMESSAGE pMsg, LPWSTR *pwStr);
HRESULT CheckSecReceipt(LPMIMEMESSAGE pMsg);
HRESULT HrShowSecurityProperty(HWND hwnd, LPMIMEMESSAGE pMsg);
HRESULT HandleSecReceipt(LPMIMEMESSAGE pMsg, IImnAccount * pAcct, HWND hWnd, TCHAR **ppszSubject, TCHAR **ppszFrom, FILETIME *pftSentTime, FILETIME *pftSigningTime);
void CreateContentIdentifier(TCHAR *pchContentID, LPMIMEMESSAGE pMsg);
HRESULT _HrFindMyCertForAccount(HWND hwnd, PCCERT_CONTEXT * ppcCertContext, IImnAccount * pAccount, BOOL fEncrypt);
HRESULT CheckDecodedForReceipt(LPMIMEMESSAGE pMsg, PSMIME_RECEIPT * ppSecReceipt);
HRESULT HrGetInnerLayer(LPMIMEMESSAGE pMsg, HBODY *phBody);

/////////////////////////////////////////////////////////////////////////////
//
// Predicate wrappers
//

inline BOOL IsSecure(DWORD dwMst)
    { return (MST_NONE != dwMst); }

inline BOOL IsSecure(LPMIMEMESSAGE pMsg, const HBODY hBodyToCheck)
    { return (MST_NONE != DwGetSecurityOfMessage(pMsg, hBodyToCheck)); }

inline BOOL IsSigned(LPMIMEMESSAGE pMsg, BOOL fIncludeDescendents)
    { return IsSigned(pMsg, HBODY_ROOT, fIncludeDescendents); }

inline BOOL IsSigned(DWORD dwMST)
    { return (BOOL)(dwMST & MST_SIGN_MASK); }

inline BOOL IsSignTrusted(SECSTATE *pSecState)
    { return (BOOL)((ATHSEC_TRUSTED == pSecState->user_validity) &&
            (MSV_OK == (pSecState->ro_msg_validity & ~MSV_ENCRYPT_MASK))); }

inline BOOL IsEncrypted(LPMIMEMESSAGE pMsg, BOOL fIncludeDescendents)
    { return IsEncrypted(pMsg, HBODY_ROOT, fIncludeDescendents); }

inline BOOL IsEncrypted(DWORD dwMST)
    { return (BOOL)(dwMST & MST_ENCRYPT_MASK); }

inline BOOL IsEncryptionOK(SECSTATE *pSecState)
    { return (BOOL) (MSV_OK == ((MSV_MSG_MASK|MSV_ENCRYPT_MASK) & pSecState->ro_msg_validity));}

/////////////////////////////////////////////////////////////////////////////
//
// Other wrappers
//

inline HRESULT CommonUI_ViewSigningCertificate(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
    { return CommonUI_ViewSigningProperties(hwnd, pCert, hcMsg, 0); }

inline HRESULT CommonUI_ViewSigningCertificateTrust(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
    { return CommonUI_ViewSigningProperties(hwnd, pCert, hcMsg, 2); }

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\secutil.cpp ===
/*
**  s e c u t i l . c p p
**
**  Purpose:
**      Implementation of a class to wrap around CAPI functionality
**
**  History
**      1/12/97: (t-erikne) Recreated after VC ate the file. yum.
**      1/10/97: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1997.
*/

/////////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include "ipab.h"
#include "secutil.h"
#include <certs.h>
#include <imsgcont.h>
#include "sechtml.h"
#include <ibodyobj.h>
#include <wincrypt.h>
#include <cryptdlg.h>
#include <capi.h>
#include "demand.h"
#include "storecb.h"
#include "shlwapip.h"
#include "mailutil.h"
#include "menuutil.h"
#include "menures.h"
#include "mimeolep.h"
#include "msgprop.h"
#include "shared.h"
#include "htmlhelp.h"
#include "seclabel.h"
#include "iheader.h"
#include "browser.h"
#include "taskutil.h"

#define szOID_MSFT_Defaults     "1.3.6.1.4.1.311.16.3"

#define sz_OEMS_ContIDPrefix     "797374"

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

#define S_DUPLICATE_FOUND   MAKE_MAPI_S(0x700)

extern INT_PTR CALLBACK CertErrorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK CertWarnDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

HRESULT HrBuildAndVerifyCerts(IMimeMessageTree * pTree, DWORD * pcCert, PCX509CERT ** prgpccert,
                      PCCERT_CONTEXT pccertSender, IImnAccount *pAccount);

/////////////////////////////////////////////////////////////////////////////
//
// Private structures, macros
//

static const TCHAR s_szHTMLMIME[] =
    "Content-Type: text/html\r\n\r\n";

// Public constants
const BYTE c_RC2_40_ALGORITHM_ID[] =
      {0x30, 0x0F, 0x30, 0x0D, 0x06, 0x08, 0x2A, 0x86,
       0x48, 0x86, 0xF7, 0x0D, 0x03, 0x02, 0x02, 0x01,
       0x28};
const ULONG cbRC2_40_ALGORITHM_ID = 0x11;     // Must be 11 hex to match size!

#define CONTENTID_SIZE      50

/////////////////  CAPI Enhancement code

#ifdef SMIME_V3
#define ASN1_ERR_FIRST  0x80093001L
#define ASN1_ERR_LAST   0x800931FFL
#endif // SMIME_V3

typedef struct tagFilterInfo
{
    TCHAR   *szEmail;
    BOOL    fEncryption;
    DWORD   dwFlags;
} ACCTFILTERINFO;

CRYPT_ENCODE_PARA       CryptEncodeAlloc = {
    sizeof(CRYPT_ENCODE_PARA), CryptAllocFunc, CryptFreeFunc
};

CRYPT_DECODE_PARA       CryptDecodeAlloc = {
    sizeof(CRYPT_DECODE_PARA), CryptAllocFunc, CryptFreeFunc
};

#define FILETIME_SECOND    10000000     // 100ns intervals per second
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds


/////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
static int      _CompareCertAndSenderEmail(LPMIMEMESSAGE pMsg, IMimeSecurity *pSMime, PCX509CERT pCert);
static HRESULT  _RemoveSecurity(LPMIMEMESSAGE pMsg, HWND hWnd);
static HRESULT  _ValidateAndTrust(HWND hwndOwner, IMimeSecurity *pSMime, IMimeMessage *pMsg);
static BOOL     _IsMaskedBodySecure(LPMIMEMESSAGE pMsg, HBODY hBodyToCheck, DWORD dwMask);

#ifdef SMIME_V3
static HRESULT _HrPrepSecureMsgForSending(HWND hwnd, LPMIMEMESSAGE pMsg, IImnAccount *pAccount, BOOL *pfHaveSenderCert, BOOL *fDontEncryptForSelf, IHeaderSite *pHeaderSite);
#else
static HRESULT _HrPrepSecureMsgForSending(HWND hwnd, LPMIMEMESSAGE pMsg, IImnAccount *pAccount, BOOL *pfHaveSenderCert, BOOL *fDontEncryptForSelf);
#endif // SMIME_V3

int GetNumMyCertForAccount(HWND hwnd, IImnAccount * pAccount, BOOL fEncrypt, HCERTSTORE hcMy, PCCERT_CONTEXT * ppcSave);
/////////////////////////////////////////////////////////////////////////////
//
// Inlines
//

/*  _IsMaskedBodySecure:
**
**  Purpose:
**      Private function to allow the IsSigned, etc queries to work
**  Takes:
**      IN pMsg         - message to query
**      IN hBodyToCheck - body to query, HBODY_ROOT is valid
**      IN dwMask       - bitmask for MST_ result
*/
inline BOOL _IsMaskedBodySecure(LPMIMEMESSAGE   pMsg,
                                HBODY           hBodyToCheck,
                                DWORD           dwMask)
{
    return (dwMask & DwGetSecurityOfMessage(pMsg, hBodyToCheck));
}

/////////////////////////////////////////////////////////////////////////////
//
// Functions
//

/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (error && ! (error & 0x80000000))
        hr = error | 0x80070000;    // system error
    else
        hr = (HRESULT)error;

    return(hr);
}


//
// Here we include a few constants and guids from the WAB API code.
// This should probably be available somewhere in the WAB headers, but it
// isn't currently.

// From WABAPI code: _mapiprv.h
// Generic internal entry ID structure
#pragma warning (disable: 4200)
typedef struct _MAPIEID {
	BYTE	abFlags[4];
	MAPIUID	mapiuid;
	BYTE	bData[];
} MAPI_ENTRYID, *LPMAPI_ENTRYID;
#pragma warning (default: 4200)

// From WABAPI code: _entryid.h
enum _WAB_ENTRYID_TYPE {
    // Must not use 0, this value is invalid.
    WAB_PAB = 1,
    WAB_DEF_DL,
    WAB_DEF_MAILUSER,
    WAB_ONEOFF,
    WAB_ROOT,
    WAB_DISTLIST,
    WAB_CONTAINER,
    WAB_LDAP_CONTAINER,
    WAB_LDAP_MAILUSER
};
// From WABAPI code: entryid.c
static UUID WABGUID = { /* d3ad91c0-9d51-11cf-a4a9-00aa0047faa4 */
    0xd3ad91c0,
    0x9d51,
    0x11cf,
    {0xa4, 0xa9, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
};

static UUID MAPIGUID = { /* a41f2b81-a3be-1910-9d6e-00dd010f5402 */
    0xa41f2b81,
    0xa3be,
    0x1910,
    {0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02}
};
/***************************************************************************

    Name      : IsWABOneOff

    Purpose   : Is this WAB EntryID a one-off?

    Parameters: cbEntryID = size of lpEntryID.
                lpEntryID -> entryid to check.

    Returns   : True if this is a WAB one-off entryid

    Comment   :

***************************************************************************/
BOOL IsWABOneOff(ULONG cbEntryID, LPENTRYID lpEntryID)
{
    BYTE bType;
    LPMAPI_ENTRYID lpeid;
    LPBYTE lpData1, lpData2, lpData3;
    ULONG cbData1, cbData2;
    LPBYTE lpb;

    // First check... is it big enough?
    if (cbEntryID < sizeof(MAPI_ENTRYID) + sizeof(bType))
        return(FALSE);

    lpeid = (LPMAPI_ENTRYID)lpEntryID;

    // Next check... does it contain our GUID?
    /// MAPI One Off stuff
    if (! memcmp(&lpeid->mapiuid, &MAPIGUID, sizeof(MAPIGUID)))
    {
        lpb = lpeid->bData + sizeof(DWORD);
        bType = WAB_ONEOFF;
    }
    else if (! memcmp(&lpeid->mapiuid, &WABGUID, sizeof(WABGUID)))
    {
        lpb = lpeid->bData;
        bType = *lpb;
        lpb++;
    }
    else
        return(FALSE);  // No match

    switch ((int)bType)
    {
        case WAB_ONEOFF:
            return(TRUE);       // This is a WAB One-off
            break;

        case WAB_PAB:
        case WAB_DEF_DL:
        case WAB_DEF_MAILUSER:
        case WAB_LDAP_CONTAINER:
        case WAB_LDAP_MAILUSER:
        default:
            break;              // Not a one-off
    }
    return(FALSE);
}


// enum for ADRENTRY props
enum {
    irnPR_ENTRYID = 0,
    irnPR_DISPLAY_NAME,
    irnPR_EMAIL_ADDRESS,
    irnPR_OBJECT_TYPE,
    irnMax
};

// enum for Resolve props
enum {
    irsPR_ENTRYID = 0,
    irsPR_EMAIL_ADDRESS,
    irsPR_CONTACT_EMAIL_ADDRESSES,
    irsPR_CONTACT_ADDRTYPES,
    irsPR_CONTACT_DEFAULT_ADDRESS_INDEX,
    irsPR_DISPLAY_NAME,
    irsPR_OBJECT_TYPE,
    irsPR_USER_X509_CERTIFICATE,
    irsMax
};

SizedSPropTagArray(1, ptaCert) = {1, {PR_USER_X509_CERTIFICATE}};

SizedSPropTagArray(1, ptaEntryID) = {1, {PR_ENTRYID}};

SizedSPropTagArray(irsMax, ptaResolve) = {irsMax,
    {
        PR_ENTRYID,
        PR_EMAIL_ADDRESS_W,
        PR_CONTACT_EMAIL_ADDRESSES_W,
        PR_CONTACT_ADDRTYPES_W,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
        PR_DISPLAY_NAME_W,
        PR_OBJECT_TYPE,
        PR_USER_X509_CERTIFICATE
    }
};

/***************************************************************************

    Name      : HrFindThumbprint

    Purpose   : Find a matching entry with a certificate in the WAB

    Parameters: pAdrInfo -> ADRINFO structure for this contact
                lpWabal -> WABAL object
                lppspv -> returned data.  Caller must WABFreeBuffer the returned pointer.
    Returns   : HRESULT, MIME_E_SECURITY_NOCERT if not found

    Comment   :

***************************************************************************/
HRESULT HrFindThumbprintInWAB(ADRINFO * pAdrInfo, LPWABAL lpWabal, LPSPropValue * lppspv)
{
    HRESULT hr = hrSuccess, hrReturn = MIME_E_SECURITY_NOCERT;
    LPADRBOOK lpAdrBook;
    LPADRLIST lpAdrList = NULL;
    ULONG ulObjectType;
    LPMAILUSER lpMailUser = NULL;
    SCODE sc;
    ULONG cProps = 0;
    LPSPropValue ppv = NULL;

    if (! (lpAdrBook = lpWabal->GetAdrBook())) // Don't release this!
    {
        Assert(lpAdrBook);
        return(MIME_E_SECURITY_NOCERT);
    }

    if (sc = lpWabal->AllocateBuffer(sizeof(ADRLIST) + 1 * sizeof(ADRENTRY), (LPVOID*)&lpAdrList))
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->cEntries = 1;
    lpAdrList->aEntries[0].ulReserved1 = 0;
    lpAdrList->aEntries[0].cValues = irnMax;

    // Allocate the prop array for the ADRENTRY
    if (sc = lpWabal->AllocateBuffer(lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
      (LPVOID*)&lpAdrList->aEntries[0].rgPropVals))
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb = 0;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb = NULL;

    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;


    if (pAdrInfo->lpwszDisplay)
    {
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME_W;
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].Value.lpszW = pAdrInfo->lpwszDisplay;
    }
    else
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_NULL;

    if (pAdrInfo->lpwszAddress)
    {
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS_W;
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].Value.lpszW = pAdrInfo->lpwszAddress;
    }
    else
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;

    hr = lpAdrBook->ResolveName((ULONG)NULL,    // hwnd
      WAB_RESOLVE_FIRST_MATCH | WAB_RESOLVE_LOCAL_ONLY | WAB_RESOLVE_ALL_EMAILS |
      WAB_RESOLVE_NO_ONE_OFFS | WAB_RESOLVE_NEED_CERT | WAB_RESOLVE_UNICODE,
      NULL,
      lpAdrList);

    switch (GetScode(hr))
    {
        case SUCCESS_SUCCESS:   // Should be a resolved entry now
            if (lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag == PR_ENTRYID)
            {
                if (! (HR_FAILED(hr = lpAdrBook->OpenEntry(lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb,
                    (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb,
                    NULL,
                    MAPI_MODIFY,  // ulFlags
                    &ulObjectType,
                    (LPUNKNOWN *)&(lpMailUser)))))
                {

                    // Got the entry, Get the cert property.
                    // NOTE: don't FreeBuffer the ppv.  The caller will handle this.
                    hr = lpMailUser->GetProps((LPSPropTagArray)&ptaCert, 0, &cProps, &ppv);

                    if (HR_FAILED(hr) || ! cProps || ! ppv || PROP_ERROR(ppv[0]))
                    {
                        if (ppv)
                            lpWabal->FreeBuffer(ppv);
                        break;
                    }

                    // Got the cert prop
                    // Fill in the return prop array with our new prop array
                    *lppspv = ppv;
                    hrReturn = hrSuccess;
                }
            }
            break;

        case MAPI_E_AMBIGUOUS_RECIP:
            // More than one match.  This would be really weird since we specified WAB_RESOLVE_FIRST_MATCH
            Assert(FALSE);
            break;

        case MAPI_E_NOT_FOUND:
            DOUTL(DOUTL_CRYPT, "ResolveName to find entry with cert failed.");
            // no match with a cert
            break;

        case MAPI_E_USER_CANCEL:
            hrReturn = hr;
            break;

        default:
            break;
    }

exit:
    if (lpAdrList)
    {
        for (ULONG iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry)
            if(lpAdrList->aEntries[iEntry].rgPropVals)
                lpWabal->FreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
        lpWabal->FreeBuffer(lpAdrList);
    }

    if (lpMailUser)
        lpMailUser->Release();

    return(hr);
}


BOOL MatchCertEmailAddress(PCCERT_CONTEXT pcCert, LPTSTR szEmailAddress)
{
    BOOL fRet = FALSE;

    LPSTR szCertEmail = SzGetCertificateEmailAddress(pcCert);

    if (szCertEmail)
    {
        fRet = !(BOOL(lstrcmpi(szCertEmail, szEmailAddress)));
        MemFree(szCertEmail);
    }

#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
        // backdoor to avoid having to care about email addresses
        // Hold down the shift key while the Send is happening to
        // skip the address check and use the first one marked default
        fRet = TRUE;
#endif

    return(fRet);
}

BOOL CompareCertHash(PCCERT_CONTEXT pCert,
                     DWORD dwPropId, PCRYPT_HASH_BLOB pHash )
{
    BYTE rgbHash[20];
    DWORD cbHash = 20;
    CertGetCertificateContextProperty(pCert,
                                      dwPropId,
                                      rgbHash,
                                      &cbHash);
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HRESULT HrUserSMimeCertCracker(LPBYTE pbIn, DWORD cbIn, HCERTSTORE hCertStoreCA,
                               HCERTSTORE hCertStore, BOOL * pfDefault,
                               PCCERT_CONTEXT * ppccert, BLOB * pSymCaps)
{
    DWORD                       cb;
    DWORD                       cbCert;
    DWORD                       cbMaxCert;
    DWORD                       cbSMimeCaps;
    DWORD                       cCerts;
    DWORD                       cSigners;
    DWORD                       cval;
    DWORD                       dwDefaults=0;
    DWORD                       dwNortelAlg;
    BOOL                        f;
    HCERTSTORE                  hstoreMem = NULL;
    HCRYPTMSG                   hmsg;
    HRESULT                     hr=S_OK;
    ULONG                       i;
    PCRYPT_ATTRIBUTE            pattr;
    PCRYPT_ATTRIBUTE            pattrSymCaps = NULL;
    LPBYTE                      pbCert=NULL;
    LPBYTE                      pbData;
    LPBYTE                      pbSMimeCaps;
    PCCERT_CONTEXT              pccert;
    PCCERT_CONTEXT              pccertReturn = NULL;
    PCMSG_SIGNER_INFO           pinfo;
    PCRYPT_RECIPIENT_ID         prid = NULL;
    PSMIME_ENC_KEY_PREFERENCE   pekp = NULL;

    hmsg = CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING, 0, 0, NULL,
                                NULL, NULL);
    if (hmsg == 0)
    {
        return E_FAIL;
    }

    if (!CryptMsgUpdate(hmsg, pbIn, cbIn, TRUE))
    {
        return E_FAIL;
    }

    cb = sizeof(cSigners);
    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_COUNT_PARAM, 0, &cSigners, &cb) ||
        (cSigners == 0))
    {
        return E_FAIL;
    }
    Assert(cSigners == 1);

    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &cb))
    {
        goto CryptError;
    }

    pinfo = (PCMSG_SIGNER_INFO) malloc(cb);
    f = CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, pinfo, &cb);
    Assert(f);

    // M00BUG -- verify signature on message

    for (i=0; i<pinfo->AuthAttrs.cAttr; i++)
    {
        pattr = &pinfo->AuthAttrs.rgAttr[i];
        if (strcmp(pattr->pszObjId, szOID_RSA_SMIMECapabilities) == 0)
        {
            Assert(pattr->cValue == 1);
            pattrSymCaps = pattr;
        }
        else if (strcmp(pattr->pszObjId, szOID_MSFT_Defaults) == 0)
        {
            Assert(pattr->cValue == 1);
            Assert(pattr->rgValue[0].cbData == 3);
            dwDefaults = pattr->rgValue[0].pbData[2];
        }
        else if (strcmp(pattr->pszObjId, szOID_Microsoft_Encryption_Cert) == 0)
        {
            Assert(pattr->cValue == 1);
            f = CryptDecodeObjectEx(X509_ASN_ENCODING,
                                    szOID_Microsoft_Encryption_Cert,
                                    pattr->rgValue[0].pbData,
                                    pattr->rgValue[0].cbData,
                                    CRYPT_DECODE_ALLOC_FLAG, 0,
                                    (LPVOID *) &prid, &cb);
            Assert(f);
        }
        else if (strcmp(pattr->pszObjId, szOID_SMIME_Encryption_Key_Preference) == 0)
        {
            Assert(pattr->cValue == 1);
            f = CryptDecodeObjectEx(X509_ASN_ENCODING,
                                    szOID_SMIME_Encryption_Key_Preference,
                                    pattr->rgValue[0].pbData,
                                    pattr->rgValue[0].cbData,
                                    CRYPT_DECODE_ALLOC_FLAG, 0,
                                    (LPVOID *) &pekp, &cb);
            Assert(f);
        }
    }

    if ((prid == NULL) && (pekp == NULL))
        goto Exit;

    //  Enumerate all certs and pack into the structure

    cbCert = sizeof(cCerts);
    if (!CryptMsgGetParam(hmsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbCert))
    {
        goto CryptError;
    }

    cbMaxCert = 0;
    for (i=0; i<cCerts; i++)
    {
        if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, NULL, &cbCert))
        {
            goto CryptError;
        }
        if (cbCert > cbMaxCert)
            cbMaxCert = cbCert;
    }

    pbCert = (LPBYTE) LocalAlloc(0, cbMaxCert);
    if (pbCert == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hstoreMem = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING, NULL, 0, NULL);
    if (hstoreMem == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for (i=0; i<cCerts; i++)
    {
        BOOL fFoundEncryptCert;

        cb = cbMaxCert;
        if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, pbCert, &cb))
        {
            goto CryptError;
        }

        pccert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cb);
        if (pccert == NULL)
            continue;

        fFoundEncryptCert = FALSE;
        if (pekp != NULL) {
            PCERT_ID pCertId = (PCERT_ID) &pekp->RecipientId;
            
            switch (pCertId->dwIdChoice) {
                case CERT_ID_ISSUER_SERIAL_NUMBER:
                    if (CertCompareCertificateName(X509_ASN_ENCODING,
                                               &pccert->pCertInfo->Issuer,
                                               &pCertId->IssuerSerialNumber.Issuer) &&
                        CertCompareIntegerBlob(&pccert->pCertInfo->SerialNumber,
                                               &pCertId->IssuerSerialNumber.SerialNumber)) {
                        fFoundEncryptCert = TRUE;
                        //pval[ival].ulPropTag = PR_CERT_KEYEX_CERTIFICATE_BIN;
                    }
                    break;
                case CERT_ID_KEY_IDENTIFIER:
                    if (CompareCertHash(pccert, CERT_KEY_IDENTIFIER_PROP_ID,
                                        &pCertId->KeyId)) {
                        fFoundEncryptCert = TRUE;
                        //pval[ival].ulPropTag = PR_CERT_KEYEX_CERTIFICATE_BIN;
                    }
                    break;
                case CERT_ID_SHA1_HASH:
                    if (CompareCertHash(pccert, CERT_SHA1_HASH_PROP_ID,
                                        &pCertId->HashId)) {
                        fFoundEncryptCert = TRUE;
                        //pval[ival].ulPropTag = PR_CERT_KEYEX_CERTIFICATE_BIN;
                    }
                    break;
                default:
                    Assert(FALSE);
            }
        }
        else if (prid != NULL) {
            if (CertCompareCertificateName(X509_ASN_ENCODING,
                                           &pccert->pCertInfo->Issuer,
                                           &prid->Issuer) &&
                CertCompareIntegerBlob(&pccert->pCertInfo->SerialNumber,
                                       &prid->SerialNumber)) {
                fFoundEncryptCert = TRUE;
                //pval[ival].ulPropTag = PR_CERT_KEYEX_CERTIFICATE_BIN;
            }
        }

        if (fFoundEncryptCert)
        {
            pccertReturn = CertDuplicateCertificateContext(pccert);
            CertAddCertificateContextToStore(hCertStore, pccert,
                                             CERT_STORE_ADD_USE_EXISTING, NULL);
        }

        CertAddCertificateContextToStore(hstoreMem, pccert,
                                         CERT_STORE_ADD_USE_EXISTING, NULL);
        CertFreeCertificateContext(pccert);
    }

    if (pccertReturn == NULL)
    {
        hr = S_FALSE;
        goto Exit;
    }

    HrSaveCACerts(hCertStoreCA, hstoreMem);

    *ppccert = pccertReturn;
    *pfDefault = dwDefaults;
    if (pattrSymCaps != NULL)
    {
        pSymCaps->pBlobData = (LPBYTE) LocalAlloc(0, pattrSymCaps->rgValue[0].cbData);
        if (pSymCaps->pBlobData != NULL)
        {
            pSymCaps->cbSize = pattrSymCaps->rgValue[0].cbData;
            memcpy(pSymCaps->pBlobData, pattrSymCaps->rgValue[0].pbData,
                   pSymCaps->cbSize);
        }
    }

    hr = S_OK;

Exit:
    if (pbCert != NULL)         LocalFree(pbCert);
    if (prid != NULL)           LocalFree(prid);
    if (pekp != NULL)           LocalFree(pekp);
    if (pinfo != NULL)          LocalFree(pinfo);
    if (hmsg != NULL)           CryptMsgClose(hmsg);
    if (hstoreMem != NULL)      CertCloseStore(hstoreMem, 0);
    return hr;

CryptError:
    hr = E_FAIL;
    goto Exit;
}

/*  HrGetThumbprint:
**
**  Purpose:
**      Give a wabal, grab a thumbprint from the PR_X509 prop
**  Takes:
**      IN lpWabal      - the wabal from which recipients are read
**      IN pAdrInfo     - wab entry to query
**      OUT pThumbprint - thumbprint that was found (Caller should MemFree)
**      OUT pSymCaps    - symcaps that was found (Caller should MemFree)
**      OUT ftSigningTime - Signing time for cert
**  Returns:
**      SMIME_E_NOCERT if the MAPI cert prop doesn't exist for one of the recips
**  Wabal Layout:
**      PR_X509 = MVBin
**                  SBin
**                    lpb = tagarr
**                      tag
**                        tagid = def, trust, thumb
**                        data
**                      tag
**                      tag
**                  SBin
**                    tagarr
**                      tag
**                  ...
*/

HRESULT HrGetThumbprint(LPWABAL lpWabal, ADRINFO *pAdrInfo, THUMBBLOB *pThumbprint,
                        BLOB * pSymCaps, FILETIME * pftSigningTime)
{
    HRESULT         hr = S_OK;
    int             iPass;
    ADRINFO         rAdrInfo;
    LPMAPIPROP      pmp = NULL;
    LPSPropValue    ppv = NULL;
    ULONG           cCerts;
    ULONG           ul, ulDefault = 0;
    HCERTSTORE      hCertStore = NULL;
    HCERTSTORE      hCertStoreCA = NULL;
    PCCERT_CONTEXT  pccert = NULL;
    LPBYTE          pbData;
    ULONG           cbData;
    LPTSTR          pszAddr = NULL;

    Assert(lpWabal && pAdrInfo);
    pThumbprint->pBlobData = NULL;
    pSymCaps->pBlobData = NULL;
    pSymCaps->cbSize = 0;


    pftSigningTime->dwLowDateTime = pftSigningTime->dwHighDateTime = 0;

    // Find out if this wabal entry is the sender
    if (pAdrInfo->lRecipType == MAPI_ORIG)
    {
        hr = TrapError(MIME_E_SECURITY_NOCERT);
        goto exit;
    }

    CHECKHR(hr = lpWabal->HrGetPMP(pAdrInfo->cbEID, (LPENTRYID)pAdrInfo->lpbEID, &ul, &pmp));
    CHECKHR(hr = pmp->GetProps((LPSPropTagArray)&ptaCert, 0, &ul, &ppv));

    if (MAPI_W_ERRORS_RETURNED == hr)
    {
        if (PROP_TYPE(ppv->ulPropTag) == PT_ERROR)
        {
            // the property doesn't exist, so we have no certs
            // for this wabal entry

            lpWabal->FreeBuffer(ppv);
            ppv = NULL;

            // Was it a one-off?  If so, go look for it in the address book
            if (IsWABOneOff(pAdrInfo->cbEID, (LPENTRYID)pAdrInfo->lpbEID))
            {
                // Look it up
                hr = HrFindThumbprintInWAB(pAdrInfo, lpWabal, &ppv);
                if (FAILED(hr))
                {
                    hr = MIME_E_SECURITY_NOCERT;    // no cert in wab
                    goto exit;
                }
            }
            else
            {
                hr = MIME_E_SECURITY_NOCERT;
                goto exit;
            }
        }
        else
        {
            // bad MAPI return
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }
    else if (FAILED(hr) || 1 != ul)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Open Address Book Cert Store
    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, 0,
                               CERT_SYSTEM_STORE_CURRENT_USER, c_szWABCertStore);
    if (!hCertStore)
    {
        // Can't open cert store.  No point continuing.
        hr = HrGetLastError();
        goto exit;
    }

    // Open CA Cert Store
    hCertStoreCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, 0,
                               CERT_SYSTEM_STORE_CURRENT_USER, c_szCACertStore);
    if (!hCertStoreCA)
    {
        // Can't open cert store.  No point continuing.
        hr = HrGetLastError();
        goto exit;
    }

    //
    // Here is what is going to happen for the next few lines of code.  This is
    //  drastically different from what the old code here did.
    //
    //  Pass #1:
    //        Look at each row in the binary structure for the 'default' row.
    //        When found extract the cert and verify that it is trusted and valid.
    //        If not valid, goto pass #2.
    //        If not trusted, -----
    //
    // Now need to loop over the SBinary structures to look at each cert

    cCerts = ppv->Value.MVbin.cValues;
    for (iPass = 0; (pccert == NULL) && (iPass < 2); iPass++)
        for (ul = 0; ul < cCerts; ul++)
        {
            BOOL        fDefault = 0;

            fDefault = FALSE;

            //  This is the userSMimeCertificate field
            if (ppv->Value.MVbin.lpbin[ul].lpb[0] == CERT_TAG_SMIMECERT)
            {
                hr = HrUserSMimeCertCracker(ppv->Value.MVbin.lpbin[ul].lpb,
                                            ppv->Value.MVbin.lpbin[ul].cb,
                                            hCertStoreCA, hCertStore,
                                            &fDefault, &pccert, pSymCaps);
                if (FAILED(hr))
                    continue;
            }
            else
            {
                // Grab the "default" tag for later testing.
                if (pbData = FindX509CertTag(&ppv->Value.MVbin.lpbin[ul], CERT_TAG_DEFAULT, &cbData))
                {
                    memcpy((void*)&fDefault, pbData, min(cbData, sizeof(fDefault)));
                    if (!fDefault && (iPass ==0))
                        continue;
                }

                // scan for "thumbprint" tag

                if (pbData = FindX509CertTag(&ppv->Value.MVbin.lpbin[ul], CERT_TAG_THUMBPRINT, &cbData))
                {
                    pThumbprint->cbSize = cbData;
                    pThumbprint->pBlobData = pbData;

                    // Find the cert in the store
                    pccert = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING, 0,
                                                               CERT_FIND_HASH, (void*)pThumbprint, NULL);
                    if (pccert == NULL)   // Got the cert context
                    {
                        pThumbprint->cbSize = 0;
                        pThumbprint->pBlobData = NULL;
                        continue;   // no cert in store, skip this one
                    }
                }
                else if (pbData = FindX509CertTag(&ppv->Value.MVbin.lpbin[ul], CERT_TAG_BINCERT, &cbData))
                {
                    pccert = CertCreateCertificateContext(X509_ASN_ENCODING, pbData, cbData);
                    if (pccert == NULL)
                        continue;
                }
                else
                {
                    continue;
                }
            }

            // Does the email address of the cert match the email address of the recipient?
            Assert(pAdrInfo->lpwszAddress);
            IF_NULLEXIT(pszAddr = PszToANSI(CP_ACP, pAdrInfo->lpwszAddress));

            BOOL fSame = MatchCertEmailAddress(pccert, pszAddr);
            SafeMemFree(pszAddr);
            if (fSame)
            {
                DWORD dw = 0;
                HrGetCertKeyUsage(pccert, &dw);
                if(dw == 0xff)          // all purposes
                    break;
                else if (dw & CERT_KEY_ENCIPHERMENT_KEY_USAGE) // Encryption certificate
                        break;
            }

            CertFreeCertificateContext(pccert);
            pccert = NULL;

            if (pSymCaps->pBlobData != NULL)
            {
                LocalFree(pSymCaps->pBlobData);
                pSymCaps->pBlobData = NULL;
                pSymCaps->cbSize = 0;
            }

            // Not the same, go back and try again!

            pThumbprint->cbSize = 0;
            pThumbprint->pBlobData = NULL;

        } // for loop over certs

    if (pccert == NULL)
    {
        hr = MIME_E_SECURITY_NOCERT;
        goto exit;
    }
    hr = hrSuccess;

    // If we have a match, find other associated tags
    if (pThumbprint->pBlobData)
    {
        if (pbData = FindX509CertTag(&ppv->Value.MVbin.lpbin[ul], CERT_TAG_SYMCAPS, &cbData))
        {
            if (! MemAlloc((LPVOID *)&pSymCaps->pBlobData, cbData))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }
            pSymCaps->cbSize = cbData;
            memcpy(pSymCaps->pBlobData, pbData, cbData);
        }
        else
            DOUTL(DOUTL_CRYPT, "No symcaps for recipient.");

        if (pbData = FindX509CertTag(&ppv->Value.MVbin.lpbin[ul], CERT_TAG_SIGNING_TIME, &cbData))
            memcpy(pftSigningTime, &pbData, min(sizeof(FILETIME), cbData));
        else
            DOUTL(DOUTL_CRYPT, "No signing time for recipient.");
    }

#ifdef DEBUG
    // Make sure the HRESULT is in sync with thumbprint
    if (pccert == NULL)
        Assert(FAILED(hr));
    else
        Assert(SUCCEEDED(hr));
#endif

    if (SUCCEEDED(hr) && (pccert != NULL))
    {
        pThumbprint->pBlobData = (LPBYTE) PVGetCertificateParam(pccert, CERT_HASH_PROP_ID, &pThumbprint->cbSize);

        if (pThumbprint->pBlobData == NULL)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

exit:
    if (! pThumbprint->pBlobData)
        pThumbprint->cbSize = 0;
    if (ppv)
        lpWabal->FreeBuffer(ppv);

    ReleaseObj(pmp);

    if (FAILED(hr) && (pSymCaps != NULL))
    {
        MemFree(pSymCaps->pBlobData);
        pSymCaps->pBlobData = NULL;
        pSymCaps->cbSize = 0;
    }

    if (pccert)
        CertFreeCertificateContext(pccert);

    if (hCertStoreCA)
        CertCloseStore(hCertStoreCA, 0);
    if (hCertStore)
        CertCloseStore(hCertStore, 0);

    return hr;
}


/*  IsEncrypted:
**
**  Purpose:
**      Answer the question
**
**  Takes:
**      IN pMsg         - message to query
**      IN hBodyToCheck - body to query, HBODY_ROOT is valid
**      IN fIncludeDescendents - if FALSE, returns with MST_CHILD and
**                      MST_SUBMSG don't count
*/
BOOL IsEncrypted(LPMIMEMESSAGE  pMsg,
                 const HBODY    hBodyToCheck,
                 BOOL           fIncludeDescendents)
{
    return _IsMaskedBodySecure(pMsg, hBodyToCheck,
        fIncludeDescendents ? MST_ENCRYPT_MASK : MST_ENCRYPT_MASK & MST_THIS_MASK);
}

/*  IsSigned:
**
**  Purpose:
**      Answer the question
**
**  Takes:
**      IN pMsg         - message to query
**      IN hBodyToCheck - body to query, HBODY_ROOT is valid
**      IN fIncludeDescendents - if FALSE, returns with MST_CHILD and
**                      MST_SUBMSG don't count
*/
BOOL IsSigned(LPMIMEMESSAGE pMsg,
              const HBODY   hBodyToCheck,
              BOOL          fIncludeDescendents)
{
    return _IsMaskedBodySecure(pMsg, hBodyToCheck,
        fIncludeDescendents ? MST_SIGN_MASK : MST_SIGN_MASK & MST_THIS_MASK);
}

/*  DwGetSecurityOfMessage:
**
**  Purpose:
**      Wrap up the slight nastiness of options
**  Takes:
**      IN pMsg         - message to query
**      IN hBodyToCheck - body to query, HBODY_ROOT is valid
*/
DWORD DwGetSecurityOfMessage(LPMIMEMESSAGE  pMsg,
                             const HBODY    hBodyToCheck)
{
    IMimeBody          *pBody;
    PROPVARIANT         var;
    DWORD               dwRet = MST_NONE;

    Assert(pMsg);

    if (SUCCEEDED(pMsg->BindToObject(hBodyToCheck, IID_IMimeBody, (void**)&pBody)))
    {
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var)))
            dwRet = var.ulVal;
        pBody->Release();
    }

    return dwRet;
}


/*  CleanupSECSTATE
**
**  Purpose:
**      Cleanup the strings allocated by HrGetSecurityState
**  Takes:
**      IN secstate     - secstate structure
*/
VOID CleanupSECSTATE(SECSTATE *psecstate)
{
    SafeMemFree(psecstate->szSignerEmail);
    SafeMemFree(psecstate->szSenderEmail);
}


/*  HrHaveAnyMyCerts:
**
**  Purpose:
**      see if any certificates exist in the CAPI "My" store
**  Returns:
**      S_OK if certificates exist, S_FALSE if the store is empty
**      or does not exist
*/
HRESULT HrHaveAnyMyCerts()
{
    IMimeSecurity   *pSMime = NULL;
    HRESULT         hr;
    HCAPICERTSTORE  hcMy = NULL;

    CHECKHR(hr = MimeOleCreateSecurity(&pSMime));
    CHECKHR(hr = pSMime->InitNew());
    hcMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
        X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
    if (hcMy)
    {
        hr = pSMime->EnumCertificates(hcMy, 0, NULL, NULL);
        CertCloseStore(hcMy, 0);
    }
    else
        hr = S_FALSE;

exit:
    ReleaseObj(pSMime);
    return hr;
}

/*  HandleSecurity:
**
**  Purpose:
**      Two fold.  One, strip the security from the message, so it ends
**      up being rebuilt from the non-secure MIME.  Then build the client-
**      side message properties for security.
**
**  Takes:
**      IN pMsg - message from which to remove security
*/
HRESULT HandleSecurity(HWND hwndOwner, LPMIMEMESSAGE pMsg)
{
    HRESULT             hr;
    HWND                hWnd = NULL;

    if(g_pBrowser)
        g_pBrowser->GetWindow(&hWnd);
    if(hWnd == NULL)
        hWnd = hwndOwner;

    Assert(pMsg);
    hr = _RemoveSecurity(pMsg, hWnd);
    if ((HR_S_NOOP != hr) && (MIME_S_SECURITY_NOOP != hr) && SUCCEEDED(hr))
    {
        IMimeSecurity *pSMime = NULL;
        if (IsSigned(pMsg, FALSE))
        {
            //N2 look at the creation in removsec
            hr = MimeOleCreateSecurity(&pSMime);
            if (SUCCEEDED(hr))
                hr = pSMime->InitNew();
            if (SUCCEEDED(hr))
                hr = _ValidateAndTrust(hwndOwner, pSMime, pMsg);
            ReleaseObj(pSMime);
        }
    }
    else if((hr == OSS_PDU_MISMATCH) || (hr == CRYPT_E_ASN1_BADTAG))  // bug 38394
    {
        AthMessageBoxW(hwndOwner, MAKEINTRESOURCEW(idsAthenaMail),
                    MAKEINTRESOURCEW(idsWrongSecHeader), NULL, MB_OK);
        hr = HR_S_NOOP;
    }

#if 0
    else if(((hr >= ASN1_ERR_FIRST) && (hr <= ASN1_ERR_LAST)) || (HR_CODE(hr) == ERROR_ACCESS_DENIED))
        hr = MIME_E_SECURITY_LABELACCESSDENIED;
#endif

    return hr;
}

#ifdef SMIME_V3

// Find secure receipt in decoded message
HRESULT CheckDecodedForReceipt(LPMIMEMESSAGE pMsg, PSMIME_RECEIPT * ppSecReceipt)
{
    IMimeBody        *  pBody = NULL;
    LPBYTE              pbData = NULL;
    DWORD               cbData, cb;
    LPSTREAM            pstmBody = NULL;
    STATSTG             statstg;
    HRESULT             hr = S_OK;
    HBODY               hBody = NULL;

    if(!IsSecure(pMsg))
        return(E_FAIL);

    if(FAILED(hr = HrGetInnerLayer(pMsg, &hBody)))
        goto exit;

    if (FAILED(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pBody)))
        goto notinit;
    if (FAILED(hr = pBody->GetData(IET_BINARY, &pstmBody)))
        goto notinit;
    if (FAILED(hr = pstmBody->Stat(&statstg,STATFLAG_NONAME)))
        goto notinit;

    Assert(statstg.cbSize.HighPart == 0);

    if(statstg.cbSize.LowPart == 0)
        goto notinit;
    if (FAILED(hr = HrAlloc((LPVOID *)&pbData, statstg.cbSize.LowPart)))
        goto notinit;
    if (FAILED(hr = pstmBody->Read(pbData, statstg.cbSize.LowPart, &cbData)))
    {
notinit:
            hr = MIME_E_SECURITY_NOTINIT;
            goto exit;
    }

    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_ContentType_Receipt,
        pbData,
        cbData,
        CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
        ppSecReceipt, &cb))
    {
        hr = MIME_E_SECURITY_RECEIPT_CANTDECODE;
        goto exit;
    }

exit:
    SafeMemFree(pbData);
    SafeRelease(pstmBody);
    SafeRelease(pBody);
    return(hr);
}

// Decode a message and find secure receipt
HRESULT HrFindSecReceipt(LPMIMEMESSAGE pMsg, PSMIME_RECEIPT * ppSecReceipt)
{
    IMimeSecurity    *  pSMime = NULL;
    IMimeBody        *  pBody = NULL;
    LPBYTE              pbData = NULL;
    DWORD               cbData;
    LPSTREAM            pstmBody = NULL;
    STATSTG             statstg;
    HRESULT             hr = S_OK;
    DWORD               cb = 0;
    HWND                hWnd = NULL;
    PROPVARIANT         var;
    HBODY               hBody = NULL;

    // Need to set correct window for decode
    if(g_pBrowser)
        g_pBrowser->GetWindow(&hWnd);

    IF_FAILEXIT(hr = HrGetInnerLayer(pMsg, &hBody));

    IF_FAILEXIT(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pBody));

#ifdef _WIN64
        var.vt = VT_UI8;
        var.pulVal = (ULONG *) hWnd;
        IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER_64, &var));
#else
        var.vt = VT_UI4;
        var.ulVal = (DWORD) hWnd;
        IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER, &var));
#endif // _WIN64
    SafeRelease(pBody);

    if (FAILED(hr = MimeOleCreateSecurity(&pSMime)))
        goto notinit;
    if (FAILED(hr = pSMime->InitNew()))
    {
notinit:
            hr = MIME_E_SECURITY_NOTINIT;
            goto exit;
    }

    // we handle all hr from DecodeMessage
    IF_FAILEXIT(hr = pSMime->DecodeMessage(pMsg, 0));
    hr = CheckDecodedForReceipt(pMsg, ppSecReceipt);

exit:
    SafeRelease(pSMime);
    SafeRelease(pBody);
    return(hr);
}

HRESULT CheckSecReceipt(LPMIMEMESSAGE pMsg)
{
    PSMIME_RECEIPT      pSecReceipt = NULL;
    HRESULT             hr = S_OK;

    hr = CheckDecodedForReceipt(pMsg, &pSecReceipt);
    SafeMemFree(pSecReceipt);

    return(hr);
}

#define ROWSET_FETCH            100

HRESULT HandleSecReceipt(LPMIMEMESSAGE pMsg, IImnAccount * pAcct, HWND hWnd, TCHAR **ppszSubject, TCHAR **ppszFrom, FILETIME *pftSentTime, FILETIME *pftSigningTime)
{
    IMimeSecurity2   *  pSMIME3 = NULL;
    IMimeBody        *  pOrgBody = NULL;
    PSMIME_RECEIPT      pSecReceipt = NULL;
    HRESULT             hr = S_FALSE;
    HRESULT             hrVerify = S_OK;
    LPMIMEMESSAGE       pOrgMsg = NULL;
    IMessageFolder      *pSentItems = NULL;
    HROWSET             hRowset=NULL;
    LPMESSAGEINFO       pMessage;
    MESSAGEINFO         Message={0};
    DWORD               i = 0;
    PCCERT_CONTEXT      pcSigningCert = NULL;
    THUMBBLOB           tbSigner = {0};
    BLOB                blSymCaps = {0};
    PROPVARIANT         var;
    HBODY               hBody = NULL;

    // bug 80490
    if(pAcct == NULL)
    {
        hr = MIME_E_SECURITY_RECEIPT_CANTFINDSENTITEM;
        goto exit;
    }

    // IF_FAILEXIT(hr = HrFindSecReceipt(pMsg, &pSecReceipt));
    IF_FAILEXIT(hr = CheckDecodedForReceipt(pMsg, &pSecReceipt));

    // check that this secure receipt is not from us

    // Name from sign certificate
    pftSigningTime->dwLowDateTime =  0;
    pftSigningTime->dwHighDateTime = 0;

    GetSigningCert(pMsg, &pcSigningCert, &tbSigner, &blSymCaps, pftSigningTime);
    if(pcSigningCert)
    {
        HCERTSTORE      hMyCertStore = NULL;
        X509CERTRESULT  certResult;
        CERTSTATE       cs;
        TCHAR           *pUserName = NULL;

        *ppszFrom = SzGetCertificateEmailAddress(pcSigningCert);
        CertFreeCertificateContext(pcSigningCert);
        pcSigningCert = NULL;

        SafeMemFree(tbSigner.pBlobData);

        // get certificate for account

        if (SUCCEEDED(hr = pAcct->GetProp(AP_SMTP_CERTIFICATE, NULL, &tbSigner.cbSize)))
        {
            // we have encryption certificate
            hr = HrAlloc((void**)&tbSigner.pBlobData, tbSigner.cbSize);
            if (SUCCEEDED(hr))
            {
                hr = pAcct->GetProp(AP_SMTP_CERTIFICATE, tbSigner.pBlobData, &tbSigner.cbSize);
                if (SUCCEEDED(hr))
                {
                    hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                        NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
                    if (hMyCertStore)
                    {
                        certResult.cEntries = 1;
                        certResult.rgcs = &cs;
                        certResult.rgpCert = &pcSigningCert;

                        hr = MimeOleGetCertsFromThumbprints(&tbSigner, &certResult, &hMyCertStore, 1);
                        pUserName = SzGetCertificateEmailAddress(pcSigningCert);
                        if(!lstrcmpi(pUserName, *ppszFrom))
                            hr  = MIME_S_RECEIPT_FROMMYSELF;

                        SafeMemFree(pUserName);
                        CertCloseStore(hMyCertStore, 0);
                    }
                    else
                        goto notinit;
                }
                SafeMemFree(tbSigner.pBlobData);
            }
            else
            {
notinit:
                hr = MIME_E_SECURITY_NOTINIT;
                goto exit;
            }
        }
    }

    if(hr == MIME_S_RECEIPT_FROMMYSELF)
        goto exit;

    // Verification of receipt
    // 1. Try to find Original message
    // 2. If found call pSMIME2->VerifyReceipt
    // 3. Fill all text fields for displaying receipt

    // Find original message
    // a). Open Sent Item folder for account

    if (FAILED(hr = TaskUtil_OpenSentItemsFolder(pAcct, &pSentItems)))
        goto NoSentItem;
    // Create a Rowset
    if (FAILED(hr = pSentItems->CreateRowset(IINDEX_PRIMARY, 0, &hRowset)))
    {
NoSentItem:
    hr = MIME_E_SECURITY_RECEIPT_CANTFINDSENTITEM;
    goto exit;
    }

    // Walk the Rowset
    hr = MIME_E_SECURITY_RECEIPT_CANTFINDORGMSG;
    while (S_OK == pSentItems->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Messages without request receipt doesn't have pszMSOESRec
        if(Message.pszMSOESRec && (lstrlen(Message.pszMSOESRec) == ((int) pSecReceipt->ContentIdentifier.cbData)))
        {
            if(!memcmp(pSecReceipt->ContentIdentifier.pbData, Message.pszMSOESRec,
                pSecReceipt->ContentIdentifier.cbData))
            {
                // Original message found!!!
                // Need take pMsg and verify receipt
                IF_FAILEXIT(hr = pSentItems->OpenMessage(Message.idMessage, 0, &pOrgMsg, NOSTORECALLBACK));
                IF_FAILEXIT(hr = pOrgMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pOrgBody));
                IF_FAILEXIT(hr = pOrgBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pSMIME3));
                IF_FAILEXIT(hr = pSMIME3->VerifyReceipt(0, pMsg));

                // If we are in here then we found original message and verified receipt.
                // Now need to feel all text fields

                // Subject and Sent from original message
                if (MemAlloc((LPVOID *)ppszSubject, lstrlen(Message.pszSubject) + 1))
                    lstrcpy(*ppszSubject, Message.pszSubject);

                pftSentTime->dwLowDateTime =  Message.ftSent.dwLowDateTime;
                pftSentTime->dwHighDateTime =  Message.ftSent.dwHighDateTime;

                if((pftSigningTime->dwLowDateTime == 0) && (pftSigningTime->dwHighDateTime == 0))
                {   // We may have this situation when message was signed, but certificate not included and not in storage.
                    SafeRelease(pOrgBody);

                    IF_FAILEXIT(hr = HrGetInnerLayer(pMsg, &hBody));

                    if(pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pOrgBody) == S_OK)
                    {
                        if (SUCCEEDED(pOrgBody->GetOption(OID_SECURITY_SIGNTIME, &var)))
                        {
                            Assert(VT_FILETIME == var.vt);
                            *pftSigningTime = var.filetime;
                        }
                    }
                }

                hr = S_OK;
                goto exit;
            }
        }
        pSentItems->FreeRecord(&Message);
    }
exit:
    SafeRelease(pSMIME3);
    SafeRelease(pOrgBody);
    SafeRelease(pOrgMsg);

    if(pSentItems)
        pSentItems->FreeRecord(&Message);

    if(pSentItems && hRowset)
        pSentItems->CloseRowset(&hRowset);

    SafeRelease(pSentItems);
    SafeMemFree(blSymCaps.pBlobData);
    SafeMemFree(tbSigner.pBlobData);
    if(pcSigningCert)
        CertFreeCertificateContext(pcSigningCert);

    SafeMemFree(pSecReceipt);

    return(hr);
}
#endif // SMIME_V3

HRESULT _RemoveSecurity(LPMIMEMESSAGE pMsg, HWND hWnd)
{
    HRESULT             hr = S_OK;
    IMimeSecurity       *pSMime = NULL;
    IMimeMessageTree    *pTree = NULL;
    IMimeBody        *  pBody = NULL;
    PROPVARIANT         var;

    DWORD               dwFlags;

    //N this is expensive, so _RemoveSecurity should not be called twice
    pMsg->GetFlags(&dwFlags);

    if (IMF_SECURE & dwFlags)
    {
        IF_FAILEXIT(hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pBody));

#ifdef _WIN64
        var.vt = VT_UI8;
        var.pulVal = (ULONG *)hWnd;
        IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER_64, &var));
#else
        var.vt = VT_UI4;
        var.ulVal = (DWORD) hWnd;
        IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER, &var));
#endif // _WIN64

        CHECKHR(hr = MimeOleCreateSecurity(&pSMime));
        CHECKHR(hr = pSMime->InitNew());
        CHECKHR(hr = pMsg->QueryInterface(IID_IMimeMessageTree, (LPVOID *)&pTree));
        CHECKHR(hr = pSMime->DecodeMessage(pTree, 0));
    }
    else
        hr = HR_S_NOOP;

exit:
    ReleaseObj(pBody);
    ReleaseObj(pSMime);
    ReleaseObj(pTree);
    return hr;
}

HRESULT _ValidateAndTrust(HWND hwndOwner, IMimeSecurity *pSMime, IMimeMessage *pMsg)
{
    ULONG               ulTrust = ATHSEC_NOTRUSTUNKNOWN;
    ULONG               ulValidity = 0;
    IMimeBody          *pBody;
    HRESULT             hr;
    HBODY               hBody = NULL;

    Assert(pSMime && pMsg);

    // Cast the bones and decide if we trust this thing

    // Athena only supports root-body S/MIME
    if(FAILED(hr = HrGetInnerLayer(pMsg, &hBody)))
        return TrapError(hr);

    if (SUCCEEDED(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody)))
    {
        PROPVARIANT         var;
        PCCERT_CONTEXT      pcSigningCert;

#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            Assert(VT_UI8 == var.vt);

            pcSigningCert = (PCCERT_CONTEXT)(var.pulVal);
#else // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            Assert(VT_UI4 == var.vt);

            pcSigningCert = (PCCERT_CONTEXT)var.ulVal;
#endif // _WIN64

            if (pcSigningCert)
            {
                DWORD dwComputedTrust;
                //N7 trust mask.  what if issuer is expired.  can't lose this like I do.
                const DWORD dwIgnore =
                    // CERT_VALIDITY_BEFORE_START |
                    CERT_VALIDITY_AFTER_END    |
                    CERT_VALIDITY_NO_CRL_FOUND;

                dwComputedTrust = DwGenerateTrustedChain(hwndOwner, pMsg, pcSigningCert,
                    dwIgnore, FALSE, NULL, NULL);

                // Trust
                ulTrust = ATHSEC_TRUSTED;
                if (dwComputedTrust & CERT_VALIDITY_NO_TRUST_DATA)
                {
                    ulTrust |= ATHSEC_NOTRUSTUNKNOWN;
                    dwComputedTrust &= ~CERT_VALIDITY_NO_TRUST_DATA;
                }
                if (dwComputedTrust & CERT_VALIDITY_MASK_TRUST)
                {
                    ulTrust |= ATHSEC_NOTRUSTNOTTRUSTED;
                    dwComputedTrust &= ~CERT_VALIDITY_MASK_TRUST;
                }

                // Validity
                if (dwComputedTrust & CERT_VALIDITY_CERTIFICATE_REVOKED)
                {
                    ulValidity |= ATHSEC_NOTRUSTREVOKED;
                    dwComputedTrust &= ~CERT_VALIDITY_CERTIFICATE_REVOKED;
                }
                if (dwComputedTrust & CERT_VALIDITY_NO_CRL_FOUND)
                {
                    ulValidity |= ATHSEC_NOTRUSTREVFAIL;
                    dwComputedTrust &= ~CERT_VALIDITY_NO_CRL_FOUND;
                }

                if (dwComputedTrust & CERT_VALIDITY_MASK_VALIDITY)
                {
                    ulValidity |= ATHSEC_NOTRUSTOTHER;
                    dwComputedTrust &= ~CERT_VALIDITY_MASK_VALIDITY;
                }

                Assert(dwComputedTrust == ATHSEC_TRUSTED);  // Should have removed it all by now

                //N this could become a helper fn call as part of the trust
                //N provider.  Currently trust helpers are nyi.
                if (0 != _CompareCertAndSenderEmail(pMsg, pSMime, pcSigningCert))
                    ulValidity |= ATHSEC_NOTRUSTWRONGADDR;
                CertFreeCertificateContext(pcSigningCert);
            }
            else
                // if we don't have a cert then the signing is already
                // in trouble.  trust has no meaning
                Assert(!ulValidity);
        }

        Assert(!(ulTrust & ulValidity));  // no overlap
        hr = (ulTrust | ulValidity) ? S_FALSE : S_OK;
        var.vt = VT_UI4;
        var.ulVal = ulTrust|ulValidity;
        pBody->SetOption(OID_SECURITY_USER_VALIDITY, &var);
        pBody->Release();
    }

    DOUTL(DOUTL_CRYPT, "SMIME: _ValidateAndTrust returns trust:0x%lX, valid:0x%lX", ulTrust, ulValidity);
    return TrapError(hr);
}

/***************************************************************************

    Name      : GetSenderEmail

    Purpose   : Get the email address of the sender of the message

    Parameters: pMsg = IMimeMsg object

    Returns   : MemAlloc'ed string.  Caller must MemFree it.

***************************************************************************/
LPTSTR GetSenderEmail(LPMIMEMESSAGE pMsg)
{
    ADDRESSLIST             rAdrList = {0};
    LPTSTR                  szReturn = NULL;

    Assert(pMsg);

    if (SUCCEEDED(pMsg->GetAddressTypes(IAT_FROM, IAP_EMAIL, &rAdrList)))
    {
        if (rAdrList.cAdrs > 0)
        {
            Assert(rAdrList.prgAdr[0].pszEmail);
            if (MemAlloc((LPVOID *)&szReturn, lstrlen(rAdrList.prgAdr[0].pszEmail) + 1))
                lstrcpy(szReturn, rAdrList.prgAdr[0].pszEmail);
        }
    }

    g_pMoleAlloc->FreeAddressList(&rAdrList);
    return(szReturn);
}


/*  _CompareCertAndSenderEmail:
**
**  Returns:
**      0 if they are equal (case insensitive)
**      //N SECURITY: what about whitespace in the email.  mimeOLE strips it?
**      nonzero if unequal
*/
int _CompareCertAndSenderEmail(LPMIMEMESSAGE pMsg, IMimeSecurity *pSMime, PCX509CERT pCert)
{
    int                     ret = 1;
    PROPVARIANT             var;
    HRESULT                 hr;
    LPTSTR                  szSenderEmail = NULL;

    Assert(pMsg && pCert && pSMime);

    szSenderEmail = GetSenderEmail(pMsg);

    if (szSenderEmail && SUCCEEDED(hr = pSMime->GetCertData(pCert, CDID_EMAIL, &var)))
    {
        Assert(VT_LPSTR == var.vt);
        ret = lstrcmpi(szSenderEmail, var.pszVal);
        MemFree(var.pszVal);
    }

    SafeMemFree(szSenderEmail);
    return ret;
}


/***************************************************************************

    Name      : HrInitSecurityOptions

    Purpose   : Set some basic security options on the message.

    Parameters: pMsg = IMimeMsg object
                ulSecurityType = SMIME security type:
                                    MST_THIS_SIGN
                                    MST_THIS_ENCRYPT
                                    MST_CLASS_SMIME_V1
                                    MST_THIS_BLOBSIGN

    Returns   : HRESULT

    Comment   : Sets the security type option on all messages
                Sets hash algorithm only if we are signing.

***************************************************************************/
HRESULT HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType)
{
    HRESULT         hr;
    IMimeBody      *pBody = NULL;
    PROPVARIANT     var;

    hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void**)&pBody);
    if (FAILED(hr))
        goto exit;

    var.vt = VT_UI4;
    var.ulVal = ulSecurityType;
    hr = pBody->SetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))
        goto exit;

    if (ulSecurityType & MST_SIGN_MASK)
    {
        // Hack!  This is the ALOGORITHM ID for SHA1, our only supported signing algorithm
        BYTE rgbHash[] = {0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A};
        ULONG cbHash = sizeof(rgbHash);

        var.vt = VT_BLOB;
        var.blob.cbSize = cbHash;
        var.blob.pBlobData = rgbHash;
        hr = pBody->SetOption(OID_SECURITY_ALG_HASH, &var);
    }

    if(ulSecurityType == MST_THIS_SIGN)
    {
        var.vt = VT_BOOL;
        var.boolVal = TRUE;
        hr = pMsg->SetOption(OID_SAVEBODY_KEEPBOUNDARY, &var);
    }

exit:
    ReleaseObj(pBody);
    return(hr);
}


// Get inner layer for using with multisign messages
HRESULT HrGetInnerLayer(LPMIMEMESSAGE pMsg, HBODY *phBody)
{
    HRESULT     hr = S_OK;
    HBODY       hBody = NULL;
    BOOL        fWrapped = FALSE;
    IMimeBody  *pBody = NULL;

    Assert(pMsg);
    hr = pMsg->GetBody(IBL_ROOT, NULL, &hBody);
    if(FAILED(hr))
        return(hr);

    do
    {
        if (SUCCEEDED(hr = pMsg->BindToObject(hBody, IID_IMimeBody, (void **)&pBody)))
        {
            fWrapped = (pBody->IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK);

            if(phBody)
                *phBody = hBody;

            SafeRelease(pBody);

            if (fWrapped)
            {
                hr = pMsg->GetBody(IBL_FIRST, hBody, &hBody);
                Assert(SUCCEEDED(hr));
                if (FAILED(hr))
                    break;
            }
        }
        else
            break;

    }while(fWrapped && hBody);

    return hr;
}


HRESULT HrGetSecurityState(LPMIMEMESSAGE pMsg, SECSTATE *pSecState, HBODY *phBody)
{
    HRESULT     hr = S_OK;
    IMimeBody  *pBody = NULL;
    PROPVARIANT var;
    BOOL        fWrapped = FALSE;


    pSecState->szSignerEmail = NULL;
    pSecState->szSenderEmail = NULL;
    HBODY   hBody;

    hr = pMsg->GetBody(IBL_ROOT, NULL, &hBody);
    if(FAILED(hr))
        return(hr);

    do
    {
        if (SUCCEEDED(hr = pMsg->BindToObject(hBody, IID_IMimeBody, (void **)&pBody)))
        {
            SafeMemFree(pSecState->szSignerEmail);
            SafeMemFree(pSecState->szSenderEmail);

            pSecState->type = SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var))
                ? var.ulVal
                : MST_NONE;

            pSecState->szSenderEmail = GetSenderEmail(pMsg);

            if (MST_NONE != pSecState->type)
            {
                pSecState->user_validity = SUCCEEDED(pBody->GetOption(OID_SECURITY_USER_VALIDITY, &var))
                    ? var.ulVal
                    : 0;

                pSecState->ro_msg_validity = SUCCEEDED(pBody->GetOption(OID_SECURITY_RO_MSG_VALIDITY, &var))
                    ? var.ulVal
                    : MSV_OK;

#ifdef _WIN64
                if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
                {
                    pSecState->fHaveCert = (NULL != (PCCERT_CONTEXT)(var.pulVal));

                    if (pSecState->fHaveCert)
                    {
                        pSecState->szSignerEmail = SzGetCertificateEmailAddress((PCCERT_CONTEXT)(var.pulVal));
                        CertFreeCertificateContext((PCCERT_CONTEXT)(var.pulVal));
                    }
                }
#else   //!_WIN64
                if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
                {
                    pSecState->fHaveCert = (NULL != ((PCCERT_CONTEXT)var.ulVal));

                    if (pSecState->fHaveCert)
                    {
                        pSecState->szSignerEmail = SzGetCertificateEmailAddress((PCCERT_CONTEXT)var.ulVal);
                        CertFreeCertificateContext((PCCERT_CONTEXT)var.ulVal);
                    }
                }
#endif  // _WIN64
                else
                    pSecState->fHaveCert = FALSE;
            }
            fWrapped = (pBody->IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK);

            if(phBody)
                *phBody = hBody;

            SafeRelease(pBody);

            if (fWrapped)
            {
                hr = pMsg->GetBody(IBL_FIRST, hBody, &hBody);
                Assert(SUCCEEDED(hr));
                if (FAILED(hr))
                    break;
            }

        }
        else
            break;

        if(IsSigned(pSecState->type) && !IsSignTrusted(pSecState))
            break;

        if(IsEncrypted(pSecState->type) && !IsEncryptionOK(pSecState))
            break;

    }while(fWrapped && hBody);

    return hr;
}


/***************************************************************************

    Name      : CheckAndFixMissingCert

    Purpose   : Check to see if we can locate the certs for the missing
                entries.

    Parameters: hwnd = window handle
                pAdrTable = Address Table object
                pAccount = sending account

    Returns   : TRUE if we able to find and fix at least one missing cert.
                FALSE if there was nothing we could do.

    Comment   :

***************************************************************************/
BOOL CheckAndFixMissingMeCert(HWND hwnd, IMimeAddressTable *pAdrTable, IImnAccount *pAccount)
{
    IMimeEnumAddressTypes   *pEnum = NULL;
    ADDRESSPROPS            apAddress = {0};
    ADDRESSPROPS            apModify = {0};
    TCHAR                   szAcctEmailAddress[CCHMAX_EMAIL_ADDRESS + 1] = "";
    HRESULT                 hr;
    THUMBBLOB               tbSender = {0, 0};
    BOOL                    fRet = FALSE;
    PCCERT_CONTEXT          pcCert = NULL;

    Assert(pAdrTable && pAccount);

    pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szAcctEmailAddress, sizeof(szAcctEmailAddress));

    if (FAILED(pAdrTable->EnumTypes(IAT_TO | IAT_CC | IAT_BCC, IAP_HANDLE | IAP_EMAIL | IAP_ADRTYPE | IAP_CERTSTATE | IAP_FRIENDLY, &pEnum)))
        return(FALSE);

    while (S_OK == pEnum->Next(1, &apAddress, NULL))
    {
        if (CERTIFICATE_NOT_PRESENT == apAddress.certstate || CERTIFICATE_NOPRINT == apAddress.certstate)
        {
            // Don't have this recipient's cert
            // Is this recipient ME?
            if (! lstrcmpi(apAddress.pszEmail, szAcctEmailAddress))
            {
                // Yes, this is me.  Get my cert and put it in here.
                // Do I have a cert in the account?
                hr = pAccount->GetProp(AP_SMTP_CERTIFICATE, NULL, &apModify.tbEncryption.cbSize);
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(HrAlloc((void**)&apModify.tbEncryption.pBlobData, apModify.tbEncryption.cbSize)))
                        pAccount->GetProp(AP_SMTP_CERTIFICATE, apModify.tbEncryption.pBlobData, &apModify.tbEncryption.cbSize);
                }
                else
                {
                    // No, go get one
                    hr = _HrFindMyCertForAccount(hwnd, &pcCert, pAccount, FALSE);
                    if (SUCCEEDED(hr) && pcCert)
                    {
                        // Get the thumbprint
                        apModify.tbEncryption.pBlobData = (BYTE *)PVGetCertificateParam(pcCert, CERT_HASH_PROP_ID, &apModify.tbEncryption.cbSize);
                        CertFreeCertificateContext(pcCert);
                        pcCert = NULL;
                    }
                }

                // OK, do I finally have a cert?
                if (apModify.tbEncryption.pBlobData && apModify.tbEncryption.cbSize)
                {
                    apModify.dwProps = IAP_ENCRYPTION_PRINT;
                    if (SUCCEEDED(hr = pAdrTable->SetProps(apAddress.hAddress, &apModify)))
                        fRet = TRUE;
                }
                SafeMemFree(apModify.tbEncryption.pBlobData);
                apModify.tbEncryption.cbSize = 0;
            }
        }
        g_pMoleAlloc->FreeAddressProps(&apAddress);
    }

    ReleaseObj(pEnum);
    return(fRet);
}

HRESULT SendSecureMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail, IHeaderSite *pHeaderSite)
{
    HRESULT         hr;
    BOOL            fNoErrorUI;
    BOOL            fContLoop;
    BOOL            fHaveSender;
    BOOL            fAllowTryAgain;
    PROPVARIANT     var;
    BOOL            fDontEncryptForSelf = !!DwGetOption(OPT_NO_SELF_ENCRYPT);
    HWND            hwndOwner = 0;
    IImnAccount    *pAccount = NULL;
    CERTERRPARAM   CertErrParam = {0};

    Assert(IsSecure(pMsg));

    pStoreCB->GetParentWindow(0, &hwndOwner);
    AssertSz(hwndOwner, "How did we not get an hwnd???");

    var.vt = VT_LPSTR;
    hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
    if (FAILED(hr))
        return hr;

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAccount);

    SafeMemFree(var.pszVal);
    if (FAILED(hr))
        return hr;
    if (FAILED(hr = _HrPrepSecureMsgForSending(hwndOwner, pMsg, pAccount, &fHaveSender, &fDontEncryptForSelf, pHeaderSite)))
    {
        SafeRelease(pAccount);
        return hr;
    }

    var.ulVal = 0;
    hr = pMsg->GetOption(OID_SECURITY_ENCODE_FLAGS, &var);

    if (fHaveSender)
    {
        var.ulVal |= SEF_SENDERSCERTPROVIDED;

        hr = pMsg->SetOption(OID_SECURITY_ENCODE_FLAGS, &var);
    }

    fNoErrorUI = FALSE;
    fContLoop = TRUE;
    fAllowTryAgain = TRUE;
    do
    {
        hr = SendMailToOutBox(pStoreCB, pMsg, fSendImmediate, fNoUI, fMail);
        if (SUCCEEDED(hr))
        {
            fContLoop = FALSE;
            break;
        }
        else if ((MIME_E_SECURITY_CERTERROR == hr) || (MIME_E_SECURITY_NOCERT == hr))
        {
            IMimeAddressTable *pAdrTable;

            if (SUCCEEDED(hr = pMsg->GetAddressTable(&pAdrTable)))
            {
                // First off, are we sending to ourselves?  If so, find our cert, make sure
                // there's a cert associated with the account and then add it to the address
                // table.
                if (fAllowTryAgain && CheckAndFixMissingMeCert(hwndOwner,
                    pAdrTable,
                    pAccount))
                {
                    // Try again, we found at least one missing cert.
                    fContLoop = TRUE;
                }
                else
                {
                    // Didn't get them all, tell the user.
                    CertErrParam.pAdrTable = pAdrTable;
                    CertErrParam.fForceEncryption = FALSE;
                    if (pHeaderSite != NULL)
                    {
                        if(pHeaderSite->IsForceEncryption() == S_OK)
                            CertErrParam.fForceEncryption = TRUE;
                    }


                    if(IDOK == DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSecCerificateErr),
                        hwndOwner, CertErrorDlgProc, (LPARAM)(&CertErrParam)))
                    {
                        ULONG ulSecurityType = MST_CLASS_SMIME_V1;

                        if (IsSigned(pMsg, TRUE))
                            ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
                        else
                            ulSecurityType &= ~((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);


                        ulSecurityType &= ~MST_THIS_ENCRYPT;
                        hr = HrInitSecurityOptions(pMsg, ulSecurityType);
                        fContLoop = TRUE;
                    }
                    else
                        fContLoop = FALSE; //N work item: allow users to send anyway

                   fNoErrorUI = TRUE;
                }

                pAdrTable->Release();
                fAllowTryAgain = FALSE;
            }
        }
        else if (MIME_E_SECURITY_ENCRYPTNOSENDERCERT == hr)
        {
            // We may have situations in here Signed & Crypted, but no certificate (bug 60056)
            if (IsSigned(pMsg, TRUE))
            {

                AthMessageBoxW(hwndOwner, MAKEINTRESOURCEW(idsSecurityWarning), MAKEINTRESOURCEW(idsErrSecurityNoSigningCert), NULL, MB_OK | MB_ICONEXCLAMATION);
                fNoErrorUI = TRUE;
                fContLoop = FALSE;
            }
            // find out if user doesn't care
            else if (fDontEncryptForSelf || (IDYES == AthMessageBoxW(hwndOwner,
                MAKEINTRESOURCEW(idsSecurityWarning),
                MAKEINTRESOURCEW(idsWrnSecurityNoCertForEnc), NULL,
                MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING|MB_SETFOREGROUND)))
            {
                var.ulVal |= SEF_ENCRYPTWITHNOSENDERCERT;

                // abort on failure to avoid extra looping
                if (FAILED(hr = pMsg->SetOption(OID_SECURITY_ENCODE_FLAGS, &var)))
                    fContLoop = FALSE;
            }
            else
            {
                fNoErrorUI = TRUE;
                fContLoop = FALSE;
            }
        }
        else if (CRYPT_E_NO_KEY_PROPERTY == hr)
        {
            // no choice for this one
            AthMessageBoxW(hwndOwner,
                MAKEINTRESOURCEW(idsSecurityWarning),
                MAKEINTRESOURCEW(idsErrSecurityNoPrivateKey), NULL,
                MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
            fContLoop = FALSE;
            fNoErrorUI = TRUE;
        }
        else if (E_ACCESSDENIED == hr)
        {
            // no choice for this one
            AthMessageBoxW(hwndOwner,
                MAKEINTRESOURCEW(idsSecurityWarning),
                MAKEINTRESOURCEW(idsErrSecurityAccessDenied), NULL,
                MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
            fContLoop = FALSE;
            fNoErrorUI = TRUE;
        }
        else
            // unknown error
            fContLoop = FALSE;
    } while (fContLoop);

    if (fNoErrorUI)
        // return the recognized error code
        hr = HR_E_ATHSEC_FAILED;
    ReleaseObj(pAccount);

    return hr;
}


HRESULT HrBuildAndVerifyCerts(HWND hwnd, IMimeMessageTree * pTree, DWORD * pcCert,
                      PCX509CERT ** prgpccert, PCCERT_CONTEXT pccertSender, IImnAccount *pAccount, IHeaderSite *pHeaderSite)
{
    ADDRESSPROPS                apEntry;
    ADDRESSPROPS                apModify;
    DWORD                       cCerts;
    DWORD                       cPrints = 0;
    DWORD                       dw;
    HRESULT                     hr;
    DWORD                       i;
    IMimeAddressTable *         pAdrTbl = NULL;
    IMimeEnumAddressTypes *     pAdrEnum = NULL;
    HCERTSTORE                  rgCertStore[2];
    PCX509CERT *                rgpccert = NULL;
    CERTERRPARAM                CertErrParam = {0};

    if (SUCCEEDED(hr = pTree->BindToObject(HBODY_ROOT, IID_IMimeAddressTable,
                                           (void**)&pAdrTbl))) {
        hr = pAdrTbl->EnumTypes(IAT_TO | IAT_CC | IAT_BCC | IAT_SENDER,
                                IAP_HANDLE | IAP_ADRTYPE | IAP_SIGNING_PRINT |
                                IAP_ENCRYPTION_PRINT | IAP_CERTSTATE, &pAdrEnum);
    }


    pAdrEnum->Count(&cCerts);
    if (cCerts == 0) {
        return MIME_S_SECURITY_NOOP;
    }

    if (!MemAlloc((LPVOID *) &rgpccert, sizeof(PCX509CERT)*(cCerts+1))) {
        return E_OUTOFMEMORY;
    }
    memset(rgpccert, 0, sizeof(CERTSTATE)*(cCerts+1));

    rgCertStore[1] = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
      X509_ASN_ENCODING, NULL,
      CERT_STORE_READONLY_FLAG|CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
    if (rgCertStore[1] == NULL) {
        hr = MIME_S_SECURITY_ERROROCCURED;
        goto Exit;
    }
    rgCertStore[0] = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
          X509_ASN_ENCODING, NULL,
          CERT_STORE_READONLY_FLAG|CERT_SYSTEM_STORE_CURRENT_USER, c_szWABCertStore);
    if (rgCertStore[0] == NULL) {
        hr = MIME_S_SECURITY_ERROROCCURED;
        goto Exit;
    }

    pAdrEnum->Reset();
    apModify.dwProps = IAP_CERTSTATE;

    while (pAdrEnum->Next(1, &apEntry, NULL) == S_OK) {
        Assert((apEntry.tbEncryption.pBlobData && apEntry.tbEncryption.cbSize) ||
               (!apEntry.tbEncryption.pBlobData && !apEntry.tbEncryption.cbSize));


        if (apEntry.tbEncryption.cbSize) {
            CRYPT_DIGEST_BLOB           blob;

            // Make an assumption
            apModify.certstate = CERTIFICATE_INVALID;

            // we need to null out the thumbprint flag so print doesn't get
            // freed below
            blob.pbData = apEntry.tbEncryption.pBlobData;
            blob.cbData = apEntry.tbEncryption.cbSize;
            for (i=0; i<2; i++) {
                rgpccert[cPrints] = CertFindCertificateInStore(rgCertStore[i],
                                                                X509_ASN_ENCODING, 0,
                                                                CERT_FIND_HASH,
                                                                (LPVOID) &blob, NULL);
                if (rgpccert[cPrints] == NULL)
                    continue;

                HrGetCertKeyUsage(rgpccert[cPrints], &dw);
                if (!(dw & CERT_KEY_ENCIPHERMENT_KEY_USAGE)) {
                    CertFreeCertificateContext(rgpccert[cPrints]);
                    rgpccert[cPrints] = NULL;
                    continue;
                }


                dw = DwGenerateTrustedChain(hwnd, NULL, rgpccert[cPrints],
                                            CERT_VALIDITY_NO_CRL_FOUND, TRUE, NULL, NULL);
                if (dw & CERT_VALIDITY_NO_TRUST_DATA) {
                    apModify.certstate = CERTIFICATE_NOT_TRUSTED;
                }
                else if (dw & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
                    apModify.certstate = CERTIFICATE_MISSING_ISSUER;
                }
                else if (dw & (CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END)) {
                    apModify.certstate = CERTIFICATE_EXPIRED;
                }
                else if (dw & CERT_VALIDITY_CERTIFICATE_REVOKED) {
                    apModify.certstate = CERTIFICATE_CRL_LISTED;
                }
                else if (dw & CERT_VALIDITY_MASK_TRUST) {
                    apModify.certstate = CERTIFICATE_NOT_TRUSTED;
                }
                else if (dw & CERT_VALIDITY_MASK_VALIDITY) {
                    apModify.certstate = CERTIFICATE_INVALID;
                }

                // Check label
                hr = S_OK;
                if(pHeaderSite != NULL)
                {
                    PSMIME_SECURITY_LABEL plabel = NULL;

                    hr = pHeaderSite->GetLabelFromNote(&plabel);
                    if(plabel)
                    {
                        hr  = HrValidateLabelRecipCert(plabel, hwnd, rgpccert[cPrints]);
                        if(FAILED(hr))
                            apModify.certstate = CERTIFICATE_INVALID;
                    }
                    else
                        hr = S_OK;  // ignore any error

                }

                if (dw || FAILED(hr))
                {
                    CertFreeCertificateContext(rgpccert[cPrints]);
                    rgpccert[cPrints] = NULL;
                    continue;
                }

                apModify.certstate = CERTIFICATE_OK;
                cPrints += 1;
                break;
            }
        }
        else {
            apModify.certstate = CERTIFICATE_NOT_PRESENT;
        }

        SideAssert(SUCCEEDED(pAdrTbl->SetProps(apEntry.hAddress, &apModify)));
        g_pMoleAlloc->FreeAddressProps(&apEntry);
    }

    // First off, are we sending to ourselves?  If so, find our cert, make sure
    // there's a cert associated with the account and then add it to the address
    // table.
    if ((pccertSender != NULL) && CheckAndFixMissingMeCert(hwnd, pAdrTbl, pAccount))
    {
        rgpccert[cPrints] = CertDuplicateCertificateContext(pccertSender);
        cPrints += 1;

        if (cCerts != cPrints)
            goto NoCert;
    }

    else if (cCerts != cPrints) {
NoCert:
        // Didn't get them all, tell the user.
        CertErrParam.pAdrTable = pAdrTbl;
        CertErrParam.fForceEncryption = FALSE;
        if (pHeaderSite != NULL)
        {
            if(pHeaderSite->IsForceEncryption() == S_OK)
                CertErrParam.fForceEncryption = TRUE;
        }

        if(IDOK ==DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSecCerificateErr),
                       hwnd, CertErrorDlgProc, (LPARAM)(&CertErrParam)))
            hr = S_FALSE;
        else
            hr = HR_E_ATHSEC_FAILED;
        goto Exit;
    }
    else if(pccertSender != NULL) // include sender if we send encrypted message
    {
        rgpccert[cPrints] = CertDuplicateCertificateContext(pccertSender);
        cPrints += 1;
    }

    *prgpccert = rgpccert;
    *pcCert = cPrints;

Exit:
    if (FAILED(hr)) {
        for (i=0; i<cPrints; i++) {
            if (rgpccert[i] != NULL) {
                CertFreeCertificateContext(rgpccert[i]);
            }
        }
    }

    CertCloseStore(rgCertStore[1], 0);
    CertCloseStore(rgCertStore[0], 0);

    if(pAdrTbl)
        ReleaseObj(pAdrTbl);
    ReleaseObj(pAdrEnum);
    return hr;
}

// This function parse error for signing certificate and do autoassociation in case if we have more signing certificate
//
HRESULT ProceedSignCertError(HWND hwnd, IImnAccount *pCertAccount, DWORD dwTrust)
{
    ERRIDS ErrIds = {0, 0};
    int cCert = 0;
    HRESULT hr = S_OK;

    if(!dwTrust)
        return(S_OK);

    // we must here parse the error

    // Sure, the user might get multiple errors from this,
    // but it is so rare I'll let this slide.
    if (CERT_VALIDITY_BEFORE_START & dwTrust ||
        CERT_VALIDITY_AFTER_END & dwTrust)
    {
        // do the fatal one first
        ErrIds.idsText1 = idsErrSecuritySendExpiredSign;
    }
    else if(CERT_VALIDITY_OTHER_EXTENSION_FAILURE & dwTrust)
    {
        ErrIds.idsText1 = idsErrSecurityExtFailure;
    }
    else if(CERT_VALIDITY_CERTIFICATE_REVOKED  & dwTrust)
    {
        ErrIds.idsText1 = idsErrSecurityCertRevoked;
    }
    else
    {
        ErrIds.idsText1 = idsErrSecuritySendTrust;
    }

    // Check # of available signed certificates for autoassociation.
    cCert = GetNumMyCertForAccount(hwnd, pCertAccount, FALSE, NULL, NULL);
    if(cCert < 1)
        ErrIds.idsText2 = idsErrSignCertText20;

    else if(cCert == 1)
        ErrIds.idsText2 = idsErrSignCertText21;

    else
        ErrIds.idsText2 = idsErrSignCertText22;

    INT uiRes = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddWarnSecuritySigningCert),
                        hwnd, CertWarnDlgProc, ((LPARAM)(&ErrIds)));

    if(uiRes == IDCANCEL)           // cancel, return to note
        hr = HR_E_ATHSEC_FAILED;

    else if(uiRes == IDOK)
    {
        if(cCert < 1)               // Go to web and return to note
        {
            GetDigitalIDs(pCertAccount);
            hr = HR_E_ATHSEC_FAILED;
        }
        else                        // Do autoassociation
            hr = HR_E_ATHSEC_USENEWSIGN;
    }
    else                            // Don't sign
        hr = HR_E_ATHSEC_DONTSIGN;

    return(hr);
}

// This function parse error for encryption certificate and uf user like to do it then remove it from account
//
HRESULT ProceedEncCertError(HWND hwnd, IImnAccount *pCertAccount, DWORD dwTrust)
{
    WORD ids = 0;
    HRESULT hr = S_OK;

    if(!dwTrust)
        return(S_OK);

    // we must here parse the error

    // Sure, the user might get multiple errors from this,
    // but it is so rare I'll let this slide.
    if (CERT_VALIDITY_BEFORE_START & dwTrust ||
        CERT_VALIDITY_AFTER_END & dwTrust)
    {
        // do the fatal one first
        ids = idsErrSecuritySendExpSignEnc;
    }
    else if(CERT_VALIDITY_OTHER_EXTENSION_FAILURE & dwTrust)
    {
        ids = idsErrSecurityExtFailureEnc;
    }
    else if(CERT_VALIDITY_CERTIFICATE_REVOKED  & dwTrust)
    {
        ids = idsErrSecurityCertRevokedEnc;
    }
    else
    {
        ids = idsErrSecuritySendTrustEnc;
    }

    if(AthMessageBoxW(hwnd,
        MAKEINTRESOURCEW(idsSecurityWarning),
        MAKEINTRESOURCEW(ids), MAKEINTRESOURCEW(idsErrEncCertCommon),
        MB_YESNO| MB_ICONWARNING| MB_SETFOREGROUND) != IDYES)
    {
        // Cancel send message in this case
        hr = HR_E_ATHSEC_FAILED;
    }
    else
    {
        // remove wrong certificate from property
        pCertAccount->SetProp(AP_SMTP_ENCRYPT_CERT, NULL, 0);

        // send message anyway
        hr = HR_E_ATHSEC_SAMEASSIGNED;

    }
    return(hr);
}


// Get certificate from Account, check it, display erro, set cheain to msg cert store
HRESULT HrPrepSignCert(HWND hwnd, BOOL fEncryptCert, BOOL fIsSigned, IImnAccount *pCertAccount, IMimeBody *pBody, PCX509CERT * ppCert,
                       BOOL *fDontEncryptForSelf, BOOL *fEncryptForMe, PCX509CERT pCertSig)
{
    // need to check also encryption certificate and send it
    THUMBBLOB       tbCert = {0, 0};
    HRESULT         hr = S_OK;
    HCERTSTORE      hMyCertStore = NULL;
    PROPVARIANT     var;
    DWORD           dw = 0;

    if (SUCCEEDED(hr = pCertAccount->GetProp((fEncryptCert ? AP_SMTP_ENCRYPT_CERT : AP_SMTP_CERTIFICATE), NULL, &tbCert.cbSize)))
    {
        // we have encryption certificate
        hr = HrAlloc((void**)&tbCert.pBlobData, tbCert.cbSize);
        if (SUCCEEDED(hr))
        {
            hr = pCertAccount->GetProp((fEncryptCert ? AP_SMTP_ENCRYPT_CERT : AP_SMTP_CERTIFICATE), tbCert.pBlobData, &tbCert.cbSize);
            if (SUCCEEDED(hr))
            {
                hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                    NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
                if (hMyCertStore)
                {
                    //
                    // Check the chain
                    //
                    X509CERTRESULT  certResult;
                    CERTSTATE       cs;
                    PCX509CERT      pCert = NULL;

                    certResult.cEntries = 1;
                    certResult.rgcs = &cs;
                    certResult.rgpCert = &pCert;

                    hr = MimeOleGetCertsFromThumbprints(&tbCert, &certResult, &hMyCertStore, 1);
                    if (S_OK == hr)
                    {
                        DWORD           dwTrust;
                        PCCERT_CONTEXT *rgCertChain = NULL;
                        DWORD           cCertChain = 0;
                        const DWORD     dwIgnore = CERT_VALIDITY_NO_CRL_FOUND;

                        Assert(1 == certResult.cEntries);

                        // If we asking about encryption certificate we need to check that it's not the same
                        // as signrd
                        if(fEncryptCert && fIsSigned)
                        {
                            if(CertCompareCertificate(X509_ASN_ENCODING, pCert->pCertInfo, pCertSig->pCertInfo))
                            {
                                hr = HR_E_ATHSEC_SAMEASSIGNED;
                                goto Exit;
                            }
                        }
                        // As to CRLs, if we'll ever have one!
                        dwTrust = DwGenerateTrustedChain(hwnd, NULL, pCert,
                            dwIgnore, TRUE, &cCertChain, &rgCertChain);

                        if (dwTrust)
                        {
                            if (fIsSigned)
                            {
                                if(fEncryptCert)
                                {
                                    if(pCertSig && SUCCEEDED(HrGetCertKeyUsage(pCertSig, &dw)))
                                    {
                                        if ((dw & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                                                        CERT_KEY_AGREEMENT_KEY_USAGE)))
                                        {
                                            hr = HR_E_ATHSEC_SAMEASSIGNED;
                                            goto Exit;
                                        }
                                    }
                                    else
                                    {
                                        hr = HR_E_ATHSEC_SAMEASSIGNED;
                                        goto Exit;
                                    }

                                    hr = ProceedEncCertError(hwnd, pCertAccount, dwTrust);
                                }
                                else
                                    hr = ProceedSignCertError(hwnd, pCertAccount, dwTrust);

                            }
                            else
                            { // Encryption certificate
                                // we must here parse the error
                                WORD ids;
                                BOOL fFatal = TRUE;

                                // Sure, the user might get multiple errors from this,
                                // but it is so rare I'll let this slide.
                                if (CERT_VALIDITY_BEFORE_START & dwTrust ||
                                    CERT_VALIDITY_AFTER_END & dwTrust)
                                {
                                    // Assert(IsEncrypted(pMsg, TRUE));
                                    ids = idsErrSecuritySendExpiredEnc;
                                    fFatal = FALSE;
                                }
                                else if(CERT_VALIDITY_OTHER_EXTENSION_FAILURE & dwTrust)
                                {
                                    ids = idsErrSecurityExtFailure;
                                    fFatal = TRUE;
                                }
                                else if(CERT_VALIDITY_CERTIFICATE_REVOKED  & dwTrust)
                                {
                                    ids = (fEncryptCert ? idsErrSecurityCertRevokedEnc : idsErrSecurityCertRevoked);
                                    fFatal = TRUE;
                                }
                                else
                                {
                                    ids = idsErrSecuritySendTrustEnc;
                                    fFatal = FALSE;
                                }
                                if (fFatal)
                                {
                                    AthMessageBoxW(hwnd,
                                        MAKEINTRESOURCEW(idsSecurityWarning),
                                        MAKEINTRESOURCEW(ids), NULL,
                                        MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
                                    hr = HR_E_ATHSEC_FAILED;
                                }
                                else
                                {
                                    if (IDYES != AthMessageBoxW(hwnd,
                                        MAKEINTRESOURCEW(idsSecurityWarning),
                                        MAKEINTRESOURCEW(ids), MAKEINTRESOURCEW(idsWrnSecEncryption),
                                        MB_YESNO|MB_ICONWARNING|MB_SETFOREGROUND))
                                    {
                                        // This error code has the special meaning of
                                        // "don't show any more UI, the user has been
                                        // beaten enough"
                                        hr = HR_E_ATHSEC_FAILED;
                                    }
                                    else
                                    {
                                        if(!fEncryptCert)
                                        {
                                            // Since the user's cert is expired, we won't
                                            // let it be used to encrypt
                                            *fEncryptForMe = FALSE;
                                            *fDontEncryptForSelf = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                        else  // no errors
                        {
                            // We need to add encryption certificate to message cert store
#ifdef _WIN64               // (YST) I believe Win64 part will be not work...
                            if (DwGetOption(OPT_MAIL_INCLUDECERT))
                            {
                                var.vt = VT_VECTOR | VT_UI8;
                                if (0 != cCertChain)
                                {
                                    var.cauh.cElems = cCertChain;
                                    var.cauh.pElems = (ULARGE_INTEGER *)rgCertChain;
                                }
                                else
                                {
                                    var.cauh.cElems = 1;
                                    var.cauh.pElems = (ULARGE_INTEGER *)&pCert;
                                }
                                hr = pBody->SetOption(OID_SECURITY_RG_CERT_BAG_64, &var);
                                Assert((cCertChain > 0) || dwTrust);
                            }
#else  //_WIN64
                            if (DwGetOption(OPT_MAIL_INCLUDECERT))
                            {
                                var.vt = VT_VECTOR | VT_UI4;
                                if (0 != cCertChain)
                                {
                                    var.caul.cElems = cCertChain;
                                    var.caul.pElems = (ULONG *)rgCertChain;
                                }
                                else
                                {
                                    var.caul.cElems = 1;
                                    var.caul.pElems = (ULONG *)&pCert;
                                }
                                hr = pBody->SetOption(OID_SECURITY_2KEY_CERT_BAG, &var);
                                Assert((cCertChain > 0) || dwTrust);
                            }
#endif // _WIN64
                        }
Exit:
                        *ppCert = pCert;
                        // Still might have a chain on error, so run the
                        // freeing code outside the result test

                        if (rgCertChain)
                        {
                            for (cCertChain--; int(cCertChain)>=0; cCertChain--)
                                CertFreeCertificateContext(rgCertChain[cCertChain]);
                            MemFree(rgCertChain);
                        }
                    }
                    else
                        hr = MIME_S_SECURITY_ERROROCCURED;
                }
                else
                    hr = MIME_S_SECURITY_ERROROCCURED;

                if(hMyCertStore)
                    CertCloseStore(hMyCertStore, 0);
            }
            else
                hr = MIME_S_SECURITY_ERROROCCURED;
        }
        if(tbCert.pBlobData)
            MemFree(tbCert.pBlobData);
    }
    else
    {
        if (fIsSigned)
        {
            if(fEncryptCert)
            {
                if(pCertSig && SUCCEEDED(HrGetCertKeyUsage(pCertSig, &dw)))
                {
                    if ((dw & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                                    CERT_KEY_AGREEMENT_KEY_USAGE)))
                    {
                        hr = HR_E_ATHSEC_SAMEASSIGNED;
                        return(hr);
                    }
                }
                else
                {
                    hr = HR_E_ATHSEC_SAMEASSIGNED;
                    return(hr);
                }
            }
        }

        hr = MIME_S_SECURITY_ERROROCCURED;
    }
    return(hr);
}

HRESULT _HrPrepSecureMsgForSending(HWND hwnd, LPMIMEMESSAGE pMsg, IImnAccount *pAccount, BOOL *pfHaveSenderCert, BOOL *fDontEncryptForSelf, IHeaderSite *pHeaderSite)
{
    HRESULT         hr;
    IMimeBody      *pBody = NULL;
    //     THUMBBLOB       tbSender = {0, 0};
    BOOL            fIsSigned = IsSigned(pMsg, TRUE);
    BOOL            fIsEncrypted = IsEncrypted(pMsg, TRUE);
    BOOL            fAllowTryAgain = TRUE;
    IImnAccount    *pCertAccount = NULL;
    ACCTTYPE        acctType;
    PROPVARIANT     var;
    SYSTEMTIME      stNow;
    DWORD           cCert=0;
    DWORD           i;
    PCCERT_CONTEXT  pccertSender = NULL;
    PCX509CERT *    rgpccert = NULL;

    hr = pAccount->GetAccountType(&acctType);
    if (FAILED(hr))
        goto Exit;

    if (ACCT_NEWS == acctType)
    {
        if (IDCANCEL == DoDontShowMeAgainDlg(hwnd, c_szDSUseMailCertInNews, MAKEINTRESOURCE(idsAthena),
            MAKEINTRESOURCE(idsWarnUseMailCertInNews), MB_OKCANCEL))
            hr = MAPI_E_USER_CANCEL;
        else
            hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pCertAccount);

        if (FAILED(hr))
            goto Exit;
    }
    else
        ReplaceInterface(pCertAccount, pAccount);

    Assert(pMsg && pAccount && pfHaveSenderCert);

    *pfHaveSenderCert = FALSE;

    hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
    if (FAILED(hr))
        goto Exit;

    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow, &var.filetime);
    var.vt = VT_FILETIME;
    pBody->SetOption(OID_SECURITY_SIGNTIME, &var);

    // Here, we should check the encryption algorithm
    if (fIsEncrypted)
    {
        if (SUCCEEDED(hr = pBody->GetOption(OID_SECURITY_ALG_BULK, &var)))
        {
            DWORD dwStrength = 40;  // default
            DWORD dwWarnStrength = DwGetOption(OPT_MAIL_ENCRYPT_WARN_BITS);

            // Figure out the bit-strength of this algorithm.
            Assert(var.vt == VT_BLOB);

            if (var.blob.pBlobData)
            {
                MimeOleAlgStrengthFromSMimeCap(var.blob.pBlobData, var.blob.cbSize, TRUE, &dwStrength);
                SafeMemFree(var.blob.pBlobData);
            }

            if (! dwWarnStrength) // zero is the default to highest available
                // Calculate the highest available
                dwWarnStrength = GetHighestEncryptionStrength();

            if (dwStrength < dwWarnStrength)
            {
                // Load the warning string and fill it in with the numbers.
                LPTSTR lpMessage = NULL;
                DWORD rgdw[2] = {dwStrength, dwWarnStrength};
                TCHAR szBuffer[256] = "";   // really ought to be big enough
                DWORD dwResult = IDNO;

                LoadString(g_hLocRes, idsWrnLowSecurity, szBuffer, sizeof(szBuffer));

                if (szBuffer[0])
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY, szBuffer,
                    0, 0,
                    (LPTSTR)&lpMessage, 0, (va_list *)rgdw);

                if (lpMessage)
                {
                    dwResult = AthMessageBox(hwnd,
                        MAKEINTRESOURCE(idsSecurityWarning),
                        lpMessage,
                        NULL,
                        MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING | MB_SETFOREGROUND);

                    LocalFree(lpMessage);   // allocated by WIN32 inside FormatMessage
                }

                if (IDYES != dwResult)
                {
                    hr = HR_E_ATHSEC_FAILED;
                    goto Exit;
                }
            }
        }
    }

try_again:
    if ((*fDontEncryptForSelf))
        hr = E_NoPropData;
    if ((!(*fDontEncryptForSelf) || fIsSigned))
    {
        PCX509CERT      pCert = NULL;
        BOOL  fEncryptForMe = TRUE;

#ifndef _WIN64
        var.ulVal = 0;
        var.vt = VT_UI4;
        hr = pBody->SetOption(OID_SECURITY_HCERTSTORE, &var);
#else
        var.pulVal = 0;
        var.vt = VT_UI8;
        hr = pBody->SetOption(OID_SECURITY_HCERTSTORE_64, &var);
#endif

        hr = S_OK;
        if(fIsSigned)
            hr = HrPrepSignCert(hwnd,
                FALSE /* fEncryptCert*/,
                fIsSigned,
                pCertAccount,
                pBody,
                &pCert,
                fDontEncryptForSelf,
                &fEncryptForMe,
                NULL);

        else
            pCert = NULL;

        // This will only be valid if we got an S_OK from the cert
        // finder.
        if(hr == S_OK)
        {
#ifdef _WIN64
            var.vt = VT_UI8;
            var.pulVal = (ULONG *) pCert;
            hr = pBody->SetOption(OID_SECURITY_CERT_SIGNING_64, &var);
#else  //_WIN64
            var.vt = VT_UI4;
            var.ulVal = (ULONG) pCert;
            if(fIsSigned)
                hr = pBody->SetOption(OID_SECURITY_CERT_SIGNING, &var);
#endif // _WIN64

            // need to check also encryption certificate and send it
            PCX509CERT      pCertEnc = NULL;
            fAllowTryAgain = TRUE;

try_encrypt:
            hr = HrPrepSignCert(hwnd,
                TRUE,                // fEncryptCert,
                fIsSigned,
                pCertAccount,
                pBody,
                &pCertEnc,
                fDontEncryptForSelf,
                &fEncryptForMe,
                pCert               // Signed certificate
                );

            if((hr == HR_E_ATHSEC_SAMEASSIGNED) ||     // Encryption certificate is the same as signed
                (hr == E_NoPropData))
            {
                if(fEncryptForMe)
                {
                    pccertSender = CertDuplicateCertificateContext(pCert);
                    *pfHaveSenderCert = TRUE;
                }
                // Do nothing in this case
                hr = S_OK;
                goto EncrDone;
            }

            // This will only be valid if we got an S_OK from the cert
            // finder.  This is because we only ask for one.
            if(hr == S_OK)
            {

                if(fEncryptForMe)
                {
                    pccertSender = CertDuplicateCertificateContext(pCertEnc);
                    *pfHaveSenderCert = TRUE;
                }

                if(!fIsSigned)
                    goto EncrDone;

                // Now wee need to set auth attribute
                // OE will use Issuer and Serial #  for searching certificate in Message store
                // 1. Prepare CRYPT_RECIPIENT_ID
                // 2. Add it to the message

                CRYPT_RECIPIENT_ID   rid;
                LPBYTE pbData = NULL;
                DWORD cbData = 0;
                CRYPT_ATTRIBUTE   attr;
                CRYPT_ATTRIBUTES   Attrs;
                CRYPT_ATTR_BLOB BlobEnc;
                LPBYTE pbBlob = NULL;
                DWORD cbBlob = 0;
                IMimeSecurity2 *        psm2 = NULL;

                IF_FAILEXIT(hr = pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psm2));

                // 1. Prepare CRYPT_RECIPIENT_ID

                rid.dwRecipientType = 0;
                rid.Issuer =  pCertEnc->pCertInfo->Issuer;
                rid.SerialNumber = pCertEnc->pCertInfo->SerialNumber;

                BOOL fResult = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Encryption_Cert,
                    &rid, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                    &pbData,
                    &cbData);

                // Fatal error if fResult is FALSE,
                // need a parsing
                if(!fResult)
                {
FatalEnc:
                CertFreeCertificateContext(pCertEnc);
                AthMessageBoxW(hwnd,
                    MAKEINTRESOURCEW(idsSecurityWarning),
                    MAKEINTRESOURCEW(idsErrSecurityExtFailure), NULL,
                    MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
                hr = HR_E_ATHSEC_FAILED;
                goto exit;
                }

                // 2. Prepare array of attributes (in our case just 1)
                BlobEnc.cbData = cbData;
                BlobEnc.pbData = pbData;

                attr.pszObjId = szOID_Microsoft_Encryption_Cert;
                attr.cValue = 1;
                attr.rgValue = &BlobEnc;

                hr = psm2->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, &attr);
                if (FAILED(hr))
                    goto FatalEnc;

                psm2->Release();
            }
            else if (MIME_S_SECURITY_ERROROCCURED == hr)
            {
                // We are missing a encryption cert.  If it is signed or encrypted
                // go try to find a cert to use.
                //
                // If it is encrypted to someone else, let the S/MIME engine handle
                // This allows the order of errors to become
                // 1) errors for lack of recip certs
                // 2) warn no sender cert
                if (fAllowTryAgain && (fIsSigned || !(*fDontEncryptForSelf)))
                {
                    fAllowTryAgain = FALSE;  // Only one more try, please.  Prevent infinite loop.

                    // Is there a cert that I can use?  If so, let's go associate it with the
                    // account and try again.
                    if (SUCCEEDED(hr = _HrFindMyCertForAccount(hwnd, NULL, pAccount, TRUE)))
                    {
                        // Go back and try again.
                        pCertEnc = NULL;
                        goto try_encrypt;
                    }
                    else if(hr != MAPI_E_USER_CANCEL)
                    {
                        if(!fIsEncrypted || (IDYES == AthMessageBoxW(hwnd,
                                        MAKEINTRESOURCEW(idsSecurityWarning),
                                        MAKEINTRESOURCEW(idsWrnSecurityNoCertForEnc), NULL,
                                        MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING|MB_SETFOREGROUND)))
                            hr = S_OK;
                        else
                            hr = HR_E_ATHSEC_FAILED;

                    }
                }

            }
EncrDone:
            if(pCertEnc)
                CertFreeCertificateContext(pCertEnc);

            if((HR_E_ATHSEC_FAILED != hr) && (hr != MAPI_E_USER_CANCEL))
            {

                // check secutity label
                if ((pHeaderSite != NULL) && fIsSigned)
                {
                    PSMIME_SECURITY_LABEL plabel = NULL;
                    CRYPT_ATTRIBUTE     attrCrypt;
                    CRYPT_ATTR_BLOB     valCrypt;
                    IMimeSecurity2 * pSMIME3 = NULL;

                    if(pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pSMIME3) == S_OK)
                    {

                        hr = pHeaderSite->GetLabelFromNote(&plabel);

                        if(hr == S_OK )
                        {
                            if((plabel != NULL) && SUCCEEDED(hr = HrValidateLabelOnSend(plabel, hwnd, pCert, 0, NULL)))
                            {
                                LPBYTE              pbLabel = NULL;
                                DWORD               cbLabel;

                                // hr = HrEncodeAndAlloc(X509_ASN_ENCODING,
                                //            szOID_SMIME_Security_Label, plabel,
                                //            &pbLabel, &cbLabel);

                                if(CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                    plabel, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                    &pbLabel, &cbLabel))
                                {
                                    attrCrypt.pszObjId = szOID_SMIME_Security_Label;
                                    attrCrypt.cValue = 1;
                                    attrCrypt.rgValue = &valCrypt;
                                    valCrypt.cbData = cbLabel;
                                    valCrypt.pbData = pbLabel;
                                    hr = pSMIME3->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, &attrCrypt);
                                }
                                else
                                    hr = HR_E_ATHSEC_FAILED;

                                SafeMemFree(pbLabel);
                            }
                            else
                            {
                                if(SUCCEEDED(hr))
                                    hr = HR_E_ATHSEC_FAILED;
                            }

                            if(FAILED(hr))
                            {
                                if(hr != HR_E_ATHSEC_FAILED)
                                {
                                    AthMessageBoxW(hwnd,
                                            MAKEINTRESOURCEW(idsSecurityWarning),
                                            MAKEINTRESOURCEW(idsSecPolicyBadCert), NULL,
                                            MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
                                        hr = HR_E_ATHSEC_FAILED;
                                }
                                else if(IDYES == AthMessageBoxW(hwnd,
                                        MAKEINTRESOURCEW(idsSecurityWarning),
                                        MAKEINTRESOURCEW(idsSendLabelErr), NULL,
                                        MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING|MB_SETFOREGROUND))
                                    hr = S_OK;
                                else
                                    hr = HR_E_ATHSEC_FAILED;

                            }
                            if(FAILED(hr))
                            {
                                SafeRelease(pSMIME3);
                                goto exit;
                            }
                        }

                        // Check security receipts
                        if (pHeaderSite->IsSecReceiptRequest() == S_OK)
                        {
                            CERT_NAME_BLOB              blob;
                            // DATA_BLOB                   BlobId;

                            SMIME_RECEIPT_REQUEST       req = {0};
                            DWORD                       cbName;
                            SpBYTE                      pbName;
                            LPBYTE                      pbReq = NULL;
                            DWORD                       cbReq = 0;

                            CERT_ALT_NAME_INFO          SenderName;
                            PCERT_ALT_NAME_ENTRY        palt;

                            // Get a sender name and encrypt it
                            LPSTR szCertEmailAddress = SzGetCertificateEmailAddress(pCert);
                            Assert(szCertEmailAddress != NULL);

                            if(MemAlloc((LPVOID *) &palt, sizeof(CERT_ALT_NAME_ENTRY)))
                            {
                                TCHAR pchContentID[CONTENTID_SIZE]; // length this will be 46. See CreateContentIdentifier comment

                                CreateContentIdentifier(pchContentID, pMsg);

                                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, STR_HDR_XMSOESREC, NOFLAGS, pchContentID);
                                req.ContentIdentifier.pbData = (BYTE *) pchContentID;
                                req.ContentIdentifier.cbData = lstrlen(pchContentID);

                                palt->pwszRfc822Name = NULL;
                                palt->dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;

                                cbName = MultiByteToWideChar(CP_ACP, 0, szCertEmailAddress, -1, NULL, 0);

                                if (MemAlloc((LPVOID *) &(palt->pwszRfc822Name), (cbName + 1)*sizeof(WCHAR)))
                                {

                                    MultiByteToWideChar(CP_ACP, 0, szCertEmailAddress, -1, palt->pwszRfc822Name, cbName);
                                    SenderName.cAltEntry = 1;
                                    SenderName.rgAltEntry = palt;

                                    if(CryptEncodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                        &SenderName, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                        &pbName, &cbName))
                                    {

                                        blob.pbData = pbName;
                                        blob.cbData = cbName;

                                        // create sec receipt request
                                        req.ReceiptsFrom.AllOrFirstTier = SMIME_RECEIPTS_FROM_ALL;
                                        req.ReceiptsFrom.cNames = 0;

                                        req.cReceiptsTo = 1;
                                        req.rgReceiptsTo = &blob;

                                        // Encrypt it
                                        if(CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Receipt_Request,
                                            &req, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                            &pbReq, &cbReq))
                                        {

                                            // Set sec receipt request attribute
                                            attrCrypt.pszObjId = szOID_SMIME_Receipt_Request;
                                            attrCrypt.cValue = 1;
                                            attrCrypt.rgValue = &valCrypt;
                                            valCrypt.cbData = cbReq;
                                            valCrypt.pbData = pbReq;

                                            hr = pSMIME3->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, &attrCrypt);

                                            Assert(hr == S_OK);
                                            SafeMemFree(pbReq);
                                        }
                                        else
                                            hr = HR_E_ATHSEC_FAILED;

                                        SafeMemFree(pbName);
                                    }
                                    else
                                        hr = HR_E_ATHSEC_FAILED;

                                    SafeMemFree(palt->pwszRfc822Name);
                                }
                                else
                                    hr = HR_E_ATHSEC_FAILED;

                                SafeMemFree(palt);
                            }
                            else
                                hr = HR_E_ATHSEC_FAILED;

                            if(FAILED(hr))
                            {
                                if(IDYES == AthMessageBoxW(hwnd,
                                            MAKEINTRESOURCEW(idsSecurityWarning),
                                            MAKEINTRESOURCEW(idsSendRecRequestErr), NULL,
                                            MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING|MB_SETFOREGROUND))
                                    hr = S_OK;
                                else
                                    hr = HR_E_ATHSEC_FAILED;

                            }
                            if(FAILED(hr))
                                goto exit;
                            SafeMemFree(szCertEmailAddress);

                        }
                        SafeRelease(pSMIME3);
                    }

                }
            }
        }
        else if (MIME_S_SECURITY_ERROROCCURED == hr)
        {
            // We are missing a MY cert.  If it is signed or encrypted
            // go try to find a cert to use.
            //
            // If it is encrypted to someone else, let the S/MIME engine handle
            // This allows the order of errors to become
            // 1) errors for lack of recip certs
            // 2) warn no sender cert
            hr = fIsSigned ? HR_E_ATHSEC_NOCERTTOSIGN : S_OK;

            if (fAllowTryAgain && (fIsSigned || !(*fDontEncryptForSelf)))
            {
                fAllowTryAgain = FALSE;  // Only one more try, please.  Prevent infinite loop.

                // Is there a cert that I can use?  If so, let's go associate it with the
                // account and try again.
                if (SUCCEEDED(hr = _HrFindMyCertForAccount(hwnd, NULL, pAccount, /*fIsSigned ?*/ FALSE /*: TRUE*/)))
                    // Go back and try again.
                    goto try_again;
                else if(fIsEncrypted)
                {
                    if(IDYES == AthMessageBoxW(hwnd,
                                        MAKEINTRESOURCEW(idsSecurityWarning),
                                        MAKEINTRESOURCEW(idsWrnSecurityNoCertForEnc), NULL,
                                        MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING|MB_SETFOREGROUND))
                        hr = S_OK;
                    else
                        hr = HR_E_ATHSEC_FAILED;
                }

            }
        }
        // This will only be valid if we got an S_OK from the cert
        // finder.  This is because we only ask for one.

        if(pCert)
            CertFreeCertificateContext(pCert);
    }
    else
    {
        if (E_NoPropData == hr)
        {
            BOOL fTryAgain = FALSE;
            DOUTL(DOUTL_CRYPT, "No certificate for this account...");

            // We are missing a MY cert.  If it is signed or encrypted
            // go try to find a cert to use.
            //
            // If it is encrypted to someone else, let the S/MIME engine handle
            // This allows the order of errors to become
            // 1) errors for lack of recip certs
            // 2) warn no sender cert
            hr = fIsSigned ? HR_E_ATHSEC_NOCERTTOSIGN : S_OK;

            if (fAllowTryAgain && (fIsSigned || !(*fDontEncryptForSelf)))
            {
                fAllowTryAgain = FALSE;  // Only one more try, please.  Prevent infinite loop.

                // Is there a cert that I can use?  If so, let's go associate it with the
                // account and try again.
                if (SUCCEEDED(hr = _HrFindMyCertForAccount(hwnd, NULL, pAccount, TRUE)))
                    // Go back and try again.
                    goto try_again;
            }
        }
    }

    if(FAILED(hr))
        goto Exit;

    if (fIsEncrypted)
    {
        if((hr = HrBuildAndVerifyCerts(hwnd, pMsg, &cCert, &rgpccert, pccertSender, pAccount, pHeaderSite)) == S_FALSE)
        {
            ULONG       ulSecurityType = MST_CLASS_SMIME_V1;

            if (fIsSigned)
                ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
            else
                ulSecurityType &= ~((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);


            ulSecurityType &= ~MST_THIS_ENCRYPT;
            hr = HrInitSecurityOptions(pMsg, ulSecurityType);
            fIsEncrypted = FALSE;
            goto exit;
        }

        CHECKHR(hr);

        if (cCert > 0)
        {
            PROPVARIANT         var;

#ifdef _WIN64
            var.vt = VT_UI8;
            var.cauh.cElems = cCert;
            var.cauh.pElems = (ULARGE_INTEGER *) rgpccert;
            CHECKHR(hr = pBody->SetOption(OID_SECURITY_RG_CERT_ENCRYPT_64, &var));
#else   // !_WIN64
            var.vt = VT_UI4;
            var.caul.cElems = cCert;
            var.caul.pElems = (ULONG *) rgpccert;
            CHECKHR(hr = pBody->SetOption(OID_SECURITY_RG_CERT_ENCRYPT, &var));
#endif  // _WIN64
        }
    }
Exit:
    // For signing messages
    if(fIsSigned)
    {
        // Do autoassociation
        if(hr == HR_E_ATHSEC_USENEWSIGN)
        {
            if (SUCCEEDED(hr = _HrFindMyCertForAccount(hwnd, NULL, pAccount, FALSE)))
            {
                // Go back and try again.
                fAllowTryAgain = TRUE;
                goto try_again;
            }
        }
        else if(hr == HR_E_ATHSEC_DONTSIGN)   // Don't sign message
        {
            ULONG       ulSecurityType = MST_CLASS_SMIME_V1;

            if (fIsEncrypted)
                ulSecurityType |= MST_THIS_ENCRYPT;

            ulSecurityType &= ~((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);

            hr = HrInitSecurityOptions(pMsg, ulSecurityType);
            fIsSigned = FALSE;
        }
    }

exit:
    ReleaseObj(pBody);
    ReleaseObj(pCertAccount);
    if (rgpccert != NULL)
    {
        for (i=0; i<cCert; i++)
        {
            if (rgpccert[i] != NULL)
                CertFreeCertificateContext(rgpccert[i]);
        }
        if (pccertSender != NULL)
            CertFreeCertificateContext(pccertSender);
    }
    return TrapError(hr);
}

DWORD DwGenerateTrustedChain(
                             HWND                hwnd,
                             IMimeMessage *      pMsg,
                             PCCERT_CONTEXT      pcCertToTest,
                             DWORD               dwToIgnore,
                             BOOL                fFullSearch,
                             DWORD *             pcChain,
                             PCCERT_CONTEXT **   prgChain)
{
    DWORD       dwErr = 0;
    GUID        guidAction = CERT_CERTIFICATE_ACTION_VERIFY;
    CERT_VERIFY_CERTIFICATE_TRUST trust = {0};
    WINTRUST_BLOB_INFO blob = {0};
    WINTRUST_DATA data = {0};
    IMimeBody * pBody;
    PROPVARIANT var;
    HCERTSTORE  rgCAs[3] = {0};
    HCERTSTORE *pCAs = NULL;
    HCERTSTORE hMsg = NULL;
    FILETIME FileTime;
    SYSTEMTIME SysTime;
    LONG lr = 0;
    BOOL    fIgnoreTimeError = FALSE;
    HBODY   hBody = NULL;


    Assert(pcCertToTest);

    if (pMsg)
    {
        if(FAILED(HrGetInnerLayer(pMsg, &hBody)))
            goto contin;

        pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody);
        if (pBody)
        {
#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
                hMsg = (HCERTSTORE) (var.pulVal);
#else   // !_WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
                hMsg = (HCERTSTORE)var.ulVal;
#endif  // _WIN64
            pBody->Release();

            if (hMsg)
            {
                rgCAs[0] = hMsg;

                rgCAs[1] = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
                if (rgCAs[1])
                {
                    rgCAs[2] = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER, c_szCACertStore);
                    if (rgCAs[2])
                        pCAs = rgCAs;
                }
            }
        }
    }

contin:
    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE)&trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pcCertToTest;
    trust.dwFlags = (fFullSearch ? CERT_TRUST_DO_FULL_SEARCH : 0);
    trust.pdwErrors = &dwErr;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.pcChain = pcChain;
    trust.prgChain = prgChain;

    if(!((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && CheckCDPinCert(pcCertToTest)))
        trust.dwFlags |= CRYPTDLG_REVOCATION_NONE;
    else
        trust.dwFlags |= CRYPTDLG_REVOCATION_ONLINE;

    //cvct.prgdwErrors
    trust.dwIgnoreErr = dwToIgnore;
    if (pCAs)
    {
        trust.dwFlags |= CERT_TRUST_ADD_CERT_STORES;
        trust.rghstoreCAs = pCAs;
        trust.cStores = 3;
    }

// Delta checking
    GetSystemTime(&SysTime);
    if(SystemTimeToFileTime(&SysTime, &FileTime))
    {
        LONG    lRet;
        // Need to check with Delta
        lr = CertVerifyTimeValidity(&FileTime, pcCertToTest->pCertInfo);
        if(lr < 0)
        {
            FILETIME ftNow;
            __int64  i64Offset;

            union
            {
                 FILETIME ftDelta;
                __int64 i64Delta;
            };

            GetSystemTimeAsFileTime(&ftNow);

            i64Delta = ftNow.dwHighDateTime;
            i64Delta = i64Delta << 32;
            i64Delta += ftNow.dwLowDateTime;

            // Add the offset into the original time to get us a new time to check
            i64Offset = FILETIME_SECOND;
            i64Offset *= TIME_DELTA_SECONDS;
            i64Delta += i64Offset;

            lr = CertVerifyTimeValidity(&ftDelta, pcCertToTest->pCertInfo);
        }
        if(lr == 0)
            fIgnoreTimeError = TRUE;
    }

// End of delta checking
    lr = WinVerifyTrust(hwnd, &guidAction, (void*)&data);

    if(((LRESULT) lr) == CERT_E_REVOKED)
        dwErr = CERT_VALIDITY_CERTIFICATE_REVOKED;

    else if(((LRESULT) lr) == CERT_E_REVOCATION_FAILURE)
    {
        Assert(FALSE);
        dwErr = CERT_VALIDITY_NO_CRL_FOUND;
    }
    else if (0 > lr)            // WinVerifyTrust(hwnd, &guidAction, (void*)&data))
        dwErr = CERT_VALIDITY_NO_TRUST_DATA;

    if (dwErr)
        DOUTL(DOUTL_CRYPT, "Trust provider returned 0x%.8lx", dwErr);

    // Filter these out since the trust provider isn't.
    if(fIgnoreTimeError)
        dwErr &= ~(CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END);


    if(!(CheckCDPinCert(pMsg) && (dwErr == CERT_VALIDITY_NO_CRL_FOUND)))
        dwErr &= ~dwToIgnore;

    CertCloseStore(rgCAs[0], 0);
    CertCloseStore(rgCAs[1], 0);
    CertCloseStore(rgCAs[2], 0);

    return dwErr;
}

HRESULT CommonUI_ViewSigningProperties(HWND hwnd, PCCERT_CONTEXT pCert, HCERTSTORE hcMsg, UINT nStartPage)
{
    CERT_VIEWPROPERTIES_STRUCT  cvps;
    TCHAR                       szTitle[CCHMAX_STRINGRES];
    LPSTR                       oidPurpose = szOID_PKIX_KP_EMAIL_PROTECTION;

    AthLoadString(idsSigningCertProperties, szTitle, ARRAYSIZE(szTitle));

    memset((void*)&cvps, 0, sizeof(cvps));

    cvps.dwSize = sizeof(cvps);
    cvps.hwndParent = hwnd;
    cvps.hInstance = g_hLocRes;
    cvps.szTitle = szTitle;
    cvps.pCertContext = pCert;
    cvps.nStartPage = nStartPage;
    cvps.arrayPurposes = &oidPurpose;
    cvps.cArrayPurposes = 1;
    cvps.cStores = hcMsg ? 1 : 0;                      // Count of other stores to search
    cvps.rghstoreCAs = hcMsg ? &hcMsg : NULL;     // Array of other stores to search
    cvps.dwFlags = hcMsg ? CM_ADD_CERT_STORES : 0;

    if(!((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline()))
        cvps.dwFlags |= CRYPTDLG_REVOCATION_NONE;
    else
        cvps.dwFlags |= CRYPTDLG_REVOCATION_ONLINE;

    return CertViewProperties(&cvps) ? S_OK : S_FALSE;
}

HRESULT LoadResourceToHTMLStream(LPCTSTR szResName, IStream **ppstm)
{
    HRESULT hr;

    Assert(ppstm);

    hr = MimeOleCreateVirtualStream(ppstm);

    if (SUCCEEDED(hr))
    {
        // MIME header
        // don't fail
        (*ppstm)->Write(s_szHTMLMIME, sizeof(s_szHTMLMIME)-sizeof(TCHAR), NULL);

        // HTML Header information
        hr = HrLoadStreamFileFromResource(szResName, ppstm);

        // If we didn't get the resource, lose the stream.  The caller
        // won't want it
        if (FAILED(hr))
        {
            (*ppstm)->Release();
            *ppstm = NULL;
        }
    }

    return hr;
}

#ifdef YST
/***************************************************************************

    Name      : FreeCertArray

    Purpose   : Frees the array of certs returned by HrGetMyCerts.

    Parameters: rgcc = array of cert contexts
                ccc = count of cert contexts in rgcc

    Returns   : none

    Comment   :

***************************************************************************/
void FreeCertArray(PCCERT_CONTEXT * rgcc, ULONG ccc)
{
    if (rgcc)
    {
        for (ULONG i = 0; i < ccc; i++)
            if (rgcc[i])
                CertFreeCertificateContext(rgcc[i]);
        MemFree(rgcc);
    }
}

#endif // YST
/***************************************************************************

    Name      : GetSignersEncryptionCert

    Purpose   : Gets the signer's encryption cert from the message

    Parameters: pMsg -> Message Object

    Returns   : HRESULT - S_OK on success, MIME_E_SECURITY_NOCERT if no cert

    Comment   : Zero fills any return structures with no matching parameter

*************************************************************************/

HRESULT GetSignerEncryptionCert(IMimeMessage * pMsg, PCCERT_CONTEXT * ppcEncryptCert,
                                THUMBBLOB * ptbEncrypt, BLOB * pblSymCaps,
                                FILETIME * pftSigningTime)
{
    DWORD               cb;
    HRESULT             hr;
    HCERTSTORE          hcMsg = NULL;
    DWORD               i;
    IMimeBody *         pBody = NULL;
    PCCERT_CONTEXT      pccertEncrypt = NULL;
    PCCERT_CONTEXT      pccertSender = NULL;
    THUMBBLOB           tbTemp = {0, 0};

    // Next 5 lines repeats in 3 others places of OE and we may have a separate function from then in future.
    HBODY               hBody = NULL;
    SECSTATE            SecState ={0};

    if(FAILED(hr = HrGetSecurityState(pMsg, &SecState, &hBody)))
        return(hr);

    CleanupSECSTATE(&SecState);

    Assert((ptbEncrypt != NULL) && (pblSymCaps != NULL) && (pftSigningTime != NULL));

    // Init return structure
    ptbEncrypt->pBlobData = NULL;
    ptbEncrypt->cbSize = 0;
    pblSymCaps->pBlobData = NULL;
    pblSymCaps->cbSize = 0;
    pftSigningTime->dwLowDateTime = 0;
    pftSigningTime->dwHighDateTime = 0;

    if (SUCCEEDED(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
    {
        PROPVARIANT     var;

        hr = MIME_E_SECURITY_NOCERT;    // assume failure;

#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
        {
            hcMsg = (HCERTSTORE *) (var.pulVal);
        }

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            Assert(VT_UI8 == var.vt);

            pccertSender = (PCCERT_CONTEXT) (var.pulVal);
        }
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
        {
            hcMsg = (HCERTSTORE) var.ulVal;
        }

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            Assert(VT_UI4 == var.vt);

            pccertSender = (PCCERT_CONTEXT) var.ulVal;
        }
#endif  // _WIN64
        //
        //  Need to do a bit of work to identify the sender's encryption
        //      certificate.
        //
        //  1.  Look for the id-aa-encryptKeyPref
        //  2.  Look for the Microsoft_Encryption_Key_Preference
        //  3.  If this is a sign only cert, look for a cert with the same
        //      issuer and subject
        //  4.  If this is a sign only cert, look for a cert with the same
        //      subject
        //

        if (hcMsg && SUCCEEDED(pBody->GetOption(OID_SECURITY_AUTHATTR, &var)))
        {
            PCRYPT_ATTRIBUTE    pattr;
            PCRYPT_ATTRIBUTES   pattrs = NULL;

            if (CryptDecodeObjectEx(X509_ASN_ENCODING,
                                    szOID_Microsoft_Attribute_Sequence,
                                    var.blob.pBlobData, var.blob.cbSize,
                                    CRYPT_ENCODE_ALLOC_FLAG, NULL, &pattrs, &cb))
            {
                for (i=0, pattr = NULL; i < pattrs->cAttr; i++)
                {
                    if (strcmp(pattrs->rgAttr[i].pszObjId,
                               szOID_Microsoft_Encryption_Cert) == 0)
                    {
                        PCRYPT_RECIPIENT_ID         prid = NULL;
                        pattr = &pattrs->rgAttr[i];
                        if (CryptDecodeObjectEx(X509_ASN_ENCODING,
                                        szOID_Microsoft_Encryption_Cert,
                                        pattr->rgValue[0].pbData,
                                        pattr->rgValue[0].cbData,
                                        CRYPT_ENCODE_ALLOC_FLAG, NULL, &prid, &cb))
                        {
                            CERT_INFO       certinfo;
                            certinfo.SerialNumber = prid->SerialNumber;
                            certinfo.Issuer = prid->Issuer;
                            pccertEncrypt = CertGetSubjectCertificateFromStore(
                                                hcMsg, X509_ASN_ENCODING, &certinfo);
                        }
                        LocalFree(prid);
                    }
                    else if (strcmp(pattrs->rgAttr[i].pszObjId,
                                    szOID_SMIME_Encryption_Key_Preference) == 0)
                    {
                        PSMIME_ENC_KEY_PREFERENCE   pekp = NULL;
                        pattr = &pattrs->rgAttr[i];
                        if (CryptDecodeObjectEx(X509_ASN_ENCODING,
                                        szOID_SMIME_Encryption_Key_Preference,
                                        pattr->rgValue[0].pbData,
                                        pattr->rgValue[0].cbData,
                                        CRYPT_ENCODE_ALLOC_FLAG, NULL, &pekp, &cb))
                        {
                            pccertEncrypt = CertFindCertificateInStore(hcMsg, 
                                               X509_ASN_ENCODING, 0,
                                               CERT_FIND_CERT_ID,
                                               &pekp->RecipientId, NULL);
                        }
                        LocalFree(pekp);
                        break;
                    }
                }

                LocalFree(pattrs);
            }

            MemFree(var.blob.pBlobData);
        }
        if ((pccertEncrypt == NULL) && (pccertSender != NULL))
        {
            DWORD       dw;
            HrGetCertKeyUsage(pccertSender, &dw);
            if (!(dw & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                        CERT_KEY_AGREEMENT_KEY_USAGE)))
            {
                pccertEncrypt = CertFindCertificateInStore(hcMsg, 
                                   X509_ASN_ENCODING, 0,
                                   CERT_FIND_SUBJECT_NAME,
                                   &pccertSender->pCertInfo->Subject, NULL);
                while (pccertEncrypt != NULL) {
                    HrGetCertKeyUsage(pccertEncrypt, &dw);
                    if (dw & CERT_KEY_ENCIPHERMENT_KEY_USAGE) {
                        break;
                    }
                    
                    pccertEncrypt = CertFindCertificateInStore(
                                hcMsg, X509_ASN_ENCODING, 0, 
                                CERT_FIND_SUBJECT_NAME,
                                &pccertSender->pCertInfo->Subject, 
                                pccertEncrypt);
                }
            }
            else
                pccertEncrypt = CertDuplicateCertificateContext(pccertSender);
        }

        if (pccertEncrypt == NULL)
            goto error;

        tbTemp.pBlobData =
                (BYTE *)PVGetCertificateParam(pccertEncrypt, CERT_HASH_PROP_ID,
                                              &tbTemp.cbSize);

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SYMCAPS, &var)))
        {
            if (var.blob.cbSize) {
                // we don't have to dupe the symcaps because we won't free
                // the var's.
                *pblSymCaps = var.blob;
            }
        }

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SIGNTIME, &var)))
        {
            if (var.filetime.dwLowDateTime != 0 || var.filetime.dwHighDateTime != 0) {
                *pftSigningTime = var.filetime;
            }
        }

        if (tbTemp.pBlobData && tbTemp.cbSize)
        {
            ptbEncrypt->cbSize = tbTemp.cbSize;
            ptbEncrypt->pBlobData = tbTemp.pBlobData;
            tbTemp.pBlobData = NULL;
        }

        if (ppcEncryptCert != NULL)
            *ppcEncryptCert = CertDuplicateCertificateContext(pccertEncrypt);
        hr = S_OK;
    }

error:
    SafeRelease(pBody);
    if (tbTemp.pBlobData != NULL)
        MemFree(tbTemp.pBlobData);

    if (hcMsg != NULL)
        CertCloseStore(hcMsg, 0);

    if (pccertSender != NULL)
        CertFreeCertificateContext(pccertSender);
    if (pccertEncrypt != NULL)
        CertFreeCertificateContext(pccertEncrypt);
    return hr;
}

/***************************************************************************

    Name      : GetSigningCert

    Purpose   : Gets the signing cert from the message

    Parameters: pMsg -> Message object
                ppcSigningCert -> returned signing cert context.  (optional)
                  Caller must CertFreeCertificateContext.
                ptbSigner -> thumbprint blob.
                  Caller should supply the blob but must free the pbData.
                pblSymCaps -> SymCaps blob.
                  Caller should supply the blob but must free the pbData.
                pftSigningTime -> returned signing time

    Returns   : HRESULT - S_OK on success, MIME_E_SECURITY_NOCERT if no cert

    Comment   : Zero fills any return structures which have no matching
                parameter.

***************************************************************************/
HRESULT GetSigningCert(IMimeMessage * pMsg, PCCERT_CONTEXT * ppcSigningCert, THUMBBLOB * ptbSigner, BLOB * pblSymCaps, FILETIME * pftSigningTime)
{
    HRESULT             hr = S_OK;
    IMimeBody           *pBody = NULL;
    HBODY               hBody = NULL;

    Assert(ptbSigner && pblSymCaps && pftSigningTime);

    // Init return structure
    ptbSigner->pBlobData = NULL;
    ptbSigner->cbSize = 0;
    pblSymCaps->pBlobData = NULL;
    pblSymCaps->cbSize = 0;
    pftSigningTime->dwLowDateTime = 0;
    pftSigningTime->dwHighDateTime = 0;

    if(FAILED(hr = HrGetInnerLayer(pMsg, &hBody)))
        return(hr);

    if (SUCCEEDED(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody)))
    {
        PROPVARIANT         var;
        PCCERT_CONTEXT      pcSigningCert;
        THUMBBLOB           tbTemp = {0,0};

        hr = MIME_E_SECURITY_NOCERT;    // assume failure

#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            Assert(VT_UI8 == var.vt);

            pcSigningCert = (PCCERT_CONTEXT)(var.pulVal);
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            Assert(VT_UI4 == var.vt);

            pcSigningCert = (PCCERT_CONTEXT) var.ulVal;
#endif  // _WIN64
            if (pcSigningCert)
            {
                // Get the thumbprint
                tbTemp.pBlobData = (BYTE *)PVGetCertificateParam(pcSigningCert, CERT_HASH_PROP_ID, &tbTemp.cbSize);
                if (tbTemp.pBlobData && tbTemp.cbSize)
                {
                    // Allocate return buffer
                    if (! MemAlloc((LPVOID *)&ptbSigner->pBlobData, tbTemp.cbSize))
                        hr = ResultFromScode(E_OUTOFMEMORY);
                    else
                    {
                        ptbSigner->cbSize = tbTemp.cbSize;
                        memcpy(ptbSigner->pBlobData, tbTemp.pBlobData, tbTemp.cbSize);

                        MemFree(tbTemp.pBlobData);

                        hr = S_OK;

                        // Have a thumbprint.  Go get the symcaps and signing time
                        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SYMCAPS, &var)))
                        {
                            Assert(VT_BLOB == var.vt);

                            *pblSymCaps = var.blob;

                            // Have a symcaps.  Go get the signing time
                            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SIGNTIME, &var)))
                            {
                                Assert(VT_FILETIME == var.vt);

                                *pftSigningTime = var.filetime;
                            }
                        }
                    }
                }

                if (ppcSigningCert)
                    *ppcSigningCert = pcSigningCert;    // Let caller free it.
                else
                    CertFreeCertificateContext(pcSigningCert);
            }
        }
    }

    SafeRelease(pBody);
    return(hr);
}


/***************************************************************************

    Name      : HrSaveCACerts

    Purpose   : Add the messages CA certs to the CA store

    Parameters: hcCA = CA system cert store
                hcMsg = message cert store

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrSaveCACerts(HCERTSTORE hcCA, HCERTSTORE hcMsg)
{
    HRESULT                     hr = S_OK;
    PCCERT_CONTEXT              pccert = NULL;
    PCCERT_CONTEXT              pccertSubject;
    PCERT_EXTENSION             pext;

    //  Verify good parameters exist

    if ((hcCA == NULL) || (hcMsg == NULL))
    {
        Assert((hcCA != NULL) && (hcMsg != NULL));
        goto error;
    }

    //
    //  The logic we are going to following to determine if we should be adding
    //  a certificate to the CA store is as follows:
    //
    //  1.  If the basic constraints extension exists, and says its a CA then add
    //          to the CA store.  Note that the converse is not true as NT4 Cert Server
    //          generated CA certs with the end-entity version of basic contraints.
    //  2.  If the certificate's subject is matched by the issuer of antoher cert in
    //          the store then it goes into the CA cert store.
    //
    //  Note:  There are some certificates in the store which may not get added to
    //          the CA store and are not.  If the basic constraints extension is
    //          missing, but no issued cert is included in the message then it will
    //          be dropped on the floor.  This case should not matter in practice.
    //

    while (pccert = CertEnumCertificatesInStore(hcMsg, pccert))
    {
        pext = CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                                 pccert->pCertInfo->cExtension,
                                 pccert->pCertInfo->rgExtension);
        if (pext != NULL)
        {
            ;   // M00TODO
        }

        pccertSubject = CertFindCertificateInStore(hcMsg, X509_ASN_ENCODING, 0,
                                                   CERT_FIND_ISSUER_NAME,
                                                   &pccert->pCertInfo->Subject, NULL);
        if (pccertSubject != NULL)
        {
            if (!CertAddCertificateContextToStore(hcCA, pccert,
                                                  CERT_STORE_ADD_USE_EXISTING, NULL))
                // Don't really fail
                DebugTrace("CertAddCertificateContextToStore -> %x\n", GetLastError());
            CertFreeCertificateContext(pccertSubject);
        }

    }

error:
    return(hr);
}


/***************************************************************************

    Name      : IsThumbprintInMVPBin

    Purpose   : Check the PR_USER_X509_CERTIFICATE prop for this thumbprint

    Parameters: spv = prop value structure of PR_USER_X509_CERTIFICATE
                lpThumbprint -> THUMBBLOB structure to find
                lpIndex -> Returned index in MVP (or NULL)
                pblSymCaps -> symcaps blob to fill in (or NULL)
                lpftSigningTime -> returned signing time (or NULL)
                lpfDefault -> returned default flag (or NULL)

    Returns   : TRUE if found

    Comment   : Note that the values returned in pblSymCaps and lpftSigningTime
                are only valid if TRUE is returned.

***************************************************************************/
BOOL IsThumbprintInMVPBin(SPropValue spv, THUMBBLOB * lpThumbprint, ULONG * lpIndex,
            BLOB * pblSymCaps, FILETIME * lpftSigningTime, BOOL * lpfDefault)
{
    ULONG cValues, i;
    LPSBinary lpsb = NULL;
    CERTTAGS UNALIGNED *lpCurrentTag = NULL;
    CERTTAGS UNALIGNED *lpTempTag;
    LPBYTE lpbTagEnd;
    BOOL fFound = FALSE;

    // Initialize the return data
    if (lpIndex)
        *lpIndex = (ULONG)-1;
    if (lpftSigningTime)
        lpftSigningTime->dwLowDateTime = lpftSigningTime->dwHighDateTime = 0;
    if (pblSymCaps)
    {
        pblSymCaps->cbSize = 0;
        pblSymCaps->pBlobData = 0;
    }

    if (! PROP_ERROR((spv)))
    {
        lpsb = spv.Value.MVbin.lpbin;
        cValues = spv.Value.MVbin.cValues;

        // Check for duplicates
        for (i = 0; i < cValues; i++)
        {
            lpCurrentTag = (LPCERTTAGS)lpsb[i].lpb;
            lpbTagEnd = (LPBYTE)lpCurrentTag + lpsb[i].cb;

            // Init the return structures
            if (lpftSigningTime)
                lpftSigningTime->dwLowDateTime = lpftSigningTime->dwHighDateTime = 0;
            if (pblSymCaps)
            {
                pblSymCaps->cbSize = 0;
                pblSymCaps->pBlobData = 0;
            }
            if (lpfDefault)
                *lpfDefault = FALSE;

            while ((LPBYTE)lpCurrentTag < lpbTagEnd)
            {
                // Check if this is the tag that contains the thumbprint
                if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag)
                {
                    if ((lpThumbprint->cbSize == lpCurrentTag->cbData - SIZE_CERTTAGS) &&
                            ! memcmp(lpThumbprint->pBlobData, &lpCurrentTag->rgbData,
                            lpThumbprint->cbSize))
                    {
                        if (lpIndex)
                            *lpIndex = i;
                        fFound = TRUE;
                    }
                }
                if (lpfDefault && (CERT_TAG_DEFAULT == lpCurrentTag->tag))
                    memcpy(lpfDefault, &lpCurrentTag->rgbData, min(sizeof(*lpfDefault), lpCurrentTag->cbData));
                if (lpftSigningTime && (CERT_TAG_SIGNING_TIME == lpCurrentTag->tag))
                    memcpy(lpftSigningTime, &lpCurrentTag->rgbData, min(sizeof(FILETIME), lpCurrentTag->cbData));
                if (pblSymCaps && (CERT_TAG_SYMCAPS == lpCurrentTag->tag))
                {
                    pblSymCaps->cbSize = lpCurrentTag->cbData - SIZE_CERTTAGS;
                    pblSymCaps->pBlobData = lpCurrentTag->rgbData;
                }

                lpTempTag = lpCurrentTag;
                lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
                if (lpCurrentTag == lpTempTag)
                {
                    DOUTL(DOUTL_CRYPT, "Bad CertTag in PR_USER_X509_CERTIFICATE");
                    break;        // Safety valve, prevent infinite loop if bad data
                }
            }

            if (fFound)
                return(TRUE);
        }
    }
    return(FALSE);
}


/***************************************************************************

    Name      : MatchCertificate

    Purpose   : Checks if a specific certificate is in the WAB entry

    Parameters: lpAdrBook -> IADRBook object
                lpWabal -> Wabal object (for allocators)
                lpbEntryID -> EntryID of this entry
                cbEntryID -> Size of EntryID
                pSenderThumbprint -> THUMBBLOB structure to find
                lppMailUser -> [optional] returned MailUser object

    Returns   : TRUE if a match is found

    Comment   :

***************************************************************************/
BOOL MatchCertificate(LPADRBOOK lpAdrBook,
                      LPWABAL lpWabal,
                      DWORD  cbEntryID,
                      LPBYTE lpbEntryID,
                      THUMBBLOB * pSenderThumbprint,
                      LPMAILUSER * lppMailUser)
{
    HRESULT hr;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjectType;
    ULONG ul;
    LPSPropValue ppv = NULL;
    BOOL fReturn = FALSE;


    if (HR_FAILED(hr = lpAdrBook->OpenEntry(cbEntryID, (LPENTRYID)lpbEntryID, NULL, MAPI_MODIFY, &ulObjectType, (LPUNKNOWN *)&(lpMailUser))))
    {
        Assert(FALSE);
        goto exit;
    }

    if (HR_FAILED(hr = lpMailUser->GetProps((LPSPropTagArray)&ptaCert, 0, &ul, &ppv)))
        // Shouldn't happen, but if it does, we don't have a ppv
        goto exit;

    fReturn = IsThumbprintInMVPBin(ppv[0], pSenderThumbprint, NULL, NULL, NULL, NULL);

exit:
    if (ppv)
        lpWabal->FreeBuffer(ppv);
    if (lpMailUser)
    {
        if (lppMailUser && fReturn)
            *lppMailUser = lpMailUser;
        else
            lpMailUser->Release();
    }
    else if (lppMailUser)
        *lppMailUser = NULL;

    return(fReturn);
}


/***************************************************************************

    Name      : InitPropertyRestriction

    Purpose   : Fills in the property restriction structure

    Parameters: lpsres -> SRestriction to fill in
                lpspv -> property value structure for this property restriction

    Returns   : none

    Comment   :

***************************************************************************/
void InitPropertyRestriction(LPSRestriction lpsres, LPSPropValue lpspv)
{
    lpsres->rt = RES_PROPERTY;    // Restriction type Property
    lpsres->res.resProperty.relop = RELOP_EQ;
    lpsres->res.resProperty.ulPropTag = lpspv->ulPropTag;
    lpsres->res.resProperty.lpProp = lpspv;
}


/***************************************************************************

    Name      : FreeProws

    Purpose   : Destroys an SRowSet structure.

    Parameters: prows -> row set to free

    Returns   : none

    Comment   :

***************************************************************************/
void FreeProws(LPWABAL lpWabal, LPSRowSet prows)
{
    register ULONG irow;

    if (prows)
    {
        for (irow = 0; irow < prows->cRows; ++irow)
            if (prows->aRow[irow].lpProps)
                lpWabal->FreeBuffer(prows->aRow[irow].lpProps);
        lpWabal->FreeBuffer(prows);
    }
}


/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpWabal -> Wabal object with allocator functions
                lpaProps -> array of properties
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string
                fNoDuplicates = TRUE if we should do nothing on duplicate adds
                fCaseSensitive = TRUE if the duplicate check should be case sensitive

    Returns   : HRESULT
                    S_DUPLICATE_FOUND if we didn't add because of a duplicate

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(LPWABAL lpWabal, LPSPropValue lpaProps, DWORD index, LPWSTR lpwszNew,
            BOOL fNoDuplicates, BOOL fCaseSensitive)
{
    SWStringArray UNALIGNED *lprgwszOld = NULL; // old SString array
    LPWSTR         *lppwszNew = NULL;      // new prop array
    LPWSTR         *lppwszOld = NULL;      // old prop array
    ULONG           cbMVP = 0;
    ULONG           cExisting = 0;
    LPBYTE          lpNewTemp = NULL;
    HRESULT         hResult = hrSuccess;
    SCODE           sc = SUCCESS_SUCCESS;
    ULONG           i;
    ULONG           cbNew;

    cbNew = lpwszNew ? (lstrlenW(lpwszNew) + 1)*sizeof(*lpwszNew) : 0;

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index]))
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(MV_FLAG|PT_UNICODE, PROP_ID(lpaProps[index].ulPropTag));
    else
    {
        // point to the structure in the prop array.
        lprgwszOld = &(lpaProps[index].Value.MVszW);
        lppwszOld = lprgwszOld->lppszW;

        cExisting = lprgwszOld->cValues;
        cbMVP = cExisting * sizeof(LPWSTR);

        // Check for duplicates
        if (fNoDuplicates)
        {
            for (i = 0; i < cExisting; i++)
                if (fCaseSensitive ? (! StrCmpW(lpwszNew, lppwszOld[i])) : (! StrCmpIW(lpwszNew, lppwszOld[i])))
                {
                    DOUTL(DOUTL_CRYPT,"AddPropToMVPStringfound duplicate.\n");
                    return(S_DUPLICATE_FOUND);
                }
        }
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPWSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = lpWabal->AllocateMore(cbMVP, lpaProps, (LPVOID *)&lppwszNew))
    {
        DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++)
        // Copy this property value to the MVP
        lppwszNew[i] = lppwszOld[i];

    // Add the new property value
    // Allocate room for it
    if (cbNew)
    {
        if (sc = lpWabal->AllocateMore(cbNew, lpaProps, (LPVOID *)&(lppwszNew[i])))
        {
            DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbNew, sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        StrCpyW(lppwszNew[i], lpwszNew);

        lpaProps[index].Value.MVszW.lppszW= lppwszNew;
        lpaProps[index].Value.MVszW.cValues = cExisting + 1;

    }
    else
        lppwszNew[i] = NULL;

    return(hResult);
}


/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew
                fNoDuplicates = TRUE if we should not add duplicates

    Returns   : HRESULT
                    S_DUPLICATE_FOUND if we didn't add because of a duplicate

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(LPWABAL lpWabal, LPSPropValue lpaProps, DWORD index, LPVOID lpNew,
            ULONG cbNew, BOOL fNoDuplicates)
{
    SBinaryArray UNALIGNED * lprgsbOld = NULL;
    SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;

    // Find the size of any existing MVP entries
    if (PT_ERROR == PROP_TYPE(lpaProps[index].ulPropTag))
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    else
    {
        // point to the structure in the prop array.
        lprgsbOld = &(lpaProps[index].Value.MVbin);
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;

        // Check for duplicates
        if (fNoDuplicates)
        {
            for (i = 0; i < cExisting; i++)
                if (cbNew == lpsbOld[i].cb && !memcmp(lpNew, lpsbOld[i].lpb, cbNew))
                {
                    DOUTL(DOUTL_CRYPT,"AddPropToMVPBin found duplicate.\n");
                    return(S_DUPLICATE_FOUND);
                }
        }

        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = lpWabal->AllocateMore(cbMVP, lpaProps, (LPVOID*)&lpsbNew))
    {
        DOUTL(DOUTL_CRYPT,"AddPropToMVPBin allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++)
    {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = lpWabal->AllocateMore(cbNew, lpaProps, (LPVOID*)&(lpsbNew[i].lpb)))
    {
        DOUTL(DOUTL_CRYPT,"AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}


/***************************************************************************

    Name      : RemoveValueFromMVPBinByIndex

    Purpose   : Remove a value from a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                PropIndex = index in lpaProps of MVP
                ValueIndex = index in MVP of value to remove

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT RemovePropFromMVBinByIndex(LPSPropValue lpaProps, DWORD cProps, DWORD PropIndex, DWORD ValueIndex)
{
    SBinaryArray UNALIGNED * lprgsb = NULL;
    LPSBinary lpsb = NULL;
    ULONG cbTest;
    LPBYTE lpTest;
    ULONG cExisting;

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[PropIndex]))
        // Property value doesn't exist.
        return(ResultFromScode(MAPI_W_PARTIAL_COMPLETION));

    // point to the structure in the prop array.
    lprgsb = &(lpaProps[PropIndex].Value.MVbin);
    lpsb = lprgsb->lpbin;

    cExisting = lprgsb->cValues;
    Assert(ValueIndex < cExisting);

    // Look for value
    lpsb = &(lprgsb->lpbin[ValueIndex]);

    // Decrment number of values
    if (--lprgsb->cValues == 0)
        // If there are none left, mark the prop as an error
        lpaProps[PropIndex].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpaProps[PropIndex].ulPropTag));
    else
        // Copy the remaining entries down over it.
        if (ValueIndex + 1 < cExisting) // Are there any higher entries to copy?
            CopyMemory(lpsb, lpsb + 1, ((cExisting - ValueIndex) - 1) * sizeof(SBinary));

    return S_OK;
}

#ifdef DEBUG
void DebugFileTime(FILETIME ft)
{
    SYSTEMTIME st = {0};
    TCHAR szBuffer[256];

    FileTimeToSystemTime(&ft, &st);
    wsprintf(szBuffer, "%02d/%02d/%04d  %02d:%02d:%02d\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
    OutputDebugString(szBuffer);
}
#endif

/***************************************************************************

    Name      : HrAddCertToWabContact

    Purpose   : Update a certificate in a particular wab contact

    Parameters: lpWabal -> WABAL for WAB function access
                lpAdrBook -> WAB ADRBOOK object
                cbEntryID = size of lpEntryID
                lpEntryID = entry id to operate on
                pThumbprint -> certificate thumbprint
                szEmailAddress -> email address to search for (optional)
                szCertEmailAddress -> email address from the cert
                pblSymCaps -> symcap blob (will be calculated if thumbprint is NULL)
                ftSigningTime = signing time (will be calculated if thumbprint is NULL)
                dwFlags = WFF_SHOWUI (we are allowed to show UI)

    Returns   : HRESULT

    Comment   : dwFlags is currently ignored

***************************************************************************/
HRESULT HrAddCertToWabContact(HWND hwnd, LPWABAL lpWabal, LPADRBOOK lpAdrBook, ULONG cbEntryID, LPBYTE lpEntryID,
                THUMBBLOB * pThumbprint, LPWSTR lpwszEmailAddress, LPWSTR lpwszCertEmailAddress, BLOB *pblSymCaps,
                FILETIME ftSigningTime, DWORD dwFlags)
{
    HRESULT         hr;
    ULONG           ulObjectType;
    LPMAILUSER      lpMailUser = NULL;
    ULONG           cProps = 0;
    LPSPropValue    ppv = NULL;
    ULONG           MVPindex;
    BOOL            fExistingSymCaps,
                    fMsgSymCaps,
                    fExistingSigningTime,
                    fMsgSigningTime,
                    fExists,
                    fExisted,
                    fDefault = FALSE,
                    fNewerThanExistingTime,
                    fNoCert;
    BLOB            blExistingSymCaps = {0};
    FILETIME        ftExistingSigningTime;
    UNALIGNED BYTE * lpCertProp = NULL;
    ULONG           cbCertProp;

    Assert(lpWabal);
    Assert(lpEntryID);
    Assert(pThumbprint);
    Assert(lpwszEmailAddress || lpwszCertEmailAddress);

    hr = lpAdrBook->OpenEntry(cbEntryID, (LPENTRYID)lpEntryID, NULL, MAPI_MODIFY, &ulObjectType, (LPUNKNOWN *)&(lpMailUser));
    if (HR_FAILED(hr))
        goto exit;

    hr = lpMailUser->GetProps((LPSPropTagArray)&ptaResolve, 0, &cProps, &ppv);
    if (HR_FAILED(hr) || ! cProps || ! ppv || PROP_ERROR(ppv[0]))
        goto exit;

    // Do we need to remove the existing value?  Only if it has the same
    // thumbprint, has a sMimeCapability and a signing time < the signing time
    // input and the sMIMEcapability is different.

    // The returned data is not reallocated, but the blobs point into the property data
    fNoCert = PROP_ERROR(ppv[irsPR_USER_X509_CERTIFICATE]);

    fExisted = fExists = IsThumbprintInMVPBin(ppv[irsPR_USER_X509_CERTIFICATE], pThumbprint, &MVPindex,
            &blExistingSymCaps, &ftExistingSigningTime, &fDefault);

    if (fExists)
    {
        // Create a bunch of flags to aid in deciding when to replace a cert and when to add one.
        fExistingSymCaps = blExistingSymCaps.cbSize;
        fMsgSymCaps = pblSymCaps && pblSymCaps->cbSize;
        fExistingSigningTime = ftExistingSigningTime.dwLowDateTime || ftExistingSigningTime.dwHighDateTime;
        fMsgSigningTime = ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime;

#ifdef DEBUG
        DebugFileTime(ftSigningTime);
        DebugFileTime(ftExistingSigningTime);
#endif

        fNewerThanExistingTime = (CompareFileTime(&ftSigningTime, &ftExistingSigningTime) > 0);

        if (fExists && fMsgSymCaps &&
            (! fExistingSymCaps ||
            fMsgSigningTime && !fExistingSigningTime ||
            fMsgSigningTime && fExistingSigningTime && fNewerThanExistingTime))
        {
            RemovePropFromMVBinByIndex(ppv, cProps, irsPR_USER_X509_CERTIFICATE, MVPindex);
            fExists = FALSE;
        }
    }

    if (!fExists)
    {
        // Build up the PR_USER_X509_CERTIFICATE data
        if (HR_FAILED(hr = HrBuildCertSBinaryData(fNoCert || (fExisted && fDefault), pThumbprint, pblSymCaps,
            ftSigningTime, &lpCertProp, &cbCertProp)))
        {
            goto exit;
        }

        // Add the new thumbprint to PR_USER_X509_CERTIFICATE
        if (HR_FAILED(hr = AddPropToMVPBin(lpWabal, ppv, irsPR_USER_X509_CERTIFICATE, lpCertProp, cbCertProp, TRUE)))
            goto exit;

        // Make sure that the e-mail addresses are in this contact.
        // NOTE: Add szEmailAddress BEFORE szCertEmailAddress!
        if (lpwszEmailAddress)
        {
            if (! AddPropToMVPString(lpWabal, ppv, irsPR_CONTACT_EMAIL_ADDRESSES, lpwszEmailAddress, TRUE, FALSE))
                // If we succeeded in adding an email address, we must match it with an
                // address type.
                AddPropToMVPString(lpWabal, ppv, irsPR_CONTACT_ADDRTYPES, (LPWSTR)c_wszSMTP, FALSE, FALSE);
            // Don't care on failure
        }

        if (lpwszCertEmailAddress)
        {
            if (! AddPropToMVPString(lpWabal, ppv, irsPR_CONTACT_EMAIL_ADDRESSES, lpwszCertEmailAddress, TRUE, FALSE))
                // If we succeeded in adding an email address, we must match it with an address type.
                AddPropToMVPString(lpWabal, ppv, irsPR_CONTACT_ADDRTYPES, (LPWSTR)c_wszSMTP, FALSE, FALSE);
            // Don't care on failure
        }

        // Make sure there is a PR_EMAIL_ADDRESS
        if (PROP_ERROR(ppv[irsPR_EMAIL_ADDRESS]))
        {
            ppv[irsPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS_W;
            ppv[irsPR_EMAIL_ADDRESS].Value.lpszW = lpwszEmailAddress ? lpwszEmailAddress : lpwszCertEmailAddress;
        }

        // Make sure there is a PR_CONTACT_DEFAULT_ADDRESS_INDEX
        if (PROP_ERROR(ppv[irsPR_CONTACT_DEFAULT_ADDRESS_INDEX]))
        {
            ppv[irsPR_CONTACT_DEFAULT_ADDRESS_INDEX].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            ppv[irsPR_CONTACT_DEFAULT_ADDRESS_INDEX].Value.ul = 0;
        }

        hr = lpMailUser->SetProps(cProps, ppv, NULL);
        if (SUCCEEDED(hr))
            hr = lpMailUser->SaveChanges(KEEP_OPEN_READWRITE);
        if (HR_FAILED(hr))
            goto exit;
    }

exit:
    SafeMemFree(lpCertProp);

    if (ppv)
        lpWabal->FreeBuffer(ppv);
    ReleaseObj(lpMailUser);
    return(hr);
}


/***************************************************************************

    Name      : HrAddCertToWab

    Purpose   : Add or update a certificate in the wab

    Parameters: hwnd = parent window handle
                lpWabal -> WABAL for WAB function access
                pThumbprint -> certificate thumbprint (optional)
                pcCertContext -> certificate context (optional, if not supplied, we
                  will find it based on the pSenderThumbprint)
                szEmailAddress -> email address to search for (optional)
                szDisplayName -> display name for NEW contacts (optional)
                pblSymCaps -> symcap blob (will be calculated if thumbprint is NULL)
                ftSigningTime = signing time (will be calculated if thumbprint is NULL)
                dwFlags = WFF_SHOWUI (we are allowed to show UI)
                         WFF_CREATE (we are allowed to create an entry if not found)

    Returns   : HRESULT

    Comment   : Must have either pSenderThumbprint or pcCertContext.

                This function will search the address book for all occurences of
                the email addresses specified (szEmailAddress and the one in the cert)
                and and will add or update the cert thumbprint and associated symcap
                and signing time to each entry found.

***************************************************************************/
HRESULT HrAddCertToWab(HWND hwnd, LPWABAL lpWabal, THUMBBLOB *pThumbprint, PCCERT_CONTEXT pcCertContext,
        LPWSTR lpwszEmailAddress, LPWSTR lpwszDisplayName, BLOB *pblSymCaps, FILETIME ftSigningTime, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    ULONG           ulObjectType;
    ULONG           cbWABEID;
    LPENTRYID       lpWABEID = NULL;
    LPABCONT        lpABCont = NULL;
    LPMAPITABLE     lpContentsTable = NULL;
    LPSRowSet       lpRow = NULL;
    SRestriction    res;
    SRestriction    resOr[4];        // array for OR restrictions
    SPropValue      propEmail1, propEmail2, propEmails1, propEmails2;
    ULONG           resCount;
    LPADRBOOK       lpAdrBook = NULL;   // Don't Release!
    HCERTSTORE      hCertStore = NULL;
    PCCERT_CONTEXT  pcCertContextLocal = NULL;
    LPWSTR          pwszCertEmailAddress = NULL;
    THUMBBLOB       ThumbprintLocal = {0};
    LPWABOBJECT     lpWabObject;
    LPMAILUSER      lpMailUser = NULL;
    ULONG           cProps = 0;
    LPSPropValue    ppv = NULL;
    ULONG           ulRowCount = 0;
    LPSTR           pszCertEmail = NULL;

    Assert(pcCertContext || pThumbprint);
    if (! pcCertContext && !pThumbprint)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the email address from the cert
    if (! pcCertContext)
    {
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                   CERT_SYSTEM_STORE_CURRENT_USER, c_szWABCertStore);
        if (hCertStore)
        {
            // Find the cert in the store
            if (pcCertContextLocal =  CertFindCertificateInStore( hCertStore, X509_ASN_ENCODING, 0, CERT_FIND_HASH, (void *)pThumbprint, NULL))
                pcCertContext = pcCertContextLocal;
        }
    }
    if (pcCertContext)
    {
        pszCertEmail = SzGetCertificateEmailAddress(pcCertContext);   // in msoert

        pwszCertEmailAddress = PszToUnicode(CP_ACP, pszCertEmail);
        if (!pwszCertEmailAddress && pszCertEmail)
            IF_NULLEXIT(NULL);

        if (pcCertContextLocal)
            CertFreeCertificateContext(pcCertContextLocal);

        // Make sure we have a thumbprint
        if (! pThumbprint)
        {
            ThumbprintLocal.pBlobData = (BYTE *)PVGetCertificateParam(pcCertContext, CERT_HASH_PROP_ID, &ThumbprintLocal.cbSize);
            if (ThumbprintLocal.pBlobData)
                pThumbprint = &ThumbprintLocal;
        }
    }
    if (hCertStore)
        CertCloseStore(hCertStore, 0);

    // Must have an email address and a thumbprint
    if (! (pwszCertEmailAddress || lpwszEmailAddress) || ! pThumbprint)
    {
        hr = E_INVALIDARG;
        goto exit;
    }


    // Get Address Book object
    if (! (lpAdrBook = lpWabal->GetAdrBook())) // Don't release this!
    {
        Assert(lpAdrBook);
        goto exit;
    }

    // Open the contents table on the local WAB.  This will be a time hit with a large WAB.
    if (HR_FAILED(hr = lpAdrBook->GetPAB(&cbWABEID, &lpWABEID)))
        goto exit;      // extremely unlikely failure

    if (HR_FAILED(hr = lpAdrBook->OpenEntry(cbWABEID, lpWABEID, NULL, 0, &ulObjectType, (LPUNKNOWN *)&lpABCont)))
        goto exit;

    hr = lpABCont->GetContentsTable((WAB_PROFILE_CONTENTS|MAPI_UNICODE), &lpContentsTable);
    if (SUCCEEDED(hr))
    {
        // Set the column set
        hr = lpContentsTable->SetColumns((LPSPropTagArray)&ptaResolve, 0);
        if (HR_FAILED(hr))
            goto exit;

        // Set up the property values for restrictions
        // At least ONE of these will be filled in.
        if (pwszCertEmailAddress)
        {
            propEmail1.ulPropTag = PR_EMAIL_ADDRESS_W;
            propEmail1.Value.lpszW = pwszCertEmailAddress;
            propEmails1.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES_W;
            propEmails1.Value.MVszW.cValues = 1;
            propEmails1.Value.MVszW.lppszW = &pwszCertEmailAddress;
        }
        if (lpwszEmailAddress)
        {
            propEmail2.ulPropTag = PR_EMAIL_ADDRESS_W;
            propEmail2.Value.lpszW = lpwszEmailAddress;
            propEmails2.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES_W;
            propEmails2.Value.MVszW.cValues = 1;
            propEmails2.Value.MVszW.lppszW = &lpwszEmailAddress;
        }

        resCount = 0;
        res.rt = RES_OR;
        res.res.resOr.lpRes = resOr;

        if (pwszCertEmailAddress)
        {
            // PR_CONTACT_EMAIL_ADDRESSES match for cert email address
            resOr[resCount].rt = RES_CONTENT;
            resOr[resCount].res.resContent.ulFuzzyLevel = FL_IGNORECASE | FL_FULLSTRING;
            resOr[resCount].res.resContent.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES_W;
            resOr[resCount++].res.resContent.lpProp = &propEmails1;

            // PR_EMAIL_ADDRESS for cert email address
            InitPropertyRestriction(&(resOr[resCount++]), &propEmail1);
        }

        if (lpwszEmailAddress && (!pwszCertEmailAddress || StrCmpIW(lpwszEmailAddress, pwszCertEmailAddress)))
        {
            // PR_CONTACT_EMAIL_ADDRESSES match for specified email address
            resOr[resCount].rt = RES_CONTENT;
            resOr[resCount].res.resContent.ulFuzzyLevel = FL_IGNORECASE | FL_FULLSTRING;
            resOr[resCount].res.resContent.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES_W;
            resOr[resCount++].res.resContent.lpProp = &propEmails2;

            // PR_EMAIL_ADDRESS for specified email address
            InitPropertyRestriction(&(resOr[resCount++]), &propEmail2);
        }
        Assert(resCount);

        res.res.resOr.cRes = resCount;

        // Perform the restriction.
        if (HR_FAILED(hr = lpContentsTable->Restrict(&res, 0)))
            goto exit;

        // Find any matches?
        if (HR_FAILED(hr = lpContentsTable->GetRowCount(0, &ulRowCount)))
            goto exit;
    }

    if (ulRowCount)
    {
        Assert(lpContentsTable);
        // For each one, update the cert properties.
        do
        {
            if (lpRow)
            {
                FreeProws(lpWabal, lpRow);
                lpRow = NULL;
            }
            lpContentsTable->QueryRows(1, 0, &lpRow);
            if (lpRow)
            {
                if (lpRow->cRows)
                {
                    // Update the cert props for this contact
                    hr = HrAddCertToWabContact(hwnd, lpWabal, lpAdrBook,
                                lpRow->aRow[0].lpProps[irsPR_ENTRYID].Value.bin.cb,
                                lpRow->aRow[0].lpProps[irsPR_ENTRYID].Value.bin.lpb,
                                pThumbprint, lpwszEmailAddress, pwszCertEmailAddress,
                                pblSymCaps, ftSigningTime, dwFlags);
                    if (HR_FAILED(hr))
                        break;
                }
                else
                {
                    FreeProws(lpWabal, lpRow);
                    lpRow = NULL;
                }
            }
        } while (lpRow);

    }
    else if (dwFlags & WFF_CREATE)
    {
        // Need to create a new entry and set it's properties
        if (! (lpWabObject = lpWabal->GetWABObject()))      // Don't release this!
        {
            Assert(lpWabObject);
            hr = E_INVALIDARG;
            goto exit;
        }

        hr = HrWABCreateEntry(lpAdrBook, lpWabObject, lpwszDisplayName, NULL, 0, &lpMailUser);

        if (lpMailUser)
        {
            // Get the ENTRYID for this object
            hr = lpMailUser->GetProps((LPSPropTagArray)&ptaEntryID, 0, &cProps, &ppv);
            ReleaseObj(lpMailUser);
            if (HR_FAILED(hr) || ! cProps || ! ppv || PROP_ERROR(ppv[0]))
                goto exit;

            // Update the cert props and email addresses for this contact
            hr = HrAddCertToWabContact(hwnd, lpWabal, lpAdrBook, ppv[0].Value.bin.cb, ppv[0].Value.bin.lpb,
                        pThumbprint, lpwszEmailAddress, pwszCertEmailAddress, pblSymCaps, ftSigningTime, dwFlags);

            if (HR_FAILED(hr))
                goto exit;
        }
    }
    else
        hr = ResultFromScode(MAPI_E_NOT_FOUND);

exit:
    if (ppv)
        lpWabal->FreeBuffer(ppv);
    if (lpRow)
        FreeProws(lpWabal, lpRow);
    if (lpWABEID)
        lpWabal->FreeBuffer(lpWABEID);
    ReleaseObj(lpABCont);
    ReleaseObj(lpContentsTable);
    MemFree(ThumbprintLocal.pBlobData);
    MemFree(pwszCertEmailAddress);
    MemFree(pszCertEmail);
    return(hr);
}


/***************************************************************************

    Name      : HrAddSenderCertToWab

    Purpose   : Add or update a sender's certificate in the wab

    Parameters: hwnd = parent window handle
                pMsg -> mimeole msg
                lpWabal -> wabal for this message (will be calculated if NULL)
                pSenderThumbprint -> sender's thumbprint (will be calculated if NULL)
                pblSymCaps -> symcap blob (will be calculated if thumbprint is NULL)
                ftSigningTime = signing time (will be calculated if thumbprint is NULL)
                dwFlags = WFF_SHOWUI (we are allowed to show UI)
                         WFF_CREATE (we are allowed to create an entry if
                           not found)

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrAddSenderCertToWab(HWND hwnd, LPMIMEMESSAGE pMsg, LPWABAL lpWabal,
                             THUMBBLOB *pSenderThumbprint, BLOB *pblSymCaps,
                             FILETIME ftSigningTime, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    BOOL            fFound;
    ADRINFO         rAdrInfo;
    ULONG           cProps;
    THUMBBLOB       tbThumbprint = {0};
    BLOB            blSymCaps = {0};
    LPWABAL         lpLocalWabal = NULL;
    BOOL            fLocalCert = FALSE;
    CRYPT_HASH_BLOB hash;
    HCERTSTORE      hcsAddressBook = NULL;
    HCERTSTORE      hcsCA = NULL;
    HCERTSTORE      hcsMsg = NULL;
    IMimeBody *     pBody = NULL;
    PCCERT_CONTEXT  pcSignerCert = NULL;
    PROPVARIANT     var;
    HBODY           hBody = NULL;

    // If we don't have all the required inputs, get them.
    if (! pSenderThumbprint)
    {
        Assert(! pblSymCaps);

        // Point the parameters to local blobs
        pblSymCaps = &blSymCaps;
        pSenderThumbprint = &tbThumbprint;
        hr = GetSignerEncryptionCert(pMsg, NULL, pSenderThumbprint, pblSymCaps,
                                     &ftSigningTime);
        if (HR_FAILED(hr))
            goto exit;

        fLocalCert = TRUE;

        if (! pSenderThumbprint || ! pSenderThumbprint->cbSize)
        {
            // No cert.  Give it up.
            hr = E_FAIL;
            goto exit;
        }
    }

    if (! lpWabal)
    {
        hr = HrGetWabalFromMsg(pMsg, &lpLocalWabal);
        if (HR_FAILED(hr))
            goto exit;
        lpWabal = lpLocalWabal;
    }

    if (!(lpWabal && pMsg && pSenderThumbprint))
    {
        AssertSz(pSenderThumbprint, "Null thumbprint");
        hr = E_FAIL;
        goto exit;
    }

    // Get the message certs into AddressBook and CA CAPI stores
    if(FAILED(hr = HrGetInnerLayer(pMsg, &hBody)))
        goto exit;

    hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
    if (SUCCEEDED(hr))
    {
        hcsAddressBook = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                            CERT_SYSTEM_STORE_CURRENT_USER, c_szWABCertStore);

#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            pcSignerCert = (PCCERT_CONTEXT)(var.pulVal);
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            Assert(VT_UI4 == var.vt);

            pcSignerCert = (PCCERT_CONTEXT) var.ulVal;
#endif  // _WIN64

            if (pcSignerCert)
            {
                if (hcsAddressBook)
                {
                    CertAddCertificateContextToStore(hcsAddressBook, pcSignerCert, CERT_STORE_ADD_REPLACE_EXISTING, NULL);
                }
                CertFreeCertificateContext(pcSignerCert);
            }
        }

        // Get the certbag property which contains the CA chain
#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
        {
            hcsMsg = (HCERTSTORE)(var.pulVal);
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
        {
            hcsMsg = (HCERTSTORE) var.ulVal;
#endif  // _WIN64
            if (hcsMsg)                    // message store containing certs
            {
                // Add the CA certs
                hcsCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                    CERT_SYSTEM_STORE_CURRENT_USER, c_szCACertStore);
                if (hcsCA)
                {
                    HrSaveCACerts(hcsCA, hcsMsg);
                    CertCloseStore(hcsCA, 0);
                }

                //  We have a thumbprint, we need to get that cert and add it to the
                //      address book store.

                hash.cbData = pSenderThumbprint->cbSize;
                hash.pbData = pSenderThumbprint->pBlobData;
                pcSignerCert = CertFindCertificateInStore(hcsMsg, X509_ASN_ENCODING, 0,
                                                    CERT_FIND_SHA1_HASH, &hash, NULL);
                if (pcSignerCert != NULL)
                {
                    CertAddCertificateContextToStore(hcsAddressBook, pcSignerCert,
                                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                                     NULL);
                    CertFreeCertificateContext(pcSignerCert);
                }

                CertCloseStore(hcsMsg, 0);

            }
        }

        if (hcsAddressBook)
            CertCloseStore(hcsAddressBook, 0);
        SafeRelease(pBody);
    }

    fFound = lpWabal->FGetFirst(&rAdrInfo);
    while (fFound)
    {
        // Get a sender (there may be more than one)
        if (MAPI_ORIG == rAdrInfo.lRecipType && (rAdrInfo.lpwszDisplay || rAdrInfo.lpwszAddress))
        {
            hr = HrAddCertToWab(hwnd, lpWabal, pSenderThumbprint, NULL, rAdrInfo.lpwszAddress,
                    rAdrInfo.lpwszDisplay, pblSymCaps, ftSigningTime, dwFlags);
            if (HR_FAILED(hr))
                goto exit;
        }

        // Get the next address
        fFound = lpWabal->FGetNext(&rAdrInfo);
    }  // while fFound

exit:
    SafeRelease(lpLocalWabal);
    if (fLocalCert)
    {
        if (tbThumbprint.pBlobData)
            MemFree(tbThumbprint.pBlobData);

        if (blSymCaps.pBlobData)
            MemFree(blSymCaps.pBlobData);
    }

    if ((dwFlags & WFF_SHOWUI) && HR_FAILED(hr))
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddCertToWAB), hr);

    return(hr);
}

BOOL CertFilterFunction(PCCERT_CONTEXT pCertContext, LPARAM dwEmailAddr, DWORD, DWORD)
{
    // return TRUE to show, FALSE to hide
    BOOL fRet = TRUE;
    ACCTFILTERINFO * pFilterInfo = (ACCTFILTERINFO *) dwEmailAddr;

    PCCERT_CONTEXT *rgCertChain = NULL;
    DWORD           cCertChain = 0;
    const DWORD     dwIgnore = CERT_VALIDITY_NO_CRL_FOUND | CERT_VALIDITY_NO_TRUST_DATA;
    LONG    lRet;

            // return TRUE to show, FALSE to hide
    if(MatchCertEmailAddress(pCertContext, pFilterInfo->szEmail) == FALSE)
        return FALSE;

    DWORD dw = 0;
    if(SUCCEEDED(HrGetCertKeyUsage(pCertContext, &dw)))
    {
        if(pFilterInfo->fEncryption)
        {
            if (!(dw & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                            CERT_KEY_AGREEMENT_KEY_USAGE)))
            {
                return(FALSE);
            }
        }
        else
        {
            if(!(dw & (CERT_DIGITAL_SIGNATURE_KEY_USAGE)))
                return(FALSE);
        }
    }

    DWORD dwErr = DwGenerateTrustedChain(NULL, NULL, pCertContext, dwIgnore, TRUE, &cCertChain, &rgCertChain);
    if (rgCertChain)
    {
        for (cCertChain--; int(cCertChain) >= 0; cCertChain--)
            CertFreeCertificateContext(rgCertChain[cCertChain]);
        MemFree(rgCertChain);
    }

    if(dwErr != 0)
        return(FALSE);

    return(fRet);
}

int GetNumMyCertForAccount(HWND hwnd, IImnAccount * pAccount, BOOL fEncrypt, HCERTSTORE hc, PCCERT_CONTEXT * ppcSave)
{
    HRESULT hr = S_OK;
    ULONG cCerts = 0;
    PCCERT_CONTEXT pcCert = NULL;
    TCHAR szAcctEmailAddress[CCHMAX_EMAIL_ADDRESS + 1] = "";
    HCERTSTORE hcMy = NULL;

    Assert(pAccount);
    if(!hc)
    {
            hcMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
    }
    else
        hcMy = hc;

    if (!hcMy)
        goto Exit;

    // Is there a cert that I can use?  If so, let's go associate it with the
    // account and try again.
    pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szAcctEmailAddress, sizeof(szAcctEmailAddress));

    // Enumerate all certs on this message
    while (pcCert = CertEnumCertificatesInStore(hcMy, pcCert))
    {
        // Does this cert match our account?
        if (MatchCertEmailAddress(pcCert, szAcctEmailAddress))
        {
            // Is it valid and trusted?
            DWORD           dwTrust;
            PCCERT_CONTEXT *rgCertChain = NULL;
            DWORD           cCertChain = 0;
            const DWORD     dwIgnore = CERT_VALIDITY_NO_CRL_FOUND |
                CERT_VALIDITY_NO_TRUST_DATA;


            if(SUCCEEDED(HrGetCertKeyUsage(pcCert, &dwTrust)))
            {
                if(fEncrypt)
                {
                    if (!(dwTrust & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                            CERT_KEY_AGREEMENT_KEY_USAGE)))
                        continue;
                }
                else
                {
                    if(!(dwTrust & (CERT_DIGITAL_SIGNATURE_KEY_USAGE)))
                        continue;
                }
            }

            dwTrust = DwGenerateTrustedChain(hwnd, NULL, pcCert, dwIgnore, TRUE, &cCertChain, &rgCertChain);
            if (!dwTrust)
            {
                cCerts++;
                if(ppcSave)
                {
                    if (cCerts == 1)
                        *ppcSave = (PCERT_CONTEXT)CertDuplicateCertificateContext(pcCert);
                    else if (*ppcSave)
                    {
                        // more than one cert, get rid of the one we saved
                        CertFreeCertificateContext(*ppcSave);
                        *ppcSave = NULL;
                    }
                }
            }
            // clean up the cert chain
            if (rgCertChain)
            {
                for (cCertChain--; int(cCertChain) >= 0; cCertChain--)
                    CertFreeCertificateContext(rgCertChain[cCertChain]);
                MemFree(rgCertChain);
            }
        }
    }
Exit:
    if((hc == NULL) && hcMy)
        CertCloseStore(hcMy, 0);

    return(cCerts);
}

HRESULT _HrFindMyCertForAccount(HWND hwnd, PCCERT_CONTEXT * ppcCertContext, IImnAccount * pAccount, BOOL fEncrypt)
{
    HRESULT hr = S_OK;
    ULONG cCerts = 0;
    HCERTSTORE hcMy = NULL;
    PCCERT_CONTEXT pcSave = NULL;
    TCHAR szAcctEmailAddress[CCHMAX_EMAIL_ADDRESS + 1] = "";

    ACCTFILTERINFO      FilterInfo;

    Assert(pAccount);

    hcMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);
    if (!hcMy)
    {
        hr = E_FAIL;
        goto Exit;
    }

    cCerts = GetNumMyCertForAccount(hwnd, pAccount, fEncrypt, hcMy, &pcSave);

    pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szAcctEmailAddress, sizeof(szAcctEmailAddress));

    if (cCerts > 1)
    {
        // Bring up a cert selector UI for the account
        CERT_SELECT_STRUCT css;
        LPTSTR lpTitle = NULL;
        TCHAR szAcctName[CCHMAX_ACCOUNT_NAME + 1] = "";
        TCHAR szTitleFormat[200] = "%1";
        LPTSTR rgpsz[1] = {szAcctName};

        memset(&css, 0, sizeof(css));

        pcSave = NULL;
        AthLoadString(fEncrypt ? idsSelectEncrCertTitle : idsSelectMyCertTitle, szTitleFormat, ARRAYSIZE(szTitleFormat));

        pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcctName, sizeof(szAcctName));

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY, szTitleFormat, 0, 0,
                      (LPTSTR)&lpTitle, 0, (va_list *)rgpsz);

        css.dwSize = sizeof(css);
        css.hwndParent = hwnd;
        css.hInstance = g_hInst;
        css.szTitle = lpTitle;
        css.arrayCertStore = &hcMy;
        css.cCertStore = 1;
        css.szPurposeOid = szOID_PKIX_KP_EMAIL_PROTECTION;
        css.arrayCertContext = &pcSave;
        css.cCertContext = 1;
        FilterInfo.fEncryption = fEncrypt;
        FilterInfo.dwFlags = 0;
        FilterInfo.szEmail = szAcctEmailAddress;
        css.lCustData = (LPARAM)(&FilterInfo);
        css.pfnFilter = CertFilterFunction;

        if (CertSelectCertificate(&css) && pcSave)
            cCerts = 1;
        else
            hr = MAPI_E_USER_CANCEL;

        if (lpTitle)
            LocalFree(lpTitle); // Note, this is allocated by WIN32 function: FormatMessage

    }
    else if (cCerts == 0)
        // No matches.
        if(fEncrypt)
            hr = MIME_E_SECURITY_NOCERT;
        else
            hr = MIME_E_SECURITY_NOSIGNINGCERT;

    if (cCerts == 1)
    {
        PCCERT_CONTEXT pcCertContext = NULL;
        THUMBBLOB tbSender = {0, 0};

        // Found a cert.  Associate it with the account!
        // Get the thumbprint
        tbSender.pBlobData = (BYTE *)PVGetCertificateParam(pcSave, CERT_HASH_PROP_ID, &tbSender.cbSize);
        if (tbSender.pBlobData && tbSender.cbSize)
        {
            hr = pAccount->SetProp((fEncrypt ? AP_SMTP_ENCRYPT_CERT: AP_SMTP_CERTIFICATE), tbSender.pBlobData, tbSender.cbSize);
            hr = pAccount->SaveChanges();
        }

        SafeMemFree(tbSender.pBlobData);
        if (ppcCertContext)
            *ppcCertContext = pcSave;
        else
            CertFreeCertificateContext(pcSave);
    }

Exit:
    if (hcMy)
        CertCloseStore(hcMy, 0);
    return(hr);
}


ULONG GetHighestEncryptionStrength(void)
{
    static ULONG ulHighestStrength = 0;

    if (! ulHighestStrength)
        // we haven't figured it out yet.  Ask MimeOle what's highest.
        MimeOleAlgStrengthFromSMimeCap(NULL, 0, TRUE, &ulHighestStrength);
    return(ulHighestStrength);
}


// Largest symcap is currently 0x4E with 3DES, RC2/128, RC2/64, DES, RC2/40 and SHA-1.
// You may want to bump up the size when FORTEZZA algorithms are supported.
#define CCH_BEST_SYMCAP 0x50

HRESULT HrGetHighestSymcaps(LPBYTE * ppbSymcap, LPULONG pcbSymcap)
{
    HRESULT hr=S_OK;
    LPVOID pvSymCapsCookie = NULL;
    LPBYTE pbEncode = NULL;
    ULONG cbEncode = 0;
    DWORD dwBits;
    // The MimeOleSMimeCapsFull call is quite expensive.  The results are always
    // the same during a session.  (They can only change with software upgrade.)
    // Cache the results here for better performance.
    static BYTE szSaveBestSymcap[CCH_BEST_SYMCAP];
    static ULONG cbSaveBestSymcap = 0;

    if (cbSaveBestSymcap == 0)
    {
        // Init with no symcap gives max allowed by providers
        hr = MimeOleSMimeCapInit(NULL, NULL, &pvSymCapsCookie);
        if (FAILED(hr))
            goto exit;

        if (pvSymCapsCookie)
        {
            // Finish up with SymCaps
            MimeOleSMimeCapsFull(pvSymCapsCookie, TRUE, FALSE, pbEncode, &cbEncode);

            if (cbEncode)
            {
                if (! MemAlloc((LPVOID *)&pbEncode, cbEncode))
                    cbEncode = 0;
                else
                {
                    hr = MimeOleSMimeCapsFull(pvSymCapsCookie, TRUE, FALSE, pbEncode, &cbEncode);
                    if (SUCCEEDED(hr))
                    {
                        // Save this symcap in the static array for next time
                        // Only if we have room!
                        if (cbEncode <= CCH_BEST_SYMCAP)
                        {
                            memcpy(szSaveBestSymcap, pbEncode, cbEncode);
                            cbSaveBestSymcap = cbEncode;
                        }
                    }
                }
            }
            SafeMemFree(pvSymCapsCookie);
        }

    }
    else
    {
        // We have saved the best in the static array.  Avoid the time intensive
        // MimeOle query.
        cbEncode = cbSaveBestSymcap;
        if (! MemAlloc((LPVOID *)&pbEncode, cbEncode))
            cbEncode = 0;
        else
            memcpy(pbEncode, szSaveBestSymcap, cbEncode);
    }

exit:
    if (! pbEncode)
    {
        // Hey, there should ALWAYS be at least RC2 (40 bit).  What happened?
        AssertSz(cbEncode, "MimeOleSMimeCapGetEncAlg gave us no encoding algorithm");

        // Try to fix it up as best you can.  Stick in the RC2 value.
        cbEncode = cbRC2_40_ALGORITHM_ID;
        if (MemAlloc((LPVOID *)&pbEncode, cbEncode))
        {
            memcpy(pbEncode, (LPBYTE)c_RC2_40_ALGORITHM_ID, cbEncode);
            hr = S_OK;
        }
    }
    if (cbEncode && pbEncode)
    {
        *pcbSymcap = cbEncode;
        *ppbSymcap = pbEncode;
    }
    return(hr);
}

// Not in use anymore
#if 0
HRESULT ShowSecurityPopup(HWND hwnd, DWORD cmdID, POINT *pPoint, IMimeMessage *pMsg)
{
    HRESULT     hr = S_OK;
    HMENU       hMenu;
    INT         id;
    BOOL        fDisableCertMenus = TRUE;
    IMimeBody  *pRoot = NULL;
    PROPVARIANT var;
    TCHAR       szT[CCHMAX_STRINGRES];

    AssertSz(pMsg, "Didn't expect to get here without a pMsg.");

    hMenu = LoadPopupMenu(IDR_SECURE_MESSAGE_POPUP);
    if (hMenu)
    {
        if ((OECSECCMD_ENCRYPTED == cmdID))
        {
            // remove the edit-trust menu
            RemoveMenu(hMenu, ID_EDIT_TRUST, MF_BYCOMMAND);
            RemoveMenu(hMenu, ID_SEPARATOR_1, MF_BYCOMMAND);
            AthLoadString(idsViewEncryptID, szT, ARRAYSIZE(szT));
            ModifyMenu(hMenu, ID_DIGITAL_ID, MF_BYCOMMAND | MF_STRING, ID_ENCRYPT_ID, szT);
        }

        hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void**)&pRoot);
        if (SUCCEEDED(hr))
        {
#ifdef _WIN64
            DWORD dwOption = (OECSECCMD_ENCRYPTED == cmdID) ? OID_SECURITY_CERT_DECRYPTION_64 : OID_SECURITY_CERT_SIGNING_64;
            hr = pRoot->GetOption(dwOption, &var);
            if (SUCCEEDED(hr))
            {
                Assert(VT_UI8 == var.vt);
                if ((PCCERT_CONTEXT )(var.pulVal))
                {
                    fDisableCertMenus = FALSE;
                    CertFreeCertificateContext((PCCERT_CONTEXT)(var.pulVal));
                }
            }
#else   // !_WIN64
            DWORD dwOption = (OECSECCMD_ENCRYPTED == cmdID) ? OID_SECURITY_CERT_DECRYPTION : OID_SECURITY_CERT_SIGNING;
            hr = pRoot->GetOption(dwOption, &var);
            if (SUCCEEDED(hr))
            {
                Assert(VT_UI4 == var.vt);
                if ((PCCERT_CONTEXT) var.ulVal)
                {
                    fDisableCertMenus = FALSE;
                    CertFreeCertificateContext((PCCERT_CONTEXT) var.ulVal);
                }
            }
#endif  // !_WIN64
        }

        if (fDisableCertMenus)
        {
            EnableMenuItem(hMenu, ID_DIGITAL_ID, MF_GRAYED);
            EnableMenuItem(hMenu, ID_EDIT_TRUST, MF_GRAYED);
            // EnableMenuItem(hMenu, ID_DIGITAL_ID, MF_GRAYED);
        }

        id = (INT)TrackPopupMenu(
                hMenu,
                TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                pPoint->x,
                pPoint->y,
                0,
                hwnd,
                NULL);

        // we have to use TPM_RETURNCMD here as we need to process the command-id before returning from this
        // function, other wise trident will be confused about the object being clicked on.
        switch (id)
        {
            case ID_SECURITY_PROPERTIES:
            {
                MSGPROP msgProp={0};

                msgProp.hwndParent = hwnd;
                msgProp.dwFlags = ARF_RECEIVED;
                msgProp.pMsg=pMsg;
                msgProp.fSecure = IsSecure(msgProp.pMsg);
                if (msgProp.fSecure)
                {
                    msgProp.mpStartPage = MP_SECURITY;
                    HrGetWabalFromMsg(msgProp.pMsg, &msgProp.lpWabal);
                }

                // This will prevent the (possibly wrong) attachment count from being shown in the properties dialog.
                msgProp.fFromListView = TRUE;

                hr = HrMsgProperties(&msgProp);
                ReleaseObj(msgProp.lpWabal);
                break;
            }

            case ID_DIGITAL_ID:
            case ID_ENCRYPT_ID:
            case ID_EDIT_TRUST:
            {
                if (pRoot)
                {
                    HCERTSTORE hcMsg = 0;
#ifdef _WIN64
                    if (SUCCEEDED(hr = pRoot->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
                    {
                        if (var.vt == VT_UI8)
                            hcMsg = (HCERTSTORE)(var.pulVal);
                    }
                    if (SUCCEEDED(hr = pRoot->GetOption((ID_ENCRYPT_ID == id) ? OID_SECURITY_CERT_DECRYPTION_64 : OID_SECURITY_CERT_SIGNING_64, &var)))
                    {
                        Assert(VT_UI8 == var.vt);
                        if ((PCCERT_CONTEXT)(var.pulVal))
                        {
                            if (ID_EDIT_TRUST != id)
                                hr = CommonUI_ViewSigningCertificate(hwnd, (PCCERT_CONTEXT)(var.pulVal), hcMsg);
                            else
                                hr = CommonUI_ViewSigningCertificateTrust(hwnd, (PCCERT_CONTEXT)(var.pulVal), hcMsg);
                            CertFreeCertificateContext(*(PCCERT_CONTEXT *)(&(var.uhVal)));
                        }
                    }
#else   // !_WIN64
                    if (SUCCEEDED(hr = pRoot->GetOption(OID_SECURITY_HCERTSTORE, &var)))
                    {
                        if (var.vt == VT_UI4)
                            hcMsg = (HCERTSTORE) var.ulVal;
                    }
                    if (SUCCEEDED(hr = pRoot->GetOption((ID_ENCRYPT_ID == id) ? OID_SECURITY_CERT_DECRYPTION : OID_SECURITY_CERT_SIGNING, &var)))
                    {
                        Assert(VT_UI4 == var.vt);
                        if ((PCCERT_CONTEXT) var.ulVal)
                        {
                            if (ID_EDIT_TRUST != id)
                                hr = CommonUI_ViewSigningCertificate(hwnd, (PCCERT_CONTEXT) var.ulVal, hcMsg);
                            else
                                hr = CommonUI_ViewSigningCertificateTrust(hwnd, (PCCERT_CONTEXT) var.ulVal, hcMsg);
                            CertFreeCertificateContext((PCCERT_CONTEXT) var.ulVal);
                        }
                    }
#endif  // _WIN64
                    if (hcMsg)
                        CertCloseStore(hcMsg, 0);
                }
                break;
            }

            case ID_HELP_SECURITY:
                OEHtmlHelp(hwnd, c_szCtxHelpFileHTMLCtx, HH_DISPLAY_TOPIC, (DWORD_PTR)(LPCSTR)"mail_overview_send_secure_messages.htm");
                break;

        }

        DestroyMenu(hMenu);
        SafeRelease(pRoot);
    } else
        hr = E_FAIL;
    return hr;
}
#endif // 0

void ShowDigitalIDs(HWND hWnd)
{
    CRYPTUI_CERT_MGR_STRUCT mgrCert;

    mgrCert.dwSize = sizeof(mgrCert);
    mgrCert.hwndParent = hWnd;
    mgrCert.dwFlags = 0;
    mgrCert.pwszTitle = NULL;
    mgrCert.pszInitUsageOID = NULL;

    CryptUIDlgCertMgr(&mgrCert);
    return;
}


BOOL CheckCDPinCert(LPMIMEMESSAGE pMsg)
{
    BOOL fRet;
    IMimeBody          *pBody;
    HBODY       hBody = NULL;

    if(!pMsg)
        return(FALSE);

    fRet = FALSE;

    if(FAILED(HrGetInnerLayer(pMsg, &hBody)))
        return(FALSE);


    if (SUCCEEDED(pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody)))
    {
        PROPVARIANT  var;

#ifdef _WIN64
        if(SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            Assert(VT_UI8 == var.vt);
            PCCERT_CONTEXT pcCert= (PCCERT_CONTEXT)(var.pulVal);
            fRet = CheckCDPinCert(pcCert);
        }
#else   // !_WIN64
        if(SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            Assert(VT_UI4 == var.vt);
            PCCERT_CONTEXT pcCert= (PCCERT_CONTEXT) var.ulVal;
            fRet = CheckCDPinCert(pcCert);
        }
#endif  // _WIN64

        pBody->Release();
    }

    return(fRet);
}
BOOL CheckCDPinCert(PCCERT_CONTEXT pcCert)
{
    if (pcCert)
    {
        PCERT_EXTENSION pExt = CertFindExtension(szOID_CRL_DIST_POINTS, pcCert->pCertInfo->cExtension, pcCert->pCertInfo->rgExtension);
        if(pExt != NULL)
            return TRUE;
    }
    return(FALSE);
}

#ifdef YST
BOOL ParseNames(DWORD * pcNames, PCERT_NAME_BLOB * prgNames, HWND hwnd, DWORD idc)
{
    DWORD               cb;
    DWORD               cEntry = 0;
    DWORD               cNames = 0;
    BOOL                f;
    DWORD               i;
    LPWSTR              pwsz;
    LPWSTR              pwsz1;
    CRYPT_DER_BLOB      rgDer[50] = {0};
    CERT_ALT_NAME_INFO  rgNames[50] = {0};
    CERT_ALT_NAME_ENTRY rgEntry[200] = {0};
    WCHAR               rgwch[4096];

    GetDlgItemTextW(hwnd, idc, rgwch, sizeof(rgwch)/sizeof(WCHAR));

    pwsz = rgwch;

    while (*pwsz != 0) {
        if (*pwsz == ' ') {
            while (*pwsz == ' ') pwsz++;
            rgNames[cNames-1].cAltEntry += 1;
        }
        else {
            cNames += 1;
            rgNames[cNames-1].rgAltEntry = &rgEntry[cEntry];
            rgNames[cNames-1].cAltEntry = 1;
        }

        if (_wcsnicmp(pwsz, L"SMTP:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
            rgEntry[cEntry].pwszRfc822Name = pwsz;
            while ((*pwsz != 0) && (*pwsz != '\n') && (*pwsz != '\r')) pwsz++;
        }
        else if (_wcsnicmp(pwsz, L"X500:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            for (pwsz1 = pwsz; ((*pwsz != 0) && (*pwsz != '\n') &&
                                (*pwsz != '\r')); pwsz++);
            if (*pwsz != 0) {
                *pwsz = 0;
                pwsz++;
            }

            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1,
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL,
                               NULL, &cb, NULL);
            if (!f) return FALSE;

            rgEntry[cEntry].DirectoryName.pbData = (LPBYTE) malloc(cb);
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1,
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL,
                               rgEntry[cEntry].DirectoryName.pbData, &cb,
                               NULL);
            if (!f) return FALSE;
            rgEntry[cEntry].DirectoryName.cbData = cb;
        }
        else {
            return FALSE;
        }

        if (*pwsz == '\r') {
            *pwsz = 0;
            pwsz++;
        }
        if (*pwsz == '\n') {
            *pwsz = 0;
            pwsz++;
        }
        cEntry += 1;
    }

    *prgNames = (PCERT_NAME_BLOB) malloc(sizeof(CERT_NAME_BLOB) * cNames);
    if (*prgNames == NULL) return FALSE;

    for (i=0; i<cNames; i++) {
        f = CryptEncodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                &rgNames[i], CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &(*prgNames)[i].pbData, &(*prgNames)[i].cbData);
        if (!f) return f;
    }
    *pcNames = cNames;
    return f;
}
#endif // YST

#ifdef SMIME_V3
BOOL FNameInList(LPSTR szAddr, DWORD cReceiptFromList, CERT_NAME_BLOB *rgReceiptFromList)
{
    BOOL fResult = FALSE;

    if (cReceiptFromList == 0)
    {
        fResult =  TRUE;
    }
    else {
        DWORD   cb;
        DWORD    i;
        DWORD   i1;
        char    rgch[256];

        for (i=0; !fResult && (i<cReceiptFromList); i++)
        {
            CERT_ALT_NAME_INFO *    pname = NULL;

            if (CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                            rgReceiptFromList[i].pbData, rgReceiptFromList[i].cbData,
                            CRYPT_DECODE_ALLOC_FLAG,NULL,
                            &pname, &cb))

                {
                for (i1=0; !fResult && (i1<pname->cAltEntry); i1++)
                {
                    switch (pname->rgAltEntry[i1].dwAltNameChoice)
                    {
                    case CERT_ALT_NAME_RFC822_NAME:
                        cb = WideCharToMultiByte(CP_ACP, 0,
                            (pname->rgAltEntry[i1]).pwszRfc822Name, -1,
                            rgch, sizeof(rgch), NULL, NULL);

                        Assert(cb < sizeof(rgch) - 2);

                        if (lstrcmpi(szAddr, rgch))
                        {
                            fResult = TRUE;
                        }
                    }
                }
                LocalFree(pname);
            }
            else
            {
                AssertSz(FALSE, "Bad Receipt From Name");
                // $TODO - handle this error
            }
        }
    }
    return fResult;
}


// Return security label as Unicode text string
HRESULT HrGetLabelString(LPMIMEMESSAGE pMsg, LPWSTR *pwStr)
{

    PCRYPT_ATTRIBUTE    pattrLabel;
    CRYPT_ATTR_BLOB     valLabel;
    LPBYTE              pbLabel = NULL;
    DWORD               cbLabel;
    PSMIME_SECURITY_LABEL plabel = NULL;
    HRESULT             hr = E_FAIL;

    IMimeSecurity2 * pSMIME3 = NULL;
    IMimeBody      *pBody = NULL;
    HBODY   hBody = NULL;

    Assert(pMsg);

    if(FAILED(hr = HrGetInnerLayer(pMsg, &hBody)))
        return(hr);

    if(pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody) == S_OK)
    {
        if(pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pSMIME3) == S_OK)
        {

            // Get label attribute
            if(pSMIME3->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED,
                0, szOID_SMIME_Security_Label,
                &pattrLabel) == S_OK)
            {
                // decode label
                if(CryptDecodeObjectEx(X509_ASN_ENCODING,
                    szOID_SMIME_Security_Label,
                    pattrLabel->rgValue[0].pbData,
                    pattrLabel->rgValue[0].cbData,
                    CRYPT_DECODE_ALLOC_FLAG,
                    &CryptDecodeAlloc, &plabel, &cbLabel))
                {
                    SpISMimePolicyLabelInfo  spspli;

                    // Get the required interface to the policy module.
                    if(HrQueryPolicyInterface(0, plabel->pszObjIdSecurityPolicy, IID_ISMimePolicyLabelInfo,
                        (LPVOID *) &spspli) == S_OK)
                    {

                        LPWSTR   pwchLabel = NULL;
                        // get label description string
                        if(spspli->GetStringizedLabel(0, plabel, &pwchLabel) == S_OK)
                        {

                            *pwStr = pwchLabel;
                            hr = S_OK;
                        }
                    }
                    else
                        hr = S_FALSE;
                    SafeMemFree(plabel);
                }
            }
            SafeRelease(pSMIME3);
        }
        ReleaseObj(pBody);
    }
    return(hr);
}
#endif // SMIME_V3

HRESULT HrShowSecurityProperty(HWND hwnd, LPMIMEMESSAGE pMsg)
{
    MSGPROP msgProp={0};
    HRESULT hr = S_OK;

    msgProp.hwndParent = hwnd;
    msgProp.dwFlags = ARF_RECEIVED;
    msgProp.pMsg = pMsg;
    msgProp.fSecure = IsSecure(msgProp.pMsg);
    if (msgProp.fSecure)
    {
        msgProp.mpStartPage = MP_SECURITY;
        HrGetWabalFromMsg(msgProp.pMsg, &msgProp.lpWabal);
    }

    hr = HrMsgProperties(&msgProp);
    ReleaseObj(msgProp.lpWabal);

    return(hr);
}

void CreateContentIdentifier(TCHAR *pchContentID, LPMIMEMESSAGE pMsg)
{
    SYSTEMTIME SysTime;
    LPWSTR lpszSubj = NULL;
    int nLen = 0;
    TCHAR szTmp[21];


    GetSystemTime(&SysTime);
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpszSubj);
    nLen = lstrlenW(lpszSubj);

    for(int i =0; (i < 5) && (i < nLen); i++)
        wsprintf(szTmp + i*4, "%04d", lpszSubj[i]);

    szTmp[i*4] = _T('\0');

    // ContentId is sequence of following text characters
    // 1. Prefix ("797374" + "-" and code  - 7 chars
    // 2. System time + "-" - 18 chars
    // 3. First 5 Unicode chars (or lstrlen) in dec of Subject - 20 chars
    // Total # of chars 7 + 18 + 20 + 1 = 46
    // if you change this, also change CONTENTID_SIZE

    wsprintf(pchContentID, "%s-%4d%2d%1d%2d%2d%2d%2d%2d-%s",
            sz_OEMS_ContIDPrefix,
            SysTime.wYear,
            SysTime.wMonth,
            SysTime.wDayOfWeek,
            SysTime.wDay,
            SysTime.wHour,
            SysTime.wMinute,
            SysTime.wSecond,
            SysTime.wMilliseconds,
            szTmp);

    SafeMimeOleFree(lpszSubj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\simpstr.cpp ===
/*
 *  s i m p s t r . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Simple string class.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "simpstr.h"

//----------------------------------------------------------------------
// CSimpleString::operator==
//----------------------------------------------------------------------
BOOL CSimpleString::operator==(const CSimpleString& rhs) const
{
    if (m_pRep == rhs.m_pRep)
        return TRUE;

    if (!m_pRep || !rhs.m_pRep)
        return FALSE;

    return (0 == lstrcmp(m_pRep->m_pszString, rhs.m_pRep->m_pszString));
}

//----------------------------------------------------------------------
// CSimpleString::SetString
//----------------------------------------------------------------------
HRESULT CSimpleString::SetString(LPCSTR pszString)
{
    _ReleaseRep();
    return _AllocateRep(pszString, FALSE);
}

//----------------------------------------------------------------------
// CSimpleString::AdoptString
//----------------------------------------------------------------------
HRESULT CSimpleString::AdoptString(LPSTR pszString)
{
    _ReleaseRep();
    return _AllocateRep(pszString, TRUE);
}

//----------------------------------------------------------------------
// CSimpleString::_AcquireRep
//----------------------------------------------------------------------
void CSimpleString::_AcquireRep(SRep *pRep)
{
    if (m_pRep == pRep)
        return;

    if (m_pRep)
        _ReleaseRep();

    if (pRep)
    {
        m_pRep = pRep;
        m_pRep->m_cRef++;
    }
}

//----------------------------------------------------------------------
// CSimpleString::_ReleaseRep
//----------------------------------------------------------------------
void CSimpleString::_ReleaseRep(void)
{
    if (m_pRep)
    {
        if (0 == --m_pRep->m_cRef)
        {
            if (m_pRep->m_pszString)
                MemFree(const_cast<LPSTR>(m_pRep->m_pszString));
            delete m_pRep;
        }

        m_pRep = NULL;
    }
}

//----------------------------------------------------------------------
// CSimpleString::_AllocateRep
//----------------------------------------------------------------------
HRESULT CSimpleString::_AllocateRep(LPCSTR pszString, BOOL fAdopted)
{
    SRep        *pRep = NULL;
    HRESULT     hr = S_OK;

    if (pszString)
    {
        pRep = new SRep;
        if (NULL == pRep)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pRep->m_pszString = fAdopted ? pszString : PszDupA(pszString);
        if (NULL == pRep->m_pszString)
        {
            delete pRep;
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pRep->m_cRef = 1;
        m_pRep = pRep;
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\serverq.h ===
/*
 *    s e r v e r q . h
 *
 *    Purpose:  
 *        Implements IMessageServer wrapper for queuing operations to 
 *        IMessageServer object
 *
 *    Owner:
 *        brettm.
 *
 *  History:
 *      June 1998: Created
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */
#ifndef _SERVERQ_H
#define _SERVERQ_H

typedef struct ARGUMENT_DATA_tag
{
    STOREOPERATIONTYPE          sot;
    IStoreCallback              *pCallback;
    struct ARGUMENT_DATA_tag    *pNext;

    LPMESSAGEIDLIST             pList;
    LPADJUSTFLAGS               pFlags;
    FOLDERID                    idParent;
    FOLDERID                    idFolder;
    LPCSTR                      pszName; 

    union
    {
        // SynchronizeFolder
        struct 
        {
            SYNCFOLDERFLAGS     dwSyncFlags; 
            DWORD               cHeaders;
        };

        // GetMessage
        struct 
        {
            MESSAGEID           idMessage;
            IStoreCallback      **rgpOtherCallback;
            ULONG               cOtherCallbacks;
        };

        // PutMessage
        struct 
        {
            MESSAGEFLAGS        dwMsgFlags;
            LPFILETIME          pftReceived; // Either points to ftReceived member, or is NULL
            FILETIME            ftReceived;
            IStream             *pPutStream;
        };

        // CopyMessages
        struct 
        {
            IMessageFolder      *pDestFldr;
            COPYMESSAGEFLAGS    dwCopyOptions;
        };

        // DeleteMessages
        struct 
        {
            DELETEMESSAGEFLAGS  dwDeleteOptions;
        };

        // SetMessageFlags
        struct 
        {
            SETMESSAGEFLAGSFLAGS dwSetFlags;
        };

        // SynchronizeStore
        struct 
        {
            DWORD               dwFlags;
        };

        // CreateFolder
        struct 
        {
            SPECIALFOLDER       tySpecial;
            FLDRFLAGS           dwFldrFlags;
        };

        // MoveFolder
        struct 
        {
            FOLDERID            idParentNew;
        };

        // DeleteFolder
        struct 
        {
            DELETEFOLDERFLAGS   dwDelFldrFlags;
        };

        // SubscribeToFolder
        struct 
        {
            BOOL                fSubscribe;
        };

        // GetNewGroups
        struct
        {
            SYSTEMTIME          sysTime;
        };
    };
} ARGUMENT_DATA, *PARGUMENT_DATA;


HRESULT CreateServerQueue(IMessageServer *pServerInner, IMessageServer **ppServer);


class CServerQ : 
    public IMessageServer,
    public IStoreCallback,
    public IServiceProvider
{
public:
    // Constructor, Destructor
    CServerQ();
    ~CServerQ();

    // IUnknown Members
    STDMETHODIMP            QueryInterface(REFIID iid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    HRESULT     Init(IMessageServer *pServerInner);

    // IMessageServer Methods
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback);
    STDMETHODIMP PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDestFldr, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP SynchronizeStore(FOLDERID idParent, DWORD dwFlags,IStoreCallback *pCallback);
    STDMETHODIMP CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew,IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP ConnectionAddRef();
    STDMETHODIMP ConnectionRelease();
    STDMETHODIMP GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback);
    STDMETHODIMP GetMinPollingInterval(IStoreCallback   *pCallback);
    // IStoreCallback Methods
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    //----------------------------------------------------------------------
    // IServiceProvider
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ULONG               m_cRef,
                        m_cRefConnection;
    IMessageServer      *m_pServer;
    IStoreCallback      *m_pCurrentCallback;    // non-addref'ed pointer to pCallback of current task
    ARGUMENT_DATA       *m_pTaskQueue;          // head pointer for task queue
    ARGUMENT_DATA       *m_pLastQueueTask;      // last pointer for appending tasks
    ARGUMENT_DATA       *m_pCurrentTask;

    HWND                m_hwnd;

    HRESULT _OnNextTask();
    HRESULT _AddToQueue(STOREOPERATIONTYPE sot, IStoreCallback *pCallback, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPCSTR pszName, ARGUMENT_DATA **ppNewArgData);

    HRESULT _Flush(BOOL fSendCurrCompletion);
    HRESULT _FreeArgumentData(ARGUMENT_DATA *pArgData);
    HRESULT _StartNextTask();
    HRESULT _AppendToExistingTask(ARGUMENT_DATA *pTask, MESSAGEID idMessage);

#ifdef DEBUG
    ARGUMENT_DATA   *m_DBG_pArgDataLast;

    HRESULT _DBG_DumpQueue();
#endif
};

#endif //_SERVERQ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\sechtml.cpp ===
/*
**  s e c h t m l . c p p
**
**  Purpose:
**      Defines an inline script for the preview pane that will show general
**      security UI.  An ActiveX control sits on top of this and passes
**      the results to our command target
**
**  History
**      4/02/97: (t-erikne) Created.
**      7/15/97: (t-erikne) Removed ActiveX control
**      7/16/97: (t-erikne) updated to HTML 4.0
**
**  Copyright (C) Microsoft Corp. 1997.
*/

///////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include <pch.hxx>
#include <resource.h>
#include <docobj.h>
#include "oleutil.h"
#include "ourguid.h"
#include <error.h>
#include <mimeole.h>
#include "secutil.h"
#include <shlwapi.h>
#include "demand.h"

///////////////////////////////////////////////////////////////////////////
//
// Macros
//

#define THIS_AS_UNK ((IUnknown *)(IObjectWithSite *)this)

///////////////////////////////////////////////////////////////////////////
//
// Statics
//

static const TCHAR s_szHTMLRow[] =
    "<TR>"
	"<TD WIDTH=5%%>"
		"<IMG SRC=\"res://msoeres.dll/%s\">"
    "</TD>"
    "<TD CLASS=%s>"
		"%s"
	"</TD>"
    "</TR>\r\n";

static const TCHAR s_szHTMLRowForRec[] =
    "<TR>"
    "<TD CLASS=GOOD>"
		"%s %s"
	"</TD>"
    "</TR>\r\n";



// WARNING: If you change the order here, make sure to change it in the order of
// sprintf parameters where it is used in HrOutputSecurityScript.
static const TCHAR s_szHTMLmain[] =
    "document.all.hightext.className=\"%s\";"
    "document.all.btnCert.disabled=%d;"
    "document.all.chkShowAgain.readonly=%d;"
    "document.all.chkShowAgain.disabled=%d;"
    "document.all.btnTrust.disabled=%d;"
    "}\r\n";

static const TCHAR s_szHTMLCloseAll[] =
    "</SCRIPT>"
    "</BODY></HTML>";

static const TCHAR s_szHTMLgifUNK[] =
    "quest.gif";

static const TCHAR s_szHTMLgifGOOD[] =
    "check.gif";

static const TCHAR s_szHTMLgifBAD[] =
    "eks.gif";

static const TCHAR s_szHTMLclassGOOD[] =
    "GOOD";

static const TCHAR s_szHTMLclassBAD[] =
    "BAD";

static const TCHAR s_szHTMLclassUNK[] =
    "UNK";

static const TCHAR s_szHTMLRowNoIcon[] =
    "<TR>"
	"<TD WIDTH=5%%>"
   "</TD>"
   "<TD CLASS=%s>"  // "BAD", "GOOD", "UNK"
		"%s%s"       // label, email address
	"</TD>"
   "</TR>\r\n";

static const TCHAR s_szHMTLEndTable[] =
    "</TABLE>\r\n<p>\r\n<p>" ;

static const TCHAR s_szHTMLEnd[] =
    "</BODY></HTML>";


///////////////////////////////////////////////////////////////////////////
//
// Code
//

HRESULT HrOutputSecurityScript(LPSTREAM *ppstm, SECSTATE *pSecState, BOOL fDisableCheckbox)
{
    HRESULT     hr;
    TCHAR       szRes[CCHMAX_STRINGRES];
    TCHAR       szBuf[CCHMAX_STRINGRES];
    UINT        ids;
    ULONG       ul;
    int         i;
    BOOL        fBadThingsHappened = FALSE;
    const WORD  wTrusted = LOWORD(pSecState->user_validity);

    hr = LoadResourceToHTMLStream("secwarn1.htm", ppstm);
    if (FAILED(hr))
        goto exit;

    ul = ULONG(HIWORD(pSecState->user_validity));

    // Top level Messages

    //N8 one of the places that we need to pay attention
    // to cryptdlg's flags, see wTrusted.  I assume that
    // we get ATHSEC_NOTRUSTUNKNOWN in a certain set
    // of cases.  see the chain code in secutil.cpp

    // 1.  Tamper
    if (AthLoadString(
        (pSecState->ro_msg_validity & MSV_SIGNATURE_MASK)
            ? (pSecState->ro_msg_validity & MSV_BADSIGNATURE)
                ? idsWrnSecurityMsgTamper
                : idsUnkSecurityMsgTamper
                : (pSecState->fHaveCert ? idsOkSecurityMsgTamper : idsUnkSecurityMsgTamper),
        szRes, ARRAYSIZE(szRes)))
        {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRow,
        (pSecState->ro_msg_validity & MSV_SIGNATURE_MASK)
            ? ((pSecState->ro_msg_validity & MSV_BADSIGNATURE)
                ? s_szHTMLgifBAD
                : s_szHTMLgifUNK)
                : (pSecState->fHaveCert ? s_szHTMLgifGOOD : s_szHTMLgifUNK),

        (pSecState->ro_msg_validity & MSV_SIGNATURE_MASK)
            ? ((pSecState->ro_msg_validity & MSV_BADSIGNATURE)
                ? s_szHTMLclassBAD
                : s_szHTMLclassUNK)
            : (pSecState->fHaveCert ? s_szHTMLclassGOOD : s_szHTMLclassUNK),
            szRes);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
        }

    // 2.  Trust
    if (AthLoadString(
        (wTrusted)
            ? (wTrusted & ATHSEC_NOTRUSTUNKNOWN)
                ? idsUnkSecurityTrust
                : idsWrnSecurityTrustNotTrusted
            : idsOkSecurityTrustNotTrusted,
            szRes, ARRAYSIZE(szRes)))
        {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRow,
            (wTrusted)
                ? (wTrusted & ATHSEC_NOTRUSTUNKNOWN)
                    ? s_szHTMLgifUNK
                    : s_szHTMLgifBAD
                : s_szHTMLgifGOOD,
            (wTrusted)
                ? (wTrusted & ATHSEC_NOTRUSTUNKNOWN)
                    ? s_szHTMLclassUNK
                    : s_szHTMLclassBAD
                : s_szHTMLclassGOOD,
                szRes);

        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
        }

    // 3.  Expire
    if (AthLoadString(
            (pSecState->ro_msg_validity & MSV_EXPIRED_SIGNINGCERT)
                ? idsWrnSecurityTrustExpired
                : idsOkSecurityTrustExpired,
            szRes, ARRAYSIZE(szRes)))
        {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRow,
            (pSecState->ro_msg_validity & MSV_EXPIRED_SIGNINGCERT)
                ? s_szHTMLgifBAD
                : s_szHTMLgifGOOD,
            (pSecState->ro_msg_validity & MSV_EXPIRED_SIGNINGCERT)
                ? s_szHTMLclassBAD
                : s_szHTMLclassGOOD,
            szRes);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
        }

    // Validity Messages
    ids = idsWrnSecurityTrustAddress; //base
    for (i=ATHSEC_NUMVALIDITYBITS; i; i--)
        {
        if (!AthLoadString(
            (ul & 0x1)
                ? ids
                : ids+OFFSET_SMIMEOK,
            szRes, ARRAYSIZE(szRes)))
            {
            continue;
            }
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRow,
            (ul & 0x1) ? s_szHTMLgifBAD : s_szHTMLgifGOOD,
            (ul & 0x1) ? s_szHTMLclassBAD : s_szHTMLclassGOOD,
            szRes);
        if (ul & 0x1)
            {
            fBadThingsHappened = TRUE;
            }
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);

        if (ul & 0x1 && ids == idsWrnSecurityTrustAddress)
            {
            // Output the email addresses
            // Certificate first
            if (AthLoadString(idsWrnSecurityTrustAddressSigner, szRes, ARRAYSIZE(szRes))) {
                wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowNoIcon,
                    s_szHTMLclassBAD,
                    szRes,
                    pSecState->szSignerEmail ? pSecState->szSignerEmail : "");
                (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
            }


            // Then the Sender
            if (AthLoadString(idsWrnSecurityTrustAddressSender , szRes, ARRAYSIZE(szRes))) {
                wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowNoIcon,
                    s_szHTMLclassBAD,
                    szRes,
                    pSecState->szSenderEmail ? pSecState->szSenderEmail : "");
                (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
                }
            }
        ul >>= 1;
        ids++;
        }
    Assert(0==ul);


    // Response script
    CHECKHR(hr = HrLoadStreamFileFromResource("secwarn2.htm", ppstm));

    // main() function
    if ((pSecState->ro_msg_validity & MSV_BADSIGNATURE) ||
        (pSecState->ro_msg_validity & MSV_EXPIRED_SIGNINGCERT) ||
        (wTrusted & ATHSEC_NOTRUSTNOTTRUSTED))
        fBadThingsHappened = TRUE;

    wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLmain,
        fBadThingsHappened ? s_szHTMLclassBAD : s_szHTMLclassUNK,
        !pSecState->fHaveCert,      // fDisableCheckbox,
        fDisableCheckbox,
        fDisableCheckbox,           // !pSecState->fHaveCert,
        !pSecState->fHaveCert);
    CHECKHR(hr = (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL));

    // Finish
    CHECKHR(hr = (*ppstm)->Write(s_szHTMLCloseAll, sizeof(s_szHTMLCloseAll)-sizeof(TCHAR), NULL));

#ifdef DEBUG
    WriteStreamToFile(*ppstm, "c:\\oesecstm.htm", CREATE_ALWAYS, GENERIC_WRITE);
#endif

exit:
    return hr;
}

HRESULT HrDumpLineToStream(LPSTREAM *ppstm, UINT *ids, TCHAR *szPar) 
{
    TCHAR       szRes[CCHMAX_STRINGRES];
    TCHAR       szBuf[CCHMAX_STRINGRES];

    if(*ids)
    {
        AthLoadString(*ids, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, szPar);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
        *ids = 0;
    }
    return(S_OK);
}

HRESULT HrOutputRecHasProblems(LPSTREAM *ppstm, SECSTATE *pSecState) 
{
    HRESULT     hr = S_OK;
    const WORD  wTrusted = LOWORD(pSecState->user_validity);
    UINT        ids = 0;
    UINT        ids1 = 0;
    TCHAR       szBuf[CCHMAX_STRINGRES];
    ULONG       ul = ULONG(HIWORD(pSecState->user_validity));
    int         i;

    if(AthLoadString(idsRecHasProblems, szBuf, ARRAYSIZE(szBuf)))
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);

    // 1.  Tamper
    if(pSecState->ro_msg_validity & MSV_SIGNATURE_MASK)
        ids  = (pSecState->ro_msg_validity & MSV_BADSIGNATURE) ? idsWrnSecurityMsgTamper : idsUnkSecurityMsgTamper;
    else if(!pSecState->fHaveCert)
        ids  = idsUnkSecurityMsgTamper;
    HrDumpLineToStream(ppstm, &ids, NULL);

    // 2.  Trust
    if(wTrusted)
    {
        ids = (wTrusted & ATHSEC_NOTRUSTUNKNOWN) ? idsUnkSecurityTrust : idsWrnSecurityTrustNotTrusted;
        HrDumpLineToStream(ppstm, &ids, NULL);
    }

    // 3.  Expire
    if(pSecState->ro_msg_validity & MSV_EXPIRED_SIGNINGCERT)
    {
        ids = idsWrnSecurityTrustExpired;
        HrDumpLineToStream(ppstm, &ids, NULL);
    }

    // Validity Messages
    ids = idsWrnSecurityTrustAddress; //base
    for (i=ATHSEC_NUMVALIDITYBITS; i; i--)
    {
        if (ul & 0x1)
        {
            if(ids == idsWrnSecurityTrustAddress)
            {
                ids1 = idsWrnSecurityTrustAddress;
                HrDumpLineToStream(ppstm, &ids1, NULL);
                ids1 = idsWrnSecurityTrustAddressSigner;
                HrDumpLineToStream(ppstm, &ids1, pSecState->szSignerEmail);
                ids1 = idsWrnSecurityTrustAddressSender;
                HrDumpLineToStream(ppstm, &ids1, pSecState->szSenderEmail);
            }
            else 
            {
                ids1 = ids;
                HrDumpLineToStream(ppstm, &ids1, NULL);
            }
        }

        ul >>= 1;
        ids++;

    }
    return(S_OK);
}

HRESULT HrOutputSecureReceipt(LPSTREAM *ppstm, TCHAR * pszSubject, TCHAR * pszFrom, FILETIME * pftSentTime, FILETIME * pftSigningTime, SECSTATE *pSecState) 
{
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    CHAR       szTmp[CCHMAX_STRINGRES];
    TCHAR       szBuf[CCHMAX_STRINGRES*2];
    SYSTEMTIME  SysTime;
    int         size = 0;

    IF_FAILEXIT(hr = LoadResourceToHTMLStream("secrec.htm", ppstm));

    // Add To line
    if(AthLoadString(idsToField, szRes, ARRAYSIZE(szRes)))
    {
        size = lstrlen(pszFrom);
        if(size == 0)
        {
            if(!AthLoadString(idsRecUnknown, szTmp, ARRAYSIZE(szTmp)))
                szTmp[0] = _T('\0');
            wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, szTmp);
        }
        else
        {
            if(size >= (CCHMAX_STRINGRES - lstrlen(s_szHTMLRowForRec) - lstrlen(szRes) - 2))
                    pszFrom[CCHMAX_STRINGRES - lstrlen(s_szHTMLRowForRec) - lstrlen(szRes) - 3] = _T('\0');

            wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, pszFrom);
        }
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }
    
    // Add Subject line
    if(AthLoadString(idsSubjectField, szRes, ARRAYSIZE(szRes)))
    {
        if(lstrlen(pszSubject) >= (CCHMAX_STRINGRES - lstrlen(s_szHTMLRowForRec) - lstrlen(szRes) - 2))
            pszSubject[CCHMAX_STRINGRES - lstrlen(s_szHTMLRowForRec) - lstrlen(szRes) - 3] = _T('\0');

        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, pszSubject);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }

    // Add Sent line
    if(AthLoadString(idsSentField, szRes, ARRAYSIZE(szRes)))
    {
        CchFileTimeToDateTimeSz(pftSentTime, szTmp, CCHMAX_STRINGRES - lstrlen(szRes) - 2, DTM_NOSECONDS);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, szTmp);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }

    // End of table
    CHECKHR(hr = (*ppstm)->Write(s_szHMTLEndTable, sizeof(s_szHMTLEndTable)-sizeof(TCHAR), NULL));

    // Final message
    if(AthLoadString(idsReceiptField, szRes, ARRAYSIZE(szRes)))
    {
        CchFileTimeToDateTimeSz(pftSigningTime, szTmp, CCHMAX_STRINGRES - lstrlen(szRes) - 2, DTM_NOSECONDS);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, szTmp);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }

    if(!IsSignTrusted(pSecState))
    {
        HrOutputRecHasProblems(ppstm, pSecState) ;
        // End of table again
        CHECKHR(hr = (*ppstm)->Write(s_szHMTLEndTable, sizeof(s_szHMTLEndTable)-sizeof(TCHAR), NULL));
    }

    // End of HTML file
    CHECKHR(hr = (*ppstm)->Write(s_szHTMLEnd, sizeof(s_szHTMLEnd)-sizeof(TCHAR), NULL));
exit:     
    return(hr); 
}

// user's itself secure receipt
HRESULT HrOutputUserSecureReceipt(LPSTREAM *ppstm, IMimeMessage *pMsg)
{
    HRESULT hr = S_OK;
    LPSTR      lpszSubj = NULL;
    LPSTR      lpszTo = NULL; 
    CHAR       szTmp[CCHMAX_STRINGRES];
    TCHAR       szRes[CCHMAX_STRINGRES];
    TCHAR       szBuf[CCHMAX_STRINGRES*2];
    PROPVARIANT Var;
    int size;

    IF_FAILEXIT(hr = LoadResourceToHTMLStream("srsentit.htm", ppstm));

    MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpszSubj);
    MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &lpszTo);

     // Add To line
    if(AthLoadString(idsToField, szRes, ARRAYSIZE(szRes)))
    {
        // we have a name in <yst@microsoft.com>", 
        // need remove '<' and '>' for HTML
        size = lstrlen(lpszTo);
        if(lpszTo[size - 1] == _T('>'))
            lpszTo[size - 1] = _T('\0');

        if(lpszTo[0] == _T('<'))
            lpszTo[0] = _T(' ');

        if(size >= ((int) (CCHMAX_STRINGRES - sizeof(s_szHTMLRowForRec) - lstrlen(szRes) - 2)))
            lpszTo[CCHMAX_STRINGRES - sizeof(s_szHTMLRowForRec) - lstrlen(szRes) - 3] = _T('\0');

        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, lpszTo);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }

    // Add Subject line
    if(AthLoadString(idsSubjectField, szRes, ARRAYSIZE(szRes)))
    {
        size = lstrlen(szRes);
        if(lstrlen(lpszSubj) >= ((int) (CCHMAX_STRINGRES - sizeof(s_szHTMLRowForRec) - size - 2)))
            lpszSubj[CCHMAX_STRINGRES - sizeof(s_szHTMLRowForRec) - size - 3] = _T('\0');

        wnsprintf(szBuf, ARRAYSIZE(szBuf), s_szHTMLRowForRec, szRes, lpszSubj);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);
    }

    // End of table
    CHECKHR(hr = (*ppstm)->Write(s_szHMTLEndTable, sizeof(s_szHMTLEndTable)-sizeof(TCHAR), NULL));

    // Final message
    if(AthLoadString(idsFinalSelfReceipt, szRes, ARRAYSIZE(szRes)))
    {
        FILETIME ftSigningTime;
        PCCERT_CONTEXT      pcSigningCert = NULL;
        THUMBBLOB           tbSigner = {0};
        BLOB                blSymCaps = {0};

        GetSigningCert(pMsg, &pcSigningCert, &tbSigner, &blSymCaps, &ftSigningTime);

        CchFileTimeToDateTimeSz(&ftSigningTime, szTmp, ARRAYSIZE(szTmp),
                            DTM_NOSECONDS);

        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, szTmp);
        (*ppstm)->Write(szBuf, lstrlen(szBuf)*sizeof(TCHAR), NULL);

        if(pcSigningCert)
            CertFreeCertificateContext(pcSigningCert);
    
        SafeMemFree(tbSigner.pBlobData);
        SafeMemFree(blSymCaps.pBlobData);
    }

    // End of HTML file
    CHECKHR(hr = (*ppstm)->Write(s_szHTMLEnd, sizeof(s_szHTMLEnd)-sizeof(TCHAR), NULL));

exit:
    SafeMemFree(lpszSubj);
    SafeMemFree(lpszTo);

    return(hr); 
}

// secure receipt error screen
HRESULT HrOutputErrSecReceipt(LPSTREAM *ppstm, HRESULT hrError, SECSTATE *pSecState)
{
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    TCHAR       szTmp[CCHMAX_STRINGRES];
    TCHAR       szBuf[CCHMAX_STRINGRES*2];
    UINT        ids = 0;
    
    switch(hrError)
    {
    case MIME_E_SECURITY_RECEIPT_CANTFINDSENTITEM:
    case MIME_E_SECURITY_RECEIPT_CANTFINDORGMSG:
        hr = LoadResourceToHTMLStream("srecerr.htm", ppstm);
        break;
        
    case MIME_E_SECURITY_RECEIPT_NOMATCHINGRECEIPTBODY:
    case MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH:
        hr = LoadResourceToHTMLStream("recerr2.htm", ppstm);
        break;
        
    default:
        hr = LoadResourceToHTMLStream("recerr3.htm", ppstm);
        break;
    }
    
    if(FAILED(hr))
        goto exit;

    if(!IsSignTrusted(pSecState))
    {
        HrOutputRecHasProblems(ppstm, pSecState);
        // End of table again
        CHECKHR(hr = (*ppstm)->Write(s_szHMTLEndTable, sizeof(s_szHMTLEndTable)-sizeof(TCHAR), NULL));
    }
    
    // End of HTML file
    if(AthLoadString(idsOESignature, szRes, ARRAYSIZE(szRes)))
        (*ppstm)->Write(szRes, lstrlen(szRes)*sizeof(TCHAR), NULL);
    
    CHECKHR(hr = (*ppstm)->Write(s_szHTMLEnd, sizeof(s_szHTMLEnd)-sizeof(TCHAR), NULL));
    
exit:     
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\sigs.cpp ===
#include "pch.hxx"
#include <shlwapi.h>
#include <shlwapip.h>
#include <resource.h>
#include <options.h>
#include <optres.h>
#include <goptions.h>
#include <strconst.h>
#include <error.h>
#include "sigs.h"
#include "mimeolep.h"
#include "demand.h"
#include "menures.h"
#include <mailnews.h>

typedef struct tagSIG
{
    IOptionBucket   *pBckt;
    char            szName[MAXSIGNAME];
    LPWSTR          wszFile;
    LPSTR           szText;
    DWORD           type;
    BOOL            fDelete;
} SIG;

typedef struct tagACCTSIG
{
    IImnAccount *pAcct;
    ACCTTYPE type;
    int iSig;
} ACCTSIG;

typedef struct tagSIGOPT
{
    SIG *pSig;
    int cSig;
    int cSigBuf;
    
    ACCTSIG *pAcctSig;
    int cAcctSig;
    
    int iDefSig;
    int iInvalidSig; // needed because commctrl is a stinking piece of shit
    BOOL fNoDirty;
    
    int iSelSig; // used by the advanced sig dialog
} SIGOPT;

HRESULT ValidateSig(HWND hwnd, HWND hwndList, int iSig, SIGOPT *pSigOpt);
INT_PTR CALLBACK AdvSigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void EnableSigOptions(HWND hwnd, BOOL fEnable);

CSignatureManager *g_pSigMgr = NULL;

const OPTIONINFO c_rgSigInfo[] =
{
    {SIG_ID,    VT_LPSTR,  0, NULL,          NULL, 0, 0, MAXSIGID - 1, 0},
    {SIG_NAME,  VT_LPSTR,  0, c_szSigName,   NULL, 0, 0, MAXSIGNAME - 1, 0},
    {SIG_FILE,  VT_LPWSTR, 0, c_szSigFile,   NULL, 0, 0, MAX_PATH - 1, 0},
    {SIG_TEXT,  VT_LPSTR,  0, c_szSigText,   NULL, 0, 0, MAXSIGTEXT - 1, 0},
    {SIG_TYPE,  VT_UI4,    0, c_szSigType,   (LPCSTR)SIGTYPE_TEXT, 0, 0, 0, 0}
};

HRESULT InitSignatureManager(HKEY hkey, LPCSTR szRegRoot)
{
    HRESULT hr;
    
    Assert(g_pSigMgr == NULL);
    Assert(g_pOpt != NULL);
    
    g_pSigMgr = new CSignatureManager(hkey, szRegRoot);
    if (g_pSigMgr == NULL)
        hr = E_OUTOFMEMORY;
    else
        hr = S_OK;
    
    return(hr);
}

HRESULT DeinitSignatureManager()
{
    if (g_pSigMgr != NULL)
    {
        g_pSigMgr->Release();
        g_pSigMgr = NULL;
    }
    
    return(S_OK);
}

CSignatureManager::CSignatureManager(HKEY hkey, LPCSTR pszRegKeyRoot)
{
    m_cRef = 1;
    m_fInit = FALSE;
    m_hkey = hkey;
    wsprintf(m_szRegRoot, c_szPathFileFmt, pszRegKeyRoot, c_szSigs);
    m_pBckt = NULL;
    m_cBckt = 0;
    m_cBcktBuf = 0;
}

CSignatureManager::~CSignatureManager(void)
{
    int i;
    
    if (m_pBckt != NULL)
    {
        for (i = 0; i < m_cBckt; i++)
        {
            if (m_pBckt[i].pBckt != NULL)
                m_pBckt[i].pBckt->Release();
        }
        
        MemFree(m_pBckt);
    }
}

ULONG CSignatureManager::AddRef(void)
{
    return((ULONG)InterlockedIncrement(&m_cRef));
}

ULONG CSignatureManager::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return((ULONG)cRef);
}

#define CSIGREALLOC     8

HRESULT CSignatureManager::Initialize()
{
    HKEY hkey;
    HRESULT hr;
    BOOL fDef;
    DWORD cSig, cSigBuf, cb, i;
    SIGBUCKET *pBckt;
    
    hr = S_OK;
    
    if (!m_fInit)
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_READ, NULL, &hkey, &cb))
        {
            fDef = FALSE;
            
            cb = sizeof(m_szDefSigID);
            RegQueryValueEx(hkey, c_szRegDefSig, NULL, &i, (LPBYTE)m_szDefSigID, &cb);
            
            if (ERROR_SUCCESS == RegQueryInfoKey (hkey, NULL, NULL, NULL, &cSig, NULL, 
                NULL, NULL, NULL, NULL, NULL, NULL))
            {
                cSigBuf = cSig + CSIGREALLOC;
                cb = cSigBuf * sizeof(SIGBUCKET);
                if (!MemAlloc((void **)&m_pBckt, cb))
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    ZeroMemory(m_pBckt, cb);
                    m_cBcktBuf = cSigBuf;
                    
                    for (i = 0, pBckt = m_pBckt; i < cSig; i++, pBckt++)
                    {
                        cb = sizeof(pBckt->szID);
                        if (ERROR_SUCCESS != RegEnumKeyEx(hkey, i, pBckt->szID, &cb, NULL, NULL, NULL, NULL))
                        {
                            // TODO: what if this fails????
                            break;
                        }
                        
                        if (!fDef &&
                            *m_szDefSigID != 0 &&
                            0 == lstrcmpi(m_szDefSigID, pBckt->szID))
                            fDef = TRUE;
                        
                        m_cBckt++;
                    }
                }
            }
            
            if (!fDef && m_cBckt > 0)
            {
                // there was no default or it was bogus, so just set it to the 1st sig
                lstrcpy(m_szDefSigID, m_pBckt->szID);
            }
            
            RegCloseKey(hkey);
        }
        
        if (SUCCEEDED(hr))
            m_fInit = TRUE;
    }
    
    return(hr);
}

HRESULT CSignatureManager::GetBucket(SIGBUCKET *pSigBckt)
{
    OPTBCKTINIT init;
    char szKey[MAX_PATH];
    IOptionBucketEx *pBcktEx;
    HRESULT hr;
    PROPVARIANT var;
    
    Assert(pSigBckt != NULL);
    Assert(pSigBckt->pBckt == NULL);
    
    hr = CreateOptionBucketEx(&pBcktEx);
    if (FAILED(hr))
        return(hr);
    
    ZeroMemory(&init, sizeof(OPTBCKTINIT));
    init.rgInfo = c_rgSigInfo;
    init.cInfo = ARRAYSIZE(c_rgSigInfo);
    init.hkey = m_hkey;
    wsprintf(szKey, c_szPathFileFmt, m_szRegRoot, pSigBckt->szID);
    init.pszRegKeyBase = szKey;
    
    var.vt = VT_LPSTR;
    var.pszVal = pSigBckt->szID;
    
    if (FAILED(hr = pBcktEx->Initialize(&init)) ||
        FAILED(hr = pBcktEx->SetProperty(MAKEPROPSTRING(SIG_ID), &var, 0)))
    {
        pBcktEx->Release();
        return(hr);
    }
    
    hr = pBcktEx->QueryInterface(IID_IOptionBucket, (void **)&pSigBckt->pBckt);
    Assert(SUCCEEDED(hr));
    
    pBcktEx->Release();
    
    return(hr);
}

HRESULT CSignatureManager::GetSignature(LPCSTR szID, IOptionBucket **ppBckt)
{
    HRESULT hr;
    SIGBUCKET *pBckt;
    int i;
    
    Assert(szID != NULL);
    Assert(ppBckt != NULL);
    AssertSz(m_cBckt, "Someone didn't check to see if we had any sigs");
    
    *ppBckt = NULL;
    
    hr = Initialize();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        
        for (i = 0, pBckt = m_pBckt; i < m_cBckt; i++, pBckt++)
        {
            if (0 == lstrcmpi(pBckt->szID, szID))
            {
                hr = S_OK;
                
                if (pBckt->pBckt == NULL)
                    hr = GetBucket(pBckt);
                
                if (SUCCEEDED(hr))
                {
                    *ppBckt = pBckt->pBckt;
                    (*ppBckt)->AddRef();
                }
                
                break;
            }
        }
    }
    
    return(hr);
}

HRESULT CSignatureManager::GetSignatureCount(int *pcSig)
{
    HRESULT hr;
    
    Assert(pcSig != NULL);

    hr = Initialize();
    if (SUCCEEDED(hr))
        *pcSig = m_cBckt;
    
    return(hr);
}

HRESULT CSignatureManager::EnumSignatures(int index, IOptionBucket **ppBckt)
{
    HRESULT hr;
    SIGBUCKET *pBckt;
    
    Assert(ppBckt != NULL);
    
    *ppBckt = NULL;
    
    hr = Initialize();
    if (SUCCEEDED(hr))
    {
        if (index >= m_cBckt)
            return(S_FALSE);
        
        hr = S_OK;
        pBckt = &m_pBckt[index];
        
        if (pBckt->pBckt == NULL)
            hr = GetBucket(pBckt);
        
        if (SUCCEEDED(hr))
        {
            *ppBckt = pBckt->pBckt;
            (*ppBckt)->AddRef();
        }
    }
    
    return(hr);
}

static const char c_szIDFmt[] = "%08lx";

HRESULT CSignatureManager::CreateSignature(IOptionBucket **ppBckt)
{
    HRESULT hr;
    int cAlloc;
    DWORD id, dwDisp;
    HKEY hkey;
    SIGBUCKET *pBckt;
    char szKey[MAX_PATH], szID[MAXSIGID];
    
    Assert(ppBckt != NULL);
    
    *ppBckt = NULL;
    
    hr = Initialize();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        
        if (m_cBckt == m_cBcktBuf)
        {
            cAlloc = m_cBcktBuf + CSIGREALLOC;
            if (!MemRealloc((void **)&m_pBckt, cAlloc * sizeof(SIGBUCKET)))
                return(E_OUTOFMEMORY);
            
            m_cBcktBuf = cAlloc;
            ZeroMemory(&m_pBckt[m_cBckt], CSIGREALLOC * sizeof(SIGBUCKET));
        }
        
        pBckt = &m_pBckt[m_cBckt];
        id = 0;
        while (TRUE)
        {
            wsprintf(szID, c_szIDFmt, id);
            wsprintf(szKey, c_szPathFileFmt, m_szRegRoot, szID);
            if (ERROR_SUCCESS == RegCreateKeyEx(m_hkey, szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                KEY_READ, NULL, &hkey, &dwDisp))
            {
                RegCloseKey(hkey);
                
                if (dwDisp == REG_OPENED_EXISTING_KEY)
                {
                    id++;
                    continue;
                }
                
                lstrcpy(pBckt->szID, szID);
                hr = GetBucket(pBckt);
                
                if (SUCCEEDED(hr))
                {
                    m_cBckt++;
                    *ppBckt = pBckt->pBckt;
                    (*ppBckt)->AddRef();
                }
                else
                {
                    RegDeleteKey(m_hkey, szKey);
                }
            }
            
            break;
        }
    }
    
    return(hr);
}

HRESULT CSignatureManager::DeleteSignature(LPCSTR szID)
{
    HRESULT             hr;
    char                sz[MAX_PATH], 
                        szSigID[MAXSIGID];
    int                 i;
    SIGBUCKET          *pBckt;
    ACCTTYPE            type;
    IImnAccount        *pAcct;
    IImnEnumAccounts   *pEnum;
    BOOL                fDeletingDefault = FALSE;
    
    hr = Initialize();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        
        for (i = 0, pBckt = m_pBckt; i < m_cBckt; i++, pBckt++)
        {
            if (0 == lstrcmpi(pBckt->szID, szID))
            {
                fDeletingDefault = (0 == lstrcmpi(pBckt->szID, m_szDefSigID));

                wsprintf(sz, c_szPathFileFmt, m_szRegRoot, szID);
                if (ERROR_SUCCESS == SHDeleteKey(m_hkey, sz))
                {
                    if (pBckt->pBckt != NULL)
                    {
                        pBckt->pBckt->Release();
                        pBckt->pBckt = NULL;
                    }
                    if (i + 1 < m_cBckt)
                        MoveMemory(&m_pBckt[i], &m_pBckt[i + 1], (m_cBckt - (i + 1)) * sizeof(SIGBUCKET));
                    m_cBckt--;
                    m_pBckt[m_cBckt].pBckt = NULL;
                    hr = S_OK;
                    
                    Assert(g_pAcctMan != NULL);
                    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
                    {
                        Assert(pEnum != NULL);
                        
                        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
                        {
                            Assert(pAcct != NULL);
                            hr = pAcct->GetAccountType(&type);
                            Assert(SUCCEEDED(hr));
                            
                            if (SUCCEEDED(pAcct->GetPropSz(type == ACCT_MAIL ? AP_SMTP_SIGNATURE : AP_NNTP_SIGNATURE, szSigID, ARRAYSIZE(szSigID))) &&
                                0 == lstrcmpi(szSigID, szID))
                            {
                                pAcct->SetPropSz(type == ACCT_MAIL ? AP_SMTP_SIGNATURE : AP_NNTP_SIGNATURE, NULL);
                                pAcct->SaveChanges();
                            }
                            
                            pAcct->Release();
                        }
                        
                        pEnum->Release();
                    }
                }
                
                break;
            }
        }
        if (fDeletingDefault)
        {
            if (m_cBckt > 0)
                SetDefaultSignature(m_pBckt->szID);
            else
                SetDefaultSignature("");
        }
    }
    
    return(hr);
}

HRESULT CSignatureManager::GetDefaultSignature(LPSTR szID)
{
    HRESULT hr;
    
    AssertSz(m_cBckt, "Someone didn't check to see if we had any sigs");

    hr = Initialize();
    if (SUCCEEDED(hr))
        lstrcpy(szID, m_szDefSigID);
    
    return(hr);
}

HRESULT CSignatureManager::SetDefaultSignature(LPCSTR szID)
{
    HRESULT hr;
    
    Assert(szID != NULL);
    Assert(lstrlen(szID) < MAXSIGID);
    
    hr = Initialize();
    if (SUCCEEDED(hr))
    {
        if (ERROR_SUCCESS == SHSetValue(m_hkey, m_szRegRoot, c_szRegDefSig, REG_SZ, szID, lstrlen(szID) + 1))
            lstrcpy(m_szDefSigID, szID);
        else
            hr = E_FAIL;
    }
    
    return(hr);
}

// TODO: error handling would be useful
SIGOPT *InitSigOpt(void)
{
    HRESULT hr;
    int i, cSig;
    SIG *pSig;
    char szDef[MAXSIGID];
    PROPVARIANT var;
    SIGOPT *pSigOpt = NULL;
    
    Assert(g_pSigMgr != NULL);
    
    if (MemAlloc((void **)&pSigOpt, sizeof(SIGOPT)))
    {
        ZeroMemory(pSigOpt, sizeof(SIGOPT));
        
        pSigOpt->iDefSig = -1;
        pSigOpt->iInvalidSig = -1;
        
        hr = g_pSigMgr->GetSignatureCount(&cSig);
        Assert(SUCCEEDED(hr));
        if (cSig > 0)
        {
            pSigOpt->cSigBuf = cSig + CSIGREALLOC;
            if (MemAlloc((void **)&pSigOpt->pSig, pSigOpt->cSigBuf * sizeof(SIG)))
            {
                ZeroMemory(pSigOpt->pSig, pSigOpt->cSigBuf * sizeof(SIG));
                
                hr = g_pSigMgr->GetDefaultSignature(szDef);
                Assert(SUCCEEDED(hr));
                Assert(szDef[0] != 0);
                
                for (i = 0, pSig = pSigOpt->pSig; i < cSig; i++, pSig++)
                {
                    hr = g_pSigMgr->EnumSignatures(i, &pSig->pBckt);
                    if (hr != S_OK)
                        break;
                    
                    Assert(pSig->pBckt != NULL);
                    
                    if (pSigOpt->iDefSig == -1)
                    {
                        hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0);
                        Assert(SUCCEEDED(hr));
                        Assert(var.vt == VT_LPSTR);
                        Assert(var.pszVal != NULL);
                        if (0 == lstrcmpi(szDef, var.pszVal))
                            pSigOpt->iDefSig = i;
                        MemFree(var.pszVal);
                    }
                    
                    hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_NAME), &var, 0);
                    Assert(SUCCEEDED(hr));
                    Assert(var.vt == VT_LPSTR);
                    Assert(var.pszVal != NULL);
                    lstrcpy(pSig->szName, var.pszVal);
                    MemFree(var.pszVal);
                    
                    hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_TYPE), &var, 0);
                    Assert(SUCCEEDED(hr));
                    Assert(var.vt == VT_UI4);
                    pSig->type = var.ulVal;
                    
                    if (pSig->type == SIGTYPE_TEXT)
                    {
                        hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_TEXT), &var, 0);
                        Assert(SUCCEEDED(hr));
                        Assert(var.vt == VT_LPSTR);
                        Assert(var.pszVal != NULL);
                        pSig->szText = var.pszVal;
                    }
                    else
                    {
                        Assert(pSig->type == SIGTYPE_FILE);
                        hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_FILE), &var, 0);
                        Assert(SUCCEEDED(hr));
                        Assert(var.vt == VT_LPWSTR);
                        Assert(var.pwszVal != NULL);
                        pSig->wszFile = var.pwszVal;
                    }
                    
                    pSigOpt->cSig++;
                }
            }
        }
    }
    
    return(pSigOpt);
}

void DeinitSigOpt(SIGOPT *pSigOpt)
{
    int i;
    SIG *pSig;
    ACCTSIG *pAcctSig;
    
    if (pSigOpt != NULL)
    {
        if (pSigOpt->pSig != NULL)
        {
            for (i = 0, pSig = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSig++)
            {
                if (pSig->wszFile != NULL)
                    MemFree(pSig->wszFile);
                if (pSig->szText != NULL)
                    MemFree(pSig->szText);
                if (pSig->pBckt != NULL)
                    pSig->pBckt->Release();
            }
            
            MemFree(pSigOpt->pSig);
        }
        
        if (pSigOpt->pAcctSig != NULL)
        {
            for (i = 0, pAcctSig = pSigOpt->pAcctSig; i < pSigOpt->cAcctSig; i++, pAcctSig++)
            {
                if (pAcctSig->pAcct != NULL)
                    pAcctSig->pAcct->Release();
            }
            
            MemFree(pSigOpt->pAcctSig);
        }
        
        MemFree(pSigOpt);
    }
}

int InsertSig(HWND hwndList, SIG *pSig, int i)
{
    int index;
    LV_ITEM lvi;
    
    Assert(pSig != NULL);
    
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = i;
    lvi.iSubItem = 0;
    lvi.pszText = pSig->szName;
    lvi.lParam = i;
    index = ListView_InsertItem(hwndList, &lvi);
    Assert(index != -1);
    
    return(index);
}

void SetDefault(HWND hwndList, int iOldDef, int iNewDef)
{
    char sz[64];
    LV_FINDINFO lvfi;
    int i;
    
    if (iOldDef >= 0)
    {
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = iOldDef;
        i = ListView_FindItem(hwndList, -1, &lvfi);
        
        ListView_SetItemText(hwndList, i, 1, (LPSTR)c_szEmpty);
    }
    
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = iNewDef;
    i = ListView_FindItem(hwndList, -1, &lvfi);
    
    AthLoadString(idsDefaultSignature, sz, ARRAYSIZE(sz));
    ListView_SetItemText(hwndList, i, 1, sz);
}

void EnableSignatureWindows(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVE_BUTTON), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RENAME_BUTTON), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_TEXT_RADIO), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_TEXT_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_FILE_RADIO), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_FILE_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE_BUTTON), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_DEFAULT_BUTTON), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_ADV_BUTTON), fEnable);
    
    if (!fEnable)
    {
        CheckDlgButton(hwnd, IDC_TEXT_RADIO, BST_UNCHECKED);
        SetDlgItemText(hwnd, IDC_TEXT_EDIT, c_szEmpty);
        CheckDlgButton(hwnd, IDC_FILE_RADIO, BST_UNCHECKED);
        SetDlgItemText(hwnd, IDC_FILE_EDIT, c_szEmpty);
        
        if (!IsWindowEnabled(GetFocus()))
            SetFocus(GetDlgItem(hwnd, IDC_NEW_BUTTON));
    }
}

WNDPROC g_SigListUnicodeProc = NULL;
LRESULT CALLBACK SigListANSIProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    return(CallWindowProc(g_SigListUnicodeProc, hwnd, msg, wParam, lParam));
}

void InitSigDlg(HWND hwnd, SIGOPT *pSigOpt, OPTINFO *poi)
{
    HWND hwndList, hwndT;
    RECT rc;
    int i;
    DWORD dw;
    LV_COLUMN lvc;
    SIG *pSig;
    
    Assert(pSigOpt != NULL);
    
    hwndT = GetDlgItem(hwnd, IDC_TEXT_EDIT);
    SetIntlFont(hwndT);
    SendMessage(hwndT, EM_LIMITTEXT, MAXSIGTEXT - 1, 0);

    hwndT = GetDlgItem(hwnd, IDC_FILE_EDIT);
    SetIntlFont(hwndT);
    SendMessage(hwndT, EM_LIMITTEXT, MAX_PATH - 1, 0);
    
    dw = IDwGetOption(poi->pOpt, OPT_SIGNATURE_FLAGS);
    CheckDlgButton(hwnd, IDC_ADDSIG_CHECK,
        !!(dw & SIGFLAG_AUTONEW) ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hwnd, IDC_ADDREPLY_CHECK,
        !(dw & SIGFLAG_AUTOREPLY) ? BST_CHECKED : BST_UNCHECKED);
    
    if (!(dw & SIGFLAG_AUTONEW))
        EnableWindow(GetDlgItem(hwnd, IDC_ADDREPLY_CHECK), FALSE);
    
    hwndList = GetDlgItem(hwnd, IDC_SIG_LIST);
    g_SigListUnicodeProc = (WNDPROC) SetWindowLongPtr(hwndList, GWLP_WNDPROC, (LONG_PTR)SigListANSIProc);
    GetClientRect(hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    rc.right = rc.right / 2;
    
    lvc.mask = LVCF_WIDTH;
    lvc.cx = rc.right;
    ListView_InsertColumn(hwndList, 0, &lvc);
    ListView_InsertColumn(hwndList, 1, &lvc);
    
    for (i = 0, pSig = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSig++)
        InsertSig(hwndList, pSig, i);
    
    if (pSigOpt->iDefSig >= 0)
        SetDefault(hwndList, -1, pSigOpt->iDefSig);
    
    if (pSigOpt->cSig > 0)
    {
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    else
    {
        EnableSignatureWindows(hwnd, FALSE);
        EnableSigOptions(hwnd, FALSE);
    }
    
    // Pictures
    HICON hIcon;
    
    hIcon = ImageList_GetIcon(poi->himl, ID_SIGNATURES, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SIG_SETTINGS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_SIG_LIST, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SIGLIST_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_SIG_EDIT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SIG_EDIT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
}

BOOL IsUniqueSigName(LPCSTR szName, SIGOPT *pSigOpt)
{
    int i;
    SIG *pSig;
    
    for (i = 0, pSig = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSig++)
    {
        if (!pSig->fDelete &&
            0 == lstrcmpi(szName, pSig->szName))
            return(FALSE);
    }
    
    return(TRUE);
}

int GetItemIndex(HWND hwndList, int i)
{
    LV_ITEM lvi;
    
    if (i == -1)
    {
        // get the selected item's index
        i = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
        Assert(i >= 0);
    }
    
    lvi.iItem = i;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    ListView_GetItem(hwndList, &lvi);
    
    return((int)(INT_PTR)(lvi.lParam));
}

HRESULT HandleNewSig(HWND hwnd, SIGOPT *pSigOpt)
{
    HRESULT hr;
    SIG *pSig;
    char sz[MAXSIGNAME];
    int i, cSig, cAlloc;
    HWND hwndList;
    
    hwndList = GetDlgItem(hwnd, IDC_SIG_LIST);
    
    cSig = ListView_GetItemCount(hwndList);
    if (cSig > 0)
    {
        i = GetItemIndex(hwndList, -1);
        if (i >= 0)
        {
            hr = ValidateSig(hwnd, hwndList, i, pSigOpt);
            if (FAILED(hr))
                return(E_FAIL);
        }
    }
    
    if (pSigOpt->cSig == pSigOpt->cSigBuf)
    {
        cAlloc = pSigOpt->cSigBuf + CSIGREALLOC;
        if (!MemRealloc((void **)&pSigOpt->pSig, cAlloc * sizeof(SIG)))
            return(E_OUTOFMEMORY);
        
        ZeroMemory(&pSigOpt->pSig[pSigOpt->cSig], CSIGREALLOC * sizeof(SIG));
        pSigOpt->cSigBuf = cAlloc;
    }
    
    pSig = &pSigOpt->pSig[pSigOpt->cSig];
    
    AthLoadString(idsSigNameFmt, sz, ARRAYSIZE(sz));
    for (i = 1; i < 10000; i++)
    {
        wsprintf(pSig->szName, sz, i);
        if (IsUniqueSigName(pSig->szName, pSigOpt))
            break;
    }
    
    if (i == 10000)
        return(E_FAIL);
    
    pSig->type = SIGTYPE_TEXT;
    
    i = InsertSig(hwndList, pSig, pSigOpt->cSig);
    if (pSigOpt->iDefSig == -1)
    {
        SetDefault(hwndList, -1, pSigOpt->cSig);
        pSigOpt->iDefSig = pSigOpt->cSig;
    }
    
    pSigOpt->cSig++;
    
    if (cSig == 0)
    {
        EnableSignatureWindows(hwnd, TRUE);
        EnableSigOptions(hwnd, TRUE);
    }
    
    EnableWindow(GetDlgItem(hwnd, IDC_DEFAULT_BUTTON), pSigOpt->iDefSig != GetItemIndex(hwndList, i));
    
    ListView_SetItemState(hwndList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList, i, FALSE);
    SetFocus(GetDlgItem(hwnd, IDC_TEXT_EDIT));
    
    return(S_OK);
}

HRESULT HandleDeleteSig(HWND hwnd, SIGOPT *pSigOpt)
{
    int i, iSig, iNewSel, cSig;
    HWND hwndList;
    SIG *pSig;
    
    hwndList = GetDlgItem(hwnd, IDC_SIG_LIST);
    
    i = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
    Assert(i >= 0);
    
    iSig = GetItemIndex(hwndList, i);
    
    pSig = &pSigOpt->pSig[iSig];
    Assert(!pSig->fDelete);
    pSig->fDelete = TRUE;
    
    ListView_DeleteItem(hwndList, i);
    
    cSig = ListView_GetItemCount(hwndList);
    if (cSig == 0)
        iNewSel = -1;
    else if (i == 0)
        iNewSel = 0;
    else
        iNewSel = i - 1;
    
    Assert(pSigOpt->iDefSig >= 0);
    if (iSig == pSigOpt->iDefSig)
    {
        if (iNewSel >= 0)
        {
            iSig = GetItemIndex(hwndList, iNewSel);
            
            SetDefault(hwndList, -1, iSig);
            pSigOpt->iDefSig = iSig;
            
            EnableWindow(GetDlgItem(hwnd, IDC_DEFAULT_BUTTON), FALSE);
        }
        else
        {
            pSigOpt->iDefSig = -1;
        }
    }
    
    if (iNewSel >= 0)
    {
        ListView_SetItemState(hwndList, iNewSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_EnsureVisible(hwndList, iNewSel, FALSE);
    }
    else
    {
        EnableSignatureWindows(hwnd, FALSE);
        EnableSigOptions(hwnd, FALSE);
    }
    
    return(S_OK);
}

HRESULT HandleSigRename(HWND hwnd, LV_DISPINFO *pdi, SIGOPT *pSigOpt)
{
    HWND hwndList;
    SIG *pSig, *pSigT;
    LPSTR pszText = NULL;
    HRESULT hr = S_OK;
    int i;
    
    Assert(pdi != NULL);
    Assert(pSigOpt != NULL);

    IF_TRUEEXIT((pdi->item.pszText == NULL || FIsEmpty(pdi->item.pszText)), S_FALSE);

    if(IsWindowUnicode(hwnd))
        pszText = PszToANSI(CP_ACP, (WCHAR*)(pdi->item.pszText));
    else
        pszText = StrDupA(pdi->item.pszText);

    IF_NULLEXIT(pszText);    
    IF_TRUEEXIT((lstrlen(pszText) >= MAXSIGNAME), S_FALSE);
    
    pSig = &pSigOpt->pSig[pdi->item.lParam];
    Assert(!pSig->fDelete);
    Assert(pSig->szName[0] != 0);
    
    IF_TRUEEXIT((0 == lstrcmpi(pSig->szName, pszText)), S_FALSE);
    
    for (i = 0, pSigT = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSigT++)
    {
        if (pSigT->fDelete)
            continue;

        IF_TRUEEXIT((0 == lstrcmpi(pSigT->szName, pszText)), S_FALSE);
    }
    
    lstrcpy(pSig->szName, pszText);
    
exit:
    MemFree(pszText);
    return hr;
}

static const int c_rgidsFilter[] =
{
    idsTextFileFilter,
        idsHtmlFileFilter,
        idsAllFilesFilter
};

HRESULT HandleBrowseButton(HWND hwnd)
{
    OPENFILENAMEW ofnw;
    WCHAR         wszFilter[MAX_PATH], wszFile[MAX_PATH], wszDir[MAX_PATH];
    HRESULT       hr;
    int           cch;
    LPWSTR        pwszFile;
    
    hr = S_FALSE;
    *wszFilter = 0;
    *wszFile = 0;
    
    ZeroMemory(&ofnw, sizeof(ofnw));
    ofnw.lStructSize = sizeof(ofnw);
    
    cch = GetDlgItemTextWrapW(hwnd, IDC_FILE_EDIT, wszDir, ARRAYSIZE(wszDir));
    if (cch > 0)
    {
        if (PathIsDirectoryW(wszDir))
        {
            ofnw.lpstrInitialDir = wszDir;
        }
        else if (PathFileExistsW(wszDir))
        {
            pwszFile = PathFindFileNameW(wszDir);
            if (pwszFile != NULL)
                lstrcpyW(wszFile, pwszFile);

            *pwszFile = 0;
            
            if (*wszDir != 0)
                ofnw.lpstrInitialDir = wszDir;

        }
        else if (PathIsFileSpecW(wszDir))
        {
            lstrcpyW(wszFile, wszDir);
        }
    }
    
    CombineFiltersW((int *)c_rgidsFilter, ARRAYSIZE(c_rgidsFilter), wszFilter);
    ofnw.hwndOwner = hwnd;
    ofnw.lpstrFile = wszFile;
    ofnw.lpstrFilter = wszFilter;
    ofnw.nMaxFile = ARRAYSIZE(wszFile);
    ofnw.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NONETWORKBUTTON | OFN_NOCHANGEDIR | OFN_EXPLORER;
    if (HrAthGetFileNameW(&ofnw, TRUE)==S_OK)
    {
        SetDlgItemTextWrapW(hwnd, IDC_FILE_EDIT, wszFile);
        hr = S_OK;
    }
    
    return(hr);
}

HRESULT ValidateSig(HWND hwnd, HWND hwndList, int iSig, SIGOPT *pSigOpt)
{
    SIG     *pSig;
    BOOL    fText;
    HWND    hwndT;
    int     cch, id, i;
    char    **ppsz, *psz;
    
    Assert(pSigOpt != NULL);
    Assert(iSig < pSigOpt->cSig);
    
    pSig = &pSigOpt->pSig[iSig];
    if (pSig->fDelete)
        return(S_OK);
    
    fText = (IsDlgButtonChecked(hwnd, IDC_TEXT_RADIO) == BST_CHECKED);
    id = fText ? IDC_TEXT_EDIT : IDC_FILE_EDIT;
    hwndT = GetDlgItem(hwnd, id);
    cch = GetWindowTextLength(hwndT);
    if (cch == 0)
    {
        i = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
        ListView_SetItemState(hwndList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
        InvalidOptionProp(hwnd, id, fText ? idsEnterSigText : idsEnterSigFile, iddOpt_Signature);
        return(E_FAIL);
    }
    
    cch++;
    if (!fText)
    {
        WCHAR   *pwsz = NULL;

        if (!MemAlloc((void **)&pwsz, cch * sizeof(*pwsz)))
            return(E_OUTOFMEMORY);

        GetWindowTextWrapW(hwndT, pwsz, cch);
        if (!PathFileExistsW(pwsz) || PathIsDirectoryW(pwsz))
        {
            MemFree(pwsz);
            i = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
            ListView_SetItemState(hwndList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
            InvalidOptionProp(hwnd, id, idsSigFileNoExistError, iddOpt_Signature);
            return(E_FAIL);
        }
        else
        {
            //Free the previous sig file
            MemFree(pSig->wszFile);
            pSig->wszFile = pwsz;
        }
    }
    else
    {
        if (!MemAlloc((void **)&psz, cch))
            return(E_OUTOFMEMORY);
        GetWindowText(hwndT, psz, cch);

        //Free the previous sig text
        MemFree(pSig->szText);

        pSig->szText = psz;
    }

    pSig->type = fText ? SIGTYPE_TEXT : SIGTYPE_FILE;
    
    return(S_OK);
}

HRESULT SaveSigs(HWND hwnd, SIGOPT *pSigOpt)
{
    int cSigT, cSig, i;
    SIG *pSig;
    ACCTSIG *pAcctSig;
    PROPVARIANT var;
    HRESULT hr;
    HWND hwndList;
    char *szSigID;
    
    Assert(pSigOpt != NULL);
    Assert(g_pSigMgr != NULL);
    
    hwndList = GetDlgItem(hwnd, IDC_SIG_LIST);
    cSig = ListView_GetItemCount(hwndList);
    
    cSigT = 0;
    for (i = 0, pSig = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSig++)
    {
        if (pSig->fDelete)
        {
            if (pSig->pBckt != NULL)
            {
                if (SUCCEEDED(pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0)) && var.pszVal != NULL)
                {
                    g_pSigMgr->DeleteSignature(var.pszVal);
                    MemFree(var.pszVal);
                }
            }
            
            continue;
        }
        else
        {
            if (pSig->pBckt == NULL)
            {
                hr = g_pSigMgr->CreateSignature(&pSig->pBckt);
                Assert(SUCCEEDED(hr));
                Assert(pSig->pBckt != NULL);
            }
            
            if (pSigOpt->iDefSig == i)
            {
                if (SUCCEEDED(pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0)) && var.pszVal)
                {
                    g_pSigMgr->SetDefaultSignature(var.pszVal);
                    MemFree(var.pszVal);
                }
            }
            
            var.vt = VT_LPSTR;
            var.pszVal = pSig->szName;
            hr = pSig->pBckt->SetProperty(MAKEPROPSTRING(SIG_NAME), &var, 0);
            AssertSz(SUCCEEDED(hr), "Sig name failed to be set");
            
            var.vt = VT_UI4;
            var.ulVal = pSig->type;
            hr = pSig->pBckt->SetProperty(MAKEPROPSTRING(SIG_TYPE), &var, 0);
            AssertSz(SUCCEEDED(hr), "Sig type failed to be set");
            
            var.vt = VT_LPSTR;
            AssertSz(((SIGTYPE_TEXT == pSig->type) ? (NULL != pSig->szText) : TRUE), "Text should be set.");
            var.pszVal = (SIGTYPE_TEXT == pSig->type) ? pSig->szText : (LPSTR)c_szEmpty;
            hr = pSig->pBckt->SetProperty(MAKEPROPSTRING(SIG_TEXT), &var, 0);
            AssertSz(SUCCEEDED(hr), "Sig text failed to be set");
            
            var.vt = VT_LPWSTR;
            var.pwszVal = (pSig->type == SIGTYPE_FILE) ? pSig->wszFile : (LPWSTR)c_wszEmpty;
            hr = pSig->pBckt->SetProperty(MAKEPROPSTRING(SIG_FILE), &var, 0);
            AssertSz(SUCCEEDED(hr), "Sig filename failed to be set");
            
            cSigT++;
        }
    }
    
    Assert(cSig == cSigT);
    
    for (i = 0, pAcctSig = pSigOpt->pAcctSig; i < pSigOpt->cAcctSig; i++, pAcctSig++)
    {
        szSigID = NULL;
        if (pAcctSig->iSig >= 0)
        {
            pSig = &pSigOpt->pSig[pAcctSig->iSig];
            if (!pSig->fDelete)
            {
                hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0);
                Assert(SUCCEEDED(hr));
                Assert(var.pszVal != NULL);
                szSigID = var.pszVal;
            }
        }
        
        hr = pAcctSig->pAcct->SetPropSz(pAcctSig->type == ACCT_MAIL ? AP_SMTP_SIGNATURE : AP_NNTP_SIGNATURE, szSigID);
        Assert(SUCCEEDED(hr));
        hr = pAcctSig->pAcct->SaveChanges();
        Assert(SUCCEEDED(hr));
        
        if (szSigID != NULL)
            MemFree(szSigID);
    }
    
    return(S_OK);
}
    
void EnableSigWindows(HWND hwnd, BOOL fText)
{
    HWND focus;
    
    focus = GetFocus();
    
    EnableWindow(GetDlgItem(hwnd, IDC_TEXT_EDIT), fText);    
    EnableWindow(GetDlgItem(hwnd, IDC_FILE_EDIT), !fText);    
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE_BUTTON), !fText);    
    
    // don't disable button that has the focus
    if (!IsWindowEnabled(focus))
        SetFocus(GetDlgItem(hwnd, fText ? IDC_TEXT_EDIT : IDC_FILE_EDIT));
}

void EnableSigOptions(HWND hwnd, BOOL fEnable)
{
    HWND hwndT;
    
    hwndT = GetDlgItem(hwnd, IDC_ADDSIG_CHECK);
    
    EnableWindow(hwndT, fEnable);
    
    if (fEnable)
        fEnable = (SendMessage(hwndT, BM_GETCHECK, 0, 0) == BST_CHECKED);
    
    EnableWindow(GetDlgItem(hwnd, IDC_ADDREPLY_CHECK), fEnable);
}

static const HELPMAP g_rgCtxMapSigs[] = {
    {IDC_ADDSIG_CHECK,          353569},
    {IDC_ADDREPLY_CHECK,        35610},
    {IDC_SIG_LIST,              35594},
    {IDC_NEW_BUTTON,            35591},
    {IDC_REMOVE_BUTTON,         35592},
    {IDC_RENAME_BUTTON,         35593},
    {IDC_TEXT_EDIT,             35595},
    {IDC_FILE_EDIT,             35600},
    {IDC_DEFAULT_BUTTON,        35596},
    {IDC_ADV_BUTTON,            35597},
    {IDC_BROWSE_BUTTON,         35605},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_SIG_SETTINGS_ICON,     IDH_NEWS_COMM_GROUPBOX},
    {IDC_SIGLIST_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {IDC_SIG_EDIT_ICON,         IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

WNDPROC g_SigRenameEditUnicodeProc = NULL;
LRESULT CALLBACK SigRenameEditANSIProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    return(CallWindowProc(g_SigRenameEditUnicodeProc, hwnd, msg, wParam, lParam));
}

INT_PTR CALLBACK SigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    SIGOPT *pSigOpt;
    WORD code, id;
    SIG *pSig;
    int i, cSig;
    DWORD dw;
    OPTINFO *poi;
    LPNMHDR pnmh;
    NM_LISTVIEW *pnmlv;
    HRESULT hr;
    HWND hwndList;
    BOOL fEnable, fRet = TRUE;
    
    pSigOpt = (SIGOPT *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    hwndList = GetDlgItem(hwnd, IDC_SIG_LIST);
    
    switch (msg)
    {
        case WM_INITDIALOG:
            Assert(poi == NULL);
            poi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
            Assert(poi != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
        
            pSigOpt = InitSigOpt();
            Assert(pSigOpt != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pSigOpt);
        
            InitSigDlg(hwnd, pSigOpt, poi);
        
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            break;
        
        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SIG_SETTINGS_ICON);
            FreeIcon(hwnd, IDC_SIGLIST_ICON);
            FreeIcon(hwnd, IDC_SIG_EDIT_ICON);
        
            if (pSigOpt != NULL)
            {
                DeinitSigOpt(pSigOpt);
                SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            }

	    SetWindowLongPtr(hwndList, GWLP_WNDPROC, (LONG_PTR)g_SigListUnicodeProc);
            g_SigListUnicodeProc = NULL;
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxMapSigs);
        
        case WM_COMMAND:
            if (poi == NULL)
                break;
        
            code = HIWORD(wParam);
            id = LOWORD(wParam);
            switch (id)
            {
                case IDC_FILE_EDIT:
                case IDC_TEXT_EDIT:
                    if (code == EN_CHANGE && !pSigOpt->fNoDirty)
                        SetPageDirty(poi, hwnd, PAGE_SIGS);
                    break;
            
                case IDC_FILE_RADIO:
                case IDC_TEXT_RADIO:
                    if (code == BN_CLICKED)
                    {
                        EnableSigWindows(hwnd, id == IDC_TEXT_RADIO);
                        SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }
                    break;
            
                case IDC_ADDREPLY_CHECK:
                case IDC_SIGBOTTOM_CHECK:
                    if (code == BN_CLICKED)
                        SetPageDirty(poi, hwnd, PAGE_SIGS);
                    break;
            
                case IDC_ADDSIG_CHECK:
                    if (code == BN_CLICKED)
                    {
                        fEnable = (IsDlgButtonChecked(hwnd, IDC_ADDSIG_CHECK) == BST_CHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_ADDREPLY_CHECK), fEnable);
                
                        SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }
                    break;
            
                case IDC_NEW_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        if (SUCCEEDED(HandleNewSig(hwnd, pSigOpt)))
                            SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }
                    break;
            
                case IDC_REMOVE_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        if (SUCCEEDED(HandleDeleteSig(hwnd, pSigOpt)))
                            SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }
                    break;
                    
                case IDC_RENAME_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        i = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
                        Assert(i >= 0);
                        SetFocus(hwndList);
                        ListView_EditLabel(hwndList, i);
                    }
                    break;
                    
                case IDC_DEFAULT_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        i = GetItemIndex(hwndList, -1);
                        if (i != pSigOpt->iDefSig)
                        {
                            SetDefault(hwndList, pSigOpt->iDefSig, i);
                            pSigOpt->iDefSig = i;
                            SetPageDirty(poi, hwnd, PAGE_SIGS);
                            
                            EnableWindow(GetDlgItem(hwnd, IDC_DEFAULT_BUTTON), FALSE);
                            if (!IsWindowEnabled(GetFocus()))
                                SetFocus(GetDlgItem(hwnd, IDC_NEW_BUTTON));
                        }
                    }
                    break;
                    
                case IDC_BROWSE_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        if (S_OK == HandleBrowseButton(hwnd))
                            SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }
                    break;
                    
                case IDC_ADV_BUTTON:
                    if (code == BN_CLICKED)
                    {
                        pSigOpt->iSelSig = GetItemIndex(hwndList, -1);
                        Assert(pSigOpt->iSelSig >= 0);
                        if (IDOK == DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddAdvSig), hwnd, AdvSigDlgProc, (LPARAM)pSigOpt))
                            SetPageDirty(poi, hwnd, PAGE_SIGS);
                    }    
                    break;
            }
            break;
            
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_APPLY:
                    Assert(poi != NULL);
                
                    cSig = ListView_GetItemCount(hwndList);
                    if (cSig > 0)
                    {
                        i = GetItemIndex(hwndList, -1);
                        hr = ValidateSig(hwnd, hwndList, i, pSigOpt);
                        if (hr != S_OK)
                        {
                            SetDlgMsgResult(hwnd, WM_NOTIFY, PSNRET_INVALID_NOCHANGEPAGE);
                            return (PSNRET_INVALID_NOCHANGEPAGE);
                        }
                    }
                
                    dw = 0;
                    if (cSig > 0 &&
                        IsDlgButtonChecked(hwnd, IDC_ADDSIG_CHECK) == BST_CHECKED)
                    {
                        dw = SIGFLAG_AUTONEW;
                        if (IsDlgButtonChecked(hwnd, IDC_ADDREPLY_CHECK) == BST_UNCHECKED)
                            dw |= SIGFLAG_AUTOREPLY;
                    }
                    ISetDwOption(poi->pOpt, OPT_SIGNATURE_FLAGS, dw, NULL, 0);
                    
                    SaveSigs(hwnd, pSigOpt);
                    
                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    break;
                    
                
                case LVN_BEGINLABELEDITW:
                    {
                        HWND hwndEdit;

                        hwndEdit = ListView_GetEditControl(hwndList);
                        if(hwndEdit)
			    g_SigRenameEditUnicodeProc = (WNDPROC) SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)SigRenameEditANSIProc);
                    }
                case LVN_BEGINLABELEDITA:
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE);
                    break;

                case LVN_ENDLABELEDITW:
                    {
                        HWND hwndEdit;

                        hwndEdit = ListView_GetEditControl(hwndList);

                        if(hwndEdit)
                        {
			    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)g_SigRenameEditUnicodeProc);
                            g_SigRenameEditUnicodeProc = NULL;
                        }
                    }
                case LVN_ENDLABELEDITA:                
                    hr = HandleSigRename(hwnd, (LV_DISPINFO *)pnmh, pSigOpt);
                    if (hr == S_OK)
                        SetPageDirty(poi, hwnd, PAGE_SIGS);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, hr == S_OK);
                    break;

                case LVN_ITEMCHANGING:
                    pnmlv = (NM_LISTVIEW *)pnmh;
                    if (!!(pnmlv->uOldState & LVIS_FOCUSED) &&
                        !(pnmlv->uNewState & LVIS_FOCUSED) &&
                        pnmlv->iItem != -1)
                    {
                        // item is losing selection
                        
                        if (pSigOpt->iInvalidSig != -1)
                        {
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                            pSigOpt->iInvalidSig = -1;
                            break;
                        }
                        
                        hr = ValidateSig(hwnd, hwndList, (int)pnmlv->lParam, pSigOpt);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, hr != S_OK);
                        if (hr != S_OK)
                            pSigOpt->iInvalidSig = pnmlv->iItem;
                    }
                    break;
                    
                case LVN_ITEMCHANGED:
                    pnmlv = (NM_LISTVIEW *)pnmh;
                    if (!(pnmlv->uOldState & LVIS_FOCUSED) &&
                        !!(pnmlv->uNewState & LVIS_FOCUSED) &&
                        pnmlv->iItem != -1)
                    {
                        // item is becoming the selection
                        
                        Assert(pSigOpt->iInvalidSig == -1);
                        
                        pSigOpt->fNoDirty = TRUE;
                        
                        pSig = &pSigOpt->pSig[pnmlv->lParam];
                        if (pSig->type == SIGTYPE_TEXT)
                        {
                            CheckDlgButton(hwnd, IDC_TEXT_RADIO, BST_CHECKED);
                            SetDlgItemText(hwnd, IDC_TEXT_EDIT, pSig->szText != NULL ? pSig->szText : c_szEmpty);
                            CheckDlgButton(hwnd, IDC_FILE_RADIO, BST_UNCHECKED);
                            SetDlgItemText(hwnd, IDC_FILE_EDIT, c_szEmpty);
                        }
                        else
                        {
                            Assert(pSig->type == SIGTYPE_FILE);
                            CheckDlgButton(hwnd, IDC_FILE_RADIO, BST_CHECKED);
                            SetDlgItemTextWrapW(hwnd, IDC_FILE_EDIT, pSig->wszFile != NULL ? pSig->wszFile : c_wszEmpty);
                            CheckDlgButton(hwnd, IDC_TEXT_RADIO, BST_UNCHECKED);
                            SetDlgItemText(hwnd, IDC_TEXT_EDIT, c_szEmpty);
                        }
                        EnableSigWindows(hwnd, pSig->type == SIGTYPE_TEXT);
                        
                        EnableWindow(GetDlgItem(hwnd, IDC_DEFAULT_BUTTON), pSigOpt->iDefSig != GetItemIndex(hwndList, pnmlv->iItem));
                        
                        pSigOpt->fNoDirty = FALSE;
                    }
                    break;
                    
                default:
                    break;
            }
            break;
                
        default:
            fRet = FALSE;
            break;
    }

    return(fRet);
}

HRESULT FillSignatureMenu(HMENU hmenu, LPCSTR szAcct)
{
    HRESULT hr;
    int i, cSig, iDef;
    char *psz, szDef[MAXSIGID], sz[MAXSIGNAME + 64], szT[64];
    IOptionBucket *pSig;
    PROPVARIANT var;
    
    Assert(g_pSigMgr != NULL);
    
    hr = g_pSigMgr->GetSignatureCount(&cSig);
    Assert(SUCCEEDED(hr));
    Assert(cSig > 0);
    
    hr = g_pSigMgr->GetDefaultSignature(szDef);
    Assert(SUCCEEDED(hr));
    Assert(szDef[0] != 0);
    
    iDef = -1;
    for (i = 0; i < cSig; i++)
    {
        hr = g_pSigMgr->EnumSignatures(i, &pSig);
        if (hr != S_OK)
            break;
        
        Assert(pSig != NULL);
        
        if (iDef == -1)
        {
            hr = pSig->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0);
            Assert(SUCCEEDED(hr));
            Assert(var.vt == VT_LPSTR);
            Assert(var.pszVal != NULL);
            if (0 == lstrcmpi(szDef, var.pszVal))
                iDef = i;
            MemFree(var.pszVal);
        }
        
        hr = pSig->GetProperty(MAKEPROPSTRING(SIG_NAME), &var, 0);
        Assert(SUCCEEDED(hr));
        Assert(var.vt == VT_LPSTR);
        Assert(var.pszVal != NULL);
        
        if (i == iDef)
        {
            AthLoadString(idsDefaultAccount, szT, ARRAYSIZE(szT));
            wsprintf(sz, c_szSpaceCatFmt, var.pszVal, szT);
            psz = sz;
        }
        else
        {
            psz = var.pszVal;
        }
        
        InsertMenu(hmenu, i, MF_BYPOSITION | MF_STRING, ID_SIGNATURE_FIRST + i, psz);
        
        MemFree(var.pszVal);
    }
    
    Assert(iDef != -1);
    
    return(S_OK);
}

HRESULT InitSigPopupMenu(HMENU hmenu, LPCSTR szAcct)
{
    int cSig;
    HRESULT hr;
    
    Assert(g_pSigMgr != NULL);
    hr = g_pSigMgr->GetSignatureCount(&cSig);
    
    if (FAILED(hr))
        return(hr);
    
    if (cSig > 0)
    {
        HMENU hmenuOld = NULL, hmenuSig = NULL;
        MENUITEMINFO mii;
        
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;
        SideAssert(GetMenuItemInfo(hmenu, ID_INSERT_SIGNATURE, FALSE, &mii));
        hmenuOld = mii.hSubMenu;
        
        if (cSig > 1)
        {
            hmenuSig = CreatePopupMenu();
            Assert(hmenuSig != NULL);
            
            hr = FillSignatureMenu(hmenuSig, szAcct);
            if (FAILED(hr))
                return(hr);
        }
        
        mii.hSubMenu = hmenuSig;
        
        // Set the menu item
        SideAssert(SetMenuItemInfo(hmenu, ID_INSERT_SIGNATURE, FALSE, &mii));
        
        if (hmenuOld != NULL)
            DestroyMenu(hmenuOld);
    }
    
    return(S_OK);
}

void DeinitSigPopupMenu(HWND hwnd)
{
    HMENU hmenu;
    MENUITEMINFO mii;
    
    hmenu = GetMenu(hwnd);
    if (hmenu != NULL)
    {
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;
        if (GetMenuItemInfo(hmenu, ID_INSERT_SIGNATURE, FALSE, &mii) &&
            mii.hSubMenu != NULL)
            DestroyMenu(mii.hSubMenu);
    }
}

HRESULT GetSigFromCmd(int id, char *szID)
{
    HRESULT hr;
    IOptionBucket *pSig;
    PROPVARIANT var;
    
    Assert(szID != NULL);
    
    Assert(id >= ID_SIGNATURE_FIRST && id <= ID_SIGNATURE_LAST);
    id = id - ID_SIGNATURE_FIRST;
    
    Assert(g_pSigMgr != NULL);
    hr = g_pSigMgr->EnumSignatures(id, &pSig);
    if (hr != S_OK)
        return(E_FAIL);
    
    Assert(pSig != NULL);
    
    hr = pSig->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0);
    Assert(SUCCEEDED(hr));
    Assert(var.vt == VT_LPSTR);
    Assert(var.pszVal != NULL);
    lstrcpy(szID, var.pszVal);
    MemFree(var.pszVal);
    
    return(S_OK);
}

void InitAcctSig(SIGOPT *pSigOpt)
{
    IImnEnumAccounts *pEnum;
    IImnAccount *pAcct;
    ACCTSIG *pAcctSig;
    HRESULT hr;
    ULONG cAcct;
    SIG *pSig;
    int i, cmp;
    PROPVARIANT var;
    char szSigID[MAXSIGID];
    
    Assert(pSigOpt != NULL);
    
    if (pSigOpt->pAcctSig != NULL)
        return;
    
    Assert(g_pAcctMan != NULL);
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
    {
        Assert(pEnum != NULL);
        
        hr = pEnum->GetCount(&cAcct);
        Assert(SUCCEEDED(hr));
        
        if (cAcct > 0 &&
            MemAlloc((void **)&pSigOpt->pAcctSig, cAcct * sizeof(ACCTSIG)))
        {
            for (cAcct = 0, pAcctSig = pSigOpt->pAcctSig; SUCCEEDED(pEnum->GetNext(&pAcct)); cAcct++, pAcctSig++)
            {
                Assert(pAcct != NULL);
                pAcctSig->pAcct = pAcct;
                pAcctSig->iSig = -1;
                hr = pAcct->GetAccountType(&pAcctSig->type);
                Assert(SUCCEEDED(hr));
                
                if (SUCCEEDED(pAcct->GetPropSz(pAcctSig->type == ACCT_MAIL ? AP_SMTP_SIGNATURE : AP_NNTP_SIGNATURE, szSigID, ARRAYSIZE(szSigID))) &&
                    !FIsEmpty(szSigID))
                {
                    for (i = 0, pSig = pSigOpt->pSig; i < pSigOpt->cSig; i++, pSig++)
                    {
                        if (pSig->pBckt != NULL)
                        {
                            hr = pSig->pBckt->GetProperty(MAKEPROPSTRING(SIG_ID), &var, 0);
                            Assert(SUCCEEDED(hr));
                            Assert(var.vt == VT_LPSTR);
                            Assert(var.pszVal != NULL);
                            cmp = lstrcmpi(szSigID, var.pszVal);
                            MemFree(var.pszVal);
                            
                            if (cmp == 0)
                            {
                                pAcctSig->iSig = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            pSigOpt->cAcctSig = cAcct;
        }
        
        pEnum->Release();
    }
}

void InitAdvSigDlg(HWND hwnd, SIGOPT *pSigOpt)
{
    SIG *pSig;
    ACCTSIG *pAcctSig;
    char *psz, *pszT;
    int cch, i, index;
    LV_COLUMN lvc;
    RECT rc;
    HIMAGELIST himl;    
    HWND hwndT, hwndList;
    LV_ITEM lvi;
    
    Assert(pSigOpt != NULL);
    Assert(pSigOpt->iSelSig < pSigOpt->cSig);
    pSig = &pSigOpt->pSig[pSigOpt->iSelSig];
    Assert(!pSig->fDelete);
    
    InitAcctSig(pSigOpt);
    
    hwndT = GetDlgItem(hwnd, IDC_ADVSIG_STATIC);
    cch = GetWindowTextLength(hwndT) + 1;
    if (!MemAlloc((void **)&psz, cch * 2 + MAXSIGNAME))
        return;
    
    pszT = psz + cch;
    GetWindowText(hwndT, psz, cch);
    wsprintf(pszT, psz, pSig->szName);
    SetWindowText(hwndT, pszT);
    
    hwndList = GetDlgItem(hwnd, IDC_ACCOUNT_LIST);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_CHECKBOXES);
    
    GetClientRect(hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    rc.right = rc.right / 2;
    
    lvc.mask = LVCF_WIDTH | LVCF_TEXT;
    lvc.cx = rc.right;
    lvc.pszText = psz;
    // account column
    AthLoadString(idsAccount, psz, cch);
    ListView_InsertColumn(hwndList, 0, &lvc);
    // type column
    AthLoadString(idsType, psz, cch);
    ListView_InsertColumn(hwndList, 1, &lvc);
    
    // Add Folders Imagelist
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL); 
    
    for (i = 0, pAcctSig = pSigOpt->pAcctSig; i < pSigOpt->cAcctSig; i++, pAcctSig++)
    {
        Assert(pAcctSig->pAcct != NULL);
        
        if (SUCCEEDED(pAcctSig->pAcct->GetPropSz(AP_ACCOUNT_NAME, psz, cch)))
        {
            lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            lvi.pszText = psz;
            lvi.iImage = (pAcctSig->type == ACCT_MAIL) ? iMailServer : iNewsServer;
            lvi.lParam = i;
            lvi.stateMask = LVIS_STATEIMAGEMASK;
            index = ListView_InsertItem(hwndList, &lvi);
            Assert(index != -1);
            
            AthLoadString((pAcctSig->type == ACCT_MAIL) ? idsMail : idsNews, psz, cch);
            lvi.mask = LVIF_TEXT;
            lvi.iItem = index;
            lvi.iSubItem = 1;
            lvi.pszText = psz;
            ListView_SetItem(hwndList, &lvi);
            
            if (pAcctSig->iSig == pSigOpt->iSelSig)
                ListView_SetItemState(hwndList, index, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK); // 1 unchecked, 2 checked
        }
    }
    
    if (pSigOpt->cAcctSig > 0)
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
    
    MemFree(psz);
}

void SaveAcctSigSettings(HWND hwnd, SIGOPT *pSigOpt)
{
    int i, iAcctSig;
    ACCTSIG *pAcctSig;
    HWND hwndList;
    BOOL fCheck;
    
    Assert(pSigOpt != NULL);
    
    hwndList = GetDlgItem(hwnd, IDC_ACCOUNT_LIST);
    for (i = 0; i < pSigOpt->cAcctSig; i++)
    {
        iAcctSig = GetItemIndex(hwndList, i);
        Assert(iAcctSig >= 0 && iAcctSig < pSigOpt->cAcctSig);
        
        pAcctSig = &pSigOpt->pAcctSig[iAcctSig];
        fCheck = ListView_GetCheckState(hwndList, i);
        
        if (pSigOpt->iSelSig == pAcctSig->iSig)
        {
            if (!fCheck)
                pAcctSig->iSig = -1;
        }
        else
        {
            if (fCheck)
                pAcctSig->iSig = pSigOpt->iSelSig;
        }
    }
}

INT_PTR CALLBACK AdvSigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    SIGOPT *pSigOpt;
    WORD id;
    HWND hwndList;
    BOOL fRet = TRUE;
    
    pSigOpt = (SIGOPT *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    hwndList = GetDlgItem(hwnd, IDC_ACCOUNT_LIST);
    
    switch (msg)
    {
        case WM_INITDIALOG:
            Assert(pSigOpt == NULL);
            pSigOpt = (SIGOPT *)lParam;
            Assert(pSigOpt != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pSigOpt);
        
            Assert(pSigOpt->iSelSig >= 0 && pSigOpt->iSelSig < pSigOpt->cSig);
            InitAdvSigDlg(hwnd, pSigOpt);
            break;
        
        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
            {
                case IDOK:
                    SaveAcctSigSettings(hwnd, pSigOpt);
                    // fall through...
            
                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            
                default:
                    break;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statbar.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     statbar.h
//
//  PURPOSE:    Defines the CStatusBar class
//

#ifndef __STATBAR_H__
#define __STATBAR_H__

#include "spoolapi.h"

/////////////////////////////////////////////////////////////////////////////
// STATUS_BAR_PART
//
// Defines the different parts that are available in the status bar
//
typedef enum {
    SBP_FILTERED = 0,
    SBP_GENERAL,
    SBP_PROGRESS,
    SBP_CONNECTED,
    SBP_SPOOLER,
    SBP_MAX
} STATUS_BAR_PART;

/////////////////////////////////////////////////////////////////////////////
// Initialization Flags
//

#define SBI_HIDE_SPOOLER        0x00000001
#define SBI_HIDE_CONNECTED      0x00000002
#define SBI_HIDE_FILTERED       0x00000004

/////////////////////////////////////////////////////////////////////////////
// CONN_STATUS
//
// Parameter to SetConnectedStatus().
//
typedef enum {
    CONN_STATUS_WORKOFFLINE = 0,
    CONN_STATUS_CONNECTED,
    CONN_STATUS_DISCONNECTED,
    CONN_STATUS_MAX
} CONN_STATUS;

enum {
    STATUS_IMAGE_CONNECTED = 0,
    STATUS_IMAGE_AUTHORIZING,
    STATUS_IMAGE_CHECKING,
    STATUS_IMAGE_CHECKING_NEWS,
    STATUS_IMAGE_SENDING,
    STATUS_IMAGE_RECEIVING,
    STATUS_IMAGE_NOMSGS,
    STATUS_IMAGE_NEWMSGS,
    STATUS_IMAGE_ERROR,
    STATUS_IMAGE_DISCONNECTED,
    STATUS_IMAGE_OFFLINE,
    STATUS_IMAGE_ONLINE,
    STATUS_IMAGE_MAX
};


/////////////////////////////////////////////////////////////////////////////
// IStatusBar
//
interface IStatusBar : public IUnknown 
{
    STDMETHOD(Initialize)(THIS_ HWND hwndParent, DWORD dwFlags) PURE;
    STDMETHOD(ShowStatus)(THIS_ BOOL fShow) PURE;
    STDMETHOD(OnSize)(THIS_ int cx, int cy) PURE;
    STDMETHOD(GetHeight)(THIS_ int *cy) PURE;
    STDMETHOD(ShowSimpleText)(THIS_ LPTSTR pszText) PURE;
    STDMETHOD(HideSimpleText)(THIS) PURE;
    STDMETHOD(SetStatusText)(THIS_ LPTSTR pszText) PURE;
    STDMETHOD(ShowProgress)(THIS_ DWORD dwRange) PURE;
    STDMETHOD(SetProgress)(THIS_ DWORD dwPos) PURE;
    STDMETHOD(HideProgress)(THIS) PURE;
    STDMETHOD(SetConnectedStatus)(THIS_ CONN_STATUS status) PURE;
    STDMETHOD(SetSpoolerStatus)(THIS_ DELIVERYNOTIFYTYPE type, DWORD cMsgs) PURE;
    STDMETHOD(OnNotify)(THIS_ NMHDR *pnmhdr) PURE;
    STDMETHOD(SetFilter)(THIS_ RULEID ridFilter) PURE;
};

#define IDC_STATUS_BAR          4000
#define IDC_STATUS_PROGRESS     4001


/////////////////////////////////////////////////////////////////////////////
// CStatusBar
//

class CStatusBar : public IStatusBar
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    //
    CStatusBar();
    ~CStatusBar();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IStatusBar
    //
    STDMETHODIMP Initialize(HWND hwndParent, DWORD dwFlags);
    STDMETHODIMP ShowStatus(BOOL fShow);
    STDMETHODIMP OnSize(int cx, int cy);
    STDMETHODIMP GetHeight(int *pcy);
    STDMETHODIMP ShowSimpleText(LPTSTR pszText);
    STDMETHODIMP HideSimpleText(void);
    STDMETHODIMP SetStatusText(LPTSTR pszText);
    STDMETHODIMP ShowProgress(DWORD dwRange);
    STDMETHODIMP SetProgress(DWORD dwPos);
    STDMETHODIMP HideProgress(void);
    STDMETHODIMP SetConnectedStatus(CONN_STATUS status);
    STDMETHODIMP SetSpoolerStatus(DELIVERYNOTIFYTYPE type, DWORD cMsgs);
    STDMETHODIMP OnNotify(NMHDR *pnmhdr);
    STDMETHODIMP SetFilter(RULEID ridFilter);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _UpdateWidths(void);
    HICON _GetIcon(DWORD iIndex);
    
private:
    /////////////////////////////////////////////////////////////////////////
    // Class Data
    //
    ULONG       m_cRef;
    HWND        m_hwnd;
    HWND        m_hwndProg;
    DWORD       m_tidOwner;
    
    DWORD       m_dwFlags;
    HIMAGELIST  m_himl;
    HICON       m_rgIcons[STATUS_IMAGE_MAX];

    // Cached width information
    int         m_cxFiltered;
    int         m_cxSpooler;
    int         m_cxConnected;
    int         m_cxProgress;

    // State
    BOOL        m_fInSimple;

    // Cached filter info
    RULEID              m_ridFilter;
    CONN_STATUS         m_statusConn;
    DELIVERYNOTIFYTYPE  m_typeDelivery;
    DWORD               m_cMsgsDelivery;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\spell.h ===
/* *
   * s p e l l . h
   *
   */

#ifndef _SPELL_H
#define _SPELL_H

INT_PTR CALLBACK SpellingPageProc(HWND, UINT, WPARAM, LPARAM);
BOOL  FCheckSpellAvail(void);

// Query options
BOOL FIgnoreNumber(void);
BOOL FIgnoreUpper(void);
BOOL FIgnoreDBCS(void);
BOOL FIgnoreProtect(void);
BOOL FAlwaysSuggest(void);
BOOL FCheckOnSend(void);

#endif  // _SPELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\srtarray.cpp ===
/*
 *  s r t a r r a y . cpp
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Sorted array that grows dynamically. Sorting is
 *  deferred until an array element is accessed.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "srtarray.h"

const long c_DefaultCapacity = 16;

//--------------------------------------------------------------------------
// CSortedArray
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
// CSortedArray::Create
//--------------------------------------------------------------------------
HRESULT CSortedArray::Create(PFNSORTEDARRAYCOMPARE pfnCompare,
                             PFNSORTEDARRAYFREEITEM pfnFreeItem,
                             CSortedArray **ppArray)
{
    HRESULT     hr = S_OK;

    if (NULL == ppArray)
        return E_INVALIDARG;

    CSortedArray *pArray = new CSortedArray(pfnCompare, pfnFreeItem);
    if (NULL == pArray)
        hr = E_OUTOFMEMORY;
    else
        *ppArray = pArray;

    return hr;
}

//--------------------------------------------------------------------------
// CSortedArray::CSortedArray
//--------------------------------------------------------------------------
CSortedArray::CSortedArray(PFNSORTEDARRAYCOMPARE pfnCompare, PFNSORTEDARRAYFREEITEM pfnFreeItem) :
    m_lLength(0),
    m_lCapacity(0),
    m_data(NULL),
    m_pfnCompare(pfnCompare),
    m_pfnFreeItem(pfnFreeItem),
    m_fSorted(TRUE)
{
    // nothing to do
}

//--------------------------------------------------------------------------
// CSortedArray::~CSortedArray
//--------------------------------------------------------------------------
CSortedArray::~CSortedArray(void)
{
    if (NULL != m_pfnFreeItem && NULL != m_data)
    {
        for (long i = 0; i < m_lLength; i++)
            (*m_pfnFreeItem)(m_data[i]);
    }

    SafeMemFree(m_data);
}

//--------------------------------------------------------------------------
// CSortedArray::GetLength
//--------------------------------------------------------------------------
long CSortedArray::GetLength(void) const
{
    return m_lLength;
}

//--------------------------------------------------------------------------
// CSortedArray::GetItemAt
//--------------------------------------------------------------------------
void *CSortedArray::GetItemAt(long lIndex) const
{
    if (lIndex >= m_lLength || lIndex < 0)
        return NULL;
    else
    {
        if (!m_fSorted)
            _Sort();

        return m_data[lIndex];
    }
}

//--------------------------------------------------------------------------
// CSortedArray::Find
//--------------------------------------------------------------------------
BOOL CSortedArray::Find(void* pItem, long *plIndex) const
{
    if (!m_fSorted)
        _Sort();

    if (NULL == plIndex || NULL == pItem)
        return FALSE;

    *plIndex = 0;
    if (0 == m_lLength)
        return FALSE;

    long lLow = 0;
    int result = (*m_pfnCompare)(&pItem, &m_data[lLow]);
    if (result < 0)
        return FALSE;
    if (result == 0)
        return TRUE;

    long lHigh = m_lLength - 1;
    *plIndex = lHigh;
    result = (*m_pfnCompare)(&pItem, &m_data[lHigh]);
    if (result == 0)
        return TRUE;
    if (result > 0)
    {
        *plIndex = lHigh + 1;
        return FALSE;
    }

    while (lLow + 1 < lHigh)
    {
        long lMid = (lLow + lHigh) / 2;
        result = (*m_pfnCompare)(&pItem, &m_data[lMid]);
        if (result == 0)
        {
            *plIndex = lMid;
            return TRUE;
        }
        else
        {
            if (result < 0)
                lHigh = lMid;
            else
                lLow = lMid;
        }
    }

    *plIndex = lLow + 1;
    return FALSE;
}

//--------------------------------------------------------------------------
// CSortedArray::Add
//--------------------------------------------------------------------------
HRESULT CSortedArray::Add(void *pItem)
{
    HRESULT     hr = S_OK;

    if (NULL == pItem)
        return E_INVALIDARG;

    if (m_lLength == m_lCapacity)
    {
        if (FAILED(hr = _Grow()))
            goto exit;
    }

    // append the item to the end of the collection,
    // and mark the collection as unsorted.
    m_data[m_lLength++] = pItem;
    m_fSorted = FALSE;

exit:
    return hr;
}

//--------------------------------------------------------------------------
// CSortedArray::Remove
//--------------------------------------------------------------------------
HRESULT CSortedArray::Remove(long lIndex)
{
    if (lIndex >= m_lLength)
        return E_INVALIDARG;

    if (!m_fSorted)
        _Sort();

    --m_lLength;

    if (lIndex < m_lLength)
    {
        memcpy(&m_data[lIndex], 
            &m_data[lIndex + 1], 
            (m_lLength - lIndex) * sizeof(void*));
    }

    return S_OK;
}

//--------------------------------------------------------------------------
// CSortedArray::Remove
//--------------------------------------------------------------------------
HRESULT CSortedArray::Remove(void *pItem)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;

    if (NULL == pItem)
        return E_INVALIDARG;

    if (!m_fSorted)
        _Sort();

    BOOL fFound = Find(pItem, &lIndex);
    if (!fFound)
    {
        hr = E_FAIL;
        goto exit;
    }

    hr = Remove(lIndex);

exit:
    return hr;
}

//--------------------------------------------------------------------------
// CSortedArray::_Grow
//--------------------------------------------------------------------------
HRESULT CSortedArray::_Grow(void) const
{
    BOOL fSuccess = FALSE;

    if (0 == m_lCapacity)
    {
        fSuccess = MemAlloc((LPVOID*)&m_data, c_DefaultCapacity * sizeof(void*));
        if (fSuccess)
            m_lCapacity = c_DefaultCapacity;
    }
    else
    {
        long lNewCapacity = m_lCapacity * 2;

        fSuccess = MemRealloc((LPVOID*)&m_data, lNewCapacity * sizeof(void*));
        if (fSuccess)
            m_lCapacity = lNewCapacity;
    }
    
    return fSuccess ? S_OK : E_OUTOFMEMORY;;
}

//--------------------------------------------------------------------------
// CSortedArray::_Sort
//--------------------------------------------------------------------------
void CSortedArray::_Sort(void) const
{
    if (!m_fSorted && m_lLength > 1 && NULL != m_pfnCompare)
        qsort(m_data, m_lLength, sizeof(void*), m_pfnCompare);

    m_fSorted = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\srtarray.h ===
/*
 *  s r t a r r a y . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Sorted array that grows dynamically. Sorting is
 *  deferred until an array element is accessed.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef __SRTARRAY_H
#define __SRTARRAY_H

typedef int (__cdecl *PFNSORTEDARRAYCOMPARE)(const void *first, const void *second);
    // Client-installed comparison callback that enables sorting.
    // NOTE: the const void* passed into the address of a pointer in the array.
    // In other words, if the array is a collection of Foo*, the items passed
    // into the comparison callback will be of type Foo**.
    // Return values should be as follows:
    //      return a negative integer if first is less than second
    //      return 0 if first == second
    //      return a positive integer if first is greater than second

typedef void (__cdecl *PFNSORTEDARRAYFREEITEM)(void *pItem);
    // client-installed free callback. If this optional callback is installed,
    // it will be called once for each item in the array when the array
    // is destroyed.

class CSortedArray
{
public:
    // Factory function. Call this method to instantiate.
    static HRESULT Create(PFNSORTEDARRAYCOMPARE pfnCompare,
                          PFNSORTEDARRAYFREEITEM pfnFreeItem,
                          CSortedArray **ppArray);
    ~CSortedArray(void);

private:
    // constructor is private. call "Create"
    CSortedArray(void);
    CSortedArray(PFNSORTEDARRAYCOMPARE pfnCompare, PFNSORTEDARRAYFREEITEM pfnFreeItem);

    // unimplemented copy constructor and assignment operator
    CSortedArray(const CSortedArray& other);
    CSortedArray& operator=(const CSortedArray& other);

public:
    long GetLength(void) const;

    void* GetItemAt(long lIndex) const;             // Retrive the item at ulIndex.
                                                    // If ulIndex is out of bounds,
                                                    // result is NULL.

    BOOL Find(void* pItem, long *plIndex) const;    // Find item.
                                                    // If found, result is TRUE
                                                    // and pulIndex is the location of
                                                    // the item. If item is not found,
                                                    // result is FALSE, and pulIndex is
                                                    // location where item would be inserted

    HRESULT Add(void *pItem);                       // Add pItem into the array.

    HRESULT Remove(long lIndex);                    // Remove the item at ulIndex
                                                    // It is an error if ulIndex is
                                                    // out of bounds.

    HRESULT Remove(void *pItem);                    // Remove pItem from the array.
                                                    // It is an error if pItem does not exist
private:
    void    _Sort(void) const;
    HRESULT _Grow(void) const;

private:
    long                    m_lLength;
    mutable long            m_lCapacity;
    void                    **m_data;
    PFNSORTEDARRAYCOMPARE   m_pfnCompare;
    PFNSORTEDARRAYFREEITEM  m_pfnFreeItem;
    mutable BOOL            m_fSorted;
};

#endif // __SRTARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\simpstr.h ===
/*
 *  s i m p s t r . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Simple string class.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef __SIMPSTR_H
#define __SIMPSTR_H

class CSimpleString
{
public:
    CSimpleString(void) : m_pRep(NULL) { }
    CSimpleString(const CSimpleString& other) : m_pRep(NULL) { if (other.m_pRep) _AcquireRep(other.m_pRep); }

    ~CSimpleString(void) { if (m_pRep) _ReleaseRep(); }

    CSimpleString& operator=(const CSimpleString& other) { _AcquireRep(other.m_pRep); return *this; }

    BOOL operator==(const CSimpleString& rhs) const;

    HRESULT SetString(LPCSTR psz);
    HRESULT AdoptString(LPSTR psz);

    inline BOOL IsNull(void) const { return !m_pRep || !m_pRep->m_pszString; }
    inline BOOL IsEmpty(void) const { return (IsNull() || *(m_pRep->m_pszString) == 0); }
    inline LPCSTR GetString(void) const { return (m_pRep ? m_pRep->m_pszString : NULL); }

private:
    
    struct SRep
    {
        LPCSTR  m_pszString;
        long    m_cRef;
    };

    void _AcquireRep(SRep* pRep); 
    void _ReleaseRep();
    
    HRESULT _AllocateRep(LPCSTR pszString, BOOL fAdopted);

private:
    SRep        *m_pRep;
};

// compare two strings. this function can be used by any stl-type sorted collection
// to satisfy the comparator requirement.
inline BOOL operator<(const CSimpleString& lhs, const CSimpleString& rhs)
{
    LPCSTR pszLeft = lhs.GetString();
    LPCSTR pszRight = rhs.GetString();
    
    if (!pszLeft)
        pszLeft = "";
    if (!pszRight)
        pszRight = "";

    return (lstrcmp(pszLeft, pszRight) < 0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\spell.cpp ===
/*
 *  spell.c
 *
 *  Implementation of spelling
 *
 *  Owner:	v-brakol
 *			bradk@directeq.com
 */
#include "pch.hxx"
#define  SPID
#include "richedit.h"
#include "resource.h"
#include <mshtml.h>
#include <mshtmcid.h>
#include "mshtmhst.h"
#include <docobj.h>
#include "spell.h"
#include "strconst.h"
#include <options.h>
#include <goptions.h>
#include "mailnews.h"
#include "hotlinks.h"
#include "bodyutil.h"
#include <shlwapi.h>
#include <error.h>
#include "htmlstr.h"
#include "optres.h"
#include "mlang.h"
#include "lid.h"
#include "shlwapip.h"
#include "msi.h"
#include "demand.h"

#ifdef ImageList_GetIcon
#undef ImageList_GetIcon
#endif 

#include <shfusion.h>

#define cchMaxPathName      (256)

#define TESTHR(hr) (FAILED(hr) || hr == HR_S_ABORT || hr == HR_S_SPELLCANCEL)
#define SPELLER_GUID    	"{CC29EB3F-7BC2-11D1-A921-00A0C91E2AA2}"
#define DICTIONARY_GUID 	"{CC29EB3D-7BC2-11D1-A921-00A0C91E2AA2}"
#ifdef DEBUG
#define SPELLER_DEBUG_GUID    "{CC29EB3F-7BC2-11D1-A921-10A0C91E2AA2}"
#define DICTIONARY_DEBUG_GUID "{CC29EB3D-7BC2-11D1-A921-10A0C91E2AA2}"
#endif	// DEBUG

typedef BOOL (LPFNENUMLANG)(DWORD_PTR, LPTSTR);
typedef BOOL (LPFNENUMUSERDICT)(DWORD_PTR, LPTSTR);

typedef struct _FILLLANG
    {
    HWND    hwndCombo;
    BOOL    fUnknownFound;
    BOOL    fDefaultFound;
    BOOL    fCurrentFound;
    UINT    lidDefault;
    UINT    lidCurrent;
    } FILLLANG, * LPFILLLANG;

BOOL    FDBCSEnabled(void);
BOOL    TestLangID(LPCTSTR szLangId);
BOOL    GetLangID(LPTSTR szLangID, DWORD cchLangId);
WORD	WGetLangID(void);
BOOL	SetLangID(LPTSTR szLandID);
DWORD   GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer);
VOID    OpenCustomDictionary(VOID);
VOID    FillLanguageDropDown(HWND hwndLang);
VOID    EnumLanguages(DWORD_PTR, LPFNENUMLANG);
BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang);
BOOL    EnumLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang);
BOOL    FBadSpellChecker(LPSTR rgchBufDigit);
BOOL	GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail);
HRESULT OpenDirectory(TCHAR *szDir);

////Spelling tab CS-help
const static HELPMAP g_rgCtxMapSpell[] = {
                               {CHK_AlwaysSuggest, IDH_NEWS_SPELL_SUGGEST_REPL},
                               {CHK_CheckSpellingOnSend, IDH_NEWS_SPELL_CHECK_BEFORE_SEND},
                               {CHK_IgnoreUppercase, IDH_NEWS_SPELL_IGNORE_UPPERCASE},
                               {CHK_IgnoreNumbers, IDH_NEWS_SPELL_IGNORE_WITH_NUMBERS},
                               {CHK_IgnoreOriginalMessage, IDH_NEWS_SPELL_ORIGINAL_TEXT},
                               {CHK_IgnoreURL, IDH_OPTIONS_SPELLING_INTERNET_ADDRESSES},
                               {idcSpellLanguages, IDH_OPTIONS_SPELLING_LANGUAGE},
                               {idcViewDictionary, IDH_OPTIONS_SPELLING_DICTIONARY},
                               {CHK_CheckSpellingOnType, 0},
                               {idcStatic1, IDH_NEWS_COMM_GROUPBOX},
                               {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
                               {idcStatic3, IDH_NEWS_COMM_GROUPBOX},
                               {idcStatic4, IDH_NEWS_COMM_GROUPBOX},
                               {idcStatic5, IDH_NEWS_COMM_GROUPBOX},
                               {idcStatic6, IDH_NEWS_COMM_GROUPBOX},
                               {IDC_SPELL_SETTINGS_ICON, IDH_NEWS_COMM_GROUPBOX},
                               {IDC_SPELL_IGNORE_ICON, IDH_NEWS_COMM_GROUPBOX},
                               {IDC_SPELL_LANGUAGE_ICON, IDH_NEWS_COMM_GROUPBOX},
                               {0, 0}};


ASSERTDATA

BOOL FIgnoreNumber(void)    { return(DwGetOption(OPT_SPELLIGNORENUMBER)); }
BOOL FIgnoreUpper(void)     { return(DwGetOption(OPT_SPELLIGNOREUPPER)); }
BOOL FIgnoreDBCS(void)      { return(DwGetOption(OPT_SPELLIGNOREDBCS)); }
BOOL FIgnoreProtect(void)   { return(DwGetOption(OPT_SPELLIGNOREPROTECT)); }
BOOL FAlwaysSuggest(void)   { return(DwGetOption(OPT_SPELLALWAYSSUGGEST)); }
BOOL FCheckOnSend(void)     { return(DwGetOption(OPT_SPELLCHECKONSEND)); }
BOOL FIgnoreURL(void)       { return(DwGetOption(OPT_SPELLIGNOREURL)); }

BOOL TestLangID(LPCTSTR szLangId)
{
	// check for new speller
	{
	    TCHAR	rgchEngine[MAX_PATH];
	    int		cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
	    TCHAR	rgchLex[MAX_PATH];
	    int		cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

	    if (GetNewSpellerEngine((LANGID) StrToInt(szLangId), rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
	    	return TRUE;
	}

	// use the old code to check for an old speller
	{
		TCHAR       rgchBufKeyTest[cchMaxPathName];
		TCHAR       rgchBufTest[cchMaxPathName];
		TCHAR       szMdr[cchMaxPathName];

	   	wsprintf(rgchBufKeyTest, c_szRegSpellKeyDef, szLangId);
	   	if (GetSpellingPaths(rgchBufKeyTest, rgchBufTest, szMdr, sizeof(rgchBufTest)/sizeof(TCHAR)))
	   		return TRUE;
	}

	return FALSE;
}

BOOL SetLangID(LPTSTR szLangId)
{
	return SetOption(OPT_SPELL_LANGID, szLangId, lstrlen(szLangId) + 1, NULL, 0);
}

/*
 * GetSpellLangID
 *
 * Returns the LangID that should be used as the base for all registry
 * operations
 *
 */
BOOL GetLangID(LPTSTR szLangId, DWORD cchLangId)
{
TCHAR   rgchBuf[cchMaxPathName];
TCHAR   rgchBufKey[cchMaxPathName];
BOOL    fRet;

    if (GetOption(OPT_SPELL_LANGID, szLangId, cchLangId) != 5)
    {
        // For Arabic, we should consider all sub-langs also
        // since spelling checker for Aarbic uses Saudi Aarbia sub lang
    
        LANGID langid = GetUserDefaultLangID();
        if (PRIMARYLANGID(langid) == LANG_ARABIC)
        {
            langid = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);
        }
        wsprintf(szLangId, "%d", langid);
        Assert(lstrlen(szLangId) == 4);
    }

    wsprintf(rgchBufKey, c_szRegSpellKeyDef, szLangId);
    // copy c_szRegSpellProfile to buffer
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    // add key to buffer
    lstrcat(rgchBuf, rgchBufKey);

    // and see if it's legit:
    if(!(fRet = TestLangID(szLangId)))
    {
        // couldn't open it!
        // check for other languages that might be installed...
        szLangId[0] = 0;
        EnumLanguages((DWORD_PTR) szLangId, FindLangCallback);
        if(*szLangId == 0)
            wsprintf(szLangId, "%d", GetUserDefaultLangID());
    }

    fRet = (szLangId[0] != 0) && TestLangID(szLangId);

    return fRet;
}

WORD	WGetLangID()
{
    TCHAR       rgchBufDigit[10];
	
    GetLangID(rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR));

	return (WORD) StrToInt(rgchBufDigit);
}

BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang)
{
    // dwLangID is long pointer to szLang ID.  Copy it and return FALSE
    lstrcpy((LPTSTR) dwLangId, lpszLang);
    return FALSE;
}

BOOL EnumOldSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
DWORD   iKey = 0;
FILETIME    ft;
HKEY    hkey = NULL;
LONG    lRet;
TCHAR   szLangId[cchMaxPathName];
DWORD   cchLangId;
BOOL    fContinue = TRUE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSpellKeyDefRoot, 0, KEY_ENUMERATE_SUB_KEYS, &hkey) == ERROR_SUCCESS)
        {
        do
            {
            cchLangId = (cchMaxPathName - 1) * sizeof(TCHAR);

            lRet = RegEnumKeyEx(hkey,
                                iKey++,
                                szLangId,
                                &cchLangId,
                                NULL,
                                NULL,
                                NULL,
                                &ft);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;


            // do some quick sanity checking
            if (cchLangId != 4 ||
                !IsCharAlphaNumeric(szLangId[0]) ||
                IsCharAlpha(szLangId[0]))
                {
                fContinue = TRUE;
                }
            else
                fContinue = (!TestLangID(szLangId) || (*pfn)(dwCookie, szLangId));

            } while (fContinue);
        }

    if (hkey)
        RegCloseKey(hkey);

    return fContinue;
}

BOOL EnumNewSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
	BOOL    						fContinue = TRUE;
	
	DWORD		i;
	UINT 	    installState;
	UINT		componentState;
    TCHAR		rgchQualifier[MAX_PATH];
    DWORD		cchQualifier;

#ifdef DEBUG
	for(i=0; fContinue; i++)
	{
		cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
		componentState = MsiEnumComponentQualifiers(DICTIONARY_DEBUG_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

		if (componentState != ERROR_SUCCESS)
			break;

		// find the language ID
		// the string is formatted as 1033\xxxxxx
		// or						  1042
		{
			TCHAR   	szLangId[cchMaxPathName];
			TCHAR		*pSlash;

			lstrcpyn(szLangId, rgchQualifier, ARRAYSIZE(szLangId));
			pSlash = StrChr(szLangId, '\\');
			if (pSlash)
				*pSlash = 0;

		    fContinue = (*pfn)(dwCookie, szLangId);
		}
	}
#endif	// DEBUG

	for(i=0; fContinue; i++)
	{
		cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
		componentState = MsiEnumComponentQualifiers(DICTIONARY_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

		if (componentState != ERROR_SUCCESS)
			break;

		// find the language ID
		// the string is formatted as 1033\xxxxxx
		// or						  1042
		{
			TCHAR   	szLangId[cchMaxPathName];
			TCHAR		*pSlash;

			lstrcpyn(szLangId, rgchQualifier, ARRAYSIZE(szLangId));
			pSlash = StrChr(szLangId, '\\');
			if (pSlash)
				*pSlash = 0;

		    fContinue = (*pfn)(dwCookie, szLangId);
		}
	}
	
	return fContinue;
}

VOID EnumLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
	// enum all languages
	EnumNewSpellerLanguages(dwCookie, pfn);
	EnumOldSpellerLanguages(dwCookie, pfn);
}

/*
 *  GetSpellingPaths
 *
 *  Purpose:
 *      Function to get Spelling DLL names.
 *
 *  Arguments:
 *      szKey           c_szRegSpellKeyDef (with correct language)
 *      szDefault       c_szRegSpellEmpty
 *      szReturnBuffer  dll filename
 *      szMdr           dictionary filename
 *      cchReturnBufer
 *
 *  Returns:
 *      DWORD
 */
DWORD GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer)
{
    DWORD           dwRet = 0;
    TCHAR           rgchBuf[cchMaxPathName];
    DWORD           dwType, cbData;
    HKEY            hkey = NULL;
    LPTSTR          szValue;

    szReturnBuffer[0] = 0;
    wsprintf(rgchBuf, TEXT("%s%s"), c_szRegSpellProfile, szKey);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey))
        goto err;

    cbData = cchReturnBufer * sizeof(TCHAR);
    szValue = (LPTSTR) (szMdr ? c_szRegSpellPath : c_szRegSpellPathDict);
    if (ERROR_SUCCESS != SHQueryValueEx(hkey, szValue, 0L, &dwType, (BYTE *) szReturnBuffer, &cbData))
        goto err;

    // Parse off the main dictionary filename
    if(szMdr)
    {
        szMdr[0] = 0;
        cbData = cchReturnBufer * sizeof(TCHAR);
        if (ERROR_SUCCESS != SHQueryValueEx(hkey, c_szRegSpellPathLex, 0L, &dwType, (BYTE *) szMdr, &cbData))
            goto err;
    }

    dwRet = cbData;

err:
    if(hkey)
        RegCloseKey(hkey);
    return dwRet;
}

BOOL GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail)
{
    DWORD                           er;
    LPCSTR                          rgpszDictionaryTypes[] = {"Normal", "Consise", "Complete"};	
    int	                            cDictTypes = sizeof(rgpszDictionaryTypes) / sizeof(LPCSTR);
    int                             i;
    TCHAR                           rgchQual[MAX_PATH];
	bool							fFound = FALSE;
	DWORD							cch;
    INSTALLUILEVEL                  iuilOriginal;
	
	if (rgchEngine == NULL || rgchLex == NULL)
		return FALSE;

	*rgchEngine = 0;
	*rgchLex = 0;

	wsprintf(rgchQual, "%d\\Normal", lgid);
	cch = cchEngine;

    if (bTestAvail)
    {
        // Explicitly Turn off internal installer UI
        // Eg: A feature is set to "run from CD," and CD is not present - fail silently
        // OE Bug 74697
        iuilOriginal = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
    }

#ifdef DEBUG
    er = MsiProvideQualifiedComponent(SPELLER_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
	if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
	{
		cch = cchEngine;
		er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
	}
#else
	er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
#endif

    if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND)) 
    {
        fFound = FALSE;
        goto errorExit;
    }

	// Hebrew does not have a main lex
#ifdef OLDHEB
	if (lgid != lidHebrew)
	{
#endif // OLDHEB
	    for (i = 0; i < cDictTypes; i++)
	    {
	        wsprintf(rgchQual, "%d\\%s",  lgid, rgpszDictionaryTypes[i]);
			cch = cchLex;
	        
#ifdef DEBUG
			er = MsiProvideQualifiedComponent(DICTIONARY_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
			if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
			{
				cch = cchLex;
				er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
			}
#else	// DEBUG
			er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
#endif	// DEBUG

	        if ((er == ERROR_SUCCESS) || (er == ERROR_FILE_NOT_FOUND))
	        {
	            fFound = TRUE;
	            break;
	        }
	    }
#ifdef OLDHEB
	}
#endif //OLDDHEB

errorExit:
    if (bTestAvail)
    {
        // Restore original UI Level
        MsiSetInternalUI(iuilOriginal, NULL);
    }
    return fFound;
}

BOOL FIsNewSpellerInstaller()
{
    LANGID langid;
    TCHAR	rgchEngine[MAX_PATH];
    int		cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
    TCHAR	rgchLex[MAX_PATH];
    int		cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

	// first try to load dictionaries for various languages
    langid = WGetLangID();
    if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
    {
    	langid = GetSystemDefaultLangID();
    	if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
		{
    		langid = 1033;  // bloody cultural imperialists.
    		if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
    			return FALSE;
        }
    }

    return TRUE;
}

/*
 *  FIsSpellingInstalled
 *
 *  Purpose:
 *      Is the spelling stuff installed
 *
 *  Arguments:
 *      none
 *
 *  Returns:
 *      BOOL            Returns TRUE if spelling is installed, else FALSE.
 */
BOOL FIsSpellingInstalled()
{
    TCHAR       rgchBufDigit[10];

	if (GetLangID(rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR)) && !FBadSpellChecker(rgchBufDigit))
		return true;

	if (FIsNewSpellerInstaller())
		return true;

	return false;
}

// Does a quick check to see if spelling is available; caches result.
BOOL FCheckSpellAvail(void)
{
static int fSpellAvailable = -1;

    if (fSpellAvailable < 0)
        fSpellAvailable = (FIsSpellingInstalled() ? 1 : 0);

    return (fSpellAvailable > 0);
}

BOOL FDBCSEnabled(void)
{
static int fDBCS = -1;

    if (fDBCS < 0)
        fDBCS = GetSystemMetrics(SM_DBCSENABLED);

    return (fDBCS > 0);
}

// Fill the options list with the available spelling languages
VOID FillLanguageDropDown(HWND hwndLang)
{
TCHAR       rgchBuf[cchMaxPathName];
FILLLANG    fl;
int         i;

    // get the current language
    GetLangID(rgchBuf, cchMaxPathName);

    fl.hwndCombo = hwndLang;
    fl.fUnknownFound = FALSE;
    fl.fDefaultFound = FALSE;
    fl.fCurrentFound = FALSE;
    fl.lidDefault = WGetLangID();
    fl.lidCurrent = StrToInt(rgchBuf);

    EnumLanguages((DWORD_PTR) &fl, EnumLangCallback);

	// this should never happen, but just in case
    if (!fl.fDefaultFound)
        {
        LoadString(g_hLocRes, idsDefaultLang, rgchBuf, cchMaxPathName - 1);
        i = ComboBox_AddString(hwndLang, rgchBuf);
        ComboBox_SetItemData(hwndLang, i, fl.lidDefault);
        }

    // select the current one, if found, else the default one.
    for (i = ComboBox_GetCount(hwndLang) - 1; i >= 0; i--)
        {
        UINT lid = (UINT) ComboBox_GetItemData(hwndLang, i);

        if ((fl.fCurrentFound && lid == fl.lidCurrent) ||
            (!fl.fCurrentFound && fl.fDefaultFound && lid == fl.lidDefault))
            {
            ComboBox_SetCurSel(hwndLang, i);
            break;
            }
        }
}

BOOL EnumLangCallback(DWORD_PTR dw, LPTSTR lpszLang)
{
    LPFILLLANG  	lpfl = (LPFILLLANG) dw;
    TCHAR       	szLang[cchMaxPathName];
	LID				lidLang = (LID) StrToInt(lpszLang);
	int				i;
    HRESULT         hr=S_OK;
    IMultiLanguage2 *pMLang2 = NULL;
	RFC1766INFO		info;

	// check to see if we already have the LID in the ComboBox
	{
	    for (i = ComboBox_GetCount(lpfl->hwndCombo) - 1; i >= 0; i--)
	    {
	        LID lid = (UINT) ComboBox_GetItemData(lpfl->hwndCombo, i);

			if (lid == lidLang)
				return TRUE;
	    }
	}
	
    // Try to create an IMultiLanguage2 interface
    hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage2, (LPVOID *) &pMLang2);
    if (SUCCEEDED(hr))
    	hr = pMLang2->GetRfc1766Info(MAKELCID(lidLang, SORT_DEFAULT), MLGetUILanguage(), &info);

	SafeRelease(pMLang2);

	if (SUCCEEDED(hr))
	{
 		if (WideCharToMultiByte (CP_ACP, 0, info.wszLocaleName, -1,
								szLang, sizeof(szLang), NULL, NULL))
		{
	        i = ComboBox_AddString(lpfl->hwndCombo, szLang);
	        ComboBox_SetItemData(lpfl->hwndCombo, i, lidLang);

	        if (lidLang == lpfl->lidDefault)
           		lpfl->fDefaultFound = TRUE;

        	if (lidLang == lpfl->lidCurrent)
            	lpfl->fCurrentFound = TRUE;

			return TRUE;
		}
	}

    return TRUE;    // keep enumerating
}

INT_PTR CALLBACK SpellingPageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
    BOOL f;
    OPTINFO *pmoi;

    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message)
        {
        case WM_INITDIALOG:
            {
                UINT uCP;

                Assert(pmoi == NULL);
                pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
                Assert(pmoi != NULL);
                SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);

                ButtonChkFromOptInfo(hwnd, CHK_AlwaysSuggest, pmoi, OPT_SPELLALWAYSSUGGEST);
                ButtonChkFromOptInfo(hwnd, CHK_CheckSpellingOnSend, pmoi, OPT_SPELLCHECKONSEND);
                ButtonChkFromOptInfo(hwnd, CHK_CheckSpellingOnType, pmoi, OPT_SPELLCHECKONTYPE);
                ButtonChkFromOptInfo(hwnd, CHK_IgnoreUppercase, pmoi, OPT_SPELLIGNOREUPPER);
                ButtonChkFromOptInfo(hwnd, CHK_IgnoreNumbers, pmoi, OPT_SPELLIGNORENUMBER);
                ButtonChkFromOptInfo(hwnd, CHK_IgnoreOriginalMessage, pmoi, OPT_SPELLIGNOREPROTECT);
                ButtonChkFromOptInfo(hwnd, CHK_IgnoreDBCS, pmoi, OPT_SPELLIGNOREDBCS);
                ButtonChkFromOptInfo(hwnd, CHK_IgnoreURL, pmoi, OPT_SPELLIGNOREURL);

                FillLanguageDropDown(GetDlgItem(hwnd, idcSpellLanguages));

                uCP = GetACP();
                // 50406: if we're not DBCS or (we're Japaneese or either Chinese) don't show
                // the DBCS option.
                if (!FDBCSEnabled() || ((932==uCP) || (936==uCP) || (950==uCP)))
                {
                    ShowWindow(GetDlgItem(hwnd, CHK_IgnoreDBCS), SW_HIDE);
                    EnableWindow(GetDlgItem(hwnd, CHK_IgnoreDBCS), FALSE);
                }

                // Pictures
                HICON hIcon;

                hIcon = ImageList_GetIcon(pmoi->himl, ID_SPELL, ILD_TRANSPARENT);
                SendDlgItemMessage(hwnd, IDC_SPELL_SETTINGS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
                hIcon = ImageList_GetIcon(pmoi->himl, ID_SPELL_IGNORE, ILD_TRANSPARENT);
                SendDlgItemMessage(hwnd, IDC_SPELL_IGNORE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

                hIcon = ImageList_GetIcon(pmoi->himl, ID_LANGUAGE_ICON, ILD_TRANSPARENT);
                SendDlgItemMessage(hwnd, IDC_SPELL_LANGUAGE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

                SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)1);
            }
            return(TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapSpell);

        case WM_COMMAND:
            if (1 != GetWindowLongPtr(hwnd, GWLP_USERDATA))
                break;

            if (HIWORD(wParam) == BN_CLICKED || HIWORD(wParam) == CBN_SELCHANGE)
                {
                if (LOWORD(wParam) == idcViewDictionary)
                    {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsSpellCaption), MAKEINTRESOURCEW(idsErrSpellWarnDictionary), NULL, MB_OK | MB_ICONINFORMATION);
                    OpenCustomDictionary();
                    }
                else
                    {
                    PropSheet_Changed(GetParent(hwnd), hwnd);
                    }
                }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
                {
                case PSN_APPLY:
                    {
                    int i;
                    int lidNew;
                    int lidOld;
                    TCHAR       rgchBuf[10];

                    // get the current language
                    GetLangID(rgchBuf, sizeof(rgchBuf) / sizeof(TCHAR));
                    lidOld = StrToInt(rgchBuf);

                    Assert(pmoi != NULL);

                    ButtonChkToOptInfo(hwnd, CHK_AlwaysSuggest, pmoi, OPT_SPELLALWAYSSUGGEST);
                    ButtonChkToOptInfo(hwnd, CHK_CheckSpellingOnSend, pmoi, OPT_SPELLCHECKONSEND);
                    ButtonChkToOptInfo(hwnd, CHK_CheckSpellingOnType, pmoi, OPT_SPELLCHECKONTYPE);
                    ButtonChkToOptInfo(hwnd, CHK_IgnoreUppercase, pmoi, OPT_SPELLIGNOREUPPER);
                    ButtonChkToOptInfo(hwnd, CHK_IgnoreNumbers, pmoi, OPT_SPELLIGNORENUMBER);
                    ButtonChkToOptInfo(hwnd, CHK_IgnoreOriginalMessage, pmoi, OPT_SPELLIGNOREPROTECT);
                    ButtonChkToOptInfo(hwnd, CHK_IgnoreDBCS, pmoi, OPT_SPELLIGNOREDBCS);
                    ButtonChkToOptInfo(hwnd, CHK_IgnoreURL, pmoi, OPT_SPELLIGNOREURL);

                    i = ComboBox_GetCurSel(GetDlgItem(hwnd, idcSpellLanguages));
                    lidNew =(LID)  ComboBox_GetItemData(GetDlgItem(hwnd, idcSpellLanguages), i);

                    if (lidNew != lidOld)
                        {
	                        wsprintf(rgchBuf, "%d", lidNew);
                            SetLangID(rgchBuf);
                        }
                    }
                    break;
                }
            break;

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SPELL_SETTINGS_ICON);
            FreeIcon(hwnd, IDC_SPELL_IGNORE_ICON);
            FreeIcon(hwnd, IDC_SPELL_LANGUAGE_ICON);
            break;
#if 0
        case WM_HELP:
            {
            NMHDR nmhdr;

            nmhdr.code = PSN_HELP;
            SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM) &nmhdr);
            SetWindowLong(hwnd, DWL_MSGRESULT, TRUE);
            return TRUE;
            }
#endif
        }

    return(FALSE);
    }


BOOL EnumOffice9UserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR   	rgchBuf[cchMaxPathName];
    HKEY    	hkey = NULL;
	FILETIME    ft;
	DWORD   	iKey = 0;
	LONG    	lRet;
	TCHAR		szValue[cchMaxPathName];
	DWORD		cchValue;
	TCHAR   	szCustDict[cchMaxPathName];
	DWORD   	cchCustDict;
	BOOL    	fContinue = TRUE;
	BOOL		fFoundUserDict = FALSE;
	TCHAR		szOffice9Proof[cchMaxPathName]={0};
	
    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    lstrcat(rgchBuf, c_szRegSpellKeyCustom);

    if(RegOpenKeyEx(HKEY_CURRENT_USER, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
        	cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

			fFoundUserDict = TRUE;

			// check to see if we have a path
			if (!(StrChr(szCustDict, ':') || StrChr(szCustDict, '\\')))
			{
				TCHAR	szTemp[cchMaxPathName];
				
				if (!strlen(szOffice9Proof))
				{
    				LPITEMIDLIST pidl;

				    if (S_OK == SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl))
				        SHGetPathFromIDList(pidl, szOffice9Proof);

				    // if this fails then we will try the current path
				}

				lstrcpy(szTemp, szOffice9Proof);
				lstrcat(szTemp, "\\");
				lstrcat(szTemp, c_szSpellOffice9ProofPath);
				lstrcat(szTemp, szCustDict);
				lstrcpy(szCustDict, szTemp);
			}
			
            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

	return fFoundUserDict;
}

BOOL EnumOfficeUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR   	rgchBuf[cchMaxPathName];
    HKEY    	hkey = NULL;
	FILETIME    ft;
	DWORD   	iKey = 0;
	LONG    	lRet;
	TCHAR		szValue[cchMaxPathName];
	DWORD		cchValue;
	TCHAR   	szCustDict[cchMaxPathName];
	DWORD   	cchCustDict;
	BOOL		fFoundUserDict = FALSE;
	BOOL    	fContinue = TRUE;

    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    lstrcat(rgchBuf, c_szRegSpellKeyCustom);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
        	cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

			fFoundUserDict = TRUE;

            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

    return fFoundUserDict;
}

VOID EnumUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
	// check for Office9 user dictionaries. If we find any
	// we bail.
	if (EnumOffice9UserDictionaries(dwCookie, pfn))
		return;

	EnumOfficeUserDictionaries(dwCookie, pfn);
}

BOOL GetDefaultUserDictionary(TCHAR *rgchUserDict, int cchBuff)
{
    DWORD           dwType;
    DWORD			cchUserDict;
    HKEY            hkey = NULL;
	BOOL			fFound = FALSE;
	
    if(!RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedTools, 0, KEY_QUERY_VALUE, &hkey))
    {
    	cchUserDict = cchBuff;
    	
	    if (SHQueryValueEx(hkey, c_szRegSharedToolsPath, 0L, &dwType, rgchUserDict, &cchUserDict) == ERROR_SUCCESS)
	    {
		    lstrcat(rgchUserDict, c_szRegDefCustomDict);

			fFound = TRUE;
	    }

		RegCloseKey(hkey);
    }

	// if we where able to create a path to the user dict store it in the regdb
	if (fFound)
	{
    	TCHAR   rgchBuf[cchMaxPathName];

	    lstrcpy(rgchBuf, c_szRegSpellProfile);
	    lstrcat(rgchBuf, c_szRegSpellKeyCustom);

	    if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, rgchBuf, REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hkey, NULL) == ERROR_SUCCESS)
	    {
			RegSetValueEx(hkey, c_szRegSpellPathDict, 0, REG_SZ, (BYTE *)rgchUserDict, (lstrlen(rgchUserDict) + 1) * sizeof(TCHAR));

	        RegCloseKey(hkey);
		}
	}
	
	return fFound;
}

BOOL EnumUserDictCallback(DWORD_PTR dwCookie, LPTSTR lpszDict)
{
	lstrcpy((LPSTR)dwCookie, lpszDict);

	return FALSE;
}

BOOL GetDefUserDictionaries(LPTSTR lpszDict, DWORD cchDict)
{
	lpszDict[0] = 0;
	
	EnumUserDictionaries((DWORD_PTR)lpszDict, EnumUserDictCallback);

	if (strlen(lpszDict))
		return TRUE;

	if (GetDefaultUserDictionary(lpszDict, cchDict))
		return TRUE;
	
    return FALSE;
}

VOID OpenCustomDictionary(VOID)
{
HKEY    hkey = NULL;
TCHAR   rgchBuf[cchMaxPathName];
DWORD   cbData = 0;
DWORD   dwType;

    // Verify that .DIC files can be handled:
    rgchBuf[0] = '\0';

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szRegDICHandlerKEY, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
        {
        if (hkey)
            {
            SHQueryValueEx(hkey, NULL, 0L, &dwType, (BYTE *) rgchBuf, &cbData);
            RegCloseKey(hkey);
            }
        }

    if (cbData == 0 || !rgchBuf[0])
        {
        if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                            c_szRegDICHandlerKEY,
                            0,
                            rgchBuf,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            0,
                            &hkey,
                            NULL) == ERROR_SUCCESS)
            {
            if (hkey)
                {
                RegSetValueEx(hkey, NULL, 0L, REG_SZ, (BYTE *) c_szRegDICHandlerDefault, (lstrlen(c_szRegDICHandlerDefault) + 1) * sizeof(TCHAR));
                RegCloseKey(hkey);
                }
            }
        }

	if (GetDefUserDictionaries(rgchBuf, sizeof(rgchBuf)/sizeof(TCHAR)))
	{
		// make sure our directory exists
		{
			TCHAR	rgchDictDir[MAX_PATH];

			lstrcpy(rgchDictDir, rgchBuf);

			PathRemoveFileSpec(rgchDictDir);
			OpenDirectory(rgchDictDir);
		}

		// now make sure the file exists
		// if it does not create it
		{
			HANDLE		hFile;

			hFile = CreateFile(rgchBuf, GENERIC_READ | GENERIC_WRITE, 0, NULL,
								CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

			if (hFile != INVALID_HANDLE_VALUE)
				CloseHandle(hFile);
		}
		
        {
        SHELLEXECUTEINFO see;
        ZeroMemory(&see, sizeof(SHELLEXECUTEINFO));

        see.cbSize = sizeof(see);
        see.fMask = SEE_MASK_NOCLOSEPROCESS;
        see.lpFile = rgchBuf;
        see.nShow = SW_SHOWNORMAL;

        if (ShellExecuteEx(&see))
            {
            Assert(see.hProcess);
            WaitForInputIdle(see.hProcess, 20000);
            CloseHandle(see.hProcess);
            }
        }
    }
}

BOOL FBadSpellChecker(LPSTR rgchBufDigit)
{
    TCHAR       rgchBufKey[cchMaxPathName];
    TCHAR       rgchBuf[cchMaxPathName];
    TCHAR       szMdr[cchMaxPathName];
    LPSTR       pszSpell;

    wsprintf(rgchBufKey, c_szRegSpellKeyDef, rgchBufDigit);

    if (!GetSpellingPaths(rgchBufKey, rgchBuf, szMdr, sizeof(rgchBuf)/sizeof(TCHAR)))
        return TRUE;

    pszSpell = PathFindFileNameA(rgchBuf);
    if (!pszSpell)
        return TRUE;

    if (lstrcmpi(pszSpell, "msspell.dll")==0 ||
        lstrcmpi(pszSpell, "mssp32.dll")==0)
        return TRUE;

	// bradk@directeq.com - check that the dict exists (also check the spell dll
	// for good measure) - 40081

	// spell dll must exist
    if (!PathFileExists(rgchBuf))
        return TRUE;

	// main dict must exist
    if (!PathFileExists(szMdr))
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     StatBar.cpp
//
//  PURPOSE:    Implements the CStatusBar class which manipulates the apps
//              status bar.
//

#include "pch.hxx"
#include "statbar.h"
#include "menures.h"
#include <oerules.h>
#include <demand.h>

/////////////////////////////////////////////////////////////////////////////
// The order here needs to match the DELIVERYNOTIFYTYPE enumeration from
// mailnews\spooler\spoolapi.h.  If there is a zero in the below array, then
// the status area should be cleared out.

const int c_rgidsSpoolerNotify[DELIVERY_NOTIFY_ALLDONE + 1][2] = {
    /* DELIVERY_NOTIFY_STARTING       */  { 0, 0 },   
    /* DELIVERY_NOTIFY_CONNECTING     */  { idsSBConnecting, STATUS_IMAGE_CONNECTED },
    /* DELIVERY_NOTIFY_SECURE         */  { 0, 0 },
    /* DELIVERY_NOTIFY_UNSECURE       */  { 0, 0 },
    /* DELIVERY_NOTIFY_AUTHORIZING    */  { idsAuthorizing, STATUS_IMAGE_AUTHORIZING },
    /* DELIVERY_NOTIFY_CHECKING       */  { idsSBChecking, STATUS_IMAGE_CHECKING },
    /* DELIVERY_NOTIFY_CHECKING_NEWS  */  { idsSBCheckingNews, STATUS_IMAGE_CHECKING_NEWS },
    /* DELIVERY_NOTIFY_SENDING        */  { idsSBSending, STATUS_IMAGE_SENDING },
    /* DELIVERY_NOTIFY_SENDING_NEWS   */  { idsSBSendingNews, STATUS_IMAGE_SENDING },
    /* DELIVERY_NOTIFY_RECEIVING      */  { idsSBReceiving, STATUS_IMAGE_RECEIVING },
    /* DELIVERY_NOTIFY_RECEIVING_NEWS */  { idsSBReceivingNews, STATUS_IMAGE_RECEIVING },
    /* DELIVERY_NOTIFY_COMPLETE       */  { 0, 0 },
    /* DELIVERY_NOTIFY_RESULT         */  { 0, 0 },
    /* DELIVERY_NOTIFY_ALLDONE        */  { idsSBNewMsgsControl, STATUS_IMAGE_NEWMSGS }
};

const int c_rgidsConnected[][2] = {
    { idsWorkingOffline, STATUS_IMAGE_OFFLINE },
    { idsWorkingOnline,  STATUS_IMAGE_ONLINE },
    { idsNotConnected,   STATUS_IMAGE_DISCONNECTED }
};


/////////////////////////////////////////////////////////////////////////////
// Constructors etc.

CStatusBar::CStatusBar()
{
    m_cRef = 1;
    m_hwnd = 0;
    m_hwndProg = 0;
    m_tidOwner = 0;
    m_dwFlags = 0;
    m_himl = 0;
    ZeroMemory(m_rgIcons, sizeof(HICON) * STATUS_IMAGE_MAX);
    m_cxFiltered = 0;
    m_cxSpooler = 0;
    m_cxConnected = 0;
    m_cxProgress = 0;
    m_fInSimple = FALSE;
    m_ridFilter = RULEID_VIEW_ALL;
    m_statusConn = CONN_STATUS_WORKOFFLINE;
    m_typeDelivery = DELIVERY_NOTIFY_STARTING;
    m_cMsgsDelivery = 0;
}

CStatusBar::~CStatusBar()
{
    // Free the image list
    if (m_himl)
        ImageList_Destroy(m_himl);

    // Free our icons
    for (UINT i = 0; i < STATUS_IMAGE_MAX; i++)
    {
        if (m_rgIcons[i])
            DestroyIcon(m_rgIcons[i]);
    }
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown
//

HRESULT CStatusBar::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IStatusBar))
        *ppvObj = (LPVOID) (IStatusBar *) this;

    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return S_OK;
}


ULONG CStatusBar::AddRef(void)
{
    return InterlockedIncrement((LONG *) &m_cRef);
}


ULONG CStatusBar::Release(void)
{
    InterlockedDecrement((LONG *) &m_cRef);
    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }
    return (m_cRef);
}


//
//  FUNCTION:   CStatusBar::Initialize()
//
//  PURPOSE:    Creates and initializes the status bar window.
//
//  PARAMETERS: 
//      [in] hwndParent - Handle of the window that will be this control's parent
//      [in] dwFlags    - Determine which parts will be displayed
//
//  RETURN VALUE:
//      E_OUTOFMEMORY, S_OK
//
HRESULT CStatusBar::Initialize(HWND hwndParent, DWORD dwFlags)
{
    TraceCall("CStatusBar::Initialize");

    // This is now the thread that owns the class
    m_tidOwner = GetCurrentThreadId();

    // Keep these around
    m_dwFlags = dwFlags;

    // Create the status window
    m_hwnd = CreateStatusWindow(WS_CHILD | SBARS_SIZEGRIP | WS_CLIPSIBLINGS | SBT_TOOLTIPS,
                                NULL, hwndParent, IDC_STATUS_BAR);
    if (!m_hwnd)
        return (E_OUTOFMEMORY);

    // Calculate the widths of the various areas we support
    _UpdateWidths();

    // Load the image list too
    m_himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbStatus), 16,
                                 0, RGB(255, 0, 255), IMAGE_BITMAP, 0);

    // Note - We don't need to add any parts here since we do that in the 
    //        OnSize() call.
    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::ShowStatus()
//
//  PURPOSE:    Shows or hides the status bar.
//
//  PARAMETERS: 
//      [in] fShow - TRUE to show the bar, FALSE to hide it.
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CStatusBar::ShowStatus(BOOL fShow)
{
    TraceCall("CStatusBar::ShowStatus");
    Assert(GetCurrentThreadId() == m_tidOwner);

    if (IsWindow(m_hwnd))
        ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::OnSize()
//
//  PURPOSE:    Tells the status bar that the parent window resized.  In return
//              the status bar updates it's own width to match.
//
//  PARAMETERS: 
//      [in] cx - New width of the paret
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CStatusBar::OnSize(int cx, int cy)
{
    int   rgcx[SBP_MAX];
    int * prgcx = rgcx;
    DWORD cVisible = 1;
    DWORD cPart = SBP_MAX - 1;
    BOOL  dwNoProgress = 0;
    int   cxProgress = 0;
    int   cxFiltered = 0;
    int   cxConnected = 0;
    int   cxSpooler = 0;
    
    TraceCall("CStatusBar::OnSize");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // Forward a WM_SIZE message off to the status bar
    SendMessage(m_hwnd, WM_SIZE, SIZE_RESTORED, MAKELPARAM(cx, cy));

    // Check to see if the progress bar is visible
    dwNoProgress = !IsWindow(m_hwndProg);

    // Figure out our widths
    if (IsWindow(m_hwndProg))
    {
        cxProgress = m_cxProgress;
        cVisible++;
    }

    if ((0 == (m_dwFlags & SBI_HIDE_FILTERED)) && (RULEID_VIEW_ALL != m_ridFilter))
    {
        cxFiltered = m_cxFiltered;
        cVisible++;
    }

    if (0 == (m_dwFlags & SBI_HIDE_CONNECTED))
    {
        cxConnected = m_cxConnected;
        cVisible++;
    }

    if (0 == (m_dwFlags & SBI_HIDE_SPOOLER))
    {
        cxSpooler = m_cxSpooler;
        cVisible++;
    }

    // If we have a filter turned on
    if ((0 == (m_dwFlags & SBI_HIDE_FILTERED)) && (RULEID_VIEW_ALL != m_ridFilter))
    {
        *prgcx = cxFiltered;
        prgcx++;
    }

    // For general area
    *prgcx = cx - cxProgress - cxConnected - cxSpooler;
    prgcx++;

    // If we have progress
    if (0 != cxProgress)
    {
        *prgcx = cx - cxConnected - cxSpooler;
        prgcx++;
    }

    // For connected state
    *prgcx = cx - cxSpooler;
    prgcx++;

    // For spooler state
    *prgcx = cx;
    prgcx++;
    
    // Tell the status bar to update
    SendMessage(m_hwnd, SB_SETPARTS, cVisible, (LPARAM) rgcx);
    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::GetHeight()
//
//  PURPOSE:    Allows the caller to find out how tall the status bar is.
//
//  PARAMETERS: 
//      [out] pcy - Returns the height.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CStatusBar::GetHeight(int *pcy)
{
    RECT rc;

    TraceCall("CStatusBar::GetHeight");

    if (!pcy)
        return (E_INVALIDARG);

    if (IsWindowVisible(m_hwnd))
    {
        GetClientRect(m_hwnd, &rc);
        *pcy = rc.bottom;
    }
    else
        *pcy = 0;

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::ShowSimpleText()
//
//  PURPOSE:    Puts the status bar into simple mode and displays the 
//              specified string.
//
//  PARAMETERS: 
//      [in] pszText - String or resource ID of the string to display
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::ShowSimpleText(LPTSTR pszText)
{
    TCHAR szBuf[CCHMAX_STRINGRES] = "";

    TraceCall("CStatusBar::ShowSimpleText");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // If we have a progress bar visible, hide it first
    if (IsWindow(m_hwndProg))
        ShowWindow(m_hwndProg, SW_HIDE);

    // Check to see if we need to load the string
    if (IS_INTRESOURCE(pszText) && pszText != 0)
    {        
        LoadString(g_hLocRes, PtrToUlong(pszText), szBuf, ARRAYSIZE(szBuf));
        pszText = szBuf;
    }

    // Tell the status bar to go into simple mode
    SendMessage(m_hwnd, SB_SIMPLE, (WPARAM) TRUE, 0);
    m_fInSimple = TRUE;

    // Set the status text
    SendMessage(m_hwnd, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM) pszText);

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::HideSimpleText()
//
//  PURPOSE:    Tells the status bar to stop displaying simple mode.
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::HideSimpleText(void)
{
    TraceCall("CStatusBar::HideSimpleText");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // Tell the status bar to leave simple mode
    SendMessage(m_hwnd, SB_SIMPLE, (WPARAM) FALSE, 0);
    m_fInSimple = FALSE;

    // If we had a progress bar before, show it again
    if (IsWindow(m_hwndProg))
        ShowWindow(m_hwndProg, SW_SHOW);

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::SetStatusText()
//
//  PURPOSE:    Sets the text for the SBP_GENERAL area
//
//  PARAMETERS: 
//      [in] pszText - String or resource ID of the string to display
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::SetStatusText(LPTSTR pszText)
{
    TCHAR szBuf[CCHMAX_STRINGRES];

    TraceCall("CStatusBar::SetStatusText");
    Assert(GetCurrentThreadId() == m_tidOwner);

    DWORD dwPos = SBP_GENERAL;
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }
    
    // Check to see if we need to load the string
    if (IS_INTRESOURCE(pszText))
    {
        AthLoadString(PtrToUlong(pszText), szBuf, ARRAYSIZE(szBuf));
        pszText = szBuf;
    }

    // Set the status text
    SendMessage(m_hwnd, SB_SETTEXT, dwPos, (LPARAM) pszText);

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::ShowProgress()
//
//  PURPOSE:    Adds the progress bar area to the status bar.
//
//  PARAMETERS: 
//      [in] dwRange - Maximum range for the progress bar control
//
//  RETURN VALUE:
//      E_OUTOFMEMORY, S_OK 
//
HRESULT CStatusBar::ShowProgress(DWORD dwRange)
{
    TraceCall("CStatusBar::ShowProgress");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // Create the progress bar control
    m_hwndProg = CreateWindow(PROGRESS_CLASS, 0, WS_CHILD | PBS_SMOOTH,
                              0, 0, 10, 10, m_hwnd, (HMENU) IDC_STATUS_PROGRESS,
                              g_hInst, NULL);
    if (!m_hwndProg)
        return (E_OUTOFMEMORY);

    DWORD dwPos = SBP_PROGRESS;
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }

    // Hit the status bar with a size to force it to add the progress bar area
    RECT rc;
    GetClientRect(m_hwnd, &rc); 
    OnSize(rc.right, rc.bottom);

    SendMessage(m_hwndProg, PBM_SETRANGE32, 0, dwRange);

    // Now size the progress bar to sit inside the status bar
    SendMessage(m_hwnd, SB_GETRECT, dwPos, (LPARAM) &rc);
    SetWindowPos(m_hwndProg, NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    // If we're not in simple mode, show it
    if (!m_fInSimple)
        ShowWindow(m_hwndProg, SW_SHOW);

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::SetProgress()
//
//  PURPOSE:    Set's the progress bar position.
//
//  PARAMETERS: 
//      [in] dwPos - New progress bar position
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::SetProgress(DWORD dwPos)
{
    TraceCall("CStatusBar::SetProgress");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // Update the progress bar
    if (IsWindow(m_hwndProg))
    {
        SendMessage(m_hwndProg, PBM_SETPOS, dwPos, 0);
    }

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::HideProgress()
//
//  PURPOSE:    Hides the progress bar.
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::HideProgress(void)
{
    TraceCall("CStatusBar::HideProgress");
    Assert(GetCurrentThreadId() == m_tidOwner);

    if (IsWindow(m_hwndProg))
    {
        // Destroy the progress bar
        DestroyWindow(m_hwndProg);
        m_hwndProg = 0;

        // Hit the status bar with a size to have it remove the well
        RECT rc;
        GetClientRect(m_hwnd, &rc);
        OnSize(rc.right, rc.bottom);
    }

    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::SetConnectedStatus()
//
//  PURPOSE:    Updates the status in the SBP_CONNECTED area
//
//  PARAMETERS: 
//      [in] status - New status
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::SetConnectedStatus(CONN_STATUS status)
{
    TraceCall("SetConnectedStatus");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // First job is to figure out the position
    DWORD dwPos = SBP_CONNECTED - (!IsWindow(m_hwndProg));
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }

    // Next, load the appropriate string for this new status
    TCHAR szRes[CCHMAX_STRINGRES];

    Assert(status < CONN_STATUS_MAX);
    AthLoadString(c_rgidsConnected[status][0], szRes, ARRAYSIZE(szRes));

    // Also need to load the right picture
    HICON hIcon = _GetIcon(c_rgidsConnected[status][1]);

    // Tell the status bar to update
    SendMessage(m_hwnd, SB_SETTEXT, dwPos, (LPARAM) szRes); 
    SendMessage(m_hwnd, SB_SETICON, dwPos, (LPARAM) hIcon);

    // Cache the connection status
    m_statusConn = status;
    
    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::SetSpoolerStatus()
//
//  PURPOSE:    Updates the spooler area.
//
//  PARAMETERS: 
//      [in] type - New status
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CStatusBar::SetSpoolerStatus(DELIVERYNOTIFYTYPE type, DWORD cMsgs)
{
    TCHAR szRes[CCHMAX_STRINGRES] = "";
    HICON hIcon;
    DWORD dwPos;

    TraceCall("CStatusBar::SetSpoolerStatus");
    Assert(GetCurrentThreadId() == m_tidOwner);
    Assert(type <= DELIVERY_NOTIFY_ALLDONE);

    // First job is to figure out the position
    dwPos = SBP_SPOOLER - (0 != (m_dwFlags & SBI_HIDE_CONNECTED)) - (!IsWindow(m_hwndProg));
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }

    // If we are at the ALLDONE state, we do some extra work
    if (type == DELIVERY_NOTIFY_ALLDONE)
    {
        if (-1 == cMsgs)
        {
            // Some error occured
            hIcon = _GetIcon(STATUS_IMAGE_ERROR);
            AthLoadString(idsErrorText, szRes, ARRAYSIZE(szRes));
        }
        else if (0 == cMsgs)
        {
            hIcon = _GetIcon(STATUS_IMAGE_NOMSGS);
            AthLoadString(idsSBNoNewMsgs, szRes, ARRAYSIZE(szRes));
        }
        else
        {
            TCHAR szBuf[CCHMAX_STRINGRES];

            hIcon = _GetIcon(STATUS_IMAGE_NEWMSGS);
            AthLoadString(idsSBNewMsgsControl, szBuf, ARRAYSIZE(szBuf));
            wsprintf(szRes, szBuf, cMsgs);
        }
    }
    else
    {
        hIcon = _GetIcon(c_rgidsSpoolerNotify[type][1]);
        if (c_rgidsSpoolerNotify[type][0])
            AthLoadString(c_rgidsSpoolerNotify[type][0], szRes, ARRAYSIZE(szRes));
    }

    // Tell the status bar to update
    if (*szRes != 0)
    {
        SendMessage(m_hwnd, SB_SETTEXT, dwPos, (LPARAM) szRes); 
        SendMessage(m_hwnd, SB_SETICON, dwPos, (LPARAM) hIcon);
    }
    else
    {
        SendMessage(m_hwnd, SB_SETTEXT, dwPos, (LPARAM) szRes); 
        SendMessage(m_hwnd, SB_SETICON, dwPos, 0);
    }

    // Cache the delivery info
    m_typeDelivery = type;
    m_cMsgsDelivery = cMsgs;
    
    return (S_OK);
}


//
//  FUNCTION:   CStatusBar::OnNotify()
//
//  PURPOSE:    Sends notifications to the status bar
//
//  PARAMETERS: 
//      NMHDR *pnmhdr
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CStatusBar::OnNotify(NMHDR *pNotify)
{
    DWORD dwPoints;
    POINT pt;
    RECT  rc;
    DWORD dwSpoolerPos;
    DWORD dwConnectPos;

    TraceCall("CStatusBar::OnNotify");
    Assert(GetCurrentThreadId() == m_tidOwner);

    if (m_dwFlags & SBI_HIDE_SPOOLER)
    {
        dwSpoolerPos = -1;
    }
    else
    {
        dwSpoolerPos = SBP_SPOOLER - (!IsWindow(m_hwndProg));

        if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
        {
            dwSpoolerPos--;
        }
    }

    dwConnectPos = (m_dwFlags & SBI_HIDE_CONNECTED) ? -1 : dwSpoolerPos - 1;
    
    if (pNotify->idFrom == IDC_STATUS_BAR)
    {
        if (NM_DBLCLK == pNotify->code)
        {
            dwPoints = GetMessagePos();
            pt.x = LOWORD(dwPoints);
            pt.y = HIWORD(dwPoints);
            ScreenToClient(m_hwnd, &pt);
            SendMessage(m_hwnd, SB_GETRECT, dwSpoolerPos, (LPARAM)&rc);
            if (PtInRect(&rc, pt))
            {
                g_pSpooler->StartDelivery(GetParent(m_hwnd), NULL, FOLDERID_INVALID, DELIVER_SHOW);
            }
            else
            {
                SendMessage(m_hwnd, SB_GETRECT, dwConnectPos, (LPARAM)&rc);
                if (PtInRect(&rc, pt))
                {
                    PostMessage(GetParent(m_hwnd), WM_COMMAND, ID_WORK_OFFLINE, 0);
                }
            }
        }
    }
    return (S_OK);
}




//
//  FUNCTION:   CStatusBar::SetFilter()
//
//  PURPOSE:    Sets the filter for the SBP_FILTERED area
//
//  PARAMETERS: 
//      [in] ridFilter - ID for the current filter
//
//  RETURN VALUE:
//      S_OK 
//
HRESULT CStatusBar::SetFilter(RULEID ridFilter)
{
    RECT rc;
    TCHAR szBuf[CCHMAX_STRINGRES];
    DWORD dwPos;

    TraceCall("CStatusBar::SetFilter");
    Assert(GetCurrentThreadId() == m_tidOwner);

    // Get the data
    dwPos = SBP_GENERAL;
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }
    
    // Get the status text
    SendMessage(m_hwnd, SB_GETTEXT, dwPos, (LPARAM) szBuf);

    // Cache the rule
    m_ridFilter = ridFilter;
    
    // Resize the status bar
    GetClientRect(m_hwnd, &rc);
    OnSize(rc.right, rc.bottom);
    
    dwPos = SBP_GENERAL;
    if ((m_dwFlags & SBI_HIDE_FILTERED) || (RULEID_VIEW_ALL == m_ridFilter))
    {
        dwPos--;
    }
    
    // Set the status text
    SendMessage(m_hwnd, SB_SETTEXT, dwPos, (LPARAM) szBuf);
    SendMessage(m_hwnd, SB_SETICON, dwPos, (LPARAM) NULL);
    
    AthLoadString(idsViewFiltered, szBuf, ARRAYSIZE(szBuf));
    
    // Set the data into the status bar
    if ((0 == (m_dwFlags & SBI_HIDE_FILTERED)) && (RULEID_VIEW_ALL != m_ridFilter))
    {
        SendMessage(m_hwnd, SB_SETTEXT, SBP_FILTERED, (LPARAM) szBuf);
    }

    if (0 == (m_dwFlags & SBI_HIDE_SPOOLER))
    {
        SetConnectedStatus(m_statusConn);
    }

    if (0 == (m_dwFlags & SBI_HIDE_CONNECTED))
    {
        SetSpoolerStatus(m_typeDelivery, m_cMsgsDelivery);
    }

    return (S_OK);
}

//
//  FUNCTION:   CStatusBar::_UpdateWidths()
//
//  PURPOSE:    Calculates the widths of each of the different areas of the 
//              status bar.
//
void CStatusBar::_UpdateWidths(void)
{
    HDC   hdc;
    TCHAR szBuf[CCHMAX_STRINGRES];
    SIZE  size;
    int   i;

    TraceCall("CStatusBar::_UpdateWidths");

    // Get the DC from the status bar
    hdc = GetDC(m_hwnd);

    // Now we need to figure out how big our parts are going to be.

    // Figure out the space needed for the filtered state
    AthLoadString(idsViewFiltered, szBuf, ARRAYSIZE(szBuf));
    GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), &size);
    m_cxFiltered = size.cx;

    // Add some padding and space for the icon
    m_cxFiltered += (2 * GetSystemMetrics(SM_CXEDGE));
    
    // Figure out the space needed for the spooler state
    for (i = 0; i < ARRAYSIZE(c_rgidsSpoolerNotify); i++)
    {
        if (c_rgidsSpoolerNotify[i][0])
        {
            AthLoadString(c_rgidsSpoolerNotify[i][0], szBuf, ARRAYSIZE(szBuf));
            GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), &size);
            if (size.cx > m_cxSpooler)
                m_cxSpooler = size.cx;
        }
    }

    // Add some padding and space for the icon and the grippy thing
    m_cxSpooler += (2 * GetSystemMetrics(SM_CXEDGE)) + 24 + 16;

    // Do the same for the connected part
    for (i = 0; i < ARRAYSIZE(c_rgidsConnected); i++)
    {
        if (c_rgidsConnected[i][0])
        {
            LoadString(g_hLocRes, c_rgidsConnected[i][0], szBuf, ARRAYSIZE(szBuf));
            GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), &size);
            if (size.cx > m_cxConnected)
                m_cxConnected = size.cx;
        }
    }

    // Add some padding and space for the icon
    m_cxConnected += (2 * GetSystemMetrics(SM_CXEDGE)) + 24;
    
    // Let's say that the progress is always equal to 
    // the space for the connected area
    m_cxProgress = m_cxConnected;

    ReleaseDC(m_hwnd, hdc);

    return;
}


HICON CStatusBar::_GetIcon(DWORD iIndex)
{
    // Make sure the index is valid
    if (iIndex > STATUS_IMAGE_MAX)
        return 0;

    // Check to see if we've already created this one
    if (m_rgIcons[iIndex])
        return (m_rgIcons[iIndex]);

    // Otherwise, create it.
    m_rgIcons[iIndex] = ImageList_GetIcon(m_himl, iIndex, ILD_TRANSPARENT);
    return (m_rgIcons[iIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statnery.cpp ===
// =================================================================================
// S T A T N E R Y . C P P
// =================================================================================
#include "pch.hxx"
#include "strconst.h"
#include "goptions.h"
#include "error.h"
#include "resource.h"
#include "mailutil.h"
#include "statnery.h"
#include "wininet.h"
#include "options.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "regutil.h"
#include "menuutil.h"
#include "thumb.h"
#include "optres.h"
#include <statwiz.h>
#include "url.h"
#include <bodyutil.h>
#include "demand.h"
#include "menures.h"
#include "ipab.h"
#include "mailnews.h"

#define STARTINDEX      0
#define CNOMORE         4
#define MAX_ENTRY       10
#define MAX_SHOWNAME    50

BOOL PASCAL MoreStationeryNotify(HWND hDlg, LPOFNOTIFYW pofn);
BOOL FHtmlFile(LPWSTR pwszFile);
BOOL CALLBACK MoreStationeryDlgHookProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL IsValidFileName(LPWSTR pwszFile);
void ShowBlankPreview(HWND hwnd);
HRESULT ShowMorePreview(HWND hwnd);
HRESULT FillHtmlToFileA(LPSTATWIZ pApp, HANDLE hFile, INT idsSample, BOOL fTemp);
HRESULT FillHtmlToFileW(LPSTATWIZ pApp, HANDLE hFile, INT idsSample, BOOL fTemp);

BOOL   fValidFile(LPWSTR pwszFile);
BOOL   fFileOK(LPWSTR pwszFile);

static WCHAR s_wszStationeryDir[MAX_PATH]={0};
static WCHAR g_wszLastStationeryPath[MAX_PATH];

static const HELPMAP g_rgStatWizHlp[] = {
    {IDC_SHOWPREVIEW_BUTTON_ADD, IDH_STATIONERY_BROWSE_PICTURE },
    {IDC_SHOWPREVIEW_BUTTON_EDIT, IDH_STATIONERY_EDIT },
    {IDC_STATWIZ_PREVIEWBACKGROUND, IDH_STATIONERY_PREVIEW},
    {IDC_MOREPREVIEW, 35640},
    {IDC_SHOWPREVIEW_CHECK, 35656},
    {0, 0}
};
    

const static CHAR c_szHtmlExtension[] = ".htm";
const static CHAR c_szTempFileName[]  = "StatWiz";

static const WCHAR c_wszFile[] = L"File";
static const WCHAR c_wszRSFileFmt[] = L"%s%d";

const static WCHAR c_wszBlankHtml[]     = L"blank.htm";
const static WCHAR c_wszEditCmd[]       = L"edit";
const static WCHAR c_wszHtmlHeadFmt[]   = L"<HTML>\r\n<HEAD>\r\n<STYLE>\r\nBODY {\r\n";
const static WCHAR c_wszStyleClose[]    = L"}\r\n</STYLE>\r\n</HEAD>\r\n";
const static WCHAR c_wszBodyFmt[]       = L"<BODY %s=\"%s\">\r\n";
const static WCHAR c_wszHtmlClose[]     = L"</BODY>\r\n</HTML>\r\n";
const static WCHAR c_wszBkPicture[]     = L"background";
const static WCHAR c_wszBkColor[]       = L"bgcolor";
const static WCHAR c_wszFontFmt[]       = L"font-family: %s;\r\nfont-size: %dpt;\r\ncolor: %s;\r\n";
const static WCHAR c_wszBold[]          = L"font-weight: bold;\r\n";
const static WCHAR c_wszItalic[]        = L"font-style: italic;\r\n";
const static WCHAR c_wszLeftMarginFmt[] = L"margin-left: %d px;\r\n";
const static WCHAR c_wszTopMarginFmt[]  = L"margin-top: %d px;\r\n";
const static WCHAR c_wszFontFamily[]    = L"font-family:";
const static WCHAR c_wszFontSize[]      = L"font-size:";
const static WCHAR c_wszFontColor[]     = L"color:";
const static WCHAR c_wszBkRepeat[]      = L"background-repeat: %s;\r\n";
const static WCHAR c_wszBkPosition[]    = L"background-position: %s;\r\n";
const static LPWSTR c_lppwszBkPos[3][3] = { 
    {L"top left",       L"top center",      L"top right"},
    {L"center left",    L"center center",   L"center right"},
    {L"bottom left",    L"bottom center",   L"bottom right"}};
static const LPWSTR c_rgpwszHTMLExtensions[]    = {L"*.htm",        L"*.html"};
const static LPWSTR c_lpwszRepeatPos[]          = {L"no-repeat",    L"repeat-y",    L"repeat-x",    L"repeat" };
static const LPWSTR c_wszPictureExtensions[]    = {L"*.gif",        L"*.bmp",       L"*.jpg"};

const static CHAR c_szBlankHtml[]     = "blank.htm";
const static CHAR c_szEditCmd[]       = "edit";
const static CHAR c_szHtmlHeadFmt[]   = "<HTML>\r\n<HEAD>\r\n<STYLE>\r\nBODY {\r\n";
const static CHAR c_szStyleClose[]    = "}\r\n</STYLE>\r\n</HEAD>\r\n";
const static CHAR c_szBodyFmt[]       = "<BODY %s=\"%s\">\r\n";
const static CHAR c_szHtmlClose[]     = "</BODY>\r\n</HTML>\r\n";
const static CHAR c_szBkPicture[]     = "background";
const static CHAR c_szBkColor[]       = "bgcolor";
const static CHAR c_szFontFmt[]       = "font-family: %s;\r\nfont-size: %dpt;\r\ncolor: %s;\r\n";
const static CHAR c_szBold[]          = "font-weight: bold;\r\n";
const static CHAR c_szItalic[]        = "font-style: italic;\r\n";
const static CHAR c_szLeftMarginFmt[] = "margin-left: %d px;\r\n";
const static CHAR c_szTopMarginFmt[]  = "margin-top: %d px;\r\n";
const static CHAR c_szFontFamily[]    = "font-family:";
const static CHAR c_szFontSize[]      = "font-size:";
const static CHAR c_szFontColor[]     = "color:";
const static CHAR c_szBkRepeat[]      = "background-repeat: %s;\r\n";
const static CHAR c_szBkPosition[]    = "background-position: %s;\r\n";
const static LPSTR c_lppszBkPos[3][3] = { 
    {"top left",       "top center",      "top right"},
    {"center left",    "center center",   "center right"},
    {"bottom left",    "bottom center",   "bottom right"}};
static const LPSTR c_rgpszHTMLExtensions[]    = {"*.htm",        "*.html"};
const static LPSTR c_lpszRepeatPos[]          = {"no-repeat",    "repeat-y",    "repeat-x",    "repeat" };
static const LPSTR c_szPictureExtensions[]    = {"*.gif",        "*.bmp",       "*.jpg"};

/******************************************************************************************
* ListEntry
*******************************************************************************************/
ListEntry::ListEntry()
{
    INT iLen;

    m_cRef = 1;
    m_pwszFile = NULL;
	m_pNext = NULL;
}

HRESULT ListEntry::HrInit(LPWSTR pwszFile)
{
    INT         iLen;
    HRESULT     hr = S_OK;

    if(NULL == pwszFile || *pwszFile == 0)
        IF_FAILEXIT(hr = E_INVALIDARG);

#pragma prefast(suppress:11, "noise")
    iLen = lstrlenW(pwszFile);
    IF_NULLEXIT(MemAlloc((LPVOID*)&m_pwszFile, (iLen+1)*sizeof(WCHAR)));

    StrCpyW(m_pwszFile, pwszFile);

exit:
    return hr;
}

ListEntry::~ListEntry()
{
    MemFree(m_pwszFile);
    m_pNext = NULL;
}

ULONG ListEntry::AddRef(VOID)
{
    return ++m_cRef;
}

ULONG ListEntry::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



/******************************************************************************************
* CStationery
*******************************************************************************************/
CStationery::CStationery()
{
    m_cRef = 1;
    m_pFirst = NULL;
    InitializeCriticalSection(&m_rCritSect);
}

CStationery::~CStationery()
{
    Assert (m_cRef == 0);
    while(S_OK==HrDeleteEntry(0));
    DeleteCriticalSection(&m_rCritSect);
}

ULONG CStationery::AddRef(VOID)
{
    return ++m_cRef;
}

ULONG CStationery::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// always insert at the beginning.
HRESULT CStationery::HrInsertEntry(LPWSTR pwszFile)
{
    LPLISTENTRY pNewEntry = NULL;
    HRESULT     hr = S_OK;

    if(!fFileOK(pwszFile))
        return E_INVALIDARG;

    EnterCriticalSection(&m_rCritSect);
    IF_NULLEXIT(pNewEntry = new ListEntry);

    IF_FAILEXIT(hr = pNewEntry->HrInit(pwszFile));

    IF_FAILEXIT(hr = HrInsertEntry(pNewEntry));

    pNewEntry = NULL; //prevent deleting.

exit:
    LeaveCriticalSection(&m_rCritSect);
    ReleaseObj(pNewEntry);
    return hr;
}


HRESULT CStationery::HrInsertEntry(LPLISTENTRY pEntry)
{
    HRESULT     hr = S_OK;

    if(NULL==pEntry || !fFileOK(pEntry->m_pwszFile))
        return TraceResult(E_INVALIDARG);

    EnterCriticalSection(&m_rCritSect);
    if(cEntries()==MAX_ENTRY)
        IF_FAILEXIT(hr = HrDeleteEntry(MAX_ENTRY-1));

    if(NULL!=m_pFirst) //not empty
        pEntry->m_pNext = m_pFirst;

    m_pFirst = pEntry;

exit:
    LeaveCriticalSection(&m_rCritSect);
    return hr;
}


// iIndex is 0 based
HRESULT CStationery::HrPromoteEntry(INT iIndex)
{
    HRESULT     hr = NOERROR;
    LPLISTENTRY pPromotedEntry = NULL;

    if(iIndex == 0 || !fValidIndex(iIndex))
        return TraceResult(E_INVALIDARG);

    EnterCriticalSection(&m_rCritSect);
    IF_NULLEXIT(pPromotedEntry = RemoveEntry(iIndex));

    IF_FAILEXIT(hr = HrInsertEntry(pPromotedEntry));

exit:
    LeaveCriticalSection(&m_rCritSect);
    return hr;
}


LPLISTENTRY CStationery::MoveToEntry(INT iIndex)
{
    LPLISTENTRY pEntry = NULL;

    if(!fValidIndex(iIndex))
        goto error;

    pEntry = m_pFirst;

    if(iIndex!=0)
    {
        for(INT i=0; i<iIndex; i++)
        {
            pEntry = pEntry->m_pNext;
            Assert(pEntry);
        }
    }

error:
    return pEntry;
}


LPLISTENTRY CStationery::RemoveEntry(INT iIndex)
{
    LPLISTENTRY pRemovedEntry = NULL,
                pEntry = m_pFirst;

    if(!fValidIndex(iIndex))
        goto error;

    EnterCriticalSection(&m_rCritSect);

    if(iIndex==0) //remove the first one,
    {
        pRemovedEntry = m_pFirst;
        m_pFirst = pRemovedEntry->m_pNext;
    }
    else
    {
        pEntry = MoveToEntry(iIndex - 1);
        pRemovedEntry = pEntry->m_pNext;
        pEntry->m_pNext = pRemovedEntry ->m_pNext;
    }

error:
    LeaveCriticalSection(&m_rCritSect);
    return pRemovedEntry;
}


HRESULT CStationery::HrDeleteEntry(INT iIndex)
{
    HRESULT     hr = NOERROR;
    LPLISTENTRY pRemovedEntry = NULL;

    if(!fValidIndex(iIndex))
        return TraceResult(E_INVALIDARG);

    EnterCriticalSection(&m_rCritSect);
    pRemovedEntry = RemoveEntry(iIndex);
    if (!pRemovedEntry)
        IF_FAILEXIT(hr = E_FAIL);

exit:
    ReleaseObj(pRemovedEntry);
    LeaveCriticalSection(&m_rCritSect);
    return hr;
}


VOID CStationery::ValidateList(BOOL fCheckExist)
{
    HRESULT     hr      = NOERROR;
    LPLISTENTRY pEntry  = m_pFirst,
                pPrev   = NULL;
    BOOL        fValid  = FALSE;

    EnterCriticalSection(&m_rCritSect);
    while(pEntry != NULL)
    {
        fValid = fCheckExist ? fValidFile(pEntry->m_pwszFile) : fFileOK(pEntry->m_pwszFile);
        if(!fValid)
        {
            if(pEntry == m_pFirst)
            {
                m_pFirst = pEntry->m_pNext;
                ReleaseObj(pEntry);
                pEntry = m_pFirst;
            }
            else if (pPrev != NULL)
            {
                pPrev->m_pNext = pEntry->m_pNext;
                ReleaseObj(pEntry);
                pEntry = pPrev->m_pNext;
            }
        }
        pPrev = pEntry;
        if(pEntry)
            pEntry = pEntry->m_pNext;
    }

    LeaveCriticalSection(&m_rCritSect);
    return;
}

HRESULT CStationery::HrGetFileName(INT iIndex, LPWSTR pwszBuf)
{
    HRESULT     hr = NOERROR;
    LPLISTENTRY pEntry = NULL;

    if(!fValidIndex(iIndex) || NULL==pwszBuf)
        return TraceResult(E_INVALIDARG);

    pEntry = MoveToEntry(iIndex);
    if (!pEntry)
        IF_FAILEXIT(hr = E_FAIL);

#pragma prefast(suppress:11, "noise")
    StrCpyW(pwszBuf, pEntry->m_pwszFile);

exit:
    return hr;
}


INT CStationery::cEntries()
{
    INT         iRet = 0;
    LPLISTENTRY pEntry = m_pFirst;

    while(pEntry != NULL)
    {
        pEntry = pEntry->m_pNext;
        iRet++;
    }

    return iRet;
}


BOOL CStationery::fValidIndex(INT iIndex)
{
    BOOL    fRet = TRUE;

    if(iIndex < 0 || iIndex > MAX_ENTRY)
        fRet = FALSE;

    if(cEntries()<=iIndex)
        fRet = FALSE;

    return fRet;
}


BOOL fFileOK(LPWSTR pwszFile)
{
    BOOL            fRet = FALSE;

    if(pwszFile == NULL || *pwszFile == 0)
        goto exit;

    if (!FHtmlFile(pwszFile))
        goto exit;

    fRet = TRUE;

exit:
    return fRet;
}


BOOL fValidFile(LPWSTR pwszFile)
{
    BOOL            fRet = FALSE;
    WCHAR           wszBuf[MAX_PATH];
    DWORD           dwAttributes;

    *wszBuf = 0;
    if(!fFileOK(pwszFile))
        goto exit;

    StrCpyW(wszBuf, pwszFile);
    InsertStationeryDir(wszBuf);
    dwAttributes = GetFileAttributesWrapW(wszBuf);
    if((UINT)dwAttributes==(UINT)-1 || dwAttributes&FILE_ATTRIBUTE_DIRECTORY)
        goto exit;

    fRet = TRUE;

exit:
    return fRet;
}


HRESULT CStationery::HrFindEntry(LPWSTR pwszFile, INT* pRet)
{
    INT             iRet = -1, iIndex=0;
    LPLISTENTRY     pEntry = m_pFirst;
    HRESULT         hr = S_OK;

    *pRet = iRet;
    if(!fFileOK(pwszFile))
        return TraceResult(E_INVALIDARG);

    while(pEntry != NULL)
    {
        if(StrCmpW(pEntry->m_pwszFile, pwszFile) == 0)
        {
            iRet = iIndex;
            break;
        }
        pEntry = pEntry->m_pNext;
        iIndex++;
    }
    *pRet = iRet;
    if(iRet==-1)
        hr = E_FAIL;

    return hr;
}


HRESULT CStationery::HrLoadStationeryList()
{
    HRESULT         hr = NOERROR;
    INT             i;
    HKEY            hkey=NULL;
    DWORD           dwType=0, cb=0, dw=0;
    WCHAR           wszFileName[INTERNET_MAX_URL_LENGTH];
    WCHAR           wszFileRegName[MAX_PATH];
    LONG            lRegResult;

    *wszFileName = 0;
    *wszFileRegName = 0;

    lRegResult = AthUserOpenKey(c_szRegPathRSWideList, KEY_READ, &hkey);

    // If we failed, then try and open up the old list.
    if (ERROR_SUCCESS != lRegResult)
        lRegResult = AthUserOpenKey(c_szRegPathRSList, KEY_READ, &hkey);

    if (ERROR_SUCCESS == lRegResult)
    {
        for(i = MAX_ENTRY-1; i >= 0; i--)
        {
            AthwsprintfW(wszFileRegName, ARRAYSIZE(wszFileRegName), c_wszRSFileFmt, c_wszFile, i);
            cb = sizeof(wszFileName);
            if(ERROR_SUCCESS == RegQueryValueExWrapW(hkey, wszFileRegName, 0, 
                                                     &dwType, (LPBYTE)wszFileName, &cb))
            {
                hr = HrInsertEntry(wszFileName);
                if (hr == E_OUTOFMEMORY)
                    break;
            }
        }
        RegCloseKey(hkey);
    }

    if(E_OUTOFMEMORY != hr)
        hr = NOERROR; //we only catch E_OUTOFMEMORY.
        
    return hr;
}

void CStationery::SaveStationeryList()
{
    INT             index = 0;
    HKEY            hkey=NULL;
    WCHAR           wszFileRegName[MAX_PATH];
    LPLISTENTRY     pEntry = m_pFirst;
    INT             i;
    DWORD           dw;

    *wszFileRegName = 0;
    if (ERROR_SUCCESS == AthUserCreateKey(c_szRegPathRSWideList, KEY_WRITE, &hkey, &dw))
    {
        while(pEntry != NULL)
        {
            AthwsprintfW(wszFileRegName, ARRAYSIZE(wszFileRegName), c_wszRSFileFmt, c_wszFile, index);
            StripStationeryDir(pEntry->m_pwszFile);
            if(pEntry->m_pwszFile && *(pEntry->m_pwszFile))
            {
                DWORD cb = (lstrlenW(pEntry->m_pwszFile) + 1) * sizeof(WCHAR);
                RegSetValueExWrapW(hkey, wszFileRegName, 0, REG_SZ, (LPBYTE)(pEntry->m_pwszFile), cb);
                index++;
            }
            pEntry = pEntry->m_pNext;
        }
        for(i = index; i < MAX_ENTRY; i++) // NULL the rest
        {
            AthwsprintfW(wszFileRegName, ARRAYSIZE(wszFileRegName), c_wszRSFileFmt, c_wszFile, i);
            RegSetValueExWrapW(hkey, wszFileRegName, 0, REG_SZ, (LPBYTE)c_wszEmpty, sizeof(WCHAR));
        }
        RegCloseKey(hkey);
    }
}

HRESULT CStationery::HrGetShowNames(LPWSTR pwszFile, LPWSTR pwszShowName, int cchShowName, INT index)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwsz = NULL;
    INT         iLen;
    WCHAR       wszBuf[MAX_PATH];

    *wszBuf = 0;

    if(pwszFile==NULL || *pwszFile==0 || pwszShowName==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

#pragma prefast(suppress:11, "noise")
    iLen = lstrlenW(pwszFile);
    *pwszShowName = 0;

    PathCompactPathExW(wszBuf, pwszFile, MAX_SHOWNAME, 0);

    if(*wszBuf == 0)
        IF_FAILEXIT(hr = E_FAIL);

    if(index == (MAX_ENTRY-1))
        AthwsprintfW(pwszShowName, cchShowName, c_wszNumberFmt10, wszBuf);
    else
        AthwsprintfW(pwszShowName, cchShowName, c_wszNumberFmt, index+1, wszBuf);

    // delete .htm and .html
    PathRemoveExtensionW(pwszShowName);

exit:
    return hr;
}

// Assumes that there are no other items on the menu that have to be numbered.
void CStationery::AddStationeryMenu(HMENU hmenu, int idFirst, int idMore)
{
    INT             iIndex = 0,
                    cNumIDs;
    LPLISTENTRY     pEntry = m_pFirst;
    WCHAR           wszBuf[MAX_PATH];
    INT             cMenus;
    MENUITEMINFOW   mii;
    INT             iInsertPos;
    BOOL            fInsertSep = FALSE;
    int             idMax = idFirst + 10;

    *wszBuf = 0;
    if (hmenu == NULL)
        return;

    // First delete any previous stationery off this menu
    for (UINT i = idFirst; i < (UINT)idMax; i++)
    {
        // When delete fails, then have gone as far as needed
        if (0 == DeleteMenu(hmenu, i, MF_BYCOMMAND))
            break;
    }
    DeleteMenu(hmenu, ID_STATIONERY_SEPARATOR, MF_BYCOMMAND);

    // Now figure out what index to start inserting at
    cNumIDs = GetMenuItemCount(hmenu) - 1;
    while (((UINT)idMore != GetMenuItemID(hmenu, cNumIDs)) && (cNumIDs > 0))
        cNumIDs--;
    
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;

    ValidateList(FALSE);
    pEntry = m_pFirst;
    while(pEntry)
    {
        *wszBuf = 0;
        HrGetShowNames(pEntry->m_pwszFile, wszBuf, ARRAYSIZE(wszBuf), iIndex);
        if(*wszBuf != 0)
        {
            InsertMenuWrapW(hmenu, (UINT)(cNumIDs+iIndex), MF_BYPOSITION|MF_STRING, idFirst + iIndex, wszBuf);
            iIndex++;
            fInsertSep = TRUE;
        }
        pEntry = pEntry->m_pNext;
    }

    if(fInsertSep)
        InsertMenu(hmenu, (UINT)(cNumIDs+iIndex), MF_BYPOSITION | MF_SEPARATOR, ID_STATIONERY_SEPARATOR, NULL);

    return;
}

void CStationery::GetStationeryMenu(HMENU *phMenu)
{
    LPLISTENTRY     pEntry = m_pFirst;
    INT             iIndex = 0;
    WCHAR           wszBuf[MAX_PATH];

    *wszBuf = 0;
    *phMenu = LoadPopupMenu(IDR_NEW_MSG_POPUP);

    ValidateList(FALSE);
    pEntry = m_pFirst;
    while(pEntry)
    {
        *wszBuf = 0;
        HrGetShowNames(pEntry->m_pwszFile, wszBuf, ARRAYSIZE(wszBuf), iIndex);
        if(*wszBuf != 0)
        {
            InsertMenuWrapW(*phMenu, (UINT)iIndex, MF_BYPOSITION | MF_STRING, ID_STATIONERY_RECENT_0 + iIndex, wszBuf);
            iIndex++;
        }
        pEntry = pEntry->m_pNext;
    }

    if(iIndex > 0)
        InsertMenu(*phMenu, (UINT)iIndex, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
}

HRESULT HrStationeryInit(void)
{
    HRESULT hr = S_OK;

    if (NULL == g_pStationery)
    {
        g_pStationery = new CStationery;
        if (NULL == g_pStationery)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        IF_FAILEXIT(hr = g_pStationery->HrLoadStationeryList());
    }

exit:
    return hr;
}


void AddStationeryMenu(HMENU hmenu, int idPopup, int idFirst, int idMore)
{
    if (idPopup)
    {
        MENUITEMINFOW   mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_SUBMENU;

        if (GetMenuItemInfoWrapW(hmenu, idPopup, FALSE, &mii))
            hmenu = mii.hSubMenu;
    }

    if(g_pStationery == NULL)
    {
        if (FAILED(HrStationeryInit()))
            return;
    }

#pragma prefast(suppress:11, "noise")
    g_pStationery->AddStationeryMenu(hmenu, idFirst, idMore);

}

void GetStationeryMenu(HMENU *phmenu)
{
    if(g_pStationery == NULL)
    {
        if (FAILED(HrStationeryInit()))
            return;
    }

#pragma prefast(suppress:11, "noise")
    g_pStationery->GetStationeryMenu(phmenu);

}


HRESULT HrGetStationeryFileName(INT index, LPWSTR pwszFile)
{
    HRESULT     hr = S_OK;

    if(pwszFile==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if(g_pStationery == NULL)
        IF_FAILEXIT(hr = HrStationeryInit());

#pragma prefast(disable:11, "noise")
    *pwszFile = 0;
    g_pStationery->HrGetFileName(index, pwszFile);
#pragma prefast(enable:11, "noise")

    if(*pwszFile != 0)
    {
        if(!fValidFile(pwszFile))
        {
            g_pStationery->ValidateList(TRUE);
            IF_FAILEXIT(hr = E_FAIL);
        }

        InsertStationeryDir(pwszFile);
    }

exit:
    return hr;
}

HRESULT HrNewStationery(HWND hwnd,      INT     id,         LPWSTR      pwszFile, 
                        BOOL fModal,    BOOL    fMail,      FOLDERID    folderID, 
                        BOOL fAddToMRU, DWORD   dwSource,   IUnknown    *pUnkPump,
                        IMimeMessage    *pMsg)
{
    INT         index = id - ID_STATIONERY_RECENT_0;
    WCHAR       wszBuf[INTERNET_MAX_URL_LENGTH];
    HRESULT     hr = S_OK;

    *wszBuf=0;

    if(g_pStationery == NULL)
        IF_FAILEXIT(hr = HrStationeryInit());

    if(pwszFile == NULL)
        g_pStationery->HrGetFileName(index, wszBuf);
    else
        StrCpyW(wszBuf, pwszFile);

    if(*wszBuf == 0)
        IF_FAILEXIT(hr = E_FAIL)

    if(!fValidFile(wszBuf))
    {
        g_pStationery->ValidateList(TRUE);
        IF_FAILEXIT(hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    InsertStationeryDir(wszBuf);

    // This might pop up a dialog, in which case, error might be valid. Don't traceresult.
    // If don't add to MRU, then stationery by default. Therefore, send a signature.
    hr = HrSendWebPageDirect(wszBuf, hwnd, fModal, fMail, folderID, 
                             TRUE, pUnkPump, pMsg);

    if(fAddToMRU && SUCCEEDED(hr))
        // Since this only adds to the MRU, we don't care about error.
        HrAddToStationeryMRU(wszBuf);

exit:
    ULONG ulErrRsrc;
    // At this point, if we canceled, then propagate success up.
    if (MAPI_E_USER_CANCEL == hr)
        hr = S_OK;
    if(FAILED(hr))
    {
        if( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
        {   
            ulErrRsrc = idsErrStationeryNotFound;

            switch (dwSource)
            {
                case NSS_MRU:
                    // Remove fromt he MRU if file not found.
                    HrRemoveFromStationeryMRU(wszBuf);
                    break;

                case NSS_DEFAULT:
                    // need to reset stationary for user if couldn't find it in the dir
                    if( !SetDwOption( fMail ? OPT_MAIL_USESTATIONERY : OPT_NEWS_USESTATIONERY, 0, hwnd, 0) )
                    {
                        DebugTrace("reset failed\n");
                    }
                    break;
            }
        }
        else
        {
            ulErrRsrc = idsErrNewStationery;
        }
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
            MAKEINTRESOURCEW(ulErrRsrc), NULL, MB_OK);            

        if (!pMsg)
        {
            // Only contacts passes us pMsg. In that case it handles the failure correctly.

            if (FNewMessage(hwnd, fModal, FALSE, !fMail, folderID, pUnkPump))
                hr = S_OK;
            else
                hr = E_FAIL;
        }
    }        
    return hr;
}

HRESULT HrAddToStationeryMRU(LPWSTR pwszFile)
{
    int     index;
    HRESULT hr;

    if (pwszFile==NULL || *pwszFile==0)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if (g_pStationery == NULL)
        IF_FAILEXIT(hr = HrStationeryInit());

    StripStationeryDir(pwszFile);

#pragma prefast(suppress:11, "noise")
    hr = g_pStationery->HrFindEntry(pwszFile, &index);
    if(FAILED(hr))
        hr = g_pStationery->HrInsertEntry(pwszFile);
    else
        hr = g_pStationery->HrPromoteEntry(index);

exit:
    return hr;
}

HRESULT HrRemoveFromStationeryMRU(LPWSTR pwszFile)
{
    int   index;
    HRESULT hr;

    if (pwszFile==NULL || *pwszFile==0)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if (g_pStationery == NULL)
        IF_FAILEXIT(hr = HrStationeryInit());

    StripStationeryDir(pwszFile);

    IF_FAILEXIT(hr = g_pStationery->HrFindEntry(pwszFile, &index));
    IF_FAILEXIT(hr = g_pStationery->HrDeleteEntry(index));

exit:
    return hr;
}

HRESULT HrGetStationeryPath(LPWSTR pwszPath)
{
    HRESULT         hr = NOERROR;
    DWORD           cb, dwType;
    LONG            lReg=0;
    HKEY            hkey = 0;

    if(pwszPath == NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if(*s_wszStationeryDir == 0)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegStationery, 0, KEY_QUERY_VALUE, &hkey))
        {
            cb = sizeof(s_wszStationeryDir);

            // Will need to convert this. Won't compile right now.
            lReg = RegQueryValueExWrapW(hkey, c_wszValueStationery, 0, &dwType, (LPBYTE)s_wszStationeryDir , &cb);
            if (ERROR_SUCCESS!=lReg || cb==0)
                IF_FAILEXIT(hr = E_FAIL);
        }

        if(*s_wszStationeryDir == 0)
            IF_FAILEXIT(hr = E_FAIL);

        PathRemoveBackslashW(s_wszStationeryDir);
    }

    Assert(*s_wszStationeryDir);
    ExpandEnvironmentStringsWrapW(s_wszStationeryDir, pwszPath, MAX_PATH);

exit:
    if (hkey)
        RegCloseKey(hkey);

    return hr;
}

HRESULT HrGetMoreStationeryFileName(HWND hwnd, LPWSTR pwszFile)
{
    OPENFILENAMEW   ofn;            
    WCHAR           wszStationeryOpen[MAX_PATH],
                    wsz[MAX_PATH],
                    wszDir[MAX_PATH],
                    wszFile[MAX_PATH];
    LPWSTR          pwszDir = NULL;
    HRESULT         hr = S_OK;

    *wszStationeryOpen = *wszDir = *wsz = 0;
    if(!pwszFile)
        return TraceResult(E_INVALIDARG);

    ZeroMemory(&ofn, sizeof(ofn));
    AthLoadStringW(idsHtmlFileFilter, wsz, ARRAYSIZE(wsz));
    ReplaceCharsW(wsz, L'|', L'\0');
    wszFile[0] = L'\0';

    AthLoadStringW(idsStationeryOpen, wszStationeryOpen, ARRAYSIZE(wszStationeryOpen));

    if (!PathIsDirectoryW(g_wszLastStationeryPath))
    {
        *g_wszLastStationeryPath = 0;
        HrGetStationeryPath(g_wszLastStationeryPath);
    }

    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwnd;
    ofn.hInstance       = g_hLocRes;
    ofn.lpstrFilter     = wsz;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = wszFile;
    ofn.lpstrTitle      = wszStationeryOpen;
    ofn.nMaxFile        = ARRAYSIZE(wszStationeryOpen);
    ofn.lpstrInitialDir = g_wszLastStationeryPath;
    ofn.lpTemplateName  = MAKEINTRESOURCEW(iddMoreStationery);
    ofn.lpfnHook        = (LPOFNHOOKPROC)MoreStationeryDlgHookProc;
    ofn.Flags           = OFN_EXPLORER |
                          OFN_HIDEREADONLY |
                          OFN_FILEMUSTEXIST |
                          OFN_NODEREFERENCELINKS|
                          OFN_ENABLEHOOK |
                          OFN_ENABLETEMPLATE |
                          OFN_NOCHANGEDIR;

    if(GetOpenFileNameWrapW(&ofn) && *wszFile!=0)
    {
        // store the file
        StrCpyW(pwszFile, wszFile);

        // store the last path
        *g_wszLastStationeryPath = 0;
        StrCpyW(g_wszLastStationeryPath, ofn.lpstrFile);
        if (!PathIsDirectoryW(g_wszLastStationeryPath))
            PathRemoveFileSpecW(g_wszLastStationeryPath);
    }
    else
        hr = E_FAIL;

    return hr;
}


HRESULT HrMoreStationery(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump)
{
    WCHAR           wszFileName[MAX_PATH];
    HRESULT         hr;

    // Might return user cancel
    hr = HrGetMoreStationeryFileName(hwnd, wszFileName);
    if(SUCCEEDED(hr))
        hr = HrNewStationery(hwnd, 0, wszFileName, fModal, fMail, folderID, TRUE, NSS_MORE_DIALOG, pUnkPump, NULL);

    return hr;
}

BOOL CALLBACK MoreStationeryDlgHookProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WORD code;
    switch (msg)
    {
        case WM_COMMAND:
            {
                code = GET_WM_COMMAND_CMD(wParam, lParam);
                switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDC_SHOWPREVIEW_CHECK:
                    if (code == BN_CLICKED)
                    {
                        BOOL fChecked;
                        fChecked = SendMessage(GET_WM_COMMAND_HWND(wParam,lParam), BM_GETCHECK, 0, 0) == BST_CHECKED;
                        SetDwOption(OPT_NOPREVIEW, !fChecked, NULL, 0);
                        if (fChecked)
                            ShowMorePreview(hwnd);
                        else
                            ShowBlankPreview(GetDlgItem(hwnd, IDC_MOREPREVIEW));
                    }
                    SetFocus(GetDlgItem(GetParent(hwnd), lst1));  
                    return FALSE;
                    
                case IDC_SHOWPREVIEW_BUTTON_EDIT:
                    {
                        WCHAR               wszBuf[MAX_PATH];
                        TCHAR               szBuf[2 * MAX_PATH];
                        
                        *wszBuf = 0;

                        if (SendMessageWrapW(GetParent(hwnd), CDM_GETSPEC, (WPARAM)ARRAYSIZE(wszBuf), (LPARAM)wszBuf) && lstrlenW(wszBuf) > 0)
                        {
                            // This is a workaround for a bug in SendMessageWrapW. It doesn't wrap ansi strings properly
                            //Win 9x returns an ANSI string in the wide buffer.
                            //Need to make it a real wide string
                            //Bug# 78629

                            if (VER_PLATFORM_WIN32_WINDOWS == g_OSInfo.dwPlatformId)
                            {
                                memcpy(szBuf, wszBuf, 2 * MAX_PATH);
                                MultiByteToWideChar(CP_ACP, 0, szBuf, MAX_PATH, wszBuf, MAX_PATH);
                            }

                            SHELLEXECUTEINFOW   sei;
                            sei.cbSize = sizeof(sei);
                            sei.fMask = SEE_MASK_UNICODE;
                            sei.hwnd = hwnd;
                            sei.lpVerb = c_wszEditCmd;
                            sei.lpFile = wszBuf;
                            sei.lpParameters = NULL;
                            sei.lpDirectory = NULL;
                            sei.nShow = SW_SHOWNORMAL;
                            sei.hInstApp = 0;

                            if(SE_ERR_NOASSOC == (INT_PTR)ShellExecuteExWrapW(&sei))
                            {
                                sei.lpVerb = c_wszNotepad;
                                ShellExecuteExWrapW(&sei);
                            }
                        }
                        else
                        {                                        
                            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                                MAKEINTRESOURCEW(idsErrStatEditNoSelection), NULL, MB_OK);
                        }
                        return FALSE;
                    }
                case IDC_SHOWPREVIEW_BUTTON_ADD:
                    {
                        CStatWiz* pStatWiz = 0;
                        HWND hDlg = GetParent(hwnd);
                        LPWSTR pwszFile;
                        LPSTR  pszFile;

                        pStatWiz = new CStatWiz();
                        if( !pStatWiz ) return TRUE; // bail if can't create wiz                        

                        if (pStatWiz->DoWizard(hwnd) == S_OK)
                        {     
                            pwszFile = PathFindFileNameW(pStatWiz->m_wszHtmlFileName);

                            // bobn; Raid 81946; 7/1/99
                            // CDM_SETCONTROLTEXT is not handled by SendMessageWrapW, 
                            // we have to thunk it ourselves...
                            if (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId)
                                SendMessageW(hDlg, CDM_SETCONTROLTEXT, (WPARAM)edt1, (LPARAM)pwszFile);
                            else
                            {
                                pszFile = PszToANSI(CP_ACP, pwszFile);
                                if(pszFile)
                                {
                                    SendMessageA(hDlg, CDM_SETCONTROLTEXT, (WPARAM)edt1, (LPARAM)pszFile); 
                                    MemFree(pszFile);
                                }
                            }

                            if( !DwGetOption(OPT_NOPREVIEW) )
                            {
                                ShowMorePreview(hwnd);
                            }
                        }
                        ReleaseObj(pStatWiz);
                        return FALSE;
                    }
                }
            }
            return TRUE;

        case WM_INITDIALOG:
            { 
                TCHAR szBuf[CCHMAX_STRINGRES];
                LoadString(g_hLocRes, idsOK, szBuf, sizeof(szBuf));

                if (!DwGetOption(OPT_NOPREVIEW))
                    CheckDlgButton(hwnd, IDC_SHOWPREVIEW_CHECK, BST_CHECKED);
                
                SetWindowText(GetDlgItem(GetParent(hwnd), IDOK), szBuf);
                CenterDialog( GetParent(hwnd) );
            }
            return TRUE;
		case WM_NOTIFY:
			MoreStationeryNotify(hwnd, (LPOFNOTIFYW)lParam);
            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgStatWizHlp);            
    }
    return FALSE;
}

void ShowBlankPreview(HWND hwnd)
{
    SendMessage(hwnd, THM_LOADPAGE, 0, (LPARAM)c_wszBlankHtml);
}

HRESULT ShowPreview(HWND hwnd, LPWSTR pwszFile)
{
    GetStationeryFullName(pwszFile);

    // Even if the full name fails, will need to clear the thumbprint
    SendMessage(hwnd, THM_LOADPAGE, 0, (LPARAM)pwszFile);

    return S_OK;
}

HRESULT FillHtmlToFile(LPSTATWIZ pApp, HANDLE hFile, INT idsSample, BOOL fTemp)
{
    WCHAR wszImageFile[MAX_PATH];
    CHAR szImageFile[MAX_PATH];

    if (!hFile || !pApp)
        return E_INVALIDARG;

    if (*pApp->m_wszBkPictureFileName)
    {
        WideCharToMultiByte(CP_ACP, 0, pApp->m_wszBkPictureFileName, -1, szImageFile, ARRAYSIZE(szImageFile), NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, szImageFile, -1, wszImageFile, ARRAYSIZE(wszImageFile));
        if(StrCmpW(wszImageFile, pApp->m_wszBkPictureFileName))
            return(FillHtmlToFileW(pApp, hFile, idsSample, fTemp));
    }

    return(FillHtmlToFileA(pApp, hFile, idsSample, fTemp));
}

#define PSZ_CB(psz)   lstrlen(psz)*sizeof(*psz)
HRESULT FillHtmlToFileA(LPSTATWIZ pApp, HANDLE hFile, INT idsSample, BOOL fTemp)
{
    WCHAR       wszFileSpec[MAX_PATH];
    CHAR        szBuf[MAX_PATH],
                szFileSpec[MAX_PATH];        
    LPSTREAM    pStm = NULL;
    LPSTR       pszFontFace = NULL,
                pszFontColor = NULL,
                pszBkColor = NULL;
    HRESULT     hr = S_OK;

    *szFileSpec = 0;

    if (!hFile || !pApp)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pStm));

    IF_FAILEXIT(hr = pStm->Write(c_szHtmlHeadFmt, PSZ_CB(c_szHtmlHeadFmt), 0));
    if (*pApp->m_wszFontFace && pApp->m_iFontSize && *pApp->m_wszFontColor)
    {
        IF_NULLEXIT(pszFontFace = PszToANSI(CP_ACP, pApp->m_wszFontFace));
        IF_NULLEXIT(pszFontColor = PszToANSI(CP_ACP, pApp->m_wszFontColor));
        wsprintf(szBuf, c_szFontFmt, pszFontFace, pApp->m_iFontSize, pszFontColor);
        IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));        
    }
    
    if (pApp->m_iLeftMargin > 0)
    {
        wsprintf(szBuf, c_szLeftMarginFmt, pApp->m_iLeftMargin);
        IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));
    }
    
    if (pApp->m_iTopMargin > 0)
    {
        wsprintf(szBuf, c_szTopMarginFmt, pApp->m_iTopMargin);
        IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));
    }
    
    if (pApp->m_fBold)
        IF_FAILEXIT(hr = pStm->Write(c_szBold, PSZ_CB(c_szBold), 0));
    
    if (pApp->m_fItalic)
        IF_FAILEXIT(hr = pStm->Write(c_szItalic, PSZ_CB(c_szItalic), 0));
    
    wsprintf(szBuf, c_szBkPosition, c_lppszBkPos[pApp->m_iVertPos][pApp->m_iHorzPos] );
    IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0 ));

    wsprintf(szBuf, c_szBkRepeat, c_lpszRepeatPos[pApp->m_iTile]);
    IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0 ));
    
    IF_FAILEXIT(hr = pStm->Write(c_szStyleClose, PSZ_CB(c_szStyleClose), 0));
    
    if (*pApp->m_wszBkPictureFileName)
    {

        StrCpyW(wszFileSpec, pApp->m_wszBkPictureFileName);
        if (fTemp)
        {
            GetStationeryFullName(wszFileSpec);
        }
        else
        {
            PathStripPathW(wszFileSpec);
        }
        WideCharToMultiByte(CP_ACP, 0, wszFileSpec, -1, szFileSpec, MAX_PATH, NULL, NULL);
        
        if (*szFileSpec)
        {
            wsprintf(szBuf, c_szBodyFmt, c_szBkPicture, szFileSpec);
            IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));
        }
    }
    if (*pApp->m_wszBkColor)
    {
        IF_NULLEXIT(pszBkColor = PszToANSI(CP_ACP, pApp->m_wszBkColor));
        wsprintf(szBuf, c_szBodyFmt, c_szBkColor, pszBkColor);
        IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));
    }    
    
    if (idsSample)
    {
        AthLoadString(idsSample, szBuf, ARRAYSIZE(szBuf));
        for (int i=0; i<50; i++)
            IF_FAILEXIT(hr = pStm->Write(szBuf, PSZ_CB(szBuf), 0));
    }
    
    IF_FAILEXIT(hr = pStm->Write(c_szHtmlClose, PSZ_CB(c_szHtmlClose), 0));
    
    IF_FAILEXIT(hr = HrRewindStream(pStm));
    IF_FAILEXIT(hr = WriteStreamToFileHandle(pStm, hFile, NULL));
    IF_FAILEXIT(hr = (FlushFileBuffers(hFile)?S_OK:E_FAIL));
    
exit:
    MemFree(pszFontFace);
    MemFree(pszFontColor);
    MemFree(pszBkColor);
    ReleaseObj(pStm);    
    return hr;
}

#define PWSZ_CB(pwsz)   lstrlenW(pwsz)*sizeof(*pwsz)
HRESULT FillHtmlToFileW(LPSTATWIZ pApp, HANDLE hFile, INT idsSample, BOOL fTemp)
{
    WCHAR       wszBuf[MAX_PATH],
                wszFileSpec[MAX_PATH];        
    LPSTREAM    pStm = NULL;
    BYTE        bUniMark = 0xFF;
    HRESULT     hr = S_OK;

    *wszFileSpec = 0;

    if (!hFile || !pApp)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pStm));
    
    // Write out the BOM
    IF_FAILEXIT(hr = pStm->Write(&bUniMark, sizeof(bUniMark), NULL));
    bUniMark = 0xFE;
    IF_FAILEXIT(hr = pStm->Write(&bUniMark, sizeof(bUniMark), NULL));

    IF_FAILEXIT(hr = pStm->Write(c_wszHtmlHeadFmt, PWSZ_CB(c_wszHtmlHeadFmt), 0));
    if (*pApp->m_wszFontFace && pApp->m_iFontSize && *pApp->m_wszFontColor)
    {
        AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszFontFmt, pApp->m_wszFontFace, pApp->m_iFontSize, pApp->m_wszFontColor);
        IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
    }
    
    if (pApp->m_iLeftMargin > 0)
    {
        AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszLeftMarginFmt, pApp->m_iLeftMargin);
        IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
    }
    
    if (pApp->m_iTopMargin > 0)
    {
        AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszTopMarginFmt, pApp->m_iTopMargin);
        IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
    }
    
    if (pApp->m_fBold)
        IF_FAILEXIT(hr = pStm->Write(c_wszBold, PWSZ_CB(c_wszBold), 0));
    
    if (pApp->m_fItalic)
        IF_FAILEXIT(hr = pStm->Write(c_wszItalic, PWSZ_CB(c_wszItalic), 0));
    
    AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszBkPosition, c_lppwszBkPos[pApp->m_iVertPos][pApp->m_iHorzPos] );
    IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0 ));

    AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszBkRepeat, c_lpwszRepeatPos[pApp->m_iTile]);
    IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0 ));
    
    IF_FAILEXIT(hr = pStm->Write(c_wszStyleClose, PWSZ_CB(c_wszStyleClose), 0));
    
    if (*pApp->m_wszBkPictureFileName)
    {
        StrCpyW(wszFileSpec, pApp->m_wszBkPictureFileName);
        if (fTemp)
        {
            GetStationeryFullName(wszFileSpec);
        }
        else
        {
            PathStripPathW(wszFileSpec);
        }
        
        if (*wszFileSpec)
        {
            AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszBodyFmt, c_wszBkPicture, wszFileSpec);
            IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
        }
    }
    if (*pApp->m_wszBkColor)
    {
        AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), c_wszBodyFmt, c_wszBkColor, pApp->m_wszBkColor);
        IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
    }    
    
    if (idsSample)
    {
        AthLoadStringW(idsSample, wszBuf, ARRAYSIZE(wszBuf));
        for (int i=0; i<50; i++)
            IF_FAILEXIT(hr = pStm->Write(wszBuf, PWSZ_CB(wszBuf), 0));
    }
    
    IF_FAILEXIT(hr = pStm->Write(c_wszHtmlClose, PWSZ_CB(c_wszHtmlClose), 0));
    
    IF_FAILEXIT(hr = HrRewindStream(pStm));
    IF_FAILEXIT(hr = WriteStreamToFileHandle(pStm, hFile, NULL));
    IF_FAILEXIT(hr = (FlushFileBuffers(hFile)?S_OK:E_FAIL));
    
exit:
    ReleaseObj(pStm);    
    return hr;
}

HRESULT ShowPreview(HWND hwnd, LPSTATWIZ pApp, INT idsSample)
{
    WCHAR       wszBuf[MAX_PATH];
    HRESULT     hr;
    LPSTREAM    pStm = NULL;
    LPSTR       pszTempFile = NULL;
    LPWSTR      pwszTempFile = NULL;
    HANDLE      hFile=0;

    *wszBuf = 0;
    if (!hwnd || !pApp)
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr = CreateTempFile(c_szTempFileName, c_szHtmlExtension, &pszTempFile, &hFile));

    IF_FAILEXIT(hr = FillHtmlToFile(pApp, hFile, idsSample, TRUE));
    IF_NULLEXIT(pwszTempFile = PszToUnicode(CP_ACP, pszTempFile));

    SendMessage(hwnd, THM_LOADPAGE, 0, (LPARAM)pwszTempFile);

exit:
    if (hFile)
        CloseHandle(hFile);
    if (pszTempFile)
        DeleteFile(pszTempFile);
    MemFree(pszTempFile);
    MemFree(pwszTempFile);
    return hr;
}

HRESULT ShowMorePreview(HWND hwnd)
{
    HRESULT     hr = S_OK;
    WCHAR       wszFile[MAX_PATH];
    TCHAR       szFile[2 * MAX_PATH];
    *wszFile = 0;

    // Get the path of the selected file.
    if (SendMessageWrapW(GetParent(hwnd), CDM_GETFILEPATH, (WPARAM)ARRAYSIZE(wszFile), (LPARAM)(LPWSTR)wszFile) && 
                        *wszFile!=0)
    {
        //Work around for a bug in SendMessageWrapW
        //Win 9x returns an ANSI string in the wide buffer.
        //Need to make it a real wide string
        //Bug# 78619
        if (VER_PLATFORM_WIN32_WINDOWS == g_OSInfo.dwPlatformId)
        {
            memcpy(szFile, wszFile, 2 * MAX_PATH);
            MultiByteToWideChar(CP_ACP, 0, szFile, MAX_PATH, wszFile, MAX_PATH);
        }

        hr = ShowPreview(GetDlgItem(hwnd, IDC_MOREPREVIEW), wszFile);
    }
    return hr;
}

BOOL PASCAL MoreStationeryNotify(HWND hDlg, LPOFNOTIFYW pofn)
{
	if (CDN_SELCHANGE == pofn->hdr.code)
    {
        if (IsDlgButtonChecked(hDlg, IDC_SHOWPREVIEW_CHECK))
            ShowMorePreview(hDlg);
    }
    
	return TRUE;
}

BOOL FHtmlFile(LPWSTR pwszFile)
{
    LPWSTR pwszExt = PathFindExtensionW(pwszFile);

    if (pwszExt && (StrStrIW(pwszExt, L".htm") || StrStrIW(pwszExt, L".html")))
        return TRUE;
    else
        return FALSE;
}

VOID InsertStationeryDir(LPWSTR pwszPicture)
{
    WCHAR       wszDir[MAX_PATH],
                wszCopy[MAX_PATH];
    LPWSTR      pwszT1 = NULL, 
                pwszT2 = NULL;

    *wszDir = 0;
    *wszCopy = 0;
    if(pwszPicture == NULL || lstrlenW(pwszPicture)==0)
        return;

    pwszT1 = StrStrIW(pwszPicture, L"\\"); //private drive
    pwszT2 = StrStrIW(pwszPicture, L"/"); //URLs
    if(pwszT1==NULL && pwszT2==NULL) // files in background directory.
    {
        if (SUCCEEDED(HrGetStationeryPath(wszDir)))
        {
            StrCpyW(wszCopy, pwszPicture);
            AthwsprintfW(pwszPicture, MAX_PATH, L"%s\\%s", wszDir, wszCopy);
        }
    }
    return;
}

DWORD GetShortPathNameWrapW(LPCWSTR pwszLongPath, LPWSTR pwszShortPath, DWORD cchBuffer)
{
    CHAR    szShortPath[MAX_PATH*2]; // Each Unicode char might go multibyte
    LPSTR   pszLongPath = NULL;
    DWORD   cch = 0,
            cch2 = 0;

    Assert(pwszLongPath);
    Assert(pwszShortPath);
    pwszShortPath[0] = L'\0';

    if (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId)
        return(GetShortPathNameW(pwszLongPath, pwszShortPath, cchBuffer));

    pszLongPath = PszToANSI(CP_ACP, pwszLongPath);

    if (pszLongPath)
    {
        cch2 = GetShortPathName(pszLongPath, szShortPath, ARRAYSIZE(szShortPath));
        if (cch2)
            cch2 = MultiByteToWideChar(CP_ACP, 0, szShortPath, cch2+1, pwszShortPath, cchBuffer);

        if (cch2)
            cch = cch2 - 1;

        MemFree(pszLongPath);
    }

    return cch;
}

HRESULT StripStationeryDir(LPWSTR pwszPicture)
{
    WCHAR               wszDir[MAX_PATH],
                        wszPicture[MAX_PATH],
                        wszPicturePath[MAX_PATH],
                        wszShortPath[MAX_PATH] = L"",
                        wszShortDir[MAX_PATH] = L"";
    HRESULT             hr = E_FAIL;
    DWORD               cch;

    *wszDir = *wszPicture = *wszPicturePath = 0;
    if (pwszPicture==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr = HrGetStationeryPath(wszDir));

    StrCpyW(wszPicturePath, pwszPicture);
    PathRemoveFileSpecW(wszPicturePath);
    PathRemoveBackslashW(wszPicturePath);

    if (0 == StrCmpIW(wszDir, wszPicturePath))
        PathStripPathW(pwszPicture);
    else
    {
        // Convert the Picture Path to the short name as
        // it could be in the registry that way...
        if((cch = GetShortPathNameWrapW(wszDir, wszShortDir, ARRAYSIZE(wszShortDir)))==0)
        {
            hr = E_FAIL;
            goto exit;
        }

        if((cch = GetShortPathNameWrapW(wszPicturePath, wszShortPath, ARRAYSIZE(wszShortPath)))==0)
        {
            hr = E_FAIL;
            goto exit;
        }

        if (0 == StrCmpIW(wszShortDir, wszShortPath))
            PathStripPathW(pwszPicture);
    }

exit:
    return hr;
}


BOOL GetStationeryFullName(LPWSTR pwszName)
{
    WCHAR   wszBuf[MAX_PATH];
    DWORD   dwAttributes;
    HRESULT hr = S_OK;
    *wszBuf = 0;

    if (pwszName==NULL || *pwszName==0)
        IF_FAILEXIT(hr = E_INVALIDARG);

    InsertStationeryDir(pwszName);
    StrCpyW(wszBuf, pwszName);
    if (!FHtmlFile(wszBuf))
        PathAddExtensionW(wszBuf, L".htm");

    if (!PathFileExistsW(wszBuf))
    {
        StrCpyW(wszBuf, pwszName);
        if (!FHtmlFile(wszBuf))
            PathAddExtensionW(wszBuf, L".html");
        
        if (!PathFileExistsW(wszBuf))
        {
            *pwszName = 0; //this file does not exist.
            IF_FAILEXIT(hr = E_FAIL);
        }
    }

    StrCpyW(pwszName, wszBuf);

exit:
    return SUCCEEDED(hr);
}


BOOL IsValidCreateFileName(LPWSTR pwszFile)
{
    BOOL            fRet = TRUE;
    WCHAR           wszBuf[MAX_PATH];
    HANDLE          hFile;
    *wszBuf = 0;
    StrCpyW(wszBuf, pwszFile);

    if (!FHtmlFile(wszBuf))
        PathAddExtensionW(wszBuf, L".htm");

    InsertStationeryDir(wszBuf);
    if (!PathFileExistsW(wszBuf))
    {
        hFile = CreateFileWrapW(wszBuf, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            DeleteFileWrapW(wszBuf);
            StrCpyW(pwszFile, wszBuf);
            fRet = FALSE;
        }
    }

    return fRet;
}

LRESULT StationeryListBox_AddString(HWND hwndList, LPWSTR pwszFileName)
{
    LRESULT             lr=CB_ERR;
    WCHAR               wszBuf[MAX_PATH];
    HDC                 hdc;
    PAINTSTRUCT         ps;
    SIZE                rSize;
    HFONT               hfontOld, hfont;
    *wszBuf = 0;
    if(pwszFileName==NULL || *pwszFileName==0)
        return lr;

    StrCpyW(wszBuf, pwszFileName);
    StripStationeryDir(wszBuf);
    PathRemoveExtensionW(wszBuf);

    // If cannot find it
    if (SendMessageWrapW(hwndList, LB_FINDSTRINGEXACT, 0, (LPARAM)wszBuf))
    {
        hdc = GetDC(hwndList);
        hfont = (HFONT) SendMessage(hwndList, WM_GETFONT, 0, 0);
        hfontOld = (HFONT) SelectObject(hdc, hfont);
        GetTextExtentPoint32AthW(hdc, wszBuf, lstrlenW(wszBuf), &rSize, NOFLAGS);
        SelectObject(hdc, hfontOld);
        ReleaseDC(hwndList, hdc);

        if((rSize.cx+10) > ListBox_GetHorizontalExtent(hwndList))
            ListBox_SetHorizontalExtent(hwndList, rSize.cx+10);

        lr = SendMessageWrapW(hwndList, LB_ADDSTRING, 0, (LPARAM)wszBuf);
    }

    return lr;
}

LRESULT StationeryListBox_SelectString(HWND hwndList, LPWSTR pwszFileName)
{
    LRESULT             lr=CB_ERR;
    WCHAR               wszBuf[MAX_PATH];

    *wszBuf = 0;

    if (pwszFileName != NULL && *pwszFileName != 0)
    {
        StrCpyW(wszBuf, pwszFileName);
        StripStationeryDir(wszBuf);
        PathRemoveExtensionW(wszBuf);
        lr = SendMessageWrapW(hwndList, LB_FINDSTRINGEXACT, 0, (LPARAM)wszBuf);
    }

    if (lr < 0)
        lr = 0;

    ListBox_SetCurSel(hwndList, lr);

    return lr;
}


LRESULT StationeryComboBox_SelectString(HWND hwndCombo, LPWSTR pwszFileName)
{
    LRESULT             lr=CB_ERR;
    WCHAR               wszBuf[MAX_PATH];

    *wszBuf = 0;

    if (pwszFileName != NULL && *pwszFileName != 0)
    {
        StrCpyW(wszBuf, pwszFileName);
        StripStationeryDir(wszBuf);
        lr = SendMessageWrapW(hwndCombo, LB_FINDSTRINGEXACT, 0, (LPARAM)wszBuf);
    }
    
    if (lr < 0)
        lr = 0;

    ComboBox_SetCurSel(hwndCombo, lr);

    return lr;
}

HRESULT HrLoadStationery(HWND hwndList, LPWSTR pwszStationery)
{
    HRESULT         hr = NOERROR;
    LPWSTR          pwszFiles = NULL,
                    pwszT = NULL,
                    pwsz = NULL;
    LRESULT         lr=0;
    WCHAR           wszDir[MAX_PATH];
    DWORD           dw, dwType=0, cb=0;
    HKEY            hkey=NULL;
    INT             i;

    *wszDir = 0;
    ListBox_ResetContent(hwndList);

    IF_FAILEXIT(hr = HrGetStationeryPath(wszDir))

    for(i = 0; i < (ARRAYSIZE(c_rgpwszHTMLExtensions)); i++)
    {
        if(pwszFiles = Util_EnumFiles(wszDir, c_rgpwszHTMLExtensions[i]))
        {
            pwszT = pwszFiles;
            while (*pwszT)
            {
                lr = StationeryListBox_AddString(hwndList, pwszT);
                pwszT += (lstrlenW(pwszT) + 1);
            }
        }

        SafeMemFree(pwszFiles);
    }

    StationeryListBox_AddString(hwndList, pwszStationery);

exit:
    StationeryListBox_SelectString(hwndList, pwszStationery);

    return hr;
}

HRESULT HrBrowsePicture(HWND hwndParent, HWND hwndCombo)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszOpenFileName[MAX_PATH],
                    wsz[MAX_PATH],
                    wszDir[MAX_PATH],
                    wszTitle[MAX_PATH];
    LPWSTR          pwszDir = NULL;
    HRESULT         hr;

    *wszOpenFileName = *wsz = *wszDir = *wszTitle = 0;

    ZeroMemory(&ofn, sizeof(ofn));
    AthLoadStringW(idsImageFileFilter, wsz, ARRAYSIZE(wsz));
    ReplaceCharsW(wsz, L'|', L'\0');

    AthLoadStringW(idsPictureTitle, wszTitle, ARRAYSIZE(wszTitle));
    hr = HrGetStationeryPath(wszDir);
    if(SUCCEEDED(hr))
        pwszDir = wszDir;

    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndParent;
    ofn.hInstance       = g_hLocRes;
    ofn.lpstrFilter     = wsz;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = wszOpenFileName;
    ofn.nMaxFile        = MAX_PATH;
    ofn.lpstrInitialDir = pwszDir;
    ofn.lpstrTitle      = wszTitle;
    ofn.Flags           = OFN_EXPLORER |
                          OFN_HIDEREADONLY |
                          OFN_FILEMUSTEXIST |
                          OFN_NODEREFERENCELINKS|
                          OFN_NOCHANGEDIR;

    if(GetOpenFileNameWrapW(&ofn))
        PictureComboBox_AddString(hwndCombo, wszOpenFileName);

    return hr;
}

// lpszPicture is the default picture name,
HRESULT HrFillStationeryCombo(HWND hwndCombo, BOOL fBackGround, LPWSTR pwszPicture)
{
    HRESULT         hr = NOERROR;
    LPWSTR          pwszFiles = NULL,
                    pwszT = NULL,
                    pwsz = NULL;
    const LPWSTR   *pwszExtension = NULL;
    LRESULT         lr=0;
    WCHAR           wszDir[MAX_PATH];
    DWORD           dw, 
                    dwType=0, 
                    cb = 0;
    HKEY            hkey=NULL;
    INT             i, size;

    *wszDir = 0;

    IF_FAILEXIT(hr = HrGetStationeryPath(wszDir));

    if (fBackGround)
    {
        pwszExtension = c_wszPictureExtensions;
        size = ARRAYSIZE(c_wszPictureExtensions);
    }
    else
    {
        pwszExtension = c_rgpwszHTMLExtensions;
        size = ARRAYSIZE(c_rgpwszHTMLExtensions);
    }
    
    for(i = 0; i < size; i++)
    {
        if(pwszFiles = Util_EnumFiles(wszDir, pwszExtension[i]))
        {
            pwszT = pwszFiles;
            while (*pwszT)
            {
                lr = SendMessageWrapW(hwndCombo, CB_ADDSTRING, 0, (LPARAM)pwszT);
                if (lr == CB_ERR || lr == CB_ERRSPACE)
                    break;
                
                pwszT += (lstrlenW(pwszT) + 1);
            }
        }
        SafeMemFree(pwszFiles);
        if(lr == CB_ERR || lr == CB_ERRSPACE)
            break;
    }

exit:
    // add the default picture name.
    if (pwszPicture)
        PictureComboBox_AddString(hwndCombo, pwszPicture);

    return hr;
}

// add default picture name to the background picture combobox.
LRESULT PictureComboBox_AddString(HWND hwndCombo, LPWSTR pwszPicture)
{
    LRESULT             lr=CB_ERR;

    if(pwszPicture==NULL || *pwszPicture==0 || !IsValidFileName(pwszPicture))
        return lr;

    StripStationeryDir(pwszPicture);
    if (SendMessageWrapW(hwndCombo, CB_FINDSTRINGEXACT, (WPARAM)0, (LPARAM)pwszPicture) < 0)
    {
        lr = SendMessageWrapW(hwndCombo, CB_ADDSTRING, 0, (LPARAM)pwszPicture);
        if(lr==CB_ERR || lr==CB_ERRSPACE)
            return lr;
    }
    lr = SendMessageWrapW(hwndCombo, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pwszPicture);

    return lr;
}

BOOL IsValidFileName(LPWSTR pwszFile)
{
    BOOL        fRet = TRUE;
    WCHAR       wszBuf[INTERNET_MAX_URL_LENGTH];

    *wszBuf = 0;

    if(pwszFile == NULL || *pwszFile == 0)
    {
        fRet = FALSE;
        goto exit;
    }

    StrCpyW(wszBuf, pwszFile);

    InsertStationeryDir(wszBuf);
    if(!PathIsURLW(wszBuf))
    {
        if(!PathFileExistsW(wszBuf))
        {
            fRet = FALSE;
            goto exit;
        }
    }

exit:
    return fRet;
}

// Assumes that pwszName is of at least MAX_PATH chars
HRESULT GetDefaultStationeryName(BOOL fMail, LPWSTR pwszName)
{
    DWORD   fConverted = TRUE;
    CHAR    szName[MAX_PATH];

    *pwszName = 0;
    *szName = 0;

    fConverted = DwGetOption(fMail?OPT_MAIL_STATCONVERTED:OPT_NEWS_STATCONVERTED);
    if (!fConverted)
    {
        fConverted = TRUE;
        GetOption(fMail?OPT_MAIL_STATIONERYNAME:OPT_NEWS_STATIONERYNAME, szName, sizeof(szName));
        MultiByteToWideChar(CP_ACP, 0, szName, -1, pwszName, MAX_PATH);
        SetDefaultStationeryName(fMail, pwszName);
    }
    else
        GetOption(fMail?OPT_MAIL_STATIONERYNAMEW:OPT_NEWS_STATIONERYNAMEW, pwszName, MAX_PATH*sizeof(WCHAR));

    return (0 == *pwszName) ? E_FAIL : S_OK;
}

HRESULT SetDefaultStationeryName(BOOL fMail, LPWSTR pwszName)
{
    DWORD   fConverted = TRUE;

    SetOption(fMail?OPT_MAIL_STATIONERYNAMEW:OPT_NEWS_STATIONERYNAMEW, pwszName, (lstrlenW(pwszName)+1)*sizeof(WCHAR), NULL, 0);
    SetDwOption(fMail?OPT_MAIL_STATCONVERTED:OPT_NEWS_STATCONVERTED, fConverted, NULL, 0);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\storfldr.h ===
#ifndef _INC_STORFLDR_H
#define _INC_STORFLDR_H

void DoStoreLocationDlg(HWND hwnd);
BOOL DoStoreFolderDlg(HWND hwnd, TCHAR *szDir, DWORD cch);
HRESULT GetDefaultStoreRoot(HWND hwnd, TCHAR *szDir, int cch);
HRESULT OpenDirectory(TCHAR *szDir);
HRESULT HrFromLastError(void);

#endif // _INC_STORFLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statnery.h ===
// =================================================================================
// S T A T N E R Y . H
// =================================================================================
#ifndef __STATNERY_H
#define __STATNERY

// =================================================================================
// Depends On
// =================================================================================
class CStatWiz;

class ListEntry
{
    friend class CStationery;

private:
    ListEntry();
    ~ListEntry();
    ULONG   AddRef(VOID);
    ULONG   Release(VOID);
    HRESULT HrInit(LPWSTR pwszFile);

    ULONG           m_cRef;
    LPWSTR          m_pwszFile;
    ListEntry*      m_pNext;
};
typedef ListEntry *LPLISTENTRY;


class CStationery
{
private:
    ULONG               m_cRef;
    LPLISTENTRY         m_pFirst;
    CRITICAL_SECTION    m_rCritSect;

    INT             cEntries();
    LPLISTENTRY     RemoveEntry(INT iIndex);
    HRESULT         HrInsertEntry(LPLISTENTRY pEntry);

public:
                    CStationery();
                    ~CStationery();
    ULONG           AddRef(VOID);
    ULONG           Release(VOID);

    HRESULT         HrInsertEntry(LPWSTR pwszFile);
    HRESULT         HrPromoteEntry(INT iIndex);
    HRESULT         HrDeleteEntry(INT iIndex);
    HRESULT         HrLoadStationeryList();
    VOID            AddStationeryMenu(HMENU hmenu, int idFirst, int idMore);
    VOID            GetStationeryMenu(HMENU *phmenu);
    HRESULT         HrGetFileName(INT iIndex, LPWSTR wszBuf);
    LPLISTENTRY     MoveToEntry(INT iIndex);
    HRESULT         HrFindEntry(LPWSTR pwszFile, INT* pRet);
    BOOL            fValidIndex(INT iIndex);
    void            SaveStationeryList();
    HRESULT         HrGetShowNames(LPWSTR pwszFile, LPWSTR pwszszBuf, int cchBuf, INT index);
    VOID            ValidateList(BOOL fCheckExist);

};
typedef CStationery *LPSTATIONERY;

// New Stationary Source types
enum {
    NSS_DEFAULT = 0,
    NSS_MRU,
    NSS_MORE_DIALOG
};


// =================================================================================
// Prototypes
// =================================================================================
void    AddStationeryMenu(HMENU hmenu, int idPopup, int idFirst, int idMore);
void    GetStationeryMenu(HMENU *phmenu);
HRESULT HrNewStationery(HWND hwnd, INT id, LPWSTR pwszFileName, 
                        BOOL fModal, BOOL fMail, FOLDERID folderID, 
                        BOOL fAddToMRU, DWORD dwSource, IUnknown *pUnkPump, 
                        IMimeMessage    *pMsg);
HRESULT HrMoreStationery(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump);
HRESULT HrGetStationeryFileName(INT index, LPWSTR pwszFileName);
HRESULT HrGetMoreStationeryFileName(HWND hwnd, LPWSTR pwszFileName);

HRESULT HrGetStationeryPath(LPWSTR pwszPath);
HRESULT HrAddToStationeryMRU(LPWSTR pwszFile);
HRESULT HrRemoveFromStationeryMRU(LPWSTR pwszFile);
VOID    InsertStationeryDir(LPWSTR pwszPicture);
BOOL    GetStationeryFullName(LPWSTR pwszName);
BOOL    IsValidCreateFileName(LPWSTR pwszFile);
LRESULT StationeryListBox_AddString(HWND hwndList, LPWSTR pwszFileName);
LRESULT StationeryListBox_SelectString(HWND hwndList, LPWSTR pwszFileName);
LRESULT StationeryComboBox_SelectString(HWND hwndCombo, LPWSTR pwszFileName);
HRESULT HrLoadStationery(HWND hwndList, LPWSTR pwszStationery);
HRESULT HrBrowseStationery(HWND hwndParent, HWND hwndList);
HRESULT HrFillStationeryCombo(HWND hwndCombo, BOOL fBackGround, LPWSTR pwszPicture);
LRESULT PictureComboBox_AddString(HWND hwndCombo, LPWSTR pwszPicture);
HRESULT HrBrowsePicture(HWND hwndParent, HWND hwndCombo);
HRESULT ShowPreview(HWND hwnd, LPWSTR pwszFile);
HRESULT ShowPreview(HWND hwnd, CStatWiz* pApp, INT idsSample);
HRESULT FillHtmlToFile(CStatWiz* pApp, HANDLE hFile, INT idsSample, BOOL fTemp);
HRESULT StripStationeryDir(LPWSTR pwszPicture);
HRESULT GetDefaultStationeryName(BOOL fMail, LPWSTR pwszName);
HRESULT SetDefaultStationeryName(BOOL fMail, LPWSTR pwszName);

#endif // __STATNERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\storfldr.cpp ===
#include "pch.hxx"
#include <demand.h>
#include <strconst.h>
#include <storfldr.h>
#include <regstr.h>
#include <error.h>
#include <shlwapi.h>
#include "shlwapip.h" 
#include <resource.h>
#include "goptions.h"
#include "optres.h"
#include "storutil.h"
#include "multiusr.h"

INT_PTR CALLBACK StoreLocationDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LONG lRet;
    WORD code;
    char *psz, szDir[MAX_PATH];
    BOOL fRet = TRUE;
    
    switch (msg)
    {
        case WM_INITDIALOG:
            psz = (char *)lParam;
            Assert(psz != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)psz);
        
            SetDlgItemText(hwnd, IDC_STORE_EDIT, psz);
        
            SetFocus(GetDlgItem(hwnd, IDOK));
            fRet = FALSE;
            break;
        
        case WM_COMMAND:
            psz = (char *)GetWindowLongPtr(hwnd, DWLP_USER);
            Assert(psz != NULL);
        
            code = HIWORD(wParam);
        
            switch(LOWORD(wParam))
            {
                case IDC_CHANGE_BTN:
                    if (code == BN_CLICKED)
                    {
                        lstrcpy(szDir, psz);
                        if (DoStoreFolderDlg(hwnd, szDir, ARRAYSIZE(szDir)))
                            SetDlgItemText(hwnd, IDC_STORE_EDIT, szDir);
                    }
                    break;
            
                case IDOK:
                    GetDlgItemText(hwnd, IDC_STORE_EDIT, szDir, ARRAYSIZE(szDir));
                    // BUGBUG: Not foolproof...
                    if (0 != lstrcmpi(szDir, psz))
                    {
                        int cch, cchOrig, iRet;
                        BOOL fFound = FALSE;
                        HANDLE hFile;
                        WIN32_FIND_DATA fd;
                        DWORD dwMove = 1;
                
                        // Are there already ods files in the directory?
                        cchOrig = cch = lstrlen(szDir);
                        if (*CharPrev(szDir, szDir+cch) != _T('\\'))
                            szDir[cch++] = _T('\\');
                        lstrcpy(&szDir[cch], _T("*.dbx"));
                
                        hFile = FindFirstFile(szDir, &fd);
                        if (hFile != INVALID_HANDLE_VALUE)
                        {
                            do
                            {
                                // Look for a non directory match
                                if (!(FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes))
                                    fFound = TRUE;
                            }
                            while (!fFound && FindNextFile(hFile, &fd));
                    
                            FindClose(hFile);
                        }
                
                        // If we found some store files...
                        if (fFound)
                        {
                            // Ask them what they want
                            iRet = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMoveStoreFoundODS), NULL, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
                    
                            if (IDCANCEL == iRet)
                                // Bail early
                                break;
                            else if (IDYES == iRet)
                                // They want us to just change the store root
                                dwMove = 0;
                        }
                
                        // Restore dest directory name
                        szDir[cchOrig] = 0;
                
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsConfirmChangeStoreLocation), NULL, MB_OK | MB_ICONINFORMATION);
                
                        lRet = AthUserSetValue(NULL, c_szNewStoreDir, REG_SZ, (LPBYTE)szDir, lstrlen(szDir) + 1);
                        if (ERROR_SUCCESS == lRet)
                        {
                            lRet = AthUserSetValue(NULL, c_szMoveStore, REG_DWORD, (LPBYTE)&dwMove, sizeof(dwMove));
                            if (ERROR_SUCCESS != lRet)
                            {
                                AthUserDeleteValue(NULL, c_szNewStoreDir);
                            }
                        }
                
                        if (ERROR_SUCCESS != lRet)
                            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsStoreMoveRegWriteFail), NULL, MB_OK | MB_ICONSTOP);
                    }
            
                    // Purposefully fall through
                    //break;
            
                case IDCANCEL:
                    EndDialog(hwnd, code);
                    break;
            
                default:
                    // We couldn't handle this
                    fRet = TRUE;
                    break;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    return(fRet);
}

void DoStoreLocationDlg(HWND hwnd)
{
    char szTemp[MAX_PATH];
    char szDir[MAX_PATH];

    if (SUCCEEDED(GetStoreRootDirectory(szTemp, ARRAYSIZE(szTemp))))
    {
        // Strip out any relative path crap
        PathCanonicalize(szDir, szTemp);
        
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddStoreLocation), hwnd, StoreLocationDlgProc, (LPARAM)szDir);
    }
}

BOOL DoStoreFolderDlg(HWND hwnd, TCHAR *szDir, DWORD cch)
{
    return BrowseForFolder(g_hLocRes, hwnd, szDir, cch, IDS_BROWSE_FOLDER, TRUE);
}

HRESULT GetDefaultStoreRoot(HWND hwnd, TCHAR *pszDir, int cch)
{
    HRESULT hr;
    LPSTR   psz;
    BOOL    fIllegalCharExists = FALSE;
    
    Assert(pszDir != NULL);
    Assert(cch >= MAX_PATH);
    
    IF_FAILEXIT(hr = MU_GetCurrentUserDirectoryRoot(pszDir, cch));
    
    psz = pszDir;

    // Look for any ???. That would mean there was a bad conversion to ANSI.
    while (*psz)
    {
        // If we are a lead byte, then can't possibly be a ?
        if (IsDBCSLeadByte(*psz))
        {
            psz++;
        }
        else
        {
            if ('?' == *psz)
            {
                fIllegalCharExists = TRUE;
                break;
            }
        }
        psz++;
    }
    
    // If we had a bad conversion, then we need to prompt the user for a new path
    if (fIllegalCharExists)
    {
        if (!BrowseForFolder(g_hLocRes, hwnd, pszDir, cch, IDS_BROWSE_FOLDER, TRUE))
            hr = E_FAIL;
    }
    
exit:
    return(hr);
}

// checks for existence of directory, if it doesn't exist
// it is created
HRESULT OpenDirectory(TCHAR *szDir)
{
    TCHAR *sz, ch;
    HRESULT hr;
    
    Assert(szDir != NULL);
    hr = S_OK;
    
    if (!PathIsRoot(szDir) && !CreateDirectory(szDir, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
    {
        Assert(szDir[1] == _T(':'));
        Assert(szDir[2] == _T('\\'));
        
        sz = &szDir[3];
        
        while (TRUE)
        {
            while (*sz != 0)
            {
                if (!IsDBCSLeadByte(*sz))
                {
                    if (*sz == _T('\\'))
                        break;
                }
                sz = CharNext(sz);
            }
            ch = *sz;
            *sz = 0;
            if (!CreateDirectory(szDir, NULL))
            {
                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    hr = HrFromLastError();
                    *sz = ch;
                    break;
                }
            }
            *sz = ch;
            if (*sz == 0)
                break;
            sz++;
        }
    }
    
    return(hr);
}

HRESULT HrFromLastError()
{
    HRESULT hr;
    
    switch (GetLastError())
    {
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
            hr = hrMemory;
            break;
        
        case ERROR_DISK_FULL:
            hr = hrDiskFull;
            break;
        
        default:
            hr = E_FAIL;
            break;
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\strtokex.c ===
/***
*strtokex.c - tokenize a string with given delimiters
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines strtok() - breaks string into series of token
*       via repeated calls.
*
*******************************************************************************/
#if defined(unix)
#define __cdecl
#endif
#include <windows.h>
#include <string.h>
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char * __cdecl StrTokEx (char ** pstring, const char * control)
{
    unsigned char *psz;
    const unsigned char *pszCtrl = (const unsigned char *)control;
    unsigned char map[32] = {0};
    
    LPSTR pszToken;
    
    if(*pstring == NULL)
        return NULL;
    
    /* Set bits in delimiter table */
    do
    {
        map[*pszCtrl >> 3] |= (1 << (*pszCtrl & 7));
    } 
    while (*pszCtrl++);
    
    /* Initialize str. */
    psz = (unsigned char*)*pstring;
    
    /* Find beginning of token (skip over leading delimiters). Note that
    * there is no token if this loop sets str to point to the terminal
    * null (*str == '\0') */
    while ((map[*psz >> 3] & (1 << (*psz & 7))) && *psz)
        psz++;
    
    pszToken = (LPSTR)psz;
    
    /* Find the end of the token. If it is not the end of the string,
    * put a null there. */
    for (; *psz ; psz++)
    {
        if (map[*psz >> 3] & (1 << (*psz & 7))) 
        {
            *psz++ = '\0';
            break;
        }
    }
    
    /* string now points to beginning of next token */
    *pstring = (LPSTR)psz;
    
    /* Determine if a token has been found. */
    if (pszToken == (LPSTR)psz)
        return NULL;
    else
        return pszToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\subscr.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     GrpDlg.cpp
//
//  PURPOSE:    Implements the CGroupListDlg class.
//

#include "pch.hxx"
#include <iert.h>
#include <instance.h>
#include "subscr.h"
#include "resource.h"
#include "strconst.h"
#include "thormsgs.h"
#include "goptions.h"
#include "mailnews.h"
#include "shlwapip.h" 
#include "imnact.h"
#include "error.h"
#include "acctutil.h"
#include <ras.h>
#include "imagelst.h"
#include "conman.h"
#include "xpcomm.h"
#include <storutil.h>
#include "demand.h"
#include "menures.h"
#include "storecb.h"


UINT g_rgCtlMap[] = { idcFindText, idcUseDesc, idcGroupList, idcSubscribe,
                      idcUnsubscribe, idcResetList, idcGoto, IDOK, IDCANCEL, idcServers, idcStaticNewsServers,
                      idcStaticHorzLine, idcTabs};

const static HELPMAP g_rgCtxMapGrpDlg[] = {
                        {idcFindText, IDH_NEWS_SEARCH_GROUPS_CONTAINING},
                        {idcDispText, IDH_NEWS_SEARCH_GROUPS_CONTAINING},
                        {idcUseDesc, IDH_NEWS_SEARCH_GROUPS_DESC},
                        {idcGroupList, IDH_NEWS_GROUP_LISTS},
                        {idcSubscribe, IDH_NEWS_ADD_SELECTED_GROUP},
                        {idcUnsubscribe, IDH_NEWS_REMOVE_SELECTED_GROUP},
                        {idcResetList, IDH_NEWS_RESET_NEW_LIST},
                        {idcGoto, IDH_NEWS_OPEN_SELECTED_GROUP},
                        {idcServers, IDH_NEWS_SERVER_LIST},
                        {idcStaticNewsServers, IDH_NEWS_SERVER_LIST},
                        {idcTabs,   IDH_NEWSGROUP_LIST_ALL},
                        {0, 0}
};

const static HELPMAP g_rgCtxMapGrpDlgIMAP[] = {
                        {idcFindText, 50505},
                        {idcDispText, 50505},
                        {idcGroupList, 50510},
                        {idcSubscribe, 50520},
                        {idcUnsubscribe, 50525},
                        {idcResetList, 50530},
                        {idcGoto, 50515},
                        {idcServers, 50500},
                        {idcStaticNewsServers, 50500},
                        {0, 0}
};

HRESULT DoSubscriptionDialog(HWND hwnd, BOOL fNews, FOLDERID idFolder, BOOL fShowNew)
{
    CGroupListDlg *pDlg;
    FOLDERID id, idDefault;
    FOLDERINFO info;
    HRESULT hr;
    FOLDERTYPE type;

#ifdef DEBUG
    if (fShowNew)
        Assert(fNews);
#endif // DEBUG

    type = fNews ? FOLDER_NEWS : FOLDER_IMAP;

    pDlg = new CGroupListDlg;
    if (pDlg == NULL)
        return(E_OUTOFMEMORY);

    if (idFolder == FOLDERID_ROOT)
    {
        idFolder = FOLDERID_INVALID;
    }
    else if (idFolder != FOLDERID_INVALID)
    {
        hr = GetFolderStoreInfo(idFolder, &info);
        if (SUCCEEDED(hr))
        {
            if (type == info.tyFolder)
                idFolder = info.idFolder;
            else
                idFolder = FOLDERID_INVALID;
            
            g_pStore->FreeRecord(&info);
        }
        else
        {
            idFolder = FOLDERID_INVALID;
        }
    }

    if (idFolder == FOLDERID_INVALID)
    {
        hr = GetDefaultServerId(fNews ? ACCT_NEWS : ACCT_MAIL, &idDefault);
        if (SUCCEEDED(hr))
        {
            hr = g_pStore->GetFolderInfo(idDefault, &info);
            if (SUCCEEDED(hr))
            {
                if (type == info.tyFolder)
                    idFolder = idDefault;

                g_pStore->FreeRecord(&info);
            }
        }

        if (FAILED(hr))
        {
            pDlg->Release();
            return(hr);
        }
    }

    if (pDlg->FCreate(hwnd, type, &id, fShowNew ? 2 : 0, TRUE, idFolder))
    {
        if (id != FOLDERID_INVALID)
            g_pInstance->BrowseToObject(SW_SHOWNORMAL, id);
    }
    
    pDlg->Release();

    return(S_OK);
}

CGroupListDlg::CGroupListDlg()
    {
    m_cRef = 1;

    // m_hwnd
    // m_hwndFindText
    // m_hwndOwner
    
    m_fAllowDesc = TRUE;
    m_pszPrevQuery = 0;
    m_cchPrevQuery = 0;
    
    m_cxHorzSep = 0;
    m_cyVertSep = 0;
    m_rgst = 0;
    m_sizeDlg.cx = 0;
    m_sizeDlg.cy = 0;
    m_ptDragMin.x = 0;
    m_ptDragMin.y = 0;

    m_himlServer = NULL;
    m_pGrpList = NULL;
    // m_type
    // m_iTabSelect
    // m_idSel
    m_idGoto = FOLDERID_INVALID;
    // m_fEnableGoto
    m_fServerListInited = FALSE;
    m_idCurrent = FOLDERID_INVALID;
    m_hIcon = NULL;

    m_pColumns = NULL;
    }

CGroupListDlg::~CGroupListDlg()
    {
    SafeMemFree(m_pszPrevQuery);
    SafeMemFree(m_rgst);

    if (m_pColumns != NULL)
        m_pColumns->Release();

    if (m_pGrpList != NULL)
        m_pGrpList->Release();

    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));

    if (m_himlServer != NULL)
        ImageList_Destroy(m_himlServer);
    }

HRESULT STDMETHODCALLTYPE CGroupListDlg::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IGroupListAdvise *)this;
    else if (IsEqualIID(riid, IID_IGroupListAdvise))
        *ppvObj = (void*) (IGroupListAdvise *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGroupListDlg::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGroupListDlg::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//  FUNCTION:   CGroupListDlg::FCreate()
//
//  PURPOSE:    Handles initialization of the data and creation of the  
//              Newsgroups dialog.  
//
BOOL CGroupListDlg::FCreate(HWND hwndOwner, FOLDERTYPE type, FOLDERID *pGotoId,
                UINT iTabSelect, BOOL fEnableGoto, FOLDERID idSel)
    {
    MSG msg;      
    HWND hwndDlg;
    UINT idd;
    HRESULT hr;

    Assert(pGotoId != NULL);

    m_hwndOwner = hwndOwner;

    Assert(type == FOLDER_IMAP || type == FOLDER_NEWS);
    m_type = type;

    m_iTabSelect = iTabSelect;    
    m_fEnableGoto = fEnableGoto;
    m_idSel = idSel;
    
    m_pGrpList = new CGroupList;
    if (m_pGrpList == NULL)
        return(FALSE);

    idd = type == FOLDER_NEWS ? iddSubscribe : iddSubscribeImap;
    
    if (GetParent(m_hwndOwner))
        {
        while (GetParent(m_hwndOwner))
            m_hwndOwner = GetParent(m_hwndOwner);
        }
    
    // Fake this modeless dialog into behaving like a modal dialog
    EnableWindow(m_hwndOwner, FALSE);
    hwndDlg = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(idd), hwndOwner, 
                                GroupListDlgProc, (LPARAM) this);
    ShowWindow(hwndDlg, SW_SHOW);

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if (IsGrpDialogMessage(msg.hwnd, &msg))
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
    
    if (IsWindow(m_hwnd))
        {
        // GetMessage returned FALSE (WM_QUIT), but we still exist.  This 
        // means someone else posted the WM_QUIT, so we should close and 
        // put the WM_QUIT back in the queue
        SendMessage(m_hwnd, WM_COMMAND, IDCANCEL, 0L);
        PostQuitMessage((int)(msg.wParam));  // repost quit for next enclosing loop
        }        
    EnableWindow(m_hwndOwner, TRUE);
    
    *pGotoId = m_idGoto;
    
    return(TRUE);
    }

//
//  FUNCTION:   CGroupListDlg::IsGrpDialogMessage()
//
//  PURPOSE:    Because there are people who think that because we have a tab
//              control on this dialog it should behave like a property sheet,
//              we need to fake the dialog modeless and filter our own 
//              keystrokes.  I've stolen this function from the comctl32 sources
//              so if we get any bugs saying the behavior isn't the same the 
//              person is full of it.
//
//  PARAMETERS:
//      hwnd - Handle of the window to check the messages for.
//      pMsg - Message to check.
//
//  RETURN VALUE:
//      Returns TRUE if the message was dispatched, FALSE otherwise.
//
BOOL CGroupListDlg::IsGrpDialogMessage(HWND hwnd, LPMSG pMsg)
    {
    if ((pMsg->message == WM_KEYDOWN) && (GetAsyncKeyState(VK_CONTROL) < 0))
        {
        BOOL bBack = FALSE;

        switch (pMsg->wParam) 
            {
            case VK_TAB:
                bBack = GetAsyncKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                bBack = (pMsg->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
            }

        int iCur = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, idcTabs));

        // tab in reverse if shift is down
        if (bBack)
            iCur += (iTabMax - 1);
        else
            iCur++;

        iCur %= iTabMax;
        TabCtrl_SetCurSel(GetDlgItem(m_hwnd, idcTabs), iCur);
        OnSwitchTabs(hwnd, iCur);
        return TRUE;
        }

NoKeys:
    if (IsWindow(m_hwnd) && IsDialogMessage(m_hwnd, pMsg))
        return TRUE;
    
    return (FALSE);
    }    


INT_PTR CALLBACK CGroupListDlg::GroupListDlgProc(HWND hwnd, UINT uMsg,
                                              WPARAM wParam, LPARAM lParam)
    {
    CGroupListDlg* pThis = 0;
    pThis = (CGroupListDlg*) GetWindowLongPtr(hwnd, DWLP_USER);
    LRESULT lResult;

    // Bug #16910 - For some reason we get messages before we set the this
    //              pointer into the window extra bytes.  If this happens
    //              we should blow the message off.
    if (uMsg != WM_INITDIALOG && 0 == pThis)
        {
        return (FALSE);
        }

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stash the this pointer so we can use it for all the messages.
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CGroupListDlg*) lParam;
            
            return (BOOL)HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, 
                                              pThis->OnInitDialog);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, (pThis->m_type == FOLDER_IMAP) ? g_rgCtxMapGrpDlgIMAP : g_rgCtxMapGrpDlg);
        
        case WM_COMMAND:
            Assert(pThis);
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, pThis->OnCommand);
            return (TRUE);

        case WM_NOTIFY:
            Assert(pThis);
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, pThis->OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_TIMER:
            Assert(pThis);
            HANDLE_WM_TIMER(hwnd, wParam, lParam, pThis->OnTimer);
            return (TRUE);
            
        case WM_PAINT:
            Assert(pThis);
            HANDLE_WM_PAINT(hwnd, wParam, lParam, pThis->OnPaint);
            return (FALSE);
            
        case WM_SIZE:
            Assert(pThis);
            HANDLE_WM_SIZE(hwnd, wParam, lParam, pThis->OnSize);
            return (TRUE);
            
        case WM_GETMINMAXINFO:
            Assert(pThis);
            HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, pThis->OnGetMinMaxInfo);
            break;
            
        case WM_CLOSE:
            Assert(pThis);
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, pThis->OnClose);
            return (TRUE);
            
        case WM_DESTROY:
            Assert(pThis);
            HANDLE_WM_DESTROY(hwnd, wParam, lParam, pThis->OnDestroy);
            return (TRUE);
            
        case WM_NCHITTEST:
            {
            POINT pt = { LOWORD(lParam), HIWORD(lParam) };
            RECT  rc;
            GetWindowRect(hwnd, &rc);
            rc.left = rc.right - GetSystemMetrics(SM_CXSMICON);
            rc.top = rc.bottom - GetSystemMetrics(SM_CYSMICON);
            if (PtInRect(&rc, pt))
                {
                SetDlgMsgResult(hwnd, WM_NCHITTEST, HTBOTTOMRIGHT);
                return (TRUE);
                }
            else
                return (FALSE);    
            }            
            
        case NVM_CHANGESERVERS:
            pThis->OnChangeServers(hwnd);
            return (TRUE);
        }

    return (FALSE);
    }

static const UINT c_rgNewsSubTab[] =
{
    idsTabAll, idsTabSubscribed, idsTabNew
};

static const UINT c_rgImapSubTab[] =
{
    idsTabAll, idsTabVisible
};

BOOL CGroupListDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
    HRESULT hr;
    HWND hwndT, hwndList;
    WINDOWPLACEMENT wp;
    TC_ITEM tci;
    RECT rcDlg;
    UINT i, cTab, *pTab;
    char sz[CCHMAX_STRINGRES];
    COLUMN_SET_TYPE set;
    
    // It's handy to have these handles available
    m_hwnd = hwnd;
    m_hwndFindText = GetDlgItem(hwnd, idcFindText);
    SetIntlFont(m_hwndFindText);

    // Add some tabs to our tab control.
    hwndT = GetDlgItem(hwnd, idcTabs);
    Assert(IsWindow(hwndT));

    if (m_type == FOLDER_NEWS)
    {
        set = COLUMN_SET_NEWS_SUB;

        pTab = (UINT *)c_rgNewsSubTab;
        cTab = ARRAYSIZE(c_rgNewsSubTab);
    }
    else
    {
        set = COLUMN_SET_IMAP_SUB;

        pTab = (UINT *)c_rgImapSubTab;
        cTab = ARRAYSIZE(c_rgImapSubTab);
    }
    
    tci.mask = TCIF_TEXT;
    tci.pszText = sz;
    for (i = 0; i < cTab; i++)
    {
        AthLoadString(*pTab, sz, ARRAYSIZE(sz));
        TabCtrl_InsertItem(hwndT, i, &tci);
        
        pTab++;
    }
    
    hwndList = GetDlgItem(hwnd, idcGroupList);

    m_pColumns = new CColumns;
    if (m_pColumns == NULL)
        {
        EnableWindow(m_hwndOwner, TRUE);    
        DestroyWindow(m_hwnd);
        return (FALSE);
        }

    m_pColumns->Initialize(hwndList, set);
    m_pColumns->ApplyColumns(COLUMN_LOAD_REGISTRY, 0, 0);

    // Initialize the extended styles so we get full row select.  Just because
    // it looks better.
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    Assert(m_pGrpList != NULL);
    hr = m_pGrpList->Initialize((IGroupListAdvise *)this, m_pColumns, hwndList, m_type);
    Assert(SUCCEEDED(hr));

    // Add the list of servers to the list view if and only if there is more
    // than one server.
    hwndT = GetDlgItem(hwnd, idcServers);

    FillServerList(hwndT, m_idSel);
        
    // Build the control map array.
    if (!MemAlloc((LPVOID*) &m_rgst, sizeof(SIZETABLE) * iCtlMax))
        {
        EnableWindow(m_hwndOwner, TRUE);    
        DestroyWindow(m_hwnd);
        return (FALSE);
        }
    ZeroMemory(m_rgst, sizeof(SIZETABLE) * iCtlMax);
    
    // Build a table of the controls on this dialog
    for (i = 0; i < iCtlMax; i++)
        {
        m_rgst[i].hwndCtl = GetDlgItem(hwnd, g_rgCtlMap[i]);
        if (m_rgst[i].hwndCtl)
            {
            m_rgst[i].id = g_rgCtlMap[i];
            GetWindowRect(m_rgst[i].hwndCtl, &m_rgst[i].rc);
            MapWindowPoints(GetDesktopWindow(), hwnd, (LPPOINT) &m_rgst[i].rc, 2);
            }
        }    
    
    GetWindowRect(hwnd, &rcDlg);    
    m_ptDragMin.x = rcDlg.right - rcDlg.left;
    m_ptDragMin.y = rcDlg.bottom - rcDlg.top;

    // Get the distance from the button to the edge of the dialog
    GetClientRect(hwnd, &rcDlg);
    m_cxHorzSep = rcDlg.right - m_rgst[iCtlCancel].rc.right;
    
    // Get the distance from the "OK" to the "Cancel" button
    m_cyVertSep = m_rgst[iCtlCancel].rc.left - m_rgst[iCtlOK].rc.right;

    // Position the dialog
    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetOption(OPT_NEWSDLGPOS, (LPVOID) &wp, sizeof(WINDOWPLACEMENT)))
        {
        SetWindowPlacement(hwnd, &wp);

        // Bug #19258 - If SetWindowPlacement() doesn't actually resize the dialog,
        //              then a WM_SIZE doesn't happen automatically.  We check for
        //              this now and force the message if this is the case.
        GetWindowRect(hwnd, &rcDlg);    
        if (wp.rcNormalPosition.right == rcDlg.right && 
            wp.rcNormalPosition.bottom == rcDlg.bottom)
            {
            GetClientRect(hwnd, &rcDlg);
            SendMessage(hwnd, WM_SIZE, SIZE_RESTORED, MAKELPARAM(rcDlg.right, rcDlg.bottom));
            }
        }
    else
        {
        CenterDialog(hwnd);
        SendMessage(hwnd, WM_SIZE, SIZE_RESTORED, MAKELPARAM(rcDlg.right, rcDlg.bottom));
        }

    // If the view didn't invoke this dialog, than Goto has no meaning.  Hide
    // the button if this is the case.
    if (!m_fEnableGoto)
        ShowWindow(GetDlgItem(hwnd, idcGoto), SW_HIDE);

    // Bug 23685: give it the right icon
    m_hIcon= (HICON)LoadImage(g_hLocRes, m_type == FOLDER_NEWS ? MAKEINTRESOURCE(idiNewsGroup) : MAKEINTRESOURCE(idiFolder), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)m_hIcon);
        
    // Initialize the focus
    SetFocus(m_hwndFindText);
                    
    // Tell ourself to update our group list after the dialog is done
    // initializing.
    PostMessage(hwnd, NVM_CHANGESERVERS, 0, 0L);

    return (FALSE);
    }

void CGroupListDlg::OnChangeServers(HWND hwnd)
    {
    // TODO: we need to fix the initialization so the filtering is only performed
    // once (we should call IGroupList::Filter once and then IGroupList::SetServer once
    // during creation of the dialog)

    UpdateWindow(hwnd);

    TabCtrl_SetCurSel(GetDlgItem(hwnd, idcTabs), m_iTabSelect);
    OnSwitchTabs(hwnd, m_iTabSelect);

    Assert(m_idCurrent != FOLDERID_INVALID);
    ChangeServers(m_idCurrent, TRUE);
    }

//
//  FUNCTION:   CGroupListDlg::OnCommand
//
//  PURPOSE:    Handles the command messages for the dialog.
//
//  PARAMETERS:
//      hwnd       - Handle of the dialog box.
//      id         - Command id that needs processing.
//      hwndCtl    - Handle of the control that generated the command
//      codeNotify - Specific notification the control generated
//    
void CGroupListDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    HRESULT hr;
    FOLDERID fldid;
    int iSel;
    FOLDERINFO info;
    DWORD dw;
    BOOL fDesc;
    IImnAccount *pAcct;

    switch (id)
        {
        case IDOK:
        case IDCANCEL:
            if (codeNotify != BN_CLICKED)
                break;

            hr = S_OK;
            if (id == IDOK)
            {
                hr = m_pGrpList->Commit(hwnd);
                Assert(hr != E_PENDING);
                if (FAILED(hr))
                    break;
            }

            EnableWindow(m_hwndOwner, TRUE);    
            DestroyWindow(hwnd);
            break;
            
        case idcSubscribe:
        case idcUnsubscribe:
            if (codeNotify != BN_CLICKED)
                break;
                
            hr = m_pGrpList->Exec(NULL, id == idcSubscribe ? ID_SUBSCRIBE : ID_UNSUBSCRIBE, 0, NULL, NULL);
            Assert(hr == S_OK);
            break;

        case idcGoto:
            if (codeNotify != BN_CLICKED)
                break;

            hr = m_pGrpList->GetFocused(&fldid);
            if (SUCCEEDED(hr))
            {
                m_idGoto = fldid;
                SendMessage(m_hwnd, WM_COMMAND, IDOK, 0);
            }
            break;  
            
        case idcFindText:
            // This is generated when someone types in the find text edit box.
            // We set a timer and when that timer expires we assume the user is
            // done typing and go ahead and perform the query.
            if (EN_CHANGE == codeNotify)
                {
                KillTimer(hwnd, idtFindDelay);
                SetTimer(hwnd, idtFindDelay, dtFindDelay, NULL);
                }
            break;

        case idcUseDesc:
            if (IsDlgButtonChecked(hwnd, idcUseDesc))
            {
                hr = m_pGrpList->HasDescriptions(&fDesc);
                if (SUCCEEDED(hr) && !fDesc)
                {
                    if (IDYES == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                                    MAKEINTRESOURCEW(IDS_NO_DESCRIPTIONS_DOWNLOADED), NULL,
                                    MB_YESNO | MB_ICONEXCLAMATION))
                    {
                        // turn on acct desc option
                        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idCurrent, &info)))
                        {
                            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, info.pszAccountId, &pAcct)))
                            {
                                if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_USE_DESCRIPTIONS, &dw)) && dw == 0)
                                {
                                    pAcct->SetPropDw(AP_NNTP_USE_DESCRIPTIONS, 1);
                                    pAcct->SaveChanges();
                                }

                                pAcct->Release();
                            }

                            g_pStore->FreeRecord(&info);

                            hr = m_pGrpList->Exec(NULL, ID_RESET_LIST, 0, NULL, NULL);
                        }
                    }
                    else
                    {
                        SendMessage(hwndCtl, BM_SETCHECK, BST_UNCHECKED, 0);
                        break;
                    }
                }
            }

            iSel = TabCtrl_GetCurSel(GetDlgItem(hwnd, idcTabs));
            if (iSel != -1)
                OnSwitchTabs(hwnd, iSel);
            break;
            
        case idcResetList:
            hr = m_pGrpList->Exec(NULL, ID_RESET_LIST, 0, NULL, NULL);
            break;            
        }
    }

//
//  FUNCTION:   CGroupListDlg::OnNotify
//
//  PURPOSE:    Handles notifications from the common controls on the dialog.
//
LRESULT CGroupListDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    int iSel;
    LRESULT lRes;
    HRESULT hr;
    NM_LISTVIEW *pnmlv;

    hr = m_pGrpList->HandleNotify(hwnd, idFrom, pnmhdr, &lRes);
    if (hr == S_OK)
        return(lRes);

    switch (pnmhdr->code)
    {
        case TCN_SELCHANGE:
            if (idFrom == idcTabs)
            {
                // Find out which tab is currently active
                iSel = TabCtrl_GetCurSel(pnmhdr->hwndFrom);
                if (iSel != -1)
                    OnSwitchTabs(hwnd, iSel);
            }
            break;

        case LVN_ITEMCHANGED:
            Assert(idFrom == idcServers);

            pnmlv = (NM_LISTVIEW *)pnmhdr;
            if (m_fServerListInited &&
                !!(pnmlv->uChanged & LVIF_STATE) &&
                0 == (pnmlv->uOldState & LVIS_FOCUSED) &&
                !!(pnmlv->uNewState & LVIS_FOCUSED))
            {
                ChangeServers((FOLDERID)pnmlv->lParam, FALSE);

                ItemUpdate();
            }
            break;
    }

    return (0);
}

void CGroupListDlg::OnClose(HWND hwnd)
    {
    int iReturn = IDNO;
    
    if (m_pGrpList->Dirty() == S_OK)    
        iReturn = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews), 
                                MAKEINTRESOURCEW(idsDoYouWantToSave), 0, 
                                MB_YESNOCANCEL | MB_ICONEXCLAMATION );

    if (iReturn == IDYES)
        OnCommand(hwnd, IDOK, 0, 0);
    else if (iReturn == IDNO)
        OnCommand(hwnd, IDCANCEL, 0, 0);          
    }

void CGroupListDlg::OnDestroy(HWND hwnd)
    {
    // Save the dialog position
    WINDOWPLACEMENT wp;

    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetWindowPlacement(hwnd, &wp))
        SetOption(OPT_NEWSDLGPOS, (LPVOID) &wp, sizeof(WINDOWPLACEMENT), NULL, 0);

    Assert(m_pColumns != NULL);
    m_pColumns->Save(NULL, NULL);

    PostQuitMessage(0);    
    }

void CGroupListDlg::OnTimer(HWND hwnd, UINT id)
    {
    DWORD iTab;

    KillTimer(hwnd, id);

    iTab = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, idcTabs));

    OnSwitchTabs(hwnd, iTab);
    }

BOOL CGroupListDlg::ChangeServers(FOLDERID id, BOOL fForce)
    {
    HRESULT hr;

    hr = m_pGrpList->SetServer(id);
    Assert(SUCCEEDED(hr));

    m_idCurrent = id;

    ItemUpdate();
    
    return(TRUE);
    }                          

//
//  FUNCTION:   CGroupListDlg::FillServerList
//
//  PURPOSE:    If the user has multiple servers configured, then a variant of
//              this dialog appears that has a list of servers available.  This
//              function populates that list.
//
//  PARAMETERS:
//      hwndList - Handle of the list view that we add server names to.
//      pszSelectServer - Name of the server to select in the list view.
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//    
BOOL CGroupListDlg::FillServerList(HWND hwndList, FOLDERID idSel)
    {
    HRESULT     hr;
    FOLDERID    id;
    char        szServer[CCHMAX_ACCOUNT_NAME];
    LV_ITEM     lvi;
    LV_COLUMN   lvc;
    RECT        rc;
    DWORD       dw;
    int         iItem, iSelect;
    IImnAccount   *pAcct;
    IImnEnumAccounts *pEnum;
        
    Assert(!m_fServerListInited);
    Assert(hwndList != NULL);
    Assert(IsWindow(hwndList));
    
    SetIntlFont(hwndList);

    // Create the image list and add it to the listview.
    Assert(m_himlServer == NULL);
    m_himlServer = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
    if (m_himlServer == NULL)
        return(FALSE);
    ListView_SetImageList(hwndList, m_himlServer, LVSIL_NORMAL);       

    // Add a column to the listview.
    GetClientRect(hwndList, &rc);
    lvc.mask     = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx       = rc.right;
    dw = ListView_InsertColumn(hwndList, 0, &lvc);     

    iSelect = -1;
    iItem = 0;

    if (SUCCEEDED(g_pAcctMan->Enumerate(m_type == FOLDER_NEWS ? SRV_NNTP : SRV_IMAP, &pEnum)))
    {
        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lvi.iImage = m_type == FOLDER_NEWS ? iNewsServer : iMailServer;

        while (E_EnumFinished != pEnum->GetNext(&pAcct))
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szServer, ARRAYSIZE(szServer))) &&
                SUCCEEDED(g_pStore->FindServerId(szServer, &id)) &&
                SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_NAME, szServer, ARRAYSIZE(szServer))))
            {
                if (idSel == FOLDERID_INVALID ||
                    id == idSel)
                {
                    Assert(iSelect == -1);
                    idSel = id;
                    iSelect = iItem;

                    lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                }
                else
                {
                    lvi.state = 0;
                    lvi.stateMask = 0;
                }

                lvi.pszText = szServer;
                lvi.iItem = iItem;
                lvi.lParam = (LPARAM)id;
 
                dw = ListView_InsertItem(hwndList, &lvi);
                iItem++;
            }

            pAcct->Release();
            }
    
        pEnum->Release();
        }

    Assert(iItem > 0);
    Assert(iSelect != -1);
    Assert(idSel != FOLDERID_INVALID);

    ListView_EnsureVisible(hwndList, iSelect, FALSE);

    m_idCurrent = idSel;
    m_fServerListInited = TRUE;

    return (TRUE);    
    }

HRESULT CGroupListDlg::ItemUpdate(void)
{
    FOLDERID id;
    HRESULT hr;
    HWND hwndSub, hwndUnsub, hwndFocus;
    OLECMD rgCmds[2] = { { ID_SUBSCRIBE, 0 }, { ID_UNSUBSCRIBE, 0 } };

    hr = m_pGrpList->GetFocused(&id);
    EnableWindow(GetDlgItem(m_hwnd, idcGoto), hr == S_OK);

    hr = m_pGrpList->QueryStatus(NULL, ARRAYSIZE(rgCmds), rgCmds, NULL);
    if (SUCCEEDED(hr))
    {
        hwndFocus = GetFocus();

        hwndSub = GetDlgItem(m_hwnd, idcSubscribe);
        hwndUnsub = GetDlgItem(m_hwnd, idcUnsubscribe);
        
        EnableWindow(hwndSub, !!(rgCmds[0].cmdf & OLECMDF_ENABLED));
        EnableWindow(hwndUnsub, !!(rgCmds[1].cmdf & OLECMDF_ENABLED));

        if (!IsWindowEnabled(hwndFocus))
            SetFocus(!!(rgCmds[0].cmdf & OLECMDF_ENABLED) ? hwndSub : hwndUnsub);
    }

    return(S_OK);
}

HRESULT CGroupListDlg::ItemActivate(FOLDERID id)
{
    m_pGrpList->Exec(NULL, ID_TOGGLE_SUBSCRIBE, 0, NULL, NULL);

    return(S_OK);
}

//
//  FUNCTION:   CGroupListDlg::OnSwitchTabs()
//
//  PURPOSE:    This function takes care of resetting the list of groups 
//              appropriately when the user selects a different tab.
//
//  PARAMETERS:
//      hwnd - Handle of the dialog window.
//      iTab - Index of the tab to switch to.
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//
BOOL CGroupListDlg::OnSwitchTabs(HWND hwnd, UINT iTab)
    {
    UINT cch;
    LPSTR pszText;
    HRESULT hr;
    BOOL fUseDesc;

    pszText = NULL;

    cch = GetWindowTextLength(m_hwndFindText);
    if (cch > 0)
        {
        cch++;
        if (!MemAlloc((void **)&pszText, cch + 1))
            return(FALSE);

        GetWindowText(m_hwndFindText, pszText, cch);
        }

    fUseDesc = (m_type == FOLDER_NEWS && IsDlgButtonChecked(m_hwnd, idcUseDesc));

    hr = m_pGrpList->Filter(pszText, iTab, fUseDesc);
    Assert(SUCCEEDED(hr));

    if (pszText != NULL)
        MemFree(pszText);

    return(TRUE);    
    }

#define WIDTH(_rect) (_rect.right - _rect.left)
#define HEIGHT(_rect) (_rect.bottom - _rect.top)
    
void CGroupListDlg::OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
    RECT rc;

    rc.left = m_sizeDlg.cx - GetSystemMetrics(SM_CXSMICON);
    rc.top = m_sizeDlg.cy - GetSystemMetrics(SM_CYSMICON);
    rc.right = m_sizeDlg.cx;
    rc.bottom = m_sizeDlg.cy;
    InvalidateRect(hwnd, &rc, FALSE);

    m_sizeDlg.cx = cx;
    m_sizeDlg.cy = cy;

    // First move the outside buttons so they are against the edge.  These
    // buttons only move horizontally.
    m_rgst[iCtlSubscribe].rc.left = cx - m_cxHorzSep - WIDTH(m_rgst[iCtlSubscribe].rc);
    m_rgst[iCtlSubscribe].rc.right = cx - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlSubscribe].hwndCtl, 0, m_rgst[iCtlSubscribe].rc.left, 
                 m_rgst[iCtlSubscribe].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    m_rgst[iCtlUnsubscribe].rc.left = cx - m_cxHorzSep - WIDTH(m_rgst[iCtlUnsubscribe].rc);
    m_rgst[iCtlUnsubscribe].rc.right = cx - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlUnsubscribe].hwndCtl, 0, m_rgst[iCtlUnsubscribe].rc.left, 
                 m_rgst[iCtlUnsubscribe].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    m_rgst[iCtlResetList].rc.left = cx - m_cxHorzSep - WIDTH(m_rgst[iCtlResetList].rc);
    m_rgst[iCtlResetList].rc.right = cx - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlResetList].hwndCtl, 0, m_rgst[iCtlResetList].rc.left, 
                 m_rgst[iCtlResetList].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

            
    // The Goto, OK, and Cancel buttons move both horizontally and vertically.                 
    m_rgst[iCtlCancel].rc.left = cx - m_cxHorzSep - WIDTH(m_rgst[iCtlCancel].rc);
    m_rgst[iCtlCancel].rc.right = cx - m_cxHorzSep;
    m_rgst[iCtlCancel].rc.top = cy - m_cxHorzSep - HEIGHT(m_rgst[iCtlCancel].rc);
    m_rgst[iCtlCancel].rc.bottom = cy - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlCancel].hwndCtl, 0, m_rgst[iCtlCancel].rc.left, 
                 m_rgst[iCtlCancel].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    m_rgst[iCtlOK].rc.left = m_rgst[iCtlCancel].rc.left - m_cxHorzSep - WIDTH(m_rgst[iCtlCancel].rc);
    m_rgst[iCtlOK].rc.right = m_rgst[iCtlCancel].rc.left - m_cxHorzSep;
    m_rgst[iCtlOK].rc.top = cy - m_cxHorzSep - HEIGHT(m_rgst[iCtlOK].rc);
    m_rgst[iCtlOK].rc.bottom = cy - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlOK].hwndCtl, 0, m_rgst[iCtlOK].rc.left, 
                 m_rgst[iCtlOK].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
                 
    m_rgst[iCtlGoto].rc.left = m_rgst[iCtlOK].rc.left - m_cxHorzSep - WIDTH(m_rgst[iCtlGoto].rc);
    m_rgst[iCtlGoto].rc.right = m_rgst[iCtlOK].rc.left - m_cxHorzSep;
    m_rgst[iCtlGoto].rc.top = cy - m_cxHorzSep - HEIGHT(m_rgst[iCtlGoto].rc);
    m_rgst[iCtlGoto].rc.bottom = cy - m_cxHorzSep;
    SetWindowPos(m_rgst[iCtlGoto].hwndCtl, 0, m_rgst[iCtlGoto].rc.left, 
                 m_rgst[iCtlGoto].rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Update the horizontal static line
    m_rgst[iCtlStaticHorzLine].rc.left = m_cxHorzSep;
    m_rgst[iCtlStaticHorzLine].rc.right = cx - m_cxHorzSep;
    m_rgst[iCtlStaticHorzLine].rc.top = m_rgst[iCtlCancel].rc.top - m_cyVertSep - HEIGHT(m_rgst[iCtlStaticHorzLine].rc);
    m_rgst[iCtlStaticHorzLine].rc.bottom = m_rgst[iCtlCancel].rc.top - m_cyVertSep;
    SetWindowPos(m_rgst[iCtlStaticHorzLine].hwndCtl, 0, m_rgst[iCtlStaticHorzLine].rc.left, 
                 m_rgst[iCtlStaticHorzLine].rc.top, WIDTH(m_rgst[iCtlStaticHorzLine].rc), 
                 HEIGHT(m_rgst[iCtlStaticHorzLine].rc), SWP_NOZORDER | SWP_NOACTIVATE);

    // If we have a server well, then update that and the vertical static line
    if (m_rgst[iCtlServers].hwndCtl)
        {
        m_rgst[iCtlServers].rc.bottom = m_rgst[iCtlStaticHorzLine].rc.top - m_cyVertSep;
        SetWindowPos(m_rgst[iCtlServers].hwndCtl, 0, 0, 0, WIDTH(m_rgst[iCtlServers].rc), 
                     HEIGHT(m_rgst[iCtlServers].rc), SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

    // Finally update the tab control and listview
    m_rgst[iCtlTabs].rc.right = m_rgst[iCtlSubscribe].rc.left - m_cxHorzSep;
    m_rgst[iCtlTabs].rc.bottom = m_rgst[iCtlStaticHorzLine].rc.top - m_cyVertSep;
    SetWindowPos(m_rgst[iCtlTabs].hwndCtl, 0, 0, 0, WIDTH(m_rgst[iCtlTabs].rc), 
                 HEIGHT(m_rgst[iCtlTabs].rc), SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    rc = m_rgst[iCtlTabs].rc;
    TabCtrl_AdjustRect(m_rgst[iCtlTabs].hwndCtl, FALSE, &rc);
    m_rgst[iCtlGroupList].rc.right = rc.right - (m_rgst[iCtlGroupList].rc.left - rc.left);
    m_rgst[iCtlGroupList].rc.bottom = rc.bottom - m_cyVertSep; //(m_rgst[iCtlGroupList].rc.top - rc.top);
    SetWindowPos(m_rgst[iCtlGroupList].hwndCtl, 0, 0, 0, WIDTH(m_rgst[iCtlGroupList].rc), 
                 HEIGHT(m_rgst[iCtlGroupList].rc), SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    

    rc.top = m_rgst[iCtlGroupList].rc.top;
    rc.left = m_rgst[iCtlServers].rc.left;
    rc.bottom = cy;
    rc.right = cx;
    InvalidateRect(hwnd, &rc, TRUE);
    }

void CGroupListDlg::OnPaint(HWND hwnd)
    {
    PAINTSTRUCT ps;
    RECT rc;

    GetClientRect(hwnd, &rc);
    rc.left = rc.right - GetSystemMetrics(SM_CXSMICON);
    rc.top = rc.bottom - GetSystemMetrics(SM_CYSMICON);
    BeginPaint(hwnd, &ps);

    if (!IsZoomed(hwnd))
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);

    EndPaint(hwnd, &ps);
    }
    
void CGroupListDlg::OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi)
    {
    DefWindowProc(hwnd, WM_GETMINMAXINFO, 0, (LPARAM) lpmmi);
    lpmmi->ptMinTrackSize = m_ptDragMin;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statwiz.h ===
#ifndef __STATWIZ_H
#define __STATWIZ_H

#define NUM_WIZARD_PAGES 5
#define COLOR_SIZE       8

class CStatWiz;
typedef BOOL (CALLBACK* INITPROC)(CStatWiz *,HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(CStatWiz *,HWND,UINT,UINT *,BOOL *);
typedef BOOL (CALLBACK* CMDPROC)(CStatWiz *,HWND,WPARAM,LPARAM);

typedef struct tagPAGEINFO
{
    UINT        uDlgID;
    UINT        uHdrID; // string id for title
    UINT        uSubHdrID; // string id for subheader (set to 0 if no subhdr)
    // handler procedures for each page-- any of these can be
    // NULL in which case the default behavior is used
    INITPROC    InitProc;
    OKPROC      OKProc;
    CMDPROC     CmdProc;    
    
} PAGEINFO;

typedef struct tagINITWIZINFO
{
    const PAGEINFO      *pPageInfo;
    CStatWiz            *pApp;
} INITWIZINFO;

class CStatWiz
{
private:
    ULONG               m_cRef;
    
public:
                    CStatWiz();
                    ~CStatWiz();
    ULONG           AddRef(VOID);
    ULONG           Release(VOID);

    HRESULT         DoWizard(HWND hwnd);

    INT             m_iCurrentPage;
    UINT            m_cPagesCompleted;
    UINT            m_rgHistory[NUM_WIZARD_PAGES];

    WCHAR           m_wszHtmlFileName[MAX_PATH];
    WCHAR           m_wszBkPictureFileName[MAX_PATH];
    WCHAR           m_wszBkColor[COLOR_SIZE];                    
    WCHAR           m_wszFontFace[LF_FACESIZE];
    WCHAR           m_wszFontColor[COLOR_SIZE];

    INT             m_iFontSize;
    BOOL            m_fBold;
    BOOL            m_fItalic;
                    
    INT             m_iLeftMargin;
    INT             m_iTopMargin;
    INT             m_iVertPos;  // this will be coded by 
    INT             m_iHorzPos;
    INT             m_iTile;

    HFONT           m_hBigBoldFont;
};

typedef CStatWiz *LPSTATWIZ;

#define IDC_STATIC                               -1
#define IDC_STATWIZ_BIGBOLDTITLE                 10

#define IDC_STATWIZ_EDITNAME                     1000
#define IDC_STATWIZ_EDITFILE                     1001
#define IDC_STATWIZ_PREVIEWBACKGROUND            1002
#define IDC_STATWIZ_BROWSEBACKGROUND             1003
#define IDC_STATWIZ_CHECKPICTURE                 1004
#define IDC_STATWIZ_COMBOPICTURE                 1005
#define IDC_STATWIZ_CHECKCOLOR                   1006
#define IDC_STATWIZ_PREVIEWFONT                  1007
#define IDC_STATWIZ_COMBOFONT                    1008
#define IDC_STATWIZ_COMBOSIZE                    1009
#define IDC_STATWIZ_COMBOFONTCOLOR               1010
#define IDC_STATWIZ_CHECKBOLD                    1011
#define IDC_STATWIZ_CHECKITALIC                  1012
#define IDC_STATWIZ_PREVIEWMARGIN                1013
#define IDC_STATWIZ_EDITLEFTMARGIN               1014
#define IDC_STATWIZ_SPINLEFTMARGIN               1015
#define IDC_STATWIZ_EDITTOPMARGIN                1016
#define IDC_STATWIZ_SPINTOPMARGIN                1017
#define IDC_STATWIZ_COMBOCOLOR                   1018
#define IDC_STATWIZ_PREVIEWFINAL                 1019
#define IDC_STATWIZ_HORZCOMBO                    1020
#define IDC_STATWIZ_VERTCOMBO                    1021
#define IDC_STATWIZ_TILECOMBO                    1022

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\statwiz.cpp ===
// =================================================================================
// S T A T W I Z . C P P
// =================================================================================

#include "pch.hxx"
#include <prsht.h>
#include "strconst.h"
#include "goptions.h"
#include "error.h"
#include "resource.h"
#include "url.h"
#include "bodyutil.h"
#include "mailutil.h"
#include "statnery.h"
#include "wininet.h"
#include "options.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "regutil.h"
#include "thumb.h"
#include "optres.h"
#include "statwiz.h"
#include "url.h"
#include "fontnsc.h"
#include "fonts.h"
#include <mshtml.h>
#include <oleutil.h>
#include "demand.h"

#define TMARGIN_MAX 500
#define LMARGIN_MAX 500
#define MARGIN_MIN 0

void _EnableBackgroundWindows(HWND hDlg, int id, BOOL enable);
void _ShowBackgroundPreview(HWND hDlg, LPSTATWIZ pApp);
void _ShowFontPreview(HWND hDlg, LPSTATWIZ pApp);
void _ShowMarginPreview(HWND hDlg, LPSTATWIZ pApp);
void _ShowFinalPreveiew(HWND hDlg, LPSTATWIZ pApp);

void _PaintFontSample(HWND hwnd, HDC hdc, LPSTATWIZ pApp);
LRESULT CALLBACK _FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL _CopyFileToStationeryDir(LPWSTR pwszFileSrc);
BOOL _FillCombo(HWND, ULONG id);
void SetupFonts( HINSTANCE, HWND, HFONT *pBigBoldFont);
VOID SetControlFont(HFONT, HWND,INT nId);

BOOL CALLBACK _WelcomeOKProc(CStatWiz *,HWND,UINT,UINT *,BOOL *);
BOOL CALLBACK _BackgroundOKProc(CStatWiz *,HWND,UINT,UINT *,BOOL *);
BOOL CALLBACK _FontOKProc(CStatWiz *,HWND,UINT,UINT *,BOOL *);
BOOL CALLBACK _MarginOKProc(CStatWiz *,HWND,UINT,UINT *,BOOL *);
BOOL CALLBACK _FinalOKProc(CStatWiz *,HWND,UINT,UINT *,BOOL *);
INT_PTR CALLBACK _GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK _WelcomeInitProc(CStatWiz *,HWND,BOOL);
BOOL CALLBACK _BackgroundInitProc(CStatWiz *,HWND,BOOL);
BOOL CALLBACK _FontInitProc(CStatWiz *,HWND,BOOL);
BOOL CALLBACK _MarginInitProc(CStatWiz *,HWND,BOOL);
BOOL CALLBACK _FinalInitProc(CStatWiz *,HWND,BOOL);

BOOL CALLBACK _BackgroundCmdProc(CStatWiz *,HWND,WPARAM,LPARAM);
BOOL CALLBACK _FontCmdProc(CStatWiz *,HWND,WPARAM,LPARAM);
BOOL CALLBACK _MarginCmdProc(CStatWiz *,HWND,WPARAM,LPARAM);

#define idTimerEditChange   666

const static PAGEINFO s_rgPageInfo[NUM_WIZARD_PAGES] =
{
    { iddStatWelcome,   0,   0,                  _WelcomeInitProc,    _WelcomeOKProc,    NULL                    },
    { iddStatBackground,idsStatBackHeader,      idsStatBackMsg,     _BackgroundInitProc, _BackgroundOKProc, _BackgroundCmdProc      },
    { iddStatFont,      idsStatFontHeader,      idsStatFontMsg,     _FontInitProc,       _FontOKProc,       _FontCmdProc            },
    { iddStatMargin,    idsStatMarginHeader,    idsStatMarginMsg,   _MarginInitProc,     _MarginOKProc,     _MarginCmdProc          },
    { iddStatFinal,     idsStatFinalHeader,     idsStatCompleteMsg,   _FinalInitProc,      _FinalOKProc,      NULL                    }
};

CStatWiz::CStatWiz()
{
    m_cRef = 1;
    m_iCurrentPage      = 0;
    m_cPagesCompleted   = 0;
    *m_rgHistory        = 0;
    *m_wszHtmlFileName  = 0;
    *m_wszFontFace       = 0;
    *m_wszBkColor        = 0;
    *m_wszFontColor      = 0;
    *m_wszBkPictureFileName = 0;
    m_iFontSize = 0;
    m_fBold = FALSE;
    m_fItalic = FALSE;
    m_iLeftMargin = 0;
    m_iTopMargin = 0;
    m_iVertPos = 0;
    m_iHorzPos = 0;
    m_iTile = 0;

    m_hBigBoldFont = NULL;
    SetupFonts( g_hLocRes, NULL, &m_hBigBoldFont );
}


CStatWiz::~CStatWiz()
{
    Assert (m_cRef == 0);

    if (m_hBigBoldFont != NULL)
        DeleteObject(m_hBigBoldFont);
}

ULONG CStatWiz::AddRef(VOID)
{
    return ++m_cRef;
}

ULONG CStatWiz::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    DLGTEMPLATE *pDlg;

    if (uMsg == PSCB_PRECREATE)
    {
        pDlg = (DLGTEMPLATE *)lParam;
        
        if (!!(pDlg->style & DS_CONTEXTHELP))
            pDlg->style &= ~DS_CONTEXTHELP;
    }

    return(0);
}

HRESULT CStatWiz::DoWizard(HWND hwnd)
{
    int                 nPageIndex, 
                        cPages, 
                        iRet;
    PROPSHEETPAGEW      psPage = {0};
    PROPSHEETHEADERW    psHeader = {0};
    HRESULT             hr;
    HPROPSHEETPAGE      rgPage[NUM_WIZARD_PAGES] = {0};
    INITWIZINFO         rgInit[NUM_WIZARD_PAGES] = {0};
    WCHAR               wsz[CCHMAX_STRINGRES];
    
    psPage.dwSize = sizeof(psPage);
    psPage.hInstance = g_hLocRes;
    psPage.pfnDlgProc = _GenDlgProc;

    hr = S_OK;

    cPages = 0;

    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
    {
        rgInit[cPages].pPageInfo = &s_rgPageInfo[nPageIndex];
        rgInit[cPages].pApp = this;
        psPage.lParam = (LPARAM)&rgInit[cPages];
        psPage.pszTemplate = MAKEINTRESOURCEW(s_rgPageInfo[nPageIndex].uDlgID);
        
        psPage.pszHeaderTitle = MAKEINTRESOURCEW(s_rgPageInfo[nPageIndex].uHdrID);
        psPage.pszHeaderSubTitle =  MAKEINTRESOURCEW(s_rgPageInfo[nPageIndex].uSubHdrID);
        
        if( nPageIndex == 0 )
        {
            psPage.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
        }
        else
            psPage.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        
        rgPage[cPages] = CreatePropertySheetPageW(&psPage);
        
        if (rgPage[cPages] == NULL)
        {
            hr = E_FAIL;
            break;
        }
        cPages++;
    }
    
    if (SUCCEEDED(hr))
    {
        psHeader.dwSize = sizeof(psHeader);
        psHeader.dwFlags =  PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_USECALLBACK;
        psHeader.hwndParent = hwnd;
        psHeader.hInstance = g_hLocRes;
        psHeader.nPages = cPages;
        psHeader.phpage = rgPage;
        psHeader.pszbmWatermark = MAKEINTRESOURCEW(IDB_STATWIZ_WATERMARK);
        psHeader.pszbmHeader = MAKEINTRESOURCEW(IDB_STATWIZ_HEADER);
        psHeader.nStartPage = 0;
        psHeader.nPages = NUM_WIZARD_PAGES;        
        psHeader.pfnCallback = PropSheetProc;

        iRet = (int) PropertySheetW(&psHeader);

        if (iRet == -1)
            hr = E_FAIL;
        else if (iRet == 0)
            hr = S_FALSE;
        else
            hr = S_OK;
    }
    else
    {
        for (nPageIndex = 0; nPageIndex < cPages; nPageIndex++)
        {
            if (rgPage[nPageIndex] != NULL)
                DestroyPropertySheetPage(rgPage[nPageIndex]);
        }
    }
    
    return(hr);
}

INT_PTR CALLBACK _GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INITWIZINFO *pInitInfo;
    BOOL fRet, fKeepHistory;
    HWND hwndParent;
    LPPROPSHEETPAGE lpsp;
    const PAGEINFO *pPageInfo;
    CStatWiz *pApp=0;
    NMHDR *lpnm;
    UINT iNextPage;
    LPNMUPDOWN lpupdwn;
    fRet = TRUE;
    hwndParent = GetParent(hDlg);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // get propsheet page struct passed in
            lpsp = (LPPROPSHEETPAGE)lParam;
            Assert(lpsp != NULL);
    
            // fetch our private page info from propsheet struct
            pInitInfo = (INITWIZINFO *)lpsp->lParam;
            Assert(pInitInfo != NULL);

            pApp = pInitInfo->pApp;
            Assert(pApp != NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pApp);

            pPageInfo = pInitInfo->pPageInfo;
            Assert(pPageInfo != NULL);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pPageInfo);

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc != NULL)
                {
                pPageInfo->InitProc(pApp, hDlg, TRUE);
                }
            return(FALSE);


        case WM_DRAWITEM:
            LPDRAWITEMSTRUCT pdis;
            pdis = (LPDRAWITEMSTRUCT)lParam;
            Assert(pdis);
            Color_WMDrawItem(pdis, iColorCombo, GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONT)?FALSE:TRUE);
            break;

        case WM_MEASUREITEM:
            HDC hdc;
            LPMEASUREITEMSTRUCT pmis;
            pmis = (LPMEASUREITEMSTRUCT)lParam;
            hdc = GetDC(hDlg);
            if(hdc)
            {
                Color_WMMeasureItem(hdc, pmis, iColorCombo);
                ReleaseDC(hDlg, hdc);
            }
            break;
            
        case WM_NOTIFY:
            lpnm = (NMHDR *)lParam;
            pApp = (CStatWiz *)GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pApp != NULL);
            
            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);
            switch (lpnm->code)
            {
            case PSN_SETACTIVE:
                // initialize 'back' and 'next' wizard buttons, if
                // page wants something different it can fix in init proc below
                PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);
                
                // call init proc for this page if one is specified
                if (pPageInfo->InitProc != NULL)
                {
                    // TODO: what about the return value for this????
                    pPageInfo->InitProc(pApp, hDlg, FALSE);
                }
                
                pApp->m_iCurrentPage = pPageInfo->uDlgID;
                break;
                
            case PSN_WIZNEXT:
            case PSN_WIZBACK:
            case PSN_WIZFINISH:
                Assert((ULONG)pApp->m_iCurrentPage == pPageInfo->uDlgID);
                fKeepHistory = TRUE;
                iNextPage = 0;
                Assert(pPageInfo->OKProc != NULL) ;
                if (!pPageInfo->OKProc(pApp, hDlg, lpnm->code, &iNextPage, &fKeepHistory))
                {
                    // stay on this page
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
                
                if (lpnm->code != PSN_WIZBACK)
                {
                    // 'next' pressed
                    Assert(pApp->m_cPagesCompleted < NUM_WIZARD_PAGES);
                    
                    // save the current page index in the page history,
                    // unless this page told us not to when we called
                    // its OK proc above
                    if (fKeepHistory)
                    {
                        pApp->m_rgHistory[pApp->m_cPagesCompleted] = pApp->m_iCurrentPage;
                        pApp->m_cPagesCompleted++;
                    }
                }
                else
                {
                    // 'back' pressed
                    Assert(pApp->m_cPagesCompleted > 0);
                    
                    // get the last page from the history list
                    pApp->m_cPagesCompleted--;
                    iNextPage = pApp->m_rgHistory[pApp->m_cPagesCompleted];
                }
                
                // set next page, only if 'next' or 'back' button was pressed
                if (lpnm->code != PSN_WIZFINISH)
                {
                    // tell the prop sheet mgr what the next page to display is
                    Assert(iNextPage != 0);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iNextPage);
                }
                break;
                
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
              
            case UDN_DELTAPOS:
                if (lpnm->idFrom == IDC_STATWIZ_SPINLEFTMARGIN ||
                    lpnm->idFrom == IDC_STATWIZ_SPINTOPMARGIN)
                {
                    ((LPNMUPDOWN)lpnm)->iDelta *= 25;
                }
                break;
            }            
            break;

        case WM_TIMER:
            if (wParam == idTimerEditChange)
            {
                pApp = (CStatWiz *)GetWindowLongPtr(hDlg, DWLP_USER);
                if (!pApp)
                    return FALSE;

                KillTimer(hDlg, idTimerEditChange);
                _ShowMarginPreview(hDlg, pApp);
                return TRUE;
            }
            break;

        case WM_COMMAND:
            pApp = (CStatWiz *)GetWindowLongPtr(hDlg, DWLP_USER);
            if (!pApp)
                return FALSE;

            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);

            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc != NULL)
                {
                fRet = pPageInfo->CmdProc(pApp, hDlg, wParam, lParam);
                }
            break;
        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
}

const static  WCHAR c_wszUrlFile[] = L"file://";
BOOL _CopyFileToStationeryDir(LPWSTR pwszFileSrc)
{
    BOOL fRet = FALSE;
    WCHAR   wszDestFile[MAX_PATH];
    LPWSTR  pwsz=0;

    // skip file://
    pwsz = StrStrIW(pwszFileSrc, c_wszUrlFile);
    if (pwsz)
    {
        pwsz = pwszFileSrc + lstrlenW(c_wszUrlFile);
        if (*pwsz == L'/')
            pwsz++;
    }
    else
        pwsz = pwszFileSrc;

    StrCpyW(wszDestFile, pwsz);
    PathStripPathW(wszDestFile);
    InsertStationeryDir(wszDestFile);

    if (StrCmpIW(pwsz, wszDestFile) && (CopyFileWrapW(pwsz, wszDestFile, FALSE)))
        fRet = TRUE;

    return fRet;
}


BOOL CALLBACK _BackgroundInitProc(CStatWiz *pApp, HWND hDlg, BOOL fFirstInit)
{
    Assert(pApp != NULL);

    if (fFirstInit)
    {
        HrFillStationeryCombo(GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE), TRUE, NULL);
        _FillCombo(GetDlgItem(hDlg, IDC_STATWIZ_VERTCOMBO), idsStatWizVertPos); 
        _FillCombo(GetDlgItem(hDlg, IDC_STATWIZ_HORZCOMBO), idsStatWizHorzPos);
        _FillCombo(GetDlgItem(hDlg, IDC_STATWIZ_TILECOMBO), idsStatWizTile);
        HrCreateComboColor(GetDlgItem(hDlg, IDC_STATWIZ_COMBOCOLOR));
        CheckDlgButton(hDlg, IDC_STATWIZ_CHECKPICTURE, BST_CHECKED);
        _EnableBackgroundWindows(hDlg, IDC_STATWIZ_CHECKPICTURE, TRUE);
        _EnableBackgroundWindows(hDlg, IDC_STATWIZ_CHECKCOLOR, FALSE);        
        
        if (*pApp->m_wszBkColor)
        {
            Assert(*pApp->m_wszBkPictureFileName == 0);
            CheckDlgButton(hDlg, IDC_STATWIZ_CHECKCOLOR, BST_CHECKED);
            _EnableBackgroundWindows(hDlg, IDC_STATWIZ_CHECKCOLOR, TRUE);
        }
        else if (*pApp->m_wszBkPictureFileName)
        {
            StationeryComboBox_SelectString(GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE), pApp->m_wszBkPictureFileName);
        }
        else
        {
            ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE), 0);
            ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOCOLOR), 0);
        }
        
        GetWindowTextWrapW(GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE), pApp->m_wszBkPictureFileName, ARRAYSIZE(pApp->m_wszBkPictureFileName));
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_VERTCOMBO),pApp->m_iVertPos);
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_HORZCOMBO),pApp->m_iHorzPos);
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_TILECOMBO),pApp->m_iTile);
        _ShowBackgroundPreview(hDlg, pApp);
    }

    return(TRUE);
}


BOOL CALLBACK _BackgroundCmdProc(CStatWiz *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    UINT id,  code;

    id = GET_WM_COMMAND_ID(wParam,lParam);

    switch (id)
        {
        case IDC_STATWIZ_CHECKPICTURE:
        case IDC_STATWIZ_CHECKCOLOR:
            code = GET_WM_COMMAND_CMD(wParam, lParam);
            if (code == BN_CLICKED)
                {
                _EnableBackgroundWindows(hDlg, id, IsDlgButtonChecked(hDlg, id));
                _ShowBackgroundPreview(hDlg, pApp);
                }

            return TRUE;

        case IDC_STATWIZ_COMBOPICTURE:
        case IDC_STATWIZ_COMBOCOLOR:
        case IDC_STATWIZ_HORZCOMBO:
        case IDC_STATWIZ_VERTCOMBO:
        case IDC_STATWIZ_TILECOMBO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                _ShowBackgroundPreview(hDlg, pApp);
            return TRUE;

        case IDC_STATWIZ_BROWSEBACKGROUND:
            HrBrowsePicture(hDlg, GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE));
            _ShowBackgroundPreview(hDlg, pApp);
            return TRUE;

        default:
            return FALSE;
        }

    return FALSE;
}

void _ShowBackgroundPreview(HWND hDlg, LPSTATWIZ pApp)
{
    HWND    hwnd;
    INT     cch;
    INT     iCurSel;
    WCHAR   wszBuf[MAX_PATH];
    *wszBuf = 0;

    pApp->m_wszBkColor[0]=0;
    pApp->m_wszBkPictureFileName[0]=0;

    if( (iCurSel = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_VERTCOMBO)) ) != CB_ERR )
    {
        Assert( iCurSel >= 0 && iCurSel < 3 );
        pApp->m_iVertPos = iCurSel;
    }
    if( (iCurSel = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_HORZCOMBO)) ) != CB_ERR )
    {
        Assert( iCurSel >= 0 && iCurSel < 3 );
        pApp->m_iHorzPos = iCurSel;
    }
    if( (iCurSel = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_TILECOMBO)) ) != CB_ERR )
    {
        Assert( iCurSel >= 0 && iCurSel < 4 );
        pApp->m_iTile = iCurSel;
    }
    
    if (IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKPICTURE))
    {
        hwnd = GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE);
        cch = GetWindowTextLength(hwnd);
        if (cch != 0)
            GetWindowTextWrapW(hwnd, pApp->m_wszBkPictureFileName, ARRAYSIZE(pApp->m_wszBkPictureFileName));
        
    }
    if( IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKCOLOR) ) 
    {
        if (SUCCEEDED(HrFromIDToRBG(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOCOLOR)), wszBuf, TRUE)))
            StrCpyW(pApp->m_wszBkColor, wszBuf);
    }
    ShowPreview(GetDlgItem(hDlg, IDC_STATWIZ_PREVIEWBACKGROUND), pApp, NULL);
    return;
}


void _EnableBackgroundWindows(HWND hDlg, int id, BOOL enable)
{
    if( id == IDC_STATWIZ_CHECKPICTURE )
    {
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_BROWSEBACKGROUND), enable);
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE), enable);
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_VERTCOMBO), enable);
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_HORZCOMBO), enable);
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_TILECOMBO), enable);
    }
    else if ( id == IDC_STATWIZ_CHECKCOLOR)
        EnableWindow(GetDlgItem(hDlg, IDC_STATWIZ_COMBOCOLOR), enable);
}


BOOL CALLBACK _BackgroundOKProc(CStatWiz *pApp, HWND hDlg, UINT code, UINT *puNextPage, BOOL *pfKeepHistory)
{
    BOOL    fForward;
    HWND    hwnd;
    int     cch;
    WCHAR   wszBuf[MAX_PATH];

    Assert(pApp != NULL);
    fForward = code != PSN_WIZBACK;

    if (fForward)
    {
        if (IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKPICTURE))
        {
            hwnd = GetDlgItem(hDlg, IDC_STATWIZ_COMBOPICTURE);
            cch = GetWindowTextLength(hwnd);
            if (cch == 0)
            {
                AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsStationery), MAKEINTRESOURCEW(idsBackgroundEmptyWarning),
                    NULL, MB_OK | MB_ICONEXCLAMATION);
                
                SetFocus(hDlg);
                return (FALSE);
            }
            GetWindowTextWrapW(hwnd, pApp->m_wszBkPictureFileName, ARRAYSIZE(pApp->m_wszBkPictureFileName));
        }
        if( IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKCOLOR) )
        {
            if( SUCCEEDED( HrFromIDToRBG(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOCOLOR)), wszBuf, TRUE)) )
            {
                StrCpyW(pApp->m_wszBkColor, wszBuf);
            }
        }
        
        *puNextPage = iddStatFont;
    }
    return(TRUE);
}


BOOL CALLBACK _FontInitProc(CStatWiz *pApp, HWND hDlg, BOOL fFirstInit)
{
    HWND    hIDC;
    FARPROC pfnFontSampleWndProc;
    Assert(pApp != NULL);
            
    if (fFirstInit)
        {
        FillFontNames(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONT));
        HrCreateComboColor(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONTCOLOR));
        FillSizes(GetDlgItem(hDlg, IDC_STATWIZ_COMBOSIZE));
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONT), 0);
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOSIZE), 1);
        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONTCOLOR), 0);

        hIDC = GetDlgItem(hDlg, IDC_STATWIZ_PREVIEWFONT);
        pfnFontSampleWndProc = (FARPROC)SetWindowLongPtr(hIDC, GWLP_WNDPROC, (LPARAM)_FontSampleSubProc);
        SetWindowLongPtr(hIDC, GWLP_USERDATA, (LPARAM)pfnFontSampleWndProc);
        _ShowFontPreview(hDlg, pApp);

        }

    return(TRUE);
}


LRESULT CALLBACK _FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPSTATWIZ   pApp=0;
    WNDPROC     pfn;
    HDC         hdc;
    PAINTSTRUCT ps;

    pApp = (LPSTATWIZ)GetWindowLongPtr(GetParent(hwnd), DWLP_USER);
    Assert(pApp);

    if (msg == WM_PAINT)
    {
        hdc=BeginPaint (hwnd, &ps);
        _PaintFontSample(hwnd, hdc, pApp);
        EndPaint (hwnd, &ps);
        return(0);
    }

    pfn = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    Assert(pfn != NULL);
    return(CallWindowProc(pfn, hwnd, msg, wParam, lParam));
}

void _PaintFontSample(HWND hwnd, HDC hdc, LPSTATWIZ pApp)
{
    int                 dcSave=SaveDC(hdc);
    RECT                rc;
    SIZE                rSize;
    INT                 x, y, cbSample;
    HFONT               hFont, hOldFont;
    LOGFONT             lf={0};
    TCHAR               szBuf[LF_FACESIZE+1];
    DWORD               dw;
    INT                 rgb;
    BOOL                fBold=FALSE,
                        fItalic=FALSE,
                        fUnderline=FALSE;

    INT yPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    *szBuf = 0;
    lf.lfHeight =-(INT)((pApp->m_iFontSize*10*2*yPerInch)/1440);

    lf.lfWeight = pApp->m_fBold ? FW_BOLD : FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DRAFT_QUALITY;
    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfItalic = !!pApp->m_fItalic;
    lf.lfUnderline = FALSE;

    if (*pApp->m_wszFontFace != 0)
    {
        WideCharToMultiByte(CP_ACP, 0, pApp->m_wszFontFace, -1, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), NULL, NULL);
    }
    else
    {
        if(LoadString(g_hLocRes, idsComposeFontFace, szBuf, LF_FACESIZE))
            lstrcpy(lf.lfFaceName, szBuf);
    }

    hFont=CreateFontIndirect(&lf);
    hOldFont = (HFONT)SelectObject (hdc, hFont);

    GetClientRect(hwnd, &rc);
    DrawEdge (hdc, &rc, EDGE_SUNKEN, BF_RECT);
    InflateRect(&rc, -2, -2);
    FillRect (hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
    // pull in the drawing rect by 2 pixels all around
    InflateRect(&rc, -2, -2);
    SetBkMode (hdc, TRANSPARENT);  // So the background shows through the text.

    HrGetRBGFromString(&rgb, pApp->m_wszFontColor);
    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    SetTextColor(hdc, rgb);

    *szBuf = 0;
    LoadString(g_hLocRes, idsFontSample, szBuf, LF_FACESIZE);
    GetTextExtentPoint32 (hdc, szBuf, lstrlen(szBuf), &rSize);
    x = rc.left + (((rc.right-rc.left) / 2) - (rSize.cx / 2));
    y = rc.top + (((rc.bottom-rc.top) / 2) - (rSize.cy / 2));
    ExtTextOut (hdc, x, y, ETO_CLIPPED, &rc, szBuf, lstrlen(szBuf), NULL);
    DeleteObject(SelectObject (hdc, hOldFont));
    RestoreDC(hdc, dcSave);
}



void _ShowFontPreview(HWND hDlg, LPSTATWIZ pApp)
{
    TCHAR   szBuf[COLOR_SIZE];
    INT     id;
    HRESULT hr;

    GetWindowTextWrapW(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONT), pApp->m_wszFontFace, ARRAYSIZE(pApp->m_wszFontFace));
    id = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOSIZE));
    if (id >= 0)
        pApp->m_iFontSize = HTMLSizeToPointSize(id + 1);

    id = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_STATWIZ_COMBOFONTCOLOR));
    HrFromIDToRBG(id, pApp->m_wszFontColor, FALSE);
    pApp->m_fBold = IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKBOLD);
    pApp->m_fItalic = IsDlgButtonChecked(hDlg, IDC_STATWIZ_CHECKITALIC);
    InvalidateRect(GetDlgItem(hDlg, IDC_STATWIZ_PREVIEWFONT), NULL, TRUE);
}


BOOL CALLBACK _FontCmdProc(CStatWiz *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    UINT id,  code;
    id = GET_WM_COMMAND_ID(wParam,lParam);

    switch (id)
        {
        case IDC_STATWIZ_COMBOFONT:
        case IDC_STATWIZ_COMBOSIZE:
        case IDC_STATWIZ_COMBOFONTCOLOR:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                _ShowFontPreview(hDlg, pApp);
            return TRUE;

        case IDC_STATWIZ_CHECKBOLD:
        case IDC_STATWIZ_CHECKITALIC:
            code = GET_WM_COMMAND_CMD(wParam, lParam);
            if (code == BN_CLICKED)
                _ShowFontPreview(hDlg, pApp);
            return TRUE;

        default:
            return FALSE;
        }

    return FALSE;
}


BOOL CALLBACK _FontOKProc(CStatWiz *pApp, HWND hDlg, UINT code, UINT *puNextPage, BOOL *pfKeepHistory)
{
    Assert(pApp != NULL);
    BOOL    fForward;

    fForward = code != PSN_WIZBACK;

    if (fForward)
        {
        *puNextPage = iddStatMargin;
        }

    return(TRUE);
}

BOOL CALLBACK _MarginInitProc(CStatWiz *pApp, HWND hDlg, BOOL fFirstInit)
{
    Assert(pApp != NULL);
    TCHAR szBuf[16];

    if (fFirstInit)
    {
        // limit the text to 7 characters
        SendDlgItemMessage( hDlg, IDC_STATWIZ_EDITLEFTMARGIN, EM_LIMITTEXT, 7,  0);
        SendDlgItemMessage( hDlg, IDC_STATWIZ_EDITTOPMARGIN,  EM_LIMITTEXT, 7,  0);
        SendDlgItemMessage( hDlg, IDC_STATWIZ_SPINLEFTMARGIN, UDM_SETRANGE, 0L, MAKELONG(LMARGIN_MAX, MARGIN_MIN));
        SendDlgItemMessage( hDlg, IDC_STATWIZ_SPINTOPMARGIN,  UDM_SETRANGE, 0L, MAKELONG(TMARGIN_MAX, MARGIN_MIN));
        SendDlgItemMessage( hDlg, IDC_STATWIZ_SPINLEFTMARGIN, UDM_SETPOS,   0L, (LPARAM) MAKELONG((short) 0, 0));  
        SendDlgItemMessage( hDlg, IDC_STATWIZ_SPINTOPMARGIN,  UDM_SETPOS,   0L, (LPARAM) MAKELONG((short) 0, 0));  
    }
    _ShowMarginPreview(hDlg, pApp);
    return(TRUE);
}

void _ShowMarginPreview(HWND hDlg, LPSTATWIZ pApp)
{
    TCHAR szBuf[MAX_PATH];
    *szBuf=0;
    if( GetWindowText(GetDlgItem(hDlg, IDC_STATWIZ_EDITLEFTMARGIN), szBuf, sizeof(szBuf)) > 0)
        pApp->m_iLeftMargin = StrToInt(szBuf);
    else
        pApp->m_iLeftMargin = 0;
    
    if( GetWindowText(GetDlgItem(hDlg, IDC_STATWIZ_EDITTOPMARGIN), szBuf, sizeof(szBuf)) > 0 )
        pApp->m_iTopMargin = StrToInt(szBuf);
    else
        pApp->m_iTopMargin = StrToInt(szBuf);

    ShowPreview(GetDlgItem(hDlg, IDC_STATWIZ_PREVIEWMARGIN), pApp, idsStationerySample);
}


BOOL CALLBACK _MarginCmdProc(CStatWiz *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    UINT id,  code;
    WORD cmd;
    id = GET_WM_COMMAND_ID(wParam,lParam);
    cmd = GET_WM_COMMAND_CMD(wParam,lParam);

    switch (cmd)
        {
        case EN_CHANGE:
	        KillTimer(hDlg, idTimerEditChange);
            SetTimer(hDlg, idTimerEditChange, 200, NULL);
            return TRUE;

        default:
            return FALSE;
        }
    return FALSE;
}


BOOL CALLBACK _MarginOKProc(CStatWiz *pApp, HWND hDlg, UINT code, UINT *puNextPage, BOOL *pfKeepHistory)
{
    Assert(pApp != NULL);
    BOOL    fForward;

    fForward = code != PSN_WIZBACK;

    // this also stores the values of the fields in the event they are invalid and need to be updated
    _ShowMarginPreview(hDlg, pApp);
    if (fForward)
        {
        *puNextPage = iddStatFinal;
        }

    return(TRUE);
}

void _ShowFinalPreview(HWND hDlg, LPSTATWIZ pApp)
{
    // in case we want to do more fancy stuff with final preview I put this is separate
    // function
    ShowPreview(GetDlgItem(hDlg, IDC_STATWIZ_PREVIEWFINAL), pApp, idsStationerySample);
}

BOOL CALLBACK _FinalInitProc(CStatWiz *pApp, HWND hDlg, BOOL fFirstInit)
{
    Assert(pApp != NULL);
    
    _ShowFinalPreview(hDlg,pApp);

    // looks better if buttons initialize as page is being shown rather than before (IMHO)
    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH | PSWIZB_BACK);       
    if (fFirstInit)
    {
        SendDlgItemMessage(hDlg, IDC_STATWIZ_EDITNAME, EM_LIMITTEXT, 60, 0);
    }

    return(TRUE);
}

BOOL CALLBACK _FinalOKProc(CStatWiz *pApp, HWND hDlg, UINT code, UINT *puNextPage, BOOL *pfKeepHistory)
{
    int     cch;
    HWND    hwnd;
    BOOL    fForward;
    WCHAR   wszBuf[MAX_PATH];
    HANDLE  hFile;

    Assert(pApp != NULL);
    fForward = code != PSN_WIZBACK;

    if (fForward)
    {
        // check to see if file name is valid
        hwnd = GetDlgItem(hDlg, IDC_STATWIZ_EDITNAME);
        cch = GetWindowTextWrapW(hwnd, wszBuf, ARRAYSIZE(wszBuf));
        if (cch == 0 || FIsEmptyW(wszBuf))
        {
            AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsStationery), MAKEINTRESOURCEW(idsStationeryEmptyWarning),
                NULL, MB_OK | MB_ICONEXCLAMATION);
            
            SendMessage(hwnd, EM_SETSEL, 0, -1);
            SetFocus(hwnd);
            return(FALSE);
        }
        else 
        {
            LPWSTR pwszExt = PathFindExtensionW( wszBuf );
            if ( pwszExt != NULL )
            {
                if( PathIsHTMLFileW( wszBuf ) )
                {
                    DebugTrace("this is an html file\n");
                }
                else
                {
                    PathRemoveExtensionW( wszBuf );
                    if( !SetWindowTextWrapW(hwnd, wszBuf) )
                        DebugTrace("could not set text\n");
                }
            }    
        }
        
        if (IsValidCreateFileName(wszBuf))
        {
            AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsStationery), MAKEINTRESOURCEW(idsStationeryExistWarning),
                NULL, MB_OK | MB_ICONEXCLAMATION);
            
            SendMessage(hwnd, EM_SETSEL, 0, -1);
            SetFocus(hwnd);
            return(FALSE);
        }
                
        StrCpyW(pApp->m_wszHtmlFileName, wszBuf);
        hFile = CreateFileWrapW(pApp->m_wszHtmlFileName,GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE ,NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            FillHtmlToFile(pApp, hFile, 0, FALSE);
            CloseHandle(hFile);
            if (*pApp->m_wszBkPictureFileName)
            {
                InsertStationeryDir(pApp->m_wszBkPictureFileName);
                _CopyFileToStationeryDir(pApp->m_wszBkPictureFileName);                
            }
        }
    }   
    return(TRUE);
}

BOOL CALLBACK _WelcomeOKProc(CStatWiz *pApp, HWND hDlg, UINT code, UINT *puNextPage, BOOL *pfKeepHistory)
{
    Assert(pApp != NULL);
    BOOL    fForward;
   fForward = code != PSN_WIZBACK;

    if (fForward)
        {
        *puNextPage = iddStatBackground;
        }

    return(TRUE);
}

BOOL CALLBACK _WelcomeInitProc(CStatWiz *pApp, HWND hDlg, BOOL fFirstInit)
{
    Assert(pApp != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
    if( fFirstInit)
    {
        SetControlFont( pApp->m_hBigBoldFont, hDlg, IDC_STATWIZ_BIGBOLDTITLE);
    }
    return(TRUE);
}

BOOL _FillCombo(HWND hComboDlg, ULONG ulStrId)
{
    TCHAR szBuf[CCHMAX_STRINGRES];
    
    LPTSTR pch;
    LoadStringReplaceSpecial(ulStrId, szBuf, sizeof(szBuf) );
    pch = szBuf;
    while(*pch != 0 )
    {
        if( SendMessage(hComboDlg, CB_ADDSTRING, 0, (LPARAM)pch) < 0 )
            return FALSE;
        pch+=lstrlen(pch)+1;
    }
    return TRUE;
}

// from wiz97 example on MSDN
void 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm;
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //

    lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    FontSize = 12;

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
        ReleaseDC(hwnd,hdc);
    }
}

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId)
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\subscr.h ===
#ifndef __SUBSCR_H__
#define __SUBSCR_H__

#include "grplist2.h"

#define idtFindDelay    1
#define dtFindDelay     600

// SIZETABLE - This struct is used to make the dialog resizable.  We keep one
//             of these for each control in the dialog.  The rect's are updated
//             in WM_SIZE.  A table of these is built in WM_INITDIALOG.
typedef struct tagSIZETABLE
    {
    HWND hwndCtl;
    UINT id;
    RECT rc;
    } SIZETABLE, *PSIZETABLE;

class CGroupListDlg : public IGroupListAdvise
    {
    public:
        CGroupListDlg();
        ~CGroupListDlg();
  
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IGroupListAdvise
        HRESULT STDMETHODCALLTYPE ItemUpdate(void);
        HRESULT STDMETHODCALLTYPE ItemActivate(FOLDERID id);

        // CGroupListDlg
        BOOL FCreate(HWND hwndOwner, FOLDERTYPE type, FOLDERID *pGotoId,
                UINT iTabSelect, BOOL fEnableGoto, FOLDERID idSel);

    private:
        static INT_PTR	 CALLBACK GroupListDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
        void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
        LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
        void OnTimer(HWND hwnd, UINT id);
        void OnPaint(HWND hwnd);
        void OnClose(HWND hwnd);
        void OnDestroy(HWND hwnd);
        void OnSize(HWND hwnd, UINT state, int cx, int cy);
        void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
        void OnChangeServers(HWND hwnd);
    
        BOOL IsGrpDialogMessage(HWND hwnd, LPMSG pMsg);
    
        BOOL ChangeServers(FOLDERID id, BOOL fForce = FALSE);
        BOOL FillServerList(HWND hwndList, FOLDERID idSel);
        BOOL OnSwitchTabs(HWND hwnd, UINT iTab);

        // Whenever we do something that might update the state of a button on
        // the dialog, we call this to allow the subclasses to update their UI.
        void UpdateStateUI(void);

        UINT        m_cRef;

        // Handy window handles to have available
        HWND        m_hwnd;
        HWND        m_hwndFindText;
        HWND        m_hwndOwner;

        // State variables
        BOOL        m_fAllowDesc;       // TRUE if the user can search descriptions
        LPTSTR      m_pszPrevQuery;     // The string that we last searched on
        UINT        m_cchPrevQuery;     // The allocated length of m_pszPrevQuery
    
        // Values used in resizing
        UINT        m_cxHorzSep;
        UINT        m_cyVertSep;
        PSIZETABLE  m_rgst;             // st - SizeTable.  I use this a lot so I wanted it short - SteveSer
        SIZE        m_sizeDlg;
        POINT       m_ptDragMin;

        HIMAGELIST  m_himlServer;
        CGroupList *m_pGrpList;
        FOLDERTYPE  m_type;
        UINT        m_iTabSelect;
        FOLDERID    m_idSel;
        FOLDERID    m_idGoto;
        BOOL        m_fEnableGoto;

        BOOL        m_fServerListInited;
        FOLDERID    m_idCurrent;
        HICON       m_hIcon;

        CColumns   *m_pColumns;
    };

/////////////////////////////////////////////////////////////////////////////
// Dialog Control ID's
// 

#define idcGroupList                2001            // Group list listview
#define idcFindText                 2002            // Find query edit box
#define idcShowFavorites            2003            // Filter favorites toggle
#define idcUseDesc                  2004            // Use Desc checkbox
#define idcServers                  2005            // Server Listview
#define idcHelp                     2006            // Help button
#define idcResetList                2007            // Rebuild the group list

#define idcUpdateNow                1001
#define idcFullWord                 1004
#define idcPreview                  1006
#define idcProgress                 1007
#define idcApply                    1008
#define idcFind                     1010
#define idcDispText                 1011
#define idcServerText               1012
#define idcPreviewBtn               1013
#define idcSubscribe                1014
#define idcUnsubscribe              1015
#define idcTabs                     1016
#define idcStaticNewsServers        1017
#define idcStaticHorzLine           1019
#define idcGoto                     1020

enum { iTabAll = 0, iTabSubscribed, iTabNew, iTabMax };
enum { iCtlFindText = 0, iCtlUseDesc, iCtlGroupList, iCtlSubscribe, iCtlUnsubscribe,
       iCtlResetList, iCtlGoto, iCtlOK, iCtlCancel, iCtlServers, iCtlStaticNewsServers, 
       iCtlStaticHorzLine, iCtlTabs, iCtlMax };

HRESULT DoSubscriptionDialog(HWND hwnd, BOOL fNews, FOLDERID idFolder, BOOL fShowNew = FALSE);

#endif // __SUBSCR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\tbbands.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     itbar.h
//
//  PURPOSE:    Defines the CCoolbar class.
//

#ifndef __BANDS_H__
#define __BANDS_H__

#include "tbinfo.h"
#include "conman.h"

interface INotify;

#define BROWSERMENUBANDID        100
#define BROWSERTOOLBANDID        101
#define BROWSERBRANDBANDID       102
#define BROWSERRULESBANDID       103

#define NOTEMENUBANDID              100
#define NOTETOOLBANDID              101
#define NOTEBRANDBANDID             102


#define MAX_BROWSER_BANDS           4
#define MAX_NOTE_BANDS              3
#define MAX_PARENT_TYPES            2
#define MAX_BANDS                   5

#define BROWSER_BAND_VERSION        17
#define NOTE_BAND_VERSION           15

#define CIMLIST                     2

#define CBTYPE_NONE              0
#define CBTYPE_BASE              100
#define CBTYPE_BRAND             102
#define CBTYPE_TOOLS             101
#define CBTYPE_MENUBAND          100
#define CBTYPE_RULESTOOLBAR      103

#define TBSTATE_FULLTEXT         0x00000001
#define TBSTATE_NOTEXT           0x00000002
#define TBSTATE_PARTIALTEXT      0x00000004
#define TBSTATE_NOBACKGROUND     0x00000008
#define TBSTATE_ANIMATING        0x00000010
#define TBSTATE_INMENULOOP       0X00000020
#define TBSTATE_FIRSTFRAME       0x00000040
#define TEXTSTATE_MASK           0x11111118

#define LARGE_ICONS              0x00000001
#define SMALL_ICONS              0x00000002

//Parent Types
#define PARENT_TYPE_BROWSER         0
#define PARENT_TYPE_NOTE            1

#define idDownloadBegin         100
#define idDownloadEnd           101
#define idStateChange           102
#define idUpdateFolderList      103
#define idUpdateCurrentFolder   104
#define idSendToolMessage       105
#define idBitmapChange          106
#define idToggleButton          107
#define idCustomize             108
#define idNotifyFilterChange    109
#define idIsFilterBarVisible    110

// Dimensions of Coolbar Glyphs ..
#define TB_BMP_CX_W2K           22
#define TB_BMP_CX               24
#define TB_BMP_CY               24
#define TB_SMBMP_CX             16
#define TB_SMBMP_CY             16

// Max length of Button titles
#define MAX_TB_TEXT_LENGTH      256

#define MAX_TB_COMPRESSED_WIDTH 42
#define MAX_TB_TEXT_ROWS_VERT   2
#define MAX_TB_TEXT_ROWS_HORZ   1

#define ANIMATION_TIMER         123

// Child window id's
#define idcCoolbarBase          2000
#define idcSizer                (idcCoolbarBase - 2)
#define idcCoolbar              (idcCoolbarBase - 1)
#define idcToolbar              (idcCoolbarBase + CBTYPE_TOOLS)
#define idcBrand                (idcCoolbarBase + CBTYPE_BRAND)

// Number of Sites on the quick link bar and max number of toolbar buttons
#define MAX_TB_BUTTONS          10

// Indices for Toolbar imagelists
enum {
    IMLIST_DEFAULT = 0,
    IMLIST_HOT,
    CIMLISTS
};

// BANDSAVE &  - These structures are used to persist the state of the coolbar
// COOLBARSAVE   including the band order, visiblity, size, side, etc.
typedef struct tagBANDSAVE {
    DWORD           wID;
    DWORD           dwStyle;
    DWORD           cx;
} BANDSAVE, *PBANDSAVE;

typedef struct tagCOOLBARSTATECHANGE {
    UINT id;
    BOOL fEnable;
} COOLBARSTATECHANGE, *LPCOOLBARSTATECHANGE;

typedef struct tagCOOLBARBITMAPCHANGE {
    UINT id;
    UINT index;
} COOLBARBITMAPCHANGE;

typedef struct tagTOOLMESSAGE
{
    UINT uMsg;
    WPARAM wParam;
    LPARAM lParam;
    LRESULT lResult;
} TOOLMESSAGE;

typedef struct InitBandInfo_t
{
    DWORD       dwVersion;
    DWORD       cBands;
    BANDSAVE    BandData[MAX_BANDS];
}INITBANDINFO;

typedef struct ImageListTypes_t
{
    int         Small;
    int         High;
    int         Low;
}ImageListTypes;

//small is 16 x 16 16 colors
//hi    is 20x 20 256 colors
//lo    is 20 x 20 16 colors
#define MAX_IMAGELIST_TYPES     3
#define IMAGELIST_TYPE_SMALL    0
#define IMAGELIST_TYPE_HI       1
#define IMAGELIST_TYPE_LO       2

typedef struct ImageListStruct_t
{
    DWORD               cLists;
    int                 ImageListTable[MAX_IMAGELIST_TYPES];
}ImageListStruct;

enum 
{
    BRAND_SIZE_LARGE,
    BRAND_SIZE_SMALL,
    BRAND_SIZE_MINISCULE
};

class CBands : public IDockingWindow,
               public IObjectWithSite,
               public IConnectionNotify
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and initialization
    CBands();
    HRESULT HrInit(DWORD idBackground, HMENU    hmenu, DWORD    dwParentType);
    HRESULT ResetMenu(HMENU hmenu);

protected:
    virtual ~CBands();

public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow methods
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite methods
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    /////////////////////////////////////////////////////////////////////////
    // IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    /////////////////////////////////////////////////////////////////////////
    // This allows the view to send commands etc. to the toolbar
    virtual STDMETHODIMP Invoke(DWORD id, LPVOID pv);
    HRESULT SetFolderType(FOLDERTYPE ftType);

    virtual STDMETHODIMP OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    HRESULT Update();
    HRESULT UpdateViewState();
    HRESULT TranslateMenuMessage(MSG *lpmsg, LRESULT   *lpresult);
    HRESULT IsMenuMessage(MSG *lpmsg);
    void    SetNotRealSite();
    BOOL    CheckForwardWinEvent(HWND hwnd,  UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    HWND    GetToolbarWnd();
    HWND    GetRebarWnd();
    void    HideToolbar(BOOL    fVisible, DWORD    dwBandID = CBTYPE_TOOLS);
    void    SendSaveRestoreMessage(HWND hwnd, BOOL fSave);
    void    ChangeImages();
    void    TrackSliding(int x, int y);
    BOOL    IsToolbarVisible();
    BOOL    IsBandVisible(DWORD  dwBandId);
    void    CleanupImages(HWND  hwnd);
    void    CleanupImages();
    void    SetIconSize(DWORD  dw);
    void    UpdateTextSettings(DWORD  dwTextState);

protected:
    void StartDownload();
    void StopDownload();

    /////////////////////////////////////////////////////////////////////////
    // Window procedure and message handlers
    static LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam);
    virtual LRESULT OnNotify(HWND hwnd, LPARAM lparam);
    virtual void OnContextMenu(HWND hwndFrom, int xPos, int yPos);
    virtual LRESULT OnDropDown(HWND hwnd, LPNMHDR lpnmh);

    LRESULT OnGetButtonInfo(TBNOTIFY* ptbn);
    LRESULT OnGetInfoTip(LPNMTBGETINFOTIP   lpnmtb);

    /////////////////////////////////////////////////////////////////////////
    // Used for animating the logo to show progress
    HRESULT ShowBrand(void);
    HRESULT HandleStaticLogos(BOOL fSmallBrand);
    HRESULT LoadBrandingBitmap(void);    
    void    DrawBranding(LPDRAWITEMSTRUCT lpdis);

    /////////////////////////////////////////////////////////////////////////
    // For sizing etc.
    BOOL SetMinDimensions(void);    
    BOOL CompressBands(DWORD dwText);

    /////////////////////////////////////////////////////////////////////////
    // Initialization and persistance
    HRESULT CreateRebar(BOOL);
    void    SaveSettings(void);
    void    LoadBackgroundImage();
    HRESULT ValidateRetrievedData(INITBANDINFO *pSavedBandData);
    
    /////////////////////////////////////////////////////////////////////////
    // Toolbar Stuff
    HRESULT     AddTools(PBANDSAVE pbs);
    void        UpdateToolbarColors(void);

    HRESULT     CreateMenuBand(PBANDSAVE pbs);
    HRESULT     AddMenuBand(PBANDSAVE pbs);

    HMENU        LoadDefaultContextMenu(BOOL *fVisible);

    BOOL        _InitToolbar(HWND hwndToolbar);
    void        _LoadStrings(HWND hwndToolbar, TOOLBAR_INFO *pti);
    BOOL        _SetImages(HWND hwndToolbar, const int* imagelist);
    BOOL        _LoadDefaultButtons(HWND hwndToolbar, TOOLBAR_INFO *pti);
    BOOL        _ButtonInfoFromID(DWORD id, TBBUTTON *pButton, TOOLBAR_INFO *pti);
    HRESULT     Update(HWND     hwnd);

    //Rules/filters stuff
    HRESULT     AddRulesToolbar(PBANDSAVE pbs);
    HRESULT     AddComboBox();
    void        UpdateFilters(RULEID    rid);
    LRESULT     HandleComboBoxNotifications(WPARAM  wParam, LPARAM  lParam);
    void        FixComboBox(LPTSTR  szMaxName);
    void        InitRulesToolbar();
    void        CleanupRulesToolbar();
    void        FilterBoxFontChange();

    //Customize toolbar Stuff
    void    _OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm);
    static  INT_PTR CALLBACK _BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void    _PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources);
    void    _SetComboSelection(HWND hwnd, int iCurOption);
    void    _SetDialogSelections(HWND hDlg);
    void    _PopulateDialog(HWND hDlg);
    void    _UpdateTextSettings(int ids);
    inline  DWORD   _GetTextState();
    inline  DWORD   _GetIconSize();
    void    SetTextState(DWORD    dw);
    inline  void    _ChangeSendReceiveText(int ids);
    void    RecalcButtonWidths();
    void    CalcIdealSize();

    /////////////////////////////////////////////////////////////////////////
    // Misc. stuff
    UINT                m_cRef;              // Ref count
    IDockingWindowSite  *m_ptbSite;
    IOleCommandTarget   *m_ptbSiteCT;
    LONG                m_cxMaxButtonWidth;    
    FOLDERTYPE          m_ftType;
    const TOOLBAR_INFO  *m_pTBInfo;
    
    /////////////////////////////////////////////////////////////////////////
    // Handy window handles to have around
    HWND            m_hwndParent;
    HWND            m_hwndTools;
    HWND            m_hwndBrand;
    HWND            m_hwndSizer;
    HWND            m_hwndRebar;

    /////////////////////////////////////////////////////////////////////////
    // State variables
    INITBANDINFO    *m_pSavedBandInfo;
    DWORD           m_cSavedBandInfo;
    DWORD           m_dwState;

    /////////////////////////////////////////////////////////////////////////
    // GDI Resources
    UINT            m_idbBack;              // Id of the background bitmap.  Set by the subclasses.
    HBITMAP         m_hbmBack;              // Background bitmap
    HBITMAP         m_hbmBrand;
    HIMAGELIST      m_rghimlTools[CIMLISTS];  // These are for the default toolbar

    /////////////////////////////////////////////////////////////////////////
    // Used for animating the logo etc
    HPALETTE        m_hpal;
    HDC             m_hdc;
    int             m_xOrg;
    int             m_yOrg;
    int             m_cxBmp;
    int             m_cyBmp;
    int             m_cxBrand;
    int             m_cyBrand;
    int             m_cxBrandExtent;
    int             m_cyBrandExtent;
    int             m_cyBrandLeadIn;
    COLORREF        m_rgbUpperLeft;  

    /////////////////////////////////////////////////////////////////////////
    // Used in resizing etc
    int             m_xCapture;
    int             m_yCapture;

    //Used by Menubands
    IShellMenu      *m_pShellMenu;
    IDeskBand       *m_pDeskBand;
    IMenuBand       *m_pMenuBand;
    HMENU           m_hMenu;
    IWinEventHandler *m_pWinEvent;
    HWND            m_hwndMenuBand;

    //Used in new Bands
    DWORD           m_dwParentType;

    BOOL            m_fBrandLoaded;
    DWORD           m_dwBrandSize;

    //rules stuff
    HWND            m_hwndRulesToolbar;
    HWND            m_hwndFilterCombo;
    RULEID          m_DefaultFilterId;
    HFONT           m_hComboBoxFont;

    //Customize
    DWORD           m_dwToolbarTextState;
    DWORD           m_dwIconSize;
    BOOL            m_fDirty;
    DWORD           m_dwPrevTextStyle;
    INotify         *m_pTextStyleNotify;
    };


#endif //__BANDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\tbinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     tbinfo.cpp
//
//  PURPOSE:    This file contains all of the toolbar arrays used by the
//              various coolbars in the program.
//

#include "pch.hxx"
#include "strconst.h"
#include "menures.h"
#include "tbinfo.h"

/////////////////////////////////////////////////////////////////////////////
// Here are the full list of buttons.  Please try to keep this alphabetized
// by the tooltip name if at all possible.
//

const BUTTON_INFO c_rgAllButtons[] = {
      // Command ID               // Image Index                // Style            // Tooltip              // Button Name          // Text for Small Icons
    { ID_ADDRESS_BOOK,            TBIMAGE_ADDRESS_BOOK,         TBSTYLE_BUTTON,         idsAddressBookTT,       idsAddressesBtn,        0 },    
    { ID_CANCEL_MESSAGE,          TBIMAGE_CANCEL_MESSAGE,       TBSTYLE_BUTTON,         idsCancelArticle,       idsCancelBtn,           0 },    
    { ID_COMBINE_AND_DECODE,      TBIMAGE_COMBINE_AND_DECODE,   TBSTYLE_BUTTON,         idsCombineAndDecodeTT,  idsDecodeBtn,           0 },
    { ID_CONTACTS_LIST,           TBIMAGE_CONTACTS_LIST,        TBSTYLE_CHECK,          idsBAControlTT,         idsBAControlTT,         0 },
    { ID_COPY_TO_FOLDER,          TBIMAGE_COPY_TO_FOLDER,       TBSTYLE_BUTTON,         idsCopyTo,              idsCopyTo,              0 },
    { ID_DELETE_ACCEL,            TBIMAGE_DELETE,               TBSTYLE_BUTTON,         idsDelete,              idsDelete,              0 },
    { ID_POPUP_LANGUAGE,          TBIMAGE_LANGUAGE,             TBSTYLE_BUTTON | BTNS_WHOLEDROPDOWN,       idsLanguage,            idsLanguage,            0 },
    { ID_FIND_MESSAGE,            TBIMAGE_FIND,                 TBSTYLE_DROPDOWN,       idsFind,                idsFind,                0 },
    { ID_FOLDER_LIST,             TBIMAGE_FOLDER_LIST,          TBSTYLE_CHECK,          idsFolderListTT,        idsFolderListTT,        0 },
    { ID_FORWARD,                 TBIMAGE_FORWARD,              PARTIALTEXT_BUTTON,     idsForwardTT,           idsForwardTT,           1 },
    { ID_GET_HEADERS,             TBIMAGE_GET_HEADERS,          TBSTYLE_BUTTON,         idsGetNextTT,           idsGetHeadersBtn,       0 },
    { ID_GO_INBOX,                TBIMAGE_GO_INBOX,             TBSTYLE_BUTTON,         idsGotoInboxTT,         idsInboxBtn,            0 },
    { ID_GO_OUTBOX,               TBIMAGE_GO_OUTBOX,            TBSTYLE_BUTTON,         idsGotoOutbox,          idsOutboxBtn,           0 },
    { ID_GO_SENT_ITEMS,           TBIMAGE_GO_SENT_ITEMS,        TBSTYLE_BUTTON,         idsGoToSentItems,       idsSentItemsBtn,        0 },
    { ID_HELP_CONTENTS,           TBIMAGE_HELP,                 TBSTYLE_BUTTON,         idsHelp,                idsHelp,                0 },
    { ID_IMAP_FOLDERS,            TBIMAGE_IMAP_FOLDERS,         TBSTYLE_BUTTON,         idsIMAPFoldersTT,       idsIMAPFoldersTT,       0 },
    { ID_MARK_ALL_READ,           TBIMAGE_MARK_ALL_READ,        TBSTYLE_BUTTON,         idsMarkAllRead,         idsMarkAllBtn,          0 },
    { ID_MARK_RETRIEVE_MESSAGE,   TBIMAGE_MARK_DOWNLOAD,        TBSTYLE_BUTTON,         idsMarkDownload,        idsMarkOfflineBtn,      0 },
    { ID_MARK_READ,               TBIMAGE_MARK_READ,            TBSTYLE_BUTTON,         idsMarkRead,            idsMarkReadBtn,         0 },
    { ID_MARK_THREAD_READ,        TBIMAGE_MARK_THREAD_READ,     TBSTYLE_BUTTON,         idsMarkTopicReadTT,     idsMarkThreadBtn,       0 },
    { ID_MARK_UNREAD,             TBIMAGE_MARK_UNREAD,          TBSTYLE_BUTTON,         idsMarkUnread,          idsMarkUnread,          0 },
    { ID_MOVE_TO_FOLDER,          TBIMAGE_MOVE_TO_FOLDER,       TBSTYLE_BUTTON,         idsMoveTo,              idsMoveTo,              0 },
    { ID_NEW_MAIL_MESSAGE,        TBIMAGE_NEW_MESSAGE,          TBSTYLE_DROPDOWN,       idsNewMsg,              idsNewMailBtn,          0 },
    { ID_NEW_NEWS_MESSAGE,        TBIMAGE_NEW_POST,             TBSTYLE_DROPDOWN,       idsNewMsg,              idsNewNewsBtn,          0 },
    { ID_NEWSGROUPS,              TBIMAGE_NEWSGROUPS,           TBSTYLE_BUTTON,         idsNewsgroups,          idsNewsgroups,          0 },
    { ID_NEXT_UNREAD_MESSAGE,     TBIMAGE_NEXT_UNREAD_MESSAGE,  TBSTYLE_BUTTON,         idsNextUnreadArticle,   idsNextUnreadBtn,       0 },
    { ID_NEXT_UNREAD_FOLDER,      TBIMAGE_NEXT_UNREAD_FOLDER,   TBSTYLE_BUTTON,         idsNextUnreadNewsgroup, idsNextFolderBtn,       0 },
    { ID_NEXT_UNREAD_THREAD,      TBIMAGE_NEXT_UNREAD_THREAD,   TBSTYLE_BUTTON,         idsNextUnreadTopic,     idsNextThreadBtn,       0 },
    { ID_PREVIEW_PANE,            TBIMAGE_PREVIEW_PANE,         TBSTYLE_DROPDOWN,       idsPreviewPane,         idsPreviewPane,         0 },
    { ID_PRINT,                   TBIMAGE_PRINT,                TBSTYLE_BUTTON,         idsPrint,               idsPrint,               0 },
    { ID_PURGE_DELETED,           TBIMAGE_PURGE_DELETED,        TBSTYLE_BUTTON,         idsPurgeTT,             idsPurgeBtn,            0 },
    { ID_REFRESH,                 TBIMAGE_REFRESH,              TBSTYLE_BUTTON,         idsViewRefreshTT,       idsViewRefreshTT,       0 },
    { ID_REPLY,                   TBIMAGE_REPLY,                PARTIALTEXT_BUTTON,     idsReply,               idsReplyBtn,            1 },
    { ID_REPLY_ALL,               TBIMAGE_REPLY_ALL,            PARTIALTEXT_BUTTON,     idsReplyAll,            idsReplyAllBtn,         1 },
    { ID_REPLY_GROUP,             TBIMAGE_REPLY_GROUP,          PARTIALTEXT_BUTTON,     idsReplyPostTT,         idsReplyGroupBtn,       1 },
    { ID_SAVE_AS,                 TBIMAGE_SAVE_AS,              TBSTYLE_BUTTON,         idsSaveAs,              idsSaveAs,              0 },
    { ID_SEND_RECEIVE,            TBIMAGE_SEND_RECEIVE,         PARTIALTEXT_DROPDOWN,   idsDeliverMailTT,       idsSendReceiveBtn,      1 },
    { ID_STOP,                    TBIMAGE_STOP,                 TBSTYLE_BUTTON,         idsStopTT,              idsStopTT,              0 },
    { ID_SYNCHRONIZE,             TBIMAGE_SYNCHRONIZE,          TBSTYLE_BUTTON,         idsPostAndDownloadTT,   idsPostAndDownloadTT,   0 },
    { ID_UNDELETE,                TBIMAGE_UNDELETE,             TBSTYLE_BUTTON,         idsUndeleteTT,          idsUndeleteTT,          0 },
    { ID_UNSCRAMBLE,              TBIMAGE_UNSCRAMBLE,           TBSTYLE_BUTTON,         idsUnscrambleTT,        idsUnscrambleTT,        0 },
    { ID_WORK_OFFLINE,            TBIMAGE_WORK_OFFLINE,         TBSTYLE_CHECK,          idsWorkOffline,         idsOfflineBtn,          0 }
};


///////////////////////////////////////////////////////////////////////////////
// These are the default buttons for each view.  -1 are of course seperators.
//

// Front Page
const DWORD c_rgRootDefault[] = 
{
    ID_NEW_MAIL_MESSAGE,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE
};

// Local Folders
const DWORD c_rgLocalDefault[] = 
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE
};

// Local Folders International
const DWORD c_rgLocalDefaultIntl[] = 
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    -1,
    ID_POPUP_LANGUAGE
};

// News Folders
const DWORD c_rgNewsDefault[] = 
{
    ID_NEW_NEWS_MESSAGE,
    ID_REPLY_GROUP,
    ID_REPLY,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_STOP,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    ID_NEWSGROUPS,
    ID_GET_HEADERS
};

// News Folders International
const DWORD c_rgNewsDefaultIntl[] = 
{
    ID_NEW_NEWS_MESSAGE,
    ID_REPLY_GROUP,
    ID_REPLY,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_STOP,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    ID_NEWSGROUPS,
    ID_GET_HEADERS,
    -1,
    ID_POPUP_LANGUAGE
};

// IMAP Folders
const DWORD c_rgIMAPDefault[] = 
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    ID_PURGE_DELETED,
    ID_IMAP_FOLDERS
};

// IMAP Folders International
const DWORD c_rgIMAPDefaultIntl[] = 
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    ID_PURGE_DELETED,
    ID_IMAP_FOLDERS,
    -1,
    ID_POPUP_LANGUAGE
};

// HTTPMail Folders
const DWORD c_rgHTTPDefault[] =
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
};

// IMAP Folders International
const DWORD c_rgHTTPDefaultIntl[] =  
{
    ID_NEW_MAIL_MESSAGE,
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_DELETE_ACCEL,
    -1,
    ID_SEND_RECEIVE,
    -1,
    ID_ADDRESS_BOOK,
    ID_FIND_MESSAGE,
    -1,
    ID_POPUP_LANGUAGE
};


/////////////////////////////////////////////////////////////////////////////
// Read Notes
//

const BUTTON_INFO c_rgAllReadNoteButtons[] = {
      // Command ID               // Image Index                // Style            // Tooltip              // Button Name
    { ID_ADDRESS_BOOK,            TBIMAGE_ADDRESS_BOOK,         TBSTYLE_BUTTON,         idsAddressBookTT,       idsAddressesBtn,        0 },    
    { ID_NOTE_COPY_TO_FOLDER,     TBIMAGE_COPY_TO_FOLDER,       TBSTYLE_BUTTON,         idsCopyTo,              idsCopyTo,              0 },
    { ID_NOTE_DELETE,             TBIMAGE_DELETE,               TBSTYLE_BUTTON,         idsDelete,              idsDelete,              0 },
    { ID_POPUP_LANGUAGE,          TBIMAGE_LANGUAGE,             TBSTYLE_BUTTON | BTNS_WHOLEDROPDOWN,       idsLanguage,            idsLanguage,            0 },
    { ID_FORWARD,                 TBIMAGE_FORWARD,              PARTIALTEXT_BUTTON,     idsForwardTT,           idsForwardTT,           1 },
    { ID_HELP_CONTENTS,           TBIMAGE_HELP,                 TBSTYLE_BUTTON,         idsHelp,                idsHelp,        0 },
    { ID_MARK_THREAD_READ,        TBIMAGE_MARK_THREAD_READ,     TBSTYLE_BUTTON,         idsMarkTopicReadTT,     idsMarkThreadBtn,       0 },
    { ID_NOTE_MOVE_TO_FOLDER,     TBIMAGE_MOVE_TO_FOLDER,       TBSTYLE_BUTTON,         idsMoveTo,              idsMoveTo,              0 },
    { ID_NEXT_MESSAGE,            TBIMAGE_NEXT,                 TBSTYLE_BUTTON,         idsNextTT,              idsNextTT,              0 },
    { ID_NEXT_UNREAD_MESSAGE,     TBIMAGE_NEXT_UNREAD_MESSAGE,  TBSTYLE_BUTTON,         idsNextUnreadArticle,   idsNextUnreadBtn,       0 },
    { ID_NEXT_UNREAD_THREAD,      TBIMAGE_NEXT_UNREAD_THREAD,   TBSTYLE_BUTTON,         idsNextUnreadTopic,     idsNextThreadBtn,       0 },
    { ID_PREVIOUS,                TBIMAGE_PREVIOUS,             TBSTYLE_BUTTON,         idsPreviousTT,          idsPreviousTT,          0 },
    { ID_PRINT,                   TBIMAGE_PRINT,                TBSTYLE_BUTTON,         idsPrint,               idsPrint,               0 },
    { ID_REPLY,                   TBIMAGE_REPLY,                PARTIALTEXT_BUTTON,     idsReply,               idsReplyBtn,            1 },
    { ID_REPLY_ALL,               TBIMAGE_REPLY_ALL,            PARTIALTEXT_BUTTON,     idsReplyAll,            idsReplyAllBtn,         1 },
    { ID_REPLY_GROUP,             TBIMAGE_REPLY_GROUP,          PARTIALTEXT_BUTTON,     idsReplyPostTT,         idsReplyGroupBtn,       1 },
    { ID_NOTE_SAVE_AS,            TBIMAGE_SAVE_AS,              TBSTYLE_BUTTON,         idsSaveAs,              idsSaveAs,              0 },
    { ID_UNSCRAMBLE,              TBIMAGE_UNSCRAMBLE,           TBSTYLE_BUTTON,         idsUnscrambleTT,        idsUnscrambleTT,        0 }
};

/////////////////////////////////////////////////////////////////////////////
// These are the defaults for mail and news notes
//

const DWORD c_rgMailReadDefault[] = 
{
    ID_REPLY,
    ID_REPLY_ALL,
    ID_FORWARD,
    -1,
    ID_PRINT,
    ID_NOTE_DELETE,
    -1,
    ID_PREVIOUS,
    ID_NEXT_MESSAGE,
    -1,
    ID_ADDRESS_BOOK
};

const DWORD c_rgNewsReadDefault[] = 
{
    ID_REPLY_GROUP,
    ID_REPLY,
    ID_FORWARD,
    -1,
    ID_PRINT,
    -1,
    ID_PREVIOUS,
    ID_NEXT_MESSAGE,
    -1,
    ID_ADDRESS_BOOK
};

/////////////////////////////////////////////////////////////////////////////
// Send Notes
//

const BUTTON_INFO c_rgAllSendNoteButtons[] = {
      // Command ID               // Image Index                // Style                // Tooltip              // Button Name
    { ID_INSERT_ATTACHMENT,       TBIMAGE_INSERT_ATTACHMENT,    TBSTYLE_BUTTON,         idsInsertFileTT,        idsAttachBtn,           0 },    
    { ID_CHECK_NAMES,             TBIMAGE_CHECK_NAMES,          TBSTYLE_BUTTON,         idsCheckNamesTT,        idsCheckBtn,            0 },
    { ID_NOTE_COPY,               TBIMAGE_COPY,                 TBSTYLE_BUTTON,         idsCopy,                idsCopy,                0 },
    { ID_POPUP_LANGUAGE,          TBIMAGE_LANGUAGE,             TBSTYLE_BUTTON | BTNS_WHOLEDROPDOWN,       idsLanguage,            idsLanguage,            0 },
    { ID_CUT,                     TBIMAGE_CUT,                  TBSTYLE_BUTTON,         idsCutTT,               idsCutTT,               0 },
    { ID_DIGITALLY_SIGN,          TBIMAGE_SIGNED,               TBSTYLE_BUTTON,         idsDigSignTT,           idsDigSignBtn,          0 },
    { ID_ENCRYPT,                 TBIMAGE_SECURITY_POPUP,       TBSTYLE_BUTTON,         idsEncryptTT,           idsEncryptBtn,          0 },
    { ID_PASTE,                   TBIMAGE_PASTE,                TBSTYLE_BUTTON,         idsPasteTT,             idsPasteTT,             0 },
    { ID_SET_PRIORITY,            TBIMAGE_SET_PRIORITY,         TBSTYLE_DROPDOWN,       idsSetPriorityTT,       idsPriorityBtn,         0 },
    { ID_SELECT_RECIPIENTS,       TBIMAGE_ENVELOPE_BCC,         TBSTYLE_BUTTON,         idsPickRecipientsTT,    idsRecipBtn,            0 },
    { ID_SEND_DEFAULT,            TBIMAGE_SEND_MAIL,            PARTIALTEXT_BUTTON,     idsSendMsgTT,           idsSendMsgTT,           1 },
    { ID_INSERT_SIGNATURE,        TBIMAGE_INSERT_SIG,           TBSTYLE_DROPDOWN,       idsInsertSigTT,         idsInsertSigTT,         0 },
    { ID_SPELLING,                TBIMAGE_SPELLING,             TBSTYLE_BUTTON,         idsSpellingTT,          idsSpellingTT,          0 },
    { ID_UNDO,                    TBIMAGE_UNDO,                 TBSTYLE_BUTTON,         idsUndoTT,              idsUndoTT,              0 },
    { ID_WORK_OFFLINE,            TBIMAGE_WORK_OFFLINE,         TBSTYLE_CHECK,          idsWorkOffline,         idsOfflineBtn,          0 }
};


/////////////////////////////////////////////////////////////////////////////
// These are the defaults for mail and news notes
//

const DWORD c_rgMailSendDefault[] = 
{
    ID_SEND_DEFAULT,
    -1,
    ID_CUT,
    ID_NOTE_COPY,
    ID_PASTE,
    ID_UNDO,
    -1,
    ID_CHECK_NAMES,
    ID_SPELLING,
    -1,
    ID_INSERT_ATTACHMENT,
    ID_SET_PRIORITY,
    -1,
    ID_DIGITALLY_SIGN,
    ID_ENCRYPT,
    ID_WORK_OFFLINE
};

const DWORD c_rgNewsSendDefault[] = 
{
    ID_SEND_DEFAULT,
    -1,
    ID_CUT,
    ID_NOTE_COPY,
    ID_PASTE,
    ID_UNDO,
    -1,
    ID_CHECK_NAMES,
    ID_SPELLING,
    -1,
    ID_INSERT_ATTACHMENT,
    -1,
    ID_DIGITALLY_SIGN,
    ID_WORK_OFFLINE
};


/////////////////////////////////////////////////////////////////////////////
// Rules toolbar is easy
//

const BUTTON_INFO c_rgRulesButtons[] = 
{
      // Command ID     // Image Index             // Style                           // Tooltip              // Button Name
    { ID_CREATE_FILTER, TBIMAGE_INSERT_ATTACHMENT, TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE, idsCreateFilter,        idsCreateFilter, 0 }
};

const DWORD c_rgRulesDefault[] = 
{
    -1,
  //      ID_CREATE_FILTER
};



/////////////////////////////////////////////////////////////////////////////
// Here's the big map of toolbars, defaults, reg keys, etc.
//

#define MAKE_TOOLBAR_INFO(all, def, intl, key, value) { all, ARRAYSIZE(all), def, ARRAYSIZE(def), intl, ARRAYSIZE(intl), key, value }

// Note - the order here must match the order of the FOLDER_TYPE enumeration in hotstore.idl.
const TOOLBAR_INFO c_rgBrowserToolbarInfo[FOLDER_TYPESMAX] = 
{
    MAKE_TOOLBAR_INFO( c_rgAllButtons, c_rgNewsDefault,  c_rgNewsDefaultIntl,  c_szRegPathNews, c_szRegToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllButtons, c_rgIMAPDefault,  c_rgIMAPDefaultIntl,  c_szRegPathIMAP, c_szRegToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllButtons, c_rgHTTPDefault,  c_rgHTTPDefaultIntl,  c_szRegPathHTTP, c_szRegToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllButtons, c_rgLocalDefault, c_rgLocalDefaultIntl, c_szRegPathMail, c_szRegToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllButtons, c_rgRootDefault,  c_rgRootDefault,      NULL,            c_szRegToolbar )
};


const TOOLBAR_INFO c_rgNoteToolbarInfo[NOTETYPES_MAX] =
{
    MAKE_TOOLBAR_INFO( c_rgAllReadNoteButtons,  c_rgMailReadDefault, c_rgMailReadDefault, c_szRegPathNoteMail,   c_szRegMailReadToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllSendNoteButtons,  c_rgMailSendDefault, c_rgMailSendDefault, c_szRegPathNoteMail,   c_szRegMailSendToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllReadNoteButtons,  c_rgNewsReadDefault, c_rgNewsReadDefault, c_szRegPathNoteNews,   c_szRegNewsReadToolbar ),
    MAKE_TOOLBAR_INFO( c_rgAllSendNoteButtons,  c_rgNewsSendDefault, c_rgNewsSendDefault, c_szRegPathNoteNews,   c_szRegNewsSendToolbar )
};

const TOOLBAR_INFO c_rgRulesToolbarInfo[] = 
{
    MAKE_TOOLBAR_INFO( c_rgRulesButtons,        c_rgRulesDefault,    c_rgRulesDefault,    NULL,                  NULL )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\tbinfo.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     tbinfo.h
//
//  PURPOSE:    This file contains all of the toolbar arrays used by the
//              various coolbars in the program.
//

#pragma once

#ifndef __TBINFO_H__
#define __TBINFO_H__

/////////////////////////////////////////////////////////////////////////////
// BUTTON_INFO definition
//

typedef struct tagBUTTON_INFO 
{
    DWORD   idCmd;
    DWORD   iImage;
    BYTE    fStyle;
    DWORD   idsTooltip;
    DWORD   idsButton;
    BYTE    fTextOnSmall;
} BUTTON_INFO;

#define  PARTIALTEXT_BUTTON     (TBSTYLE_BUTTON | BTNS_SHOWTEXT)
#define  PARTIALTEXT_DROPDOWN   (TBSTYLE_DROPDOWN | BTNS_SHOWTEXT)

/////////////////////////////////////////////////////////////////////////////
// TOOLBAR_INFO definition
//

typedef struct tagTOOLBAR_INFO
{
    const BUTTON_INFO  *rgAllButtons;
    DWORD               cAllButtons;
    const DWORD        *rgDefButtons;
    DWORD               cDefButtons;
    const DWORD        *rgDefButtonsIntl;
    DWORD               cDefButtonsIntl;
    LPCTSTR             pszRegKey;
    LPCTSTR             pszRegValue;
} TOOLBAR_INFO;


extern const TOOLBAR_INFO c_rgBrowserToolbarInfo[FOLDER_TYPESMAX];
extern const TOOLBAR_INFO c_rgNoteToolbarInfo[NOTETYPES_MAX];
extern const TOOLBAR_INFO c_rgRulesToolbarInfo[1];

#endif // __TBINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\tbbands.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     bands.cpp
//
//  PURPOSE:    Implements the sizable coolbar window.
//



#include "pch.hxx"
#include "ourguid.h"    
#include "browser.h"
#include <resource.h>
#include "tbbands.h"
#include "strconst.h"
#include "thormsgs.h"
#include <error.h>
#include "xpcomm.h"
#include "conman.h"
#include "mailnews.h"
#include "htmlhelp.h"
#include "statnery.h"
#include "goptions.h"
#include "menuutil.h"
#include "menures.h"
#include <shlobjp.h>
#include <ieguidp.h>
#include "mbcallbk.h"
#include "baui.h"
#include "imsgsite.h"
#include "acctutil.h"
#include "tbinfo.h"
#include "tbcustom.h"
#include "oerules.h"
#include <notify.h>
#include "demand.h"
#include "mirror.h"

UINT GetCurColorRes(void);

#define RECTWIDTH(rc)   (rc.right - rc.left)
#define RECTHEIGHT(rc)  (rc.bottom - rc.top)
#define SZ_PROP_CUSTDLG     TEXT("Itbar custom dialog hwnd")

const INITBANDINFO c_DefaultTable[MAX_PARENT_TYPES] = 
    { 
    //Version, #bands, 
    {BROWSER_BAND_VERSION, 4,   {     
                                {CBTYPE_MENUBAND,     RBBS_GRIPPERALWAYS | RBBS_USECHEVRON, 100},
                                {CBTYPE_BRAND,        RBBS_FIXEDSIZE, 100},
                                {CBTYPE_TOOLS,        RBBS_BREAK | RBBS_USECHEVRON, 100},
                                {CBTYPE_RULESTOOLBAR, RBBS_BREAK | RBBS_HIDDEN, 100}
                                }
                            
    }, 
    {NOTE_BAND_VERSION, 3,      {      
                                {CBTYPE_MENUBAND,   RBBS_GRIPPERALWAYS | RBBS_USECHEVRON, 100},
                                {CBTYPE_BRAND,      RBBS_FIXEDSIZE, 100},
                                {CBTYPE_TOOLS,      RBBS_BREAK | RBBS_USECHEVRON, 100}
                                }
    }
    };

//Table for RegKeys
const LPCTSTR   c_BandRegKeyInfo[] = {
    c_szRegBrowserBands, 
    c_szRegNoteBands
    };

const TOOLBAR_INFO* c_DefButtonInfo[MAX_PARENT_TYPES] = {
    c_rgBrowserToolbarInfo,
    c_rgNoteToolbarInfo
    };

//Hot bitmap ids are def + 1
//Small, HI, Lo
const ImageListStruct c_ImageListStruct[MAX_PARENT_TYPES] = {
    {2, {idbSmBrowser, idb256Browser, idbBrowser}},
    {2, {idbSmBrowser, idb256Browser, idbBrowser}}
    };

const ImageListStruct c_NWImageListStruct[MAX_PARENT_TYPES] = {
    {2, {idbNWSmBrowser, idbNW256Browser, idbNWBrowser}},
    {2, {idbNWSmBrowser, idbNW256Browser, idbNWBrowser}}
    };

const ImageListStruct c_32ImageListStruct[MAX_PARENT_TYPES] = {
    {2, {idb32SmBrowser, idb32256Browser, idbBrowser}},
    {2, {idb32SmBrowser, idb32256Browser, idbBrowser}}
    };

const int   c_RulesImageList[3] = 
{
    idbSmRulesTB, idbHiRulesTB, idbLoRulesTB 
};

const int   c_NWRulesImageList[3] = 
{
    idbNWSmRulesTB, idbNWHiRulesTB, idbNWLoRulesTB 
};

const int   c_32RulesImageList[3] = 
{
    idb32SmRulesTB, idb32HiRulesTB, idb32LoRulesTB 
};

CBands::CBands() : m_cRef(1), m_yCapture(-1)
{
    DOUTL(1, TEXT("ctor CBands %x"), this);
    
    m_cRef          = 1;
    m_ptbSite       = NULL;
    m_ptbSiteCT     = NULL;
    m_cxMaxButtonWidth = 70;
    m_ftType = FOLDER_TYPESMAX;    
    m_hwndParent = NULL;
    m_hwndTools = NULL;
    m_hwndBrand = NULL;
    m_hwndSizer = NULL;
    m_hwndRebar = NULL;
    m_dwState = 0;
    
    m_idbBack = 0;
    m_hbmBack = NULL;
    m_hbmBrand = NULL;
    Assert(2 == CIMLISTS);

    m_hpal = NULL;
    m_hdc = NULL;
    m_xOrg = 0;
    m_yOrg = 0;
    m_cxBmp = 0;
    m_cyBmp = 0;
    m_cxBrand = 0;
    m_cyBrand = 0;
    m_cxBrandExtent = 0;
    m_cyBrandExtent = 0;
    m_cyBrandLeadIn = 0;
    m_rgbUpperLeft = 0;
    m_pSavedBandInfo = NULL;

    m_pMenuBand  = NULL;
    m_pDeskBand  = NULL;
    m_pShellMenu = NULL;
    m_pWinEvent  = NULL;
    m_xCapture = -1;
    m_yCapture = -1;
    
    // Bug #12953 - Try to load the localized max button width from the resources
    TCHAR szBuffer[32];
    if (AthLoadString(idsMaxCoolbarBtnWidth, szBuffer, ARRAYSIZE(szBuffer)))
    {
        m_cxMaxButtonWidth = StrToInt(szBuffer);
        if (m_cxMaxButtonWidth == 0)
            m_cxMaxButtonWidth = 70;
    }

    m_fBrandLoaded = FALSE;
    m_dwBrandSize  = BRAND_SIZE_SMALL;

    m_hwndRulesToolbar = NULL;
    m_hwndFilterCombo  = NULL;

    m_dwToolbarTextState        = TBSTATE_FULLTEXT;
    m_dwIconSize                = LARGE_ICONS;
    m_fDirty                    = FALSE;
    m_dwPrevTextStyle           = TBSTATE_FULLTEXT;
    m_pTextStyleNotify          = NULL; 

    m_hComboBoxFont = 0;
}


CBands::~CBands()
{
    int i;
    
    DOUTL(1, TEXT("dtor CBands %x"), this);
    
    if (m_ptbSite)
    {
        AssertSz(m_ptbSite == NULL, _T("CBands::~CBands() - For some reason ")
            _T("we still have a pointer to the site."));
        m_ptbSite->Release();
        m_ptbSite = NULL;
    }
    
    if (m_hpal)
        DeleteObject(m_hpal);
    if (m_hdc)
        DeleteDC(m_hdc);
    if (m_hbmBrand)
        DeleteObject(m_hbmBrand);
    if ( m_hbmBack )
        DeleteObject(m_hbmBack);
    
    SafeRelease(m_pDeskBand);
    SafeRelease(m_pMenuBand);
    SafeRelease(m_pWinEvent);
    SafeRelease(m_pShellMenu);
    SafeRelease(m_pTextStyleNotify);

    if (m_pSavedBandInfo)
        MemFree(m_pSavedBandInfo);

    if (m_hComboBoxFont != 0)
        DeleteObject(m_hComboBoxFont);
}


//
//  FUNCTION:   CBands::HrInit()
//
//  PURPOSE:    Initializes the coolbar with the information needed to load
//              any persisted reg settings and the correct arrays of buttons
//              to display.
//
//  PARAMETERS:
//      <in> idBackground - Resource ID of the background bitmap to use.
//
//  RETURN VALUE:
//      S_OK - Everything initialized correctly.
//
HRESULT CBands::HrInit(DWORD idBackground, HMENU hmenu, DWORD dwParentType)
{
    DWORD   cbData;
    DWORD   dwType;
    LRESULT lResult;
    HRESULT hr;

    if ((int)idBackground == -1)
        SetFlag(TBSTATE_NOBACKGROUND);

    m_idbBack       = idBackground;
    m_hMenu         = hmenu;
    m_dwParentType    = dwParentType;
    
    m_cSavedBandInfo = ((c_DefaultTable[m_dwParentType].cBands * sizeof(BANDSAVE)) + sizeof(DWORD) * 2);

    if (MemAlloc((LPVOID*)&m_pSavedBandInfo, m_cSavedBandInfo))
    {
        ZeroMemory(m_pSavedBandInfo, m_cSavedBandInfo);

        cbData = m_cSavedBandInfo;
        lResult = AthUserGetValue(NULL, c_BandRegKeyInfo[m_dwParentType], &dwType, (LPBYTE)m_pSavedBandInfo, &cbData); 
        if ((lResult != ERROR_SUCCESS) || (m_pSavedBandInfo->dwVersion != c_DefaultTable[m_dwParentType].dwVersion))
        {
            //Set up default bands
            CopyMemory(m_pSavedBandInfo, &c_DefaultTable[m_dwParentType], 
                m_cSavedBandInfo);

            //Set Icon size to Large
            m_dwIconSize = LARGE_ICONS;

        }
        else
        {
            //Validate the data we retrieved from the registry
            ValidateRetrievedData(m_pSavedBandInfo);

            cbData = sizeof(DWORD);
            if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRegToolbarIconSize, &dwType, (LPBYTE)&m_dwIconSize, &cbData))
                m_dwIconSize = LARGE_ICONS;
        }

        //If there is one, load it.
        LoadBackgroundImage();

        cbData = sizeof(DWORD);

        if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRegPrevToolbarText, &dwType, (LPBYTE)&m_dwPrevTextStyle, 
                                             &cbData))
        {
            m_dwPrevTextStyle = TBSTATE_FULLTEXT;
        }

        DWORD   dwState;
        if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRegToolbarText, &dwType, (LPBYTE)&dwState, &cbData)) 
        {
            SetTextState(TBSTATE_FULLTEXT);
        }
        else
        {
            SetTextState(dwState);
        }

        //Create notification object
        hr = CreateNotify(&m_pTextStyleNotify);
        if (SUCCEEDED(hr))
        {
            hr = m_pTextStyleNotify->Initialize((TCHAR*)c_szToolbarNotifications);
        }

        return hr;    
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}    

HRESULT CBands::ValidateRetrievedData(INITBANDINFO *pSavedBandData)
{
    DWORD       i = 0; 
    DWORD       j = 0;

    //We reach here if the version number is the same. So we just need to verify the rest of the data

    //We should definitely find MenuBandID. If we do find it, it should never be hidden
    DOUTL(16, "Validating Retrieved Data\n");

    // Make sure that the number of bands is greater than zero.
    if (pSavedBandData->cBands == 0)
    {
        // Structure has no bands, so this must be invalid and we fall back on the defaults.
        CopyMemory(pSavedBandData, &c_DefaultTable[m_dwParentType], m_cSavedBandInfo);
        return (S_OK);
    }

    if (pSavedBandData)
    {
        for (i = 0; i < c_DefaultTable[m_dwParentType].cBands; i++)
        {
            for (j = 0; j < c_DefaultTable[m_dwParentType].cBands; j++)
            {
                if (c_DefaultTable[m_dwParentType].BandData[i].wID == pSavedBandData->BandData[j].wID)
                {
                    if ((pSavedBandData->BandData[j].wID == CBTYPE_MENUBAND) && 
                        (!!(pSavedBandData->BandData[j].dwStyle & RBBS_HIDDEN)))
                    {
                        DOUTL(16, "Menuband was found hidden\n");

                        //If the Menuband style is hidden, mask it
                        pSavedBandData->BandData[j].dwStyle &= ~RBBS_HIDDEN;

                    }

                    break;
                }
            }

            if (j >= c_DefaultTable[m_dwParentType].cBands)
            {
                //We did not find the id we were looking for. We treat this case the same as the case 
                //where version number didn't match

                DOUTL(16, "ID: %d not found: Resetting\n", c_DefaultTable[m_dwParentType].BandData[i].wID);

                CopyMemory(pSavedBandData, &c_DefaultTable[m_dwParentType], m_cSavedBandInfo);
                break;
            }
        }
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CBands::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleWindow)
        || IsEqualIID(riid, IID_IDockingWindow))
    {
        *ppvObj = (IDockingWindow*)this;
        m_cRef++;
        DOUTL(2, TEXT("CBands::QI(IID_IDockingWindow) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (IObjectWithSite*)this;
        m_cRef++;
        DOUTL(2, TEXT("CBands::QI(IID_IObjectWithSite) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellMenuCallback))
    {
        *ppvObj = (IShellMenuCallback*)this;
        m_cRef++;
        DOUTL(2, TEXT("CBands::QI(IID_IShellCallback) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


ULONG CBands::AddRef()
{
    m_cRef++;
    DOUTL(4, TEXT("CBands::AddRef() - m_cRef = %d"), m_cRef);
    return m_cRef;
}

ULONG CBands::Release()
{
    m_cRef--;
    DOUTL(4, TEXT("CBands::Release() - m_cRef = %d"), m_cRef);
    
    if (m_cRef > 0)
        return m_cRef;
    
    delete this;
    return 0;
}


//
//  FUNCTION:   CBands::GetWindow()
//
//  PURPOSE:    Returns the window handle of the top side rebar.
//
HRESULT CBands::GetWindow(HWND * lphwnd)
{
    if (m_hwndSizer)
    {
        *lphwnd = m_hwndSizer;
        return (S_OK);
    }
    else
    {
        *lphwnd = NULL;
        return (E_FAIL);
    }
}


HRESULT CBands::ContextSensitiveHelp(BOOL fEnterMode)
{
    return (E_NOTIMPL);
}    


//
//  FUNCTION:   CBands::SetSite()
//
//  PURPOSE:    Allows the owner of the coolbar to tell it what the current
//              IDockingWindowSite interface to use is.
//
//  PARAMETERS:
//      <in> punkSite - Pointer of the IUnknown to query for IDockingWindowSite.
//                      If this is NULL, we just release our current pointer.
//
//  RETURN VALUE:
//      S_OK - Everything worked
//      E_FAIL - Could not get IDockingWindowSite from the punkSite provided.
//
HRESULT CBands::SetSite(IUnknown* punkSite)
{
    // If we had a previous pointer, release it.
    if (m_ptbSite)
    {
        m_ptbSite->Release();
        m_ptbSite = NULL;
    }
    
    // If a new site was provided, get the IDockingWindowSite interface from it.
    if (punkSite)    
    {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, 
            (LPVOID*) &m_ptbSite)))
        {
            Assert(m_ptbSite);
            return E_FAIL;
        }
    }
    
    return (S_OK);    
}    

HRESULT CBands::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

//
//  FUNCTION:   CBands::ShowDW()
//
//  PURPOSE:    Causes the coolbar to be either shown or hidden.
//
//  PARAMETERS:
//      <in> fShow - TRUE if the coolbar should be shown, FALSE to hide.
//
//  RETURN VALUE:
//      HRESULT 
//
#define SIZABLECLASS TEXT("SizableRebar")
HRESULT CBands::ShowDW(BOOL fShow)
{
    HRESULT hres = S_OK;
    int     i = 0, j = 0;
    IConnectionPoint    *pCP = NULL;
    
    // Check to see if our window has been created yet.  If not, do that first.
    if (!m_hwndSizer && m_ptbSite)
    {
        //Get the command target interface
        if (FAILED(hres = m_ptbSite->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_ptbSiteCT)))
        {
            return hres;
        }

        m_hwndParent = NULL;        
        hres = m_ptbSite->GetWindow(&m_hwndParent);
        
        if (SUCCEEDED(hres))
        {
            WNDCLASSEX              wc;
            
            // Check to see if we need to register our window class    
            wc.cbSize = sizeof(WNDCLASSEX);
            if (!GetClassInfoEx(g_hInst, SIZABLECLASS, &wc))
            {
                wc.style            = 0;
                wc.lpfnWndProc      = SizableWndProc;
                wc.cbClsExtra       = 0;
                wc.cbWndExtra       = 0;
                wc.hInstance        = g_hInst;
                wc.hCursor          = NULL;
                wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
                wc.lpszMenuName     = NULL;
                wc.lpszClassName    = SIZABLECLASS;
                wc.hIcon            = NULL;
                wc.hIconSm          = NULL;
                
                RegisterClassEx(&wc);
            }
            
            // Load the background bitmap to use for the coolbar and also get
            // a handle to the HDC and Palette for the coolbar.  This will be
            // used to draw the animated logo later.
            m_hdc = CreateCompatibleDC(NULL);
            if (GetDeviceCaps(m_hdc, RASTERCAPS) & RC_PALETTE)
                m_hpal = SHCreateShellPalette(m_hdc);
            
            // If we're trying to show the coolbar, then create the rebar and
            // add it's bands based on information saved in the registry.
            if (SUCCEEDED(CreateRebar(fShow)))
            {
                for (i = 0; i < (int) m_pSavedBandInfo->cBands; i++)
                {
                    switch (m_pSavedBandInfo->BandData[i].wID)
                    {
                    case CBTYPE_BRAND:
                        hres = ShowBrand();
                        break;

                    case CBTYPE_MENUBAND:
                        hres = CreateMenuBand(&m_pSavedBandInfo->BandData[i]);
                        break;

                    case CBTYPE_TOOLS:
                        hres = AddTools(&(m_pSavedBandInfo->BandData[i]));
                        break;

                    case CBTYPE_RULESTOOLBAR:
                        hres = AddRulesToolbar(&(m_pSavedBandInfo->BandData[i]));

                    }
                }

                m_pTextStyleNotify->Register(m_hwndSizer, g_hwndInit, FALSE);
            }
        }
    }
    
    //The first time OE is started, we should look at the key c_szShowToolbarIEAK or
    //if OE is started after IEAK is ran. Bug# 67503
    LRESULT     lResult;
    DWORD       dwType;
    DWORD       cbData = sizeof(DWORD);
    DWORD       dwShowToolbar = 1;

    lResult = AthUserGetValue(NULL, c_szShowToolbarIEAK, &dwType, (LPBYTE)&dwShowToolbar, &cbData);
    if (lResult == ERROR_SUCCESS)
    {
        HideToolbar(!dwShowToolbar, CBTYPE_TOOLS);
    }

    // Resize the rebar based on it's new hidden / visible state and also 
    // show or hide the window.    
    if (m_hwndSizer) 
    {
        ResizeBorderDW(NULL, NULL, FALSE);
        ShowWindow(m_hwndSizer, fShow ? SW_SHOW : SW_HIDE);
    }
    
    if (g_pConMan)
        g_pConMan->Advise(this);
    
    return hres;
}

void CBands::HideToolbar(BOOL   fHide, DWORD    dwBandID)
{
    REBARBANDINFO   rbbi = {0};
    DWORD           iBand;

    iBand = (DWORD) SendMessage(m_hwndRebar, RB_IDTOINDEX, dwBandID, 0);
    if (iBand != -1)
    {
        SendMessage(m_hwndRebar, RB_SHOWBAND, iBand, !fHide);
    }

    LoadBrandingBitmap();

    SetMinDimensions();

    if (dwBandID == CBTYPE_RULESTOOLBAR)
    {
        if (!fHide)
            UpdateFilters(m_DefaultFilterId);

    }
}

BOOL CBands::IsToolbarVisible()
{
    return IsBandVisible(CBTYPE_TOOLS);
}

BOOL CBands::IsBandVisible(DWORD  dwBandId)
{
    int iBand;

    iBand = (int) SendMessage(m_hwndRebar, RB_IDTOINDEX, dwBandId, 0);
    if (iBand != -1)
    {
        REBARBANDINFO   rbbi = {0};

        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM)&rbbi);

        return (!(rbbi.fStyle & RBBS_HIDDEN));
    }
    return FALSE;
}

//
//  FUNCTION:   CBands::CloseDW()
//
//  PURPOSE:    Destroys the coolbar.
//
HRESULT CBands::CloseDW(DWORD dwReserved)
{    
    SafeRelease(m_pWinEvent);
    SafeRelease(m_pMenuBand);
    //Bug# 68607
    if (m_pDeskBand)
    {
        m_pDeskBand->CloseDW(dwReserved);

        IInputObject        *pinpobj;
        IObjectWithSite     *pobjsite;

        if (SUCCEEDED(m_pDeskBand->QueryInterface(IID_IObjectWithSite, (LPVOID*)&pobjsite)))
        {
            pobjsite->SetSite(NULL);
            pobjsite->Release();
        }

        //m_pDeskBand->ShowDW(FALSE);
    }

    SafeRelease(m_pShellMenu);
    if (m_hwndSizer)
    {
        m_pTextStyleNotify->Unregister(m_hwndSizer);

        SaveSettings();
        DestroyWindow(m_hwndSizer);
        m_hwndSizer = NULL;
    }

    SafeRelease(m_pDeskBand);

    SafeRelease(m_ptbSiteCT);
  
    return S_OK;
}


//
//  FUNCTION:   CBands::ResizeBorderDW()
//
//  PURPOSE:    This is called when the coolbar needs to resize.  The coolbar
//              in return figures out how much border space will be required 
//              from the parent frame and tells the parent to reserve that
//              space.  The coolbar then resizes itself to those dimensions.
//
//  PARAMETERS:
//      <in> prcBorder       - Rectangle containing the border space for the
//                             parent.
//      <in> punkToolbarSite - Pointer to the IDockingWindowSite that we are
//                             part of.
//      <in> fReserved       - Ignored.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CBands::ResizeBorderDW(LPCRECT prcBorder,
                                 IUnknown* punkToolbarSite,
                                 BOOL fReserved)
{
    const DWORD  c_cxResizeBorder = 3;
    const DWORD  c_cyResizeBorder = 3;
    
    HRESULT hres = S_OK;
    RECT    rcRequest = { 0, 0, 0, 0 };
    
    // If we don't have a stored site pointer, we can't resize.
    if (!m_ptbSite)
    {
        AssertSz(m_ptbSite, _T("CBands::ResizeBorderDW() - Can't resize ")
            _T("without an IDockingWindowSite interface to call."));
        return (E_INVALIDARG);
    }
    
    // If we're visible, then calculate our border rectangle.    
    RECT rcBorder, rcRebar, rcT;
    int  cx, cy;
    
    // Get the size this rebar currently is
    GetWindowRect(m_hwndRebar, &rcRebar);
    cx = rcRebar.right - rcRebar.left;
    cy = rcRebar.bottom - rcRebar.top;
    
    // Find out how big our parent's border space is
    m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
    
    cx = rcBorder.right - rcBorder.left;
    
    // Bug #31007 - There seems to be a problem in commctrl
    // IEBug #5574  either with the REBAR or with the Toolbar
    //              when they are vertical.  If the we try to
    //              size them to 2 or less, we lock up.  This
    //              is a really poor fix, but there's no way
    //              to get commctrl fixed this late in the game.
    if (cy < 5) cy = 10;
    if (cx < 5) cx = 10;
    
    SetWindowPos(m_hwndRebar, NULL, 0, 0, cx, cy, SWP_NOZORDER | SWP_NOACTIVATE);

        // Figure out how much border space to ask the site for
    GetWindowRect(m_hwndRebar, &rcRebar);
    rcRequest.top = rcRebar.bottom - rcRebar.top + c_cxResizeBorder;
    
    // Ask the site for that border space
    if (SUCCEEDED(m_ptbSite->RequestBorderSpaceDW((IDockingWindow*) this, &rcRequest)))
    {
        // Position the window based on the area given to us
        SetWindowPos(m_hwndSizer, NULL, 
            rcBorder.left, 
            rcBorder.top,
            rcRebar.right - rcRebar.left, 
            rcRequest.top + rcBorder.top, 
            SWP_NOZORDER | SWP_NOACTIVATE);                

    }
    
    // Now tell the site how much border space we're using.    
    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);
    
    return hres;
}


//
//  FUNCTION:   CBands::Invoke()
//
//  PURPOSE:    Allows the owner of the coolbar to force the coolbar to do 
//              something.
//
//  PARAMETERS:
//      <in> id - ID of the command the caller wants the coolbar to do.
//      <in> pv - Pointer to any parameters the coolbar might need to carry
//                out the command.
//
//  RETURN VALUE:
//      S_OK - The command was carried out.
//      
//  COMMENTS:
//      <???>
//
HRESULT CBands::Invoke(DWORD id, LPVOID pv)
{
    switch (id)
    {
        // Starts animating the logo
        case idDownloadBegin:
            StartDownload();
            break;
        
            // Stops animating the logo
        case idDownloadEnd:
            StopDownload();
            break;
        
            // Update the enabled / disabled state of buttons on the toolbar
        case idStateChange:
        {
            // pv is a pointer to a COOLBARSTATECHANGE struct
            COOLBARSTATECHANGE* pcbsc = (COOLBARSTATECHANGE*) pv;
            SendMessage(m_hwndTools, TB_ENABLEBUTTON, pcbsc->id, 
                MAKELONG(pcbsc->fEnable, 0));
            break;
        }
        
        case idToggleButton:
        {
            COOLBARSTATECHANGE* pcbsc = (COOLBARSTATECHANGE *) pv;
            SendMessage(m_hwndTools, TB_CHECKBUTTON, pcbsc->id,
                MAKELONG(pcbsc->fEnable, 0));
            break;
        }
        
        case idBitmapChange:
        {
            // pv is a pointer to a COOLBARBITMAPCHANGE struct
            COOLBARBITMAPCHANGE *pcbc = (COOLBARBITMAPCHANGE*) pv;
        
            SendMessage(m_hwndTools, TB_CHANGEBITMAP, pcbc->id, MAKELPARAM(pcbc->index, 0));
            break;
        }
        
            // Sends a message directly to the toolbar.    
        case idSendToolMessage:
            #define ptm ((TOOLMESSAGE *)pv)
            ptm->lResult = SendMessage(m_hwndTools, ptm->uMsg, ptm->wParam, ptm->lParam);
            break;
            #undef ptm
        
        case idCustomize:
            SendMessage(m_hwndTools, TB_CUSTOMIZE, 0, 0);
            break;

        case idNotifyFilterChange:
            m_DefaultFilterId = (*(RULEID*)pv);
            if (IsBandVisible(CBTYPE_RULESTOOLBAR))
                UpdateFilters(m_DefaultFilterId);
            break;

        case idIsFilterBarVisible:
            *((BOOL*)pv) = IsBandVisible(CBTYPE_RULESTOOLBAR);
            break;
    }
    
    return S_OK;
}

//
//  FUNCTION:   CBands::StartDownload()
//
//  PURPOSE:    Starts animating the logo.
//
void CBands::StartDownload()
{
    if (m_hwndBrand)
    {
        SetFlag(TBSTATE_ANIMATING);
        SetFlag(TBSTATE_FIRSTFRAME);
        m_yOrg = 0;
        SetTimer(m_hwndSizer, ANIMATION_TIMER, 100, NULL);
    }
}


//
//  FUNCTION:   CBands::StopDownload()
//
//  PURPOSE:    Stops animating the logo.  Restores the logo to it's default
//              first frame.
//
void CBands::StopDownload()
{
    int           i, cBands;
    REBARBANDINFO rbbi;
    
    // Set the background colors for this band back to the first frame
    cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_BRAND == rbbi.wID)
        {
            rbbi.fMask = RBBIM_COLORS;
            rbbi.clrFore = m_rgbUpperLeft;
            rbbi.clrBack = m_rgbUpperLeft;
            SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            
            break;
        }
    }
    
    // Reset the state flags
    ClearFlag(TBSTATE_ANIMATING);
    ClearFlag(TBSTATE_FIRSTFRAME);
    
    KillTimer(m_hwndSizer, ANIMATION_TIMER);
    InvalidateRect(m_hwndBrand, NULL, FALSE);
    UpdateWindow(m_hwndBrand);
}

BOOL CBands::CheckForwardWinEvent(HWND hwnd,  UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwndForward = NULL;
    switch(uMsg)
    {
    case WM_NOTIFY:
        hwndForward = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwndForward = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwndForward = HWND_BROADCAST;
        break;
    }

    if (hwndForward && m_pWinEvent && m_pWinEvent->IsWindowOwner(hwndForward) == S_OK)
    {
        LRESULT lres;
        m_pWinEvent->OnWinEvent(hwndForward, uMsg, wParam, lParam, &lres);
        if (plres)
            *plres = lres;
        return TRUE;
    }

    return FALSE;
}


void CBands::ChangeImages()
{
    _SetImages(m_hwndTools, (fIsWhistler() ? 
        ((GetCurColorRes() > 24) ? c_32ImageListStruct[m_dwParentType].ImageListTable : c_ImageListStruct[m_dwParentType].ImageListTable)
        : c_NWImageListStruct[m_dwParentType].ImageListTable ));
    
    if (IsBandVisible(CBTYPE_RULESTOOLBAR))
        _SetImages(m_hwndRulesToolbar, (fIsWhistler() ? 
        ((GetCurColorRes() > 24) ? c_32RulesImageList : c_RulesImageList) 
              : c_NWRulesImageList ));
}


//
//  FUNCTION:   CBands::SizableWndProc() 
//
//  PURPOSE:    Handles messages sent to the coolbar root window.
//
LRESULT EXPORT_16 CALLBACK CBands::SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBands* pitbar = (CBands*)GetProp(hwnd, TEXT("CBands"));
    DWORD dw;
    
    if (!pitbar)
        goto CallDWP;
    
    switch(uMsg)
    {
        case WM_SYSCOLORCHANGE:
        {
            // Reload the graphics
            pitbar->ChangeImages();
            pitbar->UpdateToolbarColors();
            InvalidateRect(pitbar->m_hwndTools, NULL, TRUE);
            pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, NULL);
            break;
        }
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            // Forward this to our child windows
            pitbar->ChangeImages();
            SendMessage(pitbar->m_hwndTools, uMsg, wParam, lParam);
            SendMessage(pitbar->m_hwndRulesToolbar, uMsg, wParam, lParam);
            SendMessage(pitbar->m_hwndRebar, uMsg, wParam, lParam);
            InvalidateRect(pitbar->m_hwndTools, NULL, TRUE);
            pitbar->SetMinDimensions();
            pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, NULL);
            
            //Update the combo box with the new font
            pitbar->FilterBoxFontChange();

            break;
        
        case WM_SETCURSOR:
            // We play with the cursor a bit to make the resizing cursor show 
            // up when the user is over the edge of the coolbar that allows 
            // them to drag to resize etc.
            if ((HWND) wParam == hwnd)
            {
                if (pitbar->m_dwState & TBSTATE_INMENULOOP)
                    SetCursor(LoadCursor(NULL, IDC_ARROW));
                else    
                    SetCursor(LoadCursor(NULL, IDC_SIZENS));
                return (TRUE);                
            }
            return (FALSE);    

        case WM_LBUTTONDOWN:
            // The user is about to resize the bar.  Capture the cursor so we
            // can watch the changes.
            pitbar->m_yCapture = GET_Y_LPARAM(lParam);    
            SetCapture(hwnd);
            break;
        
        case WM_MOUSEMOVE:
            // The user is resizing the bar.  Handle updating the sizes as
            // they drag.
            if (pitbar->m_yCapture != -1)
            {
                if (hwnd != GetCapture())
                    pitbar->m_yCapture = -1;
                else
                    pitbar->TrackSliding(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

            }
            break;
        
        case WM_LBUTTONUP:
            // The user is done resizing.  release our capture and reset our
            // state.
            if (pitbar->m_yCapture != -1 || pitbar->m_xCapture != -1)
            {
                ReleaseCapture();
                pitbar->m_yCapture = -1;
                pitbar->m_xCapture = -1;
            }
            break;

        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
            // We must swallow these messages to avoid infinit SendMessage
            break;
        
        case WM_DRAWITEM:
            // Draws the animating brand
            if (wParam == idcBrand)
                pitbar->DrawBranding((LPDRAWITEMSTRUCT) lParam);
            break;
        
        case WM_MEASUREITEM:
            // Draws the animating brand
            if (wParam == idcBrand)
            {
                ((LPMEASUREITEMSTRUCT) lParam)->itemWidth  = pitbar->m_cxBrand;
                ((LPMEASUREITEMSTRUCT) lParam)->itemHeight = pitbar->m_cyBrand;
            }
            break;
        
        case WM_TIMER:
            // This timer fires every time we need to draw the next frame in
            // animating brand.
            if (wParam == ANIMATION_TIMER)
            {
                if (pitbar->m_hwndBrand)
                {
                    pitbar->m_yOrg += pitbar->m_cyBrand;
                    if (pitbar->m_yOrg >= pitbar->m_cyBrandExtent)
                        pitbar->m_yOrg = pitbar->m_cyBrandLeadIn;
                
                    InvalidateRect(pitbar->m_hwndBrand, NULL, FALSE);
                    UpdateWindow(pitbar->m_hwndBrand);
                }
            }
            break;
        
        case WM_NOTIFY:
            {
                LRESULT lres;
                if (pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, &lres))
                    return lres;
                return pitbar->OnNotify(hwnd, lParam);
            }
        
        case WM_COMMAND:
            {
                LRESULT lres;
                if (pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, &lres))
                    return lres;

                if (pitbar->HandleComboBoxNotifications(wParam, lParam))
                    return 0L;

                if (wParam == ID_CUSTOMIZE)
                {
                    //SendMessage(m_hwndTools, TB_CUSTOMIZE, 0, 0);
                    pitbar->OnCommand(hwnd, (int) wParam, NULL, 0);
                    return 0L;
                }
                
                //Bug# 58029. lParam is the destination folder. So it needs to be set to zero if 
                //we want the treeview dialog to show up.
                if (wParam == ID_MOVE_TO_FOLDER || wParam == ID_COPY_TO_FOLDER)
                    return SendMessage(pitbar->m_hwndParent, WM_COMMAND, wParam, (LPARAM)0);
                else
                    return SendMessage(pitbar->m_hwndParent, WM_COMMAND, wParam, lParam);
            }

        case WM_CONTEXTMENU:
            pitbar->OnContextMenu((HWND) wParam, LOWORD(lParam), HIWORD(lParam));
            break;
        
        case WM_PALETTECHANGED:
            // BUGBUG: we could optimize this by realizing and checking the
            // return value
            //
            // for now we will just invalidate ourselves and all children...
            RedrawWindow(pitbar->m_hwndSizer, NULL, NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            break;
        
        case CM_CONNECT:
            // wParam is hMenuConnect, lParam is CmdID
            g_pConMan->Connect((HMENU) wParam, (DWORD) lParam, pitbar->m_hwndParent);
            g_pConMan->FreeConnectMenu((HMENU) wParam);
            break;
        
        case TT_ISTEXTVISIBLE:
            return (pitbar->m_dwToolbarTextState != TBSTATE_NOTEXT);

        case WM_OE_TOOLBAR_STYLE:
            pitbar->UpdateTextSettings((DWORD) wParam);
            break;

        case WM_DESTROY:
            {
                IConnectionPoint *pCP = NULL;

                // Clean up our pointers
                RemoveProp(hwnd, TEXT("CBands"));
                pitbar->Release(); // Corresponding to AddRef at SetProp
    
                DOUTL(1, _T("CBands::WM_DESTROY - Called RemoveProp. Called")
                    _T(" Release() new m_cRef=%d"), pitbar->m_cRef);
                
                pitbar->CleanupImages();

                //Unregister with the connection manager
                if (g_pConMan)
                    g_pConMan->Unadvise(pitbar);
                
                RemoveProp(pitbar->m_hwndTools, SZ_PROP_CUSTDLG);

                // fall through
            }
        
        default:
CallDWP:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
    
    return 0L;
}

void CBands::CleanupImages()
{
    CleanupRulesToolbar();
    CleanupImages(m_hwndTools);
}

void CBands::CleanupRulesToolbar()
{
    HIMAGELIST  himl;

    if (IsWindow(m_hwndRulesToolbar))
    {
        CleanupImages(m_hwndRulesToolbar);
    }
}

void CBands::CleanupImages(HWND     hwnd)
{
    HIMAGELIST      himl;

    himl = (HIMAGELIST)SendMessage(hwnd, TB_SETIMAGELIST, 0, 0);
    if (himl)
    {
        //This is the old image list
        ImageList_Destroy(himl);
    }

    himl = (HIMAGELIST)SendMessage(hwnd, TB_SETHOTIMAGELIST, 0, 0);
    if (himl)
    {
        //This is the old image list
        ImageList_Destroy(himl);
    }
}

//idComboBox is the Identifier of the combo box
//idCmd is the command id or the notification id
//hwnd is the window handle of the combo box
LRESULT   CBands::HandleComboBoxNotifications(WPARAM wParam, LPARAM     lParam)
{
    LRESULT     retval = 0;
    int         ItemIndex;
    int         idCmd, id;
    HWND        hwnd;

    idCmd = GET_WM_COMMAND_CMD(wParam, lParam);
    id    = GET_WM_COMMAND_ID(wParam, lParam);
    hwnd  = GET_WM_COMMAND_HWND(wParam, lParam);

    if (hwnd != m_hwndFilterCombo)
        return 0;

    switch (idCmd)
    {
        case  CBN_SELENDOK:
            ItemIndex = ComboBox_GetCurSel(m_hwndFilterCombo);
            if(ItemIndex < 0)
                break;

            RULEID  FilterID;
            FilterID = (RULEID)ComboBox_GetItemData(hwnd, ItemIndex);
            SendMessage(m_hwndParent, WM_COMMAND, MAKEWPARAM(ID_VIEW_APPLY, 0), (LPARAM)FilterID);
            retval = 1;
            break;
    }

    return retval;
}

HRESULT CBands::OnCommand(HWND hwnd, int idCmd, HWND hwndControl, UINT cmd)
{
    LPTSTR pszTest;
    
    switch (idCmd)
    {
        case idcBrand:  // click on the spinning globe
            // We don't want to do anything at all here.
            break;
        
        case ID_CUSTOMIZE:
            SendMessage(m_hwndTools, TB_CUSTOMIZE, 0, 0);
            break;

        default:
            return S_FALSE;
    }
    return S_OK;
}

//Move this function to utils.
HMENU   LoadMenuPopup(HINSTANCE     hinst, UINT id)
{
    HMENU hMenuSub = NULL;

    HMENU hMenu = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (hMenu) {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub) {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }
        DestroyMenu(hMenu);
    }

    return hMenuSub;
}

LRESULT CBands::OnNotify(HWND hwnd, LPARAM lparam)
{
    NMHDR   *lpnmhdr = (NMHDR*)lparam;

    if ((lpnmhdr->idFrom == idcCoolbar) || (lpnmhdr->hwndFrom == m_hwndRebar))
    {
        switch (lpnmhdr->code)
        {
            case RBN_HEIGHTCHANGE:
                ResizeBorderDW(NULL, NULL, FALSE);
                break;

            case RBN_CHEVRONPUSHED:
            {                    
                ITrackShellMenu* ptsm;                   
                CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, 
                    (LPVOID*)&ptsm);
                if (!ptsm)
                    break;

                ptsm->Initialize(0, 0, 0, SMINIT_TOPLEVEL|SMINIT_VERTICAL);
            
                LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) lpnmhdr;                                        
                switch (pnmch->wID)                    
                {                        
                    case CBTYPE_TOOLS:                        
                    {                            
                        ptsm->SetObscured(m_hwndTools, NULL, SMSET_TOP);
                        HMENU   hmenu;
                        hmenu = LoadMenuPopup(g_hLocRes, IDR_TBCHEV_MENU);
                        if (hmenu)
                        {
                            ptsm->SetMenu(hmenu, m_hwndRebar, SMSET_BOTTOM);                           
                        }
                        break;                        
                    }                        
                    case CBTYPE_MENUBAND:                        
                    {                           
                        ptsm->SetObscured(m_hwndMenuBand, m_pShellMenu, SMSET_TOP);
                        break;
                    }                     
                }
            
                MapWindowPoints(m_hwndRebar, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);                  
                POINTL pt = {pnmch->rc.left, pnmch->rc.right};                   
                ptsm->Popup(m_hwndRebar, &pt, (RECTL*)&pnmch->rc, MPPF_BOTTOM);            
                ptsm->Release();                  
                break;      
            }

            case RBN_LAYOUTCHANGED:
            {
                LoadBrandingBitmap();
                SetMinDimensions();
                break;
            }
        }
    }
    else if ((lpnmhdr->idFrom == idcToolbar) || (lpnmhdr->hwndFrom == m_hwndTools))
    {
        if (lpnmhdr->code == TBN_GETBUTTONINFOA)
            return OnGetButtonInfo((TBNOTIFY*) lparam);
    
        if (lpnmhdr->code == TBN_QUERYDELETE)
            return (TRUE);
    
        if (lpnmhdr->code == TBN_QUERYINSERT)
            return (TRUE);
    
        if (lpnmhdr->code == TBN_GETINFOTIP)
            return OnGetInfoTip((LPNMTBGETINFOTIP)    lparam);

        if (lpnmhdr->code == TBN_ENDADJUST)
        {
            DWORD       dwSize;
            DWORD       dwType;
            DWORD       dwIconSize;
            DWORD       dwText;
            CBands      *pBrowserCoolbar = NULL;

            if (m_dwParentType == PARENT_TYPE_NOTE)
            {
                if ((g_pBrowser) && (FAILED(g_pBrowser->GetCoolbar(&pBrowserCoolbar))))
                    pBrowserCoolbar = NULL;
            }

            if ((AthUserGetValue(NULL, c_szRegToolbarText, &dwType, (LPBYTE)&dwText, &dwSize) != ERROR_SUCCESS) ||
                (dwText != m_dwToolbarTextState))
            {
                //Save the Text Labels into the registry
                AthUserSetValue(NULL, c_szRegToolbarText, REG_DWORD, (LPBYTE)&m_dwToolbarTextState, sizeof(DWORD));
                
                /*
                if (pBrowserCoolbar)
                {
                    pBrowserCoolbar->UpdateTextSettings(m_dwToolbarTextState);
                }
                */
            }

            if ((AthUserGetValue(NULL, c_szRegToolbarIconSize, &dwType, (LPBYTE)&dwIconSize, &dwSize) != ERROR_SUCCESS) ||
                (dwIconSize != m_dwIconSize))
            {
                SetIconSize(m_dwIconSize);

                AthUserSetValue(NULL, c_szRegToolbarIconSize, REG_DWORD, (LPBYTE)&m_dwIconSize, sizeof(DWORD));

                if (pBrowserCoolbar)
                {
                    pBrowserCoolbar->SetIconSize(m_dwIconSize);
                }
            }

            if (m_fDirty)
            {
                //Recalculate button widths and set ideal sizes
                CalcIdealSize();
                
                if (pBrowserCoolbar)
                {
                    pBrowserCoolbar->CalcIdealSize();
                }
            }

            if (pBrowserCoolbar)
            {
                pBrowserCoolbar->Release();
                pBrowserCoolbar = NULL;
            }

            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                IAthenaBrowser *psbwr;
                
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser,(void**)&psbwr)))
                {
                    psbwr->UpdateToolbar();
                    psbwr->Release();
                }
            }

            m_fDirty = FALSE;
        }
    
        if (lpnmhdr->code == TBN_TOOLBARCHANGE)
        {
            m_fDirty = TRUE;
        }

        if (lpnmhdr->code == TBN_RESET)    
        {
            // Remove all the buttons from the toolbar
            int cButtons = (int) SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0);
            while (--cButtons >= 0)
                SendMessage(m_hwndTools, TB_DELETEBUTTON, cButtons, 0);
        
            // Set the buttons back to the default    
            SendMessage(m_hwndTools, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
            _LoadDefaultButtons(m_hwndTools, (TOOLBAR_INFO *) m_pTBInfo);
        
            _UpdateTextSettings(idsShowTextLabels);

            m_dwIconSize = LARGE_ICONS;

            return (TRUE);    
        }
    
        if (lpnmhdr->code == TBN_DROPDOWN)
        {
            if (m_dwParentType == PARENT_TYPE_NOTE)
            {
                SendMessage(m_hwndParent, WM_NOTIFY, NULL, lparam);
                return (0L);
            }
            return OnDropDown(hwnd, lpnmhdr);
        }
    
        if (lpnmhdr->code == TBN_INITCUSTOMIZE)
        {
            _OnBeginCustomize((NMTBCUSTOMIZEDLG*)lpnmhdr);
            return TBNRF_HIDEHELP;
        }
    }
    
    return (0L);    
}

void CBands::_OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm)
{
    HWND hwnd = (HWND) GetProp(pnm->hDlg, SZ_PROP_CUSTDLG);

    if (!hwnd) 
    {
        //
        // hasn't been initialized.
        //
        // we need to check this because this init will be called
        // when the user hits reset as well
        hwnd = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddToolbarTextIcons), pnm->hDlg, 
            _BtnAttrDlgProc, (LPARAM)this);
        if (hwnd) 
        {
            // store hwnd of our dialog as property on tb cust dialog
            SetProp(pnm->hDlg, SZ_PROP_CUSTDLG, hwnd);

            // populate dialog controls
            _PopulateDialog(hwnd);

            // initialize dialog control selection states
            _SetDialogSelections(hwnd);

            RECT rc, rcWnd, rcClient;
            GetWindowRect(pnm->hDlg, &rcWnd);
            GetClientRect(pnm->hDlg, &rcClient);
            GetWindowRect(hwnd, &rc);

            // enlarge tb dialog to make room for our dialog
            SetWindowPos(pnm->hDlg, NULL, 0, 0, RECTWIDTH(rcWnd), RECTHEIGHT(rcWnd) + RECTHEIGHT(rc), SWP_NOMOVE | SWP_NOZORDER);

            // position our dialog at the bottom of the tb dialog
            SetWindowPos(hwnd, HWND_TOP, rcClient.left, rcClient.bottom, 0, 0, SWP_NOSIZE | SWP_SHOWWINDOW);
        }
    }
}

INT_PTR CALLBACK CBands::_BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBands* pitbar = (CBands*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            return TRUE;

        case WM_COMMAND:
            {
                BOOL    retval = FALSE;

                if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELENDOK)
                {
                    HWND    hwnd   = GET_WM_COMMAND_HWND(wParam, lParam);
                    int     iSel   = (int) SendMessage(hwnd, CB_GETCURSEL, 0, 0);
                    int     idsSel = (int) SendMessage(hwnd, CB_GETITEMDATA, iSel, 0);
        
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_SHOWTEXT)
                    {
                        pitbar->_UpdateTextSettings(idsSel);
                        retval = TRUE;
                    }
                    else 
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_SMALLICONS)
                    {
                        pitbar->m_dwIconSize = ((idsSel == idsLargeIcons) ? LARGE_ICONS : SMALL_ICONS);
                        retval = TRUE;
                    }

                }

                return retval;
            }

        case WM_DESTROY:
            return TRUE;
    }

    return FALSE;
}

void CBands::_PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources)
{
    TCHAR   sz[256];

    // loop through iResource[], load each string resource and insert into combobox
    for (UINT i = 0; i < cResources; i++) {
        if (LoadString(g_hLocRes, iResource[i], sz, ARRAYSIZE(sz))) {
            int iIndex = (int) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwnd, CB_SETITEMDATA, iIndex, iResource[i]);
        }
    }
}

void CBands::_SetComboSelection(HWND hwnd, int iCurOption)
{
    int cItems = (int) SendMessage(hwnd, CB_GETCOUNT, 0, 0);

    while (cItems--) {
        int iItemData = (int) SendMessage(hwnd, CB_GETITEMDATA, cItems, 0);

        if (iItemData == iCurOption) {
            SendMessage(hwnd, CB_SETCURSEL, cItems, 0);
            break;
        }
        else {
            // iCurOption should be in list somewhere; 
            // assert that we're not done looking
            Assert(cItems);
        }
    }
}

#define IS_LIST_STYLE(hwnd) (!!(GetWindowLong(hwnd, GWL_STYLE) & TBSTYLE_LIST))

void CBands::_SetDialogSelections(HWND hDlg)
{
    CBands* pitbar = (CBands*)this;
    
    DWORD   dw;
    int     iCurOption;
    HWND    hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);

    dw = _GetTextState();

    switch (dw)
    {
        case    TBSTATE_NOTEXT:
            iCurOption = idsNoTextLabels;
            break;

        case    TBSTATE_PARTIALTEXT:
            iCurOption = idsPartialTextLabels;
            break;

        case    TBSTATE_FULLTEXT:
        default:
            iCurOption = idsShowTextLabels;
    }

    _SetComboSelection(hwnd, iCurOption);

    dw = _GetIconSize();

    switch (dw)
    {
        case SMALL_ICONS:
            iCurOption = idsSmallIcons;
            break;

        default:
        case LARGE_ICONS:
            iCurOption = idsLargeIcons;
            break;
    }

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    _SetComboSelection(hwnd, iCurOption);
}

static const int c_iTextOptions[] = {
    idsShowTextLabels,
    idsPartialTextLabels,
    idsNoTextLabels,
};

static const int c_iIconOptions[] = {
    idsSmallIcons,
    idsLargeIcons,
};

void CBands::_PopulateDialog(HWND hDlg)
{
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);
    _PopulateComboBox(hwnd, c_iTextOptions, ARRAYSIZE(c_iTextOptions));

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    _PopulateComboBox(hwnd, c_iIconOptions, ARRAYSIZE(c_iIconOptions));
}

void CBands::_UpdateTextSettings(int ids)
{
    BOOL    fText, fList;
    DWORD   dwState;

    switch (ids) {
    case idsShowTextLabels:
        fList       = FALSE;
        fText       = TRUE;
        dwState     = TBSTATE_FULLTEXT;
        break;
    
    case idsPartialTextLabels:
        fList       = TRUE;
        fText       = TRUE;
        dwState     = TBSTATE_PARTIALTEXT;
        break;

    case idsNoTextLabels:
        fList       = FALSE;  // (but we really don't care)
        fText       = FALSE;
        dwState     = TBSTATE_NOTEXT;
        break;
    }

    DWORD dwStyle = GetWindowLong(m_hwndTools, GWL_STYLE);
    SetWindowLong(m_hwndTools, GWL_STYLE, fList ? dwStyle | TBSTYLE_LIST : dwStyle & (~TBSTYLE_LIST));
    
    SendMessage(m_hwndTools, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, fList ? TBSTYLE_EX_MIXEDBUTTONS : 0);

    CompressBands(dwState);
}

void CBands::UpdateTextSettings(DWORD  dwTextState)
{
    BOOL    fText, fList;

    switch (dwTextState) 
    {
    case TBSTATE_FULLTEXT:
        fList       = FALSE;
        fText       = TRUE;
        break;
    
    case TBSTATE_PARTIALTEXT:
        fList       = TRUE;
        fText       = TRUE;
        break;

    case TBSTATE_NOTEXT:
        fList       = FALSE;  // (but we really don't care)
        fText       = FALSE;
        break;
    }

    DWORD dwStyle = GetWindowLong(m_hwndTools, GWL_STYLE);
    SetWindowLong(m_hwndTools, GWL_STYLE, fList ? dwStyle | TBSTYLE_LIST : dwStyle & (~TBSTYLE_LIST));
    
    SendMessage(m_hwndTools, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, fList ? TBSTYLE_EX_MIXEDBUTTONS : 0);

    CompressBands(dwTextState);
}

void CBands::SetIconSize(DWORD     dwIconSize)
{
    m_dwIconSize = dwIconSize;
    ChangeImages();
    SetMinDimensions();
    ResizeBorderDW(NULL, NULL, FALSE);
}

DWORD CBands::_GetIconSize()
{
    return m_dwIconSize;
}

LRESULT CBands::OnDropDown(HWND hwnd, LPNMHDR lpnmh)
{
    HMENU           hMenuPopup = NULL;
    TBNOTIFY       *ptbn = (TBNOTIFY *)lpnmh ;
    UINT            uiCmd = ptbn->iItem ;
    RECT            rc;
    DWORD           dwCmd = 0;
    IAthenaBrowser *pBrowser;
    BOOL            fPostCmd = TRUE;
    IOleCommandTarget *pTarget;
    DWORD           cAcctMenu = 0;
    
    // Load and initialize the appropriate dropdown menu
    switch (uiCmd)
    {
        case ID_POPUP_LANGUAGE:
        {
            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser, (void**) &pBrowser)))
                {
                    // get language menu from shell/browser
                    pBrowser->GetLanguageMenu(&hMenuPopup, 0);
                    pBrowser->Release();

                    if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                    {
                        MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                        pTarget->Release();
                    }

                }
            }
        }
        break;
        
        case ID_NEW_MAIL_MESSAGE:
        case ID_NEW_NEWS_MESSAGE:
            GetStationeryMenu(&hMenuPopup);
            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                {
                    MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                    pTarget->Release();
                }
            }
            break;

        
        case ID_PREVIEW_PANE:
        {
            // Load the menu
            hMenuPopup = LoadPopupMenu(IDR_PREVIEW_POPUP);
            if (!hMenuPopup)
                break;
        
            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                {
                    MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                    pTarget->Release();
                }
            }
        
            break;
        }

        case ID_SEND_RECEIVE:
        {

            hMenuPopup = LoadPopupMenu(IDR_SEND_RECEIEVE_POPUP);
            AcctUtil_CreateSendReceieveMenu(hMenuPopup, &cAcctMenu);
            MenuUtil_SetPopupDefault(hMenuPopup, ID_SEND_RECEIVE);

            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                {
                    MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                    pTarget->Release();
                }
            }
            break;
        }
        
        case ID_FIND_MESSAGE:
        {

            hMenuPopup = LoadPopupMenu(IDR_FIND_POPUP);
            MenuUtil_SetPopupDefault(hMenuPopup, ID_FIND_MESSAGE);

            // check IDockingWindowSite 
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                {
                    MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                    pTarget->Release();
                }
            }
            break;
        }

        default:
            AssertSz(FALSE, "CBands::OnDropDown() - Unhandled TBN_DROPDOWN notification");
            return (TBDDRET_NODEFAULT);
    }
    
    // If we loaded a menu, then go ahead and display it    
    if (hMenuPopup)
    {
        rc = ((NMTOOLBAR *) lpnmh)->rcButton;
        MapWindowRect(lpnmh->hwndFrom, HWND_DESKTOP, &rc);
        SetFlag(TBSTATE_INMENULOOP);
        dwCmd = TrackPopupMenuEx(hMenuPopup, TPM_RETURNCMD | TPM_LEFTALIGN, 
            IS_WINDOW_RTL_MIRRORED(lpnmh->hwndFrom)? rc.right : rc.left, rc.bottom, m_hwndParent, NULL);    
        ClearFlag(TBSTATE_INMENULOOP);
    }        
    
    // Clean up anything needing to be cleaned up
    switch (uiCmd)
    {
        case ID_LANGUAGE:
            break;
        
        case ID_NEW_MAIL_MESSAGE:
        case ID_NEW_NEWS_MESSAGE:
        {
            // We can't just forward the normal command ID because we don't have
            // seperate stationery ID's for mail and news.
            if (m_ptbSite)
            {
                // get IAthenaBrowser interface
                if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser, (void**) &pBrowser)))
                {
                    // Get the current folder ID
                    FOLDERID id;

                    if (SUCCEEDED(pBrowser->GetCurrentFolder(&id)))
                    {
                        MenuUtil_HandleNewMessageIDs(dwCmd, m_hwndSizer, id, uiCmd == ID_NEW_MAIL_MESSAGE,
                                                     FALSE, NULL);
                        // Clear this so we don't send the command twice.
                        dwCmd = 0;
                    }

                    pBrowser->Release();
                    pBrowser = 0;
                }
            }            
            break;
        }

        case ID_NEW_MSG_DEFAULT:
            break;

        case ID_SEND_RECEIVE:
        {
            MENUITEMINFO mii;

            mii.cbSize     = sizeof(MENUITEMINFO);
            mii.fMask      = MIIM_DATA;
            mii.dwItemData = 0;

            if (GetMenuItemInfo(hMenuPopup, dwCmd, FALSE, &mii))
            {
                if (mii.dwItemData)
                {
                    g_pSpooler->StartDelivery(m_hwndSizer, (LPTSTR) mii.dwItemData, FOLDERID_INVALID,
                        DELIVER_MAIL_SEND | DELIVER_MAIL_RECV | DELIVER_NOSKIP | DELIVER_POLL | DELIVER_OFFLINE_FLAGS);

                    // Don't forward this command to the view since we've already handled it.
                    dwCmd = 0;
                }
            }

            AcctUtil_FreeSendReceieveMenu(hMenuPopup, cAcctMenu);
            break;
        }
    }
    
    if (fPostCmd && dwCmd)
        PostMessage(m_hwndSizer, WM_COMMAND, dwCmd, 0);

    if(hMenuPopup)
    {
        //Bug #101338 - (erici) destroy leaked menu
        DestroyMenu(hMenuPopup);
    }
    
    return (TBDDRET_DEFAULT);
}

void CBands::OnContextMenu(HWND hwndFrom, int xPos, int yPos)
{
    HMENU   hMenuContext;
    HWND    hwnd;
    HWND    hwndSizer = GetParent(hwndFrom);
    POINT   pt = {xPos, yPos};
    BOOL    fVisible[MAX_BANDS] = {0};  
    
    // Make sure the context menu only appears on the toolbar bars
    hwnd = WindowFromPoint(pt);

    //Load the default context menu which consists of Toolbar and Filter Bar
    hMenuContext = LoadDefaultContextMenu(fVisible);

    if (hMenuContext)
    {
        if (hwnd == m_hwndTools)
        {
            //Add a seperator and customize buttons
            int             Count;
            MENUITEMINFO    mii = {0};
            TCHAR           Str[CCHMAX_STRINGRES];            

            Count = GetMenuItemCount(hMenuContext);

            //Insert seperator
            mii.cbSize  = sizeof(MENUITEMINFO);
            mii.fMask   = MIIM_TYPE;
            mii.fType   = MFT_SEPARATOR;
            InsertMenuItem(hMenuContext, Count, TRUE, &mii);

            //Insert customize button
            ZeroMemory(Str, ARRAYSIZE(Str));
            LoadString(g_hLocRes, idsTBCustomize, Str, ARRAYSIZE(Str));
        
            ZeroMemory(&mii, sizeof(MENUITEMINFO));
            mii.cbSize          = sizeof(MENUITEMINFO);
            mii.fMask           = MIIM_ID | MIIM_TYPE;
            mii.wID             = ID_CUSTOMIZE;
            mii.fType           = MFT_STRING;
            mii.dwTypeData      = Str;
            mii.cch             = ARRAYSIZE(Str);

            InsertMenuItem(hMenuContext, Count + 1, TRUE, &mii);
        }

        SetFlag(TBSTATE_INMENULOOP);
        TrackPopupMenuEx(hMenuContext, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                               xPos, yPos, hwndFrom, NULL);

        ClearFlag(TBSTATE_INMENULOOP);

        if (hMenuContext)
            DestroyMenu(hMenuContext);

    }
}


LRESULT CBands::OnGetInfoTip(LPNMTBGETINFOTIP   lpnmtb)
{
    int i;

    for (i = 0; i < (int) m_pTBInfo->cAllButtons; i++)
    {
        if (m_pTBInfo->rgAllButtons[i].idCmd == (DWORD)lpnmtb->iItem)
        {
            AthLoadString(m_pTBInfo->rgAllButtons[i].idsTooltip,
                          lpnmtb->pszText, lpnmtb->cchTextMax);
            
            return TRUE;
        }
    }

    return FALSE;
}

//
//  FUNCTION:   CBands::OnGetButtonInfo()
//
//  PURPOSE:    Handles the TBN_GETBUTTONINFO notification by returning
//              the buttons availble for the toolbar.
//
//  PARAMETERS:
//      ptbn - pointer to the TBNOTIFY struct we need to fill in.
//
//  RETURN VALUE:
//      Returns TRUE to tell the toolbar to use this button, or FALSE
//      otherwise.
//
LRESULT CBands::OnGetButtonInfo(TBNOTIFY* ptbn)
{
    UCHAR   fState = 0;
    GUID    *pguidCmdGroup; 
    GUID    guidCmdGroup = CMDSETID_OutlookExpress;

    // Start by returning information for the first array of 
    // buttons
    if (ptbn->iItem < (int) m_pTBInfo->cAllButtons && ptbn->iItem >= 0)
    {
        ptbn->tbButton.iBitmap   = m_pTBInfo->rgAllButtons[ptbn->iItem].iImage;
        ptbn->tbButton.idCommand = m_pTBInfo->rgAllButtons[ptbn->iItem].idCmd;
        ptbn->tbButton.fsStyle   = m_pTBInfo->rgAllButtons[ptbn->iItem].fStyle;
        ptbn->tbButton.iString   = ptbn->iItem;
        ptbn->tbButton.fsState   = TBSTATE_ENABLED;
    
        // Return the string info from the string resource.  Note,
        // pszText already points to a buffer allocated by the
        // control and cchText has the length of that buffer.
        AthLoadString(m_pTBInfo->rgAllButtons[ptbn->iItem].idsButton,
                      ptbn->pszText, ptbn->cchText);

        return (TRUE);
    }

    // No more buttons, so return FALSE
    return (FALSE);
}    


HRESULT CBands::ShowBrand(void)
{
    REBARBANDINFO   rbbi;
    
    // create branding window
    m_hwndBrand = CreateWindow(TEXT("button"), NULL,WS_CHILD | BS_OWNERDRAW,
        0, 0, 0, 0, m_hwndRebar, (HMENU) idcBrand,
        g_hInst, NULL);

    if (!m_hwndBrand)
    {
        DOUTL(1, TEXT("!!!ERROR!!! CITB:Show CreateWindow(BRANDING) failed"));
        return(E_OUTOFMEMORY);
    }
    
    LoadBrandingBitmap();
    m_fBrandLoaded = TRUE;

    // add branding band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE | RBBIM_COLORS | RBBIM_CHILD | RBBIM_ID;
    rbbi.fStyle = RBBS_FIXEDSIZE;
    rbbi.wID    = CBTYPE_BRAND;
    rbbi.clrFore = m_rgbUpperLeft;
    rbbi.clrBack = m_rgbUpperLeft;
    rbbi.hwndChild = m_hwndBrand;
    
    
    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT) -1, (LPARAM) (LPREBARBANDINFO) &rbbi);
    
    return (S_OK);
}

/*
     Helper function for LoadBrandingBitmap

     In IE 2.0, the busy indicator could be branded with a static bitmap.
     This functionality has persisted through 5.0, but in 5.01, the reg
     location for this information moved to HKCU.
*/
HRESULT CBands::HandleStaticLogos(BOOL fSmallBrand)
{
    BOOL fPath = FALSE;
    DIBSECTION dib;
    DWORD cb;
    DWORD dwType;
    HBITMAP hbmOld;
    HDC hdcOld;
    HKEY hkey = NULL;
    HRESULT hr = S_FALSE;
    LPCSTR pcszValue = fSmallBrand ? c_szValueSmallBitmap : c_szValueLargeBitmap;
    LPSTR psz;
    TCHAR szPath[MAX_PATH] = "";
    TCHAR szExpanded[MAX_PATH] = "";

    // **** Read path from registry

    // 5.01 User location (OE5.01 Bug #79804)
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szPath);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey, pcszValue, NULL, &dwType, (LPBYTE)szPath, &cb))
            fPath = TRUE;

        RegCloseKey(hkey);
    }

    // **** Process the bitmap
    if (fPath)
    {
        // Should be REG_(EXPAND_)SZ, but came from the IE's registry so protect ourself
        if ((REG_EXPAND_SZ == dwType) || (REG_SZ == dwType))
        {
            // Expand the pathname if needed
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szPath;

            // Try to load the file
            hbmOld = (HBITMAP) LoadImage(NULL, psz, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            if (hbmOld)
            {
                hdcOld = CreateCompatibleDC(m_hdc);
                if (hdcOld)
                {
                    SelectObject(hdcOld, hbmOld);
                    m_rgbUpperLeft = GetPixel(hdcOld, 1, 1);
                    
                    GetObject(hbmOld, sizeof(dib), &dib);
                    StretchBlt(m_hdc, 0, 0, m_cxBrandExtent, m_cyBrand, hdcOld, 0, 0, dib.dsBm.bmWidth, dib.dsBm.bmHeight, SRCCOPY);
                    
                    DeleteDC(hdcOld);
                }

                DeleteObject(hbmOld);
            }         
        }
        else
            AssertSz(FALSE, "IE Branding of static bitmaps is not REG_SZ / REG_EXPAND_SZ");
    }

    return hr;
}        


HRESULT CBands::LoadBrandingBitmap()
{
    HKEY                hKey;
    DIBSECTION          dib;
    DWORD               dwcbData;
    DWORD               dwType = 0;
    BOOL                fReg = FALSE;
    BOOL                fRegLoaded = FALSE;
    LPTSTR              psz;
    TCHAR               szScratch[MAX_PATH];
    TCHAR               szExpanded[MAX_PATH];
    int                 ToolBandIndex;
    int                 BrandBandIndex;
    DWORD               BrandSize;
    REBARBANDINFO       rbbi = {0};
    BOOL                fSmallBrand;

    ToolBandIndex = (int) SendMessage(m_hwndRebar, RB_IDTOINDEX, CBTYPE_TOOLS, 0);
    BrandBandIndex = (int) SendMessage(m_hwndRebar, RB_IDTOINDEX, CBTYPE_BRAND, 0);

    if (ToolBandIndex != -1)
    {
        //If the toolbar is hidden we should show miniscule bitmap
        rbbi.fMask = RBBIM_STYLE;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, ToolBandIndex, (LPARAM)&rbbi);
        if (!!(rbbi.fStyle & RBBS_HIDDEN))
        {
            BrandSize = BRAND_SIZE_MINISCULE;
        }
        else
        {
            //toolbar band exists
            if (((BrandBandIndex != -1) && (BrandBandIndex > ToolBandIndex)) || 
                (BrandBandIndex == -1))
            {
                //If Brand exists and toolband index is less indicates that the toolbar is on the same row as the brand
                //If Tool band exists and brand doesn't also indicates that the toolbar is on the same row and is just being added
                //In both cases we follow toolbar's sizes.
                BrandSize = ISFLAGSET(m_dwToolbarTextState, TBSTATE_FULLTEXT) ? BRAND_SIZE_LARGE :  BRAND_SIZE_SMALL;
            }
            else
            {
                //We want to load smallest brand image
                BrandSize = BRAND_SIZE_MINISCULE;
            }
        }
    }
    else
    {
        //We want to load small brand image
        BrandSize = BRAND_SIZE_MINISCULE;
    }

    fSmallBrand = !(BrandSize == BRAND_SIZE_LARGE);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        fReg     = TRUE;
        dwcbData = MAX_PATH;

        if (fReg && (ERROR_SUCCESS == RegQueryValueEx(hKey, fSmallBrand ? c_szValueSmBrandBitmap : c_szValueBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &dwcbData)))
        {
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szScratch, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szScratch;

            if (m_hbmBrand)
            {
                DeleteObject(m_hbmBrand);
                m_hbmBrand = NULL;
            }

            m_hbmBrand = (HBITMAP) LoadImage(NULL, psz, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);

            if (m_hbmBrand)
                fRegLoaded = TRUE;
        }
    }

    if ((!m_hbmBrand) || (!fRegLoaded))
    {
        if (m_fBrandLoaded)
        {
            if (BrandSize == m_dwBrandSize)
            {    
                if (fReg && hKey)
                {
                    RegCloseKey(hKey);
                }

                return S_OK;
            }
        }

        if (m_hbmBrand)
        {
            DeleteObject(m_hbmBrand);
            m_hbmBrand = NULL;
        }

        int     id;

        switch (BrandSize)
        {
            case BRAND_SIZE_LARGE:
                id = (fIsWhistler() ? idbHiBrand38 : idbBrand38);
                break;
            case BRAND_SIZE_SMALL:
            default:
                id = (fIsWhistler() ? idbHiBrand26 : idbBrand26);
                break;
            case BRAND_SIZE_MINISCULE:
                id = (fIsWhistler() ? idbHiBrand22 : idbBrand22);
                break;
        }
        m_hbmBrand = (HBITMAP)LoadImage(g_hLocRes, MAKEINTRESOURCE(id), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
        m_dwBrandSize = BrandSize;

    } //    if (!m_hbmBrand)


    GetObject(m_hbmBrand, sizeof(DIBSECTION), &dib);
    m_cxBrandExtent = dib.dsBm.bmWidth;
    m_cyBrandExtent = dib.dsBm.bmHeight;

    m_cxBrand = m_cxBrandExtent;

    dwcbData = sizeof(DWORD);

    if (!fRegLoaded || (ERROR_SUCCESS != RegQueryValueEx(hKey, fSmallBrand ? c_szValueSmBrandHeight : c_szValueBrandHeight, NULL, &dwType,
        (LPBYTE)&m_cyBrand, &dwcbData)))
        m_cyBrand = m_cxBrandExtent;


    if (!fRegLoaded || (ERROR_SUCCESS != RegQueryValueEx(hKey, fSmallBrand ? c_szValueSmBrandLeadIn : c_szValueBrandLeadIn, NULL, &dwType,
        (LPBYTE)&m_cyBrandLeadIn, &dwcbData)))
        m_cyBrandLeadIn = 4;

    m_cyBrandLeadIn *= m_cyBrand;

    SelectObject(m_hdc, m_hbmBrand);

    m_rgbUpperLeft = GetPixel(m_hdc, 1, 1);

    if (fReg)
        RegCloseKey(hKey);

    // Brand "Busy" indicator with static logos if specified
    HandleStaticLogos(fSmallBrand);

    return(S_OK);
}


  
void CBands::DrawBranding(LPDRAWITEMSTRUCT lpdis)
{
    HPALETTE hpalPrev;
    int     x, y, cx, cy;
    int     yOrg = 0;
    
    if (IsFlagSet(TBSTATE_ANIMATING))
        yOrg = m_yOrg;
    
    if (IsFlagSet(TBSTATE_FIRSTFRAME))
    {
        REBARBANDINFO rbbi;
        int cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
        
        ZeroMemory(&rbbi, sizeof(rbbi));
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask  = RBBIM_ID;
        
        for (int i = 0; i < cBands; i++)
        {
            SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
            
            if (CBTYPE_BRAND == rbbi.wID)
            {
                rbbi.fMask = RBBIM_COLORS;
                rbbi.clrFore = m_rgbUpperLeft;
                rbbi.clrBack = m_rgbUpperLeft;
                
                SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                break;
            }
        }
        
        ClearFlag(TBSTATE_FIRSTFRAME);
    }
    
    if (m_hpal)
    {
        hpalPrev = SelectPalette(lpdis->hDC, m_hpal, TRUE);
        RealizePalette(lpdis->hDC);
    }
    
    x  = lpdis->rcItem.left;
    cx = lpdis->rcItem.right - x;
    y  = lpdis->rcItem.top;
    cy = lpdis->rcItem.bottom - y;
    
    if (m_cxBrand > m_cxBrandExtent)
    {
        HBRUSH  hbrBack = CreateSolidBrush(m_rgbUpperLeft);
        int     xRight = lpdis->rcItem.right;
        
        x += (m_cxBrand - m_cxBrandExtent) / 2;
        cx = m_cxBrandExtent;
        lpdis->rcItem.right = x;
        FillRect(lpdis->hDC, &lpdis->rcItem, hbrBack);
        lpdis->rcItem.right = xRight;
        lpdis->rcItem.left = x + cx;
        FillRect(lpdis->hDC, &lpdis->rcItem, hbrBack);
        
        DeleteObject(hbrBack);
    }
    
    BitBlt(lpdis->hDC, x, y, cx, cy, m_hdc, 0, yOrg, IS_DC_RTL_MIRRORED(lpdis->hDC)
           ? SRCCOPY | DONTMIRRORBITMAP : SRCCOPY);           
    
    if (m_hpal)
    {
        SelectPalette(lpdis->hDC, hpalPrev, TRUE);
        RealizePalette(lpdis->hDC);
    }
}
    
BOOL CBands::SetMinDimensions(void)
{
    REBARBANDINFO rbbi;
    LRESULT       lButtonSize;
    int           i, cBands;
    
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    
    cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    
    for (i = 0; i < cBands; i++)
    {
        rbbi.fMask = RBBIM_ID;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        
        switch (rbbi.wID)
        {
        case CBTYPE_BRAND:
            rbbi.cxMinChild = m_cxBrand;
            rbbi.cyMinChild = m_cyBrand;
            rbbi.fMask = RBBIM_CHILDSIZE;
            SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM)&rbbi);
            break;
            
        case CBTYPE_TOOLS:
            if (m_hwndTools)
            {
                SIZE    size = {0};
                RECT    rc = {0};

                lButtonSize = SendMessage(m_hwndTools, TB_GETBUTTONSIZE, 0, 0L);

                GetClientRect(m_hwndTools, &rc);

                // set height to be max of toolbar width and toolbar button width
                size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));

                // have toolbar calculate width given that height
                SendMessage(m_hwndTools, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);

                rbbi.cxMinChild = LOWORD(lButtonSize);
                rbbi.cyMinChild = HIWORD(lButtonSize);
                rbbi.fMask = RBBIM_CHILDSIZE /*| RBBIM_IDEALSIZE*/;
            
                rbbi.cxIdeal    = size.cx;

                SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM)&rbbi);
            }
            break;

        }
    }
    return TRUE;
}

void CBands::CalcIdealSize()
{
    SIZE            size = {0};
    RECT            rc = {0};
    LONG            lButtonSize;
    REBARBANDINFO   rbbi = {0};
    int             Index;

    if (m_hwndTools)
        GetClientRect(m_hwndTools, &rc);

    lButtonSize = (LONG) SendMessage(m_hwndTools, TB_GETBUTTONSIZE, 0, 0L);
 
    // set height to be max of toolbar width and toolbar button width
    //size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));
    
    // have toolbar calculate width given that height
    SendMessage(m_hwndTools, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);

    Index = (int) SendMessage(m_hwndRebar, RB_IDTOINDEX, CBTYPE_TOOLS, 0);

    rbbi.cbSize  = sizeof(REBARBANDINFO);
    rbbi.fMask   = RBBIM_IDEALSIZE;
    rbbi.cxIdeal = size.cx;
    SendMessage(m_hwndRebar, RB_SETBANDINFO, Index, (LPARAM)&rbbi);

}

BOOL CBands::CompressBands(DWORD    dwText)
{
    LRESULT         lTBStyle = 0;
    int             i, cBands;
    REBARBANDINFO   rbbi;
    
    if (_GetTextState() == dwText)
    {
        //No Change
        return FALSE;
    }
    
    SetTextState(dwText);

    m_yOrg = 0;
    LoadBrandingBitmap();
    
    cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);

    for (i = 0; i < cBands; i++)
    {
        rbbi.fMask = RBBIM_ID;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        
        if (dwText == TBSTATE_NOTEXT)
        {
            switch (rbbi.wID)
            {
            case CBTYPE_TOOLS:
                SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, 0, 0L);
                SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0,MAX_TB_COMPRESSED_WIDTH));
                break;
            }            
        } 
        else
        {
            switch (rbbi.wID)
            {
            case CBTYPE_TOOLS:
                SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, MAX_TB_TEXT_ROWS_HORZ, 0L);
                SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, m_cxMaxButtonWidth));
                break;
            }
        }
    }

    if (_GetTextState() == TBSTATE_PARTIALTEXT)
        _ChangeSendReceiveText(idsSendReceive);
    else
        _ChangeSendReceiveText(idsSendReceiveBtn);

    SetMinDimensions();   

    CalcIdealSize();

    return(TRUE);
}

void CBands::_ChangeSendReceiveText(int ids)
{
    TBBUTTONINFO    ptbi = {0};
    TCHAR           szText[CCHMAX_STRINGRES];
    
    ZeroMemory(szText, ARRAYSIZE(szText));
    LoadString(g_hLocRes, ids, szText, ARRAYSIZE(szText));

    ptbi.cbSize     = sizeof(TBBUTTONINFO);
    ptbi.dwMask     = TBIF_TEXT;
    ptbi.pszText    = szText;
    ptbi.cchText    = ARRAYSIZE(szText);

    //if the text style is partial text, show the text of Send & Recv button as Send/Receive
    SendMessage(m_hwndTools, TB_SETBUTTONINFO, ID_SEND_RECEIVE, (LPARAM)&ptbi);
}

#define ABS(x)  (((x) < 0) ? -(x) : (x))

void CBands::TrackSliding(int x, int y)
{
    int     cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0L);
    int     cRows  = (int) SendMessage(m_hwndRebar, RB_GETROWCOUNT, 0, 0L);
    int     cyHalfRow  = (int) SendMessage(m_hwndRebar, RB_GETROWHEIGHT, cBands - 1, 0L)/2;
    RECT    rc;
    int     cyBefore;
    int     Delta;
    BOOL    fChanged;
    DWORD   dwPrevState;
    DWORD   dwNewState;

    // do this instead of GetClientRect so that we include borders
    GetWindowRect(m_hwndRebar, &rc);
    MapWindowPoints(HWND_DESKTOP, m_hwndRebar, (LPPOINT)&rc, 2);
    cyBefore = rc.bottom - rc.top;

    Delta = y - m_yCapture;

    // was there enough change?
    if (ABS(Delta) <= cyHalfRow)
        return;

    dwPrevState = _GetTextState();

    if (Delta < -cyHalfRow)
    {
        dwNewState = TBSTATE_NOTEXT;

        UpdateTextSettings(dwNewState);
    }
    else
    {
        dwNewState = m_dwPrevTextStyle;

        UpdateTextSettings(dwNewState);
    }

    fChanged = (dwPrevState != dwNewState);

    if (fChanged) 
    {
                //Save the Text Labels into the registry
        AthUserSetValue(NULL, c_szRegToolbarText, REG_DWORD, (LPBYTE)&m_dwToolbarTextState, sizeof(DWORD));

        /*
        if (m_dwParentType == PARENT_TYPE_NOTE)
        {
            CBands  *pCoolbar = NULL;

            //Inform the browser
            g_pBrowser->GetCoolbar(&pCoolbar);

            if (pCoolbar)
            {
                pCoolbar->UpdateTextSettings(m_dwToolbarTextState);
            }
        }
        */
    }

    if (!fChanged) 
    {
        // if the compressing bands didn't change anything, try to fit it to size
        fChanged = !!SendMessage(m_hwndRebar, RB_SIZETORECT, 0, (LPARAM)&rc);
    }
}
    
//
//  FUNCTION:   CBands::CreateRebar(BOOL fVisible)
//
//  PURPOSE:    Creates a new rebar and sizer window.
//
//  RETURN VALUE:
//      Returns S_OK if the bar was created and inserted correctly, 
//      hrAlreadyExists if a band already is in that position, 
//      E_OUTOFMEMORY if a window couldn't be created.
//
HRESULT CBands::CreateRebar(BOOL fVisible)
{
    if (m_hwndSizer)
        return (hrAlreadyExists);
    
    m_hwndSizer = CreateWindowEx(0, SIZABLECLASS, NULL, WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | (fVisible ? WS_VISIBLE : 0),
        0, 0, 100, 36, m_hwndParent, (HMENU) 0, g_hInst, NULL);
    if (m_hwndSizer)
    {
        DOUTL(4, TEXT("Calling SetProp. AddRefing new m_cRef=%d"), m_cRef + 1);
        AddRef();  // Note we Release in WM_DESTROY
        SetProp(m_hwndSizer, TEXT("CBands"), this);

        m_hwndRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP | RBS_DBLCLKTOGGLE |
                           WS_VISIBLE | WS_BORDER | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                            0, 0, 100, 136, m_hwndSizer, (HMENU) idcCoolbar, g_hInst, NULL);
        if (m_hwndRebar)
        { 
            SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
            SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
			SendMessage(m_hwndRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);
            return (S_OK);
        }
    }
    
    DestroyWindow(m_hwndSizer);    
    return (E_OUTOFMEMORY);    
}

//
//  FUNCTION:   CBands::SaveSettings()
//
//  PURPOSE:    Called when we should save our state out to the specified reg
//              key.
//
void CBands::SaveSettings(void)
{
    char            szSubKey[MAX_PATH], sz[MAX_PATH];
    DWORD           iBand;
    REBARBANDINFO   rbbi;
    HKEY            hKey;
    DWORD           cBands;
    DWORD           dwShowToolbar = 1;

    // If we don't have the window, there is nothing to save.
    if (!m_hwndRebar || !m_pTBInfo)
        return;
    
    ZeroMemory(&rbbi, sizeof(REBARBANDINFO));
    
    cBands = (DWORD) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);

    m_pSavedBandInfo->dwVersion = c_DefaultTable[m_dwParentType].dwVersion;
    m_pSavedBandInfo->cBands    = cBands;

    // Loop through the bands and save their information as well
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE | RBBIM_CHILD | RBBIM_SIZE | RBBIM_ID;
    
    for (iBand = 0; iBand < m_pSavedBandInfo->cBands; iBand++)
    {
        Assert(IsWindow(m_hwndRebar));
        if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
        {
            // Save the information that we care about with this band
            m_pSavedBandInfo->BandData[iBand].cx      = rbbi.cx;
            m_pSavedBandInfo->BandData[iBand].dwStyle = rbbi.fStyle;
            m_pSavedBandInfo->BandData[iBand].wID     = rbbi.wID;
            
            if (rbbi.wID == CBTYPE_TOOLS)
            {
                dwShowToolbar = !(rbbi.fStyle & RBBS_HIDDEN);
            }

            // If this band has a toolbar, then we should instruct the toolbar
            // to save it's information now
            if (m_pSavedBandInfo->BandData[iBand].wID == CBTYPE_TOOLS)
            {
                SendSaveRestoreMessage(rbbi.hwndChild, TRUE);
            }
        }
        else
        {
            // Default Values
            m_pSavedBandInfo->BandData[iBand].wID       = CBTYPE_NONE;
            m_pSavedBandInfo->BandData[iBand].dwStyle   = 0;
            m_pSavedBandInfo->BandData[iBand].cx        = 0;
        }
    }
    
    // We have all the information collected, now save that to the specified
    // registry location
    AthUserSetValue(NULL, c_BandRegKeyInfo[m_dwParentType], REG_BINARY, (const LPBYTE)m_pSavedBandInfo, 
        m_cSavedBandInfo);
    
    //This reg key is set by IEAK.
    AthUserSetValue(NULL, c_szShowToolbarIEAK, REG_DWORD, (LPBYTE)&dwShowToolbar, sizeof(DWORD));

    //Save Text Settings
    AthUserSetValue(NULL, c_szRegToolbarText, REG_DWORD, (LPBYTE)&m_dwToolbarTextState, sizeof(DWORD));

    //Save Icon Settings
    AthUserSetValue(NULL, c_szRegToolbarIconSize, REG_DWORD, (LPBYTE)&m_dwIconSize, sizeof(DWORD));

    AthUserSetValue(NULL, c_szRegPrevToolbarText, REG_DWORD, (LPBYTE)&m_dwPrevTextStyle, sizeof(DWORD));
}

    
//
//  FUNCTION:   CBands::AddTools()
//
//  PURPOSE:    Inserts the primary toolbar into the coolbar.
//
//  PARAMETERS:
//      pbs - Pointer to a PBANDSAVE struct with the styles and size of the
//            band to insert.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
HRESULT CBands::AddTools(PBANDSAVE pbs)
{    
    REBARBANDINFO   rbbi;
    
    // add tools band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_ID | RBBIM_STYLE;
    rbbi.fStyle     = pbs->dwStyle;
    rbbi.cx         = pbs->cx;
    rbbi.wID        = pbs->wID;
    
    if (m_hbmBack)
    {
        rbbi.fMask   |= RBBIM_BACKGROUND;
        rbbi.fStyle  |= RBBS_FIXEDBMP;
        rbbi.hbmBack = m_hbmBack;
    }
    else
    {
        rbbi.fMask      |= RBBIM_COLORS;
        rbbi.clrFore    = GetSysColor(COLOR_BTNTEXT);
        rbbi.clrBack    = GetSysColor(COLOR_BTNFACE);
    }

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT) -1, (LPARAM) (LPREBARBANDINFO) &rbbi);
    
    return(S_OK);
}

void    CBands::LoadBackgroundImage()
{
    int             Count = 0;
    REBARBANDINFO   rbbi = {0};
    TCHAR           szBitMap[MAX_PATH] = {0};
    DWORD           dwType;
    DWORD           cbData;
    BOOL            fBranded = FALSE;

    //First check if there is a customized background bitmap for us.
    cbData = ARRAYSIZE(szBitMap);
    if ((SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, c_szValueBackBitmapIE5, &dwType, szBitMap, &cbData) 
        == ERROR_SUCCESS) && (*szBitMap))
        fBranded = TRUE;
    // Could be old branding in place, so try that
    else if ((SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, c_szValueBackBitmap, &dwType, szBitMap, &cbData) 
        == ERROR_SUCCESS) && (*szBitMap))
        fBranded = TRUE;
    
    if (fBranded)
    {
        ClearFlag(TBSTATE_NOBACKGROUND);
        m_hbmBack = (HBITMAP)LoadImage(NULL, szBitMap, IMAGE_BITMAP, 0, 0, 
            LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    }
    else
    {
        if (IsFlagClear(TBSTATE_NOBACKGROUND) && !m_hbmBack && m_idbBack)
        {
            m_hbmBack = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(m_idbBack), 
            IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
        }
    }
}

HRESULT CBands::SetFolderType(FOLDERTYPE ftType)
{
    TCHAR         szToolsText[(MAX_TB_TEXT_LENGTH+2) * MAX_TB_BUTTONS];
    int           i, cBands;
    REBARBANDINFO rbbi;
    HWND          hwndDestroy = NULL;
    
    // If we haven't created the rebar yet, this will fail.  Call ShowDW() first.
    if (!IsWindow(m_hwndRebar))
        return (E_FAIL);
    
    // Check to see if this would actually be a change
    if (ftType == m_ftType)
        return (S_OK);
    
    // First find the band with the toolbar
    cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_TOOLS == rbbi.wID)
            break;
    }
    
    // We didn't find it.
    if (i >= cBands)
        return (E_FAIL);
    
    // Destroy the old toolbar if it exists
    if (IsWindow(m_hwndTools))
    {
        // Save it's button configuration
        SendSaveRestoreMessage(m_hwndTools, TRUE);
        
        CleanupImages(m_hwndTools);
        
        hwndDestroy = m_hwndTools;
    }
    
    // Update our internal state information with the new folder type
    Assert(((m_dwParentType == PARENT_TYPE_BROWSER) && (ftType < FOLDER_TYPESMAX)) ||
        ((m_dwParentType == PARENT_TYPE_NOTE) && (ftType < NOTETYPES_MAX)));

    m_ftType = ftType;

    const TOOLBAR_INFO *ParentToolbarArrayInfo = c_DefButtonInfo[m_dwParentType];
    m_pTBInfo = &(ParentToolbarArrayInfo[m_ftType]);

    // Create a new toolbar
    m_hwndTools = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                 WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS 
                                 | WS_CLIPCHILDREN | WS_CLIPSIBLINGS 
                                 | CCS_NODIVIDER | CCS_NOPARENTALIGN 
                                 | CCS_ADJUSTABLE | CCS_NORESIZE,
                                 0, 0, 0, 0, m_hwndRebar, (HMENU) idcToolbar, 
                                 g_hInst, NULL);
    
    Assert(m_hwndTools);
    if (!m_hwndTools)
    {
        DOUTL(1, TEXT("CBands::SetFolderType() CreateWindow(TOOLBAR) failed"));
        return(E_OUTOFMEMORY);
    }
    
    _InitToolbar(m_hwndTools);
    
    // If we have previously save configuration info for this toolbar, load it 
    SendSaveRestoreMessage(m_hwndTools, FALSE);
    
    // First find the band with the toolbar
    cBands = (int) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_TOOLS == rbbi.wID)
            break;
    }
    
    POINT   ptIdeal = {0};
    SendMessage(m_hwndTools, TB_GETIDEALSIZE, FALSE, (LPARAM)&ptIdeal);
    
    // Add the toolbar to the rebar
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_CHILD | RBBIM_IDEALSIZE;
    rbbi.hwndChild  = m_hwndTools;
    rbbi.cxIdeal    = ptIdeal.x;
    
    SendMessage(m_hwndRebar, RB_SETBANDINFO, (UINT) i, (LPARAM) (LPREBARBANDINFO) &rbbi);
    if (hwndDestroy)
        DestroyWindow(hwndDestroy);

    SetMinDimensions();
    ResizeBorderDW(NULL, NULL, FALSE);
    
    return (S_OK);
}

HRESULT CBands::UpdateViewState()
{
    //Enable/disable the ViewsCombo box
    OLECMD      olecmd = {0};

    olecmd.cmdID = ID_VIEW_APPLY;

    if (SUCCEEDED(m_ptbSiteCT->QueryStatus(&CMDSETID_OutlookExpress, 1, &olecmd, NULL)))
    {
        EnableWindow(m_hwndFilterCombo, !!(olecmd.cmdf & OLECMDF_ENABLED));
    }

    //Enable/disable the ViewsToolbar buttons 
    return Update(m_hwndRulesToolbar);

}

void CBands::UpdateToolbarColors(void)
{
    UpdateRebarBandColors(m_hwndRebar);
}


HRESULT CBands::OnConnectionNotify(CONNNOTIFY nCode, 
    LPVOID                 pvData,
    CConnectionManager     *pConMan)
{
    if ((m_hwndTools) && (nCode == CONNNOTIFY_WORKOFFLINE))
    {
        SendMessage(m_hwndTools, TB_CHECKBUTTON, ID_WORK_OFFLINE, (LPARAM)MAKELONG(pvData, 0));
    }
    return S_OK;
}

HRESULT CBands::Update()
{
    return Update(m_hwndTools);
}

HRESULT CBands::Update(HWND     hwnd)
{
    DWORD               cButtons = 0;
    OLECMD             *rgCmds;
    TBBUTTON            tb;
    DWORD               cCmds = 0;
    DWORD               i;
    DWORD               dwState;

    // It's possible to get this before the toolbar is created
    if (!IsWindow(hwnd))
        return (S_OK);
    
    // Get the number of buttons on the toolbar
    cButtons = (DWORD) SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0);
    if (0 == cButtons) 
        return (S_OK);
    
    // Allocate an array of OLECMD structures for the buttons
    if (!MemAlloc((LPVOID *) &rgCmds, sizeof(OLECMD) * cButtons))
        return (E_OUTOFMEMORY);
    
    // Loop through the buttons and get the ID for each
    for (i = 0; i < cButtons; i++)
    {
        if (SendMessage(hwnd, TB_GETBUTTON, i, (LPARAM) &tb))
        {
            // Toolbar returns zero for seperators
            if (tb.idCommand)
            {
                rgCmds[cCmds].cmdID = tb.idCommand;
                rgCmds[cCmds].cmdf  = 0;
                cCmds++;
            }
        }
    }
    
    // I don't see how this can be false
    Assert(m_ptbSite);
    
    // Do the QueryStatus thing    

    if (m_ptbSiteCT)
    {
        if (SUCCEEDED(m_ptbSiteCT->QueryStatus(&CMDSETID_OutlookExpress, cCmds, rgCmds, NULL)))
        {
            // Go through the array now and do the enable / disable thing
            for (i = 0; i < cCmds; i++)
            {
                // Get the current state of the button
                dwState = (DWORD) SendMessage(hwnd, TB_GETSTATE, rgCmds[i].cmdID, 0);
                
                // Update the state with the feedback we've been provided
                if (rgCmds[i].cmdf & OLECMDF_ENABLED)
                    dwState |= TBSTATE_ENABLED;
                else
                    dwState &= ~TBSTATE_ENABLED;
                
                if (rgCmds[i].cmdf & OLECMDF_LATCHED)
                    dwState |= TBSTATE_CHECKED;
                else
                    dwState &= ~TBSTATE_CHECKED;
                
                // Radio check has no meaning here.
                Assert(0 == (rgCmds[i].cmdf & OLECMDF_NINCHED));
                
                SendMessage(hwnd, TB_SETSTATE, rgCmds[i].cmdID, dwState);

            }
        }
        
    }
    
    MemFree(rgCmds);
    
    return (S_OK);
}

HRESULT CBands::CreateMenuBand(PBANDSAVE pbs)
{
    HRESULT     hres;
    HWND        hwndBrowser;
    HMENU       hMenu;
    IShellMenu  *pShellMenu;
    DWORD       dwFlags = 0;

    //Cocreate menuband
    hres = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_IShellMenu, (LPVOID*)&m_pShellMenu);
    if ((hres != S_OK) || (m_pShellMenu == NULL))
    {
        return hres;
    }

    dwFlags = SMINIT_HORIZONTAL | SMINIT_TOPLEVEL | SMINIT_DEFAULTTOTRACKPOPUP;

    /*
    if (m_dwParentType == PARENT_TYPE_BROWSER)
        dwFlags |= SMINIT_USEMESSAGEFILTER;
    */

    m_pShellMenu->Initialize(NULL, -1, ANCESTORDEFAULT, dwFlags);

    m_pShellMenu->SetMenu(m_hMenu, m_hwndParent, SMSET_DONTOWN);

    hres = AddMenuBand(pbs);

    return hres;
}

HRESULT CBands::ResetMenu(HMENU hmenu)
{
    if (m_pShellMenu)
    {
        m_hMenu = hmenu;
        m_pShellMenu->SetMenu(m_hMenu, m_hwndParent, SMSET_DONTOWN | SMSET_MERGE);
    }

    MenuUtil_EnableMenu(m_hMenu, m_ptbSiteCT);

    return(S_OK);
}

HRESULT CBands::AddMenuBand(PBANDSAVE pbs)
{
    REBARBANDINFO   rbbi;
    HRESULT         hres;
    HWND            hwndMenuBand = NULL;
    IObjectWithSite *pObj;

    //We don't get here if m_pShellMenu is null. But we want to be safe
    if (m_pShellMenu)
    {
        hres = m_pShellMenu->QueryInterface(IID_IDeskBand, (LPVOID*)&m_pDeskBand);
        if (FAILED(hres))
            return hres;

        hres = m_pShellMenu->QueryInterface(IID_IMenuBand, (LPVOID*)&m_pMenuBand);
        if (FAILED(hres))
            return hres;

        hres = m_pDeskBand->QueryInterface(IID_IWinEventHandler, (LPVOID*)&m_pWinEvent);
        if (FAILED(hres))
            return hres;

        hres = m_pDeskBand->QueryInterface(IID_IObjectWithSite, (LPVOID*)&pObj);
        if (FAILED(hres))
            return hres;

        pObj->SetSite((IDockingWindow*)this);
        pObj->Release();

        m_pDeskBand->GetWindow(&m_hwndMenuBand);

        DESKBANDINFO    DeskBandInfo = {0};
        m_pDeskBand->GetBandInfo(pbs->wID, 0, &DeskBandInfo);

        ZeroMemory(&rbbi, sizeof(rbbi));
        rbbi.cbSize     = sizeof(REBARBANDINFO);
        rbbi.fMask      = RBBIM_SIZE | RBBIM_ID | RBBIM_STYLE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE;
        rbbi.fStyle     = pbs->dwStyle;
        rbbi.cx         = pbs->cx;
        rbbi.wID        = pbs->wID;
        rbbi.hwndChild  = m_hwndMenuBand;
        rbbi.cxMinChild = DeskBandInfo.ptMinSize.x;
        rbbi.cyMinChild = DeskBandInfo.ptMinSize.y;
        rbbi.cxIdeal    = DeskBandInfo.ptActual.x;
    
        if (m_hbmBack)
        {
            rbbi.fMask   |= RBBIM_BACKGROUND;
            rbbi.fStyle  |= RBBS_FIXEDBMP;
            rbbi.hbmBack  = m_hbmBack;
        }

        SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);


        SetForegroundWindow(m_hwndParent);

        m_pDeskBand->ShowDW(TRUE);

        SetNotRealSite();
    
    }
    return S_OK;
}

HRESULT CBands::TranslateMenuMessage(MSG  *pmsg, LRESULT  *lpresult)
{
    if (m_pMenuBand)
        return m_pMenuBand->TranslateMenuMessage(pmsg, lpresult);
    else
        return S_FALSE;
}

HRESULT CBands::IsMenuMessage(MSG *lpmsg)
{
    if (m_pMenuBand)
        return m_pMenuBand->IsMenuMessage(lpmsg);
    else
        return S_FALSE;
}

void CBands::SetNotRealSite()
{
    IOleCommandTarget   *pOleCmd;

    if (m_pDeskBand->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pOleCmd) == S_OK)
    {
        //pOleCmd->Exec(&CGID_MenuBand, MBANDCID_NOTAREALSITE, TRUE, NULL, NULL);
        pOleCmd->Exec(&CLSID_MenuBand, 3, TRUE, NULL, NULL);
        pOleCmd->Release();
    }
}

HMENU   CBands::LoadDefaultContextMenu(BOOL *fVisible)
{
        // Load the context menu
    HMENU hMenu = LoadPopupMenu(IDR_COOLBAR_POPUP);

    if (m_dwParentType == PARENT_TYPE_NOTE)
    {
        //Remove filter bar from the menu
        DeleteMenu(hMenu, ID_SHOW_FILTERBAR, MF_BYCOMMAND);
    }

    if (hMenu)
    {
        // Loop through the bands and see which ones are visible
        DWORD cBands, iBand;
        REBARBANDINFO rbbi = {0};

        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE | RBBIM_ID;

        cBands = (DWORD) SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
        for (iBand = 0; iBand < cBands; iBand++)
        {
            if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
            {
                if (!(rbbi.fStyle & RBBS_HIDDEN))
                {
                    switch (rbbi.wID)
                    {
                        case CBTYPE_TOOLS:
                            fVisible[CBTYPE_TOOLS - CBTYPE_BASE] = TRUE;
                            CheckMenuItem(hMenu, ID_SHOW_TOOLBAR, MF_BYCOMMAND | MF_CHECKED);
                            break;

                        case CBTYPE_RULESTOOLBAR:
                            fVisible[CBTYPE_RULESTOOLBAR - CBTYPE_BASE] = TRUE;
                            CheckMenuItem(hMenu, ID_SHOW_FILTERBAR, MF_BYCOMMAND | MF_CHECKED);
                            break;
                    }
                }
            }
        }
    }
    return hMenu;
}

HWND CBands::GetToolbarWnd()
{
    return m_hwndTools;
}

HWND CBands::GetRebarWnd()
{
    return m_hwndRebar;
}

void CBands::SendSaveRestoreMessage(HWND hwnd, BOOL fSave)
{
    TBSAVEPARAMS    tbsp;
    char            szSubKey[MAX_PATH], sz[MAX_PATH];
    DWORD           dwType;
    DWORD           dwVersion;
    DWORD           cbData = sizeof(DWORD);
    DWORD           dwError;
    
    tbsp.hkr = AthUserGetKeyRoot();
    AthUserGetKeyPath(sz, ARRAYSIZE(sz));
    if (m_pTBInfo->pszRegKey != NULL)
    {
        wsprintf(szSubKey, c_szPathFileFmt, sz, m_pTBInfo->pszRegKey);
        tbsp.pszSubKey = szSubKey;
    }
    else
    {
        tbsp.pszSubKey = sz;
    }
    tbsp.pszValueName = m_pTBInfo->pszRegValue;

    // First check to see if the version has changed
    if (!fSave)
    {
        if (ERROR_SUCCESS == AthUserGetValue(m_pTBInfo->pszRegKey, c_szRegToolbarVersion, &dwType, (LPBYTE) &dwVersion, &cbData))
        {
            if (dwVersion == c_DefaultTable[m_dwParentType].dwVersion)    
                SendMessage(hwnd, TB_SAVERESTORE, (WPARAM)fSave, (LPARAM)&tbsp);
        }
    }
    else
    {
        dwVersion = c_DefaultTable[m_dwParentType].dwVersion;
        SendMessage(hwnd, TB_SAVERESTORE, (WPARAM)fSave, (LPARAM)&tbsp);
        dwError = AthUserSetValue(m_pTBInfo->pszRegKey, c_szRegToolbarVersion, REG_DWORD, (LPBYTE) &dwVersion, cbData);
    }
}


void CBands::InitRulesToolbar()
{
    TCHAR   szToolsText[(MAX_TB_TEXT_LENGTH+2) * MAX_TB_BUTTONS];
    int     idBmp;
    TCHAR   *szActual;

    // Tell the toolbar some basic information
    SendMessage(m_hwndRulesToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndRulesToolbar, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_HIDECLIPPEDBUTTONS);

    // Tell the toolbar the number of rows of text and button width based
    // on whether or not we're showing text below the buttons or not.
    SendMessage(m_hwndRulesToolbar, TB_SETMAXTEXTROWS, 1, 0);
    SendMessage(m_hwndRulesToolbar, TB_SETBUTTONWIDTH, 0, MAKELONG(0, MAX_TB_COMPRESSED_WIDTH));

    // Now load the buttons into the toolbar
    _SetImages(m_hwndRulesToolbar, (fIsWhistler() ? 
        ((GetCurColorRes() > 24) ? c_32RulesImageList : c_RulesImageList) 
              : c_NWRulesImageList ));

    _LoadStrings(m_hwndRulesToolbar, (TOOLBAR_INFO *) c_rgRulesToolbarInfo);
    _LoadDefaultButtons(m_hwndRulesToolbar, (TOOLBAR_INFO *) c_rgRulesToolbarInfo);
}

HRESULT CBands::AddRulesToolbar(PBANDSAVE pbs)
{
    REBARBANDINFO   rbbi = {0};

    m_hwndRulesToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
        WS_CHILD | TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS 
        | WS_CLIPCHILDREN | WS_CLIPSIBLINGS 
        | CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
        0, 0, 0, 0, m_hwndRebar, (HMENU) NULL, 
        g_hInst, NULL);

    SendMessage(m_hwndRulesToolbar, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, TBSTYLE_EX_MIXEDBUTTONS);

    AddComboBox();
    InitRulesToolbar();
 
    LRESULT     lButtonSize;
    lButtonSize = SendMessage(m_hwndRulesToolbar, TB_GETBUTTONSIZE, 0, 0L);

    TCHAR   szBuf[CCHMAX_STRINGRES];
    LoadString(g_hLocRes, idsRulesToolbarTitle, szBuf, ARRAYSIZE(szBuf));
    rbbi.lpText     = szBuf;

    

    rbbi.cxMinChild = LOWORD(lButtonSize);
    rbbi.cyMinChild = HIWORD(lButtonSize);

    rbbi.wID        = pbs->wID;
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_STYLE | RBBIM_ID | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_TEXT | RBBIM_SIZE;
    rbbi.cx         = pbs->cx;
    rbbi.fStyle     = pbs->dwStyle;
    rbbi.hwndChild  = m_hwndRulesToolbar;
    if (m_hbmBack)
    {
        rbbi.fMask   |= RBBIM_BACKGROUND;
        rbbi.fStyle  |= RBBS_FIXEDBMP;
        rbbi.hbmBack  = m_hbmBack;
    }
    else
    {
        rbbi.fMask      |= RBBIM_COLORS;
        rbbi.clrFore    = GetSysColor(COLOR_BTNTEXT);
        rbbi.clrBack    = GetSysColor(COLOR_BTNFACE);
    }

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)&rbbi);
    
    return S_OK;
}

void CBands::FilterBoxFontChange()
{
    int     Count;
    int     MaxLen = 0;
    int     CurLen = 0;
    LPTSTR  szMaxName;

    Count = ComboBox_GetCount(m_hwndFilterCombo);

    if (Count != CB_ERR)
    {
        if (Count > 0)
        {
            if (MemAlloc((LPVOID*)&szMaxName, CCHMAX_STRINGRES))
            {
                ZeroMemory(szMaxName, CCHMAX_STRINGRES);
                while (--Count >= 0)
                {
                    CurLen = ComboBox_GetLBTextLen(m_hwndFilterCombo, Count);

                    if (CurLen > MaxLen)
                    {
                        if (CurLen > CCHMAX_STRINGRES)
                        {
                            if (MemRealloc((LPVOID*)&szMaxName, CurLen * sizeof(TCHAR)))
                            {
                                ZeroMemory(szMaxName, CurLen * sizeof(TCHAR));
                            }
                            else
                                szMaxName = NULL;
                        }

                        if (szMaxName)
                        {
                            ComboBox_GetLBText(m_hwndFilterCombo, Count, szMaxName);
                            MaxLen = CurLen;
                        }
                    }   
                }

                if (szMaxName && *szMaxName)
                    FixComboBox(szMaxName);
            }
        }

    }
}

void CBands::FixComboBox(LPTSTR     szName)
{
    HFONT       hFont;
    LOGFONT     lgFont;
    HDC         hdc;

    if (szName != NULL)
    {
        if (m_hComboBoxFont)
        {
            DeleteObject(m_hComboBoxFont);
            m_hComboBoxFont = NULL;
        }

        //Figure out which font to use
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lgFont, FALSE);
    
        //Create the font
        m_hComboBoxFont = CreateFontIndirect(&lgFont);

        SendMessage(m_hwndFilterCombo, WM_SETFONT, (WPARAM)m_hComboBoxFont, TRUE);

        //Get the metrics of this font
        hdc = GetDC(m_hwndRebar);
        SelectFont(hdc, m_hComboBoxFont);

        SIZE    s;
        GetTextExtentPoint32(hdc, szName, lstrlen(szName) + 2, &s);
        
        ReleaseDC(m_hwndRebar, hdc);

        int     cxDownButton;
        cxDownButton = GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXDLGFRAME);

        int         cyToolbarButton;
        RECT        rc;
        SendMessage(m_hwndRulesToolbar, TB_GETITEMRECT, 0, (LPARAM) &rc);
        cyToolbarButton = rc.bottom - rc.top + 1;

        // Figure out size of expanded dropdown lists
        int     cyExpandedList;
        cyExpandedList = 8 * cyToolbarButton;

        SetWindowPos(m_hwndFilterCombo, NULL, 0, 1, cxDownButton + s.cx, cyExpandedList, SWP_NOACTIVATE | SWP_NOZORDER);

        MemFree(szName);
    }
}

HRESULT  CBands::AddComboBox()
{

    if (!m_hwndFilterCombo)
    {
        m_hwndFilterCombo = CreateWindow("ComboBox", NULL,
                                  WS_CHILD | WS_VSCROLL | CBS_DROPDOWNLIST |
                                  WS_VISIBLE | CBS_HASSTRINGS | CBS_SORT,
                                  0, 0, 100, 100,
                                  m_hwndRulesToolbar,
                                  (HMENU) NULL, g_hInst, NULL);
    }

    return S_OK;
}

void CBands::UpdateFilters(RULEID   CurRuleID)
{
    RULEINFO    *pRuleInfo;
    DWORD       cRules = 0;
    DWORD       CurLen = 0;
    DWORD       MaxLen = 0;
    DWORD       dwFlags = 0;
    LPSTR       szMaxName = NULL;

    // Set the proper flags
    switch (m_ftType)
    {
        case FOLDER_LOCAL:
            dwFlags = GETF_POP3;
            break;
            
        case FOLDER_NEWS:
            dwFlags = GETF_NNTP;
            break;

        case FOLDER_HTTPMAIL:
            dwFlags = GETF_HTTPMAIL;
            break;

        case FOLDER_IMAP:
            dwFlags = GETF_IMAP;
            break;
    }
    
    if (g_pRulesMan && (g_pRulesMan->GetRules(dwFlags, RULE_TYPE_FILTER, &pRuleInfo, &cRules) == S_OK) && (cRules))
    {
        PROPVARIANT     pvarResult;
        DWORD           ItemIndex;
        int             Count;

        if (((Count = ComboBox_GetCount(m_hwndFilterCombo)) != CB_ERR) && (Count > 0))
        {
            //empty the Combo Box
            while (--Count >= 0)
            {
                ComboBox_DeleteString(m_hwndFilterCombo, Count);
            }
        }

        do
        { 
            cRules--;
            pRuleInfo[cRules].pIRule->GetProp(RULE_PROP_NAME, 0, &pvarResult);
            ItemIndex = ComboBox_AddString(m_hwndFilterCombo, pvarResult.pszVal);
            if ((ItemIndex != CB_ERR) && (ItemIndex != CB_ERRSPACE))
                ComboBox_SetItemData(m_hwndFilterCombo, ItemIndex, pRuleInfo[cRules].ridRule);
            
            if (pRuleInfo[cRules].ridRule == CurRuleID)
            {
                ComboBox_SetCurSel(m_hwndFilterCombo, ItemIndex);
            }

            //figure out the longest string so we can set the width of the combo box
            CurLen = strlen(pvarResult.pszVal);
            if (CurLen > MaxLen)
            {
                SafeMemFree(szMaxName);
                MaxLen      = CurLen;
                szMaxName   = pvarResult.pszVal;
            }
            else
            {
                MemFree(pvarResult.pszVal);
            }
            pRuleInfo[cRules].pIRule->Release();
        }while (cRules > 0);

        //Adjust the width of the combo box to fit the widest string
        FixComboBox(szMaxName);

        MemFree(pRuleInfo);
    }
}

BOOL LoadToolNames(const UINT *rgIds, const UINT cIds, TCHAR *szTools)
{
    for (UINT i = 0; i < cIds; i++)
    {
        LoadString(g_hLocRes, rgIds[i], szTools, MAX_TB_TEXT_LENGTH);
        szTools += lstrlen(szTools) + 1;
    }
    
    *szTools = TEXT('\0');
    return(TRUE);
}

UINT GetCurColorRes(void)
{
    HDC hdc;
    UINT uColorRes;
    
    hdc = GetDC(NULL);
    uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);
    
    return uColorRes;
}



BOOL CBands::_SetImages(HWND hwndToolbar, const int   *pImageIdList)
{
    TCHAR   szValue[32];
    DWORD   cbValue = sizeof(szValue);
    DWORD   dw;
    DWORD   dwType;
    DWORD   idImages;
    DWORD   cx = (fIsWhistler() ? TB_BMP_CX : TB_BMP_CX_W2K);

    if (m_dwIconSize == SMALL_ICONS)
    {
        idImages = pImageIdList[IMAGELIST_TYPE_SMALL];
        cx = TB_SMBMP_CX;
    }
    
    // If the user is running with greater than 256 colors, give them the spiffy
    // image list.
    else if (GetCurColorRes() >= 8)

        idImages = pImageIdList[IMAGELIST_TYPE_HI];
    // Otherwise, give 'em the default.
    else
        idImages = pImageIdList[IMAGELIST_TYPE_LO];


    CleanupImages(hwndToolbar);

    // Load the new lists

    HIMAGELIST  himl;

    himl = LoadMappedToolbarBitmap(g_hLocRes, idImages, cx);
    if (himl)
        SendMessage(hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM) himl);

    himl = LoadMappedToolbarBitmap(g_hLocRes, idImages+1, cx);
    if (himl)
        SendMessage(hwndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM) himl);

    // Tell the toolbar the size of each bitmap
    if (m_dwIconSize == SMALL_ICONS)
        SendMessage(hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG(TB_SMBMP_CX, TB_SMBMP_CY));
    else
        SendMessage(hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG((fIsWhistler() ? TB_BMP_CX : TB_BMP_CX_W2K), TB_BMP_CY));

    return (TRUE);
}


BOOL CBands::_InitToolbar(HWND hwndToolbar)
{
    // Tell the toolbar some basic information
    SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndTools, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_HIDECLIPPEDBUTTONS);

    if (_GetTextState() == TBSTATE_PARTIALTEXT)
    {
        DWORD dwStyle = GetWindowLong(m_hwndTools, GWL_STYLE);
        SetWindowLong(m_hwndTools, GWL_STYLE, dwStyle | TBSTYLE_LIST);
        SendMessage(m_hwndTools, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, TBSTYLE_EX_MIXEDBUTTONS);
    }

    // Tell the toolbar the number of rows of text and button width based
    // on whether or not we're showing text below the buttons or not.
    if (_GetTextState() == TBSTATE_NOTEXT)
    {
        SendMessage(hwndToolbar, TB_SETMAXTEXTROWS, 0, 0);
        SendMessage(hwndToolbar, TB_SETBUTTONWIDTH, 0, MAKELONG(0, MAX_TB_COMPRESSED_WIDTH));
    }
    else
    {
        SendMessage(hwndToolbar, TB_SETMAXTEXTROWS, MAX_TB_TEXT_ROWS_HORZ, 0);
        SendMessage(hwndToolbar, TB_SETBUTTONWIDTH, 0, MAKELONG(0, m_cxMaxButtonWidth));
    }

    // Now load the buttons into the toolbar
    _SetImages(hwndToolbar, (fIsWhistler() ? 
        ((GetCurColorRes() > 24) ? c_32ImageListStruct[m_dwParentType].ImageListTable : c_ImageListStruct[m_dwParentType].ImageListTable)
        : c_NWImageListStruct[m_dwParentType].ImageListTable ));

    _LoadStrings(hwndToolbar, (TOOLBAR_INFO *) m_pTBInfo);
    _LoadDefaultButtons(hwndToolbar, (TOOLBAR_INFO *) m_pTBInfo);

    return (TRUE);
} 


void CBands::_LoadStrings(HWND hwndToolbar, TOOLBAR_INFO *pti)
{
    BUTTON_INFO *pInfo;
    LPTSTR       psz = 0;
    LPTSTR       pszT;

    // Allocate an array big enough for all the strings
    if (MemAlloc((LPVOID *) &psz, MAX_TB_TEXT_LENGTH * pti->cAllButtons))
    {
        ZeroMemory(psz, MAX_TB_TEXT_LENGTH * pti->cAllButtons);
        pszT = psz;

        // Zoom through the array adding each string in turn
        pInfo = (BUTTON_INFO *) &(pti->rgAllButtons[0]);
        for (UINT i = 0; i < pti->cAllButtons; i++, pInfo++)
        {
            if ((_GetTextState() == TBSTATE_PARTIALTEXT) && (pInfo->idCmd == ID_SEND_RECEIVE))
            {
                AthLoadString(idsSendReceive, pszT, MAX_TB_TEXT_LENGTH);
            }
            else
                AthLoadString(pInfo->idsButton, pszT, MAX_TB_TEXT_LENGTH);

            pszT += lstrlen(pszT) + 1;
        }

        // Must double-NULL terminate
        *pszT = 0;

        SendMessage(hwndToolbar, TB_ADDSTRING, NULL, (LPARAM) psz);
        MemFree(psz);
    }
}

BOOL CBands::_LoadDefaultButtons(HWND hwndToolbar, TOOLBAR_INFO *pti)
{
    DWORD    *pID;
    TBBUTTON *rgBtn = 0;
    TBBUTTON *pBtn;
    DWORD     cBtns = 0;
    UINT      i;
    TCHAR     sz[32];
    DWORD     cDefButtons;
    DWORD    *rgDefButtons;

    // Figure out if we're using the intl toolbar defaults or the US
    // toolbar defaults
    AthLoadString(idsUseIntlToolbarDefaults, sz, ARRAYSIZE(sz));
    if (0 != lstrcmpi(sz, "0"))
    {
        cDefButtons = pti->cDefButtonsIntl;
        rgDefButtons = (DWORD *) pti->rgDefButtonsIntl;
    }
    else
    {
        cDefButtons = pti->cDefButtons;
        rgDefButtons = (DWORD *) pti->rgDefButtons;
    }

    // Allocate an array big enough for all the strings
    if (MemAlloc((LPVOID *) &rgBtn, sizeof(TBBUTTON) * cDefButtons))
    {
        ZeroMemory(rgBtn, sizeof(TBBUTTON) * cDefButtons);
        pBtn = rgBtn;

        // Zoom through the array adding each string in turn
        pBtn = rgBtn;
        for (i = 0, pID = (DWORD *) rgDefButtons;
             i < cDefButtons; 
             i++, pID++, pBtn++)
        {
            if (_ButtonInfoFromID(*pID, pBtn, pti))
                cBtns++;
        }

        SendMessage(hwndToolbar, TB_ADDBUTTONS, cBtns, (LPARAM) rgBtn);
        MemFree(rgBtn);
    }
 
    return (TRUE);
}


BOOL CBands::_ButtonInfoFromID(DWORD id, TBBUTTON *pButton, TOOLBAR_INFO *pti)
{
    BUTTON_INFO *pInfo;
    UINT         i;

    // Validate
    if (!pButton)
        return FALSE;

    // Special case any seperators
    if (id == -1)
    {
        pButton->iBitmap   = 0;
        pButton->idCommand = 0;
        pButton->fsState   = TBSTATE_ENABLED;
        pButton->fsStyle   = TBSTYLE_SEP;
        pButton->dwData    = 0;
        pButton->iString   = 0;

        return (TRUE);
    }

    // Zoom through the array looking for this id
    for (i = 0, pInfo = (BUTTON_INFO *) pti->rgAllButtons; i < pti->cAllButtons; i++, pInfo++)
    {
        // Check to see if we found a match
        if (id == pInfo->idCmd)
        {
            pButton->iBitmap   = pInfo->iImage;
            pButton->idCommand = pInfo->idCmd;
            pButton->fsState   = TBSTATE_ENABLED;
            pButton->fsStyle   = pInfo->fStyle;
            pButton->dwData    = 0;
            pButton->iString   = i;

            return (TRUE);
        }
    }   

    return (FALSE);
}

inline DWORD    CBands::_GetTextState()
{
    return m_dwToolbarTextState;
}

void CBands::SetTextState(DWORD dw)
{
    switch (dw)
    {
    case TBSTATE_PARTIALTEXT:
        m_dwPrevTextStyle = TBSTATE_PARTIALTEXT;
        break;

    case TBSTATE_FULLTEXT:
        m_dwPrevTextStyle = TBSTATE_FULLTEXT;
        break;

    }

    m_dwToolbarTextState = dw;

    if (m_pTextStyleNotify)
    {
        m_pTextStyleNotify->Lock(m_hwndSizer);
        m_pTextStyleNotify->DoNotification(WM_OE_TOOLBAR_STYLE, (WPARAM)dw, 0, SNF_POSTMSG);
        m_pTextStyleNotify->Unlock();
    }

    if ((dw == TBSTATE_PARTIALTEXT) || (dw == TBSTATE_FULLTEXT))
        AthUserSetValue(NULL, c_szRegPrevToolbarText, REG_DWORD, (LPBYTE)&m_dwPrevTextStyle, sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\thumb.h ===
#ifndef _THUMB_H
#define _THUMB_H


#define WC_THUMBNAIL    "Ath_ThumbNail"

#define THM_LOADPAGE    (WM_USER + 1)

LRESULT CALLBACK ThumbNailWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif //_THUMB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\thumb.cpp ===
/*
 *    t h u m b . c p 
 *    
 *    Purpose:
 *        ThumbNail control
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include "ourguid.h"
#include "mshtml.h"
#include "mshtmcid.h"
#include "oleutil.h"
#include "shlwapi.h"
#include "thumb.h"
#include "docobj.h"
#include "shlobjp.h"

ASSERTDATA


/*
 *  m a c r o s
 */

/*
 *  t y p e d e f s
 */

typedef struct THUMBDATA_tag
{
    HBITMAP     hBmp;
    HPALETTE    hPal;
} THUMBDATA, * PTHUMBDATA;

/*
 *  c o n s t a n t s
 */


/*
 *  g l o b a l s 
 */
    
/*
 *  f u n c t i o n   p r o t y p e s
 */

extern UINT GetCurColorRes(void);


/*
 *  f u n c t i o n s
 */

LRESULT CALLBACK ThumbNailWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPUNKNOWN   pUnk;
    HBITMAP     hBmp;
    PTHUMBDATA  pThumbData;
    HDC         hdc,
                hdcMem;
    PAINTSTRUCT ps;
    RECT        rc;
    HPALETTE    hPalPrev;

    switch(msg)
        {
        case WM_CREATE:
            if (!MemAlloc ((LPVOID *)&pThumbData, sizeof(THUMBDATA)))
                return -1;

            pThumbData->hBmp = NULL;
            pThumbData->hPal = NULL;

            hdc = GetDC(NULL);
            if (hdc)
                {
                if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
                    pThumbData->hPal = SHCreateShellPalette(hdc);

                ReleaseDC(NULL, hdc);
                }
            SetWndThisPtr(hwnd, pThumbData);
            return 0;
        
        case WM_NCDESTROY:
            pThumbData = (PTHUMBDATA)GetWndThisPtr(hwnd);
            if (pThumbData)
                {
                if (pThumbData->hBmp)
                    DeleteObject(pThumbData->hBmp);

                if (pThumbData->hPal)
                    DeleteObject(pThumbData->hPal);

                MemFree(pThumbData);
                }
            break;

        case WM_PAINT:
            pThumbData = (PTHUMBDATA)GetWndThisPtr(hwnd);
            if (!pThumbData)
                break;

            hdc=BeginPaint(hwnd, &ps);
            if (hdc)
                {
                if (pThumbData->hBmp)
                    {
                    GetClientRect(hwnd, &rc);

                    hdcMem = CreateCompatibleDC(hdc);
                    if (hdcMem)
                        {
                        HBITMAP hBmpOld;

                        hBmpOld = (HBITMAP)SelectObject(hdcMem, pThumbData->hBmp);

                        hPalPrev=NULL;
                        if (pThumbData->hPal)
                            {
                            hPalPrev = SelectPalette(hdc, pThumbData->hPal, TRUE);
                            RealizePalette(hdc);
                            }

                        BitBlt(hdc, 0, 0, rc.right-rc.left, rc.bottom-rc.top, hdcMem, 0, 0, SRCCOPY);
                        
                        if (hPalPrev)
                            {
                            SelectPalette(hdc, hPalPrev, TRUE);
                            RealizePalette(hdc);
                            }
                        SelectObject(hdcMem, hBmpOld);
                        DeleteDC(hdcMem);                   
                        }
                    }
                EndPaint(hwnd, &ps);
                }
            return 0;

        case THM_LOADPAGE:
            if (lParam)
                {
                WCHAR   _szPathW[MAX_PATH];
                LONG    lRet=-1;

                // if we're already showing a bitmap, release it and get a new one...
                pThumbData = (PTHUMBDATA)GetWndThisPtr(hwnd);
                if (!pThumbData)
                    return -1;

                if (pThumbData->hBmp)
                    {
                    DeleteObject(pThumbData->hBmp);
                    pThumbData->hBmp=NULL;
                    }

                if (!FAILED(CoCreateInstance(CLSID_HtmlThumbnailExtractor, 
                            NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                            IID_IUnknown, (LPVOID *)&pUnk)))
                    {
                    if (!FAILED(HrIPersistFileLoadW(pUnk, (LPWSTR)lParam)))
                        {
                        IExtractImage   *pExtract;

                        if (!FAILED(pUnk->QueryInterface(IID_IExtractImage, (LPVOID *)&pExtract)))
                            {
                            DWORD   dwPri,
                                    dwFlags;

                            dwPri = IEI_PRIORITY_MAX;
                            dwFlags = 0;
                            SIZE    size;
                            GetClientRect(hwnd, &rc);
                            size.cx = rc.right - rc.left;
                            size.cy = rc.bottom - rc.top;

                            if (!FAILED(pExtract->GetLocation(_szPathW, MAX_PATH, &dwPri, &size, GetCurColorRes(), &dwFlags)))
                                {
                                if (!FAILED(pExtract->Extract(&hBmp)))
                                    {
                                    // set the bitmap and invalidate to update the view
                                    pThumbData->hBmp = hBmp;
                                    InvalidateRect(hwnd, NULL, TRUE);
                                    lRet=0;
                                    }
                                }
                            pExtract->Release();
                            }
                        }
                    pUnk->Release();
                    }
                return lRet;
                }
            return -1;
        }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\tmap.h ===
#ifndef __TMAP_H
#define __TMAP_H

#include "srtarray.h"

//--------------------------------------------------------------------------
// TPair
//--------------------------------------------------------------------------

template<class TKey, class TValue>
class TPair
{
public:
    TPair(const TKey& key, const TValue& value) :
        m_key(key),
        m_value(value)
        { }

    TPair(const TKey& key) :
        m_key(key),
        m_value()
        { }

    const TKey  m_key;
    TValue      m_value;
};

//--------------------------------------------------------------------------
// class TMap
//--------------------------------------------------------------------------

template<class TKey, class TValue>
class TMap
{
    typedef int (__cdecl *PFNKEYYCOMPARE)(const TKey& first, const TKey& second);
    typedef void (__cdecl *PFNFREEPAIR)(TPair<TKey, TValue> *pair); 

public:
    TMap(PFNKEYYCOMPARE pfnCompare = NULL);
    ~TMap(void);

    long GetLength(void) const { return m_pArray ? m_pArray->GetLength() : 0; }

    // find the entry in the map whose key matches item->m_key
    TPair<TKey, TValue>* Find(TPair<TKey, TValue> *pPair) const;
        
    TPair<TKey, TValue>* Find(const TKey& key) const;
        // find the entry in the map whose key matches key

    HRESULT Add(const TPair<TKey, TValue> *pPair);
        // add newItem to the map

    HRESULT Add(const TKey& key, const TValue& value);
        // Create a pair and add it to the map

    BOOL Remove(TPair<TKey, TValue> *pPair);
        // Remove entry in the map whose key matches item->key

    BOOL Remove(const TKey& key);
        // Remove entry in the map whose key matches key

public:
    // install a custom pair free function. it is the
    // responsibility of this function to free any data
    // associated with the pair, and to then call
    // "delete" on the pair
    void SetPairFreeFunction(PFNFREEPAIR pfnFreePair) { m_pfnFreePair = pfnFreePair; }

    TPair<TKey, TValue>* GetItemAt(long lIndex) const;
        // Return the entry at ulIndex. This method should only be
        // used as a low-level accessor (e.g., for iterating across
        // all entries in the map). Note that adding a new entry
        // invalidates any previous index:entry associations

private:
    HRESULT _HrCreateArray(void)
    {
        Assert(NULL == m_pArray);
        return CSortedArray::Create(_Compare, _FreeItem, &m_pArray);
    }

    static int __cdecl _Compare(const void* pPair1, const void* pPair2)
    {
        const TKey& key1 = (*((TPair<TKey, TValue>**)pPair1))->m_key;
        const TKey& key2 = (*((TPair<TKey, TValue>**)pPair2))->m_key;

//        if (m_pfnCompare)
//            return (*m_pfnCompare)(key1, key2);
//        else
//        {
            if (key1 < key2)
                return -1;
            else if (key2 < key1)
                return 1;
            else
                return 0;
//        }
    }

    static void __cdecl _FreeItem(void* pPair)
    {
        delete (static_cast<TPair<TKey, TValue>*>(pPair));
    }

private:
    PFNFREEPAIR     m_pfnFreePair;
    PFNKEYYCOMPARE  m_pfnCompare;
    CSortedArray    *m_pArray;
};

template <class TKey, class TValue>
inline TMap<TKey, TValue>::TMap(PFNKEYYCOMPARE pfnCompare) :
    m_pfnFreePair(NULL),
    m_pfnCompare(pfnCompare),
    m_pArray(NULL)
{
    // nothing to do
}

template <class TKey, class TValue>
TMap<TKey, TValue>::~TMap(void)
{
    if (NULL != m_pfnFreePair)
    {
        long lLength = GetLength();
        TPair<TKey, TValue> *pPair;
        
        if (lLength > 0)
        {
            for (long i = lLength - 1; i >= 0; i--)
            {
                pPair = GetItemAt(i);
                m_pArray->Remove(i);
                if (pPair)
                    (*m_pfnFreePair)(pPair);
            }
        }
    }
    
    delete m_pArray;
}

template<class TKey, class TValue>
TPair<TKey, TValue>* TMap<TKey, TValue>::Find(TPair<TKey, TValue> *pPair) const
{
    long lIndex;
    if (NULL != m_pArray && m_pArray->Find(pPair, &lIndex))
        return static_cast<TPair<TKey, TValue>*>(m_pArray->GetItemAt(lIndex));
    else
        return NULL;
}

template<class TKey, class TValue>
inline TPair<TKey, TValue>* TMap<TKey, TValue>::Find(const TKey& key) const
{
    return Find(&TPair<TKey, TValue>(key));
}

template<class TKey, class TValue>
HRESULT TMap<TKey, TValue>::Add(const TPair<TKey, TValue> *pPair)
{
    if (NULL == m_pArray)
    {
        HRESULT hr;
        if (FAILED(hr = _HrCreateArray()))
            return hr;
    }
    
    return m_pArray->Add(const_cast<TPair<TKey, TValue>*>(pPair));

}

template<class TKey, class TValue>
inline HRESULT TMap<TKey, TValue>::Add(const TKey& key, const TValue& value)
{
    TPair<TKey, TValue> *pPair = new TPair<TKey, TValue>(key, value);
    if (NULL == pPair)
        return E_OUTOFMEMORY;

    return Add(pPair);
}

template<class TKey, class TValue>
BOOL TMap<TKey, TValue>::Remove(TPair<TKey, TValue> *pPair)
{
    long lIndex;
    BOOL fFound = m_pArray->Find(pPair, &lIndex);
    if (fFound)
    {
        TPair<TKey, TValue> *pFoundPair = static_cast<TPair<TKey, TValue>*>(m_pArray->GetItemAt(lIndex));
        m_pArray->Remove(lIndex);
        if (m_pfnFreePair)
            (*m_pfnFreePair)(pFoundPair);
        else
            delete pFoundPair;
    }

    return fFound;
}

template<class TKey, class TValue>
inline BOOL TMap<TKey, TValue>::Remove(const TKey& key)
{
    return Remove(&TPair<TKey, TValue>(key));
}

template<class TKey, class TValue>
inline TPair<TKey, TValue>* TMap<TKey, TValue>::GetItemAt(long lIndex) const
{
    return m_pArray ? static_cast<TPair<TKey, TValue>*>(m_pArray->GetItemAt(lIndex)) : NULL;
}

#endif // __TMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\treeview.cpp ===
#include "pch.hxx"
#include "treeview.h"
#include "resource.h"
#include "error.h"
#include "fonts.h"
#include "thormsgs.h"
#include "strconst.h"
#include "imagelst.h"
#include "goptions.h"
#include <notify.h>
#include "imnact.h"
#include "menuutil.h"
#include <imnxport.h>
#include <inpobj.h>
#include "fldbar.h"
#include "instance.h"
#include "imnglobl.h"
#include "ddfldbar.h"
#include "ourguid.h"
#include "storutil.h"
#include "shlwapip.h" 
#include "demand.h"
#include "newfldr.h"
#include <store.h>
#include "subscr.h"
#include "acctutil.h"
#include "menures.h"
#include "mailutil.h"
#include "dragdrop.h"
#include <storecb.h>
#include "outbar.h"
#include "navpane.h"
#include "finder.h"
#include "goptions.h"

ASSERTDATA

#define idtSelChangeTimer   5

#define C_RGBCOLORS 16
extern const DWORD rgrgbColors16[C_RGBCOLORS];

int CALLBACK TreeViewCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

////////////////////////////////////////////////////////////////////////
//
//  Module Data
//
////////////////////////////////////////////////////////////////////////

static const TCHAR s_szTreeViewWndClass[] = TEXT("ThorTreeViewWndClass");

DWORD CUnread(FOLDERINFO *pfi)
{
    DWORD dwUnread = pfi->cUnread;
    if (pfi->tyFolder == FOLDER_NEWS)
        dwUnread += pfi->dwNotDownloaded;
    return(dwUnread);
}

inline BOOL ITreeView_SelectItem(HWND hwnd, HTREEITEM hitem)
{
    TreeView_EnsureVisible(hwnd, hitem);
    return((BOOL)TreeView_SelectItem(hwnd, hitem));
}

////////////////////////////////////////////////////////////////////////
//
//  Constructors, Destructors, and other initialization stuff
//
////////////////////////////////////////////////////////////////////////

CTreeView::CTreeView(ITreeViewNotify *pNotify)
{
    m_cRef = 1;
    m_hwndParent = NULL;
    m_hwnd = NULL;
    m_hwndTree = NULL;
    m_pBrowser = NULL;
    m_hwndUIParent = NULL;

    Assert(pNotify);
    m_pNotify = pNotify;
    m_pObjSite = NULL;
    m_xWidth = DwGetOption(OPT_TREEWIDTH);
    m_fExpandUnread = DwGetOption(OPT_EXPAND_UNREAD);
    m_fShow = FALSE;
    m_idSelTimer = 0;
    
    m_htiMenu = NULL;
    m_fEditLabel = 0;
    m_hitemEdit = NULL;
    m_fIgnoreNotify = FALSE;
    
    m_pDataObject = NULL;
    m_pFolderBar = NULL;
    m_pDTCur = NULL;
    m_dwAcctConnIndex = 0;

    m_pPaneFrame = NULL;
    m_hwndPaneFrame = 0;

    m_clrWatched = 0;
}

CTreeView::~CTreeView()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    Assert(g_pStore);
    g_pStore->UnregisterNotify((IDatabaseNotify *)this);
    
    if (m_dwAcctConnIndex != 0 && g_pAcctMan != NULL)
        g_pAcctMan->Unadvise(m_dwAcctConnIndex);
    
    SafeRelease (m_pObjSite);
    SafeRelease(m_pPaneFrame);
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT CTreeView::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IInputObject))
    {
        *ppvObj = (void*)(IInputObject*)this;
    }
    else if (IsEqualIID(riid, IID_IDockingWindow))
    {
        *ppvObj = (void*)(IDockingWindow *) this;
    }
    else if (IsEqualIID(riid, IID_IOleWindow))
    {
        *ppvObj = (void*)(IOleWindow*)this;
    }
    
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (void*)(IObjectWithSite*)this;
    }
    else if (IsEqualIID(riid, IID_IDropDownFldrBar))
    {
        *ppvObj = (void*)(IDropDownFldrBar*)this;
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        *ppvObj = (LPVOID) (IDropTarget*) this;
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;
    }
    
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG CTreeView::AddRef()
{
    DOUTL(4, TEXT("CTreeView::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG CTreeView::Release()
{
    DOUTL(4, TEXT("CTreeView::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CTreeView::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = (m_hwndPaneFrame ? m_hwndPaneFrame : m_hwnd);
    return (*lphwnd ? S_OK : E_FAIL);
}

HRESULT CTreeView::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////
//
//  IDockingWindow
//
////////////////////////////////////////////////////////////////////////
HWND CTreeView::Create(HWND hwndParent, IInputObjectSite *pSiteFrame, BOOL fFrame)
{  
    m_hwndParent = hwndParent;
    
    if (m_pBrowser)
        m_pBrowser->GetWindow(&m_hwndUIParent);
    else
        m_hwndUIParent = m_hwndParent;
    
    // Decide if we need to create a new window or show a currently existing
    // window    
    if (!m_hwnd)
    {
        WNDCLASSEX  wc;
        
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szTreeViewWndClass, &wc))
        {
            // We need to register the class
            wc.style            = 0;
            wc.lpfnWndProc      = CTreeView::TreeViewWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            wc.hCursor          = LoadCursor(NULL, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szTreeViewWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;
            
            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
                return 0;
        }
        
        // Get the handle of the parent window
        if (!m_hwndParent)
            return 0;

        if (fFrame)
        {
            m_pPaneFrame = new CPaneFrame();
            if (!m_pPaneFrame)
                return (0);

            m_hwndPaneFrame = m_pPaneFrame->Initialize(m_hwndParent, pSiteFrame, idsMNBandTitle);
            hwndParent = m_hwndPaneFrame;
        }
       
        m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, s_szTreeViewWndClass, NULL,
                                WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_CHILD,
                                0, 0, 0, 0, hwndParent, NULL, g_hInst, (LPVOID) this);
        if (!m_hwnd)
        {
            AssertSz(0, _T("CTreeView::Create() - Failed to create window."));
            return 0;
        }           

        if (fFrame)
        {
            m_pPaneFrame->SetChild(m_hwnd, DISPID_MSGVIEW_FOLDERLIST, m_pBrowser, this);
            ShowWindow(m_hwndPaneFrame, SW_SHOW);
        }
        ShowWindow(m_hwnd, SW_SHOW);
    }
    
    return (fFrame ? m_hwndPaneFrame : m_hwnd);
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////

HRESULT CTreeView::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{    
    if (fActivate)
        {
        UnkOnFocusChangeIS(m_pObjSite, (IInputObject*)this, TRUE);
        SetFocus(m_hwndTree);
        }
    return S_OK;    
}

HRESULT CTreeView::HasFocusIO(void)
{
    HWND hwndFocus = GetFocus();
    return (m_fEditLabel || (hwndFocus && (hwndFocus == m_hwndTree || IsChild(m_hwndTree, hwndFocus)))) ? S_OK : S_FALSE;
}    

HRESULT CTreeView::TranslateAcceleratorIO(LPMSG pMsg)
{
    if (m_fEditLabel)
    {
        TranslateMessage(pMsg);
        DispatchMessage(pMsg);
        return (S_OK);
    }
    return (S_FALSE);
}    

////////////////////////////////////////////////////////////////////////
//
//  IObjectWithSite
//
////////////////////////////////////////////////////////////////////////

HRESULT CTreeView::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_pObjSite)
    {
        m_pObjSite->Release();
        m_pObjSite = NULL;
    }
    
    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)    
    {
        if (FAILED(punkSite->QueryInterface(IID_IInputObjectSite, (void **)&m_pObjSite)))
            return E_FAIL;
    }
    
    return S_OK;    
}

HRESULT CTreeView::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  Public Methods
//
////////////////////////////////////////////////////////////////////////

HRESULT CTreeView::HrInit(DWORD dwFlags, IAthenaBrowser *pBrowser)
{
    DWORD   dwConnection = 0;
    
    // Locals
    HRESULT hr=S_OK;
    
    // Validate
    Assert(0 == (~TREEVIEW_FLAGS & dwFlags));
    
    // Save Flags
    m_dwFlags = dwFlags;
    
#ifdef DEBUG
    // we have to have a browser if we have context menus
    if (0 == (TREEVIEW_DIALOG & dwFlags))
        Assert(pBrowser != NULL);
#endif // DEBUG
    
    // Save the Browser, but don't addref (must be a circular refcount problem)
    m_pBrowser = pBrowser;
    
    // Register for notifications on the global folder manager
    Assert(g_pStore);
    hr = g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this);
    if (FAILED(hr))
        return hr;
    
    if (0 == (TREEVIEW_DIALOG & dwFlags))
    {
        //Register for notifications from account manager
        hr = g_pAcctMan->Advise((IImnAdviseAccount*)this, &m_dwAcctConnIndex);
    }
    
    // Done
    return S_OK;
}

HRESULT CTreeView::DeInit()
{
    HTREEITEM hitem;
    
    Assert(0 == (m_dwFlags & TREEVIEW_DIALOG));
    
    hitem = TreeView_GetRoot(m_hwndTree);
    if (hitem != NULL)
        SaveExpandState(hitem);
    
    return(S_OK);
}

void CTreeView::HandleMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
        
        SendMessage(m_hwndTree, msg, wParam, lParam);
        break;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Window procedure and Message handling routines
//
/////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK EXPORT_16 CTreeView::TreeViewWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CTreeView *pmv;
    
    if (msg == WM_NCCREATE)
    {
        pmv = (CTreeView *)LPCREATESTRUCT(lp)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pmv);
    }
    else
    {
        pmv = (CTreeView *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }
    
    Assert(pmv);
    return pmv->WndProc(hwnd, msg, wp, lp);
}

////////////////////////////////////////////////////////////////////////
//
//  Private Methods
//
////////////////////////////////////////////////////////////////////////

LRESULT CTreeView::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    MSG xmsg;
    
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU,    OnContextMenu);
        HANDLE_MSG(hwnd, WM_NOTIFY,         OnNotify);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        
        case WM_DESTROY:
            //Before the image list is destroyed we should unresgister with the connection manager to avoid 
            //ending up with a null image list when we get a disconnected notification
            if (g_pConMan)
            {
                g_pConMan->Unadvise(this);
            }
            if (m_dwAcctConnIndex != 0 && g_pAcctMan != NULL)
            {
                g_pAcctMan->Unadvise(m_dwAcctConnIndex);
                m_dwAcctConnIndex = 0;
            }
            OptionUnadvise(hwnd);
            ImageList_Destroy( TreeView_GetImageList( m_hwndTree, TVSIL_NORMAL ) );
            break;

        case CM_OPTIONADVISE:
            m_fExpandUnread = DwGetOption(OPT_EXPAND_UNREAD);
            m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
            break;
        
        case WM_NCDESTROY:
            RevokeDragDrop(hwnd);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            m_hwnd = m_hwndTree = NULL;
            break;
        
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            SendMessage(m_hwndTree, msg, wParam, lParam);
        
            AdjustItemHeight();
            return (0);
        
        case WM_SETFOCUS:
            if (m_hwndTree && ((HWND)wParam) != m_hwndTree)
                SetFocus(m_hwndTree);
            return 0;
        
        case WM_TIMER:
            Assert(wParam == idtSelChangeTimer);
            KillTimer(hwnd, idtSelChangeTimer);
            m_idSelTimer = 0;
            if (m_pNotify)
            {
                FOLDERID idFolder = GetSelection();
                m_pNotify->OnSelChange(idFolder);
            }
            break;
        
        case WMR_CLICKOUTSIDE:
        {
            BOOL fHide = FALSE;
        
            if (wParam == CLK_OUT_KEYBD || wParam == CLK_OUT_DEACTIVATE)
                fHide = TRUE;
            else if (wParam == CLK_OUT_MOUSE)
            {
                HWND hwndParent = GetParent(m_hwnd);
                fHide = ((HWND) lParam != hwndParent) && !IsChild(hwndParent, (HWND) lParam);
            }
        
            if (fHide)
                m_pFolderBar->KillScopeDropDown();
            return (fHide);
        }
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HRESULT CTreeView::ForceSelectionChange()
{
    if (m_idSelTimer != 0)
    {
        KillTimer(m_hwnd, idtSelChangeTimer);
        m_idSelTimer = 0;
        if (m_pNotify)
        {
            FOLDERID idFolder = GetSelection();
            m_pNotify->OnSelChange(idFolder);
        }
        
        return(S_OK);
    }
    
    return(S_FALSE);
}

void CTreeView::AdjustItemHeight()
{
    int cyItem, cyText, cyBorder;
    HDC hdc;
    TCHAR c = TEXT('J');
    SIZE size;
    
    if (0 == (m_dwFlags & TREEVIEW_DIALOG))
    {
        hdc = GetDC(m_hwndTree);
        
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        
        GetTextExtentPoint(hdc, &c, 1, &size);
        cyText = size.cy;
        
        if (cyText < 16)
            cyText = 16; // icon size
        cyText =  cyText + (cyBorder * 2);
        
        ReleaseDC(m_hwndTree, hdc);
        
        cyItem = TreeView_GetItemHeight(m_hwndTree);
        
        if (cyText > cyItem)
            TreeView_SetItemHeight(m_hwndTree, cyText);
    }
}

BOOL CTreeView::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    HIMAGELIST      himl;
    TCHAR           szName[CCHMAX_STRINGRES];

    ZeroMemory(szName, ARRAYSIZE(szName));
    LoadString(g_hLocRes, idsFolderListTT, szName, ARRAYSIZE(szName));
    
    m_hwndTree = CreateWindowEx((0 == (m_dwFlags & TREEVIEW_DIALOG)) ? 0 : WS_EX_CLIENTEDGE,
                                WC_TREEVIEW, szName,
                                WS_CHILD | WS_VISIBLE | WS_TABSTOP | TVS_SHOWSELALWAYS |
                                TVS_HASBUTTONS | TVS_HASLINES | 
                                (0 == (m_dwFlags & TREEVIEW_DIALOG) ? TVS_EDITLABELS : TVS_DISABLEDRAGDROP),
                                0, 0, 0, 0, hwnd, NULL, g_hInst, NULL);
    if (!m_hwndTree)
        return FALSE;
    
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));           // small icons
    TreeView_SetImageList(m_hwndTree, himl, TVSIL_NORMAL);
    
    AdjustItemHeight();

    m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
    
    // Register ourselves as a drop target
    if (0 == (m_dwFlags & TREEVIEW_DIALOG))
    {
        RegisterDragDrop(hwnd, this);
        
        // Register ourselves with th connection manager so we can overlay 
        // the disconnected image when it notifies us of a disconnection
        if (g_pConMan)
            g_pConMan->Advise((IConnectionNotify *) this);

        OptionAdvise(hwnd);
    }
    
    return TRUE;
}

//
//  FUNCTION:   CTreeView::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the msgview window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CTreeView::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    LPFOLDERNODE pNode;
    NM_TREEVIEW *pnmtv;
    
    // This is necessary to prevent handling of notification after the 
    // listview window has been destroyed.
    if (!m_hwndTree)
        return 0;
    
    switch (pnmhdr->code)
    {
        case TVN_BEGINLABELEDIT:
            return OnBeginLabelEdit((TV_DISPINFO *) pnmhdr);
        
        case TVN_ENDLABELEDIT:
            return (OnEndLabelEdit((TV_DISPINFO *) pnmhdr));
        
        case TVN_BEGINDRAG:
            Assert(0 == (m_dwFlags & TREEVIEW_DIALOG));
            return OnBeginDrag((NM_TREEVIEW*) pnmhdr);
        
        case TVN_DELETEITEM:
            pnmtv = (NM_TREEVIEW *)pnmhdr;
            pNode = (LPFOLDERNODE)pnmtv->itemOld.lParam;
            if (pNode)
            {
                g_pStore->FreeRecord(&pNode->Folder);
                g_pMalloc->Free(pNode);
            }
            break;
        
        case TVN_SELCHANGED:
            pnmtv = (NM_TREEVIEW *)pnmhdr;
            if (0 == (m_dwFlags & TREEVIEW_DIALOG))
            {
                if (m_idSelTimer)
                    KillTimer(m_hwnd, idtSelChangeTimer);
                m_idSelTimer = SetTimer(m_hwnd, 
                    idtSelChangeTimer, 
                    (pnmtv->action == TVC_BYKEYBOARD) ? GetDoubleClickTime()*3/2 : 1,
                    NULL);
                if (m_pFolderBar)
                    m_pFolderBar->KillScopeDropDown();
            }
            else
            {
                if (m_pNotify)
                {
                    FOLDERID idFolder = GetSelection();
                    m_pNotify->OnSelChange(idFolder);
                }
            }
            break;
        
        case TVN_ITEMEXPANDING:
            // TODO: remove this as soon as the folder enumerator
            // returns us the folders in the proper sorted order
            pnmtv = (NM_TREEVIEW *)pnmhdr;
            if (pnmtv->action == TVE_EXPAND)
                SortChildren(pnmtv->itemNew.hItem);
            break;
        
        case NM_CUSTOMDRAW:
            return(OnCustomDraw((NMCUSTOMDRAW *)pnmhdr));
        
        case NM_SETFOCUS:
            if (IsWindowVisible(m_hwnd))
                UnkOnFocusChangeIS(m_pObjSite, (IInputObject*)this, TRUE);
            break;
        
        case NM_KILLFOCUS:
            if (m_pFolderBar)
                m_pFolderBar->KillScopeDropDown();
            break;
        
        case NM_DBLCLK:
            if (m_pNotify)
            {
                FOLDERID idFolder = GetSelection();
                m_pNotify->OnDoubleClick(idFolder);
            }
            break;
    }
    
    return 0;
}

LRESULT CTreeView::OnCustomDraw(NMCUSTOMDRAW *pnmcd)
{
    TCHAR       szNum[CCHMAX_STRINGRES];
    TCHAR       szText[CCHMAX_STRINGRES];
    RECT        rc;
    COLORREF    cr;
    int         cb, cb1;
    COLORREF    crOldBkColr = 0;
    COLORREF    crOldTxtColr = 0;
    COLORREF    crBkColor = 0;
    COLORREF    crTxtColor = 0;
    TV_ITEM     tv;
    LPFOLDERNODE pNode;
    FOLDERINFO  Folder;
    NMTVCUSTOMDRAW *ptvcd = (NMTVCUSTOMDRAW *) pnmcd;
    
    switch (pnmcd->dwDrawStage)
    {
        case CDDS_PREPAINT:
            // if we're in dialog-mode, we don't unread count displayed
            return((0 == (m_dwFlags & TREEVIEW_DIALOG)) ? (CDRF_NOTIFYPOSTPAINT | CDRF_NOTIFYITEMDRAW) : CDRF_DODEFAULT);
        
        case CDDS_ITEMPREPAINT:
            //If this item is disconnected then we gray out the text
            pNode = (LPFOLDERNODE)pnmcd->lItemlParam;
            if (pNode && 0 == (pnmcd->uItemState & CDIS_SELECTED))
            {
                if ((pNode->Folder.cWatchedUnread) && (m_clrWatched > 0 && m_clrWatched <= 16))
                {
                    ptvcd->clrText = rgrgbColors16[m_clrWatched - 1];
                }
                else if (!!(FIDF_DISCONNECTED & pNode->dwFlags))
                {
                    crTxtColor = GetSysColor(COLOR_GRAYTEXT);
                    crBkColor  = GetSysColor(COLOR_BACKGROUND);
                    if ((crTxtColor) || (crBkColor != crTxtColor))
                    {
                        ptvcd->clrText = crTxtColor;
                    }
                    else if ((crBkColor == crTxtColor) && (crTxtColor = GetSysColor(COLOR_INACTIVECAPTIONTEXT)))
                    {
                        ptvcd->clrText = crTxtColor;
                    }
                }
            }
        
            // if we're editing the label for this item, we don't want to paint the unread count
            return((m_fEditLabel && m_hitemEdit == (HTREEITEM)pnmcd->dwItemSpec) ? CDRF_DODEFAULT : CDRF_NOTIFYPOSTPAINT);
        
        case CDDS_ITEMPOSTPAINT:
            // now we need to paint the unread count, if any...
            pNode = (LPFOLDERNODE)pnmcd->lItemlParam;
            if (CUnread(&pNode->Folder) > 0)
            {
                HFONT hf = (HFONT) ::SendMessage(m_hwndTree, WM_GETFONT, 0, 0);
                HFONT hf2 = SelectFont(pnmcd->hdc, hf);
                cr = SetTextColor(pnmcd->hdc, RGB(0, 0, 0xff));
                if (cr != CLR_INVALID)
                {
                    if (TreeView_GetItemRect(m_hwndTree, (HTREEITEM)pnmcd->dwItemSpec, &rc, TRUE))
                    {
                        TCHAR c = TEXT('J');
                        SIZE  size;
                    
                        //$REVIEW - this size could be cached, but it doesn't seem to be a problem
                        GetTextExtentPoint(pnmcd->hdc, &c, 1, &size);
                        cb = wsprintf(szNum, "(%d)", CUnread(&pNode->Folder));
                        TextOut(pnmcd->hdc, rc.right + 2, rc.top + (rc.bottom - rc.top - size.cy) / 2, szNum, cb);
                    }
                
                    SetTextColor(pnmcd->hdc, cr);
                }
                SelectFont(pnmcd->hdc, hf2);
            }
            break;
    }
    return (CDRF_DODEFAULT);
}

//
//  FUNCTION:   CTreeView::OnContextMenu
//
//  PURPOSE:    If the WM_CONTEXTMENU message is generated from the keyboard
//              then figure out a pos to invoke the menu.  Then dispatch the
//              request to the handler.
//
//  PARAMETERS:
//      hwnd      - Handle of the view window.
//      hwndClick - Handle of the window the user clicked in.
//      x, y      - Position of the mouse click in screen coordinates.
//
void CTreeView::OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y)
{
    IContextMenu *pContextMenu;
    LPFOLDERNODE  pNode;
    HRESULT       hr;
    CMINVOKECOMMANDINFO ici;
    HMENU          hmenu;
    int            id = 0;
    RECT           rc;
    POINT          pt = {(int)(short) x, (int)(short) y};
    TV_HITTESTINFO tvhti;
    HTREEITEM      hti = 0;
    int            idMenu = 0;
    HWND           hwndBrowser = 0;
    
    if (!!(m_dwFlags & TREEVIEW_DIALOG))
        return;
    
    // Get the browser window from the IAthenaBrowser interface.  If we don't
    // use the browser window to pass to IContextMenu, then when the treeview
    // is in autohide mode, the mouse capture goes beserk.
    if (FAILED(m_pBrowser->GetWindow(&hwndBrowser)))
        return;
    
    if (MAKELPARAM(x, y) == -1) // invoked from keyboard: figure out pos.
    {
        Assert(hwndClick == m_hwndTree);
        hti = TreeView_GetSelection(m_hwndTree);
        
        TreeView_GetItemRect(m_hwndTree, hti, &rc, FALSE);
        ClientToScreen(m_hwndTree, (POINT *)&rc);                
        x = rc.left;
        y = rc.top;
    }
    else
    {
        ScreenToClient(m_hwndTree, &pt);
        
        tvhti.pt = pt;
        hti = TreeView_HitTest(m_hwndTree, &tvhti);
    }
    
    if (hti == NULL)
        return;
    
    TreeView_SelectDropTarget(m_hwndTree, hti);
    
    // Get the ID of the selected item
    pNode = GetFolderNode(hti);
    if (pNode)
    {
        // Load the appropriate context menu
        if (SUCCEEDED(MenuUtil_GetContextMenu(pNode->Folder.idFolder, this, &hmenu)))
        {
            // Display the context menu
            id = (int) TrackPopupMenuEx(hmenu, 
                TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
                x, y, m_hwnd, NULL);
            
            // If an ID was returned, process it
            if (id != 0)
                Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
            
            DestroyMenu(hmenu);
        }
    }
    
    TreeView_SelectDropTarget(m_hwndTree, NULL);
}


//
//  FUNCTION:   CTreeView::OnSize
//
//  PURPOSE:    Notification that the window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area. 
//      cyClient - New height of the client area.
//
void CTreeView::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    SetWindowPos(m_hwndTree, NULL, 0, 0,
        cxClient, cyClient, 
        SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
}

enum 
{
    UNINIT = 0,
    LOCAL,
    CONNECTED,
    DISCONNECTED
};

HRESULT CTreeView::GetConnectedState(FOLDERINFO *pFolder, int *pconn)
{
    HRESULT hr;
    char szAcctId[CCHMAX_ACCOUNT_NAME];
    
    Assert(pFolder != NULL);
    Assert(pconn != NULL);
    
    *pconn = UNINIT;
    
    if (!!(m_dwFlags & TREEVIEW_DIALOG))
    {
        // we don't care about connect state in dialogs
        // only in the folder list
        *pconn = LOCAL;
    }
    else
    {
        Assert(pFolder->idFolder != FOLDERID_ROOT);
        
        if (pFolder->tyFolder == FOLDER_LOCAL)
        {
            *pconn = LOCAL;
        }
        /*
        else if (!!(pFolder->dwFlags & FOLDER_SERVER))
        {
            *pconn = (g_pConMan->CanConnect(pFolder->pszAccountId) == S_OK) ? CONNECTED : DISCONNECTED;
        }
        else
        {
            hr = GetFolderAccountId(pFolder, szAcctId);
            if (SUCCEEDED(hr))
                *pconn = (g_pConMan->CanConnect(szAcctId) == S_OK) ? CONNECTED : DISCONNECTED;
        }
        */
        else
        {
            *pconn = g_pConMan->IsGlobalOffline() ? DISCONNECTED : CONNECTED;
        }
    }
    
    return(S_OK);
}

HRESULT CTreeView::HrFillTreeView()
{
    HRESULT hr;
    TV_INSERTSTRUCT tvis;
    HTREEITEM hitem;
    TCHAR sz[CCHMAX_STRINGRES];
    BOOL fUnread;
    LPFOLDERNODE pNode;
    
    if (MODE_OUTLOOKNEWS == (g_dwAthenaMode & MODE_OUTLOOKNEWS))
        LoadString(g_hLocRes, idsOutlookNewsReader, sz, ARRAYSIZE(sz));
    else
        LoadString(g_hLocRes, idsAthena, sz, ARRAYSIZE(sz));
    
    tvis.hParent = TVI_ROOT;
    tvis.hInsertAfter = TVI_LAST;
    tvis.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_TEXT;
    tvis.item.pszText  = sz;
    
    if (g_dwAthenaMode & MODE_NEWSONLY)
        tvis.item.iImage = iNewsRoot;
    else
        tvis.item.iImage = iMailNews;
    
    tvis.item.iSelectedImage = tvis.item.iImage;
    
    pNode = (LPFOLDERNODE)ZeroAllocate(sizeof(FOLDERNODE));
    if (NULL == pNode)
        return E_OUTOFMEMORY;
    
    tvis.item.lParam = (LPARAM)pNode;
    hitem = TreeView_InsertItem(m_hwndTree, &tvis);
    
    g_pStore->GetFolderInfo(FOLDERID_ROOT, &pNode->Folder);
    
    hr = FillTreeView2(hitem, &pNode->Folder, 0 == (m_dwFlags & TREEVIEW_DIALOG), UNINIT, &fUnread);
    
    TreeView_Expand(m_hwndTree, hitem, TVE_EXPAND);
    
    return (hr);
}    

HRESULT CTreeView::FillTreeView2(HTREEITEM hParent, LPFOLDERINFO pParent,
                                 BOOL fInitExpand, int conn, BOOL *pfUnread)
{
    // Locals
    HRESULT             hr=S_OK;
    int                 connT;
    TV_INSERTSTRUCT     tvis;
    HTREEITEM           hitem;
    BOOL                fNoLocal;
    BOOL                fNoNews;
    BOOL                fNoImap;
    BOOL                fNoHttp;
    BOOL                fExpand = FALSE;
    BOOL                fUnread = FALSE;
    FOLDERINFO          Folder;
    LPFOLDERNODE        pNode;
    IEnumerateFolders  *pEnum=NULL;

    // Trace
    TraceCall("CTreeView::FillTreeView2");
    
    // Initialize
    *pfUnread = FALSE;
    
    // Enumerate Children
    IF_FAILEXIT(hr = g_pStore->EnumChildren(pParent->idFolder, TRUE, &pEnum));

    // Determine what to show
    fNoNews =  ISFLAGSET(m_dwFlags, TREEVIEW_NONEWS);
    fNoImap =  ISFLAGSET(m_dwFlags, TREEVIEW_NOIMAP);
    fNoHttp =  ISFLAGSET(m_dwFlags, TREEVIEW_NOHTTP);
    fNoLocal = ISFLAGSET(m_dwFlags, TREEVIEW_NOLOCAL);
    
    // Enumerate the Sub Folders
    while (S_OK == pEnum->Next(1, &Folder, NULL))
    {
        // Is this node hidden ?
        if ((fNoNews && Folder.tyFolder == FOLDER_NEWS) ||
            (fNoImap && Folder.tyFolder == FOLDER_IMAP) ||
            (fNoHttp && Folder.tyFolder == FOLDER_HTTPMAIL) ||
            (fNoLocal && Folder.tyFolder == FOLDER_LOCAL) ||
            ((g_dwAthenaMode & MODE_OUTLOOKNEWS) && (Folder.tySpecial == FOLDER_INBOX)))
        {
            // Goto next
            g_pStore->FreeRecord(&Folder);
            continue;
        }

        // Some Connection management Thing?
        if (conn == UNINIT)
            GetConnectedState(&Folder, &connT);
        else
            connT = conn;
        
        // Set the insert item struct
        tvis.hParent = hParent;
        tvis.hInsertAfter = TVI_LAST;
        
        // 
        if (ISFLAGCLEAR(Folder.dwFlags, FOLDER_HIDDEN) &&
           (ISFLAGSET(Folder.dwFlags, FOLDER_HASCHILDREN) || ISFLAGSET(Folder.dwFlags, FOLDER_SERVER) ||
            ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED)))
        {
            // Allocate a pNode
            IF_NULLEXIT(pNode = (LPFOLDERNODE)ZeroAllocate(sizeof(FOLDERNODE)));

            // Set the Folder Info
            CopyMemory(&pNode->Folder, &Folder, sizeof(FOLDERINFO));

            // Set the Flags
            pNode->dwFlags = (connT == DISCONNECTED ? FIDF_DISCONNECTED : 0);

            // Don't free Folder
            Folder.pAllocated = NULL;

            // Insert this item
            hitem = ITreeView_InsertItem(&tvis, pNode);
           
            // Has unread
            fUnread = (fUnread || (CUnread(&Folder) > 0));
            
            // Insert this node's children ?
            if (ISFLAGSET(pNode->Folder.dwFlags, FOLDER_HASCHILDREN))
            {
                // Fill with children
                FillTreeView2(hitem, &pNode->Folder, fExpand, connT, pfUnread);
            }
            
            // Need to expand ?
            fExpand = (fInitExpand && ISFLAGSET(pNode->Folder.dwFlags, FOLDER_HASCHILDREN) && !!(pNode->Folder.dwFlags & FOLDER_EXPANDTREE));
        }

        // Otherwise, the node was not inserted
        else
            hitem = NULL;
        
        // Expand this node ?
        if (hitem && *pfUnread && m_fExpandUnread)
        {
            // Expand this node
            TreeView_Expand(m_hwndTree, hitem, TVE_EXPAND);

            // There are unread
            fUnread = TRUE;
        }
        
        // Expand this node ?
        else if (hitem && fExpand)
        {
            // Expand this node
            TreeView_Expand(m_hwndTree, hitem, TVE_EXPAND);
        }

        // Free Current
        g_pStore->FreeRecord(&Folder);
    }
    
    // Was there unread folders ?
    *pfUnread = fUnread;
    
exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}    

HTREEITEM CTreeView::ITreeView_InsertItem(TV_INSERTSTRUCT *ptvis, LPFOLDERNODE pNode)
{
    Assert(ptvis != NULL);
    Assert(pNode != NULL);
    
    ptvis->item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_TEXT;
    ptvis->item.iImage = GetFolderIcon(&pNode->Folder, !!(m_dwFlags & TREEVIEW_DIALOG));
    
    ptvis->item.iSelectedImage = ptvis->item.iImage;
    ptvis->item.lParam = (LPARAM)pNode;
    
    if (0 == (m_dwFlags & TREEVIEW_DIALOG) && CUnread(&pNode->Folder) > 0)
    {
        ptvis->item.mask |= TVIF_STATE;
        ptvis->item.state = TVIS_BOLD;
        ptvis->item.stateMask = TVIS_BOLD;
    }
    ptvis->item.pszText = pNode->Folder.pszName;

    return(TreeView_InsertItem(m_hwndTree, ptvis));
}

BOOL CTreeView::ITreeView_SetItem(TV_ITEM *ptvi, LPFOLDERINFO pFolder)
{
    BOOL f;

    Assert(ptvi != NULL);
    
    ptvi->mask |= (TVIF_STATE | TVIF_TEXT);
    ptvi->stateMask = TVIS_BOLD;

    if (0 == (m_dwFlags & TREEVIEW_DIALOG) && CUnread(pFolder) > 0)
        ptvi->state = TVIS_BOLD;
    else
        ptvi->state = 0;

    ptvi->pszText = pFolder->pszName;
    f = TreeView_SetItem(m_hwndTree, ptvi);
    
    return f;
}

HRESULT CTreeView::Refresh(void)
{
    TV_ITEM item;
    FOLDERID idFolder;
    
    if (IsWindow(m_hwndTree))
    {
        idFolder = GetSelection();
        
        TreeView_DeleteAllItems(m_hwndTree);
        m_fIgnoreNotify = TRUE;
        HrFillTreeView();
        if (FOLDERID_INVALID != idFolder)
        {
            SetSelection(idFolder, 0);
        }
        m_fIgnoreNotify = FALSE;
    }
    
    return (S_OK);
}

FOLDERID CTreeView::GetSelection()
{
    HTREEITEM hitem;
    FOLDERID idFolder=FOLDERID_INVALID;
    
    if (IsWindow(m_hwndTree))
    {
        hitem = TreeView_GetSelection(m_hwndTree);
        if (hitem != NULL)
        {
            TV_ITEM tvi;
            
            tvi.mask   = TVIF_PARAM;
            tvi.lParam = 0;
            tvi.hItem  = hitem;
            
            if (TreeView_GetItem(m_hwndTree, &tvi))
            {
                LPFOLDERNODE pNode=(LPFOLDERNODE)tvi.lParam;
                
                if (pNode)
                    idFolder = pNode->Folder.idFolder;
            }
        }
    }
    
    return (idFolder);
}

HRESULT CTreeView::SetSelection(FOLDERID idFolder, DWORD dwFlags)
{
    HRESULT hr;
    HTREEITEM hitem;
    
    hr = E_FAIL;
    
    if (IsWindow(m_hwndTree))
    {
        hitem = GetItemFromId(idFolder);
        
        if (hitem == NULL && !!(dwFlags & TVSS_INSERTIFNOTFOUND))
        {
            hitem = InsertNode(idFolder, 0);
            if (NULL != hitem)
                hr = S_OK;
        }
        
        if (hitem != NULL && ITreeView_SelectItem(m_hwndTree, hitem))
            hr = S_OK;
    }
    
    return(hr);
}

HRESULT CTreeView::SelectParent()
{
    HRESULT     hr = E_FAIL;
    HTREEITEM   hitem;
    
    if (hitem = TreeView_GetSelection(m_hwndTree))
    {
        if (hitem = TreeView_GetParent(m_hwndTree, hitem))
        {
            if (ITreeView_SelectItem(m_hwndTree, hitem))
                hr = S_OK;
        }
    }
    return(hr);
}

struct TREEUNREAD
{
    HWND        hwndTree;
    HTREEITEM   hitemSel;
    BOOL        fFoundSel;
    FOLDERTYPE  tyFolder;
};

HTREEITEM FindNextUnreadItem(HTREEITEM hitemCur, TREEUNREAD *ptu)
{
    HTREEITEM hitem;
    
    if (hitemCur == ptu->hitemSel)
        ptu->fFoundSel = TRUE;
    
    else if (ptu->fFoundSel)
    {
        TV_ITEM   tvi;
        
        tvi.mask   = TVIF_PARAM;
        tvi.lParam = 0;
        tvi.hItem  = hitemCur;
        
        if (TreeView_GetItem(ptu->hwndTree, &tvi))
        {
            LPFOLDERNODE pNode = (LPFOLDERNODE)tvi.lParam;
            
            if (pNode)
            {
                if (CUnread(&pNode->Folder))
                    return hitemCur;
            }
        }   
    }
    
    if (hitem = TreeView_GetChild(ptu->hwndTree, hitemCur))
    {
        if (hitem = FindNextUnreadItem(hitem, ptu))
            return hitem;
    }
    if (hitemCur = TreeView_GetNextSibling(ptu->hwndTree, hitemCur))
    {
        if (hitem = FindNextUnreadItem(hitemCur, ptu))
            return hitem;
    }
    
    return NULL;
}

HRESULT CTreeView::SelectNextUnreadItem()
{
    HRESULT     hr = E_FAIL;
    TREEUNREAD  tu;
    HTREEITEM   hitem;
    TV_ITEM     tvi;
    
    if (tu.hitemSel = TreeView_GetSelection(m_hwndTree))
    {
        tvi.mask   = TVIF_PARAM;
        tvi.lParam = 0;
        tvi.hItem  = tu.hitemSel;
        if (TreeView_GetItem(m_hwndTree, &tvi) && tvi.lParam)
        {
            LPFOLDERNODE pNode = (LPFOLDERNODE)tvi.lParam;
            
            tu.hwndTree = m_hwndTree;
            tu.fFoundSel = FALSE;
            tu.tyFolder = pNode->Folder.tyFolder;
            if (hitem = TreeView_GetRoot(m_hwndTree))
            {
                if (hitem = FindNextUnreadItem(hitem, &tu))
                {
                    if (ITreeView_SelectItem(m_hwndTree, hitem))
                        hr = S_OK;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsNoMoreUnreadFolders),
                      0, MB_ICONINFORMATION | MB_OK);
    }

    return hr;
}

HTREEITEM CTreeView::GetItemFromId(FOLDERID idFolder)
{
    if (FOLDERID_ROOT == idFolder)
        return TreeView_GetRoot(m_hwndTree);
    return FindKid(TreeView_GetRoot(m_hwndTree), idFolder);
}

HTREEITEM CTreeView::FindKid(HTREEITEM hitem, FOLDERID idFolder)
{
    TV_ITEM     item;
    HTREEITEM   hChild;
    HTREEITEM   hFound;
    
    hitem = TreeView_GetChild(m_hwndTree, hitem);
    while (hitem != NULL)
    {
        item.hItem = hitem;
        item.mask = TVIF_PARAM;
        if (TreeView_GetItem(m_hwndTree, &item))
        {
            LPFOLDERNODE pNode=(LPFOLDERNODE)item.lParam;
            
            if (pNode && pNode->Folder.idFolder == idFolder)
                return hitem;
        }
        
        hFound = FindKid(hitem, idFolder);
        if (hFound)
            return hFound;
        
        hitem = TreeView_GetNextSibling(m_hwndTree, hitem);
    }
    
    return(NULL);
}

HTREEITEM CTreeView::InsertNode(FOLDERID idFolder, DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    LPFOLDERNODE    pNode=NULL;
    INT             conn;
    TV_ITEM         item;
    BOOL            fUnread;
    HTREEITEM       hitem;
    HTREEITEM       hitemChild;
    HTREEITEM       hitemNew=NULL;
    TV_INSERTSTRUCT tvis;
    RECT            rc;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CTreeView::InsertNode");

    // Get parent of idFolder
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));
    
    // If this is unsubscribed IMAP fldr and we're in show subscribed only, don't show
    if (ISFLAGSET(dwFlags, TVIN_CHECKVISIBILITY))
    {
        // Hidden
        if (ISFLAGSET(Folder.dwFlags, FOLDER_HIDDEN) || !ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED))
            goto exit;

        // IE5 Bug #55075: We should never insert a folder which has any unsubscribed ancestors
        if (FOLDER_IMAP == Folder.tyFolder)
        {
            FOLDERINFO  fiCurrent;
            HRESULT     hrTemp;

            fiCurrent.idParent = Folder.idParent;
            while (FOLDERID_INVALID != fiCurrent.idParent && FOLDERID_ROOT != fiCurrent.idParent)
            {
                hrTemp = g_pStore->GetFolderInfo(fiCurrent.idParent, &fiCurrent);
                TraceError(hrTemp);
                if (SUCCEEDED(hrTemp))
                {
                    DWORD dwCurrentFlags = fiCurrent.dwFlags;

                    g_pStore->FreeRecord(&fiCurrent);
                    if (FOLDER_SERVER & dwCurrentFlags)
                        // Do not take server node subscription status into account: stop right here
                        break;

                    if (ISFLAGCLEAR(dwCurrentFlags, FOLDER_SUBSCRIBED))
                        goto exit; // Unsubscribed ancestor! NOT VISIBLE
                }
            } // while
        }
    }

    // Check for duplicates ?
    if (ISFLAGSET(dwFlags, TVIN_CHECKFORDUPS))
    {
        // Find the hitem for idFolder
        hitem = GetItemFromId(idFolder);

        // Does it Exist ?
        if (hitem != NULL)
        {
            // Setup an Item
            item.hItem = hitem;
            item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            
            // Get the Icon
            LONG iIcon = GetFolderIcon(&Folder, !!(m_dwFlags & TREEVIEW_DIALOG));
            
            // Change the Icon
            if (TreeView_GetItem(m_hwndTree, &item) && item.iImage != iIcon)
            {
                // Set the Icon
                item.iImage = iIcon;
                item.iSelectedImage = item.iImage;

                // Update the Item
                TreeView_SetItem(m_hwndTree, &item);
            }
            
            // Set hitemNew
            hitemNew = hitem;

            // Done
            goto exit;
        }
    }
   
    // If the parent of this new node is the root ?
    if (FOLDERID_INVALID == Folder.idParent)
    {
        // The root is the parent
        hitem = TreeView_GetRoot(m_hwndTree);
    }

    // Otherwise, get the parent...
    else
    {
        // Find the hitem for the parent
        hitem = GetItemFromId(Folder.idParent);

        // No parent found, insert a parent
        if (hitem == NULL)
        {
            // Insert the parent, but don't insert any of its children or there will be duplicates
            hitem = InsertNode(Folder.idParent, TVIN_DONTINSERTCHILDREN);

            // Can't be NULL
            Assert(hitem != NULL);
        }
    }
    
    // Do we have a parent
    if (hitem != NULL)
    {
        // Get the First Child
        hitemChild = TreeView_GetChild(m_hwndTree, hitem);
        
        // Setup an Insert struct
        tvis.hParent = hitem;
        tvis.hInsertAfter = TVI_LAST;
        
        // Get the Connected State
        GetConnectedState(&Folder, &conn);

        // Allocate a pNode
        IF_NULLEXIT(pNode = (LPFOLDERNODE)ZeroAllocate(sizeof(FOLDERNODE)));

        // Set the Folder Info
        CopyMemory(&pNode->Folder, &Folder, sizeof(FOLDERINFO));

        // Set the Flags
        pNode->dwFlags = (conn == DISCONNECTED ? FIDF_DISCONNECTED : 0);

        // Don't free Folder
        Folder.pAllocated = NULL;
        
        // Insert a new item
        hitemNew = ITreeView_InsertItem(&tvis, pNode);

        // Better not fail
        Assert(hitemNew != NULL);

        // If there are children
        if (0 == (dwFlags & TVIN_DONTINSERTCHILDREN) && !!(Folder.dwFlags & FOLDER_HASCHILDREN))
            FillTreeView2(hitemNew, &Folder, FALSE, conn, &fUnread);

        // Sort this parent children
        SortChildren(hitem);
        
        // TODO: we shouldn't have to do this. figure out why the parent isn't getting '+' after the insert
        if (hitemChild == NULL)
        {
            // Get the Rect of the parent
            TreeView_GetItemRect(m_hwndTree, hitem, &rc, FALSE);

            // Invalidate it so that it repaints
            InvalidateRect(m_hwndTree, &rc, TRUE);
        }

        // Make sure the new node is visible
        if (hitemNew)
        {
            // Is visible
            TreeView_EnsureVisible(m_hwndTree, hitemNew);
        }
    }
   
exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hitemNew);
}

HTREEITEM CTreeView::MoveNode(FOLDERID idFolder, FOLDERID idParentNew)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             conn;
    BOOL            fUnread;
    LPFOLDERNODE    pNode;
    HTREEITEM       hParent;
    HTREEITEM       hItemNew=NULL;
    TV_INSERTSTRUCT tvis;

    // Trace
    TraceCall("CTreeView::MoveNode");
    
    // Delete the Current Node
    DeleteNode(idFolder);

    // Allocate a pNode
    IF_NULLEXIT(pNode = (LPFOLDERNODE)ZeroAllocate(sizeof(FOLDERNODE)));
    
    // Get the Parent Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &pNode->Folder));
    
    // Get the Parent hTreeItem
    hParent = GetItemFromId(idParentNew);
    
    // Fill Insert Item
    tvis.hParent = hParent;
    tvis.hInsertAfter = TVI_LAST;

    // Get Connected State
    GetConnectedState(&pNode->Folder, &conn);

    // Set the Flags
    pNode->dwFlags = (conn == DISCONNECTED ? FIDF_DISCONNECTED : 0);
    
    // Insert a new item
    hItemNew = ITreeView_InsertItem(&tvis, pNode);

    // Fill the treeview with the children of Folder
    FillTreeView2(hItemNew, &pNode->Folder, FALSE, conn, &fUnread);
    
    // Sort the Parent
    SortChildren(hParent);
    
    // Return the new hitem
    Assert(hItemNew == GetItemFromId(idFolder));

exit:
    // Done
    return(hItemNew);
}

BOOL CTreeView::DeleteNode(FOLDERID idFolder)
{
    HTREEITEM hitem;
    BOOL fRet;
    
    hitem = GetItemFromId(idFolder);
    if (hitem != NULL)
    {
        fRet = TreeView_DeleteItem(m_hwndTree, hitem);
        Assert(fRet);
    }
    
    return(hitem != NULL);
}

STDMETHODIMP CTreeView::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HTREEITEM           hitem;
    HTREEITEM           hitemSelected;
    HTREEITEM           hitemNew;
    TV_ITEM             tvi;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    TRANSACTIONTYPE     tyTransaction;
    ORDINALLIST         Ordinals;
    INDEXORDINAL        iIndex;
    
    // Trace
    TraceCall("CTreeView::OnRecordNotify");
    
    if (m_hwndTree == NULL)
        return(S_OK);
    
    // Walk Through Notifications
    while (hTransaction)
    {
        // Set Notification Stuff
        if (FAILED(pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals)))
            break;
        
        // Insert (new Folder notification)
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Insert the node
            InsertNode(Folder1.idFolder, TVIN_CHECKFORDUPS | TVIN_CHECKVISIBILITY);
        }
        
        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Visibility change (subscription or hidden)
            if (ISFLAGSET(Folder1.dwFlags, FOLDER_SUBSCRIBED) != ISFLAGSET(Folder2.dwFlags, FOLDER_SUBSCRIBED) ||
                ISFLAGSET(Folder1.dwFlags, FOLDER_HIDDEN) != ISFLAGSET(Folder2.dwFlags, FOLDER_HIDDEN))
            {
                // Insert the node
                if (ISFLAGSET(Folder2.dwFlags, FOLDER_SUBSCRIBED) && ISFLAGCLEAR(Folder2.dwFlags, FOLDER_HIDDEN))
                {
                    // Show the node
                    InsertNode(Folder2.idFolder, TVIN_CHECKFORDUPS | TVIN_CHECKVISIBILITY);
                }
                
                // Remove the Node
                else
                {
                    // Delete the Node
                    OnNotifyDeleteNode(Folder2.idFolder);
                }
            }
            
            // Otherwise
            else
            {
                // Unread Change
                if (CUnread(&Folder1) != CUnread(&Folder2))
                {
                    // Get the Item
                    hitem = GetItemFromId(Folder1.idFolder);
                    
                    // If we found it
                    if (hitem != NULL)
                    {
                        // Initialize the item
                        tvi.hItem = hitem;
                        tvi.mask = TVIF_PARAM | TVIF_STATE;
                        
                        // Get the Items
                        if (TreeView_GetItem(m_hwndTree, &tvi) && tvi.lParam)
                        {
                            // This sets bold state for us and forces a repaint...
                            ITreeView_SetItem(&tvi, &Folder2);
                            
                            // Expand ?
                            if (!ISFLAGSET(tvi.state, TVIS_EXPANDED) && m_fExpandUnread && CUnread(&Folder2) > 0)
                            {
                                // Expand the Node
                                ExpandToVisible(m_hwndTree, hitem);
                            }
                        }
                    }
                }
                
                // Folder Moved ?
                if (Folder1.idParent != Folder2.idParent)
                {
                    // Get Current Selection
                    hitemSelected = TreeView_GetSelection(m_hwndTree);
                    
                    // Better not be NULL
                    Assert(hitemSelected != NULL);
                    
                    // Get the handle of the old item
                    hitem = GetItemFromId(Folder1.idFolder);
                    HTREEITEM htiParent = TreeView_GetParent(m_hwndTree, hitem);
                    
                    // Move the Node
                    hitemNew = MoveNode(Folder1.idFolder, Folder2.idParent);
                    
                    // Reset Selection.  
                    if (hitem == hitemSelected)
                    {
                        // If the new parent is the deleted items folder, we should 
                        // select the old node's parent.
                        FOLDERINFO rInfo;
                        if (SUCCEEDED(g_pStore->GetFolderInfo(Folder2.idParent, &rInfo)))
                        {
                            if (rInfo.tySpecial == FOLDER_DELETED)
                            {
                                hitemNew = htiParent;
                            }
                            g_pStore->FreeRecord(&rInfo);
                        }

                        ITreeView_SelectItem(m_hwndTree, hitemNew);
                    }
                }
                
                // Folder Renamed ?
                if (lstrcmp(Folder1.pszName, Folder2.pszName) != 0)
                {
                    // Get current Selection
                    hitemSelected = TreeView_GetSelection(m_hwndTree);
                    
                    // Better not be null
                    Assert(hitemSelected != NULL);
                    
                    // Get the hitem of the folder
                    hitem = GetItemFromId(Folder1.idFolder);
                    if (hitem != NULL)
                    {
                        // Reset the Tree view item
                        tvi.hItem = hitem;
                        tvi.mask = 0;
                        
                        // This will reset the folder name
                        ITreeView_SetItem(&tvi, &Folder2);
                        
                        // Get the Parent
                        HTREEITEM hitemParent = TreeView_GetParent(m_hwndTree, hitem);
                        
                        // Sort the Children
                        SortChildren(hitemParent);
                    }
                    
                    // Current Selection Changed
                    if (hitemSelected == hitem)
                        m_pNotify->OnRename(Folder1.idFolder);
                }
                
                // synchronize state changed ?
                if ((0 == (Folder1.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL))) ^
                    (0 == (Folder2.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL))))
                {
                    hitem = GetItemFromId(Folder1.idFolder);
                    if (hitem != NULL)
                    {
                        tvi.hItem = hitem;
                        tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvi.iImage = GetFolderIcon(&Folder2, !!(m_dwFlags & TREEVIEW_DIALOG));
                        tvi.iSelectedImage = tvi.iImage;
                        
                        TreeView_SetItem(m_hwndTree, &tvi);
                    }
                }

                // Special folder type changed?
                if (Folder1.tySpecial != Folder2.tySpecial)
                {
                    hitem = GetItemFromId(Folder1.idFolder);
                    if (hitem != NULL)
                    {
                        tvi.hItem = hitem;
                        tvi.mask = TVIF_PARAM;
                        if (TreeView_GetItem(m_hwndTree, &tvi) && tvi.lParam)
                            ((LPFOLDERNODE)tvi.lParam)->Folder.tySpecial = Folder2.tySpecial;
                        else
                            tvi.mask = 0; // I guess we won't be able to change special fldr type!

                        tvi.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvi.iImage = GetFolderIcon(&Folder2, !!(m_dwFlags & TREEVIEW_DIALOG));
                        tvi.iSelectedImage = tvi.iImage;
                        
                        TreeView_SetItem(m_hwndTree, &tvi);

                        hitem = GetItemFromId(Folder2.idParent);
                        SortChildren(hitem);
                    }
                }

                // Get the item
                hitem = GetItemFromId(Folder1.idFolder);
            
                // If we found it
                if (hitem != NULL)
                {
                    // Initialize the item
                    tvi.hItem = hitem;
                    tvi.mask = TVIF_PARAM;
                    
                    // Get the Items
                    if (TreeView_GetItem(m_hwndTree, &tvi) && tvi.lParam)
                    {
                        // Cast folder node
                        LPFOLDERNODE pNode = (LPFOLDERNODE)tvi.lParam;

                        // Validate
                        Assert(pNode->Folder.idFolder == Folder1.idFolder);

                        // Free current folder
                        g_pStore->FreeRecord(&pNode->Folder);

                        // Copy New Folder
                        CopyMemory(&pNode->Folder, &Folder2, sizeof(FOLDERINFO));

                        // Don't free Folder2)
                        ZeroMemory(&Folder2, sizeof(FOLDERINFO));
                    }
                }
            }
        }
        
        // Delete
        else if (TRANSACTION_DELETE == tyTransaction)
        {
            // Delete the Node
            OnNotifyDeleteNode(Folder1.idFolder);
        }
    }

    // Cleanup
    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);
    
    // Done
    return(S_OK);
}

void CTreeView::OnNotifyDeleteNode(FOLDERID idFolder)
{
    // Locals
    HTREEITEM           hitem;
    HTREEITEM           hitemSelected;
    HTREEITEM           hitemNew;
    
    // It's OK if this folder is not currently visible (IMAP)
    hitemSelected = TreeView_GetSelection(m_hwndTree);
    
    // Better not be NULL
    Assert(hitemSelected != NULL);
    
    // Get the item being deleted
    hitem = GetItemFromId(idFolder);
    
    // Reset selection if we deleted the currently selected item
    if (hitemSelected == hitem)
        hitemSelected = TreeView_GetParent(m_hwndTree, hitemSelected);
    else
        hitemSelected = NULL;
    
    // Delete this node
    DeleteNode(idFolder);
    
    // Reset the Selection
    if (hitemSelected != NULL)
        ITreeView_SelectItem(m_hwndTree, hitemSelected);
}


HRESULT CTreeView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    // Collect some information up front so we only have to ask once.
    ULONG      cServer;
    FOLDERID   idFolder = GetSelection();
    FOLDERINFO rFolder;
    HTREEITEM  htiDrop;
    
    // Check to see if there's a drop highlight
    if (NULL != (htiDrop = TreeView_GetDropHilight(m_hwndTree)))
    {
        TV_ITEM tvi;
        
        tvi.mask   = TVIF_PARAM;
        tvi.lParam = 0;
        tvi.hItem  = htiDrop;
        
        if (TreeView_GetItem(m_hwndTree, &tvi))
        {
            LPFOLDERNODE pNode = (LPFOLDERNODE)tvi.lParam;
            
            if (pNode)
                idFolder = pNode->Folder.idFolder;
        }
    }
    
    // If nothing is selected, we just disable everything
    if (idFolder == FOLDERID_INVALID)
        return (E_UNEXPECTED);        
    
    // Get the Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &rFolder)))
        return (E_UNEXPECTED);
    
    // Break some of this down for readability
    BOOL fSpecial = rFolder.tySpecial != FOLDER_NOTSPECIAL;
    BOOL fServer = rFolder.dwFlags & FOLDER_SERVER;
    BOOL fRoot = FOLDERID_ROOT == idFolder;
    BOOL fNews = rFolder.tyFolder == FOLDER_NEWS;
    BOOL fIMAP = rFolder.tyFolder == FOLDER_IMAP;
    BOOL fFocus = (m_hwndTree == GetFocus());
    BOOL fLocal = rFolder.tyFolder == FOLDER_LOCAL;
    BOOL fSubscribed = rFolder.dwFlags & FOLDER_SUBSCRIBED;
	BOOL fHotMailDisabled = FALSE;

	// Remove Synchronization/subscription from disabled Hotmail
	if(rFolder.tyFolder == FOLDER_HTTPMAIL)
	{
	    FOLDERINFO      SvrFolderInfo = {0};
	    IImnAccount     *pAccount = NULL;
	    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
		HRESULT         hr = S_OK;
		DWORD           dwShow = 0;

		// Get the server for this folder
        IF_FAILEXIT(hr = GetFolderServer(idFolder, &SvrFolderInfo));

        // Get the account ID for the server
        *szAccountId = 0;
        IF_FAILEXIT(hr = GetFolderAccountId(&SvrFolderInfo, szAccountId));

		// Get the account interface
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

		IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwShow));
		if(dwShow)
		{
			if(HideHotmail())
			{
				fSubscribed = FALSE;
				fHotMailDisabled = TRUE;
			}
		}
	}

exit:    
    for (ULONG i = 0; i < cCmds; i++)
    {
        // Only deal with commands that haven't yet been marked as supported
        if (prgCmds[i].cmdf == 0)
        {
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN_FOLDER:
                {
                    // Always
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }
                
                case ID_NEW_FOLDER:
                case ID_NEW_FOLDER2:
                {
                    // Enabled under personal folders and IMAP.
                    if (!fNews && !fRoot && rFolder.tySpecial != FOLDER_DELETED)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_COMPACT_ALL:
                case ID_NEXT_UNREAD_FOLDER:
                {
                    // This is always enabled.
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }
                
                case ID_RENAME:
                case ID_MOVE:
                {
                    // This is only enabled if we don't have a special folder
                    // selected and it's not a account or root note.
                    if (!fSpecial && !fServer && !fRoot && !fNews)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_COMPACT:
                {
                    // This is enabled whenever we have a non-server folder
                    if (!fServer && !fRoot)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_DELETE_ACCEL:
                case ID_DELETE_NO_TRASH_ACCEL:
                {
                    if (fFocus)
                    {
                        if (!fServer && !fRoot && !fSpecial)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_DELETE_FOLDER:
                case ID_DELETE_NO_TRASH:
                {
                    if (!fServer && !fRoot && !fNews && !fSpecial)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_SUBSCRIBE:
                case ID_UNSUBSCRIBE:
                {
                    if (!fServer && !fRoot && (fNews || (fIMAP && !fSpecial)))
                    {
                        if (fSubscribed ^ (prgCmds[i].cmdID == ID_SUBSCRIBE))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_PROPERTIES:
                {
                    // we only handle this if we have the focus
                    if (fFocus)
                    {
                        if (!fRoot && !(fLocal && fServer))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_NEWSGROUPS:
                case ID_IMAP_FOLDERS:
                {
                    if (SUCCEEDED(AcctUtil_GetServerCount(prgCmds[i].cmdID == ID_NEWSGROUPS ? SRV_NNTP : SRV_IMAP, &cServer)) &&
                        cServer > 0)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_EMPTY_JUNKMAIL:
                {
                    FOLDERINFO      rInfo;
                    
                    // Here's the default value
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    
                    // Get the delete items folder
                    if (g_pStore)
                    {
                        if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, prgCmds[i].cmdID == ID_EMPTY_JUNKMAIL ? FOLDER_JUNK : FOLDER_DELETED, &rInfo)))
                        {
                            if (rInfo.cMessages > 0 || FHasChildren(&rInfo, SUBSCRIBED))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            
                            g_pStore->FreeRecord(&rInfo);
                        }
                    }
                    break;
                }

                case ID_EMPTY_WASTEBASKET:
                {
                    // What we want to do here is see if the account for the currently 
                    // selected folder has a Deleted Items folder.  If it does, and that
                    // folder is not empty then this command is enabled.
                    FOLDERINFO rInfo;
                    FOLDERID   idServer;

                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (SUCCEEDED(GetFolderServerId(idFolder, &idServer)))
                    {
                        if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idServer, FOLDER_DELETED, &rInfo)))
                        {
                            if (rInfo.cMessages > 0 || FHasChildren(&rInfo, SUBSCRIBED))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            g_pStore->FreeRecord(&rInfo);
                        }
                    }

                    break;
                }
                
                case ID_SET_DEFAULT_SERVER:
                {
                    if (fServer && !fLocal)
                    {
                        // Check to see if _this_ account is the default
                        if (IsDefaultAccount(&rFolder))
                            prgCmds[i].cmdf = OLECMDF_LATCHED | OLECMDF_SUPPORTED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_REFRESH:
                case ID_RESET_LIST:
                case ID_REMOVE_SERVER:
                {
                    if (fServer && !fLocal)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_ADD_SHORTCUT:
                {
                    BOOL fVisible = FALSE;

                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    if (fSubscribed && SUCCEEDED(g_pBrowser->GetViewLayout(DISPID_MSGVIEW_OUTLOOK_BAR,
                                                                           NULL, &fVisible, NULL, NULL))
                                                                           && fVisible)
                    {
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    }
                    break;
                }
                
                case ID_POPUP_SYNCHRONIZE:
                {
                    if (!fServer && !fLocal && fSubscribed)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }
                
                case ID_UNMARK_RETRIEVE_FLD:
                {
                    if (!fServer && !fLocal && fSubscribed)
                    {
                        if (0 == (rFolder.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
                {
                    if (!fServer && !fLocal && fSubscribed)
                    {
                        if (!!(rFolder.dwFlags & FOLDER_DOWNLOADHEADERS))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
                {
                    if (!fServer && !fLocal && fSubscribed)
                    {
                        if (!!(rFolder.dwFlags & FOLDER_DOWNLOADNEW))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
                {
                    if (!fServer && !fLocal && fSubscribed)
                    {
                        if (!!(rFolder.dwFlags & FOLDER_DOWNLOADALL))
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }
                
                case ID_SYNC_THIS_NOW:
                {
                    if (!fLocal && !fHotMailDisabled)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_CATCH_UP:
                {
                    if (!fServer && fNews)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;

                    break;
                }

                case ID_FIND_FOLDER:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }

            }
        }
    }
    
    g_pStore->FreeRecord(&rFolder);
    
    return (S_OK);
}


HRESULT CTreeView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr;
    FOLDERINFO info;
    BOOL fNews, fUnsubscribed;
    FOLDERID id, idFolder = GetSelection();
    HTREEITEM htiDrop = TreeView_GetDropHilight(m_hwndTree);
    
    // Note - If you do or call anything in here that display's UI, you must 
    //        parent the UI to m_hwndUIParent.  The treeview window might not
    //        be visible when this is called.
    
    if (htiDrop)
    {
        // Get the folder id from the drop highlighted folder
        TV_ITEM tvi;
        
        tvi.mask   = TVIF_PARAM;
        tvi.lParam = 0;
        tvi.hItem  = htiDrop;
        
        if (TreeView_GetItem(m_hwndTree, &tvi))
        {
            LPFOLDERNODE pNode = (LPFOLDERNODE)tvi.lParam;
            
            if (pNode)
                idFolder = pNode->Folder.idFolder;
        }
    }
    
    switch (nCmdID)
    {
        case ID_OPEN_FOLDER:
        {
            // Check to see if there's a drop highlight
            if (NULL != htiDrop)
            {
                // Select the item that we're highlighed on
                ITreeView_SelectItem(m_hwndTree, htiDrop);
            }
            return (S_OK);
        }
        
        case ID_NEW_FOLDER:
        case ID_NEW_FOLDER2:
        {
            SelectFolderDialog(m_hwndUIParent, SFD_NEWFOLDER, idFolder, TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT | FD_FORCEINITSELFOLDER,
                NULL, NULL, NULL);
            return (S_OK);            
        }
        
        case ID_MOVE:
        {
            SelectFolderDialog(m_hwndUIParent, SFD_MOVEFOLDER, idFolder, TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT,
                MAKEINTRESOURCE(idsMove), MAKEINTRESOURCE(idsMoveCaption), NULL);
            return (S_OK);            
        }
        
        case ID_RENAME:
        {
            RenameFolderDlg(m_hwndUIParent, idFolder);
            return (S_OK);
        }
        
        case ID_DELETE_FOLDER:
        case ID_DELETE_NO_TRASH:
            fUnsubscribed = FALSE;

            hr = g_pStore->GetFolderInfo(idFolder, &info);
            if (SUCCEEDED(hr))
            {
                if (info.tyFolder == FOLDER_NEWS &&
                    0 == (info.dwFlags & FOLDER_SERVER) &&
                    0 == (info.dwFlags & FOLDER_SUBSCRIBED))
                {
                    fUnsubscribed = TRUE;
                }
                
                g_pStore->FreeRecord(&info);
            }

            if (fUnsubscribed)
            {
                DeleteNode(idFolder);
                return(S_OK);
            }
            // fall through...

        case ID_REMOVE_SERVER:
        {
            // Delete it
            MenuUtil_OnDelete(m_hwndUIParent, idFolder, nCmdID == ID_DELETE_NO_TRASH);
            return (S_OK);
        }
        
        case ID_SUBSCRIBE:
        case ID_UNSUBSCRIBE:
        {
            MenuUtil_OnSubscribeGroups(m_hwndUIParent, &idFolder, 1, nCmdID == ID_SUBSCRIBE);
            return (S_OK);
        }
        
        case ID_COMPACT:
        {
            CompactFolders(m_hwndUIParent, RECURSE_INCLUDECURRENT, idFolder);
            return (S_OK);
        }

        case ID_COMPACT_ALL:
        {
            CompactFolders(m_hwndUIParent, RECURSE_ONLYSUBSCRIBED | RECURSE_SUBFOLDERS, FOLDERID_ROOT);
            return (S_OK);
        }

        case ID_NEXT_UNREAD_FOLDER:
        {
            SelectNextUnreadItem();
            return (S_OK);
        }
        
        case ID_PROPERTIES:
        {
            if (m_hwndTree == GetFocus())
            {
                MenuUtil_OnProperties(m_hwndUIParent, idFolder);
                return(S_OK);
            }
            break;
        }
        
        case ID_EMPTY_JUNKMAIL:
        {
            if (AthMessageBoxW(m_hwndUIParent, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsWarnEmptyJunkMail),
                NULL, MB_YESNO | MB_DEFBUTTON2) == IDYES)
            {
                EmptySpecialFolder(m_hwndUIParent, FOLDER_JUNK);
            }
            return(S_OK);
        }

        case ID_EMPTY_WASTEBASKET:
        {
            if (AthMessageBoxW(m_hwndUIParent, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsWarnEmptyDeletedItems),
                NULL, MB_YESNO | MB_DEFBUTTON2) == IDYES)
            {
                FOLDERINFO rInfo;
                FOLDERID   idServer;

                if (SUCCEEDED(GetFolderServerId(idFolder, &idServer)))
                {
                    if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idServer, FOLDER_DELETED, &rInfo)))
                    {
                        if (rInfo.cMessages > 0 || FHasChildren(&rInfo, SUBSCRIBED))
                            EmptyFolder(m_hwndUIParent, rInfo.idFolder);

                        g_pStore->FreeRecord(&rInfo);
                    }
                }

            }
            return (S_OK);
        }
        
        case ID_SET_DEFAULT_SERVER:
        {
            MenuUtil_OnSetDefaultServer(idFolder);
            return (S_OK);
        }
        
        case ID_REFRESH:
        case ID_RESET_LIST:
        {
            hr = g_pStore->GetFolderInfo(idFolder, &info);
            if (SUCCEEDED(hr))
            {
                if (info.tyFolder != FOLDER_LOCAL &&
                    !!(info.dwFlags & FOLDER_SERVER))
                {
                    DownloadNewsgroupList(m_hwndUIParent, idFolder);
                }
                
                g_pStore->FreeRecord(&info);
            }
            return(S_OK);
        }
        
        case ID_NEWSGROUPS:
        case ID_IMAP_FOLDERS:
        {
            fNews = (nCmdID == ID_NEWSGROUPS);
            
            hr = g_pStore->GetFolderInfo(idFolder, &info);
            if (SUCCEEDED(hr))
            {
                if ((fNews && info.tyFolder != FOLDER_NEWS) ||
                    (!fNews && info.tyFolder != FOLDER_IMAP) ||
                    FAILED(GetFolderServerId(idFolder, &id)))
                {
                    id = FOLDERID_INVALID;
                }
                
                g_pStore->FreeRecord(&info);
                
                DoSubscriptionDialog(m_hwndUIParent, fNews, id);
            }
            return(S_OK);
        }
        
        case ID_ADD_SHORTCUT:
        {
            OutlookBar_AddShortcut(idFolder);
            return (S_OK);
        }
        
        case ID_UNMARK_RETRIEVE_FLD:
        {
            SetSynchronizeFlags(idFolder, 0);
            return(S_OK);
        }
        
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
        {
            SetSynchronizeFlags(idFolder, FOLDER_DOWNLOADHEADERS);
            return(S_OK);
        }
        
        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
        {
            SetSynchronizeFlags(idFolder, FOLDER_DOWNLOADNEW);
            return(S_OK);
        }
        
        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
        {
            SetSynchronizeFlags(idFolder, FOLDER_DOWNLOADALL);
            return(S_OK);
        }
        
        case ID_SYNC_THIS_NOW:
        {
            MenuUtil_SyncThisNow(m_hwndUIParent, idFolder);
            return(S_OK);
        }

        case ID_CATCH_UP:
        {
            MenuUtil_OnCatchUp(idFolder);
            return(S_OK);
        }

        case ID_FIND_FOLDER:
        {
            DoFindMsg(idFolder, FOLDER_LOCAL);
            return (S_OK);
        }

    }
    
    return (OLECMDERR_E_NOTSUPPORTED);
}

int CALLBACK TreeViewCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    INT             cmp;
    LPFOLDERNODE    pNode1=(LPFOLDERNODE)lParam1;
    LPFOLDERNODE    pNode2=(LPFOLDERNODE)lParam2;
    LPFOLDERINFO    pFolder1=&pNode1->Folder;
    LPFOLDERINFO    pFolder2=&pNode2->Folder;
    
    Assert(pNode1);
    Assert(pNode2);
    Assert(pFolder1);
    Assert(pFolder2);

    if (!!(pFolder1->dwFlags & FOLDER_SERVER))
    {
        Assert(!!(pFolder2->dwFlags & FOLDER_SERVER));
        
        if (pFolder1->tyFolder == pFolder2->tyFolder)
            cmp = lstrcmpi(pFolder1->pszName, pFolder2->pszName);
        else
        {
            cmp = pFolder1->tyFolder - pFolder2->tyFolder;
            cmp = (cmp < 0) ? 1 : -1;
        }
    }
    else if (pFolder1->tySpecial != FOLDER_NOTSPECIAL)
    {
        if (pFolder2->tySpecial != FOLDER_NOTSPECIAL)
            cmp = pFolder1->tySpecial - pFolder2->tySpecial;
        else
            cmp = -1;
    }
    else
    {
        if (pFolder2->tySpecial != FOLDER_NOTSPECIAL)
            cmp = 1;
        else
            cmp = lstrcmpi(pFolder1->pszName, pFolder2->pszName);
    }
    
    return(cmp);
}

void CTreeView::SortChildren(HTREEITEM hitem)
{
    TV_SORTCB   sort;
    HRESULT     hr;
    
    // sort the branch that is expanding
    // TODO: find out if it really needs to be sorted
    LPFOLDERNODE pNode = GetFolderNode(hitem);
    if (NULL == pNode)
        return;
    
    sort.hParent = hitem;
    sort.lpfnCompare = TreeViewCompare;
    sort.lParam = (LPARAM)&pNode->Folder;
    
    TreeView_SortChildrenCB(m_hwndTree, &sort, TRUE);
}

//
//  FUNCTION:   CTreeView::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE CTreeView::DragEnter(IDataObject* pDataObject, 
                                               DWORD grfKeyState, 
                                               POINTL pt, DWORD* pdwEffect)
{    
    Assert(m_pDataObject == NULL);
    DOUTL(32, _T("CTreeView::DragEnter() - Starting"));
    
    // Initialize our state
    SafeRelease(m_pDTCur);
    m_pDataObject = pDataObject;
    m_pDataObject->AddRef();
    m_grfKeyState = grfKeyState;
    m_htiCur = NULL;
    Assert(m_pDTCur == NULL);
    
    // Set the default return value to be failure
    m_dwEffectCur = *pdwEffect = DROPEFFECT_NONE;
    
    if (m_pFolderBar)
        m_pFolderBar->KillScopeCloseTimer();
    
    UpdateDragDropHilite(&pt);    
    return (S_OK);
}


//
//  FUNCTION:   CTreeView::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE CTreeView::DragOver(DWORD grfKeyState, POINTL pt, 
                                              DWORD* pdwEffect)
{
    FORMATETC       fe;
    ULONG           celtFetched;
    TV_ITEM         tvi;
    HTREEITEM       hti;
    HRESULT         hr = E_FAIL;
    DWORD           dwEffectScroll = 0;
    HWND            hwndBrowser;
    
    // If we don't have a stored data object from DragEnter()
    if (NULL == m_pDataObject)
        return (S_OK);
    
    // Get the browser window from the IAthenaBrowser interface.  If we don't
    // use the browser window to pass to IContextMenu, then when the treeview
    // is in autohide mode, the mouse capture goes beserk.
    if (FAILED(m_pBrowser->GetWindow(&hwndBrowser)))
        return (S_OK);
    
    // Autoscroll if we need to
    if (AutoScroll((const LPPOINT) &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;
    
    // Find out which item the mouse is currently over
    if (NULL == (hti = GetItemFromPoint(pt)))
    {
        DOUTL(32, _T("CTreeView::DragOver() - GetItemFromPoint() returns NULL."));        
    }
    
    // If we're over a new tree node, then bind to the folder
    if (m_htiCur != hti)
    {
        // Keep track of this for autoexpand
        m_dwExpandTime = GetTickCount();
        
        // Release our previous drop target if any
        SafeRelease(m_pDTCur);
        
        // Update the current object
        m_htiCur = hti;
        
        // Assume there's no drop target and assume error
        Assert(m_pDTCur == NULL);
        m_dwEffectCur = DROPEFFECT_NONE;
        
        // Update the treeview UI
        UpdateDragDropHilite(&pt);
        
        if (hti)
        {
            FOLDERINFO Folder={0};
            
            // Get Folder Node
            LPFOLDERNODE pNode = GetFolderNode(hti);
            
            // Get information about this folder
            if (pNode)
            {
                m_pDTCur = new CDropTarget();
                if (m_pDTCur)
                {
                    hr = ((CDropTarget *) m_pDTCur)->Initialize(m_hwndUIParent, pNode->Folder.idFolder);
                }
            }
            
            // If we have a drop target now, call DragEnter()
            if (SUCCEEDED(hr) && m_pDTCur)
            {
                hr = m_pDTCur->DragEnter(m_pDataObject, grfKeyState, pt, 
                    pdwEffect);
                m_dwEffectCur = *pdwEffect;
            }
        }
        else
        {
            m_dwEffectCur = 0;
        }
    }
    else
    {
        // No target change        
        if (m_htiCur)
        {
            DWORD dwNow = GetTickCount();
            
            // If the person is hovering, expand the node
            if ((dwNow - m_dwExpandTime) >= 1000)
            {
                m_dwExpandTime = dwNow;
                TreeView_Expand(m_hwndTree, m_htiCur, TVE_EXPAND);
            }
        }
        
        // If the keys changed, we need to re-query the drop target
        if ((m_grfKeyState != grfKeyState) && m_pDTCur)
        {
            m_dwEffectCur = *pdwEffect;
            hr = m_pDTCur->DragOver(grfKeyState, pt, &m_dwEffectCur);
        }
        else
        {
            hr = S_OK;
        }
    }
    
    *pdwEffect = m_dwEffectCur | dwEffectScroll;
    m_grfKeyState = grfKeyState;

    return (hr);
}
    
    
//
//  FUNCTION:   CTreeView::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT STDMETHODCALLTYPE CTreeView::DragLeave(void)
{
    DOUTL(32, _T("CTreeView::DragLeave()"));
    
    SafeRelease(m_pDTCur);
    SafeRelease(m_pDataObject);
    
    UpdateDragDropHilite(NULL);    
    
    if (m_pFolderBar)
        m_pFolderBar->SetScopeCloseTimer();
    
    return (S_OK);
}

    
//
//  FUNCTION:   CTreeView::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we 
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.  If this is a copy or move, then
//              we go ahead and update the store.  Otherwise, we bring up
//              a send note with the object attached.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT STDMETHODCALLTYPE CTreeView::Drop(IDataObject* pDataObject, 
    DWORD grfKeyState, POINTL pt, 
    DWORD* pdwEffect)
{
    HRESULT         hr;
    
    Assert(m_pDataObject == pDataObject);
    
    DOUTL(32, _T("CTreeView::Drop() - Starting"));
    
    if (m_pDTCur)
    {
        hr = m_pDTCur->Drop(pDataObject, grfKeyState, pt, pdwEffect);
    }
    else
    {
        DOUTL(32, "CTreeView::Drop() - no drop target.");
        *pdwEffect = 0;
        hr = S_OK;
    }
    
    UpdateDragDropHilite(NULL);  
    
    if (m_pFolderBar)
    {
        m_pFolderBar->KillScopeDropDown();
    }
    
    SafeRelease(m_pDataObject);
    SafeRelease(m_pDTCur);
    
    return (hr);
}
    
    
    
//
//  FUNCTION:   CTreeView::UpdateDragDropHilite()
//
//  PURPOSE:    Called by the various IDropTarget interfaces to move the drop
//              selection to the correct place in our listview.
//
//  PARAMETERS:
//      <in> *ppt - Contains the point that the mouse is currently at.  If this
//                  is NULL, then the function removes any previous UI.
//
void CTreeView::UpdateDragDropHilite(POINTL *ppt)
{
    TV_HITTESTINFO tvhti;
    HTREEITEM      htiTarget = NULL;
    
    // Unlock the treeview and let it repaint.  Then update the selected
    // item.  If htiTarget is NULL, the the drag highlight goes away.
    // ImageList_DragLeave(m_hwndTree);
    
    // If a position was provided
    if (ppt)
    {
        // Figure out which item is selected
        tvhti.pt.x = ppt->x;
        tvhti.pt.y = ppt->y;
        ScreenToClient(m_hwndTree, &tvhti.pt);        
        htiTarget = TreeView_HitTest(m_hwndTree, &tvhti);
        
        // Only if the cursor is over something do we relock the window.
        if (htiTarget)
        {
            TreeView_SelectDropTarget(m_hwndTree, htiTarget);
        }
    } 
    else
        TreeView_SelectDropTarget(m_hwndTree, NULL);
}   


BOOL CTreeView::AutoScroll(const POINT *ppt)
{
    // Find out if the point is above or below the tree
    RECT rcTree;
    GetWindowRect(m_hwndTree, &rcTree);
    
    // Reduce the rect so we have a scroll margin all the way around
    InflateRect(&rcTree, -32, -32);
    
    if (rcTree.top > ppt->y)
    {
        // Scroll down
        FORWARD_WM_VSCROLL(m_hwndTree, NULL, SB_LINEUP, 1, SendMessage);
        return (TRUE);
    }
    else if (rcTree.bottom < ppt->y)
    {
        // Scroll Up
        FORWARD_WM_VSCROLL(m_hwndTree, NULL, SB_LINEDOWN, 1, SendMessage);
        return (TRUE);
    }
    
    return (FALSE);
}


//
//  FUNCTION:   CTreeView::GetItemFromPoint()
//
//  PURPOSE:    Given a point, this function returns the listview item index
//              and HFOLDER for the item under that point.
//
//  PARAMETERS:
//      <in> pt       - Position in screen coordinates to check for.
//      <in> phFolder - Returns the HFOLDER for the item under pt.  If there
//                      isn't an item under pt, then NULL is returned.
//
//  RETURN VALUE:
//      Returns the handle of the item under the specified point.  If no item
//      exists, then NULL is returned.
//
HTREEITEM CTreeView::GetItemFromPoint(POINTL pt)
{
    TV_HITTESTINFO tvhti;
    TV_ITEM        tvi;
    HTREEITEM      htiTarget;
    
    // Find out from the ListView what item are we over
    tvhti.pt.x = pt.x;
    tvhti.pt.y = pt.y;
    ScreenToClient(m_hwndTree, &(tvhti.pt));
    htiTarget = TreeView_HitTest(m_hwndTree, &tvhti);
    
    return (tvhti.hItem);
}    


HRESULT STDMETHODCALLTYPE CTreeView::QueryContinueDrag(BOOL fEscapePressed, 
    DWORD grfKeyState)
{
    if (fEscapePressed)
        return (DRAGDROP_S_CANCEL);
    
    if (grfKeyState & MK_RBUTTON)
        return (DRAGDROP_S_CANCEL);
    
    if (!(grfKeyState & MK_LBUTTON))
        return (DRAGDROP_S_DROP);
    
    return (S_OK);    
}


HRESULT STDMETHODCALLTYPE CTreeView::GiveFeedback(DWORD dwEffect)
{
    return (DRAGDROP_S_USEDEFAULTCURSORS);
}
    
//
//  FUNCTION:   CTreeView::OnBeginDrag()
//
//  PURPOSE:    This function is called when the user begins dragging an item
//              in the ListView.  If the item selected is a draggable item,
//              then we create an IDataObject for the item and then call OLE's
//              DoDragDrop().
//
//  PARAMETERS:
//      <in> pnmlv - Pointer to an NM_LISTIVEW struct which tells us which item
//                   has been selected to be dragged.
//
//  RETURN VALUE:
//      Returns zero always.
//
LRESULT CTreeView::OnBeginDrag(NM_TREEVIEW* pnmtv)
{
    FOLDERID            idFolderSel=FOLDERID_INVALID;
    DWORD               cSel = 0;
    int                 iSel = -1;
    FOLDERID           *pidFolder = 0;
    PDATAOBJINFO        pdoi = 0;
    DWORD               dwEffect;
    IDataObject        *pDataObj = 0;
    HTREEITEM           htiSel;
    LPFOLDERNODE        pNode;
    
    // Bug #17491 - Check to see if this is the root node.  If so, we don't drag.
    if (0 == pnmtv->itemNew.lParam)
        return (0);
    
    // Get the Node
    pNode = (LPFOLDERNODE)pnmtv->itemNew.lParam;
    if (NULL == pNode)
        return (0);
    
    CFolderDataObject *pDataObject = new CFolderDataObject(pNode->Folder.idFolder);
    if (!pDataObject)
        return (0);
    
    DoDragDrop(pDataObject, (IDropSource*) this, DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK, &dwEffect);
    pDataObject->Release();
    
    return (0);
}    

LRESULT CTreeView::OnBeginLabelEdit(TV_DISPINFO* ptvdi)
{
    RECT rc, rcT;
    
    // Get Folder Node
    LPFOLDERNODE pNode = (LPFOLDERNODE)ptvdi->item.lParam;
    if (NULL == pNode)
        return (FALSE);
    
    // Can Rename
    if (ISFLAGSET(pNode->Folder.dwFlags, FOLDER_CANRENAME))
    {
        m_fEditLabel = TRUE;
        m_hitemEdit = ptvdi->item.hItem;
        
        if (TreeView_GetItemRect(m_hwndTree, ptvdi->item.hItem, &rc, TRUE))
        {
            GetClientRect(m_hwndTree, &rcT);
            
            rc.left = rc.right;
            rc.right = rcT.right;
            InvalidateRect(m_hwndTree, &rc, TRUE);
        }
        return (FALSE);
    }
    else
    {
        return (TRUE);
    }
}

BOOL CTreeView::OnEndLabelEdit(TV_DISPINFO* ptvdi)
{
    HRESULT         hr;
    LPFOLDERNODE    pNode;
    IImnAccount    *pAcct, *pAcctT; 
    BOOL            fReturn = FALSE;
    HWND            hwndBrowser;
    
    m_fEditLabel = FALSE;
    m_hitemEdit = NULL;
    
    // First check to see if label editing was canceled
    if (0 == ptvdi->item.pszText)
        return (FALSE);
    
    // Get the browser window from the IAthenaBrowser interface.  If we don't
    // use the browser window to pass to IContextMenu, then when the treeview
    // is in autohide mode, the mouse capture goes beserk.
    if (FAILED(m_pBrowser->GetWindow(&hwndBrowser)))
        return (FALSE);
    
    // Get the node
    pNode = (LPFOLDERNODE)ptvdi->item.lParam;
    if (NULL == pNode)
        return (FALSE);
    
    // Local Folder
    if (FALSE == ISFLAGSET(pNode->Folder.dwFlags, FOLDER_SERVER))
    {
        if (FAILED(hr = RenameFolderProgress(hwndBrowser, pNode->Folder.idFolder, ptvdi->item.pszText, NOFLAGS)))
        {
            // Display an error message
            AthErrorMessageW(hwndBrowser, MAKEINTRESOURCEW(idsAthenaMail),
                MAKEINTRESOURCEW(idsErrRenameFld), hr);
            return (FALSE);
        }
    }
    
    // Servers
    else
    {
        Assert(g_pAcctMan);
        Assert(!FIsEmptyA(pNode->Folder.pszAccountId));
        
        if (!FIsEmpty(ptvdi->item.pszText) &&
            0 != lstrcmpi(pNode->Folder.pszName, ptvdi->item.pszText) &&
            SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pNode->Folder.pszAccountId, &pAcct)))
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, ptvdi->item.pszText, &pAcctT)))
            {
                Assert(!fReturn);
                pAcctT->Release();
                hr = E_DuplicateAccountName;
            }
            else
            {
                fReturn = SUCCEEDED(hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, ptvdi->item.pszText));
                if (fReturn)
                    fReturn = SUCCEEDED(hr = pAcct->SaveChanges());
            }
            
            if (hr == E_DuplicateAccountName)
            {
                TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
                AthLoadString(idsErrDuplicateAccount, szRes, ARRAYSIZE(szRes));
                wsprintf(szBuf, szRes, ptvdi->item.pszText);
                AthMessageBox(hwndBrowser, MAKEINTRESOURCE(idsAthena), szBuf, 0, MB_ICONSTOP | MB_OK);
            }
            else if (FAILED(hr))
            {
                AthMessageBoxW(hwndBrowser, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrRenameAccountFailed),
                    0, MB_ICONSTOP | MB_OK);
            }
            
            pAcct->Release();
            return (fReturn);
        }
        else
        {
            return (FALSE);
        }
    }
    
    return (TRUE);
}

HRESULT CTreeView::RegisterFlyOut(CFolderBar *pFolderBar)
{
    Assert(m_pFolderBar == NULL);
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();

    RegisterGlobalDropDown(m_hwnd);    
    return S_OK;
}

HRESULT CTreeView::RevokeFlyOut(void)
{
    if (m_pFolderBar)
    {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
    }
    
    UnregisterGlobalDropDown(m_hwnd);
    return S_OK;
}
    
    
HRESULT CTreeView::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    UpdateLabelColors();
    return (S_OK);
}

void CTreeView::UpdateLabelColors()
{
    BOOL            fConn;
    HTREEITEM       treeitem;
    LPFOLDERNODE    pNode;
    TVITEM          item;
    
    if (m_hwndTree != NULL)
    {
        treeitem = TreeView_GetRoot(m_hwndTree);
        if (treeitem != NULL)
        {
            treeitem = TreeView_GetChild(m_hwndTree, treeitem);
            while (treeitem != NULL)
            {
                item.hItem  = treeitem;
                item.mask   = TVIF_PARAM;
                
                if (TreeView_GetItem (m_hwndTree, &item) && (pNode = (LPFOLDERNODE)item.lParam) != NULL)
                {
                    Assert(!!(pNode->Folder.dwFlags & FOLDER_SERVER));
                    
                    if (pNode->Folder.tyFolder != FOLDER_LOCAL)
                    {
                        Assert(!FIsEmptyA(pNode->Folder.pszAccountId));
                        //fConn = (g_pConMan->CanConnect(Folder.pszAccountId) == S_OK);
                        fConn = g_pConMan->IsGlobalOffline();
                        //if (fConn ^ (0 == (pNode->dwFlags & FIDF_DISCONNECTED)))
                        if (fConn ^ (!!(pNode->dwFlags & FIDF_DISCONNECTED)))
                        {
                            // if the connect state has changed, then let's update
                            UpdateChildren(treeitem, !fConn, FALSE);
                        }
                    }
                    
                    treeitem = TreeView_GetNextSibling(m_hwndTree, treeitem);
                }
            }
        }
    }
}
    
void CTreeView::UpdateChildren(HTREEITEM treeitem, BOOL canconn, BOOL fSiblings)
{
    HTREEITEM hitem;
    RECT rect;
    LPFOLDERNODE pNode;
    
    Assert(treeitem != NULL);
    
    while (treeitem != NULL)
    {
        pNode = GetFolderNode(treeitem);
        Assert(pNode != NULL);
        
        if (canconn)
            pNode->dwFlags &= ~FIDF_DISCONNECTED;
        else
            pNode->dwFlags |= FIDF_DISCONNECTED;
        
        TreeView_GetItemRect(m_hwndTree, treeitem, &rect, TRUE);
        InvalidateRect(m_hwndTree, &rect, FALSE);
        
        hitem = TreeView_GetChild(m_hwndTree, treeitem);
        if (hitem != NULL)
            UpdateChildren(hitem, canconn, TRUE);
        
        if (!fSiblings)
            break;
        
        treeitem = TreeView_GetNextSibling(m_hwndTree, treeitem);
    }
}

LPFOLDERNODE CTreeView::GetFolderNode(HTREEITEM hItem)
{
    TVITEM      item;
    BOOL        retval;
    
    if (!hItem)
        return NULL;
    
    item.hItem = hItem;
    item.mask  = TVIF_PARAM;
    retval = TreeView_GetItem (m_hwndTree,  &item);
    return (retval ? (LPFOLDERNODE)item.lParam : NULL);
}

HRESULT CTreeView::AdviseAccount(DWORD dwAdviseType, ACTX *pactx)
{
    //We are only interested in this type
    if (dwAdviseType == AN_ACCOUNT_CHANGED)
    {
        UpdateLabelColors();
    }
    return S_OK;
}

//
//
// CTreeViewFrame
//
//

CTreeViewFrame::CTreeViewFrame()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_ptv = NULL;
}

CTreeViewFrame::~CTreeViewFrame()
{
    if (m_ptv != NULL)
        m_ptv->Release();
}

HRESULT CTreeViewFrame::Initialize(HWND hwnd, RECT *prc, DWORD dwFlags)
{
    HRESULT hr;
    
    Assert(hwnd != 0);
    Assert(prc != NULL);
    
    m_hwnd = hwnd;
    m_rect = *prc;
    
    m_ptv = new CTreeView(this);
    if (m_ptv == NULL)
        return(hrMemory);
    
    hr = m_ptv->HrInit(dwFlags, NULL);
    if (!FAILED(hr))
    {
//        m_ptv->SetSite((IInputObjectSite*)this);
//        m_ptv->UIActivateIO(TRUE, NULL);
        
        //We also set the tree view window position here since the actual treeview is re-sized by the rebar
        HWND         hChild;
        TCHAR        Classname[30];
        int          Count;
        CTreeView    *ptv;   
        
        hChild = m_ptv->Create(m_hwnd, NULL, FALSE);
        
        /*
        while (hChild) 
        { 
            if ((ptv = (CTreeView*)GetWindowLong(hChild, GWL_USERDATA)) == m_ptv)
            {
            */
                SetWindowPos(hChild, NULL, m_rect.left, m_rect.top, 
                    m_rect.right - m_rect.left, 
                    m_rect.bottom - m_rect.top,
                    SWP_NOZORDER | SWP_SHOWWINDOW);
                return (hr);
                /*
            }
            hChild = ::GetNextWindow(hChild, GW_HWNDNEXT);
            
        } //while(hChild)
        
        hr = E_FAIL;
        */
    } //if (!FAILED(hr))
    
    return(hr);
}

void CTreeViewFrame::CloseTreeView()
{
    if (m_ptv != NULL)
    {
        m_ptv->UIActivateIO(FALSE, NULL);
        m_ptv->SetSite(NULL);
    }
}

HRESULT STDMETHODCALLTYPE CTreeViewFrame::QueryInterface(REFIID riid, void **ppvObj)
{
    if ((IsEqualIID(riid, IID_IInputObjectSite)) || (IsEqualIID(riid, IID_IUnknown)))
        
    {
        *ppvObj = (void*) (IInputObjectSite *) this;
    }
    else if (IsEqualIID(riid, IID_IOleWindow))
    {
        *ppvObj = (void*) (IOleWindow *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CTreeViewFrame::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CTreeViewFrame::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT STDMETHODCALLTYPE CTreeViewFrame::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CTreeViewFrame::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}

HRESULT CTreeViewFrame::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return S_OK;
}

void CTreeViewFrame::OnSelChange(FOLDERID idFolder)
{
    SendMessage(m_hwnd, TVM_SELCHANGED, 0, (LPARAM)idFolder);
    return;
}

void CTreeViewFrame::OnRename(FOLDERID idFolder)
{
    return;
}

void CTreeViewFrame::OnDoubleClick(FOLDERID idFolder)
{
    SendMessage(m_hwnd, TVM_DBLCLICK, 0, (LPARAM)idFolder);
    return;
}

HRESULT CTreeView::SaveExpandState(HTREEITEM hitem)
{
    HRESULT hr;
    TV_ITEM item;
    HTREEITEM hitemT;
    LPFOLDERNODE pNode;
    
    while (hitem != NULL)
    {
        hitemT = TreeView_GetChild(m_hwndTree, hitem);
        if (hitemT != NULL)
        {
            item.hItem = hitem;
            item.mask = TVIF_STATE;
            item.stateMask = TVIS_EXPANDED;
            if (TreeView_GetItem(m_hwndTree, &item))
            {
                pNode = GetFolderNode(hitem);
                if (pNode)
                {
                    if (!!(pNode->Folder.dwFlags & FOLDER_EXPANDTREE) ^ !!(item.state & TVIS_EXPANDED))
                    {
                        pNode->Folder.dwFlags ^= FOLDER_EXPANDTREE;
                        g_pStore->UpdateRecord(&pNode->Folder);
                    }
                }
                
                if (!!(item.state & TVIS_EXPANDED))
                {
                    // we only care about saving the expanded state for children
                    // of expanded nodes
                    hr = SaveExpandState(hitemT);
                    if (FAILED(hr))
                        return(hr);
                }
            }
        }
        
        hitem = TreeView_GetNextSibling(m_hwndTree, hitem);
    }
    
    return(S_OK);
}


void CTreeView::ExpandToVisible(HWND hwnd, HTREEITEM hti)
{
    HTREEITEM htiParent;
    htiParent = TreeView_GetParent(hwnd, hti);
    
    TV_ITEM tvi;
    tvi.mask = TVIF_STATE;
    tvi.hItem = htiParent;
    
    TreeView_GetItem(hwnd, &tvi);
    if (0 == (tvi.state & TVIS_EXPANDED))
    {
        TreeView_EnsureVisible(hwnd, hti);
    }    
}

BOOL CTreeView::IsDefaultAccount(FOLDERINFO *pInfo)
{
    IImnAccount *pAccount = NULL;
    ACCTTYPE     type = ACCT_MAIL;
    TCHAR        szDefault[CCHMAX_ACCOUNT_NAME];
    BOOL         fReturn = FALSE;
    
    // Figure out what account type to ask for
    if (pInfo->tyFolder == FOLDER_NEWS)
        type = ACCT_NEWS;
    
    // Ask the account manager to give us the account
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szDefault, ARRAYSIZE(szDefault))))
    {
        if (0 == lstrcmpi(szDefault, pInfo->pszName))
        {
            fReturn = TRUE;
        }
    }
    
    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\treeview.h ===
#ifndef __TREEVIEW_H__
#define __TREEVIEW_H__

interface INotify;
interface IAthenaBrowser;
class CFolderBar;
class CPaneFrame;

typedef struct tagFOLDERNOTIFY FOLDERNOTIFY;

#include "conman.h"
#include "ddfldbar.h"

/////////////////////////////////////////////////////////////////////////////


//
// Types 
//

interface ITreeViewNotify
{
    virtual void OnSelChange(FOLDERID idFolder) = 0;
    virtual void OnRename(FOLDERID idFolder) = 0;
    virtual void OnDoubleClick(FOLDERID idFolder) = 0;
};

// flags for CTreeView::HrInit( )
#define TREEVIEW_NOLOCAL    0x0001
#define TREEVIEW_NOIMAP     0x0002
#define TREEVIEW_NONEWS     0x0004
#define TREEVIEW_NOHTTP     0x0008
#define TREEVIEW_DIALOG     0x0010

#define TREEVIEW_FLAGS      0x00FF

// flags for CTreeView::SetSelection( )
#define TVSS_INSERTIFNOTFOUND   0x0001

#ifdef DEAD
// Flags for the collapsed unread display m_fDisplayUnread.
// By default (0x1), we expand unread in local and imap folders
#define TREEVIEW_EXPAND_UNREAD          0x00000001
#define TREEVIEW_EXPAND_IMAP            0x00000002
#define TREEVIEW_EXPAND_NEWS            0x00000004
#endif // DEAD

// Flags for CTreeView::InsertNode
#define TVIN_CHECKFORDUPS       0x00000001  // Check for duplicate entries
#define TVIN_CHECKVISIBILITY    0x00000002  // Check if folder should be displayed
#define TVIN_DONTINSERTCHILDREN 0x00000004  // When adding a node we normally add its children: this suppresses children

#define FIDF_ROOTKID    0x00000001
#define FIDF_USEDEFVIEW 0x00000002  // defview should be used for this folder
#define FIDF_SERVER     0x00000004
#define FIDF_SPECIAL    0x00000008
#define FIDF_UPDATE     0x00000010
#define FIDF_SHOWSUBSCRIBED 0x00000020  // fldr can be shown during subscribed-only (IMAP)
#define FIDF_DISCONNECTED   0x00000040

typedef struct tagFOLDERNODE {
    FOLDERINFO      Folder;
    DWORD           dwFlags;
} FOLDERNODE, *LPFOLDERNODE;

class CTreeView : public IDatabaseNotify,
                  public IInputObject,
                  public IObjectWithSite,
                  public IDropTarget,
                  public IDropSource,
                  public IDropDownFldrBar,
                  public IConnectionNotify,          //Added for Connection States
                  public IOleCommandTarget,
                  public IImnAdviseAccount
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    HWND Create(HWND hwndParent, IInputObjectSite *pSiteFrame, BOOL fFrame);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpmsg);

    // *** IDropTarget *** 
    virtual STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                                        POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                   POINTL pt, DWORD* pdwEffect);

    // *** IDropSource *** 
    virtual STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
    virtual STDMETHODIMP GiveFeedback(DWORD dwEffect);

    // *** IDatabaseNotify *** 
    virtual STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                     OLECMDTEXT *pCmdText); 
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut);    

   
#ifndef WIN16           //No RAS support in Win16
    //IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify (CONNNOTIFY nCode, LPVOID pvData, CConnectionManager  *pConMan);
#endif

    CTreeView(ITreeViewNotify *pNotify);
    ~CTreeView();

    HRESULT HrInit(DWORD dwType, IAthenaBrowser* pBrowser);
    HRESULT DeInit(void);
    void    HandleMsg(UINT msg, WPARAM wParam, LPARAM lParam);
    HRESULT Refresh(void);

    FOLDERID GetSelection(void);
    HRESULT SetSelection(FOLDERID idFolder, DWORD dwFlags);
    HRESULT SelectParent();
    HRESULT SelectNextUnreadItem();
    HRESULT ForceSelectionChange(void);

    //IDropDownFolderBar
    virtual HRESULT   RegisterFlyOut(CFolderBar *pFolderBar);
    virtual HRESULT   RevokeFlyOut();
    
    //IImnAdviseAccount
    virtual STDMETHODIMP AdviseAccount(DWORD dwType, ACTX *actx);

protected:
    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void    OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y);
    void    OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    LRESULT OnCustomDraw(NMCUSTOMDRAW *pnmcd);

    HRESULT HrFillTreeView(void);
    HRESULT FillTreeView2(HTREEITEM hparent, LPFOLDERINFO pParent, BOOL fInitExpand, int conn, BOOL *pfUnread);
    HTREEITEM GetItemFromId(FOLDERID idFolder);
    
    LPFOLDERNODE GetFolderNode(HTREEITEM hItem);
    
    HTREEITEM FindKid(HTREEITEM hitem, FOLDERID idFolder);
    HTREEITEM InsertNode(FOLDERID idFolder, DWORD dwFlags);
    HTREEITEM MoveNode(FOLDERID idFolder, FOLDERID idParentNew);
    BOOL    DeleteNode(FOLDERID idFolder);
    void    OnNotifyDeleteNode(FOLDERID idFolder);
    BOOL    FolderIsVisible(FOLDERID idFolder);
    void    SortChildren(HTREEITEM hitem);
    HTREEITEM ITreeView_InsertItem(TV_INSERTSTRUCT *ptvis, LPFOLDERNODE pNode);
    BOOL    ITreeView_SetItem(TV_ITEM *ptvi, LPFOLDERINFO pFolder);
    HRESULT SaveExpandState(HTREEITEM hitem);
    HRESULT GetConnectedState(FOLDERINFO *pFolder, int *pconn);

    // WM_NOTIFY handlers
    LRESULT OnBeginDrag(NM_TREEVIEW* pnmtv);
    LRESULT OnBeginLabelEdit(TV_DISPINFO* ptvdi);
    BOOL    OnEndLabelEdit(TV_DISPINFO* ptvdi);

    static LRESULT CALLBACK TreeViewWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    void UpdateDragDropHilite(POINTL *ppt);
    HTREEITEM GetItemFromPoint(POINTL pt);
    DWORD DragEffectFromFormat(CLIPFORMAT cf, DWORD grfKeyState);
    BOOL ValidateDropType(CLIPFORMAT cf, HTREEITEM hti);
    HRESULT PidlToGroup(HTREEITEM hti, LPTSTR *pszAccount, LPTSTR *pszGroup);
    BOOL AutoScroll(const POINT *ppt);
    void UpdateLabelColors();
    void AdjustItemHeight(void);
    void UpdateChildren(HTREEITEM treeitem, BOOL canconn, BOOL fSiblings);
    void ExpandToVisible(HWND hwnd, HTREEITEM hti);
    BOOL IsDefaultAccount(FOLDERINFO *pInfo);

protected:
    ULONG               m_cRef;
    DWORD               m_dwFlags;
    HWND                m_hwndParent;
    HWND                m_hwnd;
    HWND                m_hwndTree;
    IAthenaBrowser     *m_pBrowser;
    HWND                m_hwndUIParent;
    ITreeViewNotify    *m_pNotify;
    IDockingWindowSite *m_pObjSite;
    LONG                m_xWidth;
    BOOL                m_fShow;
    BOOL                m_fExpandUnread;
    UINT_PTR            m_idSelTimer;
    IDataObject        *m_pDataObject;          // Pointer to the IDataObject being dragged over us
    IDropTarget        *m_pDTCur;
    HTREEITEM           m_htiCur;
    DWORD               m_dwExpandTime; 
    DWORD               m_dwEffectCur;
    DWORD               m_grfKeyState;

    HTREEITEM           m_htiMenu;
    BOOL                m_fEditLabel;
    HTREEITEM           m_hitemEdit;
    BOOL                m_fIgnoreNotify;

    CFolderBar         *m_pFolderBar;
    DWORD               m_dwAcctConnIndex;

    CPaneFrame         *m_pPaneFrame;
    HWND                m_hwndPaneFrame;
    DWORD               m_clrWatched;

};

#define TVM_SELCHANGED  (WM_USER + 6)
#define TVM_DBLCLICK    (WM_USER + 7)

class CTreeViewFrame :
    public IInputObjectSite,
    public IOleWindow,
    public ITreeViewNotify
{
public:
    CTreeViewFrame(void);
    ~CTreeViewFrame(void);
    
    HRESULT Initialize(HWND hwnd, RECT *prc, DWORD dwFlags);
    inline CTreeView *GetTreeView(void)     {return(m_ptv);}
    void CloseTreeView(void);

    // IUnknown 
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);                         
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);            
    
    //IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // ITreeViewNotify
    void OnSelChange(FOLDERID idFolder);
    void OnRename(FOLDERID idFolder);
    void OnDoubleClick(FOLDERID idFolder);

private:
    UINT            m_cRef;
    HWND            m_hwnd;
    RECT            m_rect;
    CTreeView       *m_ptv;
};

#endif // __TREEVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\urltest.h ===
#define idcURL                    1001
#define idcURLReturn              1002
#define idcURLServer              1003
#define idcURLPort                1004
#define idcURLGroup               1005
#define idcURLArticle             1006
#define idcURLTest                1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\useragnt.cpp ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by Outlook Express
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#include "pch.hxx"

#include <iert.h>
#include "useragnt.h"
#include "demand.h"

static LPSTR        g_pszOEUserAgent = NULL;
CRITICAL_SECTION    g_csOEUserAgent = {0};
BOOL                g_fUserAgentInit = FALSE;


//----------------------------------------------------------------------
// InitOEUserAgent
//
// Initialize or tear down OE's user agent support.
//----------------------------------------------------------------------
void InitOEUserAgent(BOOL fInit)
{
    if (fInit && !g_fUserAgentInit)
    {
        InitializeCriticalSection(&g_csOEUserAgent);
        g_fUserAgentInit = TRUE;
    }
    else if (g_fUserAgentInit)
    {
        SafeMemFree(g_pszOEUserAgent);
        DeleteCriticalSection(&g_csOEUserAgent);

        g_fUserAgentInit = FALSE;
    }
}

//----------------------------------------------------------------------
// GetOEUserAgentString
//
// Returns the Outlook Express user agent string. The caller MUST
// delete the string that is returned.
//----------------------------------------------------------------------
LPSTR GetOEUserAgentString(void)
{
    LPSTR pszReturn = NULL;

    Assert(g_fUserAgentInit);

    // thread safety
    EnterCriticalSection(&g_csOEUserAgent);

    if (NULL == g_pszOEUserAgent)
    {
        TCHAR            szUrlMonUA[4048];
        DWORD           cbSize = ARRAYSIZE(szUrlMonUA) - 1;
        CByteStream     bs;
        TCHAR           *pch, *pchBeginTok;
        BOOL            fTokens = FALSE;
        HRESULT         hr = S_OK;
		TCHAR			szUserAgent[MAX_PATH];
		ULONG			cchMax = MAX_PATH;
		DWORD			type;

		if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat,
                                    c_szAgent,
                                    &type, (LPBYTE)szUserAgent, &cchMax) || cchMax == 0)
			lstrcpy(szUserAgent, c_szOEUserAgent);

        IF_FAILEXIT(hr = bs.Write(szUserAgent, lstrlen(szUserAgent), NULL));
        
        // allow urlmon to generate our base user agent
        if (SUCCEEDED(ObtainUserAgentString(0, szUrlMonUA, &cbSize)))
        {
            // make sure the string we obtained is null terminated
            szUrlMonUA[cbSize] = '\0';

            // find the open beginning of the token list
            pch = StrChr(szUrlMonUA, '(');
            if (NULL != pch)
            {
                pch++;
                pchBeginTok = pch;
                while (pch)
                {
                    // find the next token
                    pch = StrTokEx(&pchBeginTok, "(;)");
                    if (pch)
                    {
                        // skip past white space
                        pch = PszSkipWhiteA(pch);

                        // omit the "compatible" token...it doesn't apply to oe
                        if (0 != lstrcmpi(pch, c_szCompatible))
                        {
                            // begin the token list with an open paren, or insert a delimeter
                            if (!fTokens)
                            {
                                fTokens = TRUE;
                            }
                            else
                                IF_FAILEXIT(hr = bs.Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));

                            // write the token
                            IF_FAILEXIT(hr = bs.Write(pch, lstrlen(pch), NULL));
                        }
                    }
                }
            }
        }

        // if one or more tokens were added, add a semicolon before adding the end tokens
        if (fTokens)
            IF_FAILEXIT(hr = bs.Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));

        IF_FAILEXIT(hr = bs.Write(c_szEndUATokens, lstrlen(c_szEndUATokens), NULL));

        // adopt the string from the stream
        IF_FAILEXIT(hr = bs.HrAcquireStringA(NULL, &g_pszOEUserAgent, ACQ_DISPLACE));
    }
    
    // duplicate the user agent
    pszReturn = PszDupA(g_pszOEUserAgent);

exit:
    // thread safety
    LeaveCriticalSection(&g_csOEUserAgent);
    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\url.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Url.h
//
//  PURPOSE:    Prototypes and defines exported from the url parsing code.
//

#ifndef _URL_H
#define _URL_H

HRESULT URL_ParseNewsUrls(LPTSTR pszURL, LPTSTR* ppszServer, LPUINT puPort, 
                          LPTSTR* ppszGroup, LPTSTR* ppszArticle, LPBOOL pfSecure);
HRESULT URL_ParseMailTo(LPTSTR pszURL, LPMIMEMESSAGE pMsg);

HRESULT URL_ParseNEWS(LPTSTR pszURL, LPTSTR* ppszServer, LPTSTR* ppszGroup, 
                      LPTSTR* ppszArticle);
HRESULT URL_ParseNNTP(LPTSTR pszURL, LPTSTR* ppszServer, LPUINT puPort, 
                      LPTSTR* ppszGroup, LPTSTR* ppszArticle);

// values for dwSubstitutions in the URLSub functions below
#define URLSUB_CLCID    0x00000001
#define URLSUB_PRD      0x00000002
#define URLSUB_PVER     0x00000004
#define URLSUB_NAME     0x00000008
#define URLSUB_EMAIL    0x00000010

#define URLSUB_ALL      0x0000001F

HRESULT URLSubstitutionA(LPCSTR pszUrlIn, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions, IImnAccount *pCertAccount);
HRESULT URLSubLoadStringA(UINT idRes, LPSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions, IImnAccount *pCertAccount);

HRESULT HrCreateBasedWebPage(LPWSTR pwszUrl, LPSTREAM *ppstmHtml);


#endif //_URL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\useragnt.h ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by Outlook Express
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#ifndef _USERAGNT_H
#define _USERAGNT_H

void InitOEUserAgent(BOOL fInit);

LPSTR GetOEUserAgentString(void);

#endif // _USERAGNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\url.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     URL.cpp
//
//  PURPOSE:    All the URL parsing routines THOR would ever need.
//


#include "pch.hxx"
#include "strconst.h"
#include "urltest.h"
#include "url.h"
#include "xpcomm.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "mimeole.h"
#include <urlmon.h>
#include <wininet.h>
#include "imnact.h"
#include "demand.h"
#include <mlang.h>

//
//  FUNCTION:   URL_ParseNewsUrls
//
//  PURPOSE:    Takes a URL passed to the news view and validates it.  If the 
//              URL is valid, then the server, group, and article-id are
//              returned as appropriate.
//
//  PARAMETERS:
//      pszURL      - Pointer to the URL to parse.
//      ppszServer  - Name of the server, this function allocates the memory.
//      puPort      - Port number on the server to use.
//      ppszGroup   - Name of the group, this function allocates the memory.
//      ppszArticle - Article id, this function allocates the memory.
//      pfSecure    - whether to use SSL to connect
//
//  RETURN VALUE:
//      Returns S_OK if the URL is valid, or an appropriate error code 
//      otherwise.
//
//  COMMENTS:
//      The URLs that are valid for news are:
//
//                  news:<newsgroup-name>
//                  news:<article-id>
//                  news://<server>     (for Netscape compatibility)
//                  news://<server>/    (for URL.DLL compatibility)
//                  news://<server>/<newsgroup-name>
//                  news://<server>/<article-id>
//                  nntp://<host>:<port>/<newsgroup-name>/<article-id>
//
// $LOCALIZE - Need a separate code path for DBCS
HRESULT URL_ParseNewsUrls(LPTSTR pszURL, LPTSTR* ppszServer, LPUINT puPort, 
                          LPTSTR* ppszGroup, LPTSTR* ppszArticle, LPBOOL pfSecure)
{
    HRESULT     hr;
    UINT        cchBuffer ;
    LPTSTR      pszBuffer,
                pszTemp;

    Assert(pszURL != NULL);
    
    // Allocate a temp buffer to work with.
    cchBuffer = lstrlen(pszURL) + sizeof(TCHAR);
    
    if (!MemAlloc((LPVOID*)&pszBuffer, cchBuffer))
        return E_OUTOFMEMORY;
     
    ZeroMemory(pszBuffer, cchBuffer);
    
    // Loop through the URL looking for the first ":".  We're trying to discern
    // what the prefix is - either "nntp" or "news".
    pszTemp = pszURL;
    
    while (*pszTemp && *pszTemp != TEXT(':'))
        pszTemp++;
    
    CopyMemory(pszBuffer, pszURL, ((LPBYTE) pszTemp - (LPBYTE) pszURL));
    
    *ppszServer = NULL;
    *ppszGroup = NULL;
    *ppszArticle = NULL;
    *puPort = (UINT) -1;
    *pfSecure = FALSE;
    
    if (0 == lstrcmpi(pszBuffer, c_szURLNews))
    {
        // The URL starts with "news:", so advance the pointer past the ":"
        // and pass what's left to the appropriate parser.
        pszTemp++;
        hr = URL_ParseNEWS(pszTemp, ppszServer, ppszGroup, ppszArticle);
    }
    else if (0 == lstrcmpi(pszBuffer, c_szURLNNTP))
    {
        // The URL starts with "nntp:", so advance the pointer past the ":"
        // and pass what's left to the appropriate parser.
        pszTemp++;
        hr = URL_ParseNNTP(pszTemp, ppszServer, puPort, ppszGroup, ppszArticle);
    }
    else if (0 == lstrcmpi(pszBuffer, c_szURLSnews))
    {
        // The URL starts with "snews:", so advance the pointer past the ":"
        // and pass what's left to the appropriate parser.
        pszTemp++;
        *pfSecure = TRUE;
        hr = URL_ParseNEWS(pszTemp, ppszServer, ppszGroup, ppszArticle);
    }
    else
    {
        // this protocol is not a supported NEWS protocol
        hr = INET_E_UNKNOWN_PROTOCOL;
    }
    
    MemFree(pszBuffer);
    return hr;
}

// $LOCALIZE - Need a separate code path for DBCS
HRESULT URL_ParseNEWS(LPTSTR pszURL, LPTSTR* ppszServer, LPTSTR* ppszGroup, 
                      LPTSTR* ppszArticle)
{
    LPTSTR pszBuffer;
    LPTSTR pszBegin;
    UINT   cch = 0;
    
    if (pszURL == NULL || *pszURL == '\0')
        return INET_E_INVALID_URL;

    // First check to see if a server has been specified.  If so, then the
    // first two characters will be "//".
    if (*pszURL == TEXT('/'))
    {
        // Make sure there are two '/'
        pszURL++;
        if (*pszURL != TEXT('/'))
            return INET_E_INVALID_URL;   
        
        pszURL++;
        pszBegin = pszURL;
        
        // Ok, got a server name.  Find the end and copy it to ppszServer.    
        while (*pszURL && (*pszURL != TEXT('/')))
            pszURL++;
        
        cch = (UINT) ((LPBYTE) pszURL - (LPBYTE) pszBegin) + sizeof(TCHAR);
        if (cch <= 1)
            return S_OK; // bug 12467
        
        if (!MemAlloc((LPVOID*) ppszServer, cch))
            return E_OUTOFMEMORY;
        
        ZeroMemory(*ppszServer, cch);
        CopyMemory(*ppszServer, pszBegin, cch - sizeof(TCHAR));
        
        // if we found the last '/' skip over it
        if (*pszURL)
            pszURL++;
        
        //
        //  NOTE: This code makes the following URLs valid, taking us to the
        //       root node for the server.
        //
        //      news://<server>
        //      news://<server>/
        //
        //  The first form is necessary for compatibility with Netscape, and
        //  the second form is necessary because URL.DLL adds the trailing
        //  slash before passing the first form to us.
        //
        
        // If we're at the end, fake a news://server/* URL.
        if (!*pszURL)
            pszURL = (LPTSTR)g_szAsterisk;
    }
    
    // The difference between a group and article string is that the article
    // must have "@" in it somewhere.
    if (!lstrlen(pszURL))
    {
        if (*ppszServer)
        {
            MemFree(*ppszServer);
            *ppszServer = 0;
        }
        return INET_E_INVALID_URL;
    }
    
    if (!MemAlloc((LPVOID*) &pszBuffer, lstrlen(pszURL) + sizeof(TCHAR)))
    {
        if (*ppszServer)
        {
            MemFree(*ppszServer);
            *ppszServer = 0;
        }
        return INET_E_INVALID_URL;
    }
    lstrcpy(pszBuffer, pszURL);
    
    while (*pszURL && *pszURL != TEXT('@'))
        pszURL++;              
    
    if (*pszURL == TEXT('@'))
    {
        // This is an article
        *ppszGroup = NULL;
        *ppszArticle = pszBuffer;
    }
    else
    {
        *ppszGroup = pszBuffer;
        *ppszArticle = NULL;
    }
    
    return S_OK;
}


// $LOCALIZE - Need a separate code path for DBCS
// Validates a URL of the form NNTP://<host>:<port>/<newsgroup-name>/<message-id>
HRESULT URL_ParseNNTP(LPTSTR pszURL, LPTSTR* ppszServer, LPUINT puPort, 
                      LPTSTR* ppszGroup, LPTSTR* ppszArticle)
{
    LPTSTR pszTemp;
    UINT cch;
    HRESULT hrReturn = S_OK;
    
    Assert(pszURL != NULL);
    
    if (pszURL == NULL || *pszURL == '\0')
        return INET_E_INVALID_URL;
    
    // Make sure there are leading "//"
    if (*pszURL != TEXT('/'))
        return INET_E_INVALID_URL;
    
    pszURL++;
    if (*pszURL != TEXT('/'))
        return INET_E_INVALID_URL;
    
    pszURL++;
    pszTemp = pszURL;
    
    // Search for the host name.
    while (*pszTemp && (*pszTemp != TEXT('/')) && (*pszTemp != TEXT(':')))
        pszTemp++;
    
    if (*pszTemp != TEXT('/') && *pszTemp != TEXT(':'))
        return INET_E_INVALID_URL;
    
    // Copy the host name to the server return value
    cch = (UINT) ((LPBYTE) pszTemp - (LPBYTE) pszURL) + sizeof(TCHAR);
    if (cch <= 1)
        return INET_E_INVALID_URL;
    
    if (!MemAlloc((LPVOID*) ppszServer, cch))
        return E_OUTOFMEMORY;
    
    ZeroMemory(*ppszServer, cch);
    CopyMemory(*ppszServer, pszURL, (LPBYTE) pszTemp - (LPBYTE) pszURL);
    
    if (*pszTemp == TEXT(':'))
    {
        // The URL specified a port, so parse that puppy out.
        pszTemp++;
        pszURL = pszTemp;
        
        while (*pszTemp && (*pszTemp != TEXT('/')))
            pszTemp++;
        
        cch = (UINT) ((LPBYTE) pszTemp - (LPBYTE) pszURL);
        if (cch <= 1)
        {
            hrReturn = INET_E_INVALID_URL;
            goto error;
        }
        
        *puPort = StrToInt(pszURL);
    }
    
    if (*pszTemp != TEXT('/'))
    {
        hrReturn = INET_E_INVALID_URL;
        goto error;
    }
    
    // Get the newsgroup name
    pszTemp++;  // Pass the '/'
    pszURL = pszTemp;
    
    while (*pszTemp && (*pszTemp != TEXT('/')))
        pszTemp++;
    
    if (*pszTemp != TEXT('/'))
    {
        hrReturn = INET_E_INVALID_URL;
        goto error;
    }
    
    // Copy the group name to the group return value
    cch = (UINT) ((LPBYTE) pszTemp - (LPBYTE) pszURL) + sizeof(TCHAR);
    if (cch <= 0)
    {
        hrReturn = INET_E_INVALID_URL;
        goto error;
    }
    
    if (!MemAlloc((LPVOID*) ppszGroup, cch))
        return (E_OUTOFMEMORY);
    
    ZeroMemory(*ppszGroup, cch);
    CopyMemory(*ppszGroup, pszURL, (LPBYTE) pszTemp - (LPBYTE) pszURL);
    
    // Now copy from here to the end of the string as the article id
    pszTemp++;
    cch = lstrlen(pszTemp) + sizeof(TCHAR);
    if (cch <= 0)
    {
        hrReturn = INET_E_INVALID_URL;
        goto error;
    }
    
    if (!MemAlloc((LPVOID*) ppszArticle, cch))
        return (E_OUTOFMEMORY);
    
    lstrcpy(*ppszArticle, pszTemp);
    
    return (S_OK);
    
error:
    if (*ppszServer)
        MemFree(*ppszServer);
    if (*ppszGroup)
        MemFree(*ppszGroup);
    if (*ppszArticle)
        MemFree(*ppszArticle);
    
    *ppszServer = NULL;
    *ppszGroup = NULL;
    *ppszArticle = NULL;
    *puPort = (UINT) -1;
    
    return (hrReturn);
    }


static const TCHAR c_szColon[]      = ":";
static const TCHAR c_szQuestion[]   = "?";
static const TCHAR c_szEquals[]     = "=";
static const TCHAR c_szAmpersand[]  = "&";
static const TCHAR c_szBody[]       = "body";
static const TCHAR c_szBcc[]        = "bcc";

//
//  FUNCTION:   URL_ParseMailTo()
//
//  PURPOSE:    This function takes a mailto: URL and determines if it is a valid
//              URL for mail.  The function then fill in a pMsg from the URL
//
//  PARAMETERS:
//      pszURL      - The URL to parse.
//      pMsg        - The LPMIMEMESSAGE to fill in from the URL.
//
//  RETURN VALUE:
//      Returns S_OK if the URL is a valid mail URL and the message is filled,
//      or an appropriate HRESULT describing why the function failed.
//
//  COMMENTS:
//      Right now the only valid URL is 
//              mailto:<SMTP address>
//
HRESULT URL_ParseMailTo(LPTSTR pszURL, LPMIMEMESSAGE pMsg)
{
    CStringParser   sp;
    HRESULT hr;
    HADDRESS hAddress;
    LPMIMEADDRESSTABLE pAddrTable = 0;
    
    sp.Init(pszURL, lstrlen(pszURL), 0);
    if (sp.ChParse(c_szColon))
    {
        // verify that this is a "mailto:" URL
        if (lstrcmpi(sp.PszValue(), c_szURLMailTo))
            return INET_E_UNKNOWN_PROTOCOL;
        
        hr = pMsg->GetAddressTable(&pAddrTable);
        if (FAILED(hr))
            return(hr);
        
        Assert(pAddrTable != NULL);
        
        sp.ChParse(c_szQuestion);
        if (sp.CchValue())
        {
            // opie says it's cool that I'm about to clobber his buffer
            UrlUnescapeInPlace((LPTSTR)sp.PszValue(), 0);
            pAddrTable->Append(IAT_TO, IET_DECODED, sp.PszValue(), NULL, &hAddress);
        }
        while (sp.ChParse(c_szEquals))
        {
            LPTSTR pszAttr = StringDup(sp.PszValue());
            if (pszAttr)
            {
                sp.ChParse(c_szAmpersand);
                if (sp.CchValue())
                {
                    UrlUnescapeInPlace((LPTSTR)sp.PszValue(), 0);
                    // are we trying to set the body?
                    if (!lstrcmpi(c_szBody, pszAttr))
                    {
                        LPSTREAM pStream;
                        if (SUCCEEDED(MimeOleCreateVirtualStream(&pStream)))
                        {
                            if (SUCCEEDED(pStream->Write(sp.PszValue(), lstrlen(sp.PszValue()) * sizeof(TCHAR), NULL)))
                            {
                                pMsg->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, pStream, NULL);
                            }
                            pStream->Release();
                        }
                    }
                    else if (0 == lstrcmpi(c_szCC, pszAttr))
                    {
                        pAddrTable->Append(IAT_CC, IET_DECODED, sp.PszValue(), NULL, &hAddress);
                    }
                    else if (0 == lstrcmpi(c_szBcc, pszAttr))
                    {
                        pAddrTable->Append(IAT_BCC, IET_DECODED, sp.PszValue(), NULL, &hAddress);
                    }
                    else if (0 == lstrcmpi(c_szTo, pszAttr))
                    {
                        pAddrTable->Append(IAT_TO, IET_DECODED, sp.PszValue(), NULL, &hAddress);
                    }
                    else
                    {
                        // just stuff the prop into the message
                        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, pszAttr, NOFLAGS, sp.PszValue());
                    }
                }
                MemFree(pszAttr);
            }
        }
        
        pAddrTable->Release();
    }
    return S_OK;
}

#define MAX_SUBSTR_SIZE     CCHMAX_DISPLAY_NAME

typedef struct tagURLSub
{
    LPCTSTR szTag;
    DWORD dwType;
} URLSUB;

const static URLSUB c_UrlSub[] = {
    {TEXT("{SUB_CLCID}"),   URLSUB_CLCID},
    {TEXT("{SUB_PRD}"),     URLSUB_PRD},
    {TEXT("{SUB_PVER}"),    URLSUB_PVER},
    {TEXT("{SUB_NAME}"),    URLSUB_NAME},
    {TEXT("{SUB_EMAIL}"),   URLSUB_EMAIL},
};

HRESULT URLSubstitutionA(LPCSTR pszUrlIn, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions, IImnAccount *pCertAccount)
{
    HRESULT hr = S_OK;
    DWORD   dwIndex;
    CHAR    szTempUrl[INTERNET_MAX_URL_LENGTH];

    Assert(cchSize <= ARRAYSIZE(szTempUrl));    // We will truncate anything longer than INTERNET_MAX_URL_LENGTH

    StrCpyN(szTempUrl, pszUrlIn, ARRAYSIZE(szTempUrl));

    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_UrlSub); dwIndex++)
        {
        while (dwSubstitutions & c_UrlSub[dwIndex].dwType)
            {
            LPSTR pszTag = StrStrA(szTempUrl, c_UrlSub[dwIndex].szTag);

            if (pszTag)
                {
                TCHAR szCopyUrl[INTERNET_MAX_URL_LENGTH];
                TCHAR szSubStr[MAX_SUBSTR_SIZE];  // The Substitution 

                // Copy URL Before Substitution.
                CopyMemory(szCopyUrl, szTempUrl, (pszTag - szTempUrl));
                szCopyUrl[(pszTag - szTempUrl)/sizeof(CHAR)] = TEXT('\0');
                pszTag += lstrlen(c_UrlSub[dwIndex].szTag);

                switch (c_UrlSub[dwIndex].dwType)
                    {
                    case URLSUB_CLCID:
                        {
                        LCID lcid = GetUserDefaultLCID();
                        wsprintf(szSubStr, "%#04lx", lcid);
                        }
                        break;
                    case URLSUB_PRD:
                        lstrcpy(szSubStr, c_szUrlSubPRD);
                        break;
                    case URLSUB_PVER:
                        lstrcpy(szSubStr, c_szUrlSubPVER);
                        break;
                    case URLSUB_NAME:
                    case URLSUB_EMAIL:
                        {
                        IImnAccount *pAccount = NULL;

                        hr = E_FAIL;
                        if(pCertAccount)
                        {
                            hr = pCertAccount->GetPropSz((c_UrlSub[dwIndex].dwType == URLSUB_NAME) ? AP_SMTP_DISPLAY_NAME : AP_SMTP_EMAIL_ADDRESS,
                                        szSubStr,
                                        ARRAYSIZE(szSubStr));

                        }
                        else if (g_pAcctMan && SUCCEEDED(g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)))
                        {
                            hr = pAccount->GetPropSz((c_UrlSub[dwIndex].dwType == URLSUB_NAME) ? AP_SMTP_DISPLAY_NAME : AP_SMTP_EMAIL_ADDRESS,
                                                     szSubStr,
                                                     ARRAYSIZE(szSubStr));
                            pAccount->Release();
                        }

                        if (FAILED(hr))
                            return hr;
                        }
                        break;
                    default:
                        szSubStr[0] = TEXT('\0');
                        Assert(FALSE);  // Not Impl.
                        hr = E_NOTIMPL;
                        break;
                    }
                // Add the Substitution String to the end (will become the middle)
                StrCatN(szCopyUrl, szSubStr, ARRAYSIZE(szCopyUrl) - lstrlen(szCopyUrl));
                // Add the rest of the URL after the substitution substring.
                StrCatN(szCopyUrl, pszTag, ARRAYSIZE(szCopyUrl) - lstrlen(szCopyUrl));
                StrCpyN(szTempUrl, szCopyUrl, ARRAYSIZE(szTempUrl));
                }
            else
                break;  // This will allow us to replace all the occurances of this string.
            }
        }
    StrCpyN(pszUrlOut, szTempUrl, cchSize);

    return hr;
}


HRESULT URLSubLoadStringA(UINT idRes, LPSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions, IImnAccount *pCertAccount)
{
    HRESULT hr = E_FAIL;
    CHAR    szTempUrl[INTERNET_MAX_URL_LENGTH];

    if (LoadStringA(g_hLocRes, idRes, szTempUrl, ARRAYSIZE(szTempUrl)))
        hr = URLSubstitutionA(szTempUrl, pszUrlOut, cchSizeOut, dwSubstitutions, pCertAccount);

    return hr;
}

HRESULT HrConvertStringToUnicode(UINT uiSrcCodePage, CHAR *pSrcStr, UINT cSrcSize, WCHAR *pDstStr, UINT cDstSize)
{
    IMultiLanguage          *pMLang = NULL;
    IMLangConvertCharset    *pMLangConv = NULL;
    HRESULT                  hr = E_FAIL;

    IF_FAILEXIT(hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&pMLang));
    IF_FAILEXIT(hr = pMLang->CreateConvertCharset(uiSrcCodePage, 1200, NULL, &pMLangConv));

    hr = pMLangConv->DoConversionToUnicode(pSrcStr, &cSrcSize, pDstStr, &cDstSize);

exit:
    ReleaseObj(pMLangConv);
    ReleaseObj(pMLang);
    return hr;
}

static const char c_szBaseFmt[]="<BASE HREF=\"%s\">\n\r";
static const char c_szBaseFileFmt[]="<BASE HREF=\"file://%s\\\">\n\r";
static const WCHAR c_wszBaseFmt[]=L"<BASE HREF=\"%s\">\n\r";
static const WCHAR c_wszBaseFileFmt[]=L"<BASE HREF=\"file://%s\\\">\n\r";
HRESULT HrCreateBasedWebPage(LPWSTR pwszUrl, LPSTREAM *ppstmHtml)
{
    HRESULT     hr;
    LPSTREAM    pstm = NULL,
                pstmCopy = NULL,
                pstmTemp = NULL;
    CHAR        szBase[MAX_PATH+50],
                szCopy[MAX_PATH];
    WCHAR       wszBase[MAX_PATH+50],
                wszCopy[MAX_PATH];
    ULONG       cb,
                cbTemp;
    BOOL        fLittleEndian;
    LPSTR       pszUrl = NULL,
                pszStream = NULL,
                pszCharset = NULL;
    LPWSTR      pwszStream = NULL,
                pwszTempUrl = NULL;
    BOOL        fIsURL = PathIsURLW(pwszUrl),
                fForceUnicode,
                fIsUnicode;


    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstmCopy));

    // Are we a file or a URL?
    if(fIsURL)
    {
        // Since we have a url, then must be ansi
        IF_NULLEXIT(pszUrl = PszToANSI(CP_ACP, pwszUrl));

        // we can not write to this pstm, so we have pstmCopy.
        IF_FAILEXIT(hr = URLOpenBlockingStream(NULL, pszUrl, &pstm, 0, NULL));
        if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
        {
            BYTE rgb[2];

            IF_FAILEXIT(hr = pstm->Read(rgb, 2, &cb));
            Assert(2 == cb);

            IF_FAILEXIT(hr = pstmCopy->Write(rgb, 2, NULL));

            AthwsprintfW((LPWSTR)wszBase, ARRAYSIZE(wszBase), c_wszBaseFmt, pwszUrl);

            IF_FAILEXIT(hr = pstmCopy->Write(wszBase, lstrlenW(wszBase) * sizeof(WCHAR), NULL));
        }

        else
        {
            wsprintf(szBase, c_szBaseFmt, pszUrl);

            IF_FAILEXIT(hr = pstmCopy->Write(szBase, lstrlen(szBase), NULL));
        }
    }
    else
    {
        // If filename can't be converted to ansi, then we must do this in UNICODE
        // even if the stationery itself is normally ansi.
        IF_NULLEXIT(pszUrl = PszToANSI(CP_ACP, pwszUrl));
        IF_NULLEXIT(pwszTempUrl = PszToUnicode(CP_ACP, pszUrl));
        fForceUnicode = (0 != StrCmpW(pwszUrl, pwszTempUrl));

        IF_FAILEXIT(hr = CreateStreamOnHFileW(pwszUrl, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pstm));

        fIsUnicode = (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian));

        if (fForceUnicode || fIsUnicode)
        {
            BYTE bUniMark = 0xFF;
            IF_FAILEXIT(hr = pstmCopy->Write(&bUniMark, sizeof(bUniMark), NULL));

            bUniMark = 0xFE;
            IF_FAILEXIT(hr = pstmCopy->Write(&bUniMark, sizeof(bUniMark), NULL));

            StrCpyW(wszCopy, pwszUrl);
            PathRemoveFileSpecW(wszCopy);
            AthwsprintfW((LPWSTR)wszBase, ARRAYSIZE(wszBase), c_wszBaseFileFmt, wszCopy);

            IF_FAILEXIT(hr = pstmCopy->Write(wszBase, lstrlenW(wszBase) * sizeof(WCHAR), NULL));
        }
        else
        {
            StrCpy(szCopy, pszUrl);
            PathRemoveFileSpec(szCopy);
            wsprintf((LPSTR)szBase, c_szBaseFileFmt, szCopy);

            IF_FAILEXIT(hr = pstmCopy->Write(szBase, lstrlen(szBase), NULL));
        }

        if (fIsUnicode)
        {
            WCHAR bom;

            IF_FAILEXIT(hr = pstm->Read(&bom, 2, &cb));
            Assert(2 == cb);
        }
        // This is an ANSI stream that we are forcing into UNICODE
        // This area will only occur if we are streaming a file
        else if (fForceUnicode)
        {
            LARGE_INTEGER pos = {0};            
            UINT          uiHtmlCodepage = 0;

            Assert(!fIsURL);
            // In order for the file name to write to the stream properly, we
            // must convert the stream to unicode before we copy.

            // Get the charset
            GetHtmlCharset(pstm, &pszCharset);
            if(pszCharset)
            {
                INETCSETINFO    CSetInfo = {0};
                HCHARSET        hCharset = NULL;

                if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
                {
                    if(SUCCEEDED(MimeOleGetCharsetInfo(hCharset,&CSetInfo)))
                        uiHtmlCodepage = CSetInfo.cpiInternet;                    
                }          
            }
            
            IF_FAILEXIT(hr = HrRewindStream(pstm));             

            // Allocate enough to read ANSI
            IF_FAILEXIT(hr = HrSafeGetStreamSize(pstm, &cb)); 
            IF_NULLEXIT(MemAlloc((LPVOID*)&pszStream, cb+1));

            // Read in ANSI
            IF_FAILEXIT(hr = pstm->Read(pszStream, cb, &cbTemp)); 
            Assert(cbTemp == cb);
            pszStream[cb] = 0;

            // Alloc enough for the unicode conversion. Assume that each
            // ANSI char will be one unicode char
            IF_NULLEXIT(MemAlloc((LPVOID*)&pwszStream, (cb+1)*sizeof(WCHAR)));

            //Convert including null, if the fancy call fails, we should at least continue
            //with the old dumb way.            
            if(!uiHtmlCodepage || FAILED(HrConvertStringToUnicode(uiHtmlCodepage, pszStream, cb+1, pwszStream, cb+1)))
                MultiByteToWideChar(CP_ACP, 0, pszStream, cb+1, pwszStream, cb+1);

            // Create a new stream
            IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstmTemp));
            IF_FAILEXIT(hr = pstmTemp->Write(pwszStream, lstrlenW(pwszStream)*sizeof(WCHAR), &cb));
            IF_FAILEXIT(hr = HrRewindStream(pstmTemp));
            ReplaceInterface(pstm, pstmTemp);
        }
    }

    IF_FAILEXIT(hr = HrCopyStream(pstm, pstmCopy, &cb));
    IF_FAILEXIT(hr = HrRewindStream(pstmCopy));

    *ppstmHtml=pstmCopy;
    pstmCopy->AddRef();

exit:
    ReleaseObj(pstm);
    ReleaseObj(pstmTemp);
    ReleaseObj(pstmCopy);
    MemFree(pszUrl);
    MemFree(pszStream);
    MemFree(pwszStream);
    MemFree(pwszTempUrl);
    MemFree(pszCharset);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\xpcomm.h ===
// =================================================================================
// Common IMailXP macros and stuff
// Written by: Steven J. Bailey on 1/21/96
// =================================================================================
#ifndef __XPCOMM_H
#define __XPCOMM_H

// ------------------------------------------------------------------------------------
// INETMAILERROR
// ------------------------------------------------------------------------------------
typedef struct tagINETMAILERROR {
    DWORD               dwErrorNumber;                  // Error Number
    HRESULT             hrError;                        // HRESULT of error
    LPTSTR              pszServer;                      // Server
    LPTSTR              pszAccount;                     // Account
    LPTSTR              pszMessage;                     // Actual error message
    LPTSTR              pszUserName;                    // User Name
    LPTSTR              pszProtocol;                    // protocol smtp or pop3
    LPTSTR              pszDetails;                     // Details message
    DWORD               dwPort;                         // Port
    BOOL                fSecure;                        // Secure ssl conneciton
} INETMAILERROR, *LPINETMAILERROR;

BOOL CALLBACK InetMailErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// =================================================================================
// Defines
// =================================================================================
#define SECONDS_INA_MINUTE              (ULONG)60           // Easy
#define SECONDS_INA_HOUR                (ULONG)3600         // 60 * 60
#define SECONDS_INA_DAY                 (ULONG)86400        // 3600 * 24

#define IS_EXTENDED(ch)                 ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r')

// ============================================================================================
// Returns 0 if string is NULL, lstrlen + 1 otherwise
// ============================================================================================
#define SafeStrlen(_psz) (_psz ? lstrlen (_psz) + 1 : 0)

// =================================================================================
// CProgress
// =================================================================================
class CProgress : public IDatabaseProgress, public IStoreCallback
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CProgress(void);
    ~CProgress(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return E_NOTIMPL; }
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreCallback Members
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
    { 
        if (0 == m_cMax)
            AdjustMax(dwMax);
        ULONG cIncrement = (dwCurrent - m_cLast);
        HRESULT hr = HrUpdate(cIncrement);
        m_cLast = dwCurrent;
        return(hr);
    }

    //----------------------------------------------------------------------
    // IDatabaseProgress Members
    //----------------------------------------------------------------------
    STDMETHODIMP Update(DWORD cCount) { return HrUpdate(1); }

    //----------------------------------------------------------------------
    // CProgress Members
    //----------------------------------------------------------------------
    void        SetMsg(LPTSTR lpszMsg);
    void        SetTitle(LPTSTR lpszTitle);
    void        Show(DWORD dwDelaySeconds=0);
    void        Hide(void);
    void        Close(void);
    void        AdjustMax(ULONG cNewMax);
    void        Reset(void);
    HWND        GetHwnd(void) { return (m_hwndDlg); }
    HRESULT     HrUpdate (ULONG cInc);
    static BOOL CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void        Init(HWND hwndParent, LPTSTR lpszTitle, LPTSTR lpszMsg, ULONG cMax,  UINT idani, BOOL fCanCancel, BOOL fBacktrackParent=TRUE);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    ULONG       m_cRef;
    ULONG       m_cLast;
    ULONG       m_cMax;
    ULONG       m_cCur;
    ULONG       m_cPerCur;
    HWND        m_hwndProgress;
    HWND        m_hwndDlg;
    HWND        m_hwndOwner;
    HWND        m_hwndDisable;
    BOOL        m_fCanCancel;
    BOOL        m_fHasCancel;
};

// =================================================================================
// Max Message String
// =================================================================================
#define MAX_MESSAGE_STRING              255
#define MAX_RESOURCE_STRING             255    
#define MAX_REG_VALUE_STR               1024
#define MAX_TEXT_STM_BUFFER_STR         4096

// =================================================================================
// Detailed Error Struct
// =================================================================================
typedef struct tagDETERR {
    LPTSTR          lpszMessage;
    LPTSTR          lpszDetails;
    UINT            idsTitle;
    RECT            rc;
    BOOL            fHideDetails;
} DETERR, *LPDETERR;

// Blob parsing
HRESULT HrBlobReadData (LPBYTE lpBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData);
HRESULT HrBlobWriteData (LPBYTE lpBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData);

// String Parsing Functions
VOID StripSpaces(LPTSTR psz);
LPTSTR SzGetSearchTokens(LPTSTR pszCriteria);;
HRESULT HrCopyAlloc (LPBYTE *lppbDest, LPBYTE lpbSrc, ULONG cb);
LPTSTR StringDup (LPCTSTR lpcsz);
BOOL FIsStringEmpty (LPTSTR lpszString);
BOOL FIsStringEmptyW(LPWSTR lpwszString);
void SkipWhitespace (LPCTSTR lpcsz, ULONG *pi);
BOOL FStringTok (LPCTSTR lpcszString, ULONG *piString, LPTSTR lpcszTokens, TCHAR *chToken, LPTSTR lpszValue, ULONG cbValueMax, BOOL fStripTrailingWhitespace);
#ifdef DEAD
ULONG UlDBCSStripWhitespace (LPSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
#endif // DEAD
LPTSTR SzNormalizeSubject (LPTSTR lpszSubject);
LPTSTR SzFindChar (LPCTSTR lpcsz, TCHAR ch);
WORD NFromSz (LPCTSTR lpcsz);
UINT AthUFromSz(LPCTSTR lpcsz);
VOID ProcessNlsError (VOID);

// Networking Functions
LPSTR SzGetLocalHostName (VOID);
LPTSTR SzGetLocalPackedIP (VOID);
LPSTR SzGetLocalHostNameForID (VOID);
HRESULT HrFixupHostString (LPTSTR lpszHost);
HRESULT HrFixupAccountString (LPTSTR lpszAccount);
LPTSTR SzStrAlloc (ULONG cch);

// Whatever
HFONT HGetMenuFont (void);
VOID DetailedError (HWND hwndParent, LPDETERR lpDetErr);
ULONG UlDateDiff (LPFILETIME lpft1, LPFILETIME lpft2);
BOOL FIsLeapYear (INT nYear);
VOID ResizeDialogComboEx (HWND hwndDlg, HWND hwndCombo, UINT idcBase, HIMAGELIST himl);
VOID StripIllegalHostChars(LPSTR pszSrc, LPTSTR pszDst);

#ifdef DEBUG
VOID TestDateDiff (VOID);
#endif

#endif // _COMMON_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\util.cpp ===
////////////////////////////////////////////////////////////////////////
// 
// UTIL.CPP
// 
// Purpose:
//      misc utility functions
//
// Owner:
//      Sung Rhee (sungr@microsoft.com)
//
// Copyright (C) Microsoft Corp. 1994, 1995.
// 
////////////////////////////////////////////////////////////////////////
#include <pch.hxx>
#include <shlwapip.h>
#include "storfldr.h"
#include "options.h"
#include <io.h>
#include "docobj.h"
#include <string.h>
#include <mbstring.h>
#include "spell.h"
#include "cmdtargt.h"
#include "mimeolep.h"
#include "oleutil.h"
#include "regutil.h"
#include "secutil.h"
#include "imagelst.h"
#include "inetcfg.h"
#include "url.h"
#include <mshtmcid.h>
#include <mshtmhst.h>
#include "bodyutil.h"
#include "htmlstr.h"
#include "sigs.h"
#include "imsgcont.h"
#include <dlgs.h>
#include "msgfldr.h"
#include "shared.h"
#include "demand.h"
#include "note.h"
#include "ipab.h"
#include "menures.h"
#include <iert.h>
#include <multiusr.h>
#include "mirror.h"
ASSERTDATA

#define IS_EXTENDED(ch)     ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r')
#define IS_BINARY(ch)       ((ch < 32) && ch != '\t' && ch != '\n' && ch != '\r')
#define MAX_SIG_SIZE        4096

INT_PTR CALLBACK DontShowAgainDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EnumThreadCB(HWND hwnd, LPARAM lParam);

enum
{
    SAVEAS_RFC822   =1,     // KEEP IN ORDER of FILTER IN SAVEAS DIALOG
    SAVEAS_TEXT,
    SAVEAS_UNICODETEXT,
    SAVEAS_HTML,
    SAVEAS_NUMTYPES = SAVEAS_HTML
};

HRESULT HrSaveMsgSourceToFile(LPMIMEMESSAGE pMsg, DWORD dwSaveAs, LPWSTR pwszFile, BOOL fCanBeDirty);

#define CBPATHMAX   512

VOID    DoReadme(HWND hwndOwner)
{
    TCHAR   szbuf[CBPATHMAX];
    LPTSTR  psz;

    if((fIsNT5() && g_OSInfo.dwMinorVersion >=1) || 
            ((g_OSInfo.dwMajorVersion > 5) &&  (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)))
    {
        AthMessageBox(hwndOwner, MAKEINTRESOURCE(idsAthena), MAKEINTRESOURCE(idsReadme), NULL, MB_OK);
        return;
    }
    if (GetExePath(c_szIexploreExe, szbuf, ARRAYSIZE(szbuf), TRUE))
    {
        // need to delete stup ';' in IE path
        TCHAR *pch = CharPrev(szbuf, szbuf + lstrlen(szbuf));
        *pch = TEXT('\0');

        PathAddBackslash(szbuf);

        lstrcat(szbuf, c_szReadme);

        ShellExecute(hwndOwner, "open", (LPCTSTR)szbuf, NULL, NULL, SW_SHOWNORMAL);
    }
}


void AthErrorMessage(HWND hwnd, LPTSTR pszTitle, LPTSTR pszError, HRESULT hrDetail)
{
    LPWSTR  pwszTitle = NULL,
            pwszError = NULL;
 
    // Title can be null. So is PszToUnicode fails, we are ok. Title just becomes "Error"
    pwszTitle = IS_INTRESOURCE(pszTitle) ? (LPWSTR)pszTitle : PszToUnicode(CP_ACP, pszTitle);

    pwszError = IS_INTRESOURCE(pszError) ? (LPWSTR)pszError : PszToUnicode(CP_ACP, pszError);

    // pwszError must be valid. If not, don't do the error box.
    if (pwszError)
        AthErrorMessageW(hwnd, pwszTitle, pwszError, hrDetail);

    if (!IS_INTRESOURCE(pszTitle))
        MemFree(pwszTitle);

    if (!IS_INTRESOURCE(pszError))
        MemFree(pwszError);
}

void AthErrorMessageW(HWND hwnd, LPWSTR pwszTitle, LPWSTR pwszError, HRESULT hrDetail)
{
    register WORD ids;

    Assert(FAILED(hrDetail));

    switch (hrDetail)
    {
        case E_OUTOFMEMORY:
            ids = idsMemory;
            break;

        case DB_E_CREATEFILEMAPPING:
        case STG_E_MEDIUMFULL:
        case DB_E_DISKFULL:
        case hrDiskFull:
            ids = idsDiskFull;
            break;

        case DB_E_ACCESSDENIED:
            ids = idsDBAccessDenied;
            break;

        case hrFolderIsLocked:
            ids = idsFolderLocked;
            break;

        case hrEmptyDistList:       
            ids = idsErrOneOrMoreEmptyDistLists; 
            break;

        case hrNoSubject:           
            ids = idsErrNoSubject; 
            break;
            
        case hrNoSender:            
            ids = idsErrNoPoster; 
            break;

        case HR_E_POST_WITHOUT_NEWS:        
            ids = idsErrPostWithoutNewsgroup; 
            break;

        case HR_E_CONFIGURE_SERVER:
            ids = idsErrConfigureServer; 
            break;

        case hrEmptyRecipientAddress:        
            ids = idsErrEmptyRecipientAddress; 
            break;

        case MIME_E_URL_NOTFOUND:   
            ids = idsErrSendDownloadFail; 
            break;

        case hrUnableToLoadMapi32Dll:
            ids = idsCantLoadMapi32Dll;
            break;

        case hrImportLoad:
            ids = idsErrImportLoad;
            break;

        case hrFolderNameConflict:
            ids = idsErrFolderNameConflict;
            break;

        case STORE_E_CANTRENAMESPECIAL:
            ids = idsErrRenameSpecialFld;
            break;

        case STORE_E_BADFOLDERNAME:
            ids = idsErrBadFolderName;
            break;

        case MAPI_E_INVALID_ENTRYID:
            ids = idsErrBadRecips;
            break;

        case MIME_E_SECURITY_CERTERROR:
            ids = idsSecCerificateErr; 
            break;

        case MIME_E_SECURITY_NOCERT:
            ids = idsNoCerificateErr; 
            break;
            
        case HR_E_COULDNOTFINDACCOUNT:      
            ids = idsErrNoSendAccounts; //:idsErrConfigureServer; 
            break;

        case hrDroppedConn:
            ids = idsErrPeerClosed;
            break;

        case hrInvalidPassword:
            ids = idsErrAuthenticate;
            break;

        case hrCantMoveIntoSubfolder:
            ids = idsErrCantMoveIntoSubfolder;
            break;

        case STORE_E_CANTDELETESPECIAL:
        case hrCantDeleteSpecialFolder:
            ids = idsErrDeleteSpecialFolder;
            break;

        case hrNoRecipients:
            ids = idsErrNoRecipients;
            break;

        case hrBadRecipients:
            ids = idsErrBadRecipients;
            break;

        case HR_E_ATHSEC_NOCERTTOSIGN:
            {
                ids = idsErrSecurityNoSigningCert;
                if(DialogBoxParam(g_hLocRes, 
                        MAKEINTRESOURCE(iddErrSecurityNoSigningCert), hwnd, 
                        ErrSecurityNoSigningCertDlgProc, NULL) == idGetDigitalIDs)
                    GetDigitalIDs(NULL);
                return;
            }
            break;

        case HR_E_ATHSEC_CERTBEGONE:
            ids = idsErrSecurityCertDisappeared;
            break;

        case MIME_E_SECURITY_NOSIGNINGCERT:
            //N for the MIME error, may need to do better
            // ? delete the reg key if invalid?  sure, they
            // can always go to the combo box again.  Maybe
            // prompt them toward this
            ids = idsErrSecurityNoSigningCert;
            break;

        case hrCantMoveSpecialFolder:
            ids = idsErrCannotMoveSpecial;
            break;

        case MIME_E_SECURITY_LABELACCESSDENIED:
        case MIME_E_SECURITY_LABELACCESSCANCELLED:
        case MIME_E_SECURITY_LABELCORRUPT:
            ids = idsErrAccessDenied;
            break;

        default:
            ids = idsGenericError;
            break;
    }

    AthMessageBoxW(hwnd, pwszTitle, pwszError, MAKEINTRESOURCEW(ids), MB_OK | MB_ICONEXCLAMATION);
}

INT_PTR CALLBACK ErrSecurityNoSigningCertDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    INT id;
    switch(msg)
    {
        case WM_INITDIALOG:
            CenterDialog(hwnd);
            return TRUE;

        case WM_COMMAND:
            switch(id=GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idGetDigitalIDs:
/*                    GetDigitalIDs(NULL);
                    break; */

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
    }
    return FALSE;
}



BOOL FNewMessage(HWND hwnd, BOOL fModal, BOOL fNoStationery, BOOL fNews, FOLDERID folderID, IUnknown *pUnkPump)
{
    INIT_MSGSITE_STRUCT     initStruct;
    DWORD                   dwCreateFlags = 0;
    HRESULT                 hr;
    FOLDERTYPE              ftype;

    ftype = fNews ? FOLDER_NEWS : FOLDER_LOCAL;

    ProcessICW(hwnd, ftype);

    // Create new mail message
    initStruct.dwInitType = OEMSIT_VIRGIN;
    initStruct.folderID = folderID;
    if(fNoStationery)
        dwCreateFlags = OENCF_NOSTATIONERY;
    if (fModal)
        dwCreateFlags |= OENCF_MODAL;
    if (fNews)
        dwCreateFlags |= OENCF_NEWSFIRST;

    hr = CreateAndShowNote(OENA_COMPOSE, dwCreateFlags, &initStruct, hwnd, pUnkPump);

    return (SUCCEEDED(hr) || (MAPI_E_USER_CANCEL == hr));
}



// ********* WARNING THESE ARE NOT READY FOR PRIME TIME USE *********//
// I put them here so that they are in the right place. brent,03/24
// I will clean them up when I return from Florida.

HRESULT CreateNewShortCut(LPWSTR pwszPathName, LPWSTR pwszLinkPath, DWORD cchLink)
{ 
    WCHAR wszDisplayName[MAX_PATH];

    Assert(pwszPathName);
    Assert(pwszLinkPath);
    Assert(0 < cchLink);

    if (!FBuildTempPathW(pwszPathName, pwszLinkPath, cchLink, TRUE))
        return(E_FAIL);

    GetDisplayNameForFile(pwszPathName, wszDisplayName);
    return CreateLink(pwszPathName, pwszLinkPath, wszDisplayName);
}

//===================================================
//    
// HRESULT GetDisplayNameForFile
//
//===================================================

void GetDisplayNameForFile(LPWSTR pwszPathName, LPWSTR pwszDisplayName)
{
    SHFILEINFOW sfi={0};

    SHGetFileInfoWrapW(pwszPathName, NULL, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME); 
    StrCpyW(pwszDisplayName, sfi.szDisplayName);
}

//===================================================
//    
//  HRESULT CreateLink()
//
/* 
 * CreateLink 
 * 
 * uses the shell's IShellLink and IPersistFile interfaces 
 * to create and store a shortcut to the specified object. 
 * Returns the result of calling the member functions of the interfaces. 
 * lpszPathObj  - address of a buffer containing the path of the object 
 * lpszPathLink - address of a buffer containing the path where the 
 *                shell link is to be stored 
 * lpszDesc     - address of a buffer containing the description of the 
 *                shell link 
 */ 

HRESULT CreateLink(LPWSTR pwszPathObj, LPWSTR pwszPathLink, LPWSTR pwszDesc)  
{ 
    HRESULT         hr; 
    IShellLink     *psl = NULL; 
    IShellLinkW    *pslW = NULL; 
    LPSTR           pszPathObj = NULL,
                    pszDesc = NULL;
 
    // Get a pointer to the IShellLink interface. 
    hr = CoCreateInstance(  CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IShellLinkW, (LPVOID *)&pslW);
    
    if(SUCCEEDED(hr))
    { 
        // Set the path to the shortcut target, and add the description.
        pslW->SetPath(pwszPathObj);
        pslW->SetDescription(pwszDesc);
        hr = HrIPersistFileSaveW((LPUNKNOWN)pslW, pwszPathLink);
    }
    else
    {
        hr = CoCreateInstance(  CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IShellLink, (LPVOID *)&psl);
    
        if(SUCCEEDED(hr))
        { 
            IF_NULLEXIT(pszPathObj = PszToANSI(CP_ACP, pwszPathObj));
            IF_NULLEXIT(pszDesc = PszToANSI(CP_ACP, pwszDesc));

            // Set the path to the shortcut target, and add the description.
            psl->SetPath(pszPathObj);
            psl->SetDescription(pszDesc);
            hr = HrIPersistFileSaveW((LPUNKNOWN)psl, pwszPathLink);
        }
    }

exit:
    ReleaseObj(psl);
    ReleaseObj(pslW);

    MemFree(pszPathObj);
    MemFree(pszDesc);

    return hr;
} 

DWORD DwGetDontShowAgain (LPCSTR pszRegString)
{
    DWORD   dwDontShow, dwType;
    ULONG   cb;

    cb = sizeof(DWORD);
    if (AthUserGetValue(c_szRegPathDontShowDlgs, pszRegString, &dwType, (LPBYTE)&dwDontShow, &cb) != ERROR_SUCCESS ||
        dwType != REG_DWORD ||
        cb != sizeof(DWORD))
    {
        dwDontShow = 0;       // default to show if something fails!
    }      

    return dwDontShow;
}

VOID SetDontShowAgain (DWORD dwDontShow, LPCSTR pszRegString)
{
    AthUserSetValue(c_szRegPathDontShowDlgs, pszRegString, REG_DWORD, (LPBYTE)&dwDontShow, sizeof(DWORD));
}

typedef struct _tagDONTSHOWPARAMS
{
    LPTSTR pszMessage;
    LPTSTR pszTitle;
    UINT uType;
} DONTSHOWPARAMS, *LPDONTSHOWPARAMS;

void SetDlgButtonText(HWND hBtn, int ids)
{
    TCHAR szBuf[CCHMAX_STRINGRES];
    int id;

    AthLoadString(ids, szBuf, sizeof(szBuf));
    SetWindowText(hBtn, szBuf);

    switch (ids)
    {
        case idsYES:    id = IDYES;     break;
        case idsNO:     id = IDNO;      break;
        case idsCANCEL: id = IDCANCEL;  break;
        case idsOK:     id = IDOK;      break;
        default: AssertSz(FALSE, "Bad button type."); return;
    }

    SetWindowLong(hBtn, GWL_ID, id);
}

void DoDontShowInitDialog(HWND hwnd, LPDONTSHOWPARAMS pParams)
{
    int     btnTop, 
            heightDelta = 0, 
            btnLeftDelta = 0,
            nShowStyle1 = SWP_SHOWWINDOW, 
            nShowStyle2 = SWP_SHOWWINDOW, 
            nShowStyle3 = SWP_SHOWWINDOW;
    TCHAR   rgchTitle[CCHMAX_STRINGRES], rgchMsg[CCHMAX_STRINGRES], rgchCheck[CCHMAX_STRINGRES];
    HWND    hText, hBtn1, hBtn2, hBtn3, hCheck, hIconStat;
    HICON   hIcon;
    LONG    uBtnStyle;
    UINT    idsCheckBoxString = 0;
    UINT    uShowBtns = (MB_OK|MB_OKCANCEL|MB_YESNO|MB_YESNOCANCEL) & pParams->uType;
    UINT    uDefBtn = (MB_DEFBUTTON1|MB_DEFBUTTON2|MB_DEFBUTTON3) & pParams->uType;
    UINT    uIconStyle = (MB_ICONASTERISK|MB_ICONEXCLAMATION|MB_ICONHAND|MB_ICONEXCLAMATION ) & pParams->uType;
    RECT    rc;
    LPTSTR  szTitle = pParams->pszTitle,
            szMessage = pParams->pszMessage;

    if (0 == uShowBtns)
        uShowBtns= MB_OK;

    if (0 == uDefBtn)
        uDefBtn = MB_DEFBUTTON1;
            
    if (!uIconStyle)
    {
        switch(uShowBtns)
        {
            case MB_OK: 
                uIconStyle = MB_ICONINFORMATION; 
                idsCheckBoxString = idsDontShowMeAgain;
                break;
            case MB_OKCANCEL:
                uIconStyle = MB_ICONEXCLAMATION;
                idsCheckBoxString = idsDontShowMeAgain;
                break;
            case MB_YESNO:
            case MB_YESNOCANCEL:
                uIconStyle = MB_ICONEXCLAMATION ;
                idsCheckBoxString = idsDontAskMeAgain;
                break;
            default:
                AssertSz(FALSE, "Didn't get a valid box type");
                uIconStyle = MB_ICONWARNING;
                break;
        }
    }

    if (IS_INTRESOURCE(szTitle))
    {
        // its a string resource id
        if (0 == AthLoadString(PtrToUlong(szTitle), rgchTitle, sizeof(rgchTitle)))
            return;

        szTitle = rgchTitle;
    }

    if (IS_INTRESOURCE(szMessage))
    {
        // its a string resource id
        if (0 == AthLoadString(PtrToUlong(szMessage), rgchMsg, sizeof(rgchMsg)))
            return;

        szMessage = rgchMsg;
    }

    switch(uIconStyle)
    {
        case MB_ICONASTERISK:       hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ASTERISK)); break;
        case MB_ICONEXCLAMATION:    hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION)); break;
        case MB_ICONHAND:           hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_HAND)); break;
        case MB_ICONQUESTION :      hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION)); break;  // fixes BUG 18105
        default:                    hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION)); break;
    }
    AssertSz(hIcon, "Didn't get the appropriate system icon.");

    hIconStat = GetDlgItem(hwnd, ico1);
    AssertSz(hIconStat, "Didn't get the handle to the static icon dgl item.");
    SendMessage(hIconStat, STM_SETICON, (WPARAM)hIcon, 0);

    CenterDialog(hwnd);

    hText = GetDlgItem(hwnd, stc1);
    AssertSz(hText, "Didn't get a static text handle.");

    GetChildRect(hwnd, hText, &rc);
    HDC dc = GetDC(hwnd);
    if (dc)
    {
        switch (uShowBtns)
        {
            case MB_OK:
            {
                nShowStyle1 = SWP_HIDEWINDOW;
                nShowStyle3 = SWP_HIDEWINDOW;
                break;
            }

            case MB_OKCANCEL:
            case MB_YESNO:
            {
                nShowStyle3 = SWP_HIDEWINDOW;
                break;
            }
        }

        // Size the static text
        heightDelta = DrawText(dc, szMessage, -1, &rc, DT_CALCRECT|DT_WORDBREAK|DT_CENTER);
        ReleaseDC(hwnd, dc);
        SetWindowPos(hText, 0, 0, 0, rc.right-rc.left, heightDelta, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOZORDER);
    }

    // Move buttons
    hBtn1 = GetDlgItem(hwnd, psh1);
    hBtn2 = GetDlgItem(hwnd, psh2);
    hBtn3 = GetDlgItem(hwnd, psh3);
    AssertSz(hBtn1 && hBtn2 && hBtn3, "Didn't get one of button handles.");

    GetChildRect(hwnd, hBtn1, &rc);
    btnTop = rc.top+heightDelta;

    // With these two cases, buttons must be shifted a bit to the right
    if ((MB_OKCANCEL == uShowBtns) || (MB_YESNO == uShowBtns))
    {
        RECT tempRC;
        GetChildRect(hwnd, hBtn2, &tempRC);
        btnLeftDelta = (tempRC.left - rc.left) / 2;
    }

    SetWindowPos(hBtn1, 0, rc.left+btnLeftDelta, btnTop, 0, 0, nShowStyle1|SWP_NOSIZE|SWP_NOZORDER);            
    GetChildRect(hwnd, hBtn2, &rc);
    SetWindowPos(hBtn2, 0, rc.left+btnLeftDelta, btnTop, 0, 0, nShowStyle2|SWP_NOSIZE|SWP_NOZORDER);
    GetChildRect(hwnd, hBtn3, &rc);
    SetWindowPos(hBtn3, 0, rc.left+btnLeftDelta, btnTop, 0, 0, nShowStyle3|SWP_NOSIZE|SWP_NOZORDER);

    // Move check box
    hCheck = GetDlgItem(hwnd, idchkDontShowMeAgain);
    AssertSz(hCheck, "Didn't get a handle to the check box.");
    GetChildRect(hwnd, hCheck, &rc);
    SetWindowPos(hCheck, 0, rc.left, rc.top+heightDelta, 0, 0, SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOZORDER);
    AthLoadString(idsCheckBoxString, rgchCheck, sizeof(rgchCheck));
    SetWindowText(hCheck, rgchCheck);

    // Size dialog
    GetWindowRect(hwnd, &rc);
    heightDelta += rc.bottom - rc.top;
    SetWindowPos(hwnd, 0, 0, 0, rc.right-rc.left, heightDelta, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOOWNERZORDER);

    SetWindowText(hText, szMessage);

    SetWindowText(hwnd, szTitle);

    switch(uShowBtns)
    {
        case MB_OK:
        {
            SetFocus(hBtn2);
            SetDlgButtonText(hBtn2, idsOK);
            break;
        }

        case MB_OKCANCEL:
        case MB_YESNO:
        {
            SetFocus((MB_DEFBUTTON1 == uDefBtn) ? hBtn1 : hBtn2);

            if (MB_OKCANCEL == uShowBtns)
            {
                SetDlgButtonText(hBtn1, idsOK);
                SetDlgButtonText(hBtn2, idsCANCEL);
            }
            else
            {
                SetDlgButtonText(hBtn1, idsYES);
                SetDlgButtonText(hBtn2, idsNO);
            }
            break;
        }

        case MB_YESNOCANCEL:
        {
            switch (uDefBtn)
            {
                case MB_DEFBUTTON1: SetFocus(hBtn1); break;
                case MB_DEFBUTTON2: SetFocus(hBtn2); break;
                case MB_DEFBUTTON3: SetFocus(hBtn3); break;
                default:            SetFocus(hBtn1); break;
            }
            
            SetDlgButtonText(hBtn1, idsYES);
            SetDlgButtonText(hBtn2, idsNO);
            SetDlgButtonText(hBtn3, idsCANCEL);
            break;
        }

        default:
            AssertSz(FALSE, "Not a valid box type.");
    }
}

INT_PTR CALLBACK DontShowAgainDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            DoDontShowInitDialog(hwnd, (LPDONTSHOWPARAMS)lParam);
            return FALSE;

        case WM_COMMAND:
            if(GET_WM_COMMAND_ID(wParam, lParam) == IDOK    ||
               GET_WM_COMMAND_ID(wParam, lParam) == IDYES   ||            
               GET_WM_COMMAND_ID(wParam, lParam) == IDNO    ||
               GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
                // We'll put the yes, no, cancel return value in the HIWORD of 
                // the return, and the don't show again status in the LOWORD.
                EndDialog(hwnd, (int) MAKELPARAM(IsDlgButtonChecked(hwnd, idchkDontShowMeAgain),
                                                 GET_WM_COMMAND_ID(wParam, lParam)));
    }
    return FALSE;
}

LRESULT DoDontShowMeAgainDlg(HWND hwndOwner, LPCSTR pszRegString, LPTSTR pszTitle, LPTSTR pszMessage, UINT uType)
{
    DWORD           dwDontShow=0;
    LRESULT         lResult;
    DONTSHOWPARAMS  dlgParams;

    AssertSz(pszRegString, "Pass me a reg key string!");
    AssertSz(pszRegString, "Pass me a message to display!");
    AssertSz(pszRegString, "Pass me a title to display!");

    // read the folder view from the registry...
    dwDontShow = DwGetDontShowAgain (pszRegString);

    if (dwDontShow)     // return what was stored as if the user clicked on the button stored
        return (LRESULT) dwDontShow;

    dlgParams.pszMessage = pszMessage;
    dlgParams.pszTitle = pszTitle;
    dlgParams.uType = uType;

    lResult = (LRESULT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddDontShow), hwndOwner, 
                                       DontShowAgainDlgProc, (LPARAM)&dlgParams);
    if((IDCANCEL != HIWORD(lResult)) && LOWORD(lResult))
    {
        // save the dontshow flag
        SetDontShowAgain (HIWORD(lResult), pszRegString);         
    }
    
    return (HIWORD(lResult));    
}

HRESULT SubstituteWelcomeURLs(LPSTREAM pstmIn, LPSTREAM *ppstmOut)
{
    HRESULT             hr;
    IHTMLDocument2      *pDoc;
    LPSTREAM            pstm=0;
        
    // BUGBUG: this cocreate should also go thro' the same code path as the DocHost one
    // so that if this is the first trident in the process, we keep it's CF around

    hr = MimeEditDocumentFromStream(pstmIn, IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (SUCCEEDED(hr))
    {
        URLSUB rgUrlSub[] = {
                                { "mslink",     idsHelpMSWebHome },
                                { "certlink",   idsHelpMSWebCert },
                            };

        if (SUCCEEDED(hr = SubstituteURLs(pDoc, rgUrlSub, ARRAYSIZE(rgUrlSub))))
        {
            hr = MimeOleCreateVirtualStream(&pstm);
            if (!FAILED(hr))
            {
                IPersistStreamInit  *pPSI;

                HrSetDirtyFlagImpl(pDoc, TRUE);

                hr = pDoc->QueryInterface(IID_IPersistStreamInit, (LPVOID*)&pPSI);
                if (!FAILED(hr))
                {
                    hr = pPSI->Save(pstm, TRUE);
                    pPSI->Release();
                }
            }
        }
        pDoc->Release();
    }
    
    if (!FAILED(hr))
    {
        Assert(pstm);
        *ppstmOut=pstm;
        pstm->AddRef();
    }

    ReleaseObj(pstm);
    return hr;

}

HRESULT IAddWelcomeMessage(IMessageFolder *pfolder, LPWABAL pWabal, LPCTSTR szFile, LPCTSTR szRes)
{
    PROPVARIANT     pv;
    SYSTEMTIME      st;
    HRESULT         hr;
    LPMIMEMESSAGE   pMsg;
    LPSTREAM        pstmBody, 
                    pstmSub, 
                    pstmStore;
    TCHAR           sz[CCHMAX_STRINGRES];

    // Create the mail msg
    if (FAILED(hr = HrCreateMessage(&pMsg)))
        return(hr);

    HrSetWabalOnMsg(pMsg, pWabal);

    // Subject
    SideAssert(LoadString(g_hLocRes, idsWelcomeMessageSubj, sz, ARRAYSIZE(sz)));
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, sz);

    // Set Date
    pv.vt = VT_FILETIME;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &pv.filetime);
    pMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);

    pstmBody = NULL;
    pstmSub = NULL;

    if (szFile == NULL || *szFile == 0)
    {
        if (SUCCEEDED(hr = HrLoadStreamFileFromResource(szRes, &pstmBody)))
        {
            if (SUCCEEDED(SubstituteWelcomeURLs(pstmBody, &pstmSub)))
            {
                pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmSub, NULL);
                pstmSub->Release();
            }
            else
            {
                pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmBody, NULL);
            }

            pstmBody->Release();
        }
    }
    else
    {
        if (SUCCEEDED(hr = OpenFileStream((TCHAR *)szFile, OPEN_EXISTING, GENERIC_READ, &pstmBody)))
        {
            pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmBody, NULL);
            pstmBody->Release();
        }
    }

    // Get a stream from the store
    if (SUCCEEDED(hr))
    {
        // set encoding options
        pv.vt = VT_UI4;
        pv.ulVal = SAVE_RFC1521; 
        pMsg->SetOption(OID_SAVE_FORMAT, &pv);

        pv.ulVal = (ULONG)IET_QP; 
        pMsg->SetOption(OID_TRANSMIT_TEXT_ENCODING, &pv);

        pv.boolVal = FALSE;
        pMsg->SetOption(OID_WRAP_BODY_TEXT, &pv);

        hr = pMsg->Commit(0);
        if (!FAILED(hr))
        {
            hr = pfolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, NOFLAGS, 0, pMsg, NOSTORECALLBACK);
        }
    }

    pMsg->Release();

    return(hr);
}

static const TCHAR c_szWelcomeMsgHotmailHtm[] = TEXT("welcome.htm");
static const TCHAR c_szWelcomeMsgHtm[] = TEXT("welcome2.htm");

void AddWelcomeMessage(IMessageFolder *pfolder)
{
    HRESULT          hr;
    LPWABAL          pWabal;
    TCHAR            szName[CCHMAX_DISPLAY_NAME + 1], 
                     szEmail[CCHMAX_EMAIL_ADDRESS + 1],
                     szFromName[CCHMAX_STRINGRES],
                     szFromEmail[CCHMAX_STRINGRES],
                     szHtm[MAX_PATH],
                     szExpanded[MAX_PATH];
    LPTSTR           psz = szHtm;
    DWORD            type, cb;
    HKEY             hkey;
    BOOL             fName, fEmail, fFromName, fFromEmail;
    IImnEnumAccounts *pEnum;
    IImnAccount      *pAccount;

    if (FAILED(HrCreateWabalObject(&pWabal)))
        return;

    fName = FALSE;
    fEmail = FALSE;
    fFromName = FALSE;
    fFromEmail = FALSE;
    *szHtm = 0;

    if (ERROR_SUCCESS == AthUserOpenKey(c_szRegPathMail, KEY_READ, &hkey))
    {
        cb = sizeof(szHtm);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szWelcomeHtm, NULL, &type, (LPBYTE)szHtm, &cb))
        {
            if (REG_EXPAND_SZ == type)
            {
                ExpandEnvironmentStrings(szHtm, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }

            if (PathFileExists(psz))
            {
                cb = sizeof(szFromName);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szWelcomeName, NULL, &type, (LPBYTE)szFromName, &cb) &&
                    cb > sizeof(TCHAR))
                    fFromName = TRUE;

                cb = sizeof(szFromEmail);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szWelcomeEmail, NULL, &type, (LPBYTE)szFromEmail, &cb) &&
                    cb > sizeof(TCHAR))
                    fFromEmail = TRUE;
            }
            else
            {
                *psz = 0;
            }
        }

        RegCloseKey(hkey);
    }

    Assert(g_pAcctMan != NULL);
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_IMAP | SRV_SMTP | SRV_POP3, &pEnum)))
    {
        Assert(pEnum != NULL);

        while (!fName || !fEmail)
        {
            hr = pEnum->GetNext(&pAccount);
            if (FAILED(hr) || pAccount == NULL)
                break;

            if (!fName)
            {
                if (!FAILED(pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szName, ARRAYSIZE(szName)))
                    && !FIsEmpty(szName))
                    fName = TRUE;
            }

            if (!fEmail)
            {
                if (!FAILED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail)))
                    && SUCCEEDED(ValidEmailAddress(szEmail)))
                    fEmail = TRUE;
            }

            pAccount->Release();
        }

        pEnum->Release();
    }

    // Add Recipient
    if (!fName)
        LoadString(g_hLocRes, idsNewAthenaUser, szName, ARRAYSIZE(szName));
    
    if (!fFromName)
        LoadString(g_hLocRes, idsWelcomeFromDisplay, szFromName, ARRAYSIZE(szFromName));
    if (!fFromEmail)
        LoadString(g_hLocRes, idsWelcomeFromEmail, szFromEmail, ARRAYSIZE(szFromEmail));

    // add recipient and sender
    if (SUCCEEDED(pWabal->HrAddEntryA(szName, fEmail ? szEmail : NULL, MAPI_TO)) &&
        SUCCEEDED(pWabal->HrAddEntryA(szFromName, szFromEmail, MAPI_ORIG)))
    {
        if (SUCCEEDED(IAddWelcomeMessage(pfolder, pWabal, psz, HideHotmail() ? c_szWelcomeMsgHtm:c_szWelcomeMsgHotmailHtm)))
        {
            SetDwOption(OPT_NEEDWELCOMEMSG, FALSE, NULL, 0);
        }
    }

    pWabal->Release();
}

// Direct WM_HELP/WM_CONTEXTMENU help here:
BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            OEWinHelp ((HWND)lphi->hItemHandle,
                        c_szCtxHelpFile,
                        HELP_WM_HELP,
                        (DWORD_PTR)(LPVOID)rgCtxMap);
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU)
    {
        OEWinHelp ((HWND) wParam,
                    c_szCtxHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)rgCtxMap);
        return (TRUE);
    }

    Assert(0);

    return FALSE;
}

HRESULT HrSaveMessageToFile(HWND hwnd, LPMIMEMESSAGE pMsg, LPMIMEMESSAGE pDelSecMsg, BOOL fNews, BOOL fCanBeDirty)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszFile[MAX_PATH],
                    wszTitle[CCHMAX_STRINGRES],
                    wszFilter[MAX_PATH],
                    wszDefExt[30];
    LPWSTR          pwszSubject=0;
    HRESULT         hr;
    int             rgidsSaveAsFilter[SAVEAS_NUMTYPES],
                    rgFilterType[SAVEAS_NUMTYPES],
                    cFilter=0;
    DWORD           dwFlags=0;

    if(!pMsg || !hwnd)
        return E_INVALIDARG;

    *wszDefExt=0;
    *wszTitle=0;
    *wszFile=0;
    *wszFilter=0;
        
    pMsg->GetFlags(&dwFlags);

    // Load Res Strings
    rgidsSaveAsFilter[cFilter] = fNews?idsNwsFileFilter:idsEmlFileFilter;
    rgFilterType[cFilter++] = SAVEAS_RFC822;
    AthLoadStringW(fNews?idsDefNewsExt:idsDefMailExt, wszDefExt, ARRAYSIZE(wszDefExt));
    
    if (dwFlags & IMF_PLAIN)
    {
        rgidsSaveAsFilter[cFilter] = idsTextFileFilter;
        rgFilterType[cFilter++] = SAVEAS_TEXT;

        rgidsSaveAsFilter[cFilter] = idsUniTextFileFilter;
        rgFilterType[cFilter++] = SAVEAS_UNICODETEXT;
    }

    if (dwFlags & IMF_HTML)
    {
        rgidsSaveAsFilter[cFilter] = idsHtmlFileFilter;
        rgFilterType[cFilter++] = SAVEAS_HTML;
    }

    CombineFiltersW(rgidsSaveAsFilter, cFilter, wszFilter);
    AthLoadStringW(idsMailSaveAsTitle, wszTitle, ARRAYSIZE(wszTitle));

    // Use Subject ?
    hr=MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubject);
    if (!FAILED(hr))
    {
        AthwsprintfW(wszFile, ARRAYSIZE(wszFile), L"%.240s", pwszSubject);

        // Bug 84793. "." is not valid char for filename: "test.com"
        ULONG ich=0;
        ULONG cch=lstrlenW(wszFile);

        // Loop and remove invalids
	    while (ich < cch)
	    {
            // Illeagl file name character ?
            if (!FIsValidFileNameCharW(wszFile[ich]) || (wszFile[ich] == L'.'))
                wszFile[ich]=L'_';
        
            ich++;
        }

    }

    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = wszFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = wszFile;
    ofn.nMaxFile = ARRAYSIZE(wszFile);
    ofn.lpstrTitle = wszTitle;
    ofn.lpstrDefExt = wszDefExt;
    ofn.Flags = OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;

    // Show SaveAs Dialog
    if (HrAthGetFileNameW(&ofn, FALSE)!=S_OK)
    {
        // usercancel is cool.
        hr=hrUserCancel;
        goto error;
    }

    // ofn.nFilterIndex returns the currently selected filter.  this is the index into
    // the filter pair specified by lpstrFilter = idsMailSaveAsFilter.  currently:
    // 1 => eml
    // 2 => txt
    // 3 => unicode txt
    // 4 => html

    Assert ((int)ofn.nFilterIndex -1 < cFilter);

    if(ofn.nFilterIndex != SAVEAS_RFC822)
    {
        if(IsEncrypted(pMsg, TRUE))
        {
            if(AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsSaveEncrypted), NULL, MB_YESNO) == IDNO)
            {
                hr=hrUserCancel;
                goto error;
            }
        }

        hr = HrSaveMsgSourceToFile((pDelSecMsg ? pDelSecMsg : pMsg), rgFilterType[ofn.nFilterIndex-1], wszFile, fCanBeDirty);
    }
    else
        hr = HrSaveMsgSourceToFile(pMsg, rgFilterType[ofn.nFilterIndex-1], wszFile, fCanBeDirty);

error:
    MemFree(pwszSubject);

    if (FAILED(hr) && hr!=hrUserCancel)
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsUnableToSaveMessage), hr);

    return hr;
};

VOID OnHelpGoto(HWND hwnd, UINT id)
{
    UINT idh;
    DWORD cb;
    HRESULT hr;
    CLSID clsid;
    LPWSTR pwszCLSID;
    IContextMenu *pMenu;
    CMINVOKECOMMANDINFO info;
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if (id == ID_MSWEB_SEARCH)
    {
        cb = sizeof(szURL);
        if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_szRegIEWebSearch, szURL, (LONG *)&cb))
        {
            pwszCLSID = PszToUnicode(CP_ACP, szURL);
            if (pwszCLSID != NULL)
            {
                hr = CLSIDFromString(pwszCLSID, &clsid);
                if (SUCCEEDED(hr))
                {
                    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IContextMenu, (void **)&pMenu);
                    if (SUCCEEDED(hr))
                    {
                        ZeroMemory(&info, sizeof(CMINVOKECOMMANDINFO));
                        info.cbSize = sizeof(CMINVOKECOMMANDINFO);
                        info.hwnd = hwnd;
                        pMenu->InvokeCommand(&info);

                        pMenu->Release();
                    }
                }

                MemFree(pwszCLSID);
            }
        }

        return;
    }

    hr = E_FAIL;
    if (id == ID_MSWEB_SUPPORT)
    {
        cb = sizeof(szURL);
        if (ERROR_SUCCESS == AthUserGetValue(NULL, c_szRegHelpUrl, NULL, (LPBYTE)szURL, &cb) &&
            !FIsEmpty(szURL))
            hr = S_OK;
    }

    if (hr != S_OK)
    {
        idh = id - ID_MSWEB_BASE;
        hr = URLSubLoadStringA(idsHelpMSWebFirst + idh, szURL, ARRAYSIZE(szURL), URLSUB_ALL, NULL);
    }

    if (SUCCEEDED(hr))
        ShellExecute(NULL, "open", szURL, c_szEmpty, c_szEmpty, SW_SHOWNORMAL);
}


VOID    OnMailGoto(HWND hwnd)
{
    OpenClient(hwnd, c_szRegPathMail);
}

VOID    OnNewsGoto(HWND hwnd)
{
    OpenClient(hwnd, c_szRegPathNews);
}

// Get the command line to launch the requested client.
BOOL GetClientCmdLine(LPCTSTR szClient, LPTSTR szCmdLine, int cch)
{
    HKEY hKey = 0;
    TCHAR sz[MAX_PATH];
    TCHAR szClientKey[MAX_PATH];
    TCHAR szClientPath[MAX_PATH];
    TCHAR szExpanded[MAX_PATH];
    LPTSTR psz;
    DWORD dwType;
    DWORD cb;

    szCmdLine[0] = 0;

    wsprintf(sz, TEXT("%s%s%s"), c_szRegPathClients, g_szBackSlash, szClient);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        goto LErr;

    cb = ARRAYSIZE(szClientKey);
    if (RegQueryValueEx(hKey, c_szEmpty, NULL, &dwType, (LPBYTE) szClientKey, &cb) != ERROR_SUCCESS)
        goto LErr;

    if (dwType != REG_SZ || szClientKey[0] == 0)
        goto LErr;

    lstrcat(sz, g_szBackSlash);
    lstrcat(sz, szClientKey);
    lstrcat(sz, g_szBackSlash);
    lstrcat(sz, c_szRegClientPath);

    if (RegCloseKey(hKey) != ERROR_SUCCESS)
        goto LErr;

    hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        goto LErr;
    
    cb = ARRAYSIZE(szClientPath);
    if (RegQueryValueEx(hKey, c_szEmpty, NULL, &dwType, (LPBYTE) szClientPath, &cb) != ERROR_SUCCESS)
        goto LErr;

    if (REG_EXPAND_SZ == dwType)
    {
        ExpandEnvironmentStrings(szClientPath, szExpanded, ARRAYSIZE(szExpanded));
        psz = szExpanded;
    }
    else if (dwType != REG_SZ || szClientPath[0] == 0)
        goto LErr;
    else
        psz=szClientPath;

    lstrcpyn(szCmdLine, psz, cch);

LErr:
    if (hKey)
        RegCloseKey(hKey);

    return (szCmdLine[0] != '\0');
}

VOID OpenClient(HWND hwnd, LPCTSTR szClient)
{
    TCHAR szCmdLine[MAX_PATH];

    if (!GetClientCmdLine(szClient, szCmdLine, MAX_PATH))
    {
        // TODO: Report error
        return;
    }
    
    ShellExecute(hwnd, NULL, szCmdLine, NULL, NULL, SW_SHOW);
}


VOID    OnBrowserGoto(HWND hwnd, LPCTSTR szRegPage, UINT idDefault)
{
    HKEY  hKey = 0;
    TCHAR szStartPage[INTERNET_MAX_URL_LENGTH];
    DWORD   dw;
    DWORD   cb;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegStartPageKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        return;

    szStartPage[0] = 0;
    cb = sizeof(szStartPage) / sizeof(TCHAR);

    if (RegQueryValueEx(hKey, szRegPage, NULL, &dw, (LPBYTE) szStartPage, &cb) != ERROR_SUCCESS ||
        dw != REG_SZ ||
        szStartPage[0] == 0)
    {
        URLSubLoadStringA(idDefault, szStartPage, ARRAYSIZE(szStartPage), URLSUB_ALL, NULL);
    }

    if (szStartPage[0])
        ShellExecute(NULL, NULL, szStartPage, "", "", SW_SHOWNORMAL);

    if (hKey)
        RegCloseKey(hKey);
}

// --------------------------------------------------------------------------------
// AthLoadStringW
// --------------------------------------------------------------------------------
LPWSTR AthLoadStringW(UINT id, LPWSTR sz, int cch)
{
    LPWSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES*sizeof(WCHAR)))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    cch = LoadStringWrapW(g_hLocRes, id, szT, cch);
    Assert(cch > 0);

    if (cch == 0)
    {
        if (sz == NULL)
            MemFree(szT);                
        szT = NULL;
    }

    return(szT);
}

// --------------------------------------------------------------------------------
// AthLoadString
// --------------------------------------------------------------------------------
LPTSTR AthLoadString(UINT id, LPTSTR sz, int cch)
{
    LPTSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    cch = LoadString(g_hLocRes, id, szT, cch);
    Assert(cch > 0);

    if (cch == 0)
    {
        if (sz == NULL)
            MemFree(szT);                
        szT = NULL;
    }

    return(szT);
}

/*
 * hwnd       - hwnd for error UI
 * fHtmlOk    - if html sigs are cool or not. If not and a html sig is chosen it will be spewed as plain-text
 * pdwSigOpts - returns sig options
 * pbstr      - returns a BSTR of the HTML signature
 * uCodePage  - codepage to use when converting multibyte
 * fMail      - use mail or news options
 */
HRESULT HrGetMailNewsSignature(GETSIGINFO *pSigInfo, LPDWORD pdwSigOptions, BSTR *pbstr)
{
    PROPVARIANT     var;
    IOptionBucket   *pSig = NULL;
    TCHAR           szSigID[MAXSIGID+2];
    unsigned char   rgchSig[MAX_SIG_SIZE+2]; // might have to append a unicode null
    unsigned char   *pszSig;
    DWORD           dwSigOptions;
    LPSTREAM        pstm=0;
    ULONG           i,
                    cb=0;
    BOOL            fFile,
                    fUniPlainText = FALSE;
    LPWSTR          lpwsz=0;
    LPSTR           lpsz=0;
    HRESULT         hr;
    BSTR            bstr=0;
    
    Assert(pSigInfo != NULL);
    Assert(pdwSigOptions != NULL);

    dwSigOptions = SIGOPT_TOP;

    if (!pSigInfo->fMail)                         // news sigs. always have the prefix.
        dwSigOptions |= SIGOPT_PREFIX;

    *szSigID = 0;
    if (pSigInfo->szSigID != NULL)
    {
        Assert(*pSigInfo->szSigID != 0);
        lstrcpy((LPTSTR)szSigID, pSigInfo->szSigID);
    }
    else if (pSigInfo->pAcct != NULL)
    {
        pSigInfo->pAcct->GetPropSz(pSigInfo->fMail ? AP_SMTP_SIGNATURE : AP_NNTP_SIGNATURE,
            (LPTSTR)szSigID, ARRAYSIZE(szSigID));
        // TODO: should we validate the sig here???
        // if the sig has been deleted and for some reason the acct wasn't updated, this
        // could point to a non-existent sig or a different sig. this shouldn't happen if
        // everything else works properly...
    }
    
    if (*szSigID == 0)
    {
        Assert(g_pSigMgr != NULL);
        hr = g_pSigMgr->GetDefaultSignature((LPTSTR)szSigID);
        if (FAILED(hr))
            return(hr);
    }

    hr = g_pSigMgr->GetSignature((LPTSTR)szSigID, &pSig);
    if (FAILED(hr))
        return(hr);
    Assert(pSig != NULL);

    hr = pSig->GetProperty(MAKEPROPSTRING(SIG_TYPE), &var, 0);
    Assert(SUCCEEDED(hr));
    Assert(var.vt == VT_UI4);
    fFile = (var.ulVal == SIGTYPE_FILE);

    hr = pSig->GetProperty(fFile ? MAKEPROPSTRING(SIG_FILE) : MAKEPROPSTRING(SIG_TEXT), &var, 0);
    Assert(SUCCEEDED(hr));
    
    if(fFile)
    {
        Assert(var.vt == VT_LPWSTR);
        Assert(var.pwszVal != NULL);
        lpwsz = var.pwszVal;
    }
    else
    {
        Assert(var.vt == VT_LPSTR);
        Assert(var.pszVal != NULL);
        lpsz = var.pszVal;
    }

    if (fFile && FIsHTMLFileW(lpwsz))
        dwSigOptions |= SIGOPT_HTML;  // we're giving back a HTML sig

    if (pbstr)
    {
        *pbstr = 0;

        if (!fFile)
        {
            lstrcpyn((char *)rgchSig, lpsz, ARRAYSIZE(rgchSig));
        }
        else
        {
            // if it has a htm or html extension then assume it's a html file
            hr=CreateStreamOnHFileW(lpwsz, GENERIC_READ, FILE_SHARE_READ, NULL, 
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pstm);
            if (FAILED(hr))
            {
                DWORD   dwErr;
                dwErr=GetLastError();

                if(dwErr==ERROR_PATH_NOT_FOUND || dwErr==ERROR_FILE_NOT_FOUND)
                {
                    // Don't turn off auto sig settings, just remove current.
                    g_pSigMgr->DeleteSignature((LPTSTR)szSigID);

                    // if filenotfound, warn user and disable the option
                    AthMessageBoxW(pSigInfo->hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnSigNotFound), NULL, MB_OK);

                }
                goto error;
            }

            // perform the boundary check and binary check only on signature files
            // on others, we let them insert whatever they want.
            *rgchSig=0;
            pstm->Read(rgchSig, MAX_SIG_SIZE, &cb);
            rgchSig[cb]=0;    // null term
            pszSig=rgchSig;

            fUniPlainText = ((cb > 2) && (0xFF == pszSig[0]) && (0xFE == pszSig[1]) && (0 == (dwSigOptions & SIGOPT_HTML)));

            if (!fUniPlainText)
                for(i=0; i<cb; i++)
                {
                    if(IS_BINARY(*pszSig))
                    {
                        // Don't turn off auto sig settings, just remove current.
                        g_pSigMgr->DeleteSignature((LPTSTR)szSigID);

                        // signature contains invalid binary. Fail and disable option
                        AthMessageBoxW(pSigInfo->hwnd, MAKEINTRESOURCEW(idsAthena),
                                            MAKEINTRESOURCEW(idsWarnSigBinary), NULL, MB_OK);
                
                        hr=E_FAIL;
                        goto error;
                    }
                    pszSig++;
                }

            // warn that size is too large and we have truncated. Don't disable option
            if(cb==MAX_SIG_SIZE)
            {
                AthMessageBoxW(pSigInfo->hwnd, MAKEINTRESOURCEW(idsAthena),
                              MAKEINTRESOURCEW(idsWarnSigTruncated),
                              NULL, MB_OK);
            }
            SafeRelease(pstm);
        }

        // pstm contains our MultiByte data, let's convert the first cb bytes to a WideStream
        if (dwSigOptions & SIGOPT_HTML)
        {
            if (pSigInfo->fHtmlOk)
            {
                // the sig is already HTML. Let's just alloc a bstr
                hr = HrLPSZCPToBSTR(pSigInfo->uCodePage, (LPSTR)rgchSig, pbstr);
            }
            else
            {
                // the sig is HTML, but that's not cool. So let's downgrade it to plain-text
                LPSTREAM        pstmPlainW;
                ULARGE_INTEGER  uli;
    
                // if the signature is HTML and the user want's a plain-text signature. They we need to convert the HTML to plain-text (strip formatting) 
                // and then convert the stripped plain-text to HTML.

                Assert (pstm==NULL);

                if (FAILED(hr=MimeOleCreateVirtualStream(&pstm)))
                    goto error;
            
                pstm->Write(rgchSig, cb, NULL);

                // $REVIEW: this is a little odd. For a non-html sig file, we'll use the codepage that
                // the message is in (passed into this function). For a html file, we'll let Trident parse
                // the meta tag and figure out the code page as we convert to plain-text via trident
                if (!FAILED(hr=HrConvertHTMLToPlainText(pstm, &pstmPlainW, CF_UNICODETEXT)))
                {
                    hr = HrIStreamWToBSTR(pstmPlainW, pbstr);
                    pstmPlainW->Release();
                }
            }
        }
        else
        {
            // the signature is Plain-Text
            if (fUniPlainText)
            {
                // We had added an ANSI NULL, now let's make it a unicode null
                rgchSig[cb+1] = 0;
                *pbstr = SysAllocString((LPWSTR)(&rgchSig[2]));
                if (NULL == pbstr)
                    hr = E_OUTOFMEMORY;
            }
            else
                hr = HrLPSZCPToBSTR(pSigInfo->uCodePage, (LPSTR)rgchSig, pbstr);
        }

        AssertSz((FAILED(hr) || *pbstr), "how come we succeeded with no BSTR allocated?");
    }
    
    *pdwSigOptions = dwSigOptions;

error:
    MemFree(lpwsz);
    MemFree(lpsz);
    SafeRelease(pstm);
    SafeRelease(pSig);
    return hr;        
}

HRESULT HrSaveMsgSourceToFile(LPMIMEMESSAGE pMsg, DWORD dwSaveAs, LPWSTR pwszFile, BOOL fCanBeDirty)
{
    LPSTREAM    pstmFile=0,
                pstm=0;
    HRESULT     hr;
    TCHAR       sz[CCHMAX_STRINGRES],
                szCset[CCHMAX_CSET_NAME];
    HCHARSET    hCharset;
        
    hr = CreateStreamOnHFileW(pwszFile, GENERIC_READ|GENERIC_WRITE, NULL,
                  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0, &pstmFile);

    if (FAILED(hr))
        goto error;

    //N need to be able to save txt files as insecure messages

    switch(dwSaveAs)
    {
        case SAVEAS_RFC822:
            hr = pMsg->GetMessageSource(&pstm, fCanBeDirty ? COMMIT_ONLYIFDIRTY : 0);
            break;

        case SAVEAS_TEXT:
            hr = HrGetDataStream((LPUNKNOWN)pMsg, CF_TEXT, &pstm);
            break;

        case SAVEAS_UNICODETEXT:
            hr = HrGetDataStream((LPUNKNOWN)pMsg, CF_UNICODETEXT, &pstm);
            if (SUCCEEDED(hr))
            {
                BYTE bUniMark = 0xFF;
                hr = pstmFile->Write(&bUniMark, sizeof(bUniMark), NULL);
                if (SUCCEEDED(hr))
                {
                    bUniMark = 0xFE;
                    hr = pstmFile->Write(&bUniMark, sizeof(bUniMark), NULL);
                }
            }
            break;

        case SAVEAS_HTML:
            // if saving as HTML always get the internet cset
            hr = pMsg->GetTextBody(TXT_HTML, IET_INETCSET, &pstm, NULL);
            break;
        
        default:
            break;
            hr = E_FAIL;
    }
    
    if (FAILED(hr))
        goto error;

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        goto error;

    if (dwSaveAs == SAVEAS_HTML)
    {
        // if saving as HTML, append a meta charset into the head of the document
        if (SUCCEEDED(pMsg->GetCharset(&hCharset)) && SUCCEEDED(HrGetMetaTagName(hCharset, szCset)))
        {
            wsprintf(sz, c_szHtml_MetaTagf, szCset);
            pstmFile->Write(sz, lstrlen(sz)*sizeof(*sz), NULL);
        }
    }
    
    hr = HrCopyStream(pstm, pstmFile, NULL);
    if (FAILED(hr)) 
        goto error;
    
    hr = pstmFile->Commit(STGC_DEFAULT);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pstm);
    ReleaseObj(pstmFile);
    return hr;
    
}

void nyi(LPSTR lpsz)
{
    TCHAR   rgch[CCHMAX_STRINGRES];
    TCHAR   rgchNYI[CCHMAX_STRINGRES];

    if (IS_INTRESOURCE(lpsz))
    {
        // its a string resource id
        if (!LoadString(g_hLocRes, PtrToUlong(lpsz), rgch, CCHMAX_STRINGRES))
            return;

        lpsz = rgch;
    }

    if (!LoadString(g_hLocRes, idsNYITitle, rgchNYI, CCHMAX_STRINGRES))
        return;

    MessageBox(GetFocus(), lpsz, rgchNYI, MB_OK|MB_ICONSTOP|MB_SETFOREGROUND);
}


//NOTE: if *ppstm == NULL, then the stream is created.
//Otherwise it is written to.
HRESULT HrLoadStreamFileFromResource(LPCSTR lpszResourceName, LPSTREAM *ppstm)
{
    HRESULT         hr=E_FAIL;
    HRSRC           hres;
    HGLOBAL         hGlobal;
    LPBYTE          pb;
    DWORD           cb;

    if (!ppstm || !lpszResourceName)
        return E_INVALIDARG;
    
    hres = FindResource(g_hLocRes, lpszResourceName, MAKEINTRESOURCE(RT_FILE));
    if (!hres)
        goto error;

    hGlobal = LoadResource(g_hLocRes, hres);
    if (!hGlobal)
        goto error;

    pb = (LPBYTE)LockResource(hGlobal);
    if (!pb)
        goto error;

    cb = SizeofResource(g_hLocRes, hres);
    if (!cb)
        goto error;

    if (*ppstm)
        hr = (*ppstm)->Write(pb, cb, NULL);
    else
    {
        if (SUCCEEDED(hr = MimeOleCreateVirtualStream(ppstm)))
            hr = (*ppstm)->Write (pb, cb, NULL);
    }

error:  
    return hr;
}


void ConvertTabsToSpaces(LPSTR lpsz)
{
    if (lpsz)
    {
        while(*lpsz)
        {
            if (*lpsz == '\t')
                *lpsz = ' ';

            lpsz=CharNext(lpsz);
        }
    }
}

void ConvertTabsToSpacesW(LPWSTR lpsz)
{
    if (lpsz)
    {
        while(*lpsz)
        {
            if (*lpsz == L'\t')
                *lpsz = L' ';

            lpsz++;
        }
    }
}

// =================================================================================
// From strutil.cpp
// =================================================================================
#define SPECIAL_CHAR       '|'
#define SPECIAL_CHAR_W    L'|'

int LoadStringReplaceSpecial(UINT id, LPTSTR sz, int cch)
{
    int     cchRet=0;

    if(sz)
    {
        cchRet=LoadString(g_hLocRes, id, sz, cch);
        ReplaceChars(sz, SPECIAL_CHAR, '\0');
    }
    return cchRet;
}

int LoadStringReplaceSpecialW(UINT id, LPWSTR wsz, int cch)
{
    int     cchRet=0;
    
    if(wsz)
    {
        cchRet=LoadStringWrapW(g_hLocRes, id, wsz, cch);
        ReplaceCharsW(wsz, SPECIAL_CHAR_W, L'\0');
    }
    return cchRet;
}

void CombineFilters(int *rgidsFilter, int nFilters, LPSTR pszFilter)
{
    DWORD   cchFilter,
            dw,
            cch;

    Assert (rgidsFilter);
    Assert (nFilters);
    Assert (pszFilter);

    // we pray to the resource-editing gods that rgchFilter (MAX_PATH) is big enough...

    *pszFilter = 0;
    cchFilter = 0;
    for (dw = 0; dw < (DWORD)nFilters; dw++)
    {
        cch = LoadStringReplaceSpecial(rgidsFilter[dw], &pszFilter[cchFilter], MAX_PATH);
        Assert(cch);
        cchFilter += cch-1; // -1 as each filter is double null terminated
    }
}

void CombineFiltersW(int *rgidsFilter, int nFilters, LPWSTR pwszFilter)
{
    DWORD   cchFilter,
            dw,
            cch;

    Assert (rgidsFilter);
    Assert (nFilters);
    Assert (pwszFilter);

    // we pray to the resource-editing gods that rgchFilter (MAX_PATH) is big enough...

    *pwszFilter = 0;
    cchFilter = 0;
    for (dw = 0; dw < (DWORD)nFilters; dw++)
    {
        cch = LoadStringReplaceSpecialW(rgidsFilter[dw], &pwszFilter[cchFilter], MAX_PATH);
        Assert(cch);
        cchFilter += cch-1; // -1 as each filter is double null terminated
    }
}

void AthFormatSizeK(DWORD dw, LPTSTR szOut, UINT uiBufSize)
{
    TCHAR   szFmt[CCHMAX_STRINGRES];
    TCHAR   szBuf[CCHMAX_STRINGRES];

    AthLoadString(idsFormatK, szFmt, ARRAYSIZE(szFmt));
    if (dw == 0)
        wsprintf(szBuf, szFmt, 0);
    else if (dw <= 1024)
        wsprintf(szBuf, szFmt, 1);
    else
        wsprintf(szBuf, szFmt, (dw + 512) / 1024);
    lstrcpyn(szOut, szBuf, uiBufSize);
}




void GetDigitalIDs(IImnAccount *pCertAccount)
{
    HRESULT hr;
    TCHAR   szTemp[INTERNET_MAX_URL_LENGTH];
    TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
    DWORD   cchOut = ARRAYSIZE(szURL);
    CHAR    szIexplore[MAX_PATH];

    if (FAILED(hr = URLSubLoadStringA(idsHelpMSWebCertSubName, szTemp, ARRAYSIZE(szTemp), URLSUB_ALL, pCertAccount)) ||
        FAILED(hr = UrlEscape(szTemp, szURL, &cchOut, URL_ESCAPE_SPACES_ONLY)))
        hr = URLSubLoadStringA(idsHelpMSWebCert, szURL, ARRAYSIZE(szURL), URLSUB_ALL, pCertAccount);

    // NOTE: we shellexec iexplore.exe here NOT the default handler for http://
    //       links. We have to make sure we launch this link with IE even if
    //       netscape is the browser. see georgeh for explanation of why.
    if (SUCCEEDED(hr) && GetExePath(c_szIexploreExe, szIexplore, ARRAYSIZE(szIexplore), FALSE))
        ShellExecute(NULL, "open", szIexplore, szURL, NULL, SW_SHOWNORMAL);
}

BOOL FGetSelectedCachedMsg(IMsgContainer *pIMC, HWND hwndList, BOOL fSecure, LPMIMEMESSAGE *ppMsg)
{
    int     iSel;
    BOOL    fCached = FALSE;
    
    // Get the selected article header from the list view
    iSel = ListView_GetFirstSel(hwndList);
    if (-1 != iSel)
    {
        Assert(pIMC);
        if (pIMC->HasBody(iSel))
            pIMC->GetMsgByIndex(iSel, ppMsg, NULL, &fCached, FALSE, fSecure);
    }
    return fCached;
}

//---------------------------------------------------------------------------
// Cached Password Support
//---------------------------------------------------------------------------


//-----------------
// Data Structures
//-----------------
typedef struct tagCACHED_PASSWORD {
    DWORD dwPort;
    char szServer[CCHMAX_SERVER_NAME];
    char szUsername[CCHMAX_PASSWORD];
    char szPassword[CCHMAX_PASSWORD];
    struct tagCACHED_PASSWORD *pNext;
} CACHED_PASSWORD;


//------------------
// Static Variables
//------------------
static CACHED_PASSWORD *s_pPasswordList = NULL;

//***************************************************************************
// Function: SavePassword
//
// Purpose:
//   This function saves a password for later retrieval using GetPassword.
// It allows OE to cache passwords for the session in order to avoid asking
// a user for his password more than once. If the given password has already
// been cached, this function replaces the old password with the new password.
// It is assumed that a password's recipient may be uniquely identified
// by servername and port number.
//
// Arguments:
//   DWORD dwPort [in] - the port number of the server we are trying to
//     connect to. This allows us to keep separate passwords for SMTP and
//     POP/IMAP servers on the same machine.
//   LPSTR pszServer [in] - the server name for which the password was
//     supplied. Server names are treated as case-insensitive.
//   LPSTR pszUsername [in] - the username for which the password was supplied.
//   LPSTR pszPassword [in] - the password for this server and port number.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT SavePassword(DWORD dwPort, LPSTR pszServer, LPSTR pszUsername, LPSTR pszPassword)
{
    CACHED_PASSWORD *pExisting;
    HRESULT hrResult = S_OK;

    EnterCriticalSection(&s_csPasswordList);

    // Check if we already have a cached password entry for this server
    pExisting = s_pPasswordList;
    while (NULL != pExisting) 
    {
        if (dwPort == pExisting->dwPort &&
            0 == lstrcmpi(pszServer, pExisting->szServer) &&
            0 == lstrcmp(pszUsername, pExisting->szUsername))
            break;

        pExisting = pExisting->pNext;
    }

    if (NULL == pExisting) 
    {
        CACHED_PASSWORD *pNewPassword;

        // Insert new password at head of linked list
        pNewPassword = new CACHED_PASSWORD;
        if (NULL == pNewPassword) 
        {
            hrResult = E_OUTOFMEMORY;
            goto exit;
        }

        pNewPassword->dwPort = dwPort;
        lstrcpyn(pNewPassword->szServer, pszServer, sizeof(pNewPassword->szServer));
        lstrcpyn(pNewPassword->szUsername, pszUsername, sizeof(pNewPassword->szUsername));
        lstrcpyn(pNewPassword->szPassword, pszPassword, sizeof(pNewPassword->szPassword));
        pNewPassword->pNext = s_pPasswordList;

        s_pPasswordList = pNewPassword;
    }
    else
        // Replace existing cached value
        lstrcpyn(pExisting->szPassword, pszPassword, sizeof(pExisting->szPassword));

exit:
    LeaveCriticalSection(&s_csPasswordList);
    return hrResult;
} // SavePassword



//***************************************************************************
// Function: GetPassword
//
// Purpose:
//   This function retrieves a password previously saved using SavePassword.
//
// Arguments:
//   DWORD dwPort [in] - the port number of the server we are trying to
//     connect to. This allows us to keep separate passwords for SMTP and
//     POP/IMAP servers on the same machine.
//   LPSTR pszServer [in] - the server name which we are trying to connect to.
//     Server names are treated as case-insensitive.
//   LPSTR pszUsername [in] - the username which we are trying to connect for.
//   LPSTR pszPassword [out] - if successful, the function returns the password
//     for the given server and port number here. If the caller only wants to
//     check if a password is cached, he may pass in NULL.
//   DWORD dwSizeOfPassword [in] - the size of the buffer pointed to by
//     pszPassword, to avoid overflow.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT GetPassword(DWORD dwPort, LPSTR pszServer, LPSTR pszUsername,
                    LPSTR pszPassword, DWORD dwSizeOfPassword)
{
    HRESULT hrResult = E_FAIL;
    CACHED_PASSWORD *pCurrent;

    EnterCriticalSection(&s_csPasswordList);

    // Traverse the linked list looking for password
    pCurrent = s_pPasswordList;
    while (NULL != pCurrent) 
    {
        if (dwPort == pCurrent->dwPort &&
            0 == lstrcmpi(pszServer, pCurrent->szServer) &&
            0 == lstrcmp(pszUsername, pCurrent->szUsername)) 
        {
            if (NULL != pszPassword && 0 != dwSizeOfPassword)
                lstrcpyn(pszPassword, pCurrent->szPassword, dwSizeOfPassword);

            hrResult = S_OK;
            goto exit;
        }

        pCurrent = pCurrent->pNext;
    } // while

exit:
    LeaveCriticalSection(&s_csPasswordList);
    return hrResult;
} // GetPassword



//***************************************************************************
// Function: DestroyPasswordList
// Purpose:
//   This function deallocates all cached passwords saved using SavePassword.
//***************************************************************************
void DestroyPasswordList(void)
{
    CACHED_PASSWORD *pCurrent;

    EnterCriticalSection(&s_csPasswordList);

    pCurrent = s_pPasswordList;
    while (NULL != pCurrent) 
    {
        CACHED_PASSWORD *pDeleteMe;

        pDeleteMe = pCurrent;
        pCurrent = pCurrent->pNext;
        delete pDeleteMe;
    } // while
    s_pPasswordList = NULL;

    LeaveCriticalSection(&s_csPasswordList);

} // DestroyPasswordList

HRESULT CALLBACK FreeAthenaDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt)
{
    // Loop through the data and free it all
    if (pDataObjInfo)
    {
        for (DWORD i = 0; i < celt; i++)
        {
            SafeMemFree(pDataObjInfo[i].pData);
        }
        SafeMemFree(pDataObjInfo);    
    }
    return S_OK;
}

HRESULT _IsSameObject(IUnknown* punk1, IUnknown* punk2)
{
    IUnknown* punkI1;
    HRESULT hres = punk1->QueryInterface(IID_IUnknown, (LPVOID*)&punkI1);
    if (FAILED(hres)) 
    {
        Assert(0);
        return hres;
    }

    IUnknown* punkI2;
    hres = punk2->QueryInterface(IID_IUnknown, (LPVOID*)&punkI2);
    if (SUCCEEDED(hres)) 
    {
        hres = (punkI1 == punkI2) ? S_OK : S_FALSE;
        punkI2->Release();
    } 
    else 
    {
        Assert(0);
    }
    punkI1->Release();
    return hres;
}

BOOL FileExists(TCHAR *szFile, BOOL fNew)
{
    WIN32_FIND_DATA fd;
    HANDLE hnd;
    BOOL fRet;

    fRet = FALSE;

    hnd = FindFirstFile(szFile, &fd);
    if (hnd != INVALID_HANDLE_VALUE)
    {
        FindClose(hnd);

        if (fNew)
            fRet = TRUE;
        else
            fRet = (0 == (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));
    }

    return(fRet);
}

BOOL FIsSubDir(LPCSTR szOld, LPCSTR szNew)
{
    BOOL fRet;
    int cchNew, cchOld;

    Assert(szOld != NULL);
    Assert(szNew != NULL);

    cchOld = lstrlen(szOld);
    cchNew = lstrlen(szNew);

    fRet = (cchNew > cchOld &&
        szNew[cchOld] == '\\' &&
        0 == StrCmpNI(szOld, szNew, cchOld));

    return(fRet);
}

BOOL CALLBACK EnumThreadCB(HWND hwnd, LPARAM lParam);

#define SetMenuItem(hmenu, id, fOn) EnableMenuItem(hmenu, id, fOn?MF_ENABLED:MF_DISABLED|MF_GRAYED);

HWND GetTopMostParent(HWND hwndChild)
{
    HWND        hwnd=hwndChild;
    LONG_PTR    lStyle;

    if (FALSE == IsWindow(hwndChild))
    {
        goto exit;
    }

    do 
    {
        hwnd = hwndChild;
        
        // Get the style of the current window
        lStyle = GetWindowLongPtr(hwnd, GWL_STYLE);

        // Are we at the top window?
        if (0 == (lStyle & WS_CHILD))
        {
            goto exit;
        }

        // Get the parent of the window
    } while (NULL != (hwndChild = GetParent(hwnd)));    

exit:
    return hwnd;
}


HCURSOR HourGlass()
{
    return SetCursor(LoadCursor(NULL, IDC_WAIT));
}


HRESULT CEmptyList::Show(HWND hwndList, LPTSTR pszString)
{
    // We're already doing a window
    if (m_hwndList)
    {
        Hide();
    }

    // Keep a copy of the listview window handle
    m_hwndList = hwndList;

    if (IS_INTRESOURCE(pszString))
    {
        // If the provided string is actually a resource ID, load it
        m_pszString = AthLoadString(PtrToUlong(pszString), NULL, 0);
    }
    else
    {
        // Otherwise make a copy 
        m_pszString = PszDupA(pszString);
    }

    // Get the header window handle from the listview
    m_hwndHeader = ListView_GetHeader(m_hwndList);

    // Save our this pointer on the listview window
    SetProp(m_hwndList, _T("EmptyListClass"), (HANDLE) this);

    // Subclass the listview so we can steal sizing messages
    if (!m_pfnWndProc)
        m_pfnWndProc = SubclassWindow(m_hwndList, SubclassWndProc);

    // Create our window on top
    if (!m_hwndBlocker)
    {
        m_hwndBlocker = CreateWindow(_T("Static"), _T("Blocker!"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS | SS_CENTER,
                                     0, 0, 10, 10, m_hwndList, 0, g_hInst, NULL);
        Assert(m_hwndBlocker);
    }
    
    // Set the text for the blocker
    SetWindowText(m_hwndBlocker, m_pszString);

    // Set the font for the blocker
    HFONT hf = (HFONT) SendMessage(m_hwndList, WM_GETFONT, 0, 0);
    SendMessage(m_hwndBlocker, WM_SETFONT, (WPARAM) hf, MAKELPARAM(TRUE, 0));

    // Position the blocker
    RECT rcList, rcHead;
    GetClientRect(m_hwndList, &rcList);
    GetClientRect(m_hwndHeader, &rcHead);

    SetWindowPos(m_hwndBlocker, 0, 0, rcHead.bottom, rcList.right,
                 rcList.bottom - rcHead.bottom, SWP_NOACTIVATE | SWP_NOZORDER);

    // Show the thing
    ShowWindow(m_hwndBlocker, SW_SHOW);

    return (S_OK);
}

HRESULT CEmptyList::Hide(void)
{
    // Verify we have the blocker up first
    if (m_pfnWndProc)
    {
        // Hide the window
        ShowWindow(m_hwndBlocker, SW_HIDE);

        // Unsubclass the window
        SubclassWindow(m_hwndList, m_pfnWndProc);

        // Delete the property
        RemoveProp(m_hwndList, _T("EmptyListClass"));

        // Free the string
        SafeMemFree(m_pszString);

        // NULL everything out
        m_pfnWndProc = 0;
        m_hwndList = 0;
    }

    return (S_OK);

}


LRESULT CEmptyList::SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEmptyList* pThis = (CEmptyList *) GetProp(hwnd, _T("EmptyListClass"));
    Assert(pThis);

    switch (uMsg)
    {
        case WM_SIZE:
            if (pThis && IsWindow(pThis->m_hwndBlocker))
            {
                RECT rcHeader;

                GetClientRect(pThis->m_hwndHeader, &rcHeader);
                SetWindowPos(pThis->m_hwndBlocker, 0, 0, 0, LOWORD(lParam), 
                             HIWORD(lParam) - rcHeader.bottom, 
                             SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
                InvalidateRect(pThis->m_hwndBlocker, NULL, FALSE);
            }
            break;

        case WM_CTLCOLORSTATIC:
            if ((HWND) lParam == pThis->m_hwndBlocker)
            {
                if (!pThis->m_hbrBack)
                {
                    pThis->m_hbrBack = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                }
                SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
                return (LRESULT) pThis->m_hbrBack;
            }
            break;

        case WM_SYSCOLORCHANGE:
            if (pThis)
            {
                DeleteObject(pThis->m_hbrBack);
                pThis->m_hbrBack = 0;

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
            }
            break;

        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            if (pThis)
            {
                LRESULT lResult = CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam);

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
                HFONT hf = (HFONT) SendMessage(pThis->m_hwndList, WM_GETFONT, 0, 0);
                SendMessage(pThis->m_hwndBlocker, WM_SETFONT, (WPARAM) hf, MAKELPARAM(TRUE, 0));

                return (lResult);
            }

        case WM_DESTROY:
            {
                if (pThis)
                {
                    WNDPROC pfn = pThis->m_pfnWndProc;
                    pThis->Hide();
                    return (CallWindowProc(pfn, hwnd, uMsg, wParam, lParam));
                }
            }
            break;
    }

    if (pThis)
        return (CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam));

    return 0;
}


BOOL AllocStringFromDlg(HWND hwnd, UINT id, LPTSTR * lplpsz)
{
    UINT cb;
    HWND hwndEdit;
    
    if (*lplpsz)
    {
        MemFree(*lplpsz);
    }
    
    *lplpsz = NULL;
    
    hwndEdit = GetDlgItem(hwnd, id);
    if (hwndEdit == NULL)
        return(TRUE);
    
    cb = Edit_GetTextLength(hwndEdit);
    
    if (cb)
    {
        cb++;   // null terminator
        MemAlloc((LPVOID *) lplpsz, cb * sizeof(TCHAR));
        if (*lplpsz)
        {
            Edit_GetText(hwndEdit, *lplpsz, cb);
            return TRUE;
        }
        else
            return FALSE;
    }
    
    return TRUE;
}


void GetChildRect(HWND hwndDlg, HWND hwndChild, RECT *prc)
{
    RECT    rc;
    POINT   pt;
    
    Assert(IsWindow(hwndDlg)&&IsWindow(hwndChild));
    Assert(GetParent(hwndChild)==hwndDlg);
    Assert(prc);
    GetWindowRect(hwndChild, &rc);
    // a-msadek; Do not check for hwndChild since we already disabled mirroring
    // for Richedit controls
    pt.x= IS_WINDOW_RTL_MIRRORED(hwndDlg)? rc.right : rc.left;
    pt.y=rc.top;
    ScreenToClient(hwndDlg, &pt);
    SetRect(prc, pt.x, pt.y, pt.x+(rc.right-rc.left), pt.y+(rc.bottom-rc.top));
}




void GetEditDisableFlags(HWND hwndEdit, DWORD *pdwFlags)
{
    DWORD   dwFlags=0;

    Assert(pdwFlags);
    *pdwFlags=0;

    // RICHEDIT's
    // Figure out whether the edit has any selection or content
    if(GetFocus()==hwndEdit)
        dwFlags|=edfEditFocus;
    
    if(SendMessage(hwndEdit, EM_SELECTIONTYPE, 0, 0)!=SEL_EMPTY)
    {
        dwFlags |= edfEditHasSel;
        if(!FReadOnlyEdit(hwndEdit))
            dwFlags |= edfEditHasSelAndIsRW;
    }

    if (Edit_CanUndo(hwndEdit))
        dwFlags |= edfUndo;
    if (SendMessage(hwndEdit, EM_CANPASTE, 0, 0))
        dwFlags |= edfPaste;

    *pdwFlags=dwFlags;
}




void EnableDisableEditToolbar(HWND hwndToolbar, DWORD dwFlags)
{
    SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_CUT, 
                             MAKELONG(dwFlags&edfEditHasSelAndIsRW,0));
    SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_COPY, 
                             MAKELONG(dwFlags&edfEditHasSel,0));
    SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_PASTE, 
                             MAKELONG(dwFlags&edfPaste,0));
    SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_UNDO, 
                             MAKELONG(dwFlags&edfUndo,0));
}


void EnableDisableEditMenu(HMENU hmenuEdit, DWORD dwFlags)
{
    if(!hmenuEdit)
        return;

    SetMenuItem(hmenuEdit, ID_UNDO, dwFlags&edfUndo);
    SetMenuItem(hmenuEdit, ID_CUT, dwFlags&edfEditHasSelAndIsRW);
    SetMenuItem(hmenuEdit, ID_COPY, dwFlags&edfEditHasSel);
    SetMenuItem(hmenuEdit, ID_PASTE, dwFlags&edfPaste);
    SetMenuItem(hmenuEdit, ID_SELECT_ALL, dwFlags&edfEditFocus);
}

void StopBlockingPaints(HWND hwndBlock)
{
    if (hwndBlock)
        DestroyWindow(hwndBlock);
}

LRESULT CALLBACK BlockingWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg==WM_PAINT)
    {
        PAINTSTRUCT ps;

        BeginPaint(hwnd, &ps);
        EndPaint(hwnd, &ps);
        return 1;
    }
    if(msg==WM_ERASEBKGND)
        return 1;
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HWND HwndStartBlockingPaints(HWND hwnd)
{
    WNDCLASS    wc;
    RECT        rc;
    HWND        hwndBlock;

    // Create WNDCLASS for Paint Block
    if (!GetClassInfo(g_hInst, c_szBlockingPaintsClass, &wc))
    {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.hInstance = g_hInst;
        wc.lpfnWndProc = BlockingWndProc;
        wc.hCursor = LoadCursor(NULL, IDC_WAIT);
        wc.lpszClassName = c_szBlockingPaintsClass;
        if (!RegisterClass(&wc))
            return NULL;
    }

    GetWindowRect(hwnd, &rc);

    if(hwndBlock = CreateWindow(c_szBlockingPaintsClass, NULL,
                                 WS_POPUP, rc.left, rc.top,
                                 rc.right - rc.left, rc.bottom - rc.top,
                                 hwnd, NULL, g_hInst, NULL))
        ShowWindow(hwndBlock, SW_SHOWNA);
    return hwndBlock;
}


void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
#ifdef DEBUG
    if(fActive)
        DOUTL(4, "Setting focus to 0x%x", *phwnd);
    else
        DOUTL(4, "Focus was on 0x%x", *phwnd);
#endif
}


void DoToolbarDropdown(HWND hwnd, LPNMHDR lpnmh, HMENU hmenu)
{
    RECT rc;
    DWORD dwCmd;
    NMTOOLBAR *ptbn = (NMTOOLBAR *) lpnmh;

    rc = ptbn->rcButton;
    MapWindowRect(lpnmh->hwndFrom, HWND_DESKTOP, &rc);

    dwCmd = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_LEFTALIGN,
                             rc.left, rc.bottom, hwnd, NULL);

    if (dwCmd)
        PostMessage(hwnd, WM_COMMAND, dwCmd, 0);
}


HWND FindModalOwner()
{
    HWND    hwndPopup = NULL;
    HWND    hwnd;
    DWORD   dwThreadId = GetCurrentThreadId();

    //  Check the windows in Z-Order to find one that belongs to this
    //  task.
    hwnd = GetLastActivePopup(GetActiveWindow());
    while (IsWindow(hwnd) && IsWindowVisible(hwnd))
    {
        if (GetWindowThreadProcessId(hwnd, NULL) == dwThreadId)
        {
            hwndPopup = hwnd;
            break;
        }
        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);    
    }

    return hwndPopup;
}

//
//  FUNCTION:   FreeMessageInfo
//
//  PURPOSE:    Free all of the memory in a MESSAGEINFO structure.
//              All non-allocated pointers should be null on entry.
//              Freed pointers will be nulled on return.  The 
//              pMsgInfo is not freed.
//  
//  PARAMETERS:
//      pMsgInfo   - Pointer to an LPMESSAGEINFO structure.
//
//  RETURN VALUE:
//      ignored
//    
void FreeMessageInfo(LPMESSAGEINFO pMsgInfo)
{
    SafeMemFree(pMsgInfo->pszMessageId);
    SafeMemFree(pMsgInfo->pszSubject);
    SafeMemFree(pMsgInfo->pszFromHeader);
    SafeMemFree(pMsgInfo->pszReferences);
    SafeMemFree(pMsgInfo->pszXref);
    SafeMemFree(pMsgInfo->pszServer);
    SafeMemFree(pMsgInfo->pszDisplayFrom);
    SafeMemFree(pMsgInfo->pszEmailFrom);
    SafeMemFree(pMsgInfo->pszDisplayTo);
    SafeMemFree(pMsgInfo->pszEmailTo);
    SafeMemFree(pMsgInfo->pszUidl);
    SafeMemFree(pMsgInfo->pszPartialId);
    SafeMemFree(pMsgInfo->pszForwardTo);
    SafeMemFree(pMsgInfo->pszAcctName);
    SafeMemFree(pMsgInfo->pszAcctId);
    SafeMemFree(pMsgInfo->pszUrlComponent);
    SafeMemFree(pMsgInfo->pszFolder);
    SafeMemFree(pMsgInfo->pszMSOESRec);
}


//
//  FUNCTION:   Util_EnumFiles()
//
//  PURPOSE:    Enumerates files in a directory that match a wildcard
//
//  PARAMETERS:
//      <in> pszDir     - Handle of a window we can display UI over.
//      <in> pszMatch   - wildcard to match (*.nch)
//
//  RETURN VALUE:
//      double-null terminated list of filenames
//
LPWSTR Util_EnumFiles(LPCWSTR pwszDir, LPCWSTR pwszMatch)
{
    // Locals
    WCHAR               wszSearchPath[MAX_PATH];
    LPWSTR              pwszFiles=NULL;
    WIN32_FIND_DATAW    rfd;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    ULONG               iFiles = 0,
                        cbFileName,
                        cbFiles = 0;
    HRESULT             hr = S_OK;

    // Check Params
    Assert(pwszDir);
    Assert(pwszMatch);

    // Make Serarch Path
    AthwsprintfW(wszSearchPath, ARRAYSIZE(wszSearchPath), c_wszPathWildExtFmt, pwszDir, pwszMatch);

    // Build list of file names
    hFind = FindFirstFileWrapW(wszSearchPath, &rfd);

    // Good ...
    while (hFind != INVALID_HANDLE_VALUE)
    {
        // Get Length of file name
        cbFileName = (lstrlenW(rfd.cFileName) + 1)*sizeof(WCHAR);

        // Add onto cbFiles
        cbFiles += cbFileName;

        // Realloc pszFiles
        // sizeof(WCHAR) to handle the final double null
        IF_NULLEXIT(MemRealloc((LPVOID *)&pwszFiles, cbFiles+sizeof(WCHAR)));

        // Copy String - include null terminator
        CopyMemory(pwszFiles + iFiles, rfd.cFileName, cbFileName);

        // Increment iFiles
        iFiles += cbFileName/sizeof(WCHAR);

        // Find Next
        if (FindNextFileWrapW(hFind, &rfd) == FALSE)
        {
            FindClose (hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    // Double null terminator at the end
    if (pwszFiles)
        *(pwszFiles + iFiles) = L'\0';

exit:
    // Cleanup
    if (hFind != INVALID_HANDLE_VALUE)
        FindClose (hFind);

    if (FAILED(hr))
        SafeMemFree(pwszFiles);

    // Done
    return pwszFiles;
}

//
//  FUNCTION:   GetDefaultNewsServer()
//
//  PURPOSE:    Returns the id of the user's default news server.
//
//  PARAMETERS:
//      pszServer - Pointer to the string where the server account id should
//                  be returned.
//      cchMax    - Size of the string pszServer.
//
HRESULT GetDefaultNewsServer(LPTSTR pszServerId, DWORD cchMax)
{
    IImnAccount* pAcct;
    HRESULT   hr;
    ULONG cSrv;

    if (SUCCEEDED(hr = g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pAcct)))
    {
        hr = pAcct->GetPropSz(AP_ACCOUNT_ID, pszServerId, cchMax);
        pAcct->Release();
    }

    Assert(!FAILED(hr) || (!FAILED(g_pAcctMan->GetAccountCount(ACCT_NEWS, &cSrv)) && cSrv == 0));

    return(hr);
}



BOOL WINAPI EnumTopLevelWindows(HWND hwnd, LPARAM lParam)
{
    HWNDLIST *pHwndList = (HWNDLIST *)lParam;

    // Add the window to the list only if it is active and visible
    // if ETW_OE_WINDOWS_ONLY is set, only add registered OE windows to the list
    // [PaulHi] 6/4/99  Raid 76713
    // We need to also enumerate disabled windows, for the enumeration that
    // closes them.  Otherwise they will remain open and the user will be
    // unable to close them.
    if (/* IsWindowVisible(hwnd) && IsWindowEnabled(hwnd) && */
        (!(pHwndList->dwFlags & ETW_OE_WINDOWS_ONLY) || GetProp(hwnd, c_szOETopLevel)))
    {
        //  If pHwndList->cAlloc is 0 then we are only counting
        //  the active windows
        if (pHwndList->cAlloc)
        {
            Assert(pHwndList->cHwnd < pHwndList->cAlloc);
            pHwndList->rgHwnd[pHwndList->cHwnd] = hwnd;
        }
        
        pHwndList->cHwnd++;
    }

    return TRUE;
}


HRESULT EnableThreadWindows(HWNDLIST *pHwndList, BOOL fEnable, DWORD dwFlags, HWND hwndExcept)
{
    if (fEnable)
    {
        //  Enable keyboard and mouse input on the list of windows
        for (int i = 0; i < pHwndList->cHwnd; i++)
        {
            if (hwndExcept != pHwndList->rgHwnd[i])
            {
                if (dwFlags & ETW_OE_WINDOWS_ONLY)
                    SendMessage(pHwndList->rgHwnd[i], WM_OE_ENABLETHREADWINDOW, TRUE, 0);
                else
                    EnableWindow(pHwndList->rgHwnd[i], TRUE);
            }
        }
        if (pHwndList->rgHwnd)
            MemFree(pHwndList->rgHwnd);

        ZeroMemory(pHwndList, sizeof(HWNDLIST));
        return S_OK;
    }
    else
    {

        ZeroMemory(pHwndList, sizeof(HWNDLIST));

        pHwndList->dwFlags = dwFlags;

        //  Count the number of active and visible windows
        EnumThreadWindows(GetCurrentThreadId(), EnumTopLevelWindows, (DWORD_PTR)pHwndList);

        //  Allocate space for the window list
        if (pHwndList->cHwnd)
        {
            if (!MemAlloc((LPVOID*)&pHwndList->rgHwnd, pHwndList->cHwnd * sizeof(HWND)))
                return E_OUTOFMEMORY;
        
            pHwndList->cAlloc = pHwndList->cHwnd;
            pHwndList->cHwnd = 0;
        }

        //  List the active and visible windows
        EnumThreadWindows(GetCurrentThreadId(), EnumTopLevelWindows, (DWORD_PTR)pHwndList);

        //  Disable keyboard and mouse input on the active and visible windows
        for (int i = 0; i < pHwndList->cHwnd; i++)
        {
            if ( (hwndExcept != pHwndList->rgHwnd[i]) &&
                 IsWindowVisible(pHwndList->rgHwnd[i]) && IsWindowEnabled(pHwndList->rgHwnd[i]) )
            {
                if (dwFlags & ETW_OE_WINDOWS_ONLY)
                    SendMessage(pHwndList->rgHwnd[i], WM_OE_ENABLETHREADWINDOW, FALSE, 0);
                else
                    EnableWindow(pHwndList->rgHwnd[i], FALSE);
            }
        }

        return S_OK;
    }
}

void ActivatePopupWindow(HWND hwnd)
{
    HWND    hwndOwner;

    // set the popup to be active
    SetActiveWindow(hwnd);
    
    // walk the owner chain, and z-order the windows behind it
    while(hwndOwner = GetWindow(hwnd, GW_OWNER))
    {
        SetWindowPos(hwndOwner, hwnd, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOOWNERZORDER);  
        hwnd = hwndOwner;
    }
}


HRESULT GetOEUserName(BSTR *pbstr)
{
    TCHAR       rgch[CCHMAX_STRINGRES];
    HRESULT     hr=E_FAIL;
    LPCSTR      pszName;
    IImnAccount *pAccount;

    Assert (pbstr);

    *pbstr=NULL;

    // get multi-user name, if applicable
    pszName = MU_GetCurrentIdentityName();
    if (pszName && *pszName)
        hr = HrLPSZToBSTR(pszName, pbstr);
    else
    {
        if (g_pAcctMan && 
            g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)==S_OK)
        {
            if (pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, rgch, ARRAYSIZE(rgch))==S_OK && *rgch)
                hr = HrLPSZToBSTR(rgch, pbstr);
            
            pAccount->Release();
        }
    }
    return hr;
}
HRESULT CloseThreadWindows(HWND hwndExcept, DWORD uiThreadId)
{
    HWNDLIST HwndList = {0};
    
    //  Count the number of active and visible windows
    HwndList.dwFlags = ETW_OE_WINDOWS_ONLY;
    EnumThreadWindows(uiThreadId, EnumTopLevelWindows, ((DWORD_PTR) &HwndList));
    
    //  Allocate space for the window list
    if (HwndList.cHwnd)
    {
        if (!MemAlloc((LPVOID*)&(HwndList.rgHwnd), HwndList.cHwnd * sizeof(HWND)))
            return E_OUTOFMEMORY;
        
        HwndList.cAlloc = HwndList.cHwnd;
        HwndList.cHwnd = 0;
    }
    
    //  List the active and visible windows
    EnumThreadWindows(uiThreadId, EnumTopLevelWindows, ((DWORD_PTR)&HwndList));
    
    //  Close all OE top level windows
    for (int i = 0; i < HwndList.cHwnd; i++)
    {
        if (hwndExcept != HwndList.rgHwnd[i])
        {
            SendMessage(HwndList.rgHwnd[i], WM_CLOSE, 0, 0);
        }
    }

    MemFree(HwndList.rgHwnd);
    
    return S_OK;
}

BOOL HideHotmail()
{
    int cch;
    DWORD dw, cb, type;
    char sz[8];

    cch = LoadString(g_hLocRes, idsHideHotmailMenu, sz, ARRAYSIZE(sz));
    if (cch == 1 && *sz == '1')
        return(TRUE);

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    return(TRUE);
}

BOOL FIsIMAPOrHTTPAvailable(VOID)
{
    BOOL                fRet = FALSE;
    IImnEnumAccounts *  pEnumAcct = NULL;
    IImnAccount *       pAccount = NULL;

    // Get the account enumerator
    Assert(g_pAcctMan);
    if (FAILED(g_pAcctMan->Enumerate(SRV_HTTPMAIL | SRV_IMAP, &pEnumAcct)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Do we have any accounts?
    if ((SUCCEEDED(pEnumAcct->GetNext(&pAccount))) && (NULL != pAccount))
    {
        fRet = TRUE;
    }

exit:
    SafeRelease(pAccount);
    SafeRelease(pEnumAcct);
    return fRet;
}

// HACKHACK [neilbren]
// A recent public header change wrapped some CALENDAR constants from winnls.h
// in a WINVER >= 5.  It's too late to change our WINVER, so we'll manually 
// define these - a problem waiting to happen :-(
#ifndef CAL_GREGORIAN_ARABIC
#define CAL_GREGORIAN_ARABIC           10     // Gregorian Arabic calendar
#endif

#ifndef CAL_GREGORIAN_XLIT_ENGLISH
#define CAL_GREGORIAN_XLIT_ENGLISH     11     // Gregorian Transliterated English calendar
#endif

#ifndef CAL_GREGORIAN_XLIT_FRENCH
#define CAL_GREGORIAN_XLIT_FRENCH      12     // Gregorian Transliterated French calendar
#endif

BOOL IsBiDiCalendar(void)
{
    TCHAR chCalendar[32];
    CALTYPE defCalendar;
    static BOOL bRet = (BOOL)(DWORD)-1;

    if (bRet != (BOOL)(DWORD)-1)
    {
        return bRet;
    }

    bRet = FALSE;

    //
    // Let's verify the calendar type whether it's gregorian or not.
    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      (TCHAR *) &chCalendar[0],
                      ARRAYSIZE(chCalendar)))
    {
        defCalendar = StrToInt((TCHAR *)&chCalendar[0]);
        
        if ((defCalendar == CAL_HIJRI) ||
            (defCalendar == CAL_HEBREW) ||
            (defCalendar == CAL_GREGORIAN_ARABIC) ||
            (defCalendar == CAL_GREGORIAN_XLIT_ENGLISH) ||     
            (defCalendar == CAL_GREGORIAN_XLIT_FRENCH))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}


LPSTR PszAllocResUrl(LPSTR pszRelative)
{
    TCHAR   rgch[MAX_PATH];
    LPSTR   psz;

    *rgch = 0;

    GetModuleFileName(g_hLocRes, rgch, MAX_PATH);

    psz = PszAllocA(lstrlen(rgch) + lstrlen(pszRelative) + 8 ); //+8 "res:///0"
    if (psz)
        wsprintf(psz, "res://%s/%s", rgch, pszRelative);
    
    return psz;
}

//
//  If you are calling this function and you use the result to draw text, you
//  must use a function that supports font substitution (DrawTextWrapW, ExtTextOutWrapW).
//
BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags)
{
    RECT    rect = {0};
    int     rc;

    rc = DrawTextWrapW(hdc, lpwString, cchString, &rect, DT_CALCRECT | dwFlags);
    
    lpSize->cx = rect.right - rect.left + 1;
    lpSize->cy = rect.bottom - rect.top + 1;

    return((BOOL)rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\util.h ===
#pragma once

#ifndef __UTIL_H__
#define __UTIL_H__

////////////////////////////////////////////////////////
// Depends on....

typedef struct tagOPTPAGES OPTPAGES;
typedef struct tagOPTINFO OPTINFO;
typedef struct INETSERVER __RPC_FAR *LPINETSERVER;

interface IMimeMessage;
typedef IMimeMessage *LPMIMEMESSAGE;
interface IExplorerToolbar;
interface IMsgContainer;

////////////////////////////////////////////////////////
// Begin 

VOID DoReadme(HWND hwndOwner);

typedef VOID (*PVOIDFN)(VOID);

#define DoAboutAthena(hwnd, idIcon) \
    DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddVersion), hwnd, (DLGPROC)AboutAthena, (LPARAM) idIcon);
LRESULT CALLBACK AboutAthena(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp);

#define TOOLBAR_BKGDCLR     RGB(0xff, 0, 0xff)

#define __TOOLBAR_SEP__ {0,0,TBSTATE_ENABLED,TBSTYLE_SEP,{0,0},0,0}
#define BUTTONCOUNT(tb) (sizeof(tb) / sizeof(TBBUTTON))


UINT    RegGetKeyNumbers(HKEY hkRegDataBase, const TCHAR *szRegSection);
BOOL    RegGetKeyNameFromIndex(HKEY hkRegDataBase, const TCHAR *szRegSection, UINT Index,
								TCHAR * szBuffer, DWORD *pcbBuffer);

#ifdef TIMING
void ResetTimingInfo();
void OutputTimingInfo(LPTSTR szOutputText);
#else
#define ResetTimingInfo()
#define OutputTimingInfo(x)
#endif //TIMING

#define SPLITBAR_THICKNESS  6

#define IDS_IMAGEMASK   0x80000000
BOOL SetupLVColumns(HWND, UINT, const int *, const int *, const int *);

ULONG        CbPidl(LPCITEMIDLIST pidl);
LPVOID       PidlAlloc(ULONG cb);
VOID         PidlFree(LPVOID pv);
LPITEMIDLIST PidlDupIdList(LPCITEMIDLIST pidl, LPDWORD pcbPidl=NULL);
LPITEMIDLIST PidlDupFirstId(LPCITEMIDLIST pidl);
LPITEMIDLIST PidlDupParentIdList(LPCITEMIDLIST pidl);
LPITEMIDLIST PidlCombineIdLists(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlLeaf);
#ifdef DEBUG
LPITEMIDLIST NEXTID_C(LPCITEMIDLIST pidl);  
void DumpPidl(LPCITEMIDLIST pidl, LPSTR szComment);
#else
#define DumpPidl(x,y)
#endif

#define AthMessageBox(hwnd, pszT, psz1, psz2, fu) MessageBoxInst(g_hLocRes, hwnd, pszT, psz1, psz2, fu)
#define AthMessageBoxW(hwnd, pwszT, pwsz1, pwsz2, fu) MessageBoxInstW(g_hLocRes, hwnd, pwszT, pwsz1, pwsz2, fu, LoadStringWrapW, MessageBoxWrapW)
void AthErrorMessage(HWND hwnd, LPTSTR pszTitle, LPTSTR pszError, HRESULT hrDetail);
void AthErrorMessageW(HWND hwnd, LPWSTR pwszTitle, LPWSTR pwszError, HRESULT hrDetail);

#define AthFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags) \
        CchFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags, \
        GetDateFormatWrapW, GetTimeFormatWrapW, GetLocaleInfoWrapW)
//
// string resource crap
//

int LoadStringReplaceSpecial(UINT id, LPTSTR sz, int cch);
int LoadStringReplaceSpecialW(UINT id, LPWSTR wsz, int cch);
LPTSTR AthLoadString(UINT id, LPTSTR lpBuffer, int nBufferMax); 
LPWSTR AthLoadStringW(UINT id, LPWSTR sz, int cch);

#ifdef YST
#undef LoadString
#define LoadString(_hinst, _id, _sz, _cch)  _LoadString(_id, _sz, _cch)
int _LoadString(UINT id, LPTSTR lpBuffer, int nBufferMax);

#undef DialogBox
#define DialogBox(_hinst, _sz, _hwnd, _func)    _DialogBox(_sz, _hwnd, _func)
int _DialogBox(LPCTSTR lpTemplate, HWND hwnd, DLGPROC func);

#undef DialogBoxIndirect
#define DialogBoxIndirect(_hinst, lpTemplate,  hWndParent, lpDialogFunc) _DialogBoxIndirect(lpTemplate,  hWndParent, lpDialogFunc)
int _DialogBoxIndirect(LPCTSTR lpTemplate, HWND hwnd, DLGPROC lpDialogFunc);

#undef DialogBoxIndirectParam
#define DialogBoxIndirectParam(_hinst, lpTemplate,  hWndParent, lpDialogFunc, dwParam) _DialogBoxIndirectParam(lpTemplate,  hWndParent, lpDialogFunc, dwParam)
int _DialogBoxIndirectParam(LPCTSTR lpTemplate, HWND hwnd, DLGPROC lpDialogFunc, LPARAM dwParam);

#undef DialogBoxParam
#define DialogBoxParam(x, y, z, m, n)   _DialogBoxParam(y, z, m, n)
int _DialogBoxParam(LPCTSTR lpTemplate, HWND hwnd, DLGPROC func, LPARAM lParam);

#undef CreateDialog
#define CreateDialog(_hinst, _sz, _hwnd, _func)     _CreateDialog(_sz, _hwnd, _func)
HWND _CreateDialog(LPCTSTR lpTemplate, HWND hwnd, DLGPROC func);

#undef CreateDialogIndirect
#undef CreateDialogIndirectParam

#undef CreateDialogParam
#define CreateDialogParam(_hinst, _sz, _hwnd, _func, _param)   _CreateDialogParam(_sz, _hwnd, _func, _param)
HWND _CreateDialogParam(LPCTSTR lpTemplate, HWND hwnd, DLGPROC func, LPARAM lParam);

#undef LoadMenu
#define LoadMenu(_hinst, _sz)   _LoadMenu(_sz)
HMENU _LoadMenu(LPCTSTR lpMenuName);

#undef LoadAccelerators
#define LoadAccelerators(hInst, y)  _LoadAccelerators(y) 
HACCEL _LoadAccelerators(LPCTSTR lpTableName);

#undef ImageList_LoadImage
#define ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, uType, uFlags) _ImageList_LoadImage(lpbmp, cx, cGrow, crMask, uType, uFlags)
HIMAGELIST _ImageList_LoadImage(LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
#endif // YST


HBITMAP FAR PASCAL CreateDitherBitmap(COLORREF crFG, COLORREF crBG);
HBRUSH FAR PASCAL CreateDitherBrush(COLORREF crFG, COLORREF crBG);

LRESULT DoDontShowMeAgainDlg(HWND hwndOwner, LPCSTR pszRegString, LPTSTR pszTitle, LPTSTR pszMessage, UINT uType);
DWORD DwGetDontShowAgain (LPCSTR pszRegString);
VOID SetDontShowAgain (DWORD dwDontShow, LPCSTR pszRegString);


void nyi(LPSTR lpsz);

BOOL FNewMessage(HWND hwnd, BOOL fModal, BOOL fNoStationery, BOOL fNews, FOLDERID folderID, IUnknown *pUnkPump);

// Context-sensitive Help utility.
typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);

enum
{
    iLeft = 0,
    iTop,
    iRight,
    iBottom
};


// from athena file macros, used when saving files, dragdrop etc.
#define FIsDirectory(szFile)    PathIsDirectoryA(szFile)
#define MAX_CHARS_FOR_NUM       20

// ********* WARNING THESE ARE NOT READY FOR PRIME TIME USE *********//
HRESULT CreateLink(LPWSTR pwszPathObj,  LPWSTR pwszPathLink, LPWSTR pwszDesc);
void    GetDisplayNameForFile(LPWSTR pwszPathName, LPWSTR pwszDisplayName);
HRESULT CreateNewShortCut(LPWSTR pwszPathName, LPWSTR pwszLinkPath, DWORD cchLink);
HRESULT ScGetTempFileName(LPTSTR szOrgName, LPTSTR szTempName, BOOL fPrompt, BOOL fLink);
LPTSTR SzFileNameFromPathName( LPTSTR szPathName );

void AddWelcomeMessage(IMessageFolder *pFolder);

HRESULT HrSaveMessageToFile(HWND hwnd, LPMIMEMESSAGE pMsg, LPMIMEMESSAGE pSecMsg, BOOL fNews, BOOL fCanBeDirty);
BOOL FIsSubDir(LPCSTR szOld, LPCSTR szNew);

VOID OnHelpGoto(HWND hwnd, UINT idh);
VOID OnMailGoto(HWND);
VOID OnNewsGoto(HWND);
VOID OpenClient(HWND, LPCTSTR);
VOID OnBrowserGoto(HWND hwnd, LPCTSTR szRegPage, UINT idDefault);
BOOL GetClientCmdLine(LPCTSTR szClient, LPTSTR szCmdLine, int cch);

//////////////////////////////////////////////////////////////////////////////
// Shell Toolbar Integration Stuff
//
// The arrays of buttons that we can integrate with the shell are defined in
// cbarrays.cpp and are exported here.  The views call Util_MergeToolbarButtons()
// to merge the correct array of buttons onto the shell's toolbar.
//

#if 0
// 
// TOOLBARARRAYINFO - Contains the various arrays of default and extra toolbar
//                    buttons along with the array of strings for those buttons.
typedef struct tagTOOLBARARRAYINFO {
    const TBBUTTON  *rgDefButtons;
    DWORD            cDefButtons;
    const TBBUTTON  *rgExtraButtons;
    DWORD            cExtraButtons;
    const DWORD     *rgidsButtons;
    DWORD            cidsButtons;
    LPCTSTR          pszRegKey;
    LPCTSTR          pszRegValue;
} TOOLBARARRAYINFO, *PTOOLBARARRAYINFO;

extern const TOOLBARARRAYINFO g_rgToolbarArrayInfo[];
extern const TOOLBARARRAYINFO g_rgNoteToolbarArrayInfo[];
extern const TOOLBARARRAYINFO g_rgRulesToolbarArray;
#endif

//These values should be greater than 
#define MailReadNoteType    0
#define MailSendNoteType    1
#define NewsReadNoteType    2
#define NewsSendNoteType    3
#define NOTETYPES_MAX       4

#ifdef DEAD
HRESULT Util_MergeToolbarButtons(IExplorerToolbar* pET, FOLDER_TYPE ftType, 
                                 const GUID *cguid, LPTBBUTTON *ppTBButtons, 
                                 DWORD *pcButtons);
#endif

interface IImnAccount;

typedef struct tagGETSIGINFO
    {
    LPCSTR szSigID;
    IImnAccount *pAcct;
    HWND hwnd;
    BOOL fHtmlOk;
    BOOL fMail;
    UINT uCodePage;
    } GETSIGINFO;

HRESULT HrGetMailNewsSignature(GETSIGINFO *pSigInfo, LPDWORD pdwSigOptions, BSTR *pbstrSig);

HRESULT HrLoadStreamFileFromResource(LPCSTR lpszResourceName, LPSTREAM *ppstm);
 
void ConvertTabsToSpaces(LPSTR lpsz);
void ConvertTabsToSpacesW(LPWSTR lpsz);
void CombineFilters(int *rgidsFilter, int nFilters, LPSTR pszFilter);
void CombineFiltersW(int *rgidsFilter, int nFilters, LPWSTR pwszFilter);

void AthFormatSizeK(DWORD dw, LPTSTR szOut, UINT uiBufSize);

void GetDigitalIDs(IImnAccount *pCertAccount);
INT_PTR CALLBACK ErrSecurityNoSigningCertDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL FGetSelectedCachedMsg(IMsgContainer *pIMC, HWND hwndList, BOOL fSecure, LPMIMEMESSAGE *ppMsg);

BOOL FileExists(TCHAR *szFile, BOOL fNew);

//---------------------------------------------------------------------------
// Cached Password Support
//---------------------------------------------------------------------------
HRESULT SavePassword(DWORD dwPort, LPSTR pszServer, LPSTR pszUsername, LPSTR pszPassword);
HRESULT GetPassword(DWORD dwPort, LPSTR pszServer, LPSTR pszUsername, LPSTR pszPassword,
                    DWORD dwSizeOfPassword);
void DestroyPasswordList(void);

//------------------------------
// Drag Drop utils
//------------------------------

HRESULT CALLBACK FreeAthenaDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt);

HRESULT _IsSameObject(IUnknown* punk1, IUnknown* punk2);

// These macros are from \\trango\slmro\proj\win\src\shell\ccshell\inc\ccstock.h
#define SetFlag(f)             do {m_dwState |= (f);} while (0)
#define ToggleFlag(f)          do {m_dwState ^= (f);} while (0)
#define ClearFlag(f)           do {m_dwState &= ~(f);} while (0)
#define IsFlagSet(f)           (BOOL)(((m_dwState) & (f)) == (f))
#define IsFlagClear(f)         (BOOL)(((m_dwState) & (f)) != (f))


// From wndutil.*
/*
 * tabbing, parents etc
 */
HWND GetTopMostParent(HWND hwndChild);
void GetChildRect(HWND hwndDlg, HWND hwndChild, RECT *prc);
void SaveFocus(BOOL fActive, HWND *phwnd);
void EnableThreadWindows(BOOL fEnable);

/*
 * toobar helpers
 */

void DoToolbarDropdown(HWND hwnd, LPNMHDR lpnmh, HMENU hmenu);


/*
 * paint blocker
 */
HWND HwndStartBlockingPaints(HWND hwnd);
void StopBlockingPaints(HWND hwndBlock);

/*
 * edit control helpers
 */
#define FReadOnlyEdit(hwndEdit)  (BOOL)(GetWindowLong(hwndEdit, GWL_STYLE)&ES_READONLY)
//Enable/Disable flags for edit menu etc
enum
{
    edfEditFocus        =0x00000001,
    edfUndo             =0x00000002,
    edfEditHasSel       =0x00000004,
    edfEditHasSelAndIsRW=0x00000010,
    edfPaste            =0x00000020
};
void GetEditDisableFlags(HWND hwndEdit, DWORD *pdwFlags);
void EnableDisableEditMenu(HMENU hmenuEdit, DWORD dwFlags);
void EnableDisableEditToolbar(HWND hwndToolbar, DWORD dwFlags);


/*
 * dialog helpers
 */
BOOL AllocStringFromDlg(HWND hwnd, UINT id, LPTSTR * lplpsz);

/*
 * general
 */
HCURSOR HourGlass();

class CEmptyList
{
public:
    CEmptyList()
    {
        m_hwndList = NULL;
        m_hwndBlocker = NULL;
        m_hwndHeader = NULL;
        m_pszString = NULL;
        m_pfnWndProc = NULL;
        m_hbrBack = NULL;
    }

    ~CEmptyList()
    {
        if (IsWindow(m_hwndBlocker))
            DestroyWindow(m_hwndBlocker);
        SafeMemFree(m_pszString);
        if (NULL != m_hbrBack)
            DeleteObject(m_hbrBack);
    }

    HRESULT Show(HWND hwndList, LPTSTR pszString);
    HRESULT Hide(void);
    static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HWND    m_hwndList;
    HWND    m_hwndBlocker;
    HWND    m_hwndHeader;
    LPTSTR  m_pszString;
    WNDPROC m_pfnWndProc;
    HBRUSH  m_hbrBack;
};

HWND    FindModalOwner();

void FreeMessageInfo(LPMESSAGEINFO pMsgInfo);
LPWSTR Util_EnumFiles(LPCWSTR pwszDir, LPCWSTR pwszMatch);

HRESULT GetDefaultNewsServer(LPTSTR pszServerId, DWORD cchMax);


#define ETW_OE_WINDOWS_ONLY    0x0001

typedef struct _HWNDLIST
{
    DWORD       dwFlags;
    HWND       *rgHwnd;
    int         cAlloc;
    int         cHwnd;
} HWNDLIST;

HRESULT EnableThreadWindows(HWNDLIST *pHwndList, BOOL fEnable, DWORD dwFlags, HWND hwndExcept);
HRESULT GetOEUserName(BSTR *pbstr);
HRESULT CloseThreadWindows(HWND hwndExcept, DWORD dwThreadId);

void ActivatePopupWindow(HWND hwnd);
BOOL HideHotmail(void);
BOOL FIsIMAPOrHTTPAvailable(VOID);
BOOL IsBiDiCalendar(void);

LPSTR PszAllocResUrl(LPSTR pszRelative);

BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags);

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\xpcomm.cpp ===
// =================================================================================
// Common functions
// Written by: Steven J. Bailey on 1/21/96
// =================================================================================
#include "pch.hxx"
#include <shlwapi.h>
#include "xpcomm.h"
#include "strconst.h"
#include "error.h"
#include "deterr.h"
#include "progress.h"
#include "imaildlg.h"
#include "imnact.h"
#include "demand.h"

// =================================================================================
// Prototypes
// =================================================================================
INT_PTR CALLBACK DetailedErrorDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL DetailedErrorDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam);
void DetailedErrorDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify);
void DetailedErrorDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
void DetailedErrorDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
void DetailedErrorDlgProc_OnDetails (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);

// =================================================================================
// Defines
// =================================================================================
#define IDT_PROGRESS_DELAY WM_USER + 1

// =================================================================================
// SzStrAlloc
// =================================================================================
LPTSTR SzStrAlloc (ULONG cch)
{
    LPTSTR psz = NULL;

    if (!MemAlloc ((LPVOID *)&psz, (cch + 1) * sizeof (TCHAR)))
        return NULL;
    return psz;
}

// ------------------------------------------------------------------------------------
// InetMailErrorDlgProc (no longer part of CInetMail)
// ------------------------------------------------------------------------------------
BOOL CALLBACK InetMailErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPINETMAILERROR  pError;
    static RECT      s_rcDialog;
    static BOOL      s_fDetails=FALSE;
    RECT             rcDetails, rcDlg;
    DWORD            cyDetails;
    TCHAR            szRes[255];
    TCHAR            szMsg[255 + 50];
    HWND             hwndDetails;
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        pError = (LPINETMAILERROR)lParam;
        if (!pError)
        {
            Assert (FALSE);
            EndDialog(hwnd, IDCANCEL);
            return 1;
        }

        // Center
        CenterDialog (hwnd);

        // Set Error message
        Assert(pError->pszMessage);
        if (pError->pszMessage)
            SetDlgItemText(hwnd, idsInetMailError, pError->pszMessage);

        // Get whnd of details
        hwndDetails = GetDlgItem(hwnd, ideInetMailDetails);

        // Set Details
        if (!FIsStringEmpty(pError->pszDetails))
        {
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)pError->pszDetails);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)g_szCRLF);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)g_szCRLF);
        }

        // Configuration
        if (AthLoadString(idsDetails_Config, szRes, sizeof(szRes)/sizeof(TCHAR)))
        {
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szRes);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)g_szCRLF);
        }

        // Account:
        if (!FIsStringEmpty(pError->pszAccount))
        {
            TCHAR szAccount[255 + CCHMAX_ACCOUNT_NAME];
            if (AthLoadString(idsDetail_Account, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szAccount, "   %s %s\r\n", szRes, pError->pszAccount);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szAccount);
            }
        }

        // Server:
        if (!FIsStringEmpty(pError->pszServer))
        {
            TCHAR szServer[255 + CCHMAX_SERVER_NAME];
            if (AthLoadString(idsDetail_Server, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szServer, "   %s %s\r\n", szRes, pError->pszServer);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szServer);
            }
        }

        // User Name:
        if (!FIsStringEmpty(pError->pszUserName))
        {
            TCHAR szUserName[255 + CCHMAX_USERNAME];
            if (AthLoadString(idsDetail_UserName, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szUserName, "   %s %s\r\n", szRes, pError->pszUserName);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szUserName);
            }
        }

        // Protocol:
        if (!FIsStringEmpty(pError->pszProtocol))
        {
            TCHAR szProtocol[255 + 10];
            if (AthLoadString(idsDetail_Protocol, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szProtocol, "   %s %s\r\n", szRes, pError->pszProtocol);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szProtocol);
            }
        }

        // Port:
        if (AthLoadString(idsDetail_Port, szRes, sizeof(szRes)/sizeof(TCHAR)))
        {
            wsprintf(szMsg, "   %s %d\r\n", szRes, pError->dwPort);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szMsg);
        }
        
        // Secure:
        if (AthLoadString(idsDetail_Secure, szRes, sizeof(szRes)/sizeof(TCHAR)))
        {
            wsprintf(szMsg, "   %s %d\r\n", szRes, pError->fSecure);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szMsg);
        }

        // Error Number:
        if (pError->dwErrorNumber)
        {
            if (AthLoadString(idsDetail_ErrorNumber, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szMsg, "   %s %d\r\n", szRes, pError->dwErrorNumber);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szMsg);
            }
        }

        // HRESULT:
        if (pError->hrError)
        {
            if (AthLoadString(idsDetail_HRESULT, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
                wsprintf(szMsg, "   %s %08x\r\n", szRes, pError->hrError);
                SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szMsg);
            }
        }

        // Save Original Size of the dialog
        GetWindowRect (hwnd, &s_rcDialog);

        // Never show details by default
        s_fDetails = FALSE;

        // Hide details drop down
        if (s_fDetails == FALSE)
        {
            GetWindowRect(GetDlgItem (hwnd, idcIMProgSplitter), &rcDetails);
            cyDetails = s_rcDialog.bottom - rcDetails.top;
            MoveWindow(hwnd, s_rcDialog.left, s_rcDialog.top, s_rcDialog.right - s_rcDialog.left, s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1, FALSE);
        }
        else
        {
            AthLoadString(idsHideDetails, szRes, sizeof (szRes)/sizeof(TCHAR));
            SetWindowText(GetDlgItem(hwnd, idcIMProgSplitter), szRes);
        }

        // Save the pointer
        return 1;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
        case IDOK:
            EndDialog(hwnd, IDOK);
            return 1;

        case idbInetMailDetails:
            GetWindowRect (hwnd, &rcDlg);
            if (s_fDetails == FALSE)
            {
                MoveWindow(hwnd, rcDlg.left, rcDlg.top, s_rcDialog.right - s_rcDialog.left, s_rcDialog.bottom - s_rcDialog.top, TRUE);
                AthLoadString(idsHideDetails, szRes, sizeof(szRes)/sizeof(TCHAR));
                SetWindowText(GetDlgItem (hwnd, idbInetMailDetails), szRes);
                s_fDetails = TRUE;
            }
            else
            {
                GetWindowRect(GetDlgItem (hwnd, idcIMProgSplitter), &rcDetails);
                cyDetails = rcDlg.bottom - rcDetails.top;
                MoveWindow (hwnd, rcDlg.left, rcDlg.top, s_rcDialog.right - s_rcDialog.left, s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1, TRUE);
                AthLoadString (idsShowDetails, szRes, sizeof(szRes)/sizeof(TCHAR));
                SetWindowText (GetDlgItem (hwnd, idbInetMailDetails), szRes);
                s_fDetails = FALSE;
            }
        }
        break;
    }

    // Done
    return 0;
}

// =================================================================================
// SzGetSearchTokens
// =================================================================================
LPTSTR SzGetSearchTokens(LPTSTR pszCriteria)
{
    // Locals
    ULONG           iCriteria=0,
                    cbValueMax,
                    cbTokens=0,
                    cbValue,
                    iSave;
    TCHAR           chToken;
    LPTSTR          pszValue=NULL,
                    pszTokens=NULL;
    BOOL            fTokenFound;

    // Get Length of criteria
    cbValueMax = lstrlen(pszCriteria) + 10;
    pszValue = SzStrAlloc(cbValueMax);
    if (!pszValue)
        goto exit;

    // Alloc tokens list
    pszTokens = SzStrAlloc(cbValueMax);
    if (!pszTokens)
        goto exit;

    // Parse pszCriteria into space separated strings
    while(1)
    {
        // Skip white space
        SkipWhitespace (pszCriteria, &iCriteria);

        // Save current position
        iSave = iCriteria;

        // Parse next token
        fTokenFound = FStringTok (pszCriteria, &iCriteria, (LPTSTR)"\" ", &chToken, pszValue, cbValueMax, TRUE);
        if (!fTokenFound)
            break;

        // Toke isn't a space ?
        if (chToken == _T('"'))
        {
            // If something was found before the ", then it is a token
            if (*pszValue)
            {
                cbValue = lstrlen(pszValue) + 1;
                Assert(cbTokens + cbValue <= cbValueMax);
                CopyMemory(pszTokens + cbTokens, pszValue, cbValue);
                cbTokens+=cbValue;
            }

            // Search for ending quote
            fTokenFound = FStringTok (pszCriteria, &iCriteria, (LPTSTR)"\"", &chToken, pszValue, cbValueMax, TRUE);
                
            // Done ?
            if (chToken == _T('\0'))
            {
                cbValue = lstrlen(pszValue) + 1;
                Assert(cbTokens + cbValue <= cbValueMax);
                CopyMemory(pszTokens + cbTokens, pszValue, cbValue);
                cbTokens+=cbValue;
                break;
            }

            else if (!fTokenFound || chToken != _T('\"'))
            {
                iCriteria = iSave + 1;
                continue;
            }
        }       

        // Add value to token list
        cbValue = lstrlen(pszValue) + 1;
        Assert(cbTokens + cbValue <= cbValueMax);
        CopyMemory(pszTokens + cbTokens, pszValue, cbValue);
        cbTokens+=cbValue;

        // Done
        if (chToken == _T('\0'))
            break;
    }

    // Final NULL
    *(pszTokens + cbTokens) = _T('\0');
    
exit:
    // Cleanup
    SafeMemFree(pszValue);

    // If no tokens, then free it
    if (cbTokens == 0)
    {
        SafeMemFree(pszTokens);
    }

    // Done
    return pszTokens;
}

// =================================================================================
// ProcessNlsError
// =================================================================================
VOID ProcessNlsError (VOID)
{
    switch (GetLastError ())
    {
    case ERROR_INSUFFICIENT_BUFFER:
        AssertSz (FALSE, "NLSAPI Error: ERROR_INSUFFICIENT_BUFFER");
        break;

    case ERROR_INVALID_FLAGS:
        AssertSz (FALSE, "NLSAPI Error: ERROR_INVALID_FLAGS");
        break;

    case ERROR_INVALID_PARAMETER:
        AssertSz (FALSE, "NLSAPI Error: ERROR_INVALID_PARAMETER");
        break;

    case ERROR_NO_UNICODE_TRANSLATION:
        AssertSz (FALSE, "NLSAPI Error: ERROR_NO_UNICODE_TRANSLATION");
        break;

    default:
        AssertSz (FALSE, "NLSAPI Error: <Un-resolved error>");
        break;
    }
}

#ifdef OLDSPOOLER
// =================================================================================
// SzGetLocalHostName
// =================================================================================
LPSTR SzGetLocalHostName (VOID)
{
    // Locals
    static char s_szLocalHost[255] = {0};

    // Gets local host name from socket library
    if (*s_szLocalHost == 0)
    {
        if (gethostname (s_szLocalHost, sizeof (s_szLocalHost)) == SOCKET_ERROR)
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            //DebugTrace ("gethostname failed: WSAGetLastError: %ld\n", WSAGetLastError ());
            lstrcpyA (s_szLocalHost, "LocalHost");
        }
    }

    // Done
    return s_szLocalHost;
}

// ==========================================================================
// StripIllegalHostChars
// ==========================================================================
VOID StripIllegalHostChars(LPSTR pszSrc, LPTSTR pszDst)
{
    char  ch;

    while (ch = *pszSrc++)
    {
        if (ch <= 32  || ch >= 127 || ch == '('  || ch == ')' || 
            ch == '<' || ch == '>' || ch == '@'  || ch == ',' || 
            ch == ';' || ch == ':' || ch == '\\' || ch == '"' ||
            ch == '[' || ch == ']' || ch == '`'  || ch == '\'')
            continue;
        *pszDst++ = ch;
    }

    *pszDst = 0;
}


// ==========================================================================
// SzGetLocalHostNameForID
// ==========================================================================
LPSTR SzGetLocalHostNameForID (VOID)
{
    // Locals
    static char s_szLocalHostId[255] = {0};

    // Gets local host name from socket library
    if (*s_szLocalHostId == 0)
    {
        // Get Host name
        LPSTR pszDst = s_szLocalHostId, pszSrc = SzGetLocalHostName();

        // Strip illegals
        StripIllegalHostChars(pszSrc, pszDst);

        // if we stripped out everything, then just copy in something
        if (*s_szLocalHostId == 0)
            lstrcpyA(s_szLocalHostId, "LocalHost");
    }
    return s_szLocalHostId;
}


// =================================================================================
// SzGetLocalPackedIP
// =================================================================================
LPTSTR SzGetLocalPackedIP (VOID)
{
    // Locals
    static TCHAR    s_szLocalPackedIP[255] = {_T('\0')};

    // Gets local host name from socket library
    if (*s_szLocalPackedIP == _T('\0'))
    {
        LPHOSTENT   hp = NULL;

        hp = gethostbyname (SzGetLocalHostName ());
        if (hp != NULL)
            wsprintf (s_szLocalPackedIP, "%08x", *(long *)hp->h_addr);

        else
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            //DebugTrace ("gethostbyname failed: WSAGetLastError: %ld\n", WSAGetLastError ());
            lstrcpy (s_szLocalPackedIP, "LocalHost");
        }
    }

    // Done
    return s_szLocalPackedIP;
}
#endif

// =============================================================================================
// SzGetNormalizedSubject
// =============================================================================================
LPTSTR SzNormalizeSubject (LPTSTR lpszSubject)
{
    // Locals
    LPTSTR              lpszNormal = lpszSubject;
    ULONG               i = 0, cch = 0, cbSubject;

    // Bad Params
    if (lpszSubject == NULL)
        goto exit;

    // Les than 5 "xxx: "
    cbSubject = lstrlen (lpszSubject);
    if (cbSubject < 4)
        goto exit;

    // 1, 2, or 3 spaces followed by a ':' then a space
    while (cch < 7 && i < cbSubject)
    {
        // Colon
        if (lpszSubject[i] == _T(':'))
        {
            if (i+1 >= cbSubject)
            {
                // Should set to null terminator, nor subject
                i+=1;
                lpszNormal = (LPTSTR)(lpszSubject + i);
                break;
            }

            else if (cch <= 4 && lpszSubject[i+1] == _T(' '))
            {
                i+=1;
                lpszNormal = (LPTSTR)(lpszSubject + i);
                i = 0;
                SkipWhitespace (lpszNormal, &i);
                lpszNormal += i;
                break;
            }
            else
                break;
        }

        // Next Character
        if (IsDBCSLeadByte (lpszSubject[i]))
            i+=2;
        else
            i++;

        // Count Characters
        cch++;
    }    

exit:
    // Done
    return lpszNormal;
}

// =============================================================================================
// HrCopyAlloc
// =============================================================================================
HRESULT HrCopyAlloc (LPBYTE *lppbDest, LPBYTE lpbSrc, ULONG cb)
{
    // Check Params
    AssertSz (lppbDest && lpbSrc, "Null Parameter");

    // Alloc Memory
    if (!MemAlloc ((LPVOID *)lppbDest, cb))
        return TRAPHR (hrMemory);

    // Copy Memory
    CopyMemory (*lppbDest, lpbSrc, cb);

    // Done
    return S_OK;
}

// =============================================================================================
// StringDup - duplicates a string
// =============================================================================================
LPTSTR StringDup (LPCTSTR lpcsz)
{
    // Locals
    LPTSTR       lpszDup;

    if (lpcsz == NULL)
        return NULL;

    INT nLen = lstrlen (lpcsz) + 1;

    if (!MemAlloc ((LPVOID *)&lpszDup, nLen * sizeof (TCHAR)))
        return NULL;

    CopyMemory (lpszDup, lpcsz, nLen);

    return lpszDup;
}

// =============================================================================================
// SkipWhitespace
// Assumes piString points to character boundary
// =============================================================================================
void SkipWhitespace (LPCTSTR lpcsz, ULONG *pi)
{
    if (!lpcsz || !pi)
    {
        Assert (FALSE);
        return;
    }

#ifdef DEBUG
    Assert (*pi <= (ULONG)lstrlen (lpcsz)+1);
#endif

    LPTSTR lpsz = (LPTSTR)(lpcsz + *pi);
    while (*lpsz != _T('\0'))
    {
        if (!IsSpace(lpsz))
            break;

        if (IsDBCSLeadByte (*lpsz))
        {
            lpsz+=2;
            (*pi)+=2;
        }
        else
        {
            lpsz++;
            (*pi)+=1;
        }
    }

    return;
}

// =============================================================================================
// Converts lpcsz to a UINT
// =============================================================================================
UINT AthUFromSz(LPCTSTR lpcsz)
{
    // Locals
	UINT        u = 0, ch;

    // Check Params
    AssertSz (lpcsz, "Null parameter");

    // Do Loop
    LPTSTR lpsz = (LPTSTR)lpcsz;
	while ((ch = *lpsz) >= _T('0') && ch <= _T('9')) 
    {
		u = u * 10 + ch - _T('0');

        if (IsDBCSLeadByte (*lpsz))
            lpsz+=2;
        else
            lpsz++;
	}

	return u;
}

// =============================================================================================
// Converts first two characters of lpcsz to a WORD
// =============================================================================================
WORD NFromSz (LPCTSTR lpcsz)
{
    TCHAR acWordStr[3];
    Assert (lpcsz);
    CopyMemory (acWordStr, lpcsz, 2 * sizeof (TCHAR));
    acWordStr[2] = _T('\0');
    return ((WORD) AthUFromSz (acWordStr));
}

// =============================================================================================
// FindChar
// =============================================================================================
LPTSTR SzFindChar (LPCTSTR lpcsz, TCHAR ch)
{
    // Check Params
    Assert (lpcsz);

    // Local loop
    LPTSTR lpsz = (LPTSTR)lpcsz;

    // Loop string
    while (*lpsz != _T('\0'))
    {
        if (*lpsz == ch)
            return lpsz;

        if (IsDBCSLeadByte (*lpsz))
            lpsz+=2;
        else
            lpsz++;
    }

    return NULL;
}

#ifdef DEAD
// =============================================================================================
// UlDBCSStripTrailingWhitespace
// =============================================================================================
ULONG UlDBCSStripWhitespace(LPSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb)
{
    // Locals
    ULONG           cb=0, 
                    iLastSpace=0,
                    cCharsSinceSpace=0;
    BOOL            fLastCharSpace = FALSE;

    // Get the string length
    while (*lpsz)
    {
        if (cCharsSinceSpace && IsSpace(lpsz))
        {
            cCharsSinceSpace=0;
            iLastSpace=cb;
        }
        else
            cCharsSinceSpace++;

        if (IsDBCSLeadByte(*lpsz))
        {
            lpsz+=2;
            cb+=2;
        }
        else
        {
            lpsz++;
            cb++;
        }
    }

    if (cCharsSinceSpace == 0)
    {
        *(lpsz + iLastSpace) = _T('\0');
        cb = iLastSpace - 1;
    }

    // Set String Size
    if (pcb)
        *pcb = cb;
     
    // Done
    return cb;
}       
#endif // DEAD

// =============================================================================================
// StringTok - similiar to strtok
// =============================================================================================
BOOL FStringTok (LPCTSTR        lpcszString, 
                 ULONG          *piString, 
                 LPTSTR         lpcszTokens, 
                 TCHAR          *chToken, 
                 LPTSTR         lpszValue, 
                 ULONG          cbValueMax,
                 BOOL           fStripTrailingWhitespace)
{
    // Locals
    LPTSTR      lpszStringLoop, 
                lpszTokenLoop;
    ULONG       cbValue=0, 
                nLen=0,
                cCharsSinceSpace=0,
                iLastSpace=0;
    BOOL        fTokenFound = FALSE;

    // Check Params
    AssertSz (lpcszString && piString && lpcszTokens, "These should have been checked.");

    // INit = better be on a dbcs boundary
    lpszStringLoop = (LPTSTR)(lpcszString + (*piString));

    // Loop current
    while (*lpszStringLoop)
    {
        // If DBCS Lead Byte, skip it, it will never match the type of tokens I'm looking for
        // Or, If an escape character, don't check delimiters
        if (IsDBCSLeadByte(*lpszStringLoop) || *lpszStringLoop == _T('\\'))
        {
            cCharsSinceSpace+=2;
            lpszStringLoop+=2;
            cbValue+=2;
            continue;
        }

        // Mark and remember last space
        if (cCharsSinceSpace && IsSpace(lpszStringLoop))
        {
            cCharsSinceSpace=0;
            iLastSpace=cbValue;
        }

        // Count number of characters since last space
        else
            cCharsSinceSpace++;

        // Look for a tokens
        lpszTokenLoop=lpcszTokens;
        while(*lpszTokenLoop)
        {
            // Token Match ?
            if (*lpszStringLoop == *lpszTokenLoop)
            {
                // Save the found token
                if (chToken)
                    *chToken = *lpszStringLoop;

                // Don't count this character as a charcter seen since last space
                cCharsSinceSpace--;

                // Were done
                fTokenFound = TRUE;
                goto done;
            }

            // Next Token
            lpszTokenLoop++;
        }

        // Next Char
        lpszStringLoop++;
        cbValue++;
    }

done:
    // If reached end of string, this is a default token
    if (*lpszStringLoop == _T('\0'))
    {
        if (chToken)
            *chToken = *lpszStringLoop;
        fTokenFound = TRUE;
    }

    // Copy value if token found
    if (fTokenFound)
    {
        if (lpszValue && cbValueMax > 0 && cbValue)
        {
            if (cbValue+1 <= cbValueMax)
            {
                lstrcpyn (lpszValue, lpcszString + (*piString), cbValue+1);
                nLen = cbValue-1;
            }
            else
            {
                AssertSz (FALSE, "Buffer is too small.");
                lstrcpyn (lpszValue, lpcszString + (*piString), cbValueMax);
                nLen = cbValueMax-1;
            }

            // Strip Trailing Whitespace ?
            if (fStripTrailingWhitespace && cCharsSinceSpace == 0)
            {
                *(lpszValue + iLastSpace) = _T('\0');
                nLen = iLastSpace - 1;
            }
        }

        // No Text
        else
        {
            if (lpszValue)
                *lpszValue = _T('\0');
            nLen = 0;
            cbValue = 0;
        }

        // Set new string index
        *piString += cbValue + 1;
    }

    // Return whether we found a token
    return fTokenFound;
}

// =============================================================================================
// Return TRUE if string is empty or contains only spaces
// =============================================================================================
BOOL FIsStringEmpty (LPTSTR lpszString)
{
    // Bad Pointer
    if (!lpszString)
        return TRUE;

	// Check for All spaces
	for (; *lpszString != _T('\0'); lpszString++)
	{
		if (*lpszString != _T(' ')) 
            return FALSE;
	}

	// Done
	return TRUE;
}

BOOL FIsStringEmptyW(LPWSTR lpwszString)
{
    // Bad Pointer
    if (!lpwszString)
        return TRUE;

	// Check for All spaces
	for (; *lpwszString != L'\0'; lpwszString++)
	{
		if (*lpwszString != L' ') 
            return FALSE;
	}

	// Done
	return TRUE;
}

// =================================================================================
// Write some data to the blob
// =================================================================================
HRESULT HrBlobWriteData (LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData)
{
    // Check Parameters
    AssertSz (lpbBlob && cbBlob > 0 && pib && cbData > 0 && lpbData, "Bad Parameter");
    AssertReadWritePtr (lpbBlob, cbData);
    AssertReadWritePtr (lpbData, cbData);
    AssertSz (*pib + cbData <= cbBlob, "Blob overflow");

    // Copy Data Data
    CopyMemory (lpbBlob + (*pib), lpbData, cbData);
    *pib += cbData;

    // Done
    return S_OK;
}


// =================================================================================
// Read some data from the blob
// =================================================================================
HRESULT HrBlobReadData (LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData)
{
    // Check Parameters
    AssertSz (lpbBlob && cbBlob > 0 && pib && cbData > 0 && lpbData, "Bad Parameter");
    AssertReadWritePtr (lpbBlob, cbData);
    AssertReadWritePtr (lpbData, cbData);
    AssertSz (*pib + cbData <= cbBlob, "Blob overflow");
#ifdef  WIN16   // When it happens it cause GPF in Win16, so rather than GPF, remove it from entry.
    if ( *pib + cbData > cbBlob )
        return E_FAIL;
#endif

    // Copy Data Data
    CopyMemory (lpbData, lpbBlob + (*pib), cbData);
    *pib += cbData;

    // Done
    return S_OK;
}

// =====================================================================================
// HrFixupHostString - In: saranac.microsoft.com Out: saranac
// =====================================================================================
HRESULT HrFixupHostString (LPTSTR lpszHost)
{
    ULONG           i = 0;
    TCHAR           chToken;

    if (lpszHost == NULL)
        return S_OK;

    if (FStringTok (lpszHost, &i, _T("."), &chToken, NULL, 0, FALSE))
    {
        if (chToken != _T('\0'))
            lpszHost[i-1] = _T('\0');
    }

    return S_OK;
}

// =====================================================================================
// HrFixupAccountString - In: sbailey@microsoft.com Out: sbailey
// =====================================================================================
HRESULT HrFixupAccountString (LPTSTR lpszAccount)
{
    ULONG           i = 0;
    TCHAR           chToken;

    if (lpszAccount == NULL)
        return S_OK;

    if (FStringTok (lpszAccount, &i, _T("@"), &chToken, NULL, 0, FALSE))
    {
        if (chToken != _T('\0'))
            lpszAccount[i-1] = _T('\0');
    }

    return S_OK;
}


// =====================================================================================
// HGetMenuFont
// =====================================================================================
HFONT HGetMenuFont (void)
{
#ifndef WIN16
    // Locals
    NONCLIENTMETRICS        ncm;
    HFONT                   hFont = NULL;

    // Create the menu font
    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, (LPVOID)&ncm, 0))
    {
        // Create Font
        hFont = CreateFontIndirect(&ncm.lfMenuFont);
    }

    // Done
    return hFont;
#else
    LOGFONT  lfMenu;

    GetObject( GetStockObject( SYSTEM_FONT ), sizeof( lfMenu ), &lfMenu );
    return( CreateFontIndirect( &lfMenu ) );
#endif
}

// =================================================================================
// CreateHGlobalFromStream
// =================================================================================
BOOL    CreateHGlobalFromStream(LPSTREAM pstm, HGLOBAL * phg)
    {
    HGLOBAL hret = NULL;
    HGLOBAL hret2;
    LPBYTE  lpb;
    ULONG   cbRead = 0, cbSize = 1024;

    if (!pstm || !phg)
        return FALSE;
    
    if (!(hret = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbSize)))
        return FALSE;

    while (TRUE)
        {
        ULONG   cb;

        lpb = (LPBYTE)GlobalLock(hret);
        lpb += cbRead;

        if (pstm->Read((LPVOID)lpb, 1024, &cb) != S_OK || cb < 1024)
            {
            cbRead += cb;
            GlobalUnlock(hret);
            break;
            }

        cbRead += cb;
        cbSize += 1024;

        GlobalUnlock(hret);
        hret2 = GlobalReAlloc(hret, cbSize, GMEM_MOVEABLE|GMEM_ZEROINIT);
        if (!hret2)
            return FALSE;
        hret = hret2;
        }
    
    if (hret)
        {
        hret2 = GlobalReAlloc(hret, cbRead, GMEM_MOVEABLE|GMEM_ZEROINIT);
        *phg = hret2;
        return TRUE;
        }

    return FALSE;
    }

// =================================================================================
// HrDetailedError
// =================================================================================
VOID DetailedError (HWND hwndParent, LPDETERR lpDetErr)
{
    // Check params
    AssertSz (lpDetErr, "Null Parameter");
    Assert (lpDetErr->lpszMessage && lpDetErr->lpszDetails);

    // Beep
    MessageBeep (MB_OK);

    // Display Dialog Box
    DialogBoxParam (g_hLocRes, MAKEINTRESOURCE (iddDetailedError), hwndParent, (DLGPROC)DetailedErrorDlgProc, (LPARAM)lpDetErr);

    // Done
    return;
}

// =====================================================================================
// PasswordDlgProc
// =====================================================================================
INT_PTR CALLBACK DetailedErrorDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG (hwndDlg, WM_INITDIALOG, DetailedErrorDlgProc_OnInitDialog);
		HANDLE_MSG (hwndDlg, WM_COMMAND,    DetailedErrorDlgProc_OnCommand);
	}

	return 0;
}

// =====================================================================================
// DetailedErrorDlgProc_OnInitDialog
// =====================================================================================
BOOL DetailedErrorDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
    // Locals
    LPDETERR        lpDetErr = NULL;
    TCHAR           szTitle[255];
    RECT            rcDetails;
    ULONG           cyDetails;
    TCHAR           szButton[40];

	// Center
	CenterDialog (hwndDlg);

    // Foreground
    SetForegroundWindow (hwndDlg);

    // Get Pass info struct
    lpDetErr = (LPDETERR)lParam;
    if (lpDetErr == NULL)
    {
        Assert (FALSE);
        return 0;
    }

    SetDlgThisPtr (hwndDlg, lpDetErr);

    // Set Window Title
    if (lpDetErr->idsTitle)
        if (AthLoadString (lpDetErr->idsTitle, szTitle, sizeof (szTitle)))
            SetWindowText (hwndDlg, szTitle);

	// Show message
    SetWindowText (GetDlgItem (hwndDlg, idcMessage), lpDetErr->lpszMessage);

    if (FIsStringEmpty (lpDetErr->lpszDetails) == FALSE)
        SetWindowText (GetDlgItem (hwndDlg, ideDetails), lpDetErr->lpszDetails);
    else
        ShowWindow (GetDlgItem (hwndDlg, idbDetails), SW_HIDE);

    // Save Original Size of the dialog
    GetWindowRect (hwndDlg, &lpDetErr->rc);

    // Hide Details box
    if (lpDetErr->fHideDetails)
    {
        // Size of details
        GetWindowRect (GetDlgItem (hwndDlg, idcSplit), &rcDetails);

        // Height of details
        cyDetails = lpDetErr->rc.bottom - rcDetails.top;
    
        // Re-size
        MoveWindow (hwndDlg, lpDetErr->rc.left, 
                             lpDetErr->rc.top, 
                             lpDetErr->rc.right - lpDetErr->rc.left, 
                             lpDetErr->rc.bottom - lpDetErr->rc.top - cyDetails - 1,
                             FALSE);
    }

    else
    {
        // < Details
        AthLoadString (idsHideDetails, szButton, sizeof (szButton));
        SetWindowText (GetDlgItem (hwndDlg, idbDetails), szButton);
    }

    // Done
	return FALSE;
}

// =====================================================================================
// OnCommand
// =====================================================================================
void DetailedErrorDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
		HANDLE_COMMAND(hwndDlg, idbDetails, hwndCtl, codeNotify, DetailedErrorDlgProc_OnDetails);		
		HANDLE_COMMAND(hwndDlg, IDOK, hwndCtl, codeNotify, DetailedErrorDlgProc_OnOk);		
		HANDLE_COMMAND(hwndDlg, IDCANCEL, hwndCtl, codeNotify, DetailedErrorDlgProc_OnCancel);		
	}
	return;
}

// =====================================================================================
// OnCancel
// =====================================================================================
void DetailedErrorDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
	EndDialog (hwndDlg, IDCANCEL);
}

// =====================================================================================
// OnOk
// =====================================================================================
void DetailedErrorDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
	EndDialog (hwndDlg, IDOK);
}

// =====================================================================================
// OnDetails
// =====================================================================================
void DetailedErrorDlgProc_OnDetails (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
    // Locals
    LPDETERR        lpDetErr = NULL;
    RECT            rcDlg, rcDetails;
    TCHAR           szButton[40];
    ULONG           cyDetails;

    // Get this
    lpDetErr = (LPDETERR)GetDlgThisPtr (hwndDlg);
    if (lpDetErr == NULL)
    {
        Assert (FALSE);
        return;
    }

    // Get current location of the dialog
    GetWindowRect (hwndDlg, &rcDlg);

    // If currently hidden
    if (lpDetErr->fHideDetails)
    {
        // Re-size
        MoveWindow (hwndDlg, rcDlg.left, 
                             rcDlg.top, 
                             lpDetErr->rc.right - lpDetErr->rc.left, 
                             lpDetErr->rc.bottom - lpDetErr->rc.top,
                             TRUE);

        // < Details
        AthLoadString (idsHideDetails, szButton, sizeof (szButton));
        SetWindowText (GetDlgItem (hwndDlg, idbDetails), szButton);

        // Not Hidden
        lpDetErr->fHideDetails = FALSE;
    }

    else
    {
        // Size of details
        GetWindowRect (GetDlgItem (hwndDlg, idcSplit), &rcDetails);

        // Height of details
        cyDetails = rcDlg.bottom - rcDetails.top;
    
        // Re-size
        MoveWindow (hwndDlg, rcDlg.left, 
                             rcDlg.top, 
                             lpDetErr->rc.right - lpDetErr->rc.left, 
                             lpDetErr->rc.bottom - lpDetErr->rc.top - cyDetails - 1,
                             TRUE);

        // Details >
        AthLoadString (idsShowDetails, szButton, sizeof (szButton));
        SetWindowText (GetDlgItem (hwndDlg, idbDetails), szButton);

        // Hidden
        lpDetErr->fHideDetails = TRUE;
    }
}

// =====================================================================================
// FIsLeapYear
// =====================================================================================
BOOL FIsLeapYear (INT nYear)
{
    if (nYear % 4 == 0)
    {
        if ((nYear % 100) == 0 && (nYear % 400) != 0)
            return FALSE;
        else
            return TRUE;
    }

    return FALSE;
}

#ifdef DEBUG
VOID TestDateDiff (VOID)
{
    SYSTEMTIME          st;
    FILETIME            ft1, ft2;

    GetSystemTime (&st);
    SystemTimeToFileTime (&st, &ft2);
    st.wDay+=3;
    SystemTimeToFileTime (&st, &ft1);
    UlDateDiff (&ft1, &ft2);
}
#endif

// =====================================================================================
// Returns number of seconds between lpft1 and lpft2
// A leap year is defined as all years divisible by 4, except for years
// divisible by 100 that are not also divisible by 400. Years divisible by 400
// are leap years. 2000 is a leap year. 1900 is not a leap year.
// =====================================================================================
#define MAKEDWORDLONG(a, b) ((DWORDLONG)(((DWORD)(a)) | ((DWORDLONG)((DWORD)(b))) << 32))
#define LODWORD(l)          ((DWORD)(l))
#define HIDWORD(l)          ((DWORD)(((DWORDLONG)(l) >> 32) & 0xFFFFFFFF))

#define NANOSECONDS_INA_SECOND 10000000

ULONG UlDateDiff (LPFILETIME lpft1, LPFILETIME lpft2)
{
    DWORDLONG dwl1, dwl2, dwlDiff;
    
#ifndef WIN16
    dwl1 = MAKEDWORDLONG(lpft1->dwLowDateTime, lpft1->dwHighDateTime);
    dwl2 = MAKEDWORDLONG(lpft2->dwLowDateTime, lpft2->dwHighDateTime);
#else
    dwl1 = ((__int64)(((DWORD)(lpft1->dwLowDateTime)) | ((__int64)((DWORD)(lpft1->dwHighDateTime))) << 32));
    dwl2 = ((__int64)(((DWORD)(lpft2->dwLowDateTime)) | ((__int64)((DWORD)(lpft2->dwHighDateTime))) << 32));
#endif

    // Make sure dwl1 is greater than dwl2
    if (dwl2 > dwl1)
        {
        dwlDiff = dwl1;
        dwl1 = dwl2;
        dwl2 = dwlDiff;
        }
    
    dwlDiff = dwl1 - dwl2;
    dwlDiff = dwlDiff / NANOSECONDS_INA_SECOND;
    
    return ((ULONG) dwlDiff);    
}   

// =====================================================================================
// StripSpaces
// =====================================================================================
VOID StripSpaces(LPTSTR psz)
{
    UINT        ib = 0;
    UINT        cb = lstrlen(psz);
    TCHAR       chT;

	while (ib < cb)
	{
        // Get Character
		chT = psz[ib];

        // If lead byte, skip it, its leagal
        if (IsDBCSLeadByte(chT))
            ib+=2;

        // Illeagl file name character ?
        else if (chT == _T('\r') || chT == _T('\n') || chT == _T('\t') || chT == _T(' '))
        {
			MoveMemory (psz + ib, psz + (ib + 1), cb - ib);
			cb--;
        }
        else
            ib++;
    }
}


// =====================================================================================
// CProgress::CProgress
// =====================================================================================
CProgress::CProgress ()
{
    DOUT ("CProgress::CProgress");
    m_cRef = 1;
    m_cMax = 0;
    m_cPerCur = 0;
    m_cCur = 0;
    m_hwndProgress = NULL;
    m_hwndDlg = NULL;
    m_hwndOwner = NULL;
    m_hwndDisable = NULL;
    m_fCanCancel = FALSE;
    m_fHasCancel = FALSE;
    m_cLast = 0;
}

// =====================================================================================
// CProgress::~CProgress
// =====================================================================================
CProgress::~CProgress ()
{
    DOUT ("CProgress::~CProgress");
    Close();
}

// =====================================================================================
// CProgress::AddRef
// =====================================================================================
ULONG CProgress::AddRef ()
{
    ++m_cRef;
    DOUT ("CProgress::AddRef () Ref Count=%d", m_cRef);
    return m_cRef;
}

// =====================================================================================
// CProgress::AddRef
// =====================================================================================
ULONG CProgress::Release ()
{
    ULONG ulCount = --m_cRef;
    DOUT ("CProgress::Release () Ref Count=%d", ulCount);
    if (!ulCount)
        delete this;
    return ulCount;
}

// =====================================================================================
// CProgress::Init
// =====================================================================================
VOID CProgress::Init (HWND      hwndParent, 
                      LPTSTR    lpszTitle, 
                      LPTSTR    lpszMsg, 
                      ULONG     cMax, 
                      UINT      idani, 
                      BOOL      fCanCancel,
                      BOOL      fBacktrackParent /* =TRUE */)
{
    // Set Max and cur
    m_cMax = cMax;
    m_cPerCur = 0;
    m_fCanCancel = fCanCancel;
    m_fHasCancel = FALSE;

    // If dialog is not displayed yet
    if (m_hwndDlg == NULL)
    {
        // Save Parent
        m_hwndOwner = hwndParent;

        // Find the topmost parent
        m_hwndDisable = m_hwndOwner;

        if (fBacktrackParent)
        {
            while(GetParent(m_hwndDisable))
                m_hwndDisable = GetParent(m_hwndDisable);
        }

        // Create Dialog
        m_hwndDlg = CreateDialogParam (g_hLocRes, MAKEINTRESOURCE (iddProgress),
                        hwndParent, (DLGPROC)ProgressDlgProc, (LPARAM)this);

    }

    // Otherwise, reset
    else
    {
        // Stop and close animation
        Animate_Close (GetDlgItem (m_hwndDlg, idcANI));

        // Reset pos
        Assert (m_hwndProgress);
        SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
    }

    // Set title
    SetTitle(lpszTitle);

    // Set Message
    SetMsg(lpszMsg);

    // Animation ?
    if (idani)
    {
        // Open the animation
        Animate_OpenEx (GetDlgItem (m_hwndDlg, idcANI), g_hLocRes, MAKEINTRESOURCE(idani));
    }

    // No Cancel
    if (FALSE == m_fCanCancel)
    {
        RECT rcDialog, rcProgress, rcCancel;

        ShowWindow(GetDlgItem(m_hwndDlg, IDCANCEL), SW_HIDE);
        GetWindowRect(GetDlgItem(m_hwndDlg, IDCANCEL), &rcCancel);
        GetWindowRect(m_hwndDlg, &rcDialog);
        GetWindowRect(m_hwndProgress, &rcProgress);
        SetWindowPos(m_hwndProgress, NULL, 0, 0, rcDialog.right - rcProgress.left - (rcDialog.right - rcCancel.right), 
                    rcProgress.bottom - rcProgress.top, SWP_NOZORDER | SWP_NOMOVE);
    }
}

// =====================================================================================
// CProgress::Close
// =====================================================================================
VOID CProgress::Close (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Close the animation
        Animate_Close (GetDlgItem (m_hwndDlg, idcANI));

        // Enable parent
        if (m_hwndDisable)
            {
            EnableWindow (m_hwndDisable, TRUE);
            SetActiveWindow(m_hwndDisable);
            }

        // Destroy it
        DestroyWindow (m_hwndDlg);

        // NULL
        m_hwndDlg = NULL;
    }
}

// =====================================================================================
// CProgress::Show
// =====================================================================================
VOID CProgress::Show (DWORD dwDelaySeconds)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Disable Parent
        if (m_hwndDisable)
            EnableWindow (m_hwndDisable, FALSE);

        // Start the animation
        Animate_Play (GetDlgItem (m_hwndDlg, idcANI), 0, -1, -1);

        // Show the window if now delay
        if (dwDelaySeconds == 0)
            ShowWindow (m_hwndDlg, SW_SHOWNORMAL);
        else
            SetTimer(m_hwndDlg, IDT_PROGRESS_DELAY, dwDelaySeconds * 1000, NULL);
    }
}

// =====================================================================================
// CProgress::Hide
// =====================================================================================
VOID CProgress::Hide (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        if (m_hwndDisable)
            EnableWindow(m_hwndDisable, TRUE);
    
        // Hide it
        ShowWindow (m_hwndDlg, SW_HIDE);

        // Stop the animation
        Animate_Stop (GetDlgItem (m_hwndDlg, idcANI));
    }
}

// =====================================================================================
// CProgress::SetMsg
// =====================================================================================
VOID CProgress::SetMsg(LPTSTR lpszMsg)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszMsg)
        {
        if (IS_INTRESOURCE(lpszMsg))
            {
            LoadString(g_hLocRes, PtrToUlong(lpszMsg), sz, sizeof(sz) / sizeof(TCHAR));
            lpszMsg = sz;
            }

        SetWindowText (GetDlgItem (m_hwndDlg, idsMsg), lpszMsg);
        }
}

// =====================================================================================
// CProgress::SetTitle
// =====================================================================================
VOID CProgress::SetTitle(LPTSTR lpszTitle)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszTitle)
        {
        if (IS_INTRESOURCE(lpszTitle))
            {
            LoadString(g_hLocRes, PtrToUlong(lpszTitle), sz, sizeof(sz) / sizeof(TCHAR));
            lpszTitle = sz;
            }

        SetWindowText (m_hwndDlg, lpszTitle);
        }
}

// =====================================================================================
// CProgress::AdjustMax
// =====================================================================================
VOID CProgress::AdjustMax(ULONG cNewMax)
{
    // Set Max
    m_cMax = cNewMax;

    // If 0
    if (m_cMax == 0)
    {
        SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
        ShowWindow(m_hwndProgress, SW_HIDE);
        return;
    }
    else
        ShowWindow(m_hwndProgress, SW_SHOWNORMAL);

    // If cur is now larget than max ?
    if (m_cCur > m_cMax)
        m_cCur = m_cMax;

    // Compute percent
    m_cPerCur = (m_cCur * 100 / m_cMax);

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);

    // msgpump to process user moving window, or pressing cancel... :)
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

VOID CProgress::Reset()
{
    m_cCur = 0;
    m_cPerCur = 0;

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
}

// =====================================================================================
// CProgress::HrUpdate
// =====================================================================================
HRESULT CProgress::HrUpdate (ULONG cInc)
{
    // No max
    if (m_cMax)
    {
        // Increment m_cCur
        m_cCur += cInc;

        // If cur is now larget than max ?
        if (m_cCur > m_cMax)
            m_cCur = m_cMax;

        // Compute percent
        ULONG cPer = (m_cCur * 100 / m_cMax);

        // Step percent
        if (cPer > m_cPerCur)
        {
            // Set percur
            m_cPerCur = cPer;

            // Update status
            SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);

            // msgpump to process user moving window, or pressing cancel... :)
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    // Still pump some messages, call may not want to do this too often
    else
    {
        // msgpump to process user moving window, or pressing cancel... :)
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }


    // Done
    return m_fHasCancel ? hrUserCancel : S_OK;
}

// =====================================================================================
// CProgress::ProgressDlgProc
// =====================================================================================
BOOL CALLBACK CProgress::ProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CProgress *lpProgress = (CProgress *)GetDlgThisPtr(hwnd);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        lpProgress = (CProgress *)lParam;
        if (!lpProgress)
        {
            Assert (FALSE);
            return 1;
        }
        CenterDialog (hwnd);
        lpProgress->m_hwndProgress = GetDlgItem (hwnd, idcProgBar);
        if (lpProgress->m_cMax == 0)
            ShowWindow(lpProgress->m_hwndProgress, SW_HIDE);
        SetDlgThisPtr (hwnd, lpProgress);
        return 1;

    case WM_TIMER:
        if (wParam == IDT_PROGRESS_DELAY)
        {
            KillTimer(hwnd, IDT_PROGRESS_DELAY);
            if (lpProgress->m_cPerCur < 80)
            {
                lpProgress->m_cMax -= lpProgress->m_cCur;
                lpProgress->Reset();
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            if (lpProgress)
            {
                EnableWindow ((HWND)lParam, FALSE);
                lpProgress->m_fHasCancel = TRUE;
            }
            return 1;
        }
        break;

    case WM_DESTROY:
        KillTimer(hwnd, IDT_PROGRESS_DELAY);
        SetDlgThisPtr (hwnd, NULL);
        break;
    }

    // Done
    return 0;
}

// =====================================================================================
// ResizeDialogComboEx
// =====================================================================================
VOID ResizeDialogComboEx (HWND hwndDlg, HWND hwndCombo, UINT idcBase, HIMAGELIST himl)
{
    // Locals
    HDC                 hdc = NULL;
    HFONT               hFont = NULL, 
                        hFontOld = NULL;
    TEXTMETRIC          tm;
    RECT                rectCombo;
    INT                 cxCombo = 0, 
                        cyCombo = 0, 
                        cxIcon = 0, 
                        cyIcon = 0,
                        cyText;
    POINT               pt;

    // Get current font of combo box
    hFont = (HFONT)SendMessage (GetDlgItem (hwndDlg, idcBase), WM_GETFONT, 0, 0);
    if (hFont == NULL)
        goto exit;

    // Get a dc for the dialog
    hdc = GetDC (hwndDlg);
    if (hdc == NULL)
        goto exit;

    // Select font into dc
    hFontOld = (HFONT)SelectObject (hdc, hFont);

    // Get Text Metrics
    GetTextMetrics (hdc, &tm);

    // Comput sizeof combobox ex
    GetWindowRect (hwndCombo, &rectCombo);

    // Size of icon image
    if (himl)
        ImageList_GetIconSize (himl, &cxIcon, &cyIcon);

    // Sizeof combo
    cxCombo = rectCombo.right - rectCombo.left;
    cyText = tm.tmHeight + tm.tmExternalLeading;
    cyCombo = max (cyIcon, cyText);

    // Add a little extra
    cyCombo += (min (15, ComboBox_GetCount(hwndCombo)) * cyText);

    // Map upper left of combo
    pt.x = rectCombo.left;
    pt.y = rectCombo.top;
    MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rectCombo, 2);
    MoveWindow (hwndCombo, rectCombo.left, rectCombo.top, cxCombo, cyCombo, FALSE);


exit:
    // Cleanup
    if (hdc)
    {
        // Select Old font
        if (hFontOld)
            SelectObject (hdc, hFontOld);

        // Delete DC
        ReleaseDC (hwndDlg, hdc);
    }

    // Done
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\mso.h ===
#ifndef MSO_H
#define MSO_H

// we undef some of the macros here

#include "msoci.h"

#endif // MSO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\xputil.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     xputil.cpp
//
//  PURPOSE:    Utility functions that can be shared by all the transports.
//


#include "pch.hxx"
#include "imnxport.h"
#include "resource.h"
#include "xputil.h"
#include "strconst.h"
#include "xpcomm.h"
#include "demand.h"

//
//  FUNCTION:   XPUtil_DupResult()
//
//  PURPOSE:    Takes an IXPRESULT structure and duplicates the information
//              in that structure.
//
//  PARAMETERS:
//      <in> pIxpResult - IXPRESULT structure to dupe
//      <out> *ppDupe   - Returned duplicate.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT XPUtil_DupResult(LPIXPRESULT pIxpResult, LPIXPRESULT *ppDupe)
    {
    if (!MemAlloc((LPVOID*) ppDupe, sizeof(IXPRESULT)))
        return (E_OUTOFMEMORY);
    
    (*ppDupe)->hrResult = pIxpResult->hrResult;
    (*ppDupe)->pszResponse = PszDup(pIxpResult->pszResponse);
    (*ppDupe)->uiServerError = pIxpResult->uiServerError;
    (*ppDupe)->hrServerError = pIxpResult->hrServerError;
    (*ppDupe)->dwSocketError = pIxpResult->dwSocketError;
    (*ppDupe)->pszProblem = PszDup(pIxpResult->pszProblem);
    
    return (S_OK);        
    }

//
//  FUNCTION:   XPUtil_FreeResult()
//
//  PURPOSE:    Takes an IXPRESULT structure and frees all the memory used
//              by that structure.
//
//  PARAMETERS:
//      <in> pIxpResult - structure to free.
//
void XPUtil_FreeResult(LPIXPRESULT pIxpResult)
    {
    SafeMemFree(pIxpResult->pszResponse);
    SafeMemFree(pIxpResult->pszProblem);
    SafeMemFree(pIxpResult);
    }


//
//  FUNCTION:   XPUtil_StatusToString()
//
//  PURPOSE:    Converts the IXPSTATUS enumeration into a string resource id.
//
//  PARAMETERS:
//      <in> ixpStatus - status value to look up
//
//  RETURN VALUE:
//      Returns the string resource ID which matches the status value
//
int XPUtil_StatusToString(IXPSTATUS ixpStatus)
    {
    const int rgStatusStrings[9][2] = {
        { IXP_FINDINGHOST,   idsFindingHost   },
        { IXP_CONNECTING,    idsConnecting    },
        { IXP_SECURING,      idsSecuring      },
        { IXP_CONNECTED,     idsConnected     },
        { IXP_AUTHORIZING,   idsAuthorizing   },
        { IXP_AUTHRETRY,     idsAuthorizing   },
        { IXP_AUTHORIZED,    idsConnected     },
        { IXP_DISCONNECTING, idsDisconnecting },
        { IXP_DISCONNECTED,  idsNotConnected  }     
    };
    int iString = idsUnknown;

    for (UINT i = 0; i < 9; i++)
        {
        if (ixpStatus == rgStatusStrings[i][0])
            {
            iString = rgStatusStrings[i][1];
            break;
            }
        }
        
    // If this assert fires, it means someone added a status and didn't update 
    // the table.    
    Assert(iString != idsUnknown);    
    return (iString);    
    }    


LPTSTR XPUtil_NNTPErrorToString(HRESULT hr, LPTSTR pszAccount, LPTSTR pszGroup)
{
#ifndef WIN16
    const int rgErrorStrings[][2] = {
#else
    const LONG rgErrorStrings[][2] = {
#endif
        { IXP_E_NNTP_RESPONSE_ERROR,    idsNNTPErrUnknownResponse },
        { IXP_E_NNTP_NEWGROUPS_FAILED,  idsNNTPErrNewgroupsFailed },
        { IXP_E_NNTP_LIST_FAILED,       idsNNTPErrListFailed      },
        { IXP_E_NNTP_LISTGROUP_FAILED,  idsNNTPErrListGroupFailed },
        { IXP_E_NNTP_GROUP_FAILED,      idsNNTPErrGroupFailed     },
        { IXP_E_NNTP_GROUP_NOTFOUND,    idsNNTPErrGroupNotFound   }, 
        { IXP_E_NNTP_ARTICLE_FAILED,    idsNNTPErrArticleFailed   }, 
        { IXP_E_NNTP_HEAD_FAILED,       idsNNTPErrHeadFailed      }, 
        { IXP_E_NNTP_BODY_FAILED,       idsNNTPErrBodyFailed      }, 
        { IXP_E_NNTP_POST_FAILED,       idsNNTPErrPostFailed      }, 
        { IXP_E_NNTP_NEXT_FAILED,       idsNNTPErrNextFailed      }, 
        { IXP_E_NNTP_DATE_FAILED,       idsNNTPErrDateFailed      },
        { IXP_E_NNTP_HEADERS_FAILED,    idsNNTPErrHeadersFailed   },
        { IXP_E_NNTP_XHDR_FAILED,       idsNNTPErrXhdrFailed      },
        { IXP_E_CONNECTION_DROPPED,     idsErrPeerClosed          },
        { E_OUTOFMEMORY,                idsMemory                 },
        { IXP_E_SICILY_LOGON_FAILED,    IDS_IXP_E_SICILY_LOGON_FAILED   },
        { IXP_E_LOAD_SICILY_FAILED,     idsErrSicilyFailedToLoad  },
        { IXP_E_CANT_FIND_HOST,         idsErrCantFindHost        },
        { IXP_E_NNTP_INVALID_USERPASS,  idsNNTPErrPasswordFailed  },
        { IXP_E_TIMEOUT,                idsNNTPErrServerTimeout   }
    };
    int iString = idsNNTPErrUnknownResponse;
    int bCreatedEscaped;

    LPSTR pszEscapedAcct;
    // 2* in case every char is an ampersand, +1 for the terminator
    if (bCreatedEscaped = MemAlloc((LPVOID*)&pszEscapedAcct, 2*lstrlen(pszAccount)+1))
        PszEscapeMenuStringA(pszAccount, pszEscapedAcct, 2*lstrlen(pszAccount)+1);
    else
        pszEscapedAcct = pszAccount;
    

    // Look up the string in the string resource
    for (UINT i = 0; i < ARRAYSIZE(rgErrorStrings); i++)
        {
        if (hr == rgErrorStrings[i][0])
            {
            iString = rgErrorStrings[i][1];
            break;
            }
        }

    // Allocate a buffer for the string we're going to return
    LPTSTR psz;
    if (!MemAlloc((LPVOID*) &psz, sizeof(TCHAR) * (CCHMAX_STRINGRES + lstrlen(pszEscapedAcct) + lstrlen(pszGroup))))
        {
        if (bCreatedEscaped)
            MemFree(pszEscapedAcct);
        return NULL;
        }

    // Load the string resource
    TCHAR szRes[CCHMAX_STRINGRES];
    AthLoadString(iString, szRes, ARRAYSIZE(szRes));

    // Add any extra information to the error string that might be necessary
    switch (iString)
        {
        // Requires account name
        case idsNNTPErrUnknownResponse:
        case idsNNTPErrNewgroupsFailed:
        case idsNNTPErrListFailed:
        case idsNNTPErrPostFailed:
        case idsNNTPErrDateFailed:
        case idsErrCantFindHost:
        case idsNNTPErrPasswordFailed:
        case idsNNTPErrServerTimeout:
            wsprintf(psz, szRes, pszEscapedAcct);
            break;
        
        // Group name, then account name
        case idsNNTPErrListGroupFailed:
        case idsNNTPErrGroupFailed:
        case idsNNTPErrGroupNotFound:
            wsprintf(psz, szRes, pszGroup, pszEscapedAcct);
            break;

        // Group name only
        case idsNNTPErrHeadersFailed:
        case idsNNTPErrXhdrFailed:
            wsprintf(psz, szRes, pszGroup);
            break;

        default:
            lstrcpy(psz, szRes);            
        }

    if (bCreatedEscaped)
        MemFree(pszEscapedAcct);

    return (psz);
}



//
//  FUNCTION:   XPUtil_DisplayIXPError()
//
//  PURPOSE:    Displays a dialog box with the information from an IXPRESULT
//              structure.
//
//  PARAMETERS:
//      <in> pIxpResult - Pointer to the IXPRESULT structure to display.
//
int XPUtil_DisplayIXPError(HWND hwndParent, LPIXPRESULT pIxpResult,
                           IInternetTransport *pTransport)
    {
    CTransportErrorDlg *pDlg = 0;
    int iReturn = 0;
    
    pDlg = new CTransportErrorDlg(pIxpResult, pTransport);
    if (pDlg)
        iReturn = pDlg->Create(hwndParent);
    delete pDlg;
    
    return (iReturn);
    }


//
//  FUNCTION:   CTransportErrorDlg::CTransportErrorDlg()
//
//  PURPOSE:    Initializes the CTransportErrorDlg class.
//
CTransportErrorDlg::CTransportErrorDlg(LPIXPRESULT pIxpResult, IInternetTransport *pTransport)
    {
    m_hwnd = 0;
    m_fExpanded = TRUE;
    ZeroMemory(&m_rcDlg, sizeof(RECT));
    m_pIxpResult = pIxpResult;
    m_pTransport = pTransport;
    m_pTransport->AddRef();
    }

CTransportErrorDlg::~CTransportErrorDlg()
    {
    m_pTransport->Release();
    }

BOOL CTransportErrorDlg::Create(HWND hwndParent)    
    {
    return ((0 != DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddTransportErrorDlg),
                           hwndParent, ErrorDlgProc, (LPARAM) this)));
    }


//
//  FUNCTION:   CTransportError::ErrorDlgProc()
//
//  PURPOSE:    Dialog callback for the IXPError dialog.
//                
INT_PTR CALLBACK CTransportErrorDlg::ErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                               LPARAM lParam)
    {
    CTransportErrorDlg *pThis = (CTransportErrorDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stash the this pointer so we can use it later
            Assert(lParam);
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CTransportErrorDlg *) lParam;
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, 
                                               pThis->OnInitDialog);            
            
        case WM_COMMAND:
            if (pThis)
                HANDLE_WM_COMMAND(hwnd, wParam, lParam, pThis->OnCommand);
            return (TRUE);    
            
        case WM_CLOSE:
            Assert(pThis);
            if (pThis)
                HANDLE_WM_CLOSE(hwnd, wParam, lParam, pThis->OnClose);
            break;
        }
    
    return (FALSE);    
    }    


//
//  FUNCTION:   CTransportErrorDlg::OnInitDialog()
//
//  PURPOSE:    Initializes the dialog by setting the error strings and the 
//              detail strings.
//
//  PARAMETERS:
//      <in> hwnd      - Handle of the dialog window.
//      <in> hwndFocus - Handle of the control that will start with the focus.
//      <in> lParam    - Extra data being passed to the dialog.
//
//  RETURN VALUE:
//      Return TRUE to set the focus to hwndFocus
//
BOOL CTransportErrorDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
    RECT rcSep;
    HWND hwndDetails = GetDlgItem(hwnd, idcXPErrDetailText);
    
    // Save our window handle
    m_hwnd = hwnd;
    
    // Initialize the rectangles that we'll need for sizing later
    GetWindowRect(GetDlgItem(hwnd, idcXPErrSep), &rcSep);
    GetWindowRect(hwnd, &m_rcDlg);
    m_cyCollapsed = rcSep.top - m_rcDlg.top;

    ExpandCollapse(FALSE);
    
    // Center the error dialog over the desktop
    CenterDialog(hwnd);
    
    // Set the information into the dialog
    Assert(m_pIxpResult->pszProblem);
    SetDlgItemText(hwnd, idcXPErrError, m_pIxpResult->pszProblem);

    // Set up the details information
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES + CCHMAX_ACCOUNT_NAME];
    INETSERVER rInetServer;

    // Server Response:
    if (AthLoadString(idsDetail_ServerResponse, szRes, ARRAYSIZE(szRes)))
        {
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szRes);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)g_szCRLF);
        }

    if (m_pIxpResult->pszResponse)
        {
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM) -1, (LPARAM) -1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM) m_pIxpResult->pszResponse);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM) -1, (LPARAM )-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM) g_szCRLF);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM) -1, (LPARAM) -1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM) g_szCRLF);
        }

    // Get the account information from the server
    m_pTransport->GetServerInfo(&rInetServer);

    if (AthLoadString(idsDetails_Config, szRes, ARRAYSIZE(szRes)))
        {
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szRes);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)g_szCRLF);
        }

    // Account:
    if (!FIsStringEmpty(rInetServer.szAccount))
        {
        if (AthLoadString(idsDetail_Account, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
            wsprintf(szBuf, "   %s %s\r\n", szRes, rInetServer.szAccount);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szBuf);
            }
        }

    // Server:
    if (!FIsStringEmpty(rInetServer.szServerName))
        {
        TCHAR szServer[255 + CCHMAX_SERVER_NAME];
        if (AthLoadString(idsDetail_Server, szRes, sizeof(szRes)/sizeof(TCHAR)))
            {
            wsprintf(szServer, "   %s %s\r\n", szRes, rInetServer.szServerName);
            SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szServer);
            }
        }

    // Port:
    if (AthLoadString(idsDetail_Port, szRes, sizeof(szRes)/sizeof(TCHAR)))
        {
        wsprintf(szBuf, "   %s %d\r\n", szRes, rInetServer.dwPort);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szBuf);
        }
    
    // Secure:
    if (AthLoadString(idsDetail_Secure, szRes, sizeof(szRes)/sizeof(TCHAR)))
        {
        wsprintf(szBuf, "   %s %d\r\n", szRes, rInetServer.fSSL);
        SendMessage(hwndDetails, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        SendMessage(hwndDetails, EM_REPLACESEL, FALSE, (LPARAM)szBuf);
        }

    return (TRUE);
    }
    

//
//  FUNCTION:   CTransportErrorDlg::OnCommand()
//
//  PURPOSE:    Handle the various command messages dispatched from the dialog
//
void CTransportErrorDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    switch (id)
        {
        case IDOK:
            EndDialog(hwnd, 0);
            break;
            
        case idcXPErrDetails:
            ExpandCollapse(!m_fExpanded);
            break;
        }
    }

    
//
//  FUNCTION:   CTransportErrorDlg::OnClose()
//
//  PURPOSE:    Handles the WM_CLOSE notification by sending an IDOK to
//              the dialog.
//
void CTransportErrorDlg::OnClose(HWND hwnd)
    {
    SendMessage(hwnd, WM_COMMAND, IDOK, 0);
    }
    

//
//  FUNCTION:   CTransportErrorDlg::ExpandCollapse()
//
//  PURPOSE:    Takes care of showing and hiding the "details" part of the
//              error dialog.
//
//  PARAMETERS:
//      <in> fExpand - TRUE if we should be expanding the dialog.
//
void CTransportErrorDlg::ExpandCollapse(BOOL fExpand)
    {
    RECT rcSep;
    TCHAR szBuf[64];
    
    // Nothing to do
    if (m_fExpanded == fExpand)
        return;
    
    m_fExpanded = fExpand;
    
    GetWindowRect(GetDlgItem(m_hwnd, idcXPErrSep), &rcSep);
    
    if (!m_fExpanded)
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left, 
                     m_cyCollapsed, SWP_NOMOVE | SWP_NOZORDER);
    else
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left,
                     m_rcDlg.bottom - m_rcDlg.top, SWP_NOMOVE | SWP_NOZORDER);
                
    AthLoadString(m_fExpanded ? idsHideDetails : idsShowDetails, szBuf, 
                  ARRAYSIZE(szBuf));     
    SetDlgItemText(m_hwnd, idcXPErrDetails, szBuf);
    
    EnableWindow(GetDlgItem(m_hwnd, idcXPErrDetailText), m_fExpanded);      
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\envelope.h ===
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __envelope_h__
#define __envelope_h__

extern "C"{
#ifndef __IMsoEnvelope_FWD_DEFINED__
#define __IMsoEnvelope_FWD_DEFINED__
typedef interface IMsoEnvelope IMsoEnvelope;
#endif 	/* __IMsoEnvelope_FWD_DEFINED__ */

#ifndef __IMsoEnvelopeSite_FWD_DEFINED__
#define __IMsoEnvelopeSite_FWD_DEFINED__
typedef interface IMsoEnvelopeSite IMsoEnvelopeSite;
#endif 	/* __IMsoEnvelopeSite_FWD_DEFINED__ */

#ifndef __IMsoEnvelopeHost_FWD_DEFINED__
#define __IMsoEnvelopeHost_FWD_DEFINED__
typedef interface IMsoEnvelopeHost IMsoEnvelopeHost;
#endif 	/* __IMsoEnvelopeHost_FWD_DEFINED__ */

#include "objidl.h"
#ifndef DeclareInterfaceUtil
#define DeclareInterfaceUtil(iface)
#endif
	interface IMsoEnvelope;
	interface IMsoEnvelopeSite;
	interface IMsoEnvelopeHost;
	interface IMsoToolbar;
	interface IMsoToolbarUser;
	typedef struct MSOINST* HMSOINST;
#ifndef CMDIDS_DEFINED
#define CMDIDS_DEFINED
#define OLECMDID_PRIVATECMD_FIRST 0x4FFFFFFF
#define cmdidSend			(OLECMDID_PRIVATECMD_FIRST + 9)
#define cmdidCheckNames		(OLECMDID_PRIVATECMD_FIRST + 10)
#define cmdidAttach			(OLECMDID_PRIVATECMD_FIRST + 11)
#define cmdidOptions			(OLECMDID_PRIVATECMD_FIRST + 12)
#define cmdidSelectNames		(OLECMDID_PRIVATECMD_FIRST + 13)
#define cmdidFocusTo			(OLECMDID_PRIVATECMD_FIRST + 17)
#define cmdidFocusCc			(OLECMDID_PRIVATECMD_FIRST + 18)
#define cmdidFocusBcc		(OLECMDID_PRIVATECMD_FIRST + 19)
#define cmdidFocusSubject	(OLECMDID_PRIVATECMD_FIRST + 20)
#define cmdidFlag			(OLECMDID_PRIVATECMD_FIRST + 21)
#define cmdidSaveAttach		(OLECMDID_PRIVATECMD_FIRST + 22)
#define cmdidInsertFile		(OLECMDID_PRIVATECMD_FIRST + 23)
#define cmdidCheckSpelling	(OLECMDID_PRIVATECMD_FIRST + 24)
#define cmdidApp1			(OLECMDID_PRIVATECMD_FIRST + 25)
#define cmdidApp2			(OLECMDID_PRIVATECMD_FIRST + 26)
#define cmdidApp3			(OLECMDID_PRIVATECMD_FIRST + 27)
#define cmdidApp4			(OLECMDID_PRIVATECMD_FIRST + 28)
#define cmdidApp5			(OLECMDID_PRIVATECMD_FIRST + 29)
#endif
#define ENV_E_BUSY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200)

typedef struct MSOINST __RPC_FAR *HMSOINST;

#ifndef __IMsoEnvelope_INTERFACE_DEFINED__
#define __IMsoEnvelope_INTERFACE_DEFINED__

enum __MIDL_IMsoEnvelope_0001
    {	ENV_INIT_LOAD	= 0x1,
	ENV_INIT_FROMSTREAM	= 0x2,
	ENV_INIT_REPLYNOTE	= 0x4,
	ENV_INIT_FWDNOTE	= 0x8,
	ENV_INIT_NOBOOT	= 0x10,
	ENV_INIT_DOCBEHAVIOR	= 0x20,
	ENV_INIT_NOSHOW	= 0x40,
	ENV_INIT_INPROCHOST	= 0x80,
	ENV_INIT_READNOTE	= 0x100,
	ENV_INIT_NEWNOTE	= 0x200
    };

enum __MIDL_IMsoEnvelope_0002
    {	ENV_FOCUS_TAB	= 0x1,
	ENV_FOCUS_RESTORE	= 0x2,
	ENV_FOCUS_INITIAL	= 0x4
    };

enum __MIDL_IMsoEnvelope_0003
    {	ENV_SAVE_DOCFILE	= 0x1,
	ENV_SAVE_BODYPART	= 0x2,
	ENV_SAVE_TOMSG	= 0x8,
	ENV_SAVE_NOCOMMIT	= 0x10,
	ENV_SAVE_AUTOSAVE	= 0x20
    };

enum __MIDL_IMsoEnvelope_0004
    {	ENV_ATTACH_ASLINK	= 0x1,
	ENV_ATTACH_HIDDEN	= 0x2
    };

enum __MIDL_IMsoEnvelope_0005
    {	ENV_DEBUG_MARKMEM	= 0x1,
	ENV_DEBUG_AUTOTEST	= 0x2,
	ENV_DEBUG_DUMPALL	= 0x4
    };

enum __MIDL_IMsoEnvelope_0006
    {	ENV_DISPID_STRING	= 0,
	ENV_DISPID_DWORD	= 0x1000000,
	ENV_DISPID_STREAM	= 0x2000000,
	ENV_DISPID_TYPE_MASK	= 0xff000000,
	ENV_DISPID_ID_MASK	= 0xffffff,
	dispidHeader	= ENV_DISPID_STREAM | 0,
	dispidPrintHeader	= ENV_DISPID_STREAM | 0x1,
	dispidReplyHeader	= ENV_DISPID_STREAM | 0x2,
	dispidSubject	= ENV_DISPID_STRING | 0x37,
	dispidSendPictures	= ENV_DISPID_DWORD | 0x1000,
	dispidUserEmail	= ENV_DISPID_STRING | 0x1001,
	dispidOrigEmail	= ENV_DISPID_STRING | 0x1002,
	dispidMessageId	= ENV_DISPID_STRING | 0x1003,
	dispidOrigMsgId	= ENV_DISPID_STRING | 0x1004,
	dispidSensitivity	= ENV_DISPID_DWORD | 0x1005,
	dispidSendBtnText	= ENV_DISPID_STRING | 0x1006,
	dispidIsHTML	= ENV_DISPID_DWORD | 0x1007,
	dispidSomething	= 0xfffffff
    };

EXTERN_C const IID IID_IMsoEnvelope;

    
    MIDL_INTERFACE("00067298-0000-0000-C000-000000000046")
    IMsoEnvelope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ IMsoEnvelopeSite __RPC_FAR *penvsite,
            /* [in] */ DWORD grfInit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParent( 
            /* [in] */ HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            /* [in] */ LPCRECT prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD grfSave) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttach( 
            /* [in] */ LPCWSTR wszURL,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttach( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ LPCWSTR wszCID,
            /* [out][in] */ IStream __RPC_FAR *__RPC_FAR *ppstm,
            /* [out][in] */ DWORD __RPC_FAR *pgrfAttach) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpMode( 
            /* [in] */ BOOL fEnter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewAttach( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ DWORD grfAttach) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ DWORD grfFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHeaderInfo( 
            /* [in] */ ULONG dispid,
            /* [in] */ DWORD grfHeader,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHeaderInfo( 
            /* [in] */ ULONG dispid,
            /* [in] */ const void __RPC_FAR *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( 
            /* [in] */ HRESULT hr,
            /* [out][in] */ LPWSTR wszBuf,
            /* [in] */ ULONG cchBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDebug( 
            /* [in] */ DWORD grfDebug) = 0;
        
    };
    
#endif 	/* __IMsoEnvelope_INTERFACE_DEFINED__ */

#define DeclareIMsoEnvelopeMembers(IPURE) \
	STDMETHOD(Init)(THIS_ IUnknown* punk, IMsoEnvelopeSite* penvsite, DWORD grfInit) IPURE;\
	STDMETHOD(SetParent)(THIS_ HWND hwndParent) IPURE;\
	STDMETHOD(Resize)(THIS_ LPCRECT prc) IPURE;\
	STDMETHOD(Show)(THIS_ BOOL fShow) IPURE;\
	STDMETHOD(SetHelpMode)(THIS_ BOOL fEnter) IPURE;\
	STDMETHOD(Save)(THIS_ IStream* pstm, DWORD grfSave) IPURE;\
	STDMETHOD(GetAttach)(THIS_ LPCWSTR wszName, IStream** ppstm) IPURE;\
	STDMETHOD(SetAttach)(THIS_ LPCWSTR wszName, LPCWSTR wszFile, IStream** ppstm, DWORD* pgrfAttach) IPURE;\
	STDMETHOD(NewAttach)(THIS_ LPCWSTR wszName, DWORD grfAttach) IPURE;\
	STDMETHOD(SetFocus)(THIS_ DWORD grfFocus) IPURE;\
 STDMETHOD(GetHeaderInfo)(THIS_ ULONG dispid, DWORD grfHeader, void** ppv) IPURE;\
 STDMETHOD(SetHeaderInfo)(THIS_ ULONG dispid, const void* pv) IPURE;\
 STDMETHOD(IsDirty)(THIS) IPURE;\
 STDMETHOD(GetLastError)(THIS_ HRESULT hr, LPWSTR wszBuf, ULONG cchBuf) IPURE;\
 IfDebug(STDMETHOD(DoDebug)(THIS_ DWORD grfDebug) IPURE);\

DeclareInterfaceUtil(IMsoEnvelope)
#ifndef __IMsoEnvelopeSite_INTERFACE_DEFINED__
#define __IMsoEnvelopeSite_INTERFACE_DEFINED__

enum __MIDL_IMsoEnvelopeSite_0001
    {	ENV_CLOSE_LOGOFF	= 0x1,
	ENV_CLOSE_SEND	= 0x2,
	ENV_CLOSE_SHUTDOWN	= 0x4,
	ENV_CLOSE_USER	= 0x8
    };

enum __MIDL_IMsoEnvelopeSite_0002
    {	ENV_BODY_HTML	= 0x1,
	ENV_BODY_RTF	= 0x2,
	ENV_BODY_TEXT	= 0x3,
	ENV_BODY_MHTML	= 0x4,
	ENV_BODY_REPLY	= 0x10,
	ENV_BODY_FWD	= 0x20,
	ENV_BODY_ALLIMAGES	= 0x40,
	ENV_BODY_NOCLEAN	= 0x80,
	ENV_BODY_FMTMASK	= 0x7
    };

enum __MIDL_IMsoEnvelopeSite_0003
    {	ENV_MSG_FATALERROR	= 0x1,
	ENV_MSG_OTHERERROR	= 0x2,
	ENV_MSG_USEHR	= 0x4
    };

EXTERN_C const IID IID_IMsoEnvelopeSite;

    
    MIDL_INTERFACE("00067299-0000-0000-C000-000000000046")
    IMsoEnvelopeSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestResize( 
            /* [out][in] */ int __RPC_FAR *pcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseNote( 
            DWORD grfClose) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBody( 
            /* [in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwCodePage,
            /* [in] */ DWORD grfBody) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBody( 
            /* [in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwCodePage,
            /* [in] */ DWORD grfBody) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ BOOL fTab) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnvSetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DirtyToolbars( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPropChange( 
            /* [in] */ ULONG dispid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBodyDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandsOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMsoInst( 
            /* [in] */ HMSOINST __RPC_FAR *phinst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameWnd( 
            /* [out] */ HWND __RPC_FAR *phwndFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayMessage( 
            /* [in] */ HRESULT hr,
            /* [in] */ LPCWSTR wszError,
            /* [in] */ DWORD grfMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpMode( 
            /* [in] */ BOOL fEnter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerators( 
            /* [in] */ MSG __RPC_FAR *pMsg) = 0;
        
    };
    
#endif 	/* __IMsoEnvelopeSite_INTERFACE_DEFINED__ */

#define DeclareIMsoEnvelopeSiteMembers(IPURE) \
	STDMETHOD(RequestResize)(THIS_ int* pcHeight) IPURE;\
	STDMETHOD(CloseNote)(THIS_ DWORD grfClose) IPURE;\
	STDMETHOD(GetBody)(THIS_ IStream* pstm, DWORD dwCodePage, DWORD grfBody) IPURE;\
	STDMETHOD(SetBody)(THIS_ IStream* pstm, DWORD dwCodePage, DWORD grfBody) IPURE;\
	STDMETHOD(SetFocus)(THIS_ BOOL fTab) IPURE;\
 STDMETHOD(OnEnvSetFocus)(THIS) IPURE;\
 STDMETHOD(DirtyToolbars)(THIS) IPURE;\
 STDMETHOD(OnPropChange)(THIS_ ULONG dispid) IPURE;\
 STDMETHOD(IsBodyDirty)(THIS) IPURE;\
 STDMETHOD(HandsOff)(THIS) IPURE;\
 STDMETHOD(GetMsoInst)(THIS_ HMSOINST* phinst) IPURE;\
 STDMETHOD(GetFrameWnd)(THIS_ HWND* phwndFrame) IPURE;\
 STDMETHOD(DisplayMessage)(THIS_ HRESULT hr, LPCWSTR wszError, DWORD grfMsg) IPURE;\
 STDMETHOD(SetHelpMode)(THIS_ BOOL fEnter) IPURE;\
 STDMETHOD(TranslateAccelerators)(THIS_ MSG* pMsg) IPURE;\

DeclareInterfaceUtil(IMsoEnvelopeSite)
#ifndef __IMsoEnvelopeHost_INTERFACE_DEFINED__
#define __IMsoEnvelopeHost_INTERFACE_DEFINED__

enum __MIDL_IMsoEnvelopeHost_0001
    {	ENV_CREATE_INITMASK	= 0xff,
	ENV_CREATE_THEME	= 0x100,
	ENV_CREATE_ANNOTATE	= 0x200,
	ENV_CREATE_INET	= 0x400,
	ENV_CREATE_STATIONERY	= 0x800,
	ENV_CREATE_OMITBODY	= 0x1000,
	ENV_CREATE_INCLUDE	= 0x2000,
	ENV_CREATE_INDENT	= 0x3000,
	ENV_CREATE_PREFIX	= 0x4000,
	ENV_CREATE_BODYMASK	= 0x7000,
	ENV_CREATE_PLAINTEXT	= 0x8000
    };

EXTERN_C const IID IID_IMsoEnvelopeHost;

    
    MIDL_INTERFACE("0006729A-0000-0000-C000-000000000046")
    IMsoEnvelopeHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateNote( 
            /* [in] */ IUnknown __RPC_FAR *punk,
            /* [in] */ REFCLSID clsidCreate,
            /* [in] */ LPCWSTR wszTheme,
            /* [in] */ LPCWSTR wszAuthor,
            /* [in] */ LPCWSTR wszPrefix,
            /* [in] */ DWORD grfCreate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#endif 	/* __IMsoEnvelopeHost_INTERFACE_DEFINED__ */

#define DeclareIMsoEnvelopeHost(IPURE) \
	STDMETHOD(CreateNote)(THIS_ IUnknown* punk, LPCWSTR wszTheme, LPCWSTR wszAuthor, LPCWSTR wszPrefix, DWORD grfCreate) IPURE;\
	STDMETHOD(LockServer)(THIS_ BOOL fLock) IPURE;\

DeclareInterfaceUtil(IMsoEnvelopeHost)
STDAPI CreateEnvelopeObject(void** ppvObj);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\xputil.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     xputil.h
//
//  PURPOSE:    Functions that are used by the athena transport integration
//

#include "imnxport.h"

//
//  FUNCTION:   XPUtil_DupResult()
//
//  PURPOSE:    Takes an IXPRESULT structure and duplicates the information
//              in that structure.
//
//  PARAMETERS:
//      <in> pIxpResult - IXPRESULT structure to dupe
//      <out> *ppDupe   - Returned duplicate.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT XPUtil_DupResult(LPIXPRESULT pIxpResult, LPIXPRESULT *ppDupe);

//
//  FUNCTION:   XPUtil_FreeResult()
//
//  PURPOSE:    Takes an IXPRESULT structure and frees all the memory used
//              by that structure.
//
//  PARAMETERS:
//      <in> pIxpResult - structure to free.
//
void XPUtil_FreeResult(LPIXPRESULT pIxpResult);


//
//  FUNCTION:   XPUtil_StatusToString()
//
//  PURPOSE:    Converts the IXPSTATUS enumeration into a string resource id.
//
//  PARAMETERS:
//      <in> ixpStatus - status value to look up
//
//  RETURN VALUE:
//      Returns the string resource ID which matches the status value
//
int XPUtil_StatusToString(IXPSTATUS ixpStatus);

LPTSTR XPUtil_NNTPErrorToString(HRESULT hr, LPTSTR pszAccount, LPTSTR pszGroup);

//
//  FUNCTION:   XPUtil_DisplayIXPError()
//
//  PURPOSE:    Displays a dialog box with the information from an IXPRESULT
//              structure.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should parent the dialog.
//      <in> pIxpResult - Pointer to the IXPRESULT structure to display.
//
int XPUtil_DisplayIXPError(HWND hwndParent, LPIXPRESULT pIxpResult, 
                           IInternetTransport *pTransport);








class CTransportErrorDlg
    {
public:
    CTransportErrorDlg(LPIXPRESULT pIxpResult, IInternetTransport *pTransport);
    ~CTransportErrorDlg();
    BOOL Create(HWND hwndParent);
    
protected:
    static INT_PTR CALLBACK ErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnClose(HWND hwnd);
    void OnDestroy(HWND hwnd);
    
    void ExpandCollapse(BOOL fExpand);
    
private:
    HWND                m_hwnd;
    BOOL                m_fExpanded;
    RECT                m_rcDlg;
    LPIXPRESULT         m_pIxpResult;
    DWORD               m_cyCollapsed;
    IInternetTransport *m_pTransport;
    };


#define idcXPErrDetails    101
#define idcXPErrSep        102
#define idcXPErrError      103
#define idcXPErrDetailText 104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\convbase.h ===
#define MAXOVERFLOWBYTES 16

class CINetCodeConverter
{
public:
	CINetCodeConverter();
	~CINetCodeConverter() {}
	HRESULT GetStringSizeA(BYTE const* pbySource, long lSourceSize, long* plDestSize);
	HRESULT ConvertStringA(BYTE const* pbySource, long lSourceSize, BYTE* pbyDest, long lDestSize, long* lConvertedSize = NULL);

private:
	BOOL fOutputMode;
	BYTE* pbyOutput;
	long lOutputLimit;
	long lNumOutputBytes;
	int nNumOverflowBytes;
	BYTE OverflowBuffer[MAXOVERFLOWBYTES];

	HRESULT WalkString(BYTE const* pbySource, long lSourceSize, long* lConvertedSize);
	HRESULT EndOfDest(BYTE by);
	HRESULT OutputOverflowBuffer();

protected:
	virtual HRESULT ConvertByte(BYTE by) = 0;
	virtual HRESULT CleanUp() {return S_OK;}

protected:
	inline HRESULT Output(BYTE by)
	{
		HRESULT hr = S_OK;

		if (fOutputMode) {
			if (lNumOutputBytes < lOutputLimit)
				*pbyOutput++ = by;
			else
				hr = EndOfDest(by);
		}

		lNumOutputBytes++;

		return hr;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\msoci.h ===
/****************************************************************************
	MsoCI.h

	Owner: ClarG
 	Copyright (c) 1995 Microsoft Corporation

	This file contains the exported interfaces and declarations for 
	Office Component Integration.
****************************************************************************/

#ifndef MSOCI_H
#define MSOCI_H

#if !defined(MSOSTD_H)
#include <msostd.h>
#endif

#if !defined(MSOUSER_H)
#include <msouser.h>
#endif

#if !defined(MSODEBUG_H)
#include <msodebug.h>
#endif

#if MAC
#include <events.h>
#endif


/****************************************************************************
	Component integration structures and constants
****************************************************************************/

// Component registration flags
enum
	{
	msocrfNeedIdleTime         = 1,  // needs idle time
	msocrfNeedPeriodicIdleTime = 2,  // needs idle time every N milliseconds
	msocrfPreTranslateKeys     = 4,  // must process keyboard msgs 
	                                 // before translation
	msocrfPreTranslateAll      = 8,  // must process all msgs 
	                                 // before translation
	msocrfNeedSpecActiveNotifs = 16, // needs to be notified for special 
	                                 // activation changes (currently, this will
	                                 // notify comp if ExclusiveBorderSpace
	                                 // or ExclusiveActivation mode changes)
	                                 // Top-level comps should reg this flag.
	msocrfNeedTopActiveNotifs  = msocrfNeedSpecActiveNotifs, // old name
	msocrfNeedAllActiveNotifs  = 32, // needs to be notified for every
	                                 // change in activation state
	msocrfExclusiveBorderSpace = 64, // needs exclusive border space when 
	                                 // active (normally only used by TopLevel
	                                 // Mac components)
	msocrfExclusiveActivation = 128, // comp becomes exclusively active 
	                                 // when activated
	};

// Component registration advise flags (see msocstate enumeration)
enum
	{
	msocadvfModal              = 1,  // needs modal state change notification
	                                 //  (must be registered by components
	                                 //   managing a toplevel window)												
	msocadvfRedrawOff          = 2,  // needs redrawOff state change notif
	msocadvfWarningsOff        = 4,  // needs warningsOff state change notif
	msocadvfRecording          = 8,  // needs Recording state change notif
	};

// Component registration information
typedef struct _MSOCRINFO
	{
	ULONG cbSize;             // size of MSOCRINFO structure in bytes.
	ULONG uIdleTimeInterval;  // If msocrfNeedPeriodicIdleTime is registered
	                          // in grfcrf, component needs to perform
	                          // periodic idle time tasks during an idle phase
	                          // every uIdleTimeInterval milliseconds.
	DWORD grfcrf;             // bit flags taken from msocrf values (above)
	DWORD grfcadvf;           // bit flags taken from msocadvf values (above)
	} MSOCRINFO;


// Component Host flags
enum
	{
	msochostfExclusiveBorderSpace = 1,  // needs exclusive border space when 
	                                    // active (normally only used by 
	                                    // TopLevel Mac hosts)
	};

// Component Host information
typedef struct _MSOCHOSTINFO
	{
	ULONG cbSize;             // size of MSOCHOSTINFO structure in bytes.
	DWORD grfchostf;          // bit flags taken from msochostf values (above)
	} MSOCHOSTINFO;


// idle flags, passed to IMsoComponent::FDoIdle and 
// IMsoStdComponentMgr::FDoIdle.
enum
	{
	msoidlefPeriodic    = 1,  // periodic idle tasks
	msoidlefNonPeriodic = 2,  // any nonperiodic idle task
	msoidlefPriority    = 4,  // high priority, nonperiodic idle tasks
	msoidlefAll         = -1  // all idle tasks
	};


// Reasons for pushing a message loop, passed to 
// IMsoComponentManager::FPushMessageLoop and 
// IMsoComponentHost::FPushMessageLoop.  The host should remain in message
// loop until IMsoComponent::FContinueMessageLoop 
// (or IMsoStdComponentMgr::FContinueMessageLoop) returns FALSE.
enum
	{
	msoloopFocusWait = 1,  // component is activating host 
	msoloopDoEvents  = 2,  // component is asking host to process messages
	msoloopDebug     = 3,  // component has entered debug mode
	msoloopModalForm = 4   // component is displaying a modal form  
	};


/* msocstate values: state IDs passed to 
	IMsoComponent::OnEnterState, 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState/FInState,
	IMsoComponentHost::OnComponentEnterState,
	IMsoStdComponentMgr::OnHostEnterState/FOnHostExitState/FInState.
	When the host or a component is notified through one of these methods that 
	another entity (component or host) is entering or exiting a state 
	identified by one of these state IDs, the host/component should take
	appropriate action:
		msocstateModal (modal state):
			If app is entering modal state, host/component should disable
			its toplevel windows, and reenable them when app exits this
			state.  Also, when this state is entered or exited, host/component
			should notify approprate inplace objects via 
			IOleInPlaceActiveObject::EnableModeless.
		msocstateRedrawOff (redrawOff state):
			If app is entering redrawOff state, host/component should disable
			repainting of its windows, and reenable repainting when app exits
			this state.
		msocstateWarningsOff (warningsOff state):
			If app is entering warningsOff state, host/component should disable
			the presentation of any user warnings, and reenable this when
			app exits this state.
		msocstateRecording (Recording state):
			Used to notify host/component when Recording is turned on or off. */
enum
	{
	msocstateModal       = 1, // modal state; disable toplevel windows
	msocstateRedrawOff   = 2, // redrawOff state; disable window repainting
	msocstateWarningsOff = 3, // warningsOff state; disable user warnings
	msocstateRecording   = 4, // Recording state
	};


/*             ** Comments on State Contexts **
	IMsoComponentManager::FCreateSubComponentManager allows one to create a 
	hierarchical tree of component managers.  This tree is used to maintain 
	multiple contexts with regard to msocstateXXX states.  These contexts are 
	referred to as 'state contexts'.
	Each component manager in the tree defines a state context.  The
	components registered with a particular component manager or any of its
	descendents live within that component manager's state context.  Calls
	to IMsoComponentManager::OnComponentEnterState/FOnComponentExitState
	can be used to	affect all components, only components within the component
	manager's state context, or only those components that are outside of the
	component manager's state context.  IMsoComponentManager::FInState is used
	to query the state of the component manager's state context at its root.

   msoccontext values: context indicators passed to 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState.
	These values indicate the state context that is to be affected by the
	state change. 
	In IMsoComponentManager::OnComponentEnterState/FOnComponentExitState,
	the comp mgr informs only those components/host that are within the
	specified state context. */
enum
	{
	msoccontextAll    = 0, // all state contexts in state context tree
	msoccontextMine   = 1, // component manager's state context
	msoccontextOthers = 2, // all other state contexts outside of comp mgr's
	};


/*     ** WM_MOUSEACTIVATE Note (for top level compoenents and host) **
	If the active (or tracking) comp's reg info indicates that it
	wants mouse messages, then no MA_xxxANDEAT value should be returned 
	from WM_MOUSEACTIVATE, so that the active (or tracking) comp will be able
	to process the resulting mouse message.  If one does not want to examine
	the reg info, no MA_xxxANDEAT value should be returned from 
	WM_MOUSEACTIVATE if any comp is active (or tracking).
	One can query the reg info of the active (or tracking) component at any
	time via IMsoComponentManager::FGetActiveComponent. */

/* msogac values: values passed to 
	IMsoComponentManager::FGetActiveComponent. */ 
enum
	{
	msogacActive    = 0, // retrieve true active component
	msogacTracking   = 1, // retrieve tracking component
	msogacTrackingOrActive = 2, // retrieve tracking component if one exists,
	                            // otherwise retrieve true active component
	};


/* msocWindow values: values passed to IMsoComponent::HwndGetWindow. */ 
enum
	{
	msocWindowFrameToplevel = 0,
		/* MDI Apps should return the MDI frame (not MDI client) or App frame
			window, and SDI Apps should return the frame window which hosts the
			component. Basically it should be the topmost window which owns the
			component. For a toolbar set this will be the toplevel owner of
			TBS::m_hwnd. */

	msocWindowFrameOwner = 1,
		/* This is the window which owns the component. It could be same as
			the window obtained by msocWindowFrameTopLevel or be an owned window
			of that window. For a toolbar set this will be TBS::m_hwnd. */

	msocWindowComponent = 2,
		/* This is the "main" window of the component (if it has one). */

	msocWindowDlgOwner = 3,
		/* Caller wishes to display a dialog to be parented by the component.
			Component should return a window suitable for use as the dialog's
			owner window. */  
	};

/****************************************************************************
	Defines the IMsoComponent interface

	Any component that needs idle time, the ability to process
	messages before they are translated 
	(for example, to call TranslateAccelerator or IsDialogMessage),
	notification about modal states,
	or the ability push message loops 
	must implement this interface and register with the Component Manager.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponent

DECLARE_INTERFACE_(IMsoComponent, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponent is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Give component a chance to process the message pMsg before it is
		translated and dispatched. Component can do TranslateAccelerator,
		do IsDialogMessage, modify pMsg, or take some other action.
		Return TRUE if the message is consumed, FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreTranslateMessage) (THIS_ MSG *pMsg) PURE;

#if MAC
	/* Give Macintosh component a chance to process the event pEvt
		before it is processed by the host. 
		Return TRUE if the event is consumed, FALSE otherwise.
		(WLM components can simply return FALSE.) */
	MSOMETHOD_(BOOL, FPreProcessMacEvent) (THIS_ EventRecord *pEvt) PURE;
#endif // MAC
	
	/* Notify component when app enters or exits (as indicated by fEnter)
		the state identified by uStateID (a value from msocstate enumeration).
		Component should take action depending on value of uStateID
		(see msocstate comments, above).
		
		Note: If n calls are made with TRUE fEnter, component should consider 
		the state to be in effect until n calls are made with FALSE fEnter.
		
		Note: Components should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if component is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */
	MSOMETHOD_(void, OnEnterState) (THIS_ ULONG uStateID, BOOL fEnter) PURE;

	/* Notify component when the host application gains or loses activation.
		If fActive is TRUE, the host app is being activated and dwOtherThreadID
		is the ID of the thread owning the window being deactivated.
		If fActive is FALSE, the host app is being deactivated and 
		dwOtherThreadID is the ID of the thread owning the window being 
		activated.
		Note: this method is not called when both the window being activated
		and the one being deactivated belong to the host app. */
	MSOMETHOD_(void, OnAppActivate) (THIS_ 
		BOOL fActive, DWORD dwOtherThreadID) PURE;
	
	/* Notify the active component that it has lost its active status because
		the host or another component has become active. */
	MSOMETHOD_(void, OnLoseActivation) (THIS) PURE;

	/* Notify component when a new object is being activated.
		If pic is non-NULL, then it is the component that is being activated.
		In this case, fSameComponent is TRUE if pic is the same component as
		the callee of this method, and pcrinfo is the reg info of pic.
		If pic is NULL and fHostIsActivating is TRUE, then the host is the
		object being activated, and pchostinfo is its host info.
		If pic is NULL and fHostIsActivating is FALSE, then there is no current
		active object.

		If pic is being activated and pcrinfo->grf has the 
		msocrfExclusiveBorderSpace bit set, component should hide its border
		space tools (toolbars, status bars, etc.);
		component should also do this if host is activating and 
		pchostinfo->grfchostf has the msochostfExclusiveBorderSpace bit set.
		In either of these cases, component should unhide its border space
		tools the next time it is activated.

		If pic is being activated and pcrinfo->grf has the
		msocrfExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.  
		Component should retrieve the top frame window that is hosting pic
		(via pic->HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from component's own top frame window, 
			component should disable its windows and do other things it would do
			when receiving OnEnterState(msocstateModal, TRUE) notification. 
		Otherwise, if component is top-level, 
			it should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Component should remain in one of these states until the 
		ExclusiveActive mode ends, indicated by a future call to 
		OnActivationChange with ExclusiveActivation bit not set or with NULL
		pcrinfo. */
	MSOMETHOD_(void, OnActivationChange) (THIS_ 
		IMsoComponent *pic, 
		BOOL fSameComponent,
		const MSOCRINFO *pcrinfo,
		BOOL fHostIsActivating,
		const MSOCHOSTINFO *pchostinfo, 
		DWORD dwReserved) PURE;

	/* Give component a chance to do idle time tasks.  grfidlef is a group of
		bit flags taken from the enumeration of msoidlef values (above),
		indicating the type of idle tasks to perform.  
		Component may periodically call IMsoComponentManager::FContinueIdle; 
		if this method returns FALSE, component should terminate its idle 
		time processing and return.  
		Return TRUE if more time is needed to perform the idle time tasks, 
		FALSE otherwise.
		Note: If a component reaches a point where it has no idle tasks
		and does not need FDoIdle calls, it should remove its idle task
		registration via IMsoComponentManager::FUpdateComponentRegistration.
		Note: If this method is called on while component is performing a 
		tracking operation, component should only perform idle time tasks that
		it deems are appropriate to perform during tracking. */
	MSOMETHOD_(BOOL, FDoIdle) (THIS_ DWORD grfidlef) PURE;
	
	/* Called during each iteration of a message loop that the component
		pushed. uReason and pvLoopData are the reason and the component private 
		data that were passed to IMsoComponentManager::FPushMessageLoop.
		This method is called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no
		message is in the queue).  This method may be additionally called when
		the next message has already been removed from the queue, in which case
		pMsgPeeked is passed as NULL.
		Return TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the component manager terminates the loop without
		removing pMsgPeeked from the queue. */
	MSOMETHOD_(BOOL, FContinueMessageLoop) (THIS_ 
		ULONG uReason, void *pvLoopData, MSG *pMsgPeeked) PURE;

	/* Called when component manager wishes to know if the component is in a
		state in which it can terminate.  If fPromptUser is FALSE, component
		should simply return TRUE if it can terminate, FALSE otherwise.
		If fPromptUser is TRUE, component should return TRUE if it can
		terminate without prompting the user; otherwise it should prompt the
		user, either 1.) asking user if it can terminate and returning TRUE
		or FALSE appropriately, or 2.) giving an indication as to why it
		cannot terminate and returning FALSE. */
	MSOMETHOD_(BOOL, FQueryTerminate) (THIS_ BOOL fPromptUser) PURE;
	
	/* Called when component manager wishes to terminate the component's
		registration.  Component should revoke its registration with component
		manager, release references to component manager and perform any
		necessary cleanup. */
	MSOMETHOD_(void, Terminate) (THIS) PURE;

	/* Called to retrieve a window associated with the component, as specified
		by dwWhich, a msocWindowXXX value (see msocWindow, above).
		dwReserved is reserved for future use and should be zero.
		Component should return the desired window or NULL if no such window
		exists. */
	MSOMETHOD_(HWND, HwndGetWindow) (THIS_ 
		DWORD dwWhich, DWORD dwReserved) PURE;
	};


/****************************************************************************
	Defines the IMsoComponentManager interface

	A component manager is an object implementing the IMsoComponentManager
	interface.  The component manager coordinates components with its message
	loop for proper distribution of idle time and pre-translation message
	processing.	
	It also coordinates modalities and the pushing of message loops.
	The host application can implement its own component manager and register
	it via MsoFSetComponentManager or it can make use of the office supplied
	component manager via MsoFCreateStdComponentManager.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponentManager

DECLARE_INTERFACE_(IMsoComponentManager, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */
	MSOMETHOD(QueryService) (THIS_
		REFGUID guidService, REFIID iid, void **ppvObj) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponentManager is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Register component piComponent and its registration info pcrinfo with
		this component manager.  Return in *pdwComponentID a cookie which will
		identify the component when it calls other IMsoComponentManager
		methods.
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRegisterComponent) (THIS_
		IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, 
		DWORD *pdwComponentID) PURE;
	
	/* Undo the registration of the component identified by dwComponentID
		(the cookie returned from the FRegisterComponent method).
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRevokeComponent) (THIS_ DWORD dwComponentID) PURE;
	
	/* Update the registration info of the component identified by
		dwComponentID (the cookie returned from FRegisterComponent) with the
		new registration information pcrinfo.
		Typically this is used to update the idle time registration data, but
		can be used to update other registration data as well.
		Return TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FUpdateComponentRegistration) (THIS_ 
		DWORD dwComponentID, const MSOCRINFO *pcrinfo) PURE;
	
	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) has been activated.
		The active component gets the	chance to process messages before they
		are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
		gets first crack at idle time after the host.
		This method fails if another component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (comp usually need not take any special action
		in this case).
		Return TRUE if successful. */
	MSOMETHOD_(BOOL, FOnComponentActivate) (THIS_ DWORD dwComponentID) PURE;
	
	/* Called to inform component manager that  component identified by 
		dwComponentID (cookie returned from FRegisterComponent) wishes
		to perform a tracking operation (such as mouse tracking).
		The component calls this method with fTrack == TRUE to begin the
		tracking operation and with fTrack == FALSE to end the operation.
		During the tracking operation the component manager routes messages
		to the tracking component (via IMsoComponent::FPreTranslateMessage)
		rather than to the active component.  When the tracking operation ends,
		the component manager should resume routing messages to the active
		component.  
		Note: component manager should perform no idle time processing during a
		      tracking operation other than give the tracking component idle
		      time via IMsoComponent::FDoIdle.
		Note: there can only be one tracking component at a time.
		Return TRUE if successful, FALSE otherwise.  */
	MSOMETHOD_(BOOL, FSetTrackingComponent) (THIS_ 
		DWORD dwComponentID, BOOL fTrack) PURE;

	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is entering the state
		identified by uStateID (msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)  
		Component manager should notify all other interested components within
		the state context indicated by uContext (a msoccontextXXX value),
		excluding those within the state context of a CompMgr in rgpicmExclude,
		via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
		above).
		Component Manager should also take appropriate action depending on the 
		value of uStateID (see msocstate comments, above).
		dwReserved is reserved for future use and should be zero.

		rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
		include root CompMgr and/or sub CompMgrs); components within the state
		context of a CompMgr appearing in this	array should NOT be notified of 
		the state change (note: if uContext	is msoccontextMine, the only 
		CompMgrs in rgpicmExclude that are checked for exclusion are those that 
		are sub CompMgrs of this Component Manager, since all other CompMgrs 
		are outside of this Component Manager's state context anyway.)

		Note: Calls to this method are symmetric with calls to 
		FOnComponentExitState. 
		That is, if n OnComponentEnterState calls are made, the component is
		considered to be in the state until n FOnComponentExitState calls are
		made.  Before revoking its registration a component must make a 
		sufficient number of FOnComponentExitState calls to offset any
		outstanding OnComponentEnterState calls it has made.

		Note: inplace objects should not call this method with
		uStateID == msocstateModal when entering modal state. Such objects
		should call IOleInPlaceFrame::EnableModeless instead. */
	MSOMETHOD_(void, OnComponentEnterState) (THIS_ 
		DWORD dwComponentID, 
		ULONG uStateID, 
		ULONG uContext,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude, 
		DWORD dwReserved) PURE;
	
	/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is exiting the state
		identified by uStateID (a msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)
		uContext, cpicmExclude, and rgpicmExclude are as they are in 
		OnComponentEnterState.
		Component manager	should notify all appropriate interested components
		(taking into account uContext, cpicmExclude, rgpicmExclude) via
		IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
		Component Manager should also take appropriate action depending on
		the value of uStateID (see msocstate comments, above).
		Return TRUE if, at the end of this call, the state is still in effect
		at the root of this component manager's state context
		(because the host or some other component is still in the state),
		otherwise return FALSE (ie. return what FInState would return).
		Caller can normally ignore the return value.
		
		Note: n calls to this method are symmetric with n calls to 
		OnComponentEnterState (see OnComponentEnterState comments, above). */
	MSOMETHOD_(BOOL, FOnComponentExitState) (THIS_ 
		DWORD dwComponentID, 
		ULONG uStateID, 
		ULONG uContext,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude) PURE;

	/* Return TRUE if the state identified by uStateID (a msocstateXXX value)
		is in effect at the root of this component manager's state context, 
		FALSE otherwise (see "Comments on State Contexts", above).
		pvoid is reserved for future use and should be NULL. */
	MSOMETHOD_(BOOL, FInState) (THIS_ ULONG uStateID, void *pvoid) PURE;
	
	/* Called periodically by a component during IMsoComponent::FDoIdle.
		Return TRUE if component can continue its idle time processing, 
		FALSE if not (in which case component returns from FDoIdle.) */
	MSOMETHOD_(BOOL, FContinueIdle) (THIS) PURE;

	/* Component identified by dwComponentID (cookie returned from 
		FRegisterComponent) wishes to push a message loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		pvLoopData is data private to the component.
		The component manager should push its message loop, 
		calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
		during each loop iteration (see IMsoComponent::FContinueMessageLoop
		comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
		component manager terminates the loop.
		Returns TRUE if component manager terminates loop because component
		told it to (by returning FALSE from IMsoComponent::FContinueMessageLoop),
		FALSE if it had to terminate the loop for some other reason.  In the 
		latter case, component should perform any necessary action (such as 
		cleanup). */
	MSOMETHOD_(BOOL, FPushMessageLoop) (THIS_ 
		DWORD dwComponentID, ULONG uReason, void *pvLoopData) PURE;

	/* Cause the component manager to create a "sub" component manager, which
		will be one of its children in the hierarchical tree of component
		managers used to maintiain state contexts (see "Comments on State
		Contexts", above).
		piunkOuter is the controlling unknown (can be NULL), riid is the
		desired IID, and *ppvObj returns	the created sub component manager.
		piunkServProv (can be NULL) is a ptr to an object supporting
		IServiceProvider interface to which the created sub component manager
		will delegate its IMsoComponentManager::QueryService calls. 
		(see objext.h or docobj.h for definition of IServiceProvider).
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FCreateSubComponentManager) (THIS_ 
		IUnknown *piunkOuter, 
		IUnknown *piunkServProv,
		REFIID riid, 
		void **ppvObj) PURE;

	/* Return in *ppicm an AddRef'ed ptr to this component manager's parent
		in the hierarchical tree of component managers used to maintain state
		contexts (see "Comments on State	Contexts", above).
		Returns TRUE if the parent is returned, FALSE if no parent exists or
		some error occurred. */
	MSOMETHOD_(BOOL, FGetParentComponentManager) (THIS_ 
		IMsoComponentManager **ppicm) PURE;

	/* Return in *ppic an AddRef'ed ptr to the current active or tracking
		component (as indicated by dwgac (a msogacXXX value)), and
		its registration information in *pcrinfo.  ppic and/or pcrinfo can be
		NULL if caller is not interested these values.  If pcrinfo is not NULL,
		caller should set pcrinfo->cbSize before calling this method.
		Returns TRUE if the component indicated by dwgac exists, FALSE if no 
		such component exists or some error occurred.
		dwReserved is reserved for future use and should be zero. */
	MSOMETHOD_(BOOL, FGetActiveComponent) (THIS_ 
		DWORD dwgac, 
		IMsoComponent **ppic, 
		MSOCRINFO *pcrinfo,
		DWORD dwReserved) PURE;
	};


/****************************************************************************
	Defines the IMsoStdComponentMgr interface

	IMsoStdComponentMgr is an interface exposed by the office supplied
	standard component manager, created by MsoFCreateStdComponentMgr.
	The host application uses this interface to communicate directly with
	the standard component manager and indirectly with registered components.
	By making appropriate calls to this interface and implementing
	IMsoComponentHost the host can avoid implementing its own 
	IMsoComponentManager interface.
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoStdComponentMgr

DECLARE_INTERFACE_(IMsoStdComponentMgr, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoStdComponentMgr is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Set *pchostinfo as the host info.  Can be called multiple times.
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FSetHostInfo) (THIS_ 
		const MSOCHOSTINFO *pchostinfo) PURE;

	/* Host calls this method to give the active component a chance to
		process messages before they are translated and dispatched.
		The host need not call this method if no component is active.
		When this method is called on message pMsg, StdComponentMgr in turn 
		calls IMsoComponent::FPreTranslateMessage on the active component if
		its registration info indicates that it is interested.  
		Returns TRUE if message is consumed, in which case the host should
		perform no further processing on the message.  
		Returns FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreTranslateMessage) (THIS_ MSG *pMsg) PURE;

#if MAC
	/* On Macintosh, host calls this method to give the active component a 
		chance to process events before they are processed by the host.
		The host need not call this method if no component is active.
		When this method is called on event pEvt, StdComponentMgr in turn 
		calls IMsoComponent::FPreProcessMacEvent on the active component if
		its registration info indicates that it is interested.  
		Returns TRUE if event is consumed, in which case the host should
		perform no further processing on the event.  
		Returns FALSE otherwise. */
	MSOMETHOD_(BOOL, FPreProcessMacEvent) (THIS_ EventRecord *pEvt) PURE;
#endif // MAC

	/* Called by host to notify StdComponentMgr that one of the host's windows
		has been activated.  This causes the current active component to lose
		its active status.  However, host should not assume that the component
		is no longer active until 
		IMsoComponentHost::OnComponentActivate(NULL) is called.
		This method fails if a component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (host usually need not take any special action
		in this case).
		Returns TRUE if successful. */
	MSOMETHOD_(BOOL, FOnHostActivate) (THIS) PURE;

	/* Called by host to notify StdComponentMgr that host is entering the 
		state identified by uStateID (a msocstateXXX value).
		StdComponentMgr in turn notifies all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		dwReserved is reserved for future use and should be zero.
		Note: Calls to this method are symmetric with FOnHostExitState calls.
		That is, if n OnHostEnterState calls are made, the host is
		considered to be in the state until n FOnHostExitState calls are
		made. */
	MSOMETHOD_(void, OnHostEnterState) (THIS_ 
		ULONG uStateID, 
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude, 
		DWORD dwReserved) PURE;

	/* Called by host to notify StdComponentMgr that host is exiting the state 
		identified by uStateID (a msocstateXXX value).  
		StdComponentMgr in turn notifies  all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		Returns TRUE if the state is still in effect at the end of this call
		(because some component is still in the state), otherwise returns 
		FALSE (ie. returns what FInState would return).  Caller can normally
		ignore the return value.
		Note: n calls to this method are symmetric with n calls to 
		OnHostEnterState (see OnHostEnterState comments, above). */
	MSOMETHOD_(BOOL, FOnHostExitState) (THIS_ 
		ULONG uStateID,
		ULONG cpicmExclude,
		IMsoComponentManager **rgpicmExclude) PURE;

	/* Returns TRUE if state identified by uStateID (a value from msocstate
		enumeration) is in effect, FALSE otherwise.
		pvoid is reserved for future use and should be NULL. */
	MSOMETHOD_(BOOL, FInState) (THIS_ ULONG uStateID, void *pvoid) PURE;
	
	/* Called by host to give registered components the chance to perform idle
		time tasks of the type indicated by grfidlef, a group of bit flags
		taken from the enumeration of msoidlef values (above).
		During a component tracking operation, StdComponentMgr only gives the
		tracking component idle time.
		Returns TRUE if any component needs more time to perform the idle time
		tasks, FALSE otherwise. */
	MSOMETHOD_(BOOL, FDoIdle) (THIS_ DWORD grfidlef) PURE;

	/* Called by host just before it enters the 'wait mode' resulting from a
		call to WaitMessage, GetMessage, or MsgWaitForMultipleObjects.  Such a
		'wait mode' would prevent any components from receiving periodic idle 
		time.  If any registered components need periodic idle time, StdCompMgr
		starts an appropriate timer.  The resulting WM_TIMER message will cause
		the host	to exit the 'wait mode', allowing the processing of periodic 
		idle time tasks when the host calls IMsoStdComponentMgr::FDoIdle. */
	MSOMETHOD_(void, OnWaitForMessage) (THIS) PURE;

	/* Called by host during each iteration of a message loop that a component 
		pushed.
		This method is to be called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no 
		message is in the queue).  If this method is additionally called when
		the next message has already been removed from the queue, pMsgPeeked 
		should be passed as NULL.
		StdComponentMgr in turn calls IMsoComponent::FContinueMessageLoop
		on the component, and returns the value returned by that call. 
		Returns TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the loop should be terminated without removing
		pMsgPeeked from the queue. */
	MSOMETHOD_(BOOL, FContinueMessageLoop) (THIS_ MSG *pMsgPeeked) PURE;

	/* Called by host to determine if all registered components can terminate.
		StdComponentMgr asks each component whether it can terminate via
		IMsoComponent::FQueryTerminate(fPromptUser).  If all components
		return TRUE, then StdComponentMgr returns TRUE.  If any one of the
		components returns FALSE, then StdComponentMgr immediately returns
		FALSE without asking any more components. */
	MSOMETHOD_(BOOL, FQueryTerminate) (THIS_ BOOL fPromptUser) PURE;

	/* Called by host to terminate the StdComponentMgr.
		If fRevoke is TRUE and StdComponentMgr is registered as the current
		thread's component manager, this registration is revoked.
		Then, for each registered component, StdComponentMgr calls 
		IMsoComponent::Terminate and revokes its registration. */
	MSOMETHOD_(void, Terminate) (THIS_ BOOL fRevoke) PURE;
	};


/****************************************************************************
	Defines the IMsoComponentHost interface

	IMsoComponentHost is a host implemented interface that the standard
	component manager uses to communicate with the host.  By implementing
	this interface and making use of the standard component manager, the host
	can avoid having to implement its own component manager. 
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoComponentHost

DECLARE_INTERFACE_(IMsoComponentHost, IUnknown)
	{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* StdComponentMgr delegates calls to IMsoComponentManager::QueryService
		to the host by calling this method.
		Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */
	MSOMETHOD(QueryService) (THIS_
		REFGUID guidService, REFIID iid, void **ppvObj) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoComponentHost is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Called when component pic is activated (or should be treated as active
		by virtue of beginning a "tracking" operation 
		(see IMsoComponentManager::FSetTrackingComponent)).  
		pcrinfo contains component's registration information.  
		fTracking indicates whether the component is in tracking mode or not.
		If pic is NULL (in which case pcrinfo will be NULL), then this 
		indicates that no component is active.  
		When a component is active and its registration info indicates that it
		needs to process untranslated messages, the host must call 
		IMsoStdComponentMgr::FPreTranslateMessage for each appropriate message
		retrieved from the queue before processing it, so that the active 
		component gets a chance to process the message appropriately.
		(A simple host could avoid examining the component's registration info,
		 and simply call IMsoStdComponentMgr::FPreTranslateMessage for all
		 retrieved messages.)
		If the component is in tracking mode, as indicated by fTracking, then
		the host app should perform no idle time processing other than to give
		the tracking component idle time via IMsoStdComponentMgr::FDoIdle,
		until the tracking operation is completed (communicated to host via a
		subsequent call to OnComponentActivate with fTracking == FALSE).

		Additionally, if pic is nonNULL and fTracking is FALSE, then host 
		should check if pcrinfo->grfcrf has the ExclusiveActive or 
		ExclusiveBorderSpace bit set.  
		
		If ExclusiveBorderSpace bit is set, then host should hide its border
		space tools (toolbars, status bars, etc.) and not show them again until
		the host is reactivated.
		
		If ExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.
		Host should retrieve the top frame window that is hosting pic 
		(via pic->HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from host's own top frame window, 
			host should disable its windows and do other things it would do
			when receiving OnComponentEnterState(msocstateModal, TRUE)
			notification. 
		Otherwise, 
			host should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Host should remain in this state until the ExclusiveActive mode ends, 
		indicated by a future call to OnComponentActivate (with FALSE 
		fTracking) with ExclusiveActivation bit not set or NULL pcrinfo. */
	MSOMETHOD_(void, OnComponentActivate) (THIS_
		IMsoComponent *pic, const MSOCRINFO *pcrinfo, BOOL fTracking) PURE;
	
	/* Notify host that a component is entering or exiting (indicated by 
		fEnter) the state identified by uStateID (a msocstateXXX value).  
		Host should take action depending on value of uStateID (see msocstate
		comments, above). 
		
		Note: If n calls are made with TRUE fEnter, the host should consider
		the state to be in effect until n calls are made with FALSE fEnter.

		Note: Hosts should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if host is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */
	MSOMETHOD_(void, OnComponentEnterState) (THIS_
		ULONG uStateID, BOOL fEnter) PURE;
	
	/* Called periodically by StdComponentMgr during 
		IMsoStdComponentMgr::FDoIdle.
		Return TRUE if idle time processing can continue, FALSE if not. */
	MSOMETHOD_(BOOL, FContinueIdle) (THIS) PURE;

	/* Called by StdComponentMgr when a component wishes to push a message
		loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		The host should push its message loop, calling
		IMsoStdComponentMgr::FContinueMessageLoop during each loop iteration 
		(see IMsoStdComponentMgr::FContinueMessageLoop comments).
		When IMsoStdComponentMgr::FContinueMessageLoop returns FALSE, the host
		should terminate the loop.
		If host terminates the loop because StdComponentMgr told it to
		(by returning FALSE from IMsoStdComponentMgr::FContinueMessageLoop),
		host should return TRUE from this method.  If host had to terminate
		the loop for some other reason, it should return FALSE. */
	MSOMETHOD_(BOOL, FPushMessageLoop) (THIS_ ULONG uReason) PURE;
	};



/****************************************************************************
	Structures and constants for simple recording.
****************************************************************************/

// Simple recorder context values passed to IMsoSimpleRecorder::FGetContext
enum
	{
	msosrctxCommandBars = 0,			// pv will be the IMsoToolbarSet object
	msosrctxEscher = 1,
	msosrctxDrawing = 2,
	msosrctxDrawingSelection = 3,
	msosrctxDrawingSchemeColor = 4,
	msosrctxDrawingDefault = 5,
	};

/****************************************************************************
	Defines the IMsoSimpleRecorder interface
****************************************************************************/
#undef  INTERFACE
#define INTERFACE  IMsoSimpleRecorder

DECLARE_INTERFACE_(IMsoSimpleRecorder, IUnknown)
{
	BEGIN_MSOINTERFACE
	// *** IUnknown methods ***
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
	MSOMETHOD_(ULONG, AddRef) (THIS) PURE;
	MSOMETHOD_(ULONG, Release) (THIS) PURE;

	/* Standard FDebugMessage method.
	   Since IMsoSimpleRecorder is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */
	MSODEBUGMETHOD

	/* Returns a string specifying the position of the requested context
	   in the host's object model.  The context is specified by msosrctx, 
	   and the additional value pv if needed to disambiguate different 
	   objects of that type.  The string buffer should have room for
	   255 characters.  Returns TRUE if successful, FALSE otherwise. */
	MSOMETHOD_(BOOL, FGetContext)(THIS_ int msosrctx, void *pv, WCHAR *wz) PURE;

	/* Asks the host to record a line of text at the current position
	   in the recorder stream.  Returns TRUE if the line was successfully
	   recorded, FALSE otherwise. */
	MSOMETHOD_(BOOL, FRecordLine)(THIS_ WCHAR *wz) PURE;

	/* Returns TRUE if the host currently has recording turned on, and
	   FALSE otherwise. */
	MSOMETHOD_(BOOL, FRecording)(THIS) PURE;
};



/****************************************************************************
	Global DLL API's
****************************************************************************/

/* Called by host application to register picm as the component manager for
	the calling thread.  Standard reference counting rules apply.  
	picm can be NULL, indicating that the currently	registered component 
	manager should be revoked.
	If there is a previously registered component manager it is Released.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFSetComponentManager(IMsoComponentManager *picm);

/* Return in *ppicm an AddRef'ed pointer to the currently registered
	component manager for the calling thread.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFGetComponentManager(IMsoComponentManager **ppicm);

/* Create an object which has the Office supplied standard implementation
	of IMsoStdComponentMgr and IMsoComponentManager, and return it in *ppvObj.
	piUnkOuter is the controlling unknown for aggregation (can be NULL).
	pich (cannot be NULL) is the pointer to the IMsoComponentHost
	that will use the object.
	riid is the id of the desired interface.
	If fRegister is TRUE, the created object is registered as the calling
	thread's component manager.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFCreateStdComponentManager(
	IUnknown *piUnkOuter,
	IMsoComponentHost *pich,
	BOOL fRegister,
	REFIID riid,
	void **ppvObj);

#endif // MSOCI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\msodebug.h ===
/*************************************************************************
 	msodebug.h

 	Owner: rickp
 	Copyright (c) 1994 Microsoft Corporation

	Standard debugging definitions for the shared Office libraries.
	Includes asserts, tracing, and other cool stuff like that.
*************************************************************************/

#if !defined(MSODEBUG_H)
#define MSODEBUG_H

#if !defined(MSOSTD_H)
#include <msostd.h>
#endif

#if MAC && !defined(__TYPES__)
#include <macos\types.h>
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/*************************************************************************
	Random useful macros
*************************************************************************/

#if DEBUG
	#define Debug(e) e
	#define DebugOnly(e) e
	#define DebugElse(s, t)	s
#else
	#define Debug(e)
	#define DebugOnly(e)
	#define DebugElse(s, t) t
#endif


/****************************************************************************
   This enum contains the Debug "Messages" that are sent to the FDebugMessage
   Method
 ****************************************************************** JIMMUR **/
enum
{
	msodmWriteBe = 1, /* write out the BE record for this object */

	/* Here begin drawing only debug messages */
	msodmDgvRcvOfHsp = 2001,
		/* Ask a DGV for the bounding rectangle (if any) of an HSP.
			Assumes lParam is really a pointer to an MSODGDB, looks at the
			hsp field thereof and fills out the rcv field. */
	msodmDgsWriteBePvAnchor,
		/* Write out the BE record for a host allocated pvAnchor. */
	msodmDgsWriteBePvClient,
		/* Write out the BE record for any host allocated client data. */
	msodmDgvsAfterMouseInsert,
		/* Passed to IMsoDrawingViewSite after a shape is interactively
			inserted with the mouse. lParam is really the inserted HSP. */
	msodmDgvsAfterMarquee,
		/* Passed to IMsoDrawingViewSite after one drags out a rectangle
			with the pointer tool selecting zero or more shapes. */
	msodmIsNotMso96,
		/* Returns FALSE if the specified object is implemented by MSO96.DLL.
			Allows sleazy up-casts, for example, from IMsoDrawingView *
			to DGV *. */
	msodmGetHdesShape,
		/* Ask a DGVs for its m_hdesShape (in *(MSOHDES *)lParam).  Returns
			FALSE if it filled out an HDES. */
	msodmGetHdesSelection,
		/* Ask a DGVs for its m_hdesSelection (in *(MSOHDES *)lParam).
			Returns FALSE if it filled out an HDES. */
	msodmDguiWriteBeForDgc,
		/* Ask a DGUI to write BEs for a DGC it allocated. */
	msodmDgsWriteBeTxid,
		/* Write out the BE record for the attached text of a shape. */
	msodmDgsWriteBePvAnchorUndo,
		/* Write out the BE record for a host anchor in the undo stack. */
	msodmDgvsDragDrop,
		/* Let the host know that I just did a drag-drop from this window. */
};

enum
{
   msodmbtDoNotWriteObj = 0,    // Do Not write out the object 
   msodmbtWriteObj,             // Do write out the object and
                                    // embedded pointers
};


enum
{
	msocchBt = 20,						// Maximum size of a Bt description String
};

/* Some debug messages need more arguments than fit through
	the arguments to FDebugMethod.  For these there are various
	MSODMBfoo structs, usually defined near the objects they're passed
	to. */


/****************************************************************************
    Interface debug routine
 ****************************************************************** JIMMUR **/
#if DEBUG
   #define MSODEBUGMETHOD  MSOMETHOD_(BOOL, FDebugMessage) (THIS_ HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam) PURE;

   #define MSODEBUGMETHODIMP MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam); \
         static BOOL FCheckObject(LPVOID pv, int cb);
			
	#define MSOMACDEBUGMETHODIMP MSOMACPUB	 MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam); \
         static BOOL FCheckObject(LPVOID pv, int cb);

   #define DEBUGMETHOD(cn,bt) STDMETHODIMP_(BOOL) cn::FDebugMessage \
         (HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam) \
         { \
            if (msodmWriteBE == message) \
               {  \
                  return MsoFSaveBe(hinst,lParam,(void*)this,sizeof(cn),bt); \
               } \
            return FALSE; \
         }
 #else
   #define MSODEBUGMETHOD  MSOMETHOD_(BOOL, FDebugMessage) (THIS_ HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam) PURE;

   #define MSODEBUGMETHODIMP MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam);
			
   #define MSOMACDEBUGMETHODIMP MSOMACPUB MSOMETHODIMP_(BOOL) FDebugMessage (HMSOINST hinst, \
         UINT message, WPARAM wParam, LPARAM lParam);
	
   #define DEBUGMETHOD(cn,bt)  STDMETHODIMP_(BOOL) cn::FDebugMessage (HMSOINST, \
         UINT, WPARAM, LPARAM) { return TRUE; }
#endif



/*************************************************************************
	Enabling/disabling debug options
*************************************************************************/

enum
{
	msodcAsserts = 0,	/* asserts enabled */
	msodcPushAsserts = 1, /* push asserts enabled */
	msodcMemoryFill = 2,	/* memory fills enabled */
	msodcMemoryFillCheck = 3,	/* check memory fills */
	msodcTrace = 4,	/* trace output */
	msodcHeap = 5,	/* heap checking */
	msodcMemLeakCheck = 6,
	msodcMemTrace = 7,	/* memory allocation trace */
	msodcGdiNoBatch = 8,	/* don't batch GDI calls */
	msodcShakeMem = 9,	/* shake memory on allocations */
	msodcReports = 10,	/* report output enabled */
	msodcMsgTrace = 11,	/* WLM message trace - MAC only */
	msodcWlmValidate = 12,	/* WLM parameter validation - MAC only */
	msodcGdiNoExcep = 13,  /* Don't call GetObjectType for debug */
	msodcDisplaySlowTests = 14, /* Do slow (O(n^2) and worse) Drawing debug checks */
	msodcDisplayAbortOften = 15, /* Check for aborting redraw really often. */
	msodcDisplayAbortNever = 16, /* Don't abort redraw */
	msodcPurgedMaxSmall = 17,
	msodcSpare18 = 18, /* USE ME */
	msodcSpare19 = 19, /* USE ME */
	msodcSpare20 = 20, /* USE ME */
	msodcSpare21 = 21, /* USE ME */
	msodcSpare22 = 22, /* USE ME */
	msodcMax = 23,
};


/* Enables/disables various office debug checks. dc is the check to 
	change, fEnabled is TRUE if the check should be enabled, FALSE
	if disabled */
#if DEBUG
	extern MSOPUBDATA BYTE msovmpdcfDisabled[msodcMax];
	MSOAPI_(BOOL) MsoEnableDebugCheck(int dc, BOOL fEnabled);
	#if MAC && !OFFICE_BUILD
		// LATER: work-around linker bug that causes bad toc for exported data
		MSOAPI_(BOOL) MsoFGetDebugCheck(int dc);
	#else
		#define MsoFGetDebugCheck(dc) (!msovmpdcfDisabled[(dc)])
	#endif
#else
	#define MsoEnableDebugCheck(dc, fEnabled) (FALSE)
	#define MsoFGetDebugCheck(dc) (FALSE)
#endif


/*	Assert Output types */
enum
{
	msoiasoAssert,
	msoiasoTrace,
	msoiasoReport,
	msoiasoMax
};


/*	Returns the current debug output settings.  Note that these are
	macros referencing a DLL global variable. */
#define MsoFAssertsEnabled() (MsoFGetDebugCheck(msodcAsserts))
#define MsoFTraceEnabled() (MsoFGetDebugCheck(msodcTrace))
#define MsoFReportsEnabled() (MsoFGetDebugCheck(msodcReports))

enum
{
	msoaoDebugger = 0x01,	/* output to debugger */
	msoaoFile = 0x02,	/* output goes to file */
	msoaoMsgBox = 0x04,	/* output displayed in message box (no Traces) */
	msoaoPort = 0x08,	/* output sent to serial port */
	msoaoMappedFile = 0x10,	/* output recorded in memory mapped file */
	msoaoDebugBreak = 0x20,	/* msoaoDebugger breaks into the debugger */

	msoaoAppend = 0x8000,	/* output appended to existing file */
};

/*	Sets the destination of assert output */
#if DEBUG
	MSOAPI_(int) MsoSetAssertOutput(int iaso, int ao);
#else
	#define MsoSetAssertOutput(iaso, ao) (0)
#endif

/*	Returns the current assert output destination. */
#if DEBUG
	MSOAPI_(int) MsoGetAssertOutput(int iaso);
#else
	#define MsoGetAssertOutput(iaso) (0)
#endif

/* Sets the name of the file that the assert information gets written
	to, if file output is enabled using msoaoFile */
#if DEBUG
	MSOAPI_(void) MsoSetAssertOutputFile(int iaso, const CHAR* szFile);
#else
	#define MsoSetAssertOutputFile(iaso, szFile) (0)
#endif

/*	Returns the current name of the file that we're writing assert
	output to.   The name is saved in the buffer szFile, which must be
	cchMax characters long.  Returns the actual  length of the string
	returned. */
#if DEBUG
	MSOAPIXX_(int) MsoGetAssertOutputFile(int iaso, CHAR* szFile, int cchMax);
#else
	#define MsoGetAssertOutputFile(iaso, szFile, cchMax) (0)
#endif


/*************************************************************************
	Debugger breaks
*************************************************************************/

/* Breaks into the debugger.  Works (more or less) on all supported
 	systems. */
#if X86
	#define MsoDebugBreakInline() {__asm int 3}
#elif MAC
	#define MsoDebugBreakInline() Debugger()
#else
	#define MsoDebugBreakInline() \
		{ \
		__try { DebugBreak(); } \
		__except(EXCEPTION_EXECUTE_HANDLER) { OutputDebugStringA("DebugBreak"); } \
		}
#endif

/*	A version of debug break that you can actually call, instead of the
	above inline weirdness we use in most cases.  Can therefore be used in
	expressions. Returns 0 */
#if DEBUG
	MSOAPI_(int) MsoDebugBreak(void);
#else
	#define MsoDebugBreak() (0)
#endif


/*************************************************************************
	Assertion failures
*************************************************************************/

#if !defined(MSO_NO_ASSERTS)

/*	Displays the assert message, including flushing any assert stack.
	szFile and li are the filename and line number of the failure,
	and szMsg is an optional message to display with the assert.
	Returns FALSE if the caller should break into the debugger. */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssert(const CHAR* szFile, int li, const CHAR* szMsg);
#else
	#define MsoFAssert(szFile, li, szMsg) (TRUE)
#endif

/*	Same as MsoFAssert above, except an optional title string can be
	displayed. */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssertTitle(const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg);
#else
	#define MsoFAssertTitle(szTitle, szFile, li, szMsg) (TRUE)
#endif

/*	Same as MsoFAssertTitle above, except you can pass in your own 
	MessageBox flags */
#if DEBUG
	MSOAPIXX_(BOOL) MsoFAssertTitleMb(const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg, UINT mb);
#else
	#define MsoFAssertTitleMb(szTitle, szFile, li, szMsg, mb) (TRUE)
#endif

/*	Same as MsoFAssertTitleMb above, except you can pass in your own 
	assert output type */
#if DEBUG
	MSOAPI_(BOOL) MsoFAssertTitleAsoMb(int iaso, const CHAR* szTitle,
			const CHAR* szFile, int li, const CHAR* szMsg, UINT mb);
#else
	#define MsoFAssertTitleAsoMb(iaso, szTitle, szFile, li, szMsg, mb) (TRUE)
#endif

/*	To save space used by debug strings, you must declare the assert data
	in any file that uses asserts */
#if DEBUG
	#define AssertData static const CHAR vszAssertFile[] = __FILE__;
#else
	#define AssertData
#endif



/*	The actual guts of the assert.  if the flag f is FALSE, then we kick
	of the assertion failure, displaying the optional message szMsg along
	with the filename and line number of the failure */
#if !DEBUG
	#define AssertMsg(f, szMsg)
	#define AssertMsgInline(f, szMsg)
	#define AssertMsgTemplate(f, szMsg)
#else
	#define AssertMsg(f, szMsg) \
		do { \
		if (MsoFAssertsEnabled() && !(f) && \
				!MsoFAssert(vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	#define AssertMsgInline(f, szMsg) \
		do { \
		if (MsoFAssertsEnabled() && !(f) && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	// Template inlines don't like the inline __asm for some reason
	#define AssertMsgTemplate(f, szMsg) \
		do { \
		if (MsoFAssertsEnabled() && !(f) && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreak(); \
		} while (0)
#endif


/*	Tells if the Office is currently displaying an alert message box */
#if !DEBUG
	#define MsoFInAssert() (FALSE)
#else
	MSOAPI_(BOOL) MsoFInAssert(void);
#endif

/*	Random compatability versions of the assert macros */

#if 0
#define VSZASSERT AssertData
#if MSO_ASSERT_EXP
	#define Assert(f) AssertMsg((f), #f)
	#define AssertInline(f) AssertMsgInline((f), #f)
	#define AssertTemplate(f) AssertMsgTemplate((f), #f)
#else
	#define Assert(f) AssertMsg((f), NULL)
	#define AssertInline(f) AssertMsgInline((f), NULL)
	#define AssertTemplate(f) AssertMsgTemplate((f), NULL)
#endif
#define AssertExp(f) AssertMsg((f), #f)
#define AssertSz(f, szMsg) AssertMsg((f), szMsg)
#endif


/*************************************************************************
	Verification failures
*************************************************************************/

/*	Like Assert, except the test is still made in the ship version
 	of the application.  Especially useful for tests that have
 	required side-effects. */

#if !DEBUG
	#define VerifyMsg(f, szMsg) (f)
	#define VerifyMsgInline(f, szMsg) (f)
#else
	#define VerifyMsg(f, szMsg) \
		do { \
		if (!(f) && MsoFAssertsEnabled() && \
				!MsoFAssert(vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
	#define VerifyMsgInline(f, szMsg) \
		do { \
		if (!(f) && MsoFAssertsEnabled() && \
				!MsoFAssert(__FILE__, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#if MSO_ASSERT_EXP
	#define Verify(f) VerifyMsg((f), #f)
#else
	#define Verify(f) VerifyMsg((f), NULL)
#endif	
#define VerifyExp(f) VerifyMsg((f), #f)
#if 0
#define SideAssert(f) Verify(f)
#endif
#define AssertDo(f) Verify(f)

/*************************************************************************
	Untested notifications
*************************************************************************/

#if !DEBUG
	#define UntestedMsg(szMsg)
#else
	#define UntestedMsg(szMsg) \
		do { \
		if (MsoFAssertsEnabled() && \
				!MsoFAssertTitle("Untested", vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#define Untested() UntestedMsg(NULL)


/*************************************************************************
	Unreached notifications
*************************************************************************/

#if !DEBUG
	#define UnreachedMsg(szMsg)
#else
	#define UnreachedMsg(szMsg) \
		do { \
		if (MsoFAssertsEnabled() && \
				!MsoFAssertTitle("Unreached", vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#endif

#define Unreached() UnreachedMsg(NULL)


/*************************************************************************
	PushAsserts
*************************************************************************/

/*	Like Assert, except the message is not immediately displayed.
	Instead, the message is saved on a LIFO stack, which is dumped
	to the screen when an Assert eventually occurs.  This can be
	useful for displaying additional information about the type of
	failure inside a nested validation routine.

 	Yeah, I know, this is a bad idea, but I had the code, so I
	might as well  use it. */

#if !DEBUG
	#define MsoFPushAssert(szFile, li, szMsg) (0)
	#define PushAssertMsg(f, szMsg) (1)
#else
	MSOAPIXX_(BOOL) MsoFPushAssert(const CHAR* szFile, int li, const CHAR* szMsg);
	#define PushAssertMsg(f, szMsg) \
		((f) || (!MsoFPushAssert(vszAssertFile, __LINE__, szMsg) && MsoDebugBreak()))
#endif

#if MSO_ASSERT_EXP
	#define PushAssert(f) PushAssertMsg((f), #f)
#else
	#define PushAssert(f) PushAssertMsg((f), NULL)
#endif	
#define PushAssertExp(f) PushAssertMsg((f), #f)


/*************************************************************************
	Scratch GDI Objects
*************************************************************************/

/*	Routines to ensure only single access to global scratch GDI objects */

#if !DEBUG

	#define MsoUseScratchObj(hobj, szObjName)
	#define MsoReleaseScratchObj(hobj, szObjName)
	#define UseScratchDC(hdc)
	#define ReleaseScratchDC(hdc)
	#define UseScratchRgn(hrgn)
	#define ReleaseScratchRgn(hrgn)

#else

	/* mask that contains unused bits in the handle */
	#if MAC
		#define msohInUse (0x00000003)
		#define MsoFObjInUse(hobj) (((int)(hobj)&msohInUse)==0)
	#else
		#define msohInUse (0xffffffff)
		// REVIEW: any handle bits we can rely on to make this test more correct?
		#define MsoFObjInUse(hobj) (GetObjectType(hobj) != 0)
	#endif

	#define MsoUseScratchObj(hobj, szObjName) \
			do { \
			if (MsoFObjInUse(hobj) && MsoFAssertsEnabled() && \
					!MsoFAssert(vszAssertFile, __LINE__, "Scratch " szObjName " " #hobj " already in use")) \
				MsoDebugBreakInline(); \
			*(int*)&(hobj) ^= msohInUse; \
			} while (0)

	#define MsoReleaseScratchObj(hobj, szObjName) \
			do { \
			if (!MsoFObjInUse(hobj) && MsoFAssertsEnabled() && \
					!MsoFAssert(vszAssertFile, __LINE__, "Scratch " szObjName " " #hobj " not in use")) \
				MsoDebugBreakInline(); \
			*(int*)&(hobj) ^= msohInUse; \
			} while (0)

	#define UseScratchDC(hdc) MsoUseScratchObj(hdc, "DC")
	#define ReleaseScratchDC(hdc) MsoReleaseScratchObj(hdc, "DC")
	#define UseScratchRgn(hrgn) MsoUseScratchObj(hrgn, "region")
	#define ReleaseScratchRgn(hrgn) MsoReleaseScratchObj(hrgn, "region")

#endif


/*************************************************************************
	Reports
*************************************************************************/

#if DEBUG
	MSOAPI_(BOOL) MsoFReport(const CHAR* szFile, int li, const CHAR* szMsg);
	#define ReportMsg(f, szMsg) \
		do { \
		if (MsoFReportsEnabled() && !(f) && \
				!MsoFReport(vszAssertFile, __LINE__, (const CHAR*)(szMsg))) \
			MsoDebugBreakInline(); \
		} while (0)
#else
	#define MsoFReport(szFile, li, szMsg) (TRUE)
	#define ReportMsg(f, szMsg)
#endif


#endif // MSO_NO_ASSERTS

/*************************************************************************
	Inline Assert stubs - these should only happen for people who
	define MSO_NO_ASSERTS and don't define the asserts we need.
	They don't get asserts.
*************************************************************************/

#ifndef AssertMsgInline
	#define AssertMsgInline(f, szMsg)
#endif
#ifndef AssertMsgTemplate
	#define AssertMsgTemplate(f, szMsg)
#endif
#ifndef AssertInline
	#define AssertInline(f)
#endif
#ifndef AssertTemplate
	#define AssertTemplate(f)
#endif


/*************************************************************************
	Tracing
*************************************************************************/

/*	Displays the string sz in the debug output location */
#if DEBUG
	MSOAPI_(void) MsoTraceSz(const CHAR* szMsg, ...);
	MSOAPI_(void) MsoTraceVa(const CHAR* szMsg, va_list va);
#elif __cplusplus
	__inline void __cdecl MsoTraceSz(const CHAR*,...) {}
	#define MsoTraceVa(szMsg, va)
#else
	__inline void __cdecl MsoTraceSz(const CHAR* szMsg,...) {}
	#define MsoTraceVa(szMsg, va)
#endif



/*************************************************************************
	Debug fills
*************************************************************************/

enum
{
	msomfSentinel,	/* sentinel fill value */
	msomfFree,	/* free fill value */
	msomfNew,	/* new fill value */
	msomfMax
};

/*	Fills the memory pointed to by pv with the fill value lFill.  The
	area is assumed to be cb bytes in length.  Does nothing in the
	non-debug build */
#if DEBUG
	MSOAPI_(void) MsoDebugFillValue(void* pv, int cb, DWORD lFill);
#else
	#define MsoDebugFillValue(pv, cb, lFill)
#endif

/*	In the debug version, used to fill the area of memory pointed to by
	pv with a the standard fill value specified by mf.  The memory is 
	assumed to be cb bytes long. */
#if DEBUG
	MSOAPI_(void) MsoDebugFill(void* pv, int cb, int mf);
#else
	#define MsoDebugFill(pv, cb, mf)
#endif

/*	Checks the area given by pv and cb are filled with the debug fill
	value lFill. */
#if DEBUG
	MSOAPI_(BOOL) MsoFCheckDebugFillValue(void* pv, int cb, DWORD lFill);
#else
	#define MsoFCheckDebugFillValue(pv, cb, lFill) (TRUE)
#endif

/*	Checks the area given by pv and cb are filled with the debug fill
	of type mf. */
#if DEBUG
	MSOAPI_(BOOL) MsoFCheckDebugFill(void* pv, int cb, int mf);
#else
	#define MsoFCheckDebugFill(pv, cb, mf) (TRUE)
#endif

/* Returns the fill value corresponding to the given fill value type mf. */
#if DEBUG
	MSOAPI_(DWORD) MsoLGetDebugFillValue(int mf);
#else
	#define MsoLGetDebugFillValue(mf) ((DWORD)0)
#endif

/*	Sets the fill value to lFill for the given memory fill type mf.
	Returns the previous fill value. */
#if DEBUG
	MSOAPI_(DWORD) MsoSetDebugFillValue(int mf, DWORD lFill);
#else
	#define MsoSetDebugFillValue(mf, lFill) ((DWORD)0)
#endif

#define MsoDebugFillLocal(l) MsoDebugFill(&(l), sizeof(l), msomfFree)

/*************************************************************************
	Debug APIs
*************************************************************************/

enum
{
	msodbSaveBe = 1,
	msodbValidate = 2,
};


/*************************************************************************
	Standard debugging UI for controlling Office debug options from
	within the app.
*************************************************************************/

/*	Debug options for the Debug Options dialog box */
typedef struct MSODBO
{
	int aoEnabled;	// assert outputs
	char szOut[128];	// assert output file (for msoaoFile)
	DWORD mpmflFill[msomfMax];	// memory fill values
	BOOL mpdcfEnabled[msodcMax];	// debug checks enabled
		/* TODO rickp(peteren): I moved mpdcfEnabled to the end
			so's you could avoid full builds after adding new options.
			That OK? */
} MSODBO;

enum
{
	msodboGetDefaults = 1,	/* return default debug options */
	msodboShowDialog = 2,	/* show default debug options dialog */
	msodboSetOptions = 3	/* set debug options */
};

/*	Displays the Office standard debug dialog box with owner hwndParent;
	for msdboGetDefaults, returns the current debug settings in pdbo; for
	msdboShowDialog, displays the dialog box using the settings passed
	in pdbo, and returns the new values (if the user hits OK); for 
	msdboSetOptions, sets the current debug settings to values in pdbo.
	Returns FALSE if the user canceled the dialog. */
#if DEBUG
	MSOAPI_(BOOL) MsoFDebugOptionsDlg(HWND hwndParent, MSODBO* pdbo, int dbo);
#else
	#define MsoFDebugOptionsDlg(hwndParent, pdbo, dbo) (0)
#endif

/*	Puts up the debug dialog box that displays all the cool and
	interesting version information for all the modules linked into
	the running application.  The owning window is hwndParent, and
	additional DLL instances can be displayed by passing an array
	of instance handles in rghinst, with size chinst. */
#if DEBUG
	MSOAPI_(void) MsoModuleVersionDlg(HWND hwndParent, const HINSTANCE* rghinst,
			int chinst);
#else
	#define MsoModuleVersionDlg(hwndParent, rghinst, chinst)
#endif


/*************************************************************************
	Debug Monitors
*************************************************************************/

/*	Monitor notifcations */

enum
{
	msonmAlloc=0x1000,	// memory allocation
	msonmFree,	// memory freed
	msonmRealloc,	// memory reallocation
	msonmStartTrace,	// start trace
	msonmEndTrace,	// end trace
	msonmSbMic,
	msonmSbMac,
	msonmSbCbFree,
	msonmSbCbTotal,
};

#if DEBUG

	MSOAPIXX_(LRESULT) MsoNotifyMonitor(int nm, ...);
	MSOAPIXX_(HWND) MsoGetMonitor(void);
	MSOAPIXX_(BOOL) MsoFAddMonitor(HWND hwnd);
	MSOAPIXX_(BOOL) MsoFRemoveMonitor(HWND hwnd);
	MSOAPIXX_(BOOL) MsoFMonitorProcess(HWND hwnd);
	MSOAPIXX_(HWND) MsoGetMonitoredProcess(void);
	MSOAPIXX_(LRESULT) MsoAskMonitoredProcess(int nm, LPARAM lParam);

#elif __cplusplus
	__inline void __cdecl MsoNotifyMonitor(int,...) {}
#else
	__inline void __cdecl MsoNotifyMonitor(int nm,...) {}
#endif

#if defined(__cplusplus)
}
#endif

#endif // MSODEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\detjpncs.c ===
// File Name:   detjpncs.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"


// The DetectJapaneseCode function find out what kind of code set is there in 
// a character string. 
//
//
// UCHAR *string        Points to the character string to be checked.
//         
// int   count          Specifies the size in bytes of the string pointed
//                      to by the string parameter.
//
// Return Value
// The function return the followings values.
//
//                      Value           Meaning
//                      CODE_ONLY_SBCS  There are no Japanese character in the 
//                                      string. 
//                      CODE_JPN_JIS    JIS Code Set. There are JIS Code Set 
//                                      character in the string.
//                      CODE_JPN_EUC    EUC Code Set. There are EUC Code Set 
//                                      character in the string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. There are Shift JIS
//                                      Code Set character in the string.
//
//


int DetectJPNCode ( UCHAR *string, int count )
{
    int    i;
    BOOL fEUC = FALSE;
    int  detcount=0;

    for ( i = 0 ; i < count ; i++, string++ ) {
        if ( *string == ESC ) {
            if ( *(string+1) == KANJI_IN_1ST_CHAR    && 
                 ( *(string+2) == KANJI_IN_2ND_CHAR1 ||    // ESC $ B
                   *(string+2) == KANJI_IN_2ND_CHAR2 )) {  // ESC $ @
                    return CODE_JPN_JIS;
            }
            if ( *(string+1) == KANJI_OUT_1ST_CHAR    && 
                 ( *(string+2) == KANJI_OUT_2ND_CHAR1 ||    // ESC ( B
                   *(string+2) == KANJI_OUT_2ND_CHAR2 )) {  // ESC ( J
                    return CODE_JPN_JIS;
            }
        } else if ( *(string) >= 0x0081) {
            // Count the length of string for the detection reliability
            if (fEUC) detcount++;
            if ( *string > 0x00a0 && *string < 0x00e0 || *string == 0x008e ){
                if (!fEUC)
                    detcount++;
                fEUC = TRUE;
                continue;
            }

            if ( *(string) < 0x00a0 ) {
                return CODE_JPN_SJIS;
            }
            else if ( *(string) > 0x00fc) {
                return CODE_JPN_EUC;
            }
        }
    }
    if(fEUC)
	{
        // If the given string is not long enough, we should rather choose SJIS
        // This helps fix the bug when we are just given Window Title
        // at Shell HyperText view.
        if (detcount > MIN_JPN_DETECTLEN)
            return CODE_JPN_EUC;
        else
            return CODE_JPN_SJIS;
	}

    return CODE_ONLY_SBCS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\convbase.cpp ===
// =================================================================================
// Internet Character Set Conversion: Base Class
// =================================================================================

#include "pch.hxx"
#include "ConvBase.h"

CINetCodeConverter::CINetCodeConverter()
{
	nNumOverflowBytes = 0;
}

HRESULT CINetCodeConverter::GetStringSizeA(BYTE const* pbySource, long lSourceSize, long* plDestSize)
{
	fOutputMode = FALSE;

	return WalkString(pbySource, lSourceSize, plDestSize);
}

HRESULT CINetCodeConverter::ConvertStringA(BYTE const* pbySource, long lSourceSize, BYTE* pbyDest, long lDestSize, long* lConvertedSize)
{
	HRESULT hr;

	fOutputMode = TRUE;
	pbyOutput = pbyDest;
	lOutputLimit = lDestSize;

	// Output those bytes which could not be output at previous time.
	if (FAILED(hr = OutputOverflowBuffer()))
		return hr;

	return WalkString(pbySource, lSourceSize, lConvertedSize);
}

HRESULT CINetCodeConverter::WalkString(BYTE const* pbySource, long lSourceSize, long* lConvertedSize)
{
	HRESULT hr = S_OK;

	lNumOutputBytes = 0;

	if (pbySource) {
		while (lSourceSize-- > 0) {
			if (FAILED(hr = ConvertByte(*pbySource++)))
				break;
		}
	} else {
		hr = CleanUp();
	}

	if (lConvertedSize)
		*lConvertedSize = lNumOutputBytes;

	return hr;
}

HRESULT CINetCodeConverter::EndOfDest(BYTE by)
{
	if (nNumOverflowBytes < MAXOVERFLOWBYTES)
		OverflowBuffer[nNumOverflowBytes++] = by;

	return E_FAIL;
}

HRESULT CINetCodeConverter::OutputOverflowBuffer()
{
	for (int n = 0; n < nNumOverflowBytes; n++) {
		if (lNumOutputBytes < lOutputLimit) {
			*pbyOutput++ = OverflowBuffer[n];
			lNumOutputBytes++;
		} else {
			// Overflow again
			for (int n2 = 0; n < nNumOverflowBytes; n++, n2++)
				OverflowBuffer[n2] = OverflowBuffer[n];
			nNumOverflowBytes = n2;
			return E_FAIL;
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\msostd.h ===
/*************************************************************************
	msostd.h

	Owner: rickp
	Copyright (c) 1994 Microsoft Corporation

	Standard common definitions shared by all office stuff
*************************************************************************/

#if !defined(MSOSTD_H)
#define MSOSTD_H

/*************************************************************************
	make sure we have our processor type set up right - note that we
	now have three - count 'em, three - different symbols defined for
	each processor we support (e.g., X86, _X86_, and _M_IX386)
*************************************************************************/

#if !defined(PPCMAC) && !defined(PPCLIB) && !defined(X86) && !defined(M68K)

	#if defined(_M_IX86)
		#define X86 1
	#elif defined(_M_IA64)
	    #define X86 1
	#elif defined(_M_MPPC)
		//#define MAC 1
		#define PPCMAC 1
	#elif defined(_M_M68K)
		//#define MAC 1
		#error Hey howd we get here?
		#define M68K 1
	#elif defined(_M_AMD64)
	#elif defined(_M_PPC) || defined(PPCNT)
// REVIEW brianwen: Much as we'd like to actually define PPC,
// a bunch of code erroneously assumes PPC == PPCMAC....
//		#define PPC 1
	#else
		#error Must define a target architecture
	#endif

#endif

/*************************************************************************
	Pull in standard Windows and C definitions.
*************************************************************************/

/*	make sure the compiler generates intrinsic calls of all crt functions,
	or else we'll pull in a ton of crt stuff we probably don't want. */
#ifndef RC_INVOKED
	#include <string.h>
	#pragma intrinsic(strcpy, strcat, strlen, memcpy, memset, memcmp)
#endif

#define OEMRESOURCE
#if MAC
	// By default, use Native Mac OLE interfaces (instead of WLM)
	#if !defined(MSO_NATIVE_MACOLE)
		#define MSO_NATIVE_MACOLE 1
	#endif

	#if !defined(MSO_USE_OLENLS) && !defined(_WIN32NLS)
		#define _WIN32NLS
	#endif

	#if MSO_NATIVE_MACOLE && !defined(_MACOLENAMES)
		#define _MACOLENAMES
	#endif

	#define GUID_DEFINED
	#define __OBJECTID_DEFINED
	#ifndef _WIN32
	#define _WIN32
	#endif
#endif

#include <windows.h>
#if !defined(RC_INVOKED)
	#include <ole2.h>
#endif

#if MAC && !defined(RC_INVOKED)
	#include <macname1.h>
	#undef CopyRgn
	#undef UnionRgn
	#undef XorRgn
	#include <Types.h>
	#include <macos\Resource.h>
	#include <Lowmem.h>
	#include <Fragload.h>
	#include <Files.h>
	#include <OSUtils.h>
	#include <GestaltEqu.h>
	#include <Errors.h>
	#include <Aliases.h>
	#include <macname2.h>
	#undef CopyRgn
	#undef UnionRgn
	#undef XorRgn
	#include <winver.h>
	#if MSO_NATIVE_MACOLE
		#pragma warning(disable:4142)
		#include <macname1.h>
		#undef CopyRgn
		#undef UnionRgn
		#undef XorRgn
		#include <dispatch.h>
		#define __IDispatch_INTERFACE_DEFINED__
		#include <macname2.h>
		#undef CopyRgn
		#undef UnionRgn
		#undef XorRgn
		typedef UINT CLIPFORMAT;
	#endif
	#define LPCRECT const Rect*
	#pragma warning(disable:4041)
#endif

#include <stdarg.h>

#define MsoStrcpy strcpy
#define MsoStrcat strcat
#define MsoStrlen strlen
#define MsoMemcpy memcpy
#define MsoMemset memset
#define MsoMemcmp memcmp
#define MsoMemmove memmove

#if MAC
	#define ExtTextOutW MsoExtTextOutW
	#define TextOutW MsoTextOutW
	#define GetTextExtentPointW MsoGetTextExtentPointW

	#ifdef __cplusplus
	extern "C" {
	#endif
	WINGDIAPI BOOL APIENTRY MsoGetTextExtentPointW(HDC, LPCWSTR, int, LPSIZE);
	WINGDIAPI BOOL WINAPI MsoExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);
	WINGDIAPI BOOL WINAPI MsoTextOutW(HDC, int, int, LPCWSTR, int);
	#ifdef __cplusplus
	}
	#endif
#endif

/*************************************************************************
	Pre-processor magic to simplify Mac vs. Windows expressions.
*************************************************************************/

#if MAC
	#define Mac(foo) foo
	#define MacElse(mac, win) mac
	#define NotMac(foo)
	#define Win(foo)
	#define WinMac(win,mac) mac
#else
	#define Mac(foo)
	#define MacElse(mac, win) win
	#define NotMac(foo) foo
	#define Win(foo) foo
	#define WinMac(win,mac) win
#endif


/*************************************************************************
	Calling conventions

	If you futz with these, check the cloned copies in inc\msosdm.h
	
*************************************************************************/

#if !defined(OFFICE_BUILD)
	#define MSOPUB __declspec(dllimport)
	#define MSOPUBDATA __declspec(dllimport)
#else
	#define MSOPUB __declspec(dllexport)
	#define MSOPUBDATA __declspec(dllexport)
#endif

/* MSOPUBX are APIs that used to be public but no one currently uses,
	so we've unexported them.  If someone decides they want/need one of
	these APIs, we should feel free to re-export them */

#if GELTEST
	#define MSOPUBX MSOPUB
	#define MSOPUBDATAX MSOPUBDATA
#else
	#define MSOPUBX
	#define MSOPUBDATAX
#endif

/* used for interface that rely on using the OS (stdcall) convention */
#define MSOSTDAPICALLTYPE __stdcall

/* used for interfaces that don't depend on using the OS (stdcall) convention */
#define MSOAPICALLTYPE __stdcall

#if defined(__cplusplus)
	#define MSOEXTERN_C extern "C"
#else
	#define MSOEXTERN_C
#endif
#define MSOAPI_(t) MSOEXTERN_C MSOPUB t MSOAPICALLTYPE
#define MSOSTDAPI_(t) MSOEXTERN_C MSOPUB t MSOSTDAPICALLTYPE
#define MSOAPIX_(t) MSOEXTERN_C MSOPUBX t MSOAPICALLTYPE
#define MSOSTDAPIX_(t) MSOEXTERN_C MSOPUBX t MSOSTDAPICALLTYPE
#if MAC
	#define MSOPUBXX	
	#define MSOAPIMX_(t) MSOAPI_(t)
	#define MSOAPIXX_(t) MSOAPIX_(t)
#else
	#define MSOPUBXX MSOPUB
	#define MSOAPIMX_(t) MSOAPIX_(t)
	#define MSOAPIXX_(t) MSOAPI_(t)
#endif

#define MSOMETHOD(m)      STDMETHOD(m)
#define MSOMETHOD_(t,m)   STDMETHOD_(t,m)
#define MSOMETHODIMP      STDMETHODIMP
#define MSOMETHODIMP_(t)  STDMETHODIMP_(t)

/* Interfaces derived from IUnknown behave in funny ways on the Mac */
#if MAC && MSO_NATIVE_MACOLE
#define BEGIN_MSOINTERFACE BEGIN_INTERFACE
#else
#define BEGIN_MSOINTERFACE
#endif


// Deal with "split" DLLs for the Mac PPC Build
#if MAC &&      MACDLLSPLIT
	#define MSOMACPUB MSOPUB
	#define MSOMACPUBDATA  MSOPUBDATA
	#define MSOMACAPI_(t)  MSOAPI_(t)
	#define MSOMACAPIX_(t) MSOAPIX_(t)
#else
	#define MSOMACPUB
	#define MSOMACPUBDATA
	#define MSOMACAPI_(t) t
	#define MSOMACAPIX_(t) t
#endif
	
#if X86 && !DEBUG
	#define MSOPRIVCALLTYPE __fastcall
#else
	#define MSOPRIVCALLTYPE __cdecl
#endif

#if MAC
#define MSOCONSTFIXUP(t) t
#else
#define MSOCONSTFIXUP(t) const t
#endif

/*************************************************************************
	Extensions to winuser.h from \\ole\access\inc\winuser.h
***************************************************************** DAVEPA */
#if !MAC
	#define WM_GETOBJECT			0x003D
	#define WMOBJ_ID           0x0000
	#define WMOBJ_POINT        0x0001
	#define WMOBJID_SELF       0x00000000
#endif


/*************************************************************************
	Common #define section
*************************************************************************/

/* All Microsoft Office specific windows messages should use WM_MSO.
   Submessages passed through wParam should be defined in offpch.h.     */

// TODO: This value has been okay'ed by Word, Excel, PowerPoint, and Access.
// Still waiting to hear from Ren and Project.

#define WM_MSO (WM_USER + 0x0900)


/* All Microsoft Office specific Apple events should use MSO_EVENTCLASS
	as the EventClass of their Apple Events */
	
// TODO: This value needs to be okay'd by Word, Excel, PowerPoint, Access and
//              possibly Apple
	
#if MAC
#define MSO_EVENTCLASS '_mso'
#define MSO_WPARAM 'wprm'
#define MSO_LPARAM 'lprm'
#define MSO_NSTI 'nsti'
#endif

// NA means not applicable. Use NA to help document parameters to functions.
#undef  NA
#define NA 0L

/* End of common #define section */


/*************************************************************************
	Common segmentation definitions
*************************************************************************/

/*	Used with #pragma to swap-tune global variables into the boot section
	of the data segment.  Should link with -merge:.bootdata=.data when
	using these pragmas */
	
#if MAC || DEBUG
	#define MSO_BOOTDATA
	#define MSO_ENDBOOTDATA
#else
	#define MSO_BOOTDATA data_seg(".bootdata")
	#define MSO_ENDBOOTDATA data_seg()
#endif

#endif // MSOSTD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\extinc\msouser.h ===
/****************************************************************************
	MsoUser.h

	Owner: DavePa
 	Copyright (c) 1994 Microsoft Corporation

	Declarations for common functions and interfaces required for apps
	to use the Office DLL.
****************************************************************************/

#ifndef MSOUSER_H
#define MSOUSER_H

#include "msodebug.h"

#ifndef MSO_NO_INTERFACES
interface IMsoControlContainer;
#endif // MSO_NO_INTERFACES

#if MAC
#include <macos\dialogs.h>
#include <macos\events.h>
#endif

/****************************************************************************
	The ISimpleUnknown interface is a variant on IUnknown which supports
	QueryInterface but not reference counts.  All objects of this type
	are owned by their primary user and freed in an object-specific way.
	Objects are allowed to extend themselves by supporting other interfaces
	(or other versions of the primary interface), but these interfaces
	cannot be freed without the knowledge and cooperation of the object's 
	owner.  Hey, it's just like a good old fashioned data structure except
	now you can extend the interfaces.
****************************************************************** DAVEPA **/

#undef  INTERFACE
#define INTERFACE  ISimpleUnknown

DECLARE_INTERFACE(ISimpleUnknown)
{
	/* ISimpleUnknown's QueryInterface has the same semantics as the one in
		IUnknown, except that QI(IUnknown) succeeds if and only if the object
		also supports any real IUnknown interfaces, QI(ISimpleUnknown) always
		succeeds, and there is no implicit AddRef when an non-IUnknown-derived
		interface is requested.  If an object supports both IUnknown-derived
		and ISimpleUnknown-derived interfaces, then it must implement a 
		reference count, but all active ISimpleUnknown-derived interfaces count
		as a single reference count. */
	MSOMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
};


/****************************************************************************
	HMSOINST is an opaque reference to an Office instance record.  Each
	thread of each EXE or DLL that uses Office must call MsoFInitOffice
	to init Office and get an HMSOINST.
****************************************************************** DAVEPA **/
#ifndef HMSOINST
typedef struct MSOINST *HMSOINST;  // MSOINST is defined only within Office
#endif

/****************************************************************************
	The IMsoUser interface has methods for Office to call back to the
	app for general information that is common across Office features.
****************************************************************** DAVEPA **/

#undef  INTERFACE
#define INTERFACE  IMsoUser

enum {
	msofmGrowZone = 1,
};

enum {
	msocchMaxShortAppId = 15
};


/*	dlgType sent to IMsoUser::FPrepareForDialog. Modal dialogs have LSB 0.*/
#define msodlgWindowsModal			0x00000000
#define msodlgWindowsModeless		0x00000001
#define msodlgSdmModal				0x00000010
#define msodlgSdmModeless			0x00000011
#define msodlgUIModalWinModeless	0x00000101
#define msodlgUIModalSdmModeless	0x00000111


// Notification codes for FNotifyAction methods
enum
	{
	msonaStartHelpMode = 0,			// User entered Quick tip mode (Shift-F1).  App should update any internal state
	msonaEndHelpMode,					// Quick tip was displayed.  App should restore cursor.
	msonaBeforePaletteRealize,		// Office is going to realize one or more palettes, see comment below
	};

/* About msonaBeforePaletteRealize:

	Office will call FNotifyAction(msonaBeforePaletteRealize) to let the app
	it's going to realize a palette. The app should start palette management
	if it has delayed doing so until it absolutely needs to.
	
	The app should select and realize a palette, and from now on, should
	respond to palette messages WM_QUERYNEWPALETTE and WM_PALETTECHANGED.
*/


DECLARE_INTERFACE(IMsoUser)
{
   /* Debuging interfacing for this interface */
   MSODEBUGMETHOD

	/* Return an IDispatch object for the Application object in 'ppidisp'
		Return fSuccess. */
	MSOMETHOD_(BOOL, FGetIDispatchApp) (THIS_ IDispatch **ppidisp) PURE;

	/* Return the long representing the application, as required by the
		"Creator" method of VBA objects. */
	MSOMETHOD_(LONG, LAppCreatorCode) (THIS) PURE;

	/* If the host does not support running macros then return FALSE,
		else check the macro reference in wtzMacro, which is in a 257 char buffer,
		for validity, modify it in-place if desired, and return TRUE if valid. 
		The object trying to attach the macro, if any, is given by 'pisu'.
		The format of macro references is defined by the host, but the typical
		simple case would be the name of a VBA Sub.  The host may delay
		expensive validation checks until FRunMacro as desired. */
	MSOMETHOD_(BOOL, FCheckMacro) (THIS_ WCHAR *wtzMacro, ISimpleUnknown *pisu) PURE;

	/* Run the macro given by the reference wtz (which has been checked for
		validity by FCheckMacro).  The object to which the macro is attached, 
		if any, is given by 'pisu'.  Return TRUE if successful (FALSE if the
		host does not support running macros). */
	MSOMETHOD_(BOOL, FRunMacro) (THIS_ WCHAR *wtzMacro, ISimpleUnknown *pisu,
										 VARIANT *pvarResult, VARIANT *rgvar,
										 int cvar) PURE;

	/* When a low memory condition occurs this callback method will be invoked.  The
		Application should free up cbBytesNeeded or more if it can.  Return back the
		actual number of bytes that were freed. */
	MSOMETHOD_(int, CbFreeMem) (THIS_ int cbBytesNeeded, int msofm) PURE;

	/* Office will call this in deciding whether or not to do certain actions
		that require OLE. */
	MSOMETHOD_(BOOL, FIsOleStarted) (THIS) PURE;

	/* Office will call this in deciding whether or not to do certain actions
		that require OLE. If the Application supports delayed OLE initialization
		and OLE has not been started, try to start OLE now.  Office makes no
		guarantee that it will cache the value returned here, so this may be
		called even after OLE has been started. */
	MSOMETHOD_(BOOL, FStartOle) (THIS) PURE;
	/* If a Picture Container is being created Office will call back to the IMsoUser
		to fill the Picture Container with control(s). */
	// TODO: TCoon unsigned int should be UCBK_SDM
	MSOMETHOD_(BOOL, FFillPictureContainer) (THIS_ interface IMsoControlContainer *picc,
															unsigned int tmc, unsigned int wBtn,
															BOOL *pfStop, int *pdx, int *pdy) PURE;
	/* The app should pass thru the parameters to WinHelp or the equivalent
		on the Mac */
	MSOMETHOD_(void, CallHelp)(THIS_ HWND hwnd, WCHAR *wzHelpFile, 
			UINT uCommand, DWORD dwData) PURE;
	// WHAT IS THIS? 
	/* The init call to initialize sdm. Get called when first sdm
	   dialog needs to come up. */
	MSOMETHOD_(BOOL, FInitDialog)(THIS) PURE;

#if MAC
	// While modal alerts are up on the Mac, call back to the application to
	// allow it to do things like run MacHelp, get idle time, etc.  Most apps
	// already have an alert procedure, so this can just call that.  
	// Returns fTrue if the event is eaten, fFalse otherwise
	MSOMETHOD_(BOOL, FMacAlertFilter)(THIS_ DialogPtr pdlg, EventRecord *pevent, short *pidtem) PURE;
	MSOMETHOD_(BOOL, FShowSdmAccel)(THIS) PURE;
#endif

	/* AutoCorrect functions. Used to inegrate this feature with the apps
		undo functionality and extended AC functionality in Word. */
	MSOMETHOD_(void, ACRecordVars)(THIS_ DWORD dwVars) PURE;
	MSOMETHOD_(BOOL, ACFFullService)(THIS) PURE;
	MSOMETHOD_(void, ACRecordRepl)(THIS_ int, WCHAR *wzFrom, WCHAR *wzTo) PURE;
	MSOMETHOD_(void, ACAdjustAC)(THIS_ int iwz, int idiwz) PURE;

	/* Return the CLSID of the application */
	MSOMETHOD_(void, GetAppClsid) (THIS_ LPCLSID *) PURE;

	/* Before and After doing a sdm dialog, call back to the application for
		them to do their own init and cleanup.
		The dlg parameter is a bitmap flags defined here as msodlgXXXX
		*/
 	MSOMETHOD_(BOOL, FPrepareForDialog) (THIS_ void **ppvDlg, int dlgType) PURE;
 	MSOMETHOD_(void, CleanupFromDialog) (THIS_ void *pvDlg) PURE;

	// Applications must provide a short (max 15 char + '\0') string which
	// identifies the application.  This string is used as the application ID
	// with ODMA.  This string may be displayed to the user, so it should be
	// localized.  But strings should be chosen so that localized versions
	// can often use the same string.  (For example, "MS Excel" would be a
	// good string for Excel to use with most Western-language versions.)  If
	// the file format changes for a localized version (eg. for Far East or
	// bi-di versions), a different string should be used for the localized
	// versions whose file format is different.  (It is assumed that all
	// versions with the same localized string can read each other's files.)
	// The application should copy the string into the buffer provided.
	// This string cannot begin with a digit.  The application can assume
	// that wzShortAppId points to a buffer which can hold msocchMaxShortAppId
	// Unicode characters plus a terminating '\0' character.
	// If you have questions, contact erikhan.
	MSOMETHOD_(void, GetWzShortAppId) (THIS_ WCHAR *wzShortAppId) PURE;

	MSOMETHOD_(void, GetStickyDialogInfo) (THIS_ int hidDlg, POINT *ppt) PURE;
	MSOMETHOD_(void, SetPointStickyDialog) (THIS_ int hidDlg, POINT *ppt) PURE;

	/* Called before command bars start tracking, and after they stop. Note
		that this will be called even in the HMenu cases, and on the Mac.
		Also, when real command bars start tracking, you are called on
		OnComponentActivate by the Component Manager. Make sure you know which
		callback you want to use.
		This callback is used by Excel to remove/put back a keyboard patch they
		have on the Mac. */
	MSOMETHOD_(void, OnToolbarTrack) (THIS_ BOOL fStart) PURE;
	
	/* Notification that the action given by 'na' occurred.
		Return TRUE if the
		notification was processed.
	*/
	MSOMETHOD_(BOOL, FNotifyAction) (THIS_ int na) PURE;
};

// NOTE: Another copy of this definition is in msosdm.h
#ifndef PFNFFillPictureContainer
typedef BOOL (*PFNFFillPictureContainer) (interface IMsoControlContainer *picc,
														unsigned int tmc, unsigned int wBtn,
														BOOL *pfStop, int *pdx, int *pdy);
#endif
#if DEBUG

/*****************************************************************************
	Block Entry structure for Memory Checking
*****************************************************************************/
typedef struct _MSOBE
{
	void* hp;
	int bt;
	unsigned cb;
	BOOL fAllocHasSize;
	HMSOINST pinst;
}MSOBE;

/****************************************************************************
	The IMsoDebugUser interface has Debug methods for Office to call back
   to the app for debugging information that is common across Office features.
****************************************************************** JIMMUR **/

#undef  INTERFACE
#define INTERFACE  IMsoDebugUser

DECLARE_INTERFACE(IMsoDebugUser)
{
   /* Call the MsoFSaveBe API for all of the structures in this application 
		so that leak detection can be preformed.  If this function returns 
		FALSE the memory check will be aborted. The lparam parameter if the 
		same lparam value passed to the MsoFChkMem API.  This parameter should 
		in turn be passed to the MsoFSaveBe API which this method should call 
		to write out its stuctures. */
   MSOMETHOD_(BOOL, FWriteBe) (THIS_ LPARAM) PURE;

   /* This callback allows the application to abort an on going memory check.
	   If this function return TRUE the memory check will be aborted.  
		If FALSE then the memory check will continue.  The application should 
		check its message queue to determine if the memory check should 
		continue.  The lparam paramater if the same lparam value passed to the 
		MsoFChkMem API.  This allows the application to supply some context if 
		it is required. */
   MSOMETHOD_(BOOL, FCheckAbort) (THIS_ LPARAM) PURE;

   /* This callback is called when duplicate items are  found in the heap.
      This provides a way for an applications to manage its referenced counted
		items.  The prgbe parameter is a pointer to the array of MSOBE records. The
		ibe parameter is the current index into that array.  The cbe parameter
		is the count of BEs in the array.  This method should look at the MSOBE in
		question and return back the next index that should checked.  A value of
		0 for the return value will designate that an error has occured.*/
   MSOMETHOD_(int, IbeCheckItem) (THIS_ LPARAM lParam, MSOBE *prgbe, int ibe, int cbe) PURE;

	/* This call back is used to aquire the strigstring name of a Bt. This is used
		when an error occurs during a memory integrity check.  Returning FALSE means
		that there is no string.*/
	MSOMETHOD_(BOOL, FGetSzForBt) (THIS_ LPARAM lParam, MSOBE *pbe, int *pcbsz,
												char **ppszbt) PURE;

	/* This callback is used to signal to the application that an assert is
		about to come up.  szTitle is the title of the assert, and szMsg is the
		message to be displayed in the assert, pmb contains the messagebox
		flags that will be used for the assert.  Return a MessageBox return code
		(IDABORT, IDRETRY, IDIGNORE) to stop the current assert processing and
		simulate the given return behavior.  Returns 0 to proceed with default
		assert processing.  The messagebox type can be changed by modifying
		the MB at *pmb.  iaso contains the type of assert being performed */
	MSOMETHOD_(int, PreAssert) (THIS_ int iaso, char* szTitle, char* szMsg, UINT* pmb) PURE;

	/* This callback is used to signal to the application that an assert has 
		gone away.  id is the MessageBox return code for the assert.  The return
		value is used to modify the MessageBox return code behavior of the
		assert handler */
	MSOMETHOD_(int, PostAssert) (THIS_ int id) PURE;
};

MSOAPI_(BOOL) MsoFWriteHMSOINSTBe(LPARAM lParam, HMSOINST hinst);
#endif // DEBUG


/****************************************************************************
	Initialization of the Office DLL
****************************************************************************/

/* Initialize the Office DLL.  Each thread of each EXE or DLL using the
	Office DLL must call this function.  On Windows, 'hwndMain' is the hwnd of
	the app's main window, and is used to detect context switches to other 
	Office apps, and to send RPC-styles messages from one office dll to another.
	On the Mac, this used to establish window ownership (for WLM apps), and can
	be NULL for non-WLM apps.  The 'hinst' is the HINSTANCE of 
	the EXE or DLL.  The interface 'piuser' must implement the IMsoUser 
	interface for this use of Office.  wzHostName is a pointer to the short name
	of the host to be used in menu item text. It must be no longer than 32
	characters including the null terminator.
	The HMSOINST instance reference
	for this use of Office is returned in 'phinst'.  Return fSuccess. */
MSOAPI_(BOOL) MsoFInitOffice(HWND hwndMain, HINSTANCE hinstClient, 
									  IMsoUser *piuser, const WCHAR *wzHostName,
									  HMSOINST *phinst);

/* Uninitialize the Office DLL given the HMSOINST as returned by
	MsoFInitOffice.  The 'hinst' is no longer valid after this call. */
MSOAPI_(void) MsoUninitOffice(HMSOINST hinst);

/* This API is called by when a new thread is created which may use the
   Office memory allocation functions. */
MSOAPI_(BOOL) MsoFInitThread(HANDLE hThread);

/* This API is called by when a thread is which may use the Office memory
	allocation functions is about to be destroyed. */
MSOAPI_(void) MsoUninitThread(void);

/* Tell Lego we're done booting */
MSOAPI_(void) MsoBeginBoot(void);
MSOAPI_(void) MsoEndBoot(void);

/* Load and register the Office OLE Automation Type Library by searching
	for the appropriate resource or file (don't use existing registry entries).  
	Return typelib in ppitl or just register and release if ppitl is NULL.
	Return HRESULT returned	from LoadTypeLib/RegisterTypeLib. */
MSOAPI_(HRESULT) MsoHrLoadTypeLib(ITypeLib **ppitl);

/* Register everything that Office needs in the registry for a normal user
	setup (e.g. typelib, proxy interfaces).  Return NOERROR or an HRESULT
	error code. */
MSOAPI_(HRESULT) MsoHrRegisterAll();

/* Same as MsoHrRegisterAll except takes the szPathOleAut param which specifies 
	the path name to an alternate version of oleaut32.dll to load and use. */
MSOAPI_(HRESULT) MsoHrRegisterAllEx(char *szPathOleAut);

/* Unregister anything that is safe and easy to unregister.
	Return NOERROR or an HRESULT error code. */
MSOAPI_(HRESULT) MsoHrUnregisterAll();

#if DEBUG
	/* Add the IMsoDebugUser interface to the HMSOINST instance reference.
	   Return fSuccess. */
	MSOAPI_(BOOL) MsoFSetDebugInterface(HMSOINST hinst, IMsoDebugUser *piodu);
#endif


/****************************************************************************
	Other APIs of global interest
****************************************************************************/

/* A generic implementation of QueryInterface for an object given by pisu
	with a single ISimpleUnknown-derived interface given by riidObj.  
	Succeeds only if riidQuery == riidObj or ISimpleUnknown.  
	Returns NOERROR and pisu in *ppvObj if success, else E_NOINTERFACE. */
MSOAPI_(HRESULT) MsoHrSimpleQueryInterface(ISimpleUnknown *pisu, 
							REFIID riidObj, REFIID riidQuery, void **ppvObj);

/* Like MsoHrSimpleQueryInterface except succeeds for either riidObj1
	or riidObj2, returning pisu in both cases and therefore useful for
	inherited interfaces. */
MSOAPI_(HRESULT) MsoHrSimpleQueryInterface2(ISimpleUnknown *pisu, 
							REFIID riidObj1, REFIID riidObj2, REFIID riidQuery, 
							void **ppvObj);

/* This message filter is called for EVERY message the host app receives.
	If the procedure processes it should return TRUE otw FALSE. */
MSOAPI_(BOOL) FHandledLimeMsg(MSG *pmsg);


/*************************************************************************
	MSOGV -- Generic Value

	Currently we have a bunch of fields in Office-defined structures
	with names like pvClient, pvDgs, etc.  These are all declared as
	void *'s, but really they're just for the user of Office to stick
	some data in an Office structure.

	The problem with using void * and calling these fields pvFoo is that
	people keep assuming that you could legitimately compare them against
	NULL and draw some conclusion (like that you didn't need to call the
	host back to free	stuff).  This tended to break hosts who were storing
	indices in these fields.

	So I invented "generic value" (great name, huh?)  Variables of this
	type are named gvFoo.  Almost by definition, there is NO gvNil.

	This type will always be unsigned and always big enough to contain
	either a uint or a pointer.  We don't promise that this stays the
	same length forever, so don't go saving them in files.
************************************************************ PeterEn ****/
typedef void *MSOGV;
#define msocbMSOGV (sizeof(MSOGV))


/*************************************************************************
	MSOCLR -- Color

	This contains "typed" colors.  The high byte is the type,
	the low three are the data.  RGB colors have a "type" of zero.
	It'd be cool you could just cast a COLORREF to an MSOCR and have it
	work (for that to work we'd have to define RGB colors by something
	other than a zero high byte)

	TODO peteren:  These used to be called MSOCR, but cr was a really bad
	hungarian choice for this, it intersects with COLORREF all over the
	place an in the hosts.  I renamed it MSOCLR.  See if we can replace
	some of the "cr" with "clr"

	TODO peteren
	TODO johnbo

	We don't really use this type everywhere we should yet.
************************************************************ PeterEn ****/
typedef ULONG MSOCLR;
#define msocbMSOCLR (sizeof(MSOCLR))
#define msoclrNil   (0xFFFFFFFF)
#define msoclrBlack (0x00000000)
#define msoclrWhite (0x00FFFFFF)
#define msoclrNinch (0x80000001)
#define MsoClrFromCr(cr) ((MSOCLR)(cr & 0x00FFFFFF))
	/* Converts a Win32 COLORREF to an MSOCLR */

/* Old names, remove these */
#define MSOCR MSOCLR
#define msocbMSOCR msocbMSOCLR
#define msocrNil   msoclrNil
#define msocrBlack msoclrBlack
#define msocrWhite msoclrWhite
#define msocrNinch msoclrNinch

/* MsoFGetColorString returns the name of a color. We'll fill out WZ
	with a string of at most cchMax character, not counting the 0 at the end.
	We return TRUE on success.  If you give us a non-NULL pcch will set *pcch
	to the number of characters in the string.
	If you have a COLORREF you can convert with MsoClrFromCr(cr). */
MSOAPI_(BOOL) MsoFGetColorString(MSOCLR clr, WCHAR *wz, int cchMax, int *pcch);

/* MsoFGetSplitMenuColorString returns a string for a split menu.

	If idsItem is not msoidsNil, we'll just insert the string for idsItem
	into the string for idsPattern and return the result in wz.
	
	If idsItem is msoidsNil, we'll try to get a string from the MSOCLR
	using MsoFGetColorString.  If that fails, we'll use
	msoidsSplitMenuCustomItem. */
MSOAPI_(BOOL) MsoFGetSplitMenuColorString(int idsPattern, int idsItem, MSOCLR clr, 
												  WCHAR *wz, int cchMax, int *pcch);


/*************************************************************************
	Stream I/O Support Functions

  	MsoFByteLoad, MsoFByteSave, MsoFWordLoad, MsoFWordSave, etc.
	The following functions are helper functions to be used when loading or
	saving toolbar data using an OLE 2 Stream.  They take care of the stream
	I/O, byte swapping for consistency between Mac and Windows, and error
	checking.  They should be used in all FLoad/FSave callback functions. 
	MsoFWtzLoad expects wtz to point at an array of 257 WCHARs.  MsoFWtzSave
	will save an empty string if wtz is passed as NULL.
	
	SetLastError:  can be set to values from IStream's Read and Write methods
************************************************************ WAHHABB ****/
MSOAPI_(BOOL) MsoFByteLoad(LPSTREAM pistm, BYTE *pb);
MSOAPI_(BOOL) MsoFByteSave(LPSTREAM pistm, const BYTE b);
MSOAPI_(BOOL) MsoFWordLoad(LPSTREAM pistm, WORD *pw);
MSOAPI_(BOOL) MsoFWordSave(LPSTREAM pistm, const WORD w);
MSOAPI_(BOOL) MsoFLongLoad(LPSTREAM pistm, LONG *pl);
MSOAPI_(BOOL) MsoFLongSave(LPSTREAM pistm, const LONG l);
MSOAPI_(BOOL) MsoFWtzLoad(LPSTREAM pistm, WCHAR *wtz);
MSOAPI_(BOOL) MsoFWtzSave(LPSTREAM pistm, const WCHAR *wtz);


/****************************************************************************
	The IMSoPref (Preferences File) Interface provides a platform independent
	way to maintain settings, using a preferences file on the Macintosh, and
	a registry subkey on Windows
************************************************************** BenW ********/

enum
{
	inifNone	= 0,
	inifAppOnly	= 1,
	inifSysOnly	= 2,
	inifCache = 4
};

// This order is assumed in util.cpp SET::CbQueryProfileItemIndex
enum
{
	msoprfNil = 0,
	msoprfInt = 1,
	msoprfString = 2,
	msoprfBlob = 3
};

#undef  INTERFACE
#define INTERFACE  IMsoPref

#undef  INTERFACE
#define INTERFACE  IMsoPref

DECLARE_INTERFACE(IMsoPref)
{
   //*** FDebugMessage method ***
   MSODEBUGMETHOD

	// IMsoPref methods
	MSOMETHOD_(int, LQueryProfileInt) (THIS_ const WCHAR *, const WCHAR *, int, int) PURE;
	MSOMETHOD_(int, CchQueryProfileString) (THIS_ const WCHAR *wzSection,
			const WCHAR *wzKey, const WCHAR *wzDefault, WCHAR *wzValue,
			int cchMax, int inif) PURE;
	MSOMETHOD_(int, CbQueryProfileBlob) (THIS_ const WCHAR *, const WCHAR *, BYTE *, int, BYTE *, int, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileInt) (THIS_ const WCHAR *, const WCHAR *, int, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileString) (THIS_ const WCHAR *, const WCHAR *, WCHAR *, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileBlob)(THIS_ const WCHAR *, const WCHAR *, BYTE *, int, int) PURE;
	MSOMETHOD_(BOOL, FDelProfileSection)(THIS_ const WCHAR *) PURE;
	MSOMETHOD_(BOOL, CbQueryProfileItemIndex)	(THIS_ const WCHAR *wzSection, int ikey, WCHAR *wzKey, int cchMaxKey, BYTE *pbValue, int cbMaxValue, int *pprf, int inif) PURE;
#if MAC
	MSOMETHOD_(BOOL, FQueryProfileAlias)(THIS_ AliasHandle *, int) PURE;
	MSOMETHOD_(BOOL, FWriteProfileAlias)(THIS_ AliasHandle, int) PURE;
#endif
};

enum
{
	msoprfUser = 0x0000,	// use HKEY_CURRENT_USER
	msoprfMachine = 0x0001,	// use HKEY_LOCAL_MACHINE
	msoprfIgnoreReg = 0x8000,	// always return defaults
};

MSOAPI_(BOOL) MsoFCreateIPref(const WCHAR *wzPref, const WCHAR *wzAppName, long lCreatorType, long lFileType, int prf, int wDummy, IMsoPref **ppipref);

MSOAPI_(void) MsoDestroyIPref(IMsoPref *);

MSOAPIX_(BOOL) MsoFEnsureUserSettings(const WCHAR *wzApp);

#if !MAC
	MSOAPI_(HRESULT) MsoGetSpecialFolder(int icsidl, WCHAR *wzPath);
#endif

MSOMACAPI_(int) MsoCchGetSharedFilesFolder(WCHAR *wzFilename);

MSOAPIXX_(int) MsoCchGetUsersFilesFolder(WCHAR *wzFilename);

/*	Returns the a full pathname to the MAPIVIM DLL in szPath.  Length of
	the buffer is cchMax, and actual length of the string is returned.
	Returns 0 if no path could be found. */
#if !MAC
	MSOAPI_(int) MsoGetMapiPath(WCHAR* wzPath, int cchMax);
#endif	

MSOAPIXX_(WCHAR *) MsoWzGetKey(const WCHAR *wzApp, const WCHAR *wzSection, WCHAR *wzKey);


/*-------------------------------------------------------------------------
	MsoFGetCursorLocation

	Given the name of an animated cursor, returns the file where that cursor
	is found by looking up the name in the Cursors section of the Office prefs.
	
	On Windows, we return the name of a .CUR or .ANI file.
	On the Mac, we return the name of a single file which contains all the cursors.
	NULL means to use the cursors in the Office Shared Library.
	
	For Office 97, this is NYI on the Mac

	Returns fTrue is a cursor was found, fFalse otherwise.

------------------------------------------------------------------ BENW -*/
MSOAPI_(BOOL) MsoFGetCursorLocation(WCHAR *wzCursorName, WCHAR *wzFile);

/****************************************************************************
	The IMsoSplashUser interface is implemented by a user wishing to
	display a splash screen
************************************************************** SHAMIKB *****/

#undef  INTERFACE
#define INTERFACE  IMsoSplashUser
DECLARE_INTERFACE(IMsoSplashUser)
{
	MSOMETHOD_(BOOL, FCreateBmp) (THIS_ BITMAPINFO** pbi, void** pBits) PURE;
	MSOMETHOD_(BOOL, FDestroyBmp) (THIS_ BITMAPINFO* pbi, void* pBits) PURE;
	MSOMETHOD_(void, PreBmpDisplay) (THIS_ HDC hdcScreen, HWND hwnd, BITMAPINFO* pbi, void* pBits) PURE;
	MSOMETHOD_(void, PostBmpDisplay) (THIS_ HDC hdcScreen, HWND hwnd, BITMAPINFO *pbi, void* pBits) PURE;
};

// APIs for displaying splash screen
MSOAPI_(BOOL) MsoFShowStartup(HWND hwndMain, BITMAPINFO* pbi, void* pBits, IMsoSplashUser *pSplshUser);
MSOAPI_(void) MsoUpdateStartup();
MSOAPI_(void) MsoDestroyStartup();


/****************************************************************************
	Stuff about File IO
************************************************************** PeterEn *****/

/* MSOFO = File Offset.  This is the type in which Office stores seek
	positions in files/streams.  I kinda wanted to use FP but that's already
	a floating point quantity. Note that the IStream interfaces uses
	64-bit quantities to store these; for now we're just using 32.  These
	are exactly the same thing as FCs in Word. */
typedef ULONG MSOFO;
#define msofoFirst ((MSOFO)0x00000000)
#define msofoLast  ((MSOFO)0xFFFFFFFC)
#define msofoMax   ((MSOFO)0xFFFFFFFD)
#define msofoNil   ((MSOFO)0xFFFFFFFF)

/* MSODFO = Delta File Offset.  A difference between two MSOFOs. */
typedef MSOFO MSODFO;
#define msodfoFirst ((MSODFO)0x00000000)
#define msodfoLast  ((MSODFO)0xFFFFFFFC)
#define msodfoMax   ((MSODFO)0xFFFFFFFD)
#define msodfoNil   ((MSODFO)0xFFFFFFFF)


/****************************************************************************
	Defines the IMsoCryptSession interface

	Use this interface to encrypt or decrypt data.  In the future, perhaps
	the Crypto API can be hooked up underneath.  For now, the encryption will
	be linked to office directly.
***************************************************************** MarkWal **/
#undef INTERFACE
#define INTERFACE IMsoCryptSession

DECLARE_INTERFACE(IMsoCryptSession)
{
	MSODEBUGMETHOD

	/* discard this crypt session */
	MSOMETHOD_(void, Free) (THIS) PURE;

	/* reset the encryptor to a boundary state vs. continuing current
		stream.  iBlock indicates which block boundary to reset to. */
	MSOMETHOD_(void, Reset) (THIS_ unsigned long iBlock) PURE;

	/* encrypts/decrypts the buffer indicated by pv inplace.  cb indicates
		how long the data is.  Encryption can change the length of the
		data if block algorithms are allowed via cbBlock non-zero on
		the call to MsoFCreateCryptSession.  In that case, *pcbNew is set
		to the new size of the buffer.  In any other case pcbNew may be NULL. */
	MSOMETHOD_(void, Crypt) (THIS_ unsigned char *pb, int cb, int *pcbNew) PURE;

	/* set the password to the indicated string.  Also, resets the algorithm */
	MSOMETHOD_(BOOL, FSetPass) (THIS_ const WCHAR *wtzPass) PURE;

	/* if the encryption algorithm is a block algorithm, CbBlock indicates the
		block size.  A buffer passed in to Encrypt may grow to a CbBlock
		boundary. */
	MSOMETHOD_(int, CbBlock) (THIS) PURE;

	/* make this crypt session persistent so it can be loaded by 
		MsoFLoadCryptSession, stream should be positioned correctly
		before calling FSave and it will be positioned at the next byte
		when it returns */
	MSOMETHOD_(BOOL, FSave) (THIS_ LPSTREAM pistm) PURE;

	/* make a duplicate of this crypt session */
	MSOMETHOD_(BOOL, FClone) (THIS_ interface IMsoCryptSession **ppics) PURE;
};


/*---------------------------------------------------------------------------
	MsoFCreateCryptSession

	Creates a new crypto session using the indicated password to generate
	the encryption key.  cbBlock indicates the maximum block size supported by
	the client.  If block encryption (encryption/decryption changes information
	lenght) is not supported by the caller, cbBlock should be 0.  If arbitrary
	block lengths are supported cbBlock should be -1.
---------------------------------------------------------------- MarkWal --*/
MSOAPI_(BOOL) MsoFCreateCryptSession(const WCHAR *wtzPass, interface IMsoCryptSession **ppics, int cbBlock);

/*---------------------------------------------------------------------------
	MsoHrLoadCryptSession

	Loads a previously saved crypto session using the indicated password to 
	generate the encryption key.  cbBlock indicates the maximum block size
	supported by the client.  If block encryption (encryption/decryption 
	changes information lenght) is not supported by the caller, cbBlock 
	should be 0.  If arbitrary block lengths are supported cbBlock should
	be -1.
---------------------------------------------------------------- MarkWal --*/
MSOAPI_(BOOL) MsoFLoadCryptSession(const WCHAR *wtzPass, IStream *pistm, interface IMsoCryptSession **ppics, int cbBlock);

/*-----------------------------------------------------------------------------
|	MSOAPI_	MsoFEncrypt
| Determine whether the languauge is French Standard	
|	
|	
|	Arguments:
|		None
|	
|	Returns:
|			BOOL: True if Language != French (Standard); else false
|	Keywords:
|	
------------------------------------------------------------SALIMI-----------*/
MSOAPI_(BOOL) MsoFEncrypt();

/****************************************************************************
	Office ZoomRect animation code
****************************************************************************/
MSOAPI_(void) MsoZoomRect(RECT *prcFrom, RECT *prcTo, BOOL fAccelerate, HRGN hrgnClip);

// Mac Profiler APIs
#if HYBRID
#if MAC
MSOAPI_(void) MsoStartMProf();
MSOAPI_(void) MsoStopMProf();
MSOAPI_(VOID) MsoMsoSetMProfFile(char* rgchProfName);
#endif
#endif


// Idle Initialization stuff

// Idle Init structure
typedef struct tagMSOIDLEINIT
{
	void (*pfnIdleInit)(void);
} MSOIDLEINIT;

/*	Creates the idle init manager, registers both the office and app idle
	init task lists with idle init manager and registers idle init
	manager as component with component manager. */
MSOAPIX_(BOOL) MsoFCreateIdleInitComp(MSOIDLEINIT *pMsoIdleInit, DWORD cItem);

#if DEBUG
/*	Allows testing to turn off idle initialization at any desired point. */
MSOAPIXX_(void) MsoDisableIdleInit();
/*	Simulates plenty of idle time so that all idle init tasks are executed
	- tests that they all work. */
MSOAPIXX_(void) MsoDoAllIdleInit();
#endif

// Idle Init helper macros
#define IndexFromIif(iif)   ((iif) >> 8)
#define MaskFromIif(iif) ((iif) & 0xFF)

#define MsoMarkIdleInitDone(rgIdle, iif) \
	(rgIdle[IndexFromIif(iif)] |= MaskFromIif(iif))

#define MsoFIdleInitDone(rgIdle, iif) \
	(rgIdle[IndexFromIif(iif)] & MaskFromIif(iif))


/*	On the Windows side we don't call OleInitialize at boot time - only
	CoInitialize. On the Mac side this is currently not being done because
	the Running Object Table is tied in with OleInitialize - so we can't
	call RegisterActiveObject if OleInitialize is not called - may
	want to revisit this issue. */

/*	Should be called before every call that requires OleInitialize to have
	been called previously. This function calls OleInitialize if it hasn't
	already been called. */
MSOAPI_(BOOL) MsoFEnsureOleInited();
/*	If OleInitialize has been called then calls OleUninitialize */
MSOAPI_(void) MsoOleUninitialize();

#if !MAC
// Delayed Drag Drop Registration
/*	These routines are unnecessary on the Mac since Mac OLE doesn't require OLE
    to be initialized prior to using the drag/drop routines */
/*	All calls to RegisterDragDrop should be replaced by
	MsoHrRegisterDragDrop. RegisterDragDrop requires OleInitialize so
	during boot RegisterDragDrop should not be called. This function
	adds the drop target to a queue if OleInitialize hasn't already been
	called. If it has then it just calls RegisterDragDrop. */
#if !MAC
MSOAPI_(HRESULT) MsoHrRegisterDragDrop(HWND hwnd, IDropTarget *pDropTarget);
#else
MSOAPI_(HRESULT) MsoHrRegisterDragDrop(WindowPtr hwnd, IDropTarget *pDropTarget);
#endif

/*	All calls to RevokeDragDrop should be replaced by
	MsoHrRevokeDragDrop. If a delayed queue of drop targets exists
	then this checks the queue first for the target. */
#if !MAC
MSOAPI_(HRESULT) MsoHrRevokeDragDrop(HWND hwnd);
#else
MSOAPI_(HRESULT) MsoHrRevokeDragDrop(WindowPtr hwnd);
#endif

/*	Since all drop targets previously registered at boot time are now
	stored in a queue, we need to make sure we register them sometime.
	These can become drop targets
	a. if we are initiating a drag and drop - in which case we call this
	function before calling DoDragDrop (inside MsoHrDoDragDrop).
	b. while losing activation - so we might become the drop target of
	another app. So this function is called from the WM_ACTIVATEAPP
	message handler. */
MSOAPI_(BOOL) MsoFRegisterDragDropList();

/*	This function should be called instead of DoDragDrop - it first
	registers any drop targets that may be in the lazy init queue. */
MSOAPI_(HRESULT) MsoHrDoDragDrop(IDataObject *pDataObject,
	IDropSource *pDropSource, DWORD dwOKEffect, DWORD *pdwEffect);
#ifdef MAC
MSOAPI_(HRESULT) MsoHrDoDragDropMac(IDataObject *pDataObject,
	IDropSource *pDropSource, DWORD dwOKEffects, EventRecord *pTheEvent,
	RgnHandle dragRegion, short numTypes, DRAG_FLAVORINFO *pFlavorInfo,
	unsigned long reserved, DWORD *pdwEffect);
#endif // MAC

#endif // !MAC


/*	Module names MsoLoadModule supports */
/*  IF ANY THING IS CHANGED HERE - CHANGE GLOBALS.CPP! */
enum
{
	msoimodUser,		// System User
	msoimodGdi,			// System GDI
	msoimodWinnls,		// System International utilities
	#define msoimodGetMax (msoimodWinnls+1)
	
	msoimodShell,		// System Shell
	msoimodCommctrl,	// System Common controls
	msoimodOleAuto,		// System OLE automation
	msoimodCommdlg,		// System common dialogs
	msoimodVersion,		// System version APIs
	msoimodWinmm,		// System multimedia
	msoimodMapi,		// Mail
	msoimodCommtb,		// Button editor
	msoimodHlink,		// Hyperlink APIs
	msoimodUrlmon,		// Url moniker APIs
	msoimodMso95fx, 	// ???
	msoimodJet,			// Jet database
	msoimodOleAcc,		// OLE Accessibility
	msoimodWinsock,		// Network Sockets
	msoimodMpr,			// Windows Network
	msoimodOdma,		// odma
	msoimodWininet,		// internet stuff
	msoimodRpcrt4,		// RPC
	
	msoimodMax,
};


/*	Returns the module handle of the given module imod. Loads it if it is
	not loaded already.  fForceLoad will force a LoadLibrary on the DLL
	even if it is already in memory. */
MSOAPI_(HINSTANCE) MsoLoadModule(int imod, BOOL fForceLoad);

MSOAPI_(void) MsoFreeModule(int imod);

MSOAPI_(BOOL) MsoFModuleLoaded(int imod);

/*	Returns the proc address in the module imod of the function
	szName.  Returns NULL if the module is not found or if the entry
	point does not exist in the module. */
MSOAPI_(FARPROC) MsoGetProcAddress(int imod, const char* szName);


/*	This API should be called by the client before MsoFInitOffice to set
	our locale id so that we can load the correct international dll.
	Defaults to the user default locale if app doesn't call this API before. */
MSOAPI_(void) MsoSetLocale(LCID dwLCID);
MSOAPI_(void) MsoSetLocaleEx(LCID lcid, const WCHAR* wzSuffix);

#define msobtaNone			0
#define msobtaPreRelease	1
#define msobtaOEM			2
#define msobtaOEMCD			3
#define msobtaOEMFixed		4

/*	Puts the Office DLL in "beta-mode".  When we're in beta mode, we do
	our beta expiration test in MsoFInitOffice. There are 2 kinds of betas:
	msobtaPreRelease:	look in the intl DLL for a hardcoded expiration date
						(Apps should make this call if they ship a beta after
						mso97.dll RTM, i.e. FE betas)
	msobtaOEM:			apps expire 90 days after first boot
	msobtaOEMCD:		same as msobtaOEM, except setup sets the date -- UNUSED FOR NOW
	msobtaOEMFixed:		same as msobtaPreRelease, except a different string
	msobtaNone:			No effect */
MSOAPI_(void) MsoSetBetaMode(int bta);

/* Cover for standard GetTextExtentPointW that:
	1. Uses GetTextExtentPoint32W on Win32 (more accurate)
	2. Fixes Windows bug	when cch is 0.  If cch is 0 then the correct dy 
		is returned and dx will be 0.  Also, if cch is 0 then wz can be NULL. */
MSOAPI_(BOOL) MsoFGetTextExtentPointW(HDC hdc, const WCHAR *wz, int cch, LPSIZE lpSize);

/* Covers for Windows APIs that need to call the W versions if on a 
	Unicode system, else the A version. */
#if MAC
	#define MsoDispatchMessage	DispatchMessage
	#define MsoSendMessage		SendMessage
	#define MsoPostMessage		PostMessage
	#define MsoCallWindowProc	CallWindowProc
	#define MsoSetWindowLong	SetWindowLong
	#define MsoGetWindowLong	GetWindowLong
#else
	MSOAPI_(LONG) MsoDispatchMessage(const MSG *pmsg);
	MSOAPI_(LONG) MsoSendMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
	MSOAPI_(LONG) MsoPostMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
	MSOAPI_(LRESULT) MsoCallWindowProc(WNDPROC pPrevWndFunc, HWND hwnd, UINT msg, 
			WPARAM wParam, LPARAM lParam);
	MSOAPI_(LONG) MsoGetWindowLong(HWND hwnd, int nIndex);
	MSOAPIX_(LONG) MsoSetWindowLong(HWND hwnd, int nIndex, LONG dwNewLong);
	MSOAPI_(LONG) MsoGetWindowLong(HWND hwnd, int nIndex);
	MSOAPI_(BOOL) MsoExtTextOutW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect,
											LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp);
#endif
MSOAPI_(int) MsoGetWindowTextWtz(HWND hwnd, WCHAR *wtz, int cchMax);
MSOAPIX_(BOOL) MsoSetWindowTextWtz(HWND hwnd, WCHAR *wtz);

/* If the LOGFONT at plf is a default system UI font then change *plf 
	to substitute the Tahoma font as appropriate for the system.
	Return TRUE if *plf was changed. */
MSOAPI_(BOOL) MsoFSubstituteTahomaLogfont(LOGFONT *plf);

// Fonts supported by MsoFGetFontSettings
enum
	{
	msofntMenu,
	msofntTooltip,
	};

/* Return font and color info for the font given by 'fnt' (see msofntXXX).
	If fVertical, then the font is rotated 90 degrees if this fnt type
	supports rotation in Office.  If phfont is non-NULL, return the HFONT used 
	for this item.  This font is owned and cached by Office and should not 
	be deleted.  If phbrBk is non-NULL, return a brush used for the 
	background of this item	(owned by Office and should not be deleted).  
	If pcrText is non-NULL,	return the COLOREF used for the text color for 
	this item. Return TRUE if all requested info was returned. */
MSOAPI_(BOOL) MsoFGetFontSettings(int fnt, BOOL fVertical, HFONT *phfont, 
		HBRUSH *phbrBk, COLORREF *pcrText);

/* If the system suppports NotifyWinEvent, then call it with the given
	parameters (see \otools\inc\win\winable.h). */
#if MAC
	#define MsoNotifyWinEvent(dwEvent, hwnd, idObject, idChild)
#else
	MSOAPI_(void) MsoNotifyWinEvent(DWORD dwEvent, HWND hwnd, LONG idObject, LONG idChild);
#endif	

/* Return TRUE if an Accessibility screen reader is running. */
#if MAC
	#define MsoFScreenReaderPresent()	FALSE
#else
	MSOAPI_(BOOL) MsoFScreenReaderPresent();
#endif	

/* Put up an alert that says that a help ghosting or shortcut could not 
	be performed because the app is in a bad state. */
MSOAPI_(void) MsoDoGhostingAlert();

#if MAC
/* If you need an hwnd for an SDM dialog, here's where you can get one */
MSOMACAPIX_(HWND) HwndWrapDialog(WindowPtr, HWND);
MSOAPI_(HWND) HwndGetWindowWrapper(WindowPtr);

/* This draws those pretty 3d buttons in dialogs and alerts.  Call it if
 * you need your own pretty 3d buttons.  Note that this is NOT a Unicode
 * API! */
MSOAPI_(void) MsoDrawOnePushButton(Rect *, char *, BOOL, BOOL);

/* These APIs create a tiny, offscreen window in the front of the window list
 * whose sole purpose is to fool the Print Monitor into thinking that your
 * document is called something other than "MsoDockTop" or some such.  Call
 * MsoFSetFrontTitle before you call PrOpen and MsoRemoveFrontTitle after
 * you call PrClose.  And make sure you pass in an ANSI string */
MSOAPIXX_(BOOL) MsoFSetFrontTitle(char *);
MSOAPIXX_(void) MsoRemvoveFrontTitle(void);
#endif // MAC

#if !MAC
/*	Constructs the name of the international dll from the locale passed in. */
MSOAPI_(BOOL) MsoFGetIntlName(LCID lcid, char *sz);
#endif // !MAC


/****************************************************************************
	MsoRelayerTopmostWindows

	This function must be called when you are an OLE server, and you are
	called on OnFrameWindowActivate(FALSE) for real deactivation (as opposed
	to just being deactivated because your container is activated). Office
	receives no notification of this and requires this explicit call.

	MsoRelayerTopmostWindows moves all topmost windows in this window's
	process (Asssistant, tooltip, command bars) behind the window to turn off
	their TOPMOST bit and prevent activation and Z-order bugs on
	reactivation. Fix 59453.

	For this to work:

	1. hwnd must be your standalone top-level window, not the embedded
			window.
	2. hwnd's WndProc must call MsoFWndProc (it should, since you're an
			Office-friendly app).
	3. your OLE message filter must let WM_MSO messages through.
****************************************************************************/
MSOAPI_(void) MsoRelayerTopmostWindows(HWND hwnd);


#endif // MSOUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\euc2sjis.c ===
//
// File Name:   euc2sjis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

#ifdef _DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern DBCS_STATUS dStatus;
#endif

//@
// 
// Syntax:

int EUCChar_to_ShiftJISChar (UCHAR *pEUC, UCHAR *pShiftJIS )

// The EUCChar_to_ShiftJISChar function convert one character string 
// as EUC code to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// UCHAR *pShiftJIS     Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//
// Return Value
// The return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//

{

	if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0a1)/2+0x081;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0a2)/2+0x081;
			goto EVEN_SECOND_BYTE;
		}
	}
	if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0df)/2+0x0e0;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0e0)/2+0x0e0;
			goto EVEN_SECOND_BYTE;
		}
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pEUC == 0x08e ) {
		*pShiftJIS = *(pEUC+1);
		return( 1 );
	}
	// Is the charcter ASCII charcter ?
	*pShiftJIS = *pEUC;
	return ( 1 );

ODD_SECOND_BYTE:
	if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
		*(pShiftJIS+1) = *(pEUC+1) - 0x061;
	}
	else {
		*(pShiftJIS+1) = *(pEUC+1) - 0x060;
	}
	return ( 2 );
EVEN_SECOND_BYTE:
	*(pShiftJIS+1) = *(pEUC+1)-2;
	return ( 2 );
}

int EUC_to_ShiftJIS (CONV_CONTEXT *pcontext,  UCHAR *pEUC, int EUC_len, UCHAR *pSJIS, int SJIS_len )


// The EUC_to_ShiftJIS function convert a character string as EUC code 
// to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// int   EUC_len        Specifies the size in bytes of the string pointed
//                      to by the pEUC parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//         
// int   SJIS_len       Specifies the size, in Shift JIS characters of the 
//                      buffer pointed to by the pSJIS parameter.
//                      If the value is zero,
//                      the function returns the number of Shift JIS characters 
//                      required for the buffer, and makes no use of the pSJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and SJIS_len is nonzero, the return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//
// If the function succeeds, and SJIS_len is zero, the return value is the
// required size, in Shift JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pSJIS buffer
// is small for setting converted strings.
//

{
    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    // we have to run on the given context to be multi-thread safe.
    if(!pcontext) return 0;

    if ( EUC_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        EUC_len = strlen ( pEUC ) + 1;
    }
    i = 0;
    re = 0;
    if ( SJIS_len == 0 ) {
        // Only retrun the required size
#ifdef DBCS_DIVIDE
        if ( pcontext->dStatus0.nCodeSet == CODE_JPN_EUC ){
            pEUC++;
            i++;

            // Is the charcter Hankaku KATAKANA ?
            if ( pcontext->dStatus0.cSavedByte == 0x08e )
                re++;
            else // The character is Kanji.
                re+=2;

            pcontext->dStatus0.nCodeSet = CODE_UNKNOWN;
            pcontext->dStatus0.cSavedByte = '\0';
        }
#endif
        while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
            if( ( i == EUC_len - 1 ) &&
                ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
                pcontext->dStatus0.nCodeSet = CODE_JPN_EUC;
                pcontext->dStatus0.cSavedByte = *pEUC;
                break;
            }
#endif
            // Is the character Kanji?
            if ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe ) {
                pEUC+=2;
                i+=2;
                re+=2;
                continue;
            }
            // Is the charcter Hankaku KATAKANA ?
            if ( *pEUC == 0x08e ) {
                pEUC+=2;
                i+=2;
                re++;
                continue;
            }
            // Is the charcter ASCII charcter ?
            pEUC++;
            i++;
            re++;
        }
        return ( re );
    }

#ifdef DBCS_DIVIDE
    if ( pcontext->dStatus.nCodeSet == CODE_JPN_EUC ){
        UCHAR cEUC = pcontext->dStatus.cSavedByte;

        if ( cEUC >= 0x0a1 && cEUC <= 0x0de ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0a1) / 2 + 0x081;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0a2) / 2 + 0x081;
                goto EVEN_SECOND_BYTE2;
            }
        }
        if ( cEUC >= 0x0df && cEUC <= 0x0fe ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0df) / 2 + 0x0e0;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0e0) / 2 + 0x0e0;
                goto EVEN_SECOND_BYTE2;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( cEUC == 0x08e ) {
            *pSJIS++ = *pEUC++;
            i++;
            re++;
            goto END;
        }
ODD_SECOND_BYTE2:
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0df ) {
            *(pSJIS+1) = *pEUC - 0x061;
        }
        else {
            *(pSJIS+1) = *pEUC - 0x060;
        }
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
        goto END;
EVEN_SECOND_BYTE2:
        *(pSJIS+1) = *pEUC - 2;
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
END:
        pcontext->dStatus.nCodeSet = CODE_UNKNOWN;
        pcontext->dStatus.cSavedByte = '\0';
    }
#endif

    while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
        if( ( i == EUC_len - 1 ) &&
            ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
            pcontext->dStatus.nCodeSet = CODE_JPN_EUC;
            pcontext->dStatus.cSavedByte = *pEUC;
            break;
        }
#endif
        if ( re >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0a1)/2+0x081;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0a2)/2+0x081;
                goto EVEN_SECOND_BYTE;
            }
        }
        if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0df)/2+0x0e0;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0e0)/2+0x0e0;
                goto EVEN_SECOND_BYTE;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pEUC == 0x08e ) {
            pEUC++;
            *pSJIS++ = *pEUC++;
            i+=2;
            re++;
            continue;
        }
        // Is the charcter ASCII charcter ?
        *pSJIS++ = *pEUC++;
        i++;
        re++;
        continue;
ODD_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
            *(pSJIS+1) = *(pEUC+1) - 0x061;
        }
        else {
            *(pSJIS+1) = *(pEUC+1) - 0x060;
        }
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;
EVEN_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        *(pSJIS+1) = *(pEUC+1)-2;
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;

    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbin.h ===
#include "ConvBase.h"

class CInccHzGbIn : public CINetCodeConverter
{
public:
	CInccHzGbIn();
	~CInccHzGbIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccHzGbIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fGBMode;

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvTilde(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvDoubleByte(BOOL fCleanUp, BYTE byTrail, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbout.h ===
#include "ConvBase.h"

class CInccHzGbOut : public CINetCodeConverter
{
public:
	CInccHzGbOut();
	~CInccHzGbOut() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	BOOL fDoubleByte;
	BYTE byLead;
	BOOL fGBMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\fechrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//

#ifdef __cplusplus
extern "C" {
#endif 

// Shift JIS Kanji Code Check
#define SJISISKANJI(c) ( ( (UCHAR)(c) >= 0x81 && (UCHAR)(c) <= 0x9f ) || \
                         ( (UCHAR)(c) >= 0xe0 && (UCHAR)(c) <= 0xfc ) )

// Shift JIS Kana Code Check
#define SJISISKANA(c) ( (UCHAR)(c) >= 0xa1 && (UCHAR)(c) <= 0xdf )

#define ESC     0x1b
#define SO      0x0e
#define SI      0x0f

#define IS2022_IN_CHAR           '$'
#define IS2022_IN_KSC_CHAR1      ')'
#define IS2022_IN_KSC_CHAR2      'C'

// Define for JIS Code Kanji and Kana IN/OUT characters
#define KANJI_IN_1ST_CHAR       '$'
#define KANJI_IN_2ND_CHAR1      'B'
#define KANJI_IN_2ND_CHAR2      '@'
#define KANJI_IN_2ND_CHAR3      '('
#define KANJI_IN_3RD_CHAR       'D'
#define KANJI_IN_STR            "$B"
#define KANJI_IN_LEN             3
#define KANJI_OUT_1ST_CHAR      '('
#define KANJI_OUT_2ND_CHAR1     'J'
#define KANJI_OUT_2ND_CHAR2     'B'
#define KANJI_OUT_LEN            3
#define KANJI_OUT_STR           "(J"


// Define for Internet Code Type
#define CODE_UNKNOWN            0
#define CODE_ONLY_SBCS          0
#define CODE_JPN_JIS            1
#define CODE_JPN_EUC            2
#define CODE_JPN_SJIS           3
#define CODE_PRC_CNGB           4
#define CODE_PRC_HZGB           5
#define CODE_TWN_BIG5           6
#define CODE_KRN_KSC            7
#define CODE_KRN_UHC            8

// Minimum length to determine if the string is EUC
#define MIN_JPN_DETECTLEN      48

typedef struct _dbcs_status
{
    int nCodeSet;
    UCHAR cSavedByte;
    BOOL fESC;
} DBCS_STATUS;

typedef struct _conv_context
{
    DBCS_STATUS dStatus0;
    DBCS_STATUS dStatus;
    
    BOOL blkanji0;  // Kanji In Mode
    BOOL blkanji;   // Kanji In Mode
    BOOL blkana;    // Kana Mode
    int  nCurrentCodeSet;

    void* pIncc0;
    void* pIncc;
} CONV_CONTEXT;

// ----------------------------------
// Public Functions for All FarEast
//-----------------------------------

// Convert from PC Code Set to UNIX Code Set
int WINAPI PC_to_UNIX (
    void *pcontext,
    int CodePage,
    int CodeSet,
    UCHAR *pPC,
    int PC_len,
    UCHAR *pUNIX,
    int UNIX_len
    );

// Convert from UNIX Code Set to PC Code Set
int WINAPI UNIX_to_PC (
    void *pcontext,
    int CodePage,
    int CodeSet,
    UCHAR *pUNIX,
    int UNIX_len,
    UCHAR *pPC,
    int PC_len
    );

//--------------------------------
// Internal Functions for Japanese
//--------------------------------

// Detect Japanese Code
int DetectJPNCode ( UCHAR *string, int len );

// Convert from Shift JIS to JIS
int ShiftJIS_to_JIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from Shift JIS to EUC
int ShiftJIS_to_EUC (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

#ifdef NOTIMPLEMENTED
// Convert from JIS  to EUC
int JIS_to_EUC (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );
#endif

// Convert from JIS to Shift JIS
int JIS_to_ShiftJIS (
    CONV_CONTEXT *pcontext,
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

#ifdef NOTIMPLEMENTED
// Convert from EUC to JIS
int EUC_to_JIS (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );
#endif

// Convert from EUC to Shift JIS
int EUC_to_ShiftJIS (
    CONV_CONTEXT *pcontext,
    UCHAR *pEUC,
    int EUC_len,
    UCHAR *pShiftJIS,
    int ShiftJIS_len
    );

//--------------------------------
// Internal Functions for PRC
//--------------------------------

// Convert from HZ-GB to GB2312
int HZGB_to_GB2312 (
    CONV_CONTEXT *pcontext,
    UCHAR *pGB2312,
    int GB2312_len,
    UCHAR *pHZGB,
    int HZGB_len
    );

// Convert from GB2312 to HZ-GB
int GB2312_to_HZGB (
    CONV_CONTEXT *pcontext,
    UCHAR *pGB2312,
    int GB2312_len,
    UCHAR *pHZGB,
    int HZGB_len
    );

//--------------------------------
// Internal Functions for Korea
//--------------------------------

// Convert from KSC to Hangeul
int KSC_to_Hangeul (
    CONV_CONTEXT *pcontext,
    UCHAR *pHangeul,
    int Hangeul_len,
    UCHAR *pKSC,
    int KSC_len
    );

// Convert from Hangeul to KSC
int Hangeul_to_KSC (
    CONV_CONTEXT *pcontext,
    UCHAR *pHangeul,
    int Hangeul_len,
    UCHAR *pKSC,
    int KSC_len
    );

void WINAPI FCC_Init( PVOID );
int WINAPI FCC_GetCurrentEncodingMode( PVOID );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from HZ-GB-2312
// =================================================================================

#include "pch.hxx"
#include "HzGbIn.h"
#include "FEChrCnv.h"

int HZGB_to_GB2312 (CONV_CONTEXT *pcontext, UCHAR *pHZGB, int HZGB_len, UCHAR *pGB2312, int GB2312_len)
{
	long lConvertedSize;

	if (!GB2312_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccHzGbIn;

		if (FAILED(((CInccHzGbIn*)pcontext->pIncc0)->GetStringSizeA(pHZGB, HZGB_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccHzGbIn;

		if (FAILED(((CInccHzGbIn*)pcontext->pIncc)->ConvertStringA(pHZGB, HZGB_len, pGB2312, GB2312_len, &lConvertedSize)))
			return -1;
	}

	if (!pHZGB) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccHzGbIn::CInccHzGbIn()
{
	pfnNextProc = ConvMain;
	fGBMode = FALSE;
}

HRESULT CInccHzGbIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccHzGbIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccHzGbIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		if (!fGBMode) {
			if (by == '~') {
				pfnNextProc = ConvTilde;
			} else {
				hr = Output(by);
			}
		} else {
			if (by >= 0x20 && by <= 0x7e) {
				pfnNextProc = ConvDoubleByte;
				lNextParam = (long)by;
			} else {
				hr = Output(by);
			}
		}
	}
	return hr;
}

HRESULT CInccHzGbIn::ConvTilde(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case '~':
			return Output('~');

		case '{':
			fGBMode = TRUE;
			return ResultFromScode(S_OK);

		case '\n':
			// Just eat it
			return ResultFromScode(S_OK);

		default:
			(void)Output('~');
			return ConvertByte(by);
		}
	} else {
		return Output('~');
	}
}

HRESULT CInccHzGbIn::ConvDoubleByte(BOOL fCleanUp, BYTE byTrail, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if ((BYTE)lParam >= 0x21 && (BYTE)lParam <= 0x77 && byTrail >= 0x21 && byTrail <= 0x7e) { // Check if GB char
			(void)Output((BYTE)lParam | 0x80);
			return Output(byTrail | 0x80);
		} else if ((BYTE)lParam == '~' && byTrail == '}') { // 0x7e7d
			fGBMode = FALSE;
			return ResultFromScode(S_OK);
		} else if ((BYTE)lParam >= 0x78 && (BYTE)lParam <= 0x7d && byTrail >= 0x21 && byTrail <= 0x7e) { // Check if non standard extended code
			(void)Output(0xa1); // Output blank box symbol
			return Output(0xf5);
		} else if ((BYTE)lParam == '~') {
			(void)Output('~'); // Output blank box symbol
			return Output(byTrail);
		} else if ((BYTE)lParam == ' ') {
			return Output(byTrail);
		} else if (byTrail == ' ') {
			(void)Output(0xa1); // Output space symbol
			return Output(0xa1);
		} else {
			(void)Output((BYTE)lParam);
			return Output(byTrail);
		}
	} else {
		return Output((BYTE)lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbout.cpp ===
// =================================================================================
// Internet Character Set Conversion: Output to HZ-GB-2312
// =================================================================================

#include "pch.hxx"
#include "HzGbOut.h"
#include "FEChrCnv.h"

int GB2312_to_HZGB (CONV_CONTEXT *pcontext, UCHAR *pGB2312, int GB2312_len, UCHAR *pHZGB, int HZGB_len)
{
	long lConvertedSize;

	if (!HZGB_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccHzGbOut;

		if (FAILED(((CInccHzGbOut*)pcontext->pIncc0)->GetStringSizeA(pGB2312, GB2312_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccHzGbOut;

		if (FAILED(((CInccHzGbOut*)pcontext->pIncc)->ConvertStringA(pGB2312, GB2312_len, pHZGB, HZGB_len, &lConvertedSize)))
			return -1;
	}

	if (!pGB2312) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccHzGbOut::CInccHzGbOut()
{
	fDoubleByte = FALSE;
	fGBMode = FALSE;
}

HRESULT CInccHzGbOut::ConvertByte(BYTE by)
{
	HRESULT hr = S_OK;

	if (!fDoubleByte) {
		if (by & 0x80) {
			fDoubleByte = TRUE;
			byLead = by;
		} else {
			if (fGBMode) {
				(void)Output('~');
				hr = Output('}');
				fGBMode = FALSE;
			}
			hr = Output(by);
		}
	} else {
		fDoubleByte = FALSE;
		if (!fGBMode) {
			(void)Output('~');
			(void)Output('{');
			fGBMode = TRUE;
		}
		(void)Output(byLead & 0x7f);
		hr = Output(by & 0x7f);
	}
	return hr;
}

HRESULT CInccHzGbOut::CleanUp()
{
	HRESULT hr = S_OK;

	if (fGBMode) {
		(void)Output('~');
		hr = Output('}');
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\jisin.h ===
#include "ConvBase.h"

// This class converts a Internet code page, ISO-2022-JP (known as JIS), into a Windows code page, 932 (known as Shift-JIS).

class CInccJisIn : public CINetCodeConverter
{
public:
	CInccJisIn();
	~CInccJisIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccJisIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fKanaMode; // Indicates converting Hankaku(Single Byte) Katakana Code (>= 0x80) by SI/SO.
	BOOL fKanjiMode; // Indicates converting Double Byte Codes.

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvEsc(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiIn2(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiIn3(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiOut2(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvStar(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanji(BOOL fCleanUp, BYTE byJisTrail, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscin.h ===
#include "ConvBase.h"

class CInccKscIn : public CINetCodeConverter
{
public:
	CInccKscIn();
	~CInccKscIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccKscIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fIsoMode;
	BOOL fKscMode;

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvEsc(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvIsoIn(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKsc1st(BOOL fCleanUp, BYTE by, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from IS-2022-KR
// =================================================================================

#include "pch.hxx"
#include "KscIn.h"
#include "FEChrCnv.h"

int KSC_to_Hangeul (CONV_CONTEXT *pcontext, UCHAR *pKSC, int KSC_len, UCHAR *pHangeul, int Hangeul_len)
{
	long lConvertedSize;

	if (!Hangeul_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccKscIn;

		if (FAILED(((CInccKscIn*)pcontext->pIncc0)->GetStringSizeA(pKSC, KSC_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccKscIn;

		if (FAILED(((CInccKscIn*)pcontext->pIncc)->ConvertStringA(pKSC, KSC_len, pHangeul, Hangeul_len, &lConvertedSize)))
			return -1;
	}

	if (!pKSC) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccKscIn::CInccKscIn()
{
	pfnNextProc = ConvMain;
	fIsoMode = FALSE;
	fKscMode = FALSE;
}

HRESULT CInccKscIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccKscIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccKscIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		if (by == ESC) {
			pfnNextProc = ConvEsc;
		} else {
			if (fIsoMode) {
				switch (by) {
				case SO:
					fKscMode = TRUE;
					break;

				case SI:
					fKscMode = FALSE;
					break;

				default:
					if (fKscMode) {
						switch (by) {
						case ' ':
						case '\t':
						case '\n':
							hr = Output(by);
							break;

						default:
							hr = Output(by | 0x80);
							break;
						}
					} else {
						hr = Output(by);
					}
					break;
				}
			} else {
				hr = Output(by);
			}
		}
	}
	return hr;
}

HRESULT CInccKscIn::ConvEsc(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_CHAR) {
			pfnNextProc = ConvIsoIn;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			return ConvertByte(by);
		}
	} else {
		return Output(ESC);
	}
}

HRESULT CInccKscIn::ConvIsoIn(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_KSC_CHAR1) {
			pfnNextProc = ConvKsc1st;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(IS2022_IN_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(IS2022_IN_CHAR);
		return CleanUp();
	}
}

HRESULT CInccKscIn::ConvKsc1st(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_KSC_CHAR2) {
			fIsoMode = TRUE;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(IS2022_IN_CHAR);
			(void)ConvertByte(IS2022_IN_KSC_CHAR1);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(IS2022_IN_CHAR);
		(void)ConvertByte(IS2022_IN_KSC_CHAR1);
		return CleanUp();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\jisin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from IS-2022-JP
// =================================================================================

#include "pch.hxx"
#include "JisIn.h"
#include "FEChrCnv.h"

int JIS_to_ShiftJIS (CONV_CONTEXT *pcontext, UCHAR *pJIS, int JIS_len, UCHAR *pSJIS, int SJIS_len)
{
	long lConvertedSize;

	if (!SJIS_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccJisIn;

		if (FAILED(((CInccJisIn*)pcontext->pIncc0)->GetStringSizeA(pJIS, JIS_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccJisIn;

		if (FAILED(((CInccJisIn*)pcontext->pIncc)->ConvertStringA(pJIS, JIS_len, pSJIS, SJIS_len, &lConvertedSize)))
			return -1;
	}

	if (!pJIS) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccJisIn::CInccJisIn()
{
	pfnNextProc = ConvMain;
	fKanaMode = FALSE;
	fKanjiMode = FALSE;
}

HRESULT CInccJisIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccJisIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccJisIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		switch (by) {
		case SO:
			fKanaMode = TRUE;
			break;

		case SI:
			fKanaMode = FALSE;
			break;

		default:
			if (fKanaMode) {
				hr = Output(by | 0x80);
			} else {
				if (by == ESC) {
					pfnNextProc = ConvEsc;
				} else {
					if (fKanjiMode) {
						if (by == '*') {
							pfnNextProc = ConvStar;
						} else {
							pfnNextProc = ConvKanji;
							lNextParam = (long)by;
						}
					} else {
						hr = Output(by);
					}
				}
			}
			break;
		}
	}
	return hr;
}

HRESULT CInccJisIn::ConvEsc(BOOL fCleanUp, BYTE by, long lParam)
{
	if (!fCleanUp) {
		switch (by) {
		case KANJI_IN_1ST_CHAR:
			pfnNextProc = ConvKanjiIn2;
			return ResultFromScode(S_OK);

		case KANJI_OUT_1ST_CHAR:
			pfnNextProc = ConvKanjiOut2;
			return ResultFromScode(S_OK);

		default:
			pfnNextProc = ConvMain;
			(void)Output(ESC);
			return ConvertByte(by);
		}
	} else {
		pfnNextProc = ConvMain;
		return Output(ESC);
	}
}

HRESULT CInccJisIn::ConvKanjiIn2(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case KANJI_IN_2ND_CHAR1:
		case KANJI_IN_2ND_CHAR2:
			fKanjiMode = TRUE;
			return ResultFromScode(S_OK);

		case KANJI_IN_2ND_CHAR3:
			pfnNextProc = ConvKanjiIn3;
			return ResultFromScode(S_OK);

		default:
			(void)Output(ESC);
			(void)ConvertByte(KANJI_IN_1ST_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_IN_1ST_CHAR);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvKanjiIn3(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == KANJI_IN_3RD_CHAR) {
			fKanjiMode = TRUE;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(KANJI_IN_1ST_CHAR);
			(void)ConvertByte(KANJI_IN_2ND_CHAR3);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_IN_1ST_CHAR);
		(void)ConvertByte(KANJI_IN_2ND_CHAR3);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvKanjiOut2(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case KANJI_OUT_2ND_CHAR1:
		case KANJI_OUT_2ND_CHAR2:
			fKanjiMode = FALSE;
			return ResultFromScode(S_OK);

		default:
			(void)Output(ESC);
			(void)ConvertByte(KANJI_OUT_1ST_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_OUT_1ST_CHAR);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvStar(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;
	if (!fCleanUp) {
		return Output(by | 0x80);
	} else {
		return Output('*');
	}
}

HRESULT CInccJisIn::ConvKanji(BOOL fCleanUp, BYTE byJisTrail, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		BYTE bySJisLead;
		BYTE bySJisTrail;

		bySJisLead = ((BYTE)lParam - 0x21 >> 1) + 0x81;
		if (bySJisLead > 0x9f)
			bySJisLead += 0x40;

		bySJisTrail = byJisTrail + ((BYTE)lParam & 1 ? 0x1f : 0x7d);
		if (bySJisTrail >= 0x7f)
			bySJisTrail++;

		(void)Output(bySJisLead);
		return Output(bySJisTrail);
	} else {
		return Output((BYTE)lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscout.h ===
#include "ConvBase.h"

class CInccKscOut : public CINetCodeConverter
{
public:
	CInccKscOut();
	~CInccKscOut() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	BOOL fDoubleByte;
	BYTE byLead;
	BOOL fIsoMode;
	BOOL fKscMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscout.cpp ===
// =================================================================================
// Internet Character Set Conversion: Output to IS-2022-KSC
// =================================================================================

#include "pch.hxx"
#include "KscOut.h"
#include "FEChrCnv.h"

int Hangeul_to_KSC (CONV_CONTEXT *pcontext, UCHAR *pHangeul, int Hangeul_len, UCHAR *pKSC, int KSC_len)
{
	long lConvertedSize;

	if (!KSC_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccKscOut;

		if (FAILED(((CInccKscOut*)pcontext->pIncc0)->GetStringSizeA(pHangeul, Hangeul_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccKscOut;

		if (FAILED(((CInccKscOut*)pcontext->pIncc)->ConvertStringA(pHangeul, Hangeul_len, pKSC, KSC_len, &lConvertedSize)))
			return -1;
	}

	if (!pHangeul) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccKscOut::CInccKscOut()
{
	fDoubleByte = FALSE;
	fIsoMode = FALSE;
	fKscMode = FALSE;
}

HRESULT CInccKscOut::ConvertByte(BYTE by)
{
	HRESULT hr = S_OK;

	if (!fIsoMode) {
		(void)Output(ESC);
		(void)Output(IS2022_IN_CHAR);
		(void)Output(IS2022_IN_KSC_CHAR1);
		(void)Output(IS2022_IN_KSC_CHAR2);
		fIsoMode = TRUE;
	}
	if (!fDoubleByte) {
		if (by > 0x80) {
			fDoubleByte = TRUE;
			byLead = by;
		} else {
			if (fIsoMode && fKscMode) {
				(void)Output(SI);
				fKscMode = FALSE;
			}
			hr = Output(by);
		}
	} else {
		fDoubleByte = FALSE;
		if (by > 0x40) { // Check if trail byte indicates Hangeul
			if (!fKscMode) {
				(void)Output(SO);
				fKscMode = TRUE;
			}
			if (byLead > 0xa0 && by > 0xa0) { // Check if it's a Wansung
				(void)Output(byLead & 0x7f);
				hr = Output(by & 0x7f);
			} else {
				(void)Output(0x22); // Replace to inversed question mark
				hr = Output(0x2f);
			}
		} else {
			if (fIsoMode && fKscMode) {
				(void)Output(SI);
				fKscMode = FALSE;
			}
			(void)Output(byLead);
			hr = Output(by);
		}
	}
	return hr;
}

HRESULT CInccKscOut::CleanUp()
{
	if (!fDoubleByte)
		return S_OK;
	else
		return Output(byLead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\pc2unix.c ===
// File Name:   pc2unix.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"



int FE_PC_to_UNIX (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                           UCHAR *pPCChar, int PCChar_len,
                           UCHAR *pUNIXChar, int UNIXChar_len )
// The FE_PC_to_UNIX function convert a character string as PC code 
// set string to a Japanese UNIX code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pPCChar string 
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pPCChar string 
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pPCChar       Points to the character string to be converted.
//         
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//         
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is 
//                      zero, the function returns the number of UNIX characters 
//                      required for the buffer, and makes no use of the 
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is 
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar 
// buffer is small for setting converted strings.
//
//@
{
    int    re;

        switch ( CodeSet ) {
        default:
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from Shift JIS to JIS
			if (pPCChar) {
				re = ShiftJIS_to_JIS ( pPCChar, PCChar_len,
											   pUNIXChar, UNIXChar_len );
			} else {
				re = 0;
			}
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from Shift JIS to EUC
			if (pPCChar) {
				re = ShiftJIS_to_EUC ( pPCChar, PCChar_len,
											   pUNIXChar, UNIXChar_len );
			} else {
				re = 0;
			}
            break;
        case CODE_KRN_KSC:    // Korean KSC
            // Convert from Hangeul to KSC
            re = Hangeul_to_KSC ( pcontext, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_PRC_HZGB:   // PRC HZ-GB
            // Convert from GB2312 to HZ-GB
            re = GB2312_to_HZGB ( pcontext, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
        case CODE_KRN_UHC:     // Korean UHC
        case CODE_PRC_CNGB:    // PRC CN-GB
        case CODE_TWN_BIG5:    // Taiwanese BIG5
            // Convert from Shift JIS to Shift JIS
			if (pPCChar) {
				if ( PCChar_len == -1 ) {
					PCChar_len = strlen ( pPCChar ) + 1;
				}
				if ( UNIXChar_len != 0 ) {
					if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
						return ( -1 );
					}
					// Copy from pPCChar to pUNIXChar
					memmove ( pUNIXChar, pPCChar, PCChar_len );
				}
				re = PCChar_len;
			} else {
				re = 0;
			}
            break;
        }
		return ( re );
}


int WINAPI PC_to_UNIX (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                        UCHAR *pPCChar, int PCChar_len,
                        UCHAR *pUNIXChar, int UNIXChar_len )

// The PC_to_UNIX function convert a character string as PC code 
// set string to a UNIX code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pPCChar string 
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pPCChar string 
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pPCChar       Points to the character string to be converted.
//         
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//         
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is 
//                      zero, the function returns the number of UNIX characters 
//                      required for the buffer, and makes no use of the 
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is 
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar 
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
        case 950:    // Taiwan Code Page
        case 949:    // Korea Code Page
        case 936:    // PRC Code Page
            re = FE_PC_to_UNIX (pcontext, CodePage, CodeSet, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\pch_c.h ===
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shfusion.h>
/*#include "common.h"*/

/*#ifdef NT_BUILD*/
#include <shlobjp.h>
#include <shlguidp.h>
#include <comctrlp.h>
/*#endif*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\sjis2euc.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2euc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

//Shift JIS(SJC) to EUC Conversion algorithm
//Two byte KANJI
//  - 1st byte of Shift JIS charcter 
//	  (XX = Hex value of 1st byte of Shift JIS Charcter)
//    Range 0x81 - 0x9f
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xa1-0xdd
//              EUC 1st byte = (XX-0x81)*2 + 0xa1
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0x81)*2 + 0xa2
//
//    Range 0xe0 - 0xef
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xdf-0xfd
//              EUC 1st byte = (XX-0xe0)*2 + 0xdf
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0xe0)*2 + 0xe0
//
//  - 2nd byte of Shift JIS charcter 
//	  (YY = Hex value of 2nd byte of Shift JIS Charcter)
//    Range 0x40 - 0x7e                       (EUC)0xa1 - 0xdf
//              EUC 2nd byte = (YY+0x61)
//    Range 0x80 - 0x9e                       (EUC)0xe0 - 0xfe
//              EUC 2nd byte = (YY+0x60)
//    Range 0x9f - 0xfc                       (EUC)0xa1 - 0xfe
//              EUC 2nd byte = (YY+0x02)
//
//  Range 0x0a1 - 0x0df(Hankaku KATAKANA)
//    1st byte of EUC charcter = 0x08e
//    2nd byte if EUC charcter = C6220 Hankaku KATAKANA code
//    (same byte value as Shift JIS Hankaku KATAKANA) (0x0a1 - 0x0df)

//@
// 
// Syntax:

int ShiftJISChar_to_EUCChar ( UCHAR *pShiftJIS, UCHAR *pEUC )


// The ShiftJISChar_to_EUCChar function convert one Shift JIS character 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//
// Return Value
//      The number of bytes to copy.
//

{
	if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
		}
		goto SECOND_BYTE;
	}
	if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
		}
		goto SECOND_BYTE;
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
		*pEUC = 0x08e;
		*(pEUC+1) = *pShiftJIS;
		return( 2 );
	}
	// Is the charcter IBM Extended Charcter?
	if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
		// There are no IBM Extended Charcte in EUC charset.
		*pEUC = ' ';
		*(pEUC+1) = ' ';
		return( 2 );
	}
		// Is the charcter ASCII charcter ?
	*pEUC = *pShiftJIS;
	return ( 1 );

SECOND_BYTE:
	if ( *(pShiftJIS+1) >= 0x040 && *(pShiftJIS+1) <= 0x07e ) {
		*(pEUC+1) = *(pShiftJIS + 1) + 0x061;
	}
	else {
		if ( *(pShiftJIS+1) >= 0x080 && *(pShiftJIS+1) <= 0x09e ) {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x060;
		}
		else {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x002;
		}
	}
	return ( 2 );
}


int ShiftJIS_to_EUC ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pEUC, int EUC_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a EUC code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//         
// int   EUC_len        Specifies the size, in EUC characters of the buffer
//                      pointed to by the pEUC parameter. If the value is zero,
//                      the function returns the number of EUC characters 
//                      required for the buffer, and makes no use of the pEUC 
//                      buffer.
//
// Return Value
// If the function succeeds, and EUC_len is nonzero, the return value is the 
// number of EUC characters written to the buffer pointed to by pEUC.
//
// If the function succeeds, and EUC_len is zero, the return value is the
// required size, in EUC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pEUC buffer
// is small for setting converted strings.
//

{

    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( EUC_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {
                pShiftJIS+=2;
                i+=2;
                re+=2;
                continue;
            }
            if ( SJISISKANA(*pShiftJIS) ) {
                pShiftJIS++;
                i++;
                re+=2;
                continue;
            }
            pShiftJIS++;
            i++;
            re++;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            *pEUC = 0x08e;
            pEUC++;
            (*pEUC) = *pShiftJIS;
            re+=2;
            i++;
            pShiftJIS++;
            pEUC++;
            continue;
        }

        // Is the charcter IBM Extended Charcter?
        if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            // There are no IBM Extended Charcte in EUC charset.
            *pEUC = ' ';
            pEUC++;
            (*pEUC) = ' ';
            re+=2;
            i+=2;
            pShiftJIS+=2;
            pEUC++;
            continue;
	}

        // Is the charcter ASCII charcter ?
        if ( re  >= EUC_len ) {    // Buffer Over?
            return ( -1 );
        }
        *pEUC = *pShiftJIS;
        re++;
        i++;
        pShiftJIS++;
        pEUC++;
        continue;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\status.c ===
// File Name:   status.c
// Owner:       Masahiro Teragawa
// Revision:    1.00  08/23/'95  Masahiro Teragawa
//              Made it thread safe 2/23/96 yutakan
//

#include "pch_c.h"
#include "fechrcnv.h"

#if 0 // yutakan: will be initialized anyway.
#ifdef DBCS_DIVIDE
DBCS_STATUS dStatus0 = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji0 = FALSE;  // Kanji In Mode

DBCS_STATUS dStatus  = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji = FALSE;  // Kanji In Mode
BOOL blkana  = FALSE;  // Kana Mode
#endif  // DBCS_DIVIDE

int nCurrentCodeSet = CODE_UNKNOWN;
#endif

/*********************************************************************/
/* Function:   FCC_Init                                              */
/*********************************************************************/
void WINAPI FCC_Init( PVOID pcontext )
{
    if (!pcontext)
        return;
          
#ifdef DBCS_DIVIDE
    ((CONV_CONTEXT *)pcontext)->dStatus0.nCodeSet = CODE_UNKNOWN;
    ((CONV_CONTEXT *)pcontext)->dStatus0.cSavedByte = '\0';
    ((CONV_CONTEXT *)pcontext)->dStatus0.fESC = FALSE;

    ((CONV_CONTEXT *)pcontext)->blkanji0 = FALSE;

    ((CONV_CONTEXT *)pcontext)->dStatus.nCodeSet = CODE_UNKNOWN;
    ((CONV_CONTEXT *)pcontext)->dStatus.cSavedByte = '\0';
    ((CONV_CONTEXT *)pcontext)->dStatus.fESC = FALSE;

    ((CONV_CONTEXT *)pcontext)->blkanji = FALSE;
    ((CONV_CONTEXT *)pcontext)->blkana  = FALSE;
#endif  // DBCS_DIVIDE

    ((CONV_CONTEXT *)pcontext)->nCurrentCodeSet = CODE_UNKNOWN;

    ((CONV_CONTEXT *)pcontext)->pIncc0 = NULL;
    ((CONV_CONTEXT *)pcontext)->pIncc = NULL;

    return;
}

/*********************************************************************/
/* Function:   FCC_GetCurrentEncodingMode                            */
/*********************************************************************/
int WINAPI FCC_GetCurrentEncodingMode(void * pcontext )
{
    return pcontext?((CONV_CONTEXT *)pcontext)->nCurrentCodeSet:0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\sjis2jis.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2jis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

void ShiftJISChar_to_JISChar ( UCHAR *pShiftJIS, UCHAR *pJIS )

// The ShiftJISChar_to_JISChar function convert one character string 
// as Shift JIS code to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//
// Return Value
// None 

{
	USHORT	hi_code, low_code;

	hi_code = (*pShiftJIS);
	low_code = *(pShiftJIS+1);
	hi_code -= (hi_code > 0x9f ? 0xb1 : 0x71);
	hi_code = hi_code * 2 + 1;
	if ( low_code > 0x9e ) {
		low_code -= 0x7e;
		hi_code ++;
	}
	else {
		if ( low_code > 0x7e ) {
			low_code --;
		}
		low_code -= 0x1f;
	}
	*(pJIS) = (UCHAR)hi_code;
	*(pJIS+1) = (UCHAR)low_code;
	return;
}


int ShiftJIS_to_JIS ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pJIS, int JIS_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//         
// int   JIS_len        Specifies the size, in JIS characters of the buffer
//                      pointed to by the pJIS parameter. If the value is zero,
//                      the function returns the number of JIS characters 
//                      required for the buffer, and makes no use of the pJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and JIS_len is nonzero, the return value is the 
// number of JIS characters written to the buffer pointed to by pJIS.
//
// If the function succeeds, and JIS_len is zero, the return value is the
// required size, in JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pJIS buffer
// is small for setting converted strings.
//

{
    BOOL    kanji_in = FALSE;      // Kanji Mode
    BOOL    kana_in = FALSE;       // Kana  Mode
    int     re;                    // Convert Lenght
    int     i;                     // Loop Counter

    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( JIS_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
                if ( kana_in ) {            // Kana Mode?
                    re ++;
                    kana_in = FALSE;         // Reset Kana Mode;
                }
                if ( kanji_in == FALSE ) {  // Kanji Mode?
                    re += KANJI_IN_LEN;
                    kanji_in = TRUE;        // Set Kanji Mode
                }

                i+=2;
                re += 2;
                pShiftJIS+=2;
            }
            else if ( SJISISKANA(*pShiftJIS) ) {
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                if ( kana_in == FALSE ) {
                     re ++;
                     kana_in = TRUE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
            else {
                if ( kana_in ) {
                    re ++;
                    kana_in = FALSE;
                }
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
        }
        if ( kana_in ) {
            re ++;
            kana_in = FALSE;
        }
        if ( kanji_in ) {
            re += KANJI_OUT_LEN;
            kanji_in = FALSE;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
            if ( kana_in ) {            // Kana Mode?
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;     // Set Kana Out Charcter
                re ++;
                kana_in = FALSE;         // Reset Kana Mode;
            }
            if ( kanji_in == FALSE ) {  // Kanji Mode?
                if ( re + KANJI_IN_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = ESC;    // Set Kanji In Charcter
                (*pJIS++) = KANJI_IN_1ST_CHAR;
                (*pJIS++) = KANJI_IN_2ND_CHAR1;
                re += KANJI_IN_LEN;
                kanji_in = TRUE;        // Set Kanji Mode
            }

            if ( re + 2 > JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            ShiftJISChar_to_JISChar ( pShiftJIS, pJIS );
            i+=2;
            re += 2;
            pShiftJIS+=2;
            pJIS += 2;
        }
        else if ( SJISISKANA(*pShiftJIS) ) {
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( kana_in == FALSE ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SO;	// Set Kana In Charcter
                re ++;
                kana_in = TRUE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++) & 0x7f;
            i++;
            re++;
        }
        else {
            if ( kana_in ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;	// Set Kana Out Charcter
                re ++;
                kana_in = FALSE;
            }
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++);
            i++;
            re++;
        }
    }
    if ( kana_in ) {
        if ( re >= JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        (*pJIS++) = SI;	// Set Kana Out Charcter
        re ++;
        kana_in = FALSE;
    }
    if ( kanji_in ) {
        if ( re + KANJI_OUT_LEN  > JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        // Set Kanji Out Charcter
        (*pJIS++) = ESC;
        (*pJIS++) = KANJI_OUT_1ST_CHAR;
        (*pJIS++) = KANJI_OUT_2ND_CHAR1;
        re += KANJI_OUT_LEN;
        kanji_in = FALSE;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\help\mailnews.h ===
//Generic text for all groupbox labels
#define IDH_NEWS_COMM_GROUPBOX                  353500

//Columns dialog box: View menu, columns
#define IDH_NEWS_COL_AVAIL                      353501
#define IDH_NEWS_COL_DISPL                      353502
#define IDH_NEWS_COL_ADD                        353503
#define IDH_NEWS_COL_REMOVE                     353504
#define IDH_NEWS_COL_MOVEUP                     353505
#define IDH_NEWS_COL_MOVEDN                     353506
#define IDH_NEWS_COL_RESET                      353507

//Columns dialog: View menu, columns (mail)
#define IDH_VIEW_COLUMNS_LIST                 	50400
#define IDH_VIEW_COLUMNS_MOVE_UP                50405
#define IDH_VIEW_COLUMNS_MOVE_DOWN            	50410
#define IDH_VIEW_COLUMNS_SHOW                	50415
#define IDH_VIEW_COLUMNS_HIDE                	50420
#define IDH_VIEW_COLUMNS_WIDTH                	50425

//Newsgroups dialog box
#define IDH_NEWS_SERVER_LIST                    353508
#define IDH_NEWS_SEARCH_GROUPS_CONTAINING       353509
#define IDH_NEWS_GROUP_LISTS                    353510
//#define IDH_NEWS_FAVES_ONLY                     353511
#define IDH_NEWS_SEARCH_GROUPS_DESC             353512
#define IDH_NEWS_OPEN_SELECTED_GROUP            353513
#define IDH_NEWS_ADD_SELECTED_GROUP             353514
#define IDH_NEWS_REMOVE_SELECTED_GROUP          353515
//#define IDH_NEWS_NEW_LIST                       353516
//#define IDH_NEWS_UPDATE_NEW_LIST_NOW            353517
#define IDH_NEWS_RESET_NEW_LIST                 353518
#define IDH_NEWSGROUP_LIST_ALL                  353511
#define IDH_NEWSGROUP_LIST_SUBSCRIBE            353516
#define IDH_NEWSGROUP_LIST_NEW                  353517


//News menu, Options
////Read tab
#define IDH_NEWS_OPT_READ_MARK_MESSAGE_READ     353521
#define IDH_NEWS_OPT_CHECK_FOR_NEW              353522


////Read Tab, Tools/Options menu
#define IDH_MAIL_OPT_READ_MARK_READ             25252509
#define IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ         353519
#define IDH_NEWS_OPT_READ_AUTO_EXPAND           353520
#define IDH_NEWS_OPT_IN_PREVIEW                 353600
#define IDH_NEWS_OPT_READ_MARK_ALL_EXIT         353524
#define IDH_OPTIONS_READ_SHOW_PICTURE_ATTACHMENTS 35520
#define IDH_OPTIONS_READ_SHOW_SLIDESHOW         35525
#define IDH_OPTIONS_READ_FONT_SETTINGS          35530
#define IDH_OPTIONS_READ_INTL_SETTINGS         	35535
#define IDH_INTL_SETTINGS_READ_ENCODING         35540
#define IDH_INTL_SETTINGS_READ_DEFAULT_ENCODING  35545

#define IDH_OPT_READ_TOOLTIPS			502050
#define IDH_OPT_READ_CHAR_SETS			502055
#define IDH_OPT_READ_REMOVE_CHARSET		502060
#define IDH_OPTIONS_READ_WATCH_COLOR		35526

//General tab, Tools/Options menu
#define IDH_MAIL_OPT_READ_CHECK_4NEW            25252510
#define IDH_MAIL_OPT_READ_PLYSND                25252508
#define IDH_OPT_GENERAL_NOT_CONNECTED           25252507
#define IDH_MAIL_OPT_READ_EMPTY_DELETED         25252511
#define IDH_OPTIONS_ADD_REPLIES                 25252550
#define IDH_OPTIONS_REPLY_USING_SENT_FORMAT     25252555
#define IDH_NEWS_OPT_READ_NOTIFY_NEW_NEWS       353523
#define IDH_NEWS_OPT_READ_DEFAULT               353525
#define IDH_NEWS_SEND_IM_DEFAULT                353532
#define IDH_OPTIONS_GO_TO_INBOX                 25252560
#define IDH_GENERAL_MAKE_SIMPLE_MAPI_CLIENT     25252565
#define IDH_OPT_GEN_DISP_FOLDERS		502000
#define IDH_OPTIONS_MAINT_PURGE_DEL_IMAP	502001
#define IDH_OPTIONS_MAINT_BACKGR_COMPACT	502002
#define IDH_OPTIONS_MAINT_STORE_FOLDER		502003
#define IDH_OPTIONS_GEN_MESSENGER		502004
#define IDH_MAIL_OPT_SENDREC_AT_STARTUP		502005

////Spelling tab, Tools/Options menu
#define IDH_NEWS_SPELL_SUGGEST_REPL             353561
#define IDH_NEWS_SPELL_CHECK_BEFORE_SEND        353562
#define IDH_NEWS_SPELL_IGNORE_UPPERCASE         353563
#define IDH_NEWS_SPELL_IGNORE_WITH_NUMBERS      353564
#define IDH_NEWS_SPELL_ORIGINAL_TEXT            353565
#define IDH_OPTIONS_SPELLING_INTERNET_ADDRESSES 355500
#define IDH_OPTIONS_SPELLING_LANGUAGE           355510
#define IDH_OPTIONS_SPELLING_DICTIONARY         355520
#define IDH_OPTIONS_SPELL_BACKGROUND_CHECK	355521


//Security tab, Tools/Options menu
#define IDH_OPTIONS_ADD_DIGITAL_SIGNATURE       355530
#define IDH_OPTIONS_ENCRYPT_MESSAGES            355535
#define IDH_OPTIONS_SECURITY_ADVANCED           355540
#define IDH_MORE_ON_CERTIFICATES                355541
#define IDH_GET_DIGITAL_ID                      355542
#define IDH_SECURITY_ZONES_SETTINGS             355543
#define IDH_SECURITY_DIGITAL_ID	                355544
#define IDH_SECURITY_LABEL                      355546
#define IDH_SECURITY_SETLABEL       	        355548
#define IDH_SECURITY_SENDMAIL_WARN              355549
#define IDH_SECURITY_SAFE_ATTACHMENTS           355550

//Tools/Options/Security/Label settings		
#define IDH_SECURITY_POLICY_MODULE		355502
#define IDH_SECURITY_CLASSIFICATION		355504
#define IDH_SECURITY_PRIVACY			355506
#define IDH_SECURITY_CONFIGURE			355508

//Tools/Options/Security/Advanced settings
#define IDH_SECURITY_ADVANCED_ENCRYPTION        355522        
#define IDH_SECURITY_ADVANCED_INCLUDE_SELF      355523
#define IDH_SECURITY_SEND_TO_OTHERS             355524
#define IDH_SECURITY_ADVANCED_INCLUDE_ID        355525
#define IDH_SECURITY_ADVANCED_INCLUDE_PKCS      355526
#define IDH_OPTIONS_SECURITY_STRENGTH_WARN	355527
#define IDH_OPTIONS_SECURITY_ADV_ADD_TO_WAB	355528
#define IDH_OPTIONS_SECURITY_ADV_REVOKE_ONLINE	355529
#define IDH_OPTIONS_SECURITY_ADV_REVOKE_NEVER	355531

//Dialup tab, Tools/Options menu
#define IDH_OPTIONS_DIALUP_DONT_CONNECT         25252570
#define IDH_OPTIONS_DIALUP_CONNECTION_NUMBER    25252575
#define IDH_OPTIONS_DIALUP_ASK                  25252580
#define IDH_OPTIONS_DIALUP_WARN_BEFORE_SWITCHING 25252585
#define IDH_OPTIONS_DIALUP_HANG_UP              25252590
#define IDH_OPTIONS_DIALUP_AUTODIAL             25252595
#define IDH_OPTIONS_DIALUP_CHANGE             	25252596

//Advanced tab, Tools/Options menu
#define IDH_DELETE_AFTER_XXDAYS                 353740
#define IDH_DELETE_READ                         353745
#define IDH_COMPACT_WHEN_WASTED                 353750
#define IDH_CLEAN_UP_BUTTON                     353755
#define IDH_OPTIONS_NEWS_TRANSPORT              355560
#define IDH_OPTIONS_MAIL_TRANSPORT              355565
#define IDH_OPTIONS_HTTPLOG			355567
#define IDH_OPTIONS_OFFLINE_LOG                 355570
#define IDH_OPTIONS_IMAP_TRANSPORT              355575
#define IDH_ADVANCED_STORE_FOLDER               355576

////Send tab
#define IDH_NEWS_SEND_SAVE_COPY                 353526
#define IDH_NEWS_SEND_AUTO_WORD_SELECT          353527
#define IDH_NEWS_SEND_MESS_IN_REPLY             353528
#define IDH_NEWS_SEND_INDENT_WITH               353529
#define IDH_NEWS_SEND_ADV_SETTINGS              353530
#define IDH_NEWS_SEND_SAVE_COPY_SENT_ITEMS      353531
#define IDH_NEWS_MAILSEND_ADV_SETTINGS          353533
#define IDH_OPTIONS_SEND_SETTINGS_SEND_PICTURE  35660
#define IDH_MAIL_SEND_CHECK_ADDRESS		502065
#define IDH_OPT_SEND_INDENT_REPLY		502066
#define IDH_OPT_SEND_INDENT_WITH_X		502067


////Send tab (Mail)
#define IDH_MAIL_SEND_SAVE_COPY                 25252512
#define IDH_MAIL_SEND_IM_DEFAULT                25252516


//////Send tab, Advanced Settings 
#define IDH_NEWSMAIL_SEND_ADVSET_CHARSET        353534
#define IDH_NEWSMAIL_SEND_ADVSET_MIME           353535
#define IDH_NEWSMAIL_SEND_ADVSET_UUENCODE       353536
#define IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR   353538
#define IDH_NEWSMAIL_SEND_ADVSET_SEND_IMMED     353539
#define IDH_NEWSMAIL_SEND_ADVSET_ENCODE_WITH    353540


////Fonts tab
#define IDH_NEWS_FONTS_REPLY_SAMPLE             353557
#define IDH_NEWS_FONTS_FORMATS_NOT_INCLUDED     353558
#define IDH_NEWS_FONTS_IN_QUOTED                353559
#define IDH_NEWS_CHANGE                         353560


///Signature tab
#define IDH_NEWS_SIGNATURE_NONE                 353566
#define IDH_NEWS_SIGNATURE_TEXT                 353567
#define IDH_NEWS_SIGNATURE_FILE                 353568
#define IDH_NEWS_SIGNATURE_ADD_TO_ALL           353569
#define IDH_NEWS_SIGNATURE_NOT_REPLIES          353609
#define IDH_STATIONERY_NEW_SIGNATURE		35591
#define IDH_STATIONERY_REMOVE_SIGNATURE		35592
#define IDH_STATIONERY_RENAME_SIGNATURE		35593
#define IDH_STATIONERY_SIGNATURE_LIST		35594
#define IDH_STATIONERY_MAKE_DEFAULT_SIG		35596
#define IDH_STATIONERY_SIG_ADVANCED		35597


//Spelling dialog box
#define IDH_NEWS_SPELL_NOT_IN_DICT              353583
#define IDH_NEWS_SPELL_CHANGE_TO                353584
#define IDH_NEWS_SPELL_SUGGESTIONS              353585
#define IDH_NEWS_SPELL_OPTIONS                  353586
#define IDH_NEWS_SPELL_UNDO_LAST                353587
#define IDH_NEWS_SPELL_IGNORE                   353588
#define IDH_NEWS_SPELL_CHANGE                   353589
#define IDH_NEWS_SPELL_ADD                      353590
#define IDH_NEWS_SPELL_CANCEL                   353591
#define IDH_NEWS_SPELL_IGNORE_ALL               353592
#define IDH_NEWS_SPELL_CHANGE_ALL               353593
#define IDH_NEWS_SPELL_SUGGEST                  353594

//customize tool bar procedure for Help button in dlg
//#define IDH_PROCED_CUST_TOOL                    353700

//New ids
#define IDH_SEND_HTML                           353705
#define IDH_SEND_PLAINTEXT                      353710
#define IDH_SEND_SETTINGS                       353715
#define IDH_SEND_SETTINGS_HTML			353718
#define IDH_START_IN_LAST_NEWSGROUP             353720
#define IDH_SEND_SETTING_8BIT_HEADINGS          353725


//Mark Newsgroups dlg
#define IDH_NEWS_DWNLOAD_GET_ALL                354007  //All subscribed newsgroups
#define IDH_NEWS_DWNLOAD_GET_SELECTED           354008  //selected newsgroups
#define IDH_NEWS_DWNLOAD_GET_SELECTED_LIST      354009  //newsgroups list
#define IDH_NEWS_DWNLOAD_HEADERS                354010  //download headers only
#define IDH_NEWS_DWNLOAD_ENTIRE                 354011  //download entire message
#define IDH_NEWS_DWNLOAD_DONT_OLD_POSTS         354012  //Don't download new messages more than xx
#define IDH_NEWS_DWNLOAD_NOW_BUTTON             354013  //Download now button

//Format Font dialog box
#define IDH_FORMAT_FONT_FONT                    35420
#define IDH_FORMAT_FONT_FONTSTYLE               35425
#define IDH_FORMAT_FONT_SIZE                    35430
#define IDH_FORMAT_FONT_SAMPLE                  35435
#define IDH_FORMAT_FONT_COLOR                   35440
#define IDH_FORMAT_FONT_UNDERLINE               35445 
#define IDH_FORMAT_FONT_PALETTE               	35446

//Insert Picture (image) dialog box
#define IDH_INSERT_PICTURE_IMAGESOURCE          35450
#define IDH_INSERT_PICTURE_ALT_TEXT             35455
#define IDH_INSERT_PICTURE_LAYOUT               35460
#define IDH_INSERT_PICTURE_BROWSE               35462

#define IDH_INSERT_PICTURE_ALIGNMENT            35465
#define IDH_INSERT_PICTURE_BORDER               35470
#define IDH_INSERT_PICTURE_HSPACING             35475
#define IDH_INSERT_PICTURE_VSPACING             35480

//Insert Attachment dialog box
#define IDH_INSERT_ATTACHMENT_MAKE_SHORTCUT     35500

//Edit Link dialog box
#define IDH_INSERT_LINK_LINKINFO                35550

//Stationery dialog box, Tools menu
#define IDH_STATIONERY_FONT_SETTINGS            35560
#define IDH_STATIONERY_MY_FONT                  35565
#define IDH_STATIONERY_USE_STATIONERY           35570
#define IDH_STATIONERY_SELECT                   35575
#define IDH_STATIONERY_SIGNATURE                35580
#define IDH_STATIONERY_SAMPLE	                35585
#define IDH_STATIONERY_NAME	                35586
#define IDH_STATIONERY_USE_SELECTED             35587

//Signature dialog box, Tools/Stationery menu
#define IDH_STATIONERY_ADD_SIGNATURE            35590
#define IDH_STATIONERY_ADD_TEXT                 35595
#define IDH_STATIONERY_ADD_FILE                 35600
#define IDH_STATIONERY_BROWSE_FILES             35605
#define IDH_STATIONERY_DONT_ADD_SIGNATURE       35610
#define IDH_STATIONERY_INCLUDE_BUS_CARD		35611
#define IDH_STATIONERY_DISPLAY_BUS_CARD		35612
#define IDH_STATIONERY_NEW_BUSINESS_CARD        35615
#define IDH_STATIONERY_EDIT_BUSINESS_CARD       35620
#define IDH_STATIONERY_ATTACH_BUSINESS_CARD     35625
#define IDH_STATIONERY_ENTER_BUSINESS_CARD      35630
#define IDH_STATIONERY_CREATENEW		35632

//Select stationery dialog box, Tools/Stationery menu
#define IDH_STATIONERY_LISTBOX                  35635
#define IDH_STATIONERY_PREVIEW                  35640
#define IDH_STATIONERY_EDIT                     35645
#define IDH_STATIONERY_GET_MORE                 35650
#define IDH_STATIONERY_BROWSE_PICTURE           35655
#define IDH_STATIONERY_SHOW_PREVIEW           	35656

//Window Layout Properties (View/Layout menu)
#define  IDH_LAYOUT_OUTLOOK_BAR                 35700
#define  IDH_LAYOUT_CONTACTS                 	35702
#define  IDH_LAYOUT_STATUS_BAR                 	35704
#define  IDH_LAYOUT_TOOLBAR                 	35706
#define  IDH_LAYOUT_VIEWS_BAR                 	35708
#define  IDH_LAYOUT_FOLDER_LIST                 35710
#define  IDH_LAYOUT_INFO_PANE                 	35712
#define  IDH_LAYOUT_FOLDER_BAR                  35715
#define  IDH_LAYOUT_TIP_OF_DAY                  35720
#define  IDH_LAYOUT_TOOLBAR_MOVE                35725
#define  IDH_LAYOUT_SHOW_TEXT                   35730
#define  IDH_LAYOUT_CUSTOMIZE_BUTTONS           35735
#define  IDH_LAYOUT_PREVIEW_PANE                35740
#define  IDH_LAYOUT_PREVIEW_PANE_MOVE           35745
#define  IDH_LAYOUT_SHOW_HEADERS                35750

//Format Background Sound/Picture
#define IDH_BACKGR_FILE				50180
#define IDH_BACKGR_BROWSE			50185
#define IDH_BACKGR_SOUND_PLAY_X_TIMES		50190
#define IDH_BACKGR_SOUND_PLAY_CONTINUOUS	50195

//Misc
#define IDH_FORMAT_PARA_ALIGN			50200
#define IDH_FORMAT_PARA_BULLETS			50205
#define IDH_MAIL_NEW_USING_WEB			50210
#define IDH_MAILNEWS_BLOCK_SENDER_ADDRESS	50215
#define IDH_MAILNEWS_BLOCK_SENDER_BLOCKTYPE	50220

//Edit menu, Find options
#define IDH_FIND_TEXT				50300
#define IDH_FIND_NEXT				50305
#define IDH_FIND_IN_DOWNLOADED			50310
#define IDH_FIND_ADVANCED			50315

//Tools menu, IMAP folders
#define IDH_IMAP_SERVER_LIST			50500
#define IDH_IMAP_DISPLAY_FOLDERS_CONTAINING	50505
#define IDH_IMAP_FOLDER_LIST			50510
#define IDH_IMAP_OPEN_SELECTED_FOLDER		50515
#define IDH_IMAP_SHOW_SELECTED_FOLDER		50520
#define IDH_IMAP_HIDE_SELECTED_FOLDER		50525
#define IDH_IMAP_RESET_LIST			50530

//View menu, Current View / Customize Current View
#define IDH_VIEW_CUSTOM_CONDITIONS		50600
#define IDH_VIEW_CUSTOM_DESCRIPTION		50605
#define IDH_VIEW_CUSTOM_NAME			50610

//Tools/Message Rules/Mail Rules tab and News Rule Tab
#define IDH_RULES_NEW				50700
#define IDH_RULES_MODIFY			50705
#define IDH_RULES_COPY				50710
#define IDH_RULES_REMOVE			50715
#define IDH_RULES_APPLYNOW			50720
#define IDH_RULES_MOVEUP			50725
#define IDH_RULES_MOVEDOWN			50730
#define IDH_RULES_DESCRIPTION			50735

//Tools/Message Rules/Mail Rules or News Rules/New (Mail or News) Rules and Edit (maile or News) Rules
#define IDH_NEWRULE_CONDITION			50740
#define IDH_NEWRULE_ACTION			50745
#define IDH_NEWRULE_DESCRIPTION			50750
#define IDH_NEWRULE_NAME			50755

//Tools/Messatge Rules/Mail or News tabs/Apply now
#define IDH_APPLYRULES_SELECT			50760
#define IDH_APPLYRULES_SELECTALL		50765
#define IDH_APPLYRULES_SELECTNONE		50770
#define IDH_APPLYRULES_DESCRIPTION		50775
#define IDH_APPLYRULES_FOLDER			50780
#define IDH_APPLYRULES_SUBFOLDERS		50785
#define IDH_APPLYRULES_BROWSE			50790
#define IDH_APPLYRULES_APPLYNOW			50795

//Tools/Message Rules/June Mail tab
#define IDH_JUNKMAIL_DETECT			50800
#define IDH_JUNKMAIL_EXCEPTIONS			50805
#define IDH_JUNKMAIL_ADJUST			50810
#define IDH_JUNKMAIL_DELETE			50815

//Tools/Message Rules/Blocked Senders tab
#define IDH_BLOCKSENDERS_ADD			50820
#define IDH_BLOCKSENDERS_MODIFY			50825
#define IDH_BLOCKSENDERS_REMOVE			50830

//View/Current View/Customize current view and 
//View/Current View/Define Views/New and Modify
#define IDH_VIEW_CONDITIONS			50840
#define IDH_VIEW_DESCRIPTION			50845
#define IDH_VIEW_NAME				50850

//View/Current View/Define Views
#define IDH_DEFINEVIEWS_NEW			50860
#define IDH_DEFINEVIEWS_MODIFY			50865
#define IDH_DEFINEVIEWS_COPY			50870
#define IDH_DEFINEVEIWS_REMOVE			50875
#define IDH_DEFINEVIEWS_APPLY			50880
#define IDH_DEFINEVIEWS_DESCRIPTION		50885

//Tools/Options/Send/International setings
#define IDH_INTL_SETTINGS_DEFAULT_ENCODING	50910
#define IDH_INTL_SETTINGS_RTL                   50912
#define IDH_INTL_SETTINGS_HEADER_SETTINGS	50915

//Receipts Tab, Tools/Options menu
#define IDH_RECEIPTS_REQUEST			50260
#define IDH_RECEIPTS_NEVER			50266
#define IDH_RECEIPTS_ASK			50270
#define IDH_RECEIPTS_ALWAYS			50275
#define IDH_RECEIPTS_EXCEPTIONS			50280
#define IDH_RECEIPTS_SECURE			50285

//Secure Receipt Options dialog box, Tools/Options/Receipts menu
#define IDH_SECURERECEIPTS_REQUEST		50230
#define IDH_SECURERECEIPTS_NEVER		50235
#define IDH_SECURERECEIPTS_ASK			50240
#define IDH_SECURERECEIPTS_ALWAYS		50245
#define IDH_SECURERECEIPTS_ENCRYPT		50250
#define IDH_SECURERECEIPTS_VERIFY		50255

// Virus protection help
#define IDH_MAIL_VIRUS_TO               		70000
#define IDH_MAIL_VIRUS_SUBJECT               	70001
#define IDH_MAIL_VIRUS_SEND               		70002
#define IDH_MAIL_VIRUS_DONT_SEND               	70003
#define IDH_MAIL_VIRUS_HELP_BUTTON              70004
#define IDH_MAIL_VIRUS_HELP_TEXT               	70005

//Online tab of WAB properties
#define IDH_WAB_ONLINE_ADDNEW               96969740
#define IDH_WAB_ONLINE_ADD                  96969742
#define IDH_WAB_ONLINE_SETAS                96969744
#define IDH_WAB_ONLINE_SENDIM               96969746
#define IDH_WAB_ONLINE_LIST                 96969748
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\fechrcnv\unix2pc.c ===
// File Name:   unix2pc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

int FE_UNIX_to_PC (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                           UCHAR *pUNIXChar, int UNIXChar_len,
                           UCHAR *pPCChar, int PCChar_len )

// The FE_UNIX_to_PC function convert a character string as Japanese UNIX code 
// set string to a PC code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
{
    int   re;
#ifdef DBCS_DIVIDE
    int   i = 0, nDelta = 0;



    if ( PCChar_len == 0 && pcontext->dStatus0.nCodeSet != CODE_UNKNOWN)
        CodeSet = pcontext->dStatus0.nCodeSet;
    else if ( PCChar_len != 0 && pcontext->dStatus.nCodeSet != CODE_UNKNOWN )
        CodeSet = pcontext->dStatus.nCodeSet;
    else
#endif

    if ( pcontext->nCurrentCodeSet == CODE_UNKNOWN ) {
        if ( CodeSet == CODE_UNKNOWN ) {
            if ( ( CodeSet = DetectJPNCode ( pUNIXChar, UNIXChar_len ) )
                                           == CODE_ONLY_SBCS ) {
                CodeSet = CODE_JPN_JIS;
            }
        }
        pcontext->nCurrentCodeSet = CodeSet;
    } 
    else
        CodeSet = pcontext->nCurrentCodeSet;

    switch ( CodeSet ) {
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from JIS to Shift JIS
            re = JIS_to_ShiftJIS (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from EUC to Shift JIS
            re = EUC_to_ShiftJIS (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_KRN_KSC:    // Korean KSC
            // Convert from KSC to Hangeul
            re = KSC_to_Hangeul (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_PRC_HZGB:   // PRC HZ-GB
            // Convert from HZ-GB to GB2312
            re = HZGB_to_GB2312 (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
        case CODE_ONLY_SBCS:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;

        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
        case CODE_KRN_UHC:     // Korean UHC
        case CODE_PRC_CNGB:    // PRC CN-GB
        case CODE_TWN_BIG5:    // Taiwanese BIG5
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
#ifdef DBCS_DIVIDE
                UCHAR *pPCCharEnd = pPCChar + PCChar_len - 1;
                if ( pcontext->dStatus.nCodeSet == CODE_JPN_SJIS && pcontext->dStatus.cSavedByte){
                    *pPCChar++ = pcontext->dStatus.cSavedByte;
                    *pPCChar = *pUNIXChar;
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    pcontext->dStatus.nCodeSet = CODE_UNKNOWN;
                    pcontext->dStatus.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByteEx(CodePage, *(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            pcontext->dStatus.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            pcontext->dStatus.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus.cSavedByte = *(pUNIXChar + i);
                            *(pPCChar + i) = '\0';
                            --UNIXChar_len;
                            break;
                        }
                        if(pPCChar + i > pPCCharEnd)  // check destination buf
                            break;
                        *(pPCChar + i++) = *(pUNIXChar + i);
                        *(pPCChar + i++) = *(pUNIXChar + i);
                    } else
                        *(pPCChar + i++) = *(pUNIXChar + i);
                }
#else
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
#endif
            }
#ifdef DBCS_DIVIDE
            else {   // Only retrun the required size
                if ( pcontext->dStatus0.nCodeSet == CODE_JPN_SJIS ){ // 1st byte was saved
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    pcontext->dStatus0.nCodeSet = CODE_UNKNOWN;
                    pcontext->dStatus0.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByteEx(CodePage, *(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            pcontext->dStatus0.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            pcontext->dStatus0.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        }
                        i+=2;
                    } else
                        i++;
                }
            }
#endif
            re = UNIXChar_len;
            break;
    }
    return ( re );
}




int WINAPI UNIX_to_PC (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                        UCHAR *pUNIXChar, int UNIXChar_len,
                        UCHAR *pPCChar, int PCChar_len )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        // we have to run on the given context to be multi-thread safe.
        if(!pcontext) return 0;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
        case 950:    // Taiwan Code Page
        case 949:    // Korea Code Page
        case 936:    // PRC Code Page
            re = FE_UNIX_to_PC (pcontext, CodePage, CodeSet, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\http\httputil.cpp ===
/*
 *  h t t p u t i l. c p p
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Utility functions used to implement http mail.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "httputil.h"
#include "xpcomm.h"
#include "iso8601.h"
#include "storutil.h"
#include "flagconv.h"
#include "demand.h"

//----------------------------------------------------------------------
// Http_FreeTargetList
//----------------------------------------------------------------------
void Http_FreeTargetList(LPHTTPTARGETLIST pTargets)
{
    if (pTargets)
    {
        if (pTargets->prgTarget)
        {
            for (DWORD dw = 0; dw < pTargets->cTarget; dw++)
            {
                if (pTargets->prgTarget[dw])
                    MemFree(const_cast<char *>(pTargets->prgTarget[dw]));
            }
            
            MemFree(pTargets->prgTarget);
        }
        
        MemFree(pTargets);
    }
}

//----------------------------------------------------------------------
// Http_NameFromUrl
//----------------------------------------------------------------------
HRESULT Http_NameFromUrl(LPCSTR pszUrl, LPSTR pszBuffer, DWORD *pdwBufferLen)
{
    HRESULT         hr = S_OK;
    char            szLocalBuf[MAX_PATH];
    URL_COMPONENTS  urlComponents;
    DWORD           dw = 0;

    ZeroMemory(&urlComponents, sizeof(URL_COMPONENTS));

    // use wininet to break the path out and to decode the url while
    // we're at it.
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.lpszUrlPath = szLocalBuf;
    urlComponents.dwUrlPathLength = MAX_PATH;

    if (!InternetCrackUrl(pszUrl, lstrlen(pszUrl), NOFLAGS /* ICU_DECODE */, &urlComponents))
    {
        hr = GetLastError();
        goto exit;
    }
    
    // subtract one to start at the char before the last one. this skips
    // the last char in the case of a folder that ends in '/'
    dw = urlComponents.dwUrlPathLength - 1;
    while (dw && ('/' != szLocalBuf[dw - 1]))
        dw--;

    // dw represents the count of chars that are NOT in the
    // name. reverse it.
    dw = urlComponents.dwUrlPathLength - dw;

    if (dw >= *pdwBufferLen)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    CopyMemory(pszBuffer, &szLocalBuf[urlComponents.dwUrlPathLength - dw], dw + 1);
    *pdwBufferLen = dw;

exit:
    return hr;
}

//----------------------------------------------------------------------
// Http_AddMessageToFolder
//----------------------------------------------------------------------
HRESULT Http_AddMessageToFolder(IMessageFolder *pFolder,
                                LPSTR pszAcctId,
                                LPHTTPMEMBERINFO pmi,
                                MESSAGEFLAGS dwFlags,
                                LPSTR pszUrl,
                                LPMESSAGEID pidMessage)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     mi;
    FILETIME        ft;
    DWORD           dwTimeFlags = NOFLAGS;
    LPSTR           pszFreeFrom = NULL;
    LPSTR           pszFreeTo = NULL;
    ADDRESSLIST     addrList;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    PROPVARIANT     rDecodedSubj;
    PROPVARIANT     rDecodedFrom;
    PROPVARIANT     rDecodedTo;
    LPSTR           pszSubject = NULL;

    if (NULL == pszUrl)
        return E_INVALIDARG;

    ZeroMemory(&mi, sizeof(MESSAGEINFO));

    rDecodedSubj.vt = rDecodedFrom.vt = rDecodedTo.vt = VT_LPSTR;
    rDecodedSubj.pszVal = rDecodedFrom.pszVal = rDecodedTo.pszVal = NULL;

    // build a message info and pump the header into the store
    mi.pszAcctId = pszAcctId;

    // get the store to generate an id
    if (FAILED(hr = pFolder->GenerateId((DWORD *)&mi.idMessage)))
        goto exit;

    if (NULL != pidMessage)
        *pidMessage = mi.idMessage;

    if (FAILED(hr = Http_NameFromUrl(pszUrl, szUrlComponent, &dwUrlComponentLen)))
        goto exit;

    mi.dwFlags |= dwFlags;

    // if a message info was passed in, use its data
    if (NULL != pmi)
    {
        mi.cbMessage = pmi->dwContentLength;

        if (pmi->fRead)
            mi.dwFlags = ARF_READ;

        if (pmi->fHasAttachment)
            mi.dwFlags |= ARF_HASATTACH;

        if (NULL != pmi->pszSubject)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszSubject, &rDecodedSubj, NULL)))
                pszSubject = rDecodedSubj.pszVal;
            else
                pszSubject = pmi->pszSubject;
            
            mi.pszSubject = pszSubject;
            mi.pszNormalSubj = SzNormalizeSubject(pszSubject);
            if (NULL == mi.pszNormalSubj)
                mi.pszNormalSubj = pszSubject;
        }

        if (pmi->pszFrom && S_OK == MimeOleParseRfc822Address(IAT_FROM, IET_ENCODED, pmi->pszFrom, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pszFreeFrom = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;

                // only use the parsed address if it is at least three chars long
                if (pszFreeFrom && lstrlen(pszFreeFrom) >= 3)
                    mi.pszDisplayFrom = pszFreeFrom;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        if (NULL == mi.pszDisplayFrom && NULL != pmi->pszFrom)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszFrom, &rDecodedFrom, NULL)))
                mi.pszDisplayFrom = rDecodedFrom.pszVal;
            else
                mi.pszDisplayFrom = pmi->pszFrom;
        }

        if (SUCCEEDED(iso8601::toFileTime(pmi->pszDate, &ft, &dwTimeFlags)))
        {
            if (!(dwTimeFlags & ISO8601_ST_HOUR))
                mi.dwFlags |= ARF_PARTIAL_RECVTIME;
            mi.ftReceived = ft;
        }
        
        if (pmi->pszTo && S_OK == MimeOleParseRfc822Address(IAT_TO, IET_ENCODED, pmi->pszTo, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pszFreeTo = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;

                // only use the parsed address if it is at least three chars long
                if (pszFreeTo && lstrlen(pszFreeTo) >= 3)
                    mi.pszDisplayTo = pszFreeTo;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        if (NULL == mi.pszDisplayTo && NULL != pmi->pszTo)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszTo, &rDecodedTo, NULL)))
                mi.pszDisplayTo = rDecodedTo.pszVal;
            else
                mi.pszDisplayTo = pmi->pszTo;
        }
    }

    mi.pszUrlComponent = szUrlComponent;

    // Add it to the database
    IF_FAILEXIT(hr = pFolder->InsertRecord(&mi));

    // normalize the response
    hr = S_OK;

exit:
    SafeMimeOleFree(rDecodedSubj.pszVal);
    SafeMimeOleFree(rDecodedFrom.pszVal);
    SafeMimeOleFree(rDecodedTo.pszVal);

    SafeMemFree(pszFreeFrom);
    SafeMemFree(pszFreeTo);

    return hr;
}

//----------------------------------------------------------------------
// Http_SetMessageStream
//----------------------------------------------------------------------
HRESULT Http_SetMessageStream(IMessageFolder *pFolder, 
                              MESSAGEID idMessage, 
                              IStream *pStream,
                              LPFILEADDRESS pfa,
                              BOOL fSetDisplayProps)
{
    HRESULT             hr = S_OK;
    IMimeMessage        *pMimeMsg = NULL;
    IMimePropertySet    *pPropertySet = NULL;
    DWORD               dwFlags = 0;
    MESSAGEINFO         mi = {0};
    LPMESSAGEINFO       pmiFree = NULL;
    FILETIME            ftCurrent;
    PROPVARIANT         rVariant;
    IMimeAddressTable   *pAdrTable = NULL;
    ADDRESSPROPS        rAddress = {0};

    LPSTR               pszDisplayFrom = NULL;
    LPSTR               pszEmailFrom = NULL;
    LPSTR               pszDisplayTo = NULL;
    LPSTR               pszEmailTo = NULL;
    LPSTR               pszMessageId = NULL;
    LPSTR               pszXref = NULL;
    LPSTR               pszReferences = NULL;
    LPSTR               pszSubject = NULL;
    LPSTR               pszNormalSubj = NULL;
    LPSTR               pszAcctId = NULL;
    LPSTR               pszAcctName = NULL;
    LPSTR               pszServer = NULL;
    LPSTR               pszForwardTo = NULL;
    LPSTR               pszMSOESRec = NULL;

    // Default Sent and Received Times...
    GetSystemTimeAsFileTime(&ftCurrent);

    // Create a Message. We can't use the folder's OpenMessage
    // method, because the folder's stream will be locked for write
    // access.
    IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMimeMsg));

    IF_FAILEXIT(hr = HrRewindStream(pStream));

    IF_FAILEXIT(hr = pMimeMsg->Load(pStream));

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMimeMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // find the message in the store
    IF_FAILEXIT(hr = GetMessageInfo(pFolder, idMessage, &mi));

    pmiFree = &mi;

    // update the fields of the message info
    if (SUCCEEDED(pMimeMsg->GetFlags(&dwFlags)))
        mi.dwFlags |= ConvertIMFFlagsToARF(dwFlags);

    // unset the download flag
    mi.dwFlags &= ~ARF_DOWNLOAD;

    // Set Variant tyStore
    rVariant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
        mi.wPriority = (WORD)rVariant.ulVal;

    // Init Variant
    rVariant.vt = VT_FILETIME;

    if (0 == mi.ftSent.dwLowDateTime && 0 == mi.ftSent.dwHighDateTime)
    {
        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant)))
            mi.ftSent = rVariant.filetime;
        else
            mi.ftSent = ftCurrent;
    }

    if (0 == mi.ftReceived.dwLowDateTime && 0 == mi.ftReceived.dwHighDateTime)
    {
        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
            mi.ftReceived = rVariant.filetime;
        else
            mi.ftReceived = ftCurrent;
    }
    
    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    if (fSetDisplayProps && NULL == mi.pszDisplayFrom)
    {
        pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pszDisplayFrom);
        mi.pszDisplayFrom = pszDisplayFrom;
    }

    // Email From
    rAddress.dwProps = IAP_EMAIL;
    if (NULL == mi.pszEmailFrom && SUCCEEDED(pAdrTable->GetSender(&rAddress)))
    {
        pszEmailFrom = rAddress.pszEmail;
        mi.pszEmailFrom = pszEmailFrom;
    }

    // Display to
    if (fSetDisplayProps && NULL == mi.pszDisplayTo)
    {
        pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pszDisplayTo);
        mi.pszDisplayTo = pszDisplayTo;
    }

    // Email To
    if (NULL == mi.pszEmailTo)
    {
        pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &pszEmailTo);
        mi.pszEmailTo = pszEmailTo;
    }

    // String properties
    rVariant.vt = VT_LPSTR;

    // pszMessageId
    if (NULL == mi.pszMessageId && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &rVariant)))
    {
        pszMessageId = rVariant.pszVal;
        mi.pszMessageId = pszMessageId;
    }

    // pszXref
    if (NULL == mi.pszXref && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &rVariant)))
    {
        pszXref = rVariant.pszVal;
        mi.pszXref = pszXref;
    }

    // pszReferences
    if (NULL == mi.pszReferences && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &rVariant)))
    {
        pszReferences = rVariant.pszVal;
        mi.pszReferences = pszReferences;
    }

    // pszSubject
    if (NULL == mi.pszSubject && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &rVariant)))
    {
        pszSubject = rVariant.pszVal;
        mi.pszSubject = pszSubject;
    }

    // pszNormalSubj
    if (fSetDisplayProps && NULL == mi.pszNormalSubj && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &rVariant)))
    {
        pszNormalSubj = rVariant.pszVal;
        mi.pszNormalSubj = pszNormalSubj;
    }

    // pszAcctId
    if (NULL == mi.pszAcctId && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rVariant)))
    {
        pszAcctId = rVariant.pszVal;
        mi.pszAcctId = pszAcctId;
    }

    // pszAcctName
    if (NULL == mi.pszAcctName && SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &rVariant)))
    {
        pszAcctName = rVariant.pszVal;
        mi.pszAcctName = pszAcctName;
    }

    // pszServer
    if (NULL == mi.pszServer && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &rVariant)))
    {
        pszServer = rVariant.pszVal;
        mi.pszServer = pszServer;
    }

    // ForwardTo
    if (NULL == mi.pszForwardTo && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &rVariant)))
    {
        pszForwardTo = rVariant.pszVal;
        mi.pszForwardTo = pszForwardTo;
    }

    if (NULL == mi.pszMSOESRec && SUCCEEDED(pPropertySet->GetProp(STR_HDR_XMSOESREC, NOFLAGS, &rVariant)))
    {
        pszMSOESRec = rVariant.pszVal;
        mi.pszMSOESRec = pszMSOESRec;
    }

    IF_FAILEXIT(hr = pFolder->UpdateRecord(&mi));

    // if everything succeeded, commit the message to the store
    IF_FAILEXIT(hr = pFolder->SetMessageStream(idMessage, pStream));

    // the stream has now been used. null out the file address
    if (NULL != pfa)
        *pfa = NULL;

exit:
    MemFree(pszDisplayFrom);
    MemFree(pszEmailFrom);
    MemFree(pszDisplayTo);
    MemFree(pszEmailTo);
    MemFree(pszMessageId);
    MemFree(pszXref);
    MemFree(pszReferences);
    MemFree(pszSubject);
    MemFree(pszNormalSubj);
    MemFree(pszAcctId);
    MemFree(pszAcctName);
    MemFree(pszServer);
    MemFree(pszForwardTo);
    MemFree(pszMSOESRec);

    SafeRelease(pMimeMsg);
    SafeRelease(pPropertySet);
    if (pmiFree)
        pFolder->FreeRecord(pmiFree);
    SafeRelease(pAdrTable);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\imap\imapsync.h ===
//***************************************************************************
// IMAP4 Message Sync Header File (CIMAPSync)
// Written by Raymond Cheng, 5/5/98
//***************************************************************************


#ifndef __IMAPSync_H
#define __IMAPSync_H

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "taskutil.h"


//---------------------------------------------------------------------------
// Data Types
//---------------------------------------------------------------------------
enum IMAP_SERVERSTATE 
{
    issNotConnected,
    issNonAuthenticated,
    issAuthenticated,
    issSelected
};


enum CONN_FSM_EVENT {
    CFSM_EVENT_INITIALIZE,
    CFSM_EVENT_CMDAVAIL,
    CFSM_EVENT_CONNCOMPLETE,
    CFSM_EVENT_SELECTCOMPLETE,
    CFSM_EVENT_HDRSYNCCOMPLETE,
    CFSM_EVENT_OPERATIONSTARTED,
    CFSM_EVENT_OPERATIONCOMPLETE,
    CFSM_EVENT_ERROR,
    CFSM_EVENT_CANCEL,
    CFSM_EVENT_MAX
}; // CONN_FSM_EVENT

// Keep CONN_FSM_STATE in sync with c_pConnFSMEventHandlers
enum CONN_FSM_STATE {
    CFSM_STATE_IDLE,
    CFSM_STATE_WAITFORCONN,
    CFSM_STATE_WAITFORSELECT,
    CFSM_STATE_WAITFORHDRSYNC,
    CFSM_STATE_STARTOPERATION,
    CFSM_STATE_WAITFOROPERATIONDONE,
    CFSM_STATE_OPERATIONCOMPLETE,
    CFSM_STATE_MAX
}; // CONN_FSM_STATE

    
//---------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------
const char INVALID_HIERARCHY_CHAR = (char) 0xFF;


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
class CIMAPSyncCB;
class CRenameFolderInfo;


//---------------------------------------------------------------------------
// IMAPSync Util Function Prototypes
//---------------------------------------------------------------------------
HRESULT CreateImapStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);


//---------------------------------------------------------------------------
// CIMAPSync Class Declaration
//---------------------------------------------------------------------------
class CIMAPSync : 
    public IMessageServer,
    public IIMAPCallback, 
    public ITransportCallbackService,
    public IOperationCancel,
    public IIMAPStore
{
public:
    // Constructor, Destructor
    CIMAPSync();
    ~CIMAPSync();

    // IUnknown Members
    STDMETHODIMP            QueryInterface(REFIID iid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IStoreSync Methods
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback);
    STDMETHODIMP PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDestFldr, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore(FOLDERID idParent, DWORD dwFlags,IStoreCallback *pCallback);
    STDMETHODIMP CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew,IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID id, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; };
    STDMETHODIMP GetMinPollingInterval(IStoreCallback *pCallback) { return E_NOTIMPL; };

    // ITransportCallbackService
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);
    HRESULT STDMETHODCALLTYPE GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount);

    // ITransportCallback Members
    HRESULT STDMETHODCALLTYPE OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    INT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnStatus(IXPSTATUS ixpStatus, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnError(IXPSTATUS ixpStatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);

    // IIMAPCallback Functions
    HRESULT STDMETHODCALLTYPE OnResponse(const IMAP_RESPONSE *pirIMAPResponse);

    // IOperationCancel
    HRESULT STDMETHODCALLTYPE Cancel(CANCELTYPE tyCancel);

    // IIMAPStore
    HRESULT STDMETHODCALLTYPE ExpungeOnExit(void);


private:
    //---------------------------------------------------------------------------
    // Module Data Types
    //---------------------------------------------------------------------------
    enum IMAP_COMMAND 
    {
        icNO_COMMAND, // This indicates there are no cmds currently in progress
        icLOGIN_COMMAND,
        icCAPABILITY_COMMAND,
        icSELECT_COMMAND,
        icEXAMINE_COMMAND,
        icCREATE_COMMAND,
        icDELETE_COMMAND,
        icRENAME_COMMAND,
        icSUBSCRIBE_COMMAND,
        icUNSUBSCRIBE_COMMAND,
        icLIST_COMMAND,
        icLSUB_COMMAND,
        icAPPEND_COMMAND,
        icCLOSE_COMMAND,
        icEXPUNGE_COMMAND,
        icSEARCH_COMMAND,
        icFETCH_COMMAND,
        icSTORE_COMMAND,
        icCOPY_COMMAND,
        icLOGOUT_COMMAND,
        icNOOP_COMMAND,
        icAUTHENTICATE_COMMAND,
        icSTATUS_COMMAND,
        icALL_COMMANDS
    }; // IMAP_COMMAND


    enum READWRITE_STATUS 
    {
        rwsUNINITIALIZED,
        rwsREAD_WRITE,
        rwsREAD_ONLY
    }; // READWRITE_STATUS

    typedef struct tagIMAP_OPERATION 
    {
        WPARAM                      wParam;
        LPARAM                      lParam;
        IMAP_COMMAND                icCommandID;
        LPSTR                       pszCmdArgs;
        UINT                        uiPriority;
        IMAP_SERVERSTATE            issMinimum;
        struct tagIMAP_OPERATION   *pioNextCommand;
    } IMAP_OPERATION;

    typedef struct tagMARK_MSGS_INFO 
    {
        LPMESSAGEIDLIST     pList;
        ADJUSTFLAGS         afFlags;
        IRangeList         *pMsgRange;
        STOREOPERATIONTYPE  sotOpType;
    } MARK_MSGS_INFO;

    typedef struct tagIMAP_COPYMOVE_INFO 
    {
        COPYMESSAGEFLAGS    dwOptions;
        LPMESSAGEIDLIST     pList;
        IRangeList         *pCopyRange;
        FOLDERID            idDestFldr;
    } IMAP_COPYMOVE_INFO;

    // This structure makes me want to shower. It is used to pass info to
    // SendNextOperation, so I don't have to change its interface
    typedef struct tagAPPEND_SEND_INFO 
    {
        LPSTR           pszMsgFlags;
        FILETIME        ftReceived;
        LPSTREAM        lpstmMsg;
    } APPEND_SEND_INFO;


    enum HierCharFind_Stage 
    {
        hcfPLAN_A = 0,
        hcfPLAN_B,
        hcfPLAN_C
    };

    typedef struct tagHierarchyCharFinder 
    {
        HierCharFind_Stage  hcfStage;
        BOOL                fNonInboxNIL_Seen;
        BOOL                fDotHierarchyCharSeen;
        BYTE                bHierarchyCharBitArray[32];         // Bit-field array for 256 chars
        char                szTempFldrName[CCHMAX_STRINGRES];   // For use by Plan C (CREATE/LIST/DELETE)
    } HIERARCHY_CHAR_FINDER;

    // Used to tell FindHierarchicalFolderName what flags to set if folder is created
    typedef struct tagADD_HIER_FLDR_OPTIONS 
    {
        SPECIALFOLDER   sfType;
        FLDRFLAGS       ffFlagAdd;
        FLDRFLAGS       ffFlagRemove;
    } ADD_HIER_FLDR_OPTIONS;


    // Used to remember which folder we're dealing with during CREATE sequence
    // (CREATE, then LIST, then SUBSCRIBE). Also used when detecting existence
    // of special folders.

    enum CREATESF_STAGE 
    {
        CSF_INIT = 0,
        CSF_LIST,
        CSF_LSUBCREATE,
        CSF_CHECKSUB,
        CSF_NEXTFOLDER,
    };

    enum POSTCREATEOP
    {
        PCO_NONE = 0,
        PCO_FOLDERLIST,
        PCO_APPENDMSG,
    };

#define CFI_RECEIVEDLISTING 0x00000001 // Received LIST or LSUB response matching pszFullFolderPath
#define CFI_CREATEFAILURE   0x00000002 // CREATE failed with tagged NO so we attempted to list folder

    typedef struct tagCREATE_FOLDER_INFO 
    {
        LPSTR           pszFullFolderPath;
        FOLDERID        idFolder;               // Set after folder is created: allows us to subscribe fldr
        DWORD           dwFlags;                // Status flags like CFI_RECEIVEDLISTING
        DWORD           dwCurrentSfType;
        DWORD           dwFinalSfType;          // Used to allow us to create all special folders
        CREATESF_STAGE  csfCurrentStage;        // Used to allow us to create all special folders
        LPARAM          lParam;                 // Must carry around the lParam associated w/ fldr list
        POSTCREATEOP    pcoNextOp;              // Next operation to perform after folder creation
    } CREATE_FOLDER_INFO;


    typedef struct tagDELETE_FOLDER_INFO
    {
        LPSTR       pszFullFolderPath;
        char        cHierarchyChar;
        FOLDERID    idFolder;
    } DELETE_FOLDER_INFO;


    //---------------------------------------------------------------------------
    // Module Variables
    //---------------------------------------------------------------------------
    ULONG               m_cRef;
    IIMAPTransport2    *m_pTransport;
    INETSERVER          m_rInetServerInfo;
    FOLDERID            m_idFolder;
    FOLDERID            m_idSelectedFolder; // Currently selected fldr, DO NOT CONFUSE with m_idCurrent
    FOLDERID            m_idIMAPServer;
    LPSTR               m_pszAccountID;
    TCHAR               m_szAccountName[CCHMAX_ACCOUNT_NAME];
    LPSTR               m_pszFldrLeafName;
    IMessageStore      *m_pStore;
    IMessageFolder     *m_pFolder;
    IStoreCallback     *m_pDefCallback;

    IMAP_OPERATION     *m_pioNextOperation;

    // The following variables should be reset when we exit a folder
    DWORD               m_dwMsgCount;
    DWORD               m_dwNumNewMsgs;
    DWORD               m_dwNumHdrsDLed;
    DWORD               m_dwNumUnreadDLed;
    DWORD               m_dwNumHdrsToDL;
    DWORD               m_dwUIDValidity,
                        m_cFolders;
    DWORD               m_dwSyncFolderFlags;  // Copy of flags passed into SynchronizeFolder
    DWORD               m_dwSyncToDo;         // List of sync ops to do in current folder
    long                m_lSyncFolderRefCount; // Lets us know when to send CFSM_EVENT_HDRSYNCCOMPLETE
    DWORD_PTR           m_dwHighestCachedUID; // Highest cached UID when we processed SYNC_FOLDER_NEW_HEADERS
    READWRITE_STATUS    m_rwsReadWriteStatus;

    CONNECT_STATE       m_csNewConnState;
    IMAP_SERVERSTATE    m_issCurrent;

    TCHAR               m_cRootHierarchyChar; // For use during folder list (prefix creation) and GetFolderCounts
    HIERARCHY_CHAR_FINDER *m_phcfHierarchyCharInfo;

    char                m_szRootFolderPrefix[MAX_PATH];

    BOOL                m_fInited           :1,
                        m_fCreateSpecial    :1,
                        m_fPrefixExists     :1,
                        m_fMsgCountValid    :1,
                        m_fDisconnecting    :1,
                        m_fNewMail          :1,
                        m_fInbox            :1,
                        m_fDidFullSync      :1, // TRUE if full synchronization performed
                        m_fReconnect        :1, // TRUE to suppress operation abortion on IXP_DISCONNECTED
                        m_fTerminating      :1; // TRUE if current op is going to CFSM_STATE_OPERATIONCOMPLETE

    // Central repository to store data on the current operation
    STOREOPERATIONTYPE  m_sotCurrent;       // Current operation in progress
    IStoreCallback     *m_pCurrentCB;       // Callback for current operation in progress
    FOLDERID            m_idCurrent;        // FolderID for current operation, DO NOT CONFUSE with m_idSelectedFolder
    BOOL                m_fSubscribe;       // For SOT_SUBSCRIBE_FOLDER op, this indicates sub/unsub
    IHashTable         *m_pCurrentHash;     // List of folders cached locally
    IHashTable         *m_pListHash;        // List of folders returned via LIST response


    DWORD               m_dwThreadId;

    FILEADDRESS         m_faStream;
    LPSTREAM            m_pstmBody;
    MESSAGEID           m_idMessage;

    BOOL                m_fGotBody;

    // Connection FSM
    CONN_FSM_STATE      m_cfsState;
    CONN_FSM_STATE      m_cfsPrevState;
    HWND                m_hwndConnFSM;
    HRESULT             m_hrOperationResult;
    char                m_szOperationProblem[2*CCHMAX_STRINGRES];
    char                m_szOperationDetails[2*CCHMAX_STRINGRES];


    //---------------------------------------------------------------------------
    // Module Private Functions
    //---------------------------------------------------------------------------

    HRESULT PurgeMessageProgress(HWND hwndParent);
    HRESULT SetConnectionState(CONNECT_STATE tyConnect);

    HRESULT DownloadFoldersSequencer(const WPARAM wpTransactionID, const LPARAM lParam,
        HRESULT hrCompletionResult, const LPCSTR lpszResponseText, LPBOOL pfCompletion);
    HRESULT PostHCD(LPSTR pszErrorDescription, DWORD dwSizeOfErrorDescription,
        LPARAM lParam, LPBOOL pfCompletion);
    HRESULT CreatePrefix(LPSTR pszErrorDescription, DWORD dwSizeOfErrorDescription,
        LPARAM lParam, LPBOOL pfCompletion);
    void EndFolderList(void);

    HRESULT RenameSequencer(const WPARAM wpTransactionID, const LPARAM lParam,
        HRESULT hrCompletionResult, LPCSTR lpszResponseText, LPBOOL pfDone);
    inline BOOL EndOfRenameFolderPhaseOne(CRenameFolderInfo *pRenameInfo);
    inline BOOL EndOfRenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo);
    HRESULT RenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo,
        LPSTR szErrorDescription, DWORD dwSizeOfErrorDescription);

    void FlushOperationQueue(IMAP_SERVERSTATE issMaximum, HRESULT hrError);
    IMAP_SERVERSTATE IMAPCmdToMinISS(IMAP_COMMAND icCommandID);
    HRESULT GetNextOperation(IMAP_OPERATION **ppioOp);
    void DisposeOfWParamLParam(WPARAM wParam, LPARAM lParam, HRESULT hrResult);
    void NotifyMsgRecipients(DWORD_PTR dwUID, BOOL fCompletion,
        FETCH_BODY_PART *pFBPart, HRESULT hrCompletion, LPSTR pszDetails);
    void OnFolderExit(void);
    HRESULT _SelectFolder(FOLDERID idFolder);
    void LoadLeafFldrName(FOLDERID idFolder);

    void FillStoreError(LPSTOREERROR pErrorInfo, HRESULT hrResult,
        DWORD dwSocketError, LPSTR pszProblem, LPSTR pszDetails);
    HRESULT Fill_MESSAGEINFO(const FETCH_CMD_RESULTS_EX *pFetchResults,
        MESSAGEINFO *pMsgInfo);
    HRESULT ReadEnvelopeFields(MESSAGEINFO *pMsgInfo, const FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT ConcatIMAPAddresses(LPSTR *ppszDisplay, LPSTR *ppszEmailAddr, IMAPADDR *piaIMAPAddr);
    HRESULT ConstructIMAPEmailAddr(CByteStream &bstmOut, IMAPADDR *piaIMAPAddr);


    HRESULT CheckUIDValidity(void);
    HRESULT SyncDeletedMessages(void);

    HRESULT DeleteHashedFolders(IHashTable *pHash);
    HRESULT DeleteFolderFromCache(FOLDERID idFolder, BOOL fRecursive);
    HRESULT DeleteLeafFolder(FOLDERID *pidCurrent);
    BOOL IsValidIMAPMailbox(LPSTR pszMailboxName, char cHierarchyChar);
    HRESULT AddFolderToCache(LPSTR pszMailboxName, IMAP_MBOXFLAGS imfMboxFlags,
        char cHierarchyChar, DWORD dwAFTCFlags, FOLDERID *pFolderID,
        SPECIALFOLDER sfType);
    LPSTR RemovePrefixFromPath(LPSTR pszPrefix, LPSTR pszMailboxName,
        char cHierarchyChar, LPBOOL pfValidPrefix, SPECIALFOLDER *psfType);
    HRESULT FindHierarchicalFolderName(LPSTR lpszFolderPath, char cHierarchyChar,
        FOLDERID *phfTarget, ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo);
    HRESULT CreateFolderNode(FOLDERID idPrev, FOLDERID *pidCurrent,
        LPSTR pszCurrentFldrName, LPSTR pszNextFldrName, char cHierarchyChar,
        ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo);
    HRESULT SetTranslationMode(FOLDERID idFolderID);
    BOOL isUSASCIIOnly(LPCSTR pszFolderName);
    HRESULT CheckFolderNameValidity(LPCSTR pszName);

    HRESULT RenameFolderHelper(FOLDERID idFolder, LPSTR pszFolderPath,
        char cHierarchyChar, LPSTR pszNewFolderPath);
    HRESULT RenameTreeTraversal(WPARAM wpOperation, CRenameFolderInfo *pRenameInfo,
        BOOL fIncludeRenameFolder);
    HRESULT RenameTreeTraversalHelper(WPARAM wpOperation, CRenameFolderInfo *pRenameInfo,
        LPSTR pszCurrentFldrPath, DWORD dwLengthOfCurrentPath, BOOL fIncludeThisFolder,
        FOLDERINFO *pfiCurrentFldrInfo);
    HRESULT SubscribeSubtree(FOLDERID idFolder, BOOL fSubscribe);

    void FindRootHierarchyChar(BOOL fPlanA_Only, LPARAM lParam);
    void AnalyzeHierarchyCharInfo();
    void StopHierarchyCharSearch();
    HRESULT LoadSaveRootHierarchyChar(BOOL fSaveHC);

    HRESULT CreateNextSpecialFolder(CREATE_FOLDER_INFO *pcfiCreateInfo, LPBOOL pfCompletion);
    HRESULT _StartFolderList(LPARAM lParam);

    // notification handlers
    HRESULT _OnCmdComplete(WPARAM tid, LPARAM lParam, HRESULT hrCompletionResult, LPCSTR lpszResponseText);
    HRESULT _OnMailBoxUpdate(MBOX_MSGCOUNT *pNewMsgCount);
    HRESULT _OnMsgDeleted(DWORD dwDeletedMsgSeqNum);
    HRESULT _OnFetchBody(HRESULT hrFetchBodyResult, FETCH_BODY_PART *pFetchBodyPart);
    HRESULT _OnUpdateMsg(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT _OnApplFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags);
    HRESULT _OnPermFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags, LPSTR lpszResponseText);
    HRESULT _OnUIDValidity(WPARAM tid, DWORD dwUIDValidity, LPSTR lpszResponseText);
    HRESULT _OnReadWriteStatus(WPARAM tid, BOOL bReadWrite, LPSTR lpszResponseText);
    HRESULT _OnTryCreate(WPARAM tid, LPSTR lpszResponseText);
    HRESULT _OnSearchResponse(WPARAM tid, IRangeList *prlSearchResults);
    HRESULT _OnMailBoxList(WPARAM tid, LPARAM lParam, LPSTR pszMailboxName,
        IMAP_MBOXFLAGS imfMboxFlags, char cHierarchyChar, BOOL fNoTranslation);
    HRESULT _OnAppendProgress(LPARAM lParam, DWORD dwCurrent, DWORD dwTotal);
    HRESULT _OnStatusResponse(IMAP_STATUS_RESPONSE *pisrStatusInfo);

    // internal state helpers
    HRESULT _EnsureSelected();
    HRESULT _Connect();
    HRESULT _Disconnect();
    HRESULT _EnsureInited();

    // init helpers
    HRESULT _LoadTransport();
    HRESULT _LoadAccountInfo();

    // fetch command helpers
    HRESULT UpdateMsgHeader(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT UpdateMsgBody(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT UpdateMsgFlags(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);

    // command helpers
    HRESULT _ShowUserInfo(LPSTR pszTitle, LPSTR pszText1, LPSTR pszText2);
    HRESULT _SyncHeader(void);
    void ResetStatusCounts(void);
    HRESULT _SetMessageFlags(STOREOPERATIONTYPE sotOpType, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);


    // queuing support
    HRESULT _BeginOperation(STOREOPERATIONTYPE sotOpType, IStoreCallback *pCallback);
    HRESULT _EnqueueOperation(WPARAM wParam, LPARAM lParam, IMAP_COMMAND icCommandID, LPCSTR pszCmdArgs, UINT uiPriority);
    HRESULT _SendNextOperation(DWORD dwFlags);


public:
    // Connection FSM
    HRESULT _ConnFSM_Idle(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForConn(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForSelect(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForHdrSync(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_StartOperation(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForOpDone(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_OperationComplete(CONN_FSM_EVENT cfeEvent);

    HRESULT _ConnFSM_HandleEvent(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_ChangeState(CONN_FSM_STATE cfsNewState);
    HRESULT _ConnFSM_QueueEvent(CONN_FSM_EVENT cfeEvent);
    IMAP_SERVERSTATE _StoreOpToMinISS(STOREOPERATIONTYPE sot);
    HRESULT _LaunchOperation(void);
    HRESULT _OnOperationComplete(void);

    static LRESULT CALLBACK _ConnFSMWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
}; // CIMAPSync


// Connection FSM State Handler Functions (keep in sync with CONN_FSM_STATE)
typedef HRESULT (CIMAPSync::*CONN_FSM_EVENT_HANDLER)(CONN_FSM_EVENT cfeEvent);
const CONN_FSM_EVENT_HANDLER c_pConnFSMEventHandlers[] =
{
    &CIMAPSync::_ConnFSM_Idle,              // CFSM_STATE_IDLE,
    &CIMAPSync::_ConnFSM_WaitForConn,       // CFSM_STATE_WAITFORCONN,
    &CIMAPSync::_ConnFSM_WaitForSelect,     // CFSM_STATE_WAITFORSELECT,
    &CIMAPSync::_ConnFSM_WaitForHdrSync,    // CFSM_STATE_WAITFORHDRSYNC,
    &CIMAPSync::_ConnFSM_StartOperation,    // CFSM_STATE_STARTOPERATION,
    &CIMAPSync::_ConnFSM_WaitForOpDone,     // CFSM_STATE_WAITFOROPERATIONDONE,
    &CIMAPSync::_ConnFSM_OperationComplete, // CSFM_STATE_OPERATIONCOMPLETE
};


//---------------------------------------------------------------------------
// CRenameFolderInfo Class Declaration
//---------------------------------------------------------------------------
// This class makes me want to shower. It is used to pass info to
// SendNextOperation, so I don't have to change its interface... but even with an
// interface change, this is how the info structure would look.
class CRenameFolderInfo {
public:
    CRenameFolderInfo(void);
    ~CRenameFolderInfo(void);

    long AddRef(void);
    long Release(void);

    BOOL IsDone(void);
    HRESULT SetError(HRESULT hrResult, LPSTR pszProblemArg, LPSTR pszDetailsArg);

    LPSTR pszFullFolderPath; // Full folder path of old mailbox name
    char cHierarchyChar;
    LPSTR pszNewFolderPath;  // Full folder path of new mailbox name
    FOLDERID idRenameFolder;
    int iNumSubscribeRespExpected; // Count num of SUBSCRIBE's sent to detect end of phase one/two
    int iNumListRespExpected;      // Count num of LIST's sent to detect end of phase one
    int iNumRenameRespExpected;    // Count num of additional RENAME's sent to detect end of phase one
    int iNumUnsubscribeRespExpected; // Count num of UNSUBSCRIBE's to detect end of phase two
    int iNumFailedSubs; // Count number of failed SUBSCRIBE's to verify that we addressed them all
    int iNumFailedUnsubs; // Count number of failed UNSUBSCRIBE's, to let the user know at the end
    BOOL fNonAtomicRename; // TRUE if listing old tree returned something

    LPSTR pszRenameCmdOldFldrPath; // Old folder path for rename cmd
    BOOL fPhaseOneSent; // TRUE if all Phase One commands have been successfully sent
    BOOL fPhaseTwoSent; // TRUE if all Phase Two commands have been successfully sent

    HRESULT hrLastError;
    LPSTR   pszProblem;
    LPSTR   pszDetails;

private:
    long m_lRefCount;
}; // class CRenameFolderInfo


#endif // __IMAPSync_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\imap\imapute.h ===
/*
 *    imaputil.h
 *    
 *    Purpose:                     
 *        IMAP utility functions
 *    
 *    Owner:
 *        Raych
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#ifndef __IMAPUTIL_H
#define __IMAPUTIL_H

//---------------------------------------------------------------------------
// Function Prototypes
//---------------------------------------------------------------------------
HRESULT ImapUtil_MsgFlagsToString(IMAP_MSGFLAGS imfSource, LPSTR *ppszDestination,
                                  DWORD *pdwLengthOfDestination);
void ImapUtil_LoadRootFldrPrefix(LPCTSTR pszAccountID, LPSTR pszRootFolderPrefix,
                                 DWORD dwSizeofPrefixBuffer);
HRESULT ImapUtil_FolderIDToPath(FOLDERID idServer, FOLDERID idFolder, char **ppszPath,
                                LPDWORD pdwPathLen, char *pcHierarchyChar,
                                IMessageStore *pFldrCache, LPCSTR pszAppendStr,
                                LPCSTR pszRootFldrPrefix);
HRESULT ImapUtil_SpecialFldrTypeToPath(LPCSTR pszAccount, SPECIALFOLDER sfType,
                                       LPSTR pszRootFldrPrefix, char cHierarchyChar,
                                       LPSTR pszPath, DWORD dwSizeOfPath);
LPSTR ImapUtil_GetSpecialFolderType(LPSTR pszAccountName, LPSTR pszFullPath,
                                    char cHierarchyChar, LPSTR pszRootFldrPrefix,
                                    SPECIALFOLDER *psfType);
HRESULT ImapUtil_UIDToMsgSeqNum(IIMAPTransport *pIMAPTransport, DWORD_PTR dwUID, LPDWORD pdwMsgSeqNum);
LPSTR ImapUtil_ExtractLeafName(LPSTR pszFolderPath, char cHierarchyChar);
void ImapUtil_B2SetDirtyFlag(void);

#endif // __IMAPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\imap\imapsync.cpp ===
//***************************************************************************
// IMAP4 Message Sync Class Implementation (CIMAPSync)
// Written by Raymond Cheng, 5/5/98
// Copyright (C) Microsoft Corporation, 1998
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "imapsync.h"
#include "xputil.h"
#include "flagconv.h"
#include "imapute.h"
#include "storutil.h"
#include "xpcomm.h"
#include "iert.h"
#include "menures.h"
#include "serverq.h"
#include "instance.h"
#include "demand.h"
#include "storecb.h"

#define USE_QUEUING_LAYER
//---------------------------------------------------------------------------
// Module Data Types
//---------------------------------------------------------------------------
typedef struct tagFOLDERIDLIST
{
    FOLDERID    idFolder;
    struct tagFOLDERIDLIST *pfilNextFolderID;
} FOLDERIDLISTNODE;

//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
#define CCHMAX_CMDLINE          512
#define CCHMAX_IMAPFOLDERPATH   512
#define CHASH_BUCKETS           50

static const char cszIMAPFetchNewHdrsI4[] = "%lu:* (RFC822.HEADER RFC822.SIZE UID FLAGS INTERNALDATE)";
static const char cszIMAPFetchNewHdrsI4r1[] =
    "%lu:* (BODY.PEEK[HEADER.FIELDS (References X-Ref X-Priority X-MSMail-Priority X-MSOESRec Newsgroups)] "
    "ENVELOPE RFC822.SIZE UID FLAGS INTERNALDATE)";
static const char cszIMAPFetchCachedFlags[] = "1:%lu (UID FLAGS)";

enum
{
    tidDONT_CARE           = 0, // Means that transaction ID is unimportant or unavailable
    tidSELECTION,
    tidFETCH_NEW_HDRS,
    tidFETCH_CACHED_FLAGS,
    tidCOPYMSGS,                // The COPY command used to copy msgs to another IMAP fldr
    tidMOVEMSGS,                // The STORE command used to delete msg ranges - currently only used for moves
    tidBODYMSN,                 // The FETCH command used to get MsgSeqNumToUID translation before tidBODY
    tidBODY,                    // The FETCH command used to retrieve a msg body
    tidNOOP,                    // The NOOP command used to poll for new messages
    tidCLOSE,
    tidSELECT,
    tidUPLOADMSG,               // The APPEND command used to upload a message to IMAP server
    tidMARKMSGS,
    tidCREATE,                  // the CREATE cmd sent to create a folder
    tidCREATELIST,              // the LIST command sent after a CREATE
    tidCREATESUBSCRIBE,         // the SUBSCRIBE command sent after a CREATE
    tidHIERARCHYCHAR_LIST_B,    // the LIST cmd sent to find hierarchy char (Plan B)
    tidHIERARCHYCHAR_CREATE,    // the CREATE cmd sent to find hierarchy char
    tidHIERARCHYCHAR_LIST_C,    // the LIST cmd sent to find hierarchy char (Plan C)
    tidHIERARCHYCHAR_DELETE,    // the DELETE cmd sent to find hierarchy char
    tidPREFIXLIST,              // Prefixed hierarchy listing (eg, "~raych/Mail" prefix)
    tidPREFIX_HC,               // the LIST cmd sent to find hierarchy char for prefix
    tidPREFIX_CREATE,           // the CREATE cmd sent to create the prefix folder
    tidDELETEFLDR,              // the DELETE cmd sent to delete a folder
    tidDELETEFLDR_UNSUBSCRIBE,  // the UNSUBSCRIBE cmd sent to unsub a deleted fldr
    tidRENAME,                  // The RENAME cmd sent to rename a folder
    tidRENAMESUBSCRIBE,         // The subscribe cmd sent to subscribe a folder
    tidRENAMELIST,              // The LIST cmd sent to check if rename was atomic
    tidRENAMERENAME,            // The second rename attempt, if server does non-atomic rename
    tidRENAMESUBSCRIBE_AGAIN,   // The subscribe cmd sent to attempt second new-tree subscribe again
    tidRENAMEUNSUBSCRIBE,       // The unsubscribe cmd sent to unsubscribe the old folders
    tidSUBSCRIBE,               // The (un)subscribe command sent to (un)subscribe a folder
    tidSPECIALFLDRLIST,         // The LIST command sent to check if a special folder exists
    tidSPECIALFLDRLSUB,         // The LSUB command sent to list a special folder's subscribed subfolders
    tidSPECIALFLDRSUBSCRIBE,    // The SUBSCRIBE command sent out to subscribe an existing special folder
    tidFOLDERLIST,
    tidFOLDERLSUB,
    tidEXPUNGE,                 // EXPUNGE command
    tidSTATUS,                  // STATUS command used for IMessageServer::GetFolderCounts
};

enum
{
    fbpNONE,                    // Fetch Body Part identifier (lpFetchCookie1 is set to this)
    fbpHEADER,
    fbpBODY,
    fbpUNKNOWN
};

// Priorities, for use with _EnqueueOperation
enum
{
    uiTOP_PRIORITY,     // Ensures that we construct MsgSeqNum table before ALL user operations
    uiNORMAL_PRIORITY   // Priority level for all user operations
};


// Argument Readability Defines
const BOOL DONT_USE_UIDS = FALSE;               // For use with IIMAPTransport
const BOOL USE_UIDS = TRUE ;                    // For use with IIMAPTransport
const BOOL fUPDATE_OLD_MSGFLAGS = TRUE;         // For use with DownloadNewHeaders
const BOOL fDONT_UPDATE_OLD_MSGFLAGS = FALSE;   // For use with DownloadNewHeaders
const BOOL fCOMPLETED = 1;                      // For use with NotifyMsgRecipients
const BOOL fPROGRESS = 0;                       // For use with NotifyMsgRecipients
const BOOL fLOAD_HC = FALSE;                    // (LoadSaveRootHierarchyChar): Load hierarchy character from foldercache
const BOOL fSAVE_HC = TRUE;                     // (LoadSaveRootHierarchyChar): Save hierarchy character to foldercache
const BOOL fHCF_PLAN_A_ONLY = TRUE;             // Only execute Plan A in hierarchy char determination
const BOOL fHCF_ALL_PLANS = FALSE;              // Execute Plans A, B, C and Z in hierarchy char determination
const BOOL fSUBSCRIBE = TRUE;                   // For use with SubscribeToFolder
const BOOL fUNSUBSCRIBE = FALSE;                // For use with SubscribeToFolder
const BOOL fRECURSIVE = TRUE;                   // For use with DeleteFolderFromCache
const BOOL fNON_RECURSIVE = FALSE;              // For use with DeleteFolderFromCache
const BOOL fINCLUDE_RENAME_FOLDER = TRUE;       // For use with RenameTreeTraversal
const BOOL fEXCLUDE_RENAME_FOLDER = FALSE;      // For use with RenameTreeTraversal
const BOOL fREMOVE = TRUE;                      // For use with IHashTable::Find
const BOOL fNOPROGRESS = FALSE;                 // For use with CStoreCB::Initialize

#define pahfoDONT_CREATE_FOLDER NULL            // For use with FindHierarchalFolderName

const HRESULT S_CREATED = 1;                    // Indicates FindHierarchicalFolderName created the fldr

// None of the following bits can be set for a message to qualify as "unread"
const DWORD dwIMAP_UNREAD_CRITERIA = IMAP_MSG_SEEN | IMAP_MSG_DELETED;

// Internal flags for use with m_dwSyncToDo
const DWORD SYNC_FOLDER_NOOP    = 0x80000000;

const DWORD AFTC_SUBSCRIBED         = 0x00000001;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_KEEPCHILDRENKNOWN  = 0x00000002;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_NOTSUBSCRIBED      = 0x00000004;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_NOTRANSLATION      = 0x00000008;   // For use with AddToFolderCache's dwATFCFlags

#define AssertSingleThreaded        AssertSz(m_dwThreadId == GetCurrentThreadId(), "The IMAPSync is not multithreaded. Someone is calling me on multiple threads")

const DWORD snoDO_NOT_DISPOSE       = 0x00000001;   // For use with _SendNextOperation


// Connection FSM
const UINT WM_CFSM_EVENT = WM_USER;


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

//***************************************************************************
//***************************************************************************
HRESULT CreateImapStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    CIMAPSync  *pIMAPSync;
    HRESULT     hr;

    TraceCall("CIMAPSync::CreateImapStore");
    IxpAssert(NULL != ppUnknown);

    // Initialize return values
    *ppUnknown = NULL;
    hr = E_NOINTERFACE;

    if (NULL != pUnkOuter)
    {
        hr = TraceResult(CLASS_E_NOAGGREGATION);
        goto exit;
    }

    pIMAPSync = new CIMAPSync;
    if (NULL == pIMAPSync)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

#ifdef USE_QUEUING_LAYER
    hr = CreateServerQueue(pIMAPSync, (IMessageServer **)ppUnknown);
    pIMAPSync->Release(); // Since we're not returning this ptr, bump down refcount
#else
    // If we reached this point, everything is working great
    *ppUnknown = SAFECAST(pIMAPSync, IMessageServer *);
    hr = S_OK;
#endif

exit:
    // Done
    return hr;
}



//***************************************************************************
// Function: CIMAPSync (constructor)
//***************************************************************************
CIMAPSync::CIMAPSync(void)
{
    TraceCall("CIMAPSync::CIMAPSync");

    m_cRef = 1;
    m_pTransport = NULL;
    ZeroMemory(&m_rInetServerInfo, sizeof(m_rInetServerInfo));
    m_idFolder = FOLDERID_INVALID;
    m_idSelectedFolder = FOLDERID_INVALID;
    m_idIMAPServer = FOLDERID_INVALID;
    m_pszAccountID = NULL;
    m_szAccountName[0] = '\0';
    m_pszFldrLeafName = NULL;
    m_pStore = NULL;
    m_pFolder = NULL;
    m_pDefCallback = NULL;

    m_pioNextOperation = NULL;

    m_dwMsgCount = 0;
    m_fMsgCountValid = FALSE;
    m_dwNumNewMsgs = 0;
    m_dwNumHdrsDLed = 0;
    m_dwNumUnreadDLed = 0;
    m_dwNumHdrsToDL = 0;
    m_dwUIDValidity = 0;
    m_dwSyncFolderFlags = 0;
    m_dwSyncToDo = 0;
    m_lSyncFolderRefCount = 0;
    m_dwHighestCachedUID = 0;
    m_rwsReadWriteStatus = rwsUNINITIALIZED;
    m_fCreateSpecial = TRUE;
    m_fNewMail = FALSE;
    m_fInbox = FALSE;
    m_fDidFullSync = FALSE;

    m_csNewConnState = CONNECT_STATE_DISCONNECT;
    m_cRootHierarchyChar = INVALID_HIERARCHY_CHAR;
    m_phcfHierarchyCharInfo = NULL;
    m_fReconnect = FALSE;

    m_issCurrent = issNotConnected;

    m_szRootFolderPrefix[0] = '\0';
    m_fPrefixExists = FALSE;

    // Central repository
    m_pCurrentCB = NULL;
    m_sotCurrent = SOT_INVALID;
    m_idCurrent = FOLDERID_INVALID;
    m_fSubscribe = FALSE;
    m_pCurrentHash = NULL;
    m_pListHash = NULL;
    m_fTerminating = FALSE;

    m_fInited = 0;
    m_fDisconnecting = 0;
    m_cFolders = 0;

    m_faStream = 0;
    m_pstmBody = NULL;
    m_idMessage = 0;

    m_fGotBody = FALSE;

    m_cfsState = CFSM_STATE_IDLE;
    m_cfsPrevState = CFSM_STATE_IDLE;
    m_hwndConnFSM = NULL;
    m_hrOperationResult = OLE_E_BLANK; // Uninitialized state
    m_szOperationProblem[0] = '\0';
    m_szOperationDetails[0] = '\0';

    m_dwThreadId = GetCurrentThreadId();
}



//***************************************************************************
// Function: ~CIMAPSync (destructor)
//***************************************************************************
CIMAPSync::~CIMAPSync(void)
{
    TraceCall("CIMAPSync::~CIMAPSync");
    IxpAssert(0 == m_cRef);

    if (NULL != m_phcfHierarchyCharInfo)
        delete m_phcfHierarchyCharInfo;

    IxpAssert (!IsWindow(m_hwndConnFSM));
    SafeMemFree(m_pszAccountID);
    SafeMemFree(m_pszFldrLeafName);
    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
}

HRESULT CIMAPSync::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    TraceCall("CIMAPSync::QueryInterface");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != ppvObject);

    // Init variables, arguments
    hr = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid)
        *ppvObject = (IMessageServer *) this;
    else if (IID_IMessageServer == iid)
        *ppvObject = (IMessageServer *) this;
    else if (IID_ITransportCallback == iid)
        *ppvObject = (ITransportCallback *) this;
    else if (IID_ITransportCallbackService == iid)
        *ppvObject = (ITransportCallbackService *) this;
    else if (IID_IIMAPCallback == iid)
        *ppvObject = (IIMAPCallback *) this;
    else if (IID_IIMAPStore == iid)
        *ppvObject = (IIMAPStore *) this;

    // If we returned an interface, return success
    if (NULL != *ppvObject)
    {
        hr = S_OK;
        ((IUnknown *) *ppvObject)->AddRef();
    }

exit:
    return hr;
}



ULONG CIMAPSync::AddRef(void)
{
    TraceCall("CIMAPSync::AddRef");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);

    m_cRef += 1;

    DOUT ("CIMAPSync::AddRef, returned Ref Count=%ld", m_cRef);
    return m_cRef;
}


ULONG CIMAPSync::Release(void)
{
    TraceCall("CIMAPSync::Release");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);

    m_cRef -= 1;
    DOUT("CIMAPSync::Release, returned Ref Count = %ld", m_cRef);

    if (0 == m_cRef)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}


//===========================================================================
// IMessageSync Methods
//===========================================================================
//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder)
{
    HRESULT     hr;
    BOOL        fResult;
    WNDCLASSEX  wc;

    TraceCall("CIMAPSync::Initialize");
    AssertSingleThreaded;

    if (pStore == NULL || idStoreRoot == FOLDERID_INVALID)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // check to make sure we're not inited twice.
    if (m_fInited)
    {
        hr = TraceResult(CO_E_ALREADYINITIALIZED);
        goto exit;
    }

    // Save current folder data
    m_idIMAPServer = idStoreRoot;
    m_idFolder = idFolder;
    ReplaceInterface(m_pStore, pStore);
    ReplaceInterface(m_pFolder, pFolder);
    LoadLeafFldrName(idFolder);

    hr = _LoadAccountInfo();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = _LoadTransport();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a window to queue Connection FSM messages
    wc.cbSize = sizeof(WNDCLASSEX);
    fResult = GetClassInfoEx(g_hInst, c_szIMAPSyncCFSMWndClass, &wc);
    if (FALSE == fResult)
    {
        ATOM aResult;

        // Register this window class
        wc.style            = 0;
        wc.lpfnWndProc      = CIMAPSync::_ConnFSMWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szIMAPSyncCFSMWndClass;
        wc.hIconSm          = NULL;

        aResult = RegisterClassEx(&wc);
        if (0 == aResult && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    m_hwndConnFSM = CreateWindowEx(WS_EX_TOPMOST, c_szIMAPSyncCFSMWndClass,
        c_szIMAPSyncCFSMWndClass, WS_POPUP, 1, 1, 1, 1, NULL, NULL, g_hInst,
        (LPVOID)this);
    if (NULL == m_hwndConnFSM)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // flag successful initialization
    m_fInited = TRUE;

exit:
    return hr;
}



HRESULT CIMAPSync::ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder)
{
    TraceCall("CIMAPSync::ResetFolder");
    Assert(m_cRef > 0);

    m_idFolder = idFolder;
    ReplaceInterface(m_pFolder, pFolder);
    LoadLeafFldrName(idFolder);

    return S_OK;
}



void CIMAPSync::LoadLeafFldrName(FOLDERID idFolder)
{
    FOLDERINFO  fiFolderInfo;

    SafeMemFree(m_pszFldrLeafName);
    if (FOLDERID_INVALID != idFolder)
    {
        HRESULT hr;

        hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
        if (SUCCEEDED(hr))
        {
            m_pszFldrLeafName = PszDupA(fiFolderInfo.pszName);
            if (NULL == m_pszFldrLeafName)
            {
                TraceResult(E_OUTOFMEMORY);
                m_pszFldrLeafName = PszDupA(""); // If this fails, tough luck
            }

            m_pStore->FreeRecord(&fiFolderInfo);
        }
    }
}


HRESULT CIMAPSync::Close(DWORD dwFlags)
{
    HRESULT             hrTemp;

    BOOL                fCancelOperation = FALSE;
    STOREERROR          seErrorInfo;
    IStoreCallback     *pCallback = NULL;
    STOREOPERATIONTYPE  sotCurrent;

    TraceCall("CIMAPSync::Close");

    AssertSingleThreaded;

    // validate flags
    if (0 == (dwFlags & (MSGSVRF_HANDS_OFF_SERVER | MSGSVRF_DROP_CONNECTION)))
        return TraceResult(E_UNEXPECTED);

    // Check if we are to cancel the current operation
    if (SOT_INVALID != m_sotCurrent &&
        (dwFlags & (MSGSVRF_DROP_CONNECTION | MSGSVRF_HANDS_OFF_SERVER)))
    {
        fCancelOperation = TRUE;
        if (NULL != m_pCurrentCB)
        {
            IxpAssert(SOT_INVALID != m_sotCurrent);
            FillStoreError(&seErrorInfo, STORE_E_OPERATION_CANCELED, 0,
                MAKEINTRESOURCE(IDS_IXP_E_USER_CANCEL), NULL);

            // Remember how to call callback
            pCallback = m_pCurrentCB;
            sotCurrent = m_sotCurrent;
        }

        // Reset current operation vars
        m_hrOperationResult = OLE_E_BLANK;
        m_sotCurrent = SOT_INVALID;
        m_pCurrentCB = NULL;
        m_cfsState = CFSM_STATE_IDLE;
        m_cfsPrevState = CFSM_STATE_IDLE;
        m_fTerminating = FALSE;

        // Clear the Connection FSM event queue
        if (IsWindow(m_hwndConnFSM))
        {
            MSG msg;

            while (PeekMessage(&msg, m_hwndConnFSM, WM_CFSM_EVENT, WM_CFSM_EVENT, PM_REMOVE))
            {
                TraceInfoTag(TAG_IMAPSYNC,
                    _MSG("CIMAPSync::Close removing WM_CFSM_EVENT, cfeEvent = %lX",
                    msg.wParam));
            }
        }
    }

    // If connection still exists, perform purge-on-exit and disconnect us as required
    // Connection might not exist, however (eg, if modem connection terminated)
    if (dwFlags & MSGSVRF_DROP_CONNECTION || dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_fDisconnecting = TRUE;
            m_pTransport->DropConnection();
        }
    }

    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);
    SafeRelease(m_pstmBody);

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        SafeRelease(m_pDefCallback);
        FlushOperationQueue(issNotConnected, STORE_E_OPERATION_CANCELED);

        if (IsWindow(m_hwndConnFSM))
        {
            if (m_dwThreadId == GetCurrentThreadId())
                SideAssert(DestroyWindow(m_hwndConnFSM));
            else
                SideAssert(PostMessage(m_hwndConnFSM, WM_CLOSE, 0, 0));
        }

        // Let go of our transport object
        if (m_pTransport)
        {
            m_pTransport->HandsOffCallback();
            m_pTransport->Release();
            m_pTransport = NULL;
        }

        m_fInited = 0;
    }

    // Notify caller that we're complete
    if (fCancelOperation && NULL != pCallback)
    {
        HRESULT hrTemp;

        hrTemp = pCallback->OnComplete(sotCurrent, seErrorInfo.hrResult, NULL, &seErrorInfo);
        TraceError(hrTemp);
        pCallback->Release();
    }
    // *** WARNING: After this point, OnComplete may have been called which may cause
    // us to have been re-entered. Make no reference to module vars!

    return S_OK;
}



HRESULT CIMAPSync::PurgeMessageProgress(HWND hwndParent)
{
    CStoreCB   *pCB = NULL;
    HRESULT     hrResult = S_OK;

    TraceCall("CIMAPSync::PurgeMessageProgress");

    // Check if we're connected and selected
    if (NULL == m_pTransport || issSelected != m_issCurrent ||
        FOLDERID_INVALID == m_idSelectedFolder || m_idSelectedFolder != m_idFolder ||
        CFSM_STATE_IDLE != m_cfsState)
    {
        // Not in proper state to issue CLOSE
        goto exit;
    }

    pCB = new CStoreCB;
    if (NULL == pCB)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hrResult = pCB->Initialize(hwndParent, MAKEINTRESOURCE(idsPurgingMessages), fNOPROGRESS);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Issue the CLOSE command
    hrResult = _EnqueueOperation(tidCLOSE, 0, icCLOSE_COMMAND, NULL, uiNORMAL_PRIORITY);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = _BeginOperation(SOT_PURGING_MESSAGES, pCB);
    if (FAILED(hrResult) && E_PENDING != hrResult)
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Wait until CLOSE is complete
    hrResult = pCB->Block();
    TraceError(hrResult);

    // Shut down
    hrResult = pCB->Close();
    TraceError(hrResult);

exit:
    SafeRelease(pCB);
    return hrResult;
}




HRESULT CIMAPSync::_ConnFSM_HandleEvent(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    TraceCall("CIMAPSync::_HandleConnFSMEvent");

    if (cfeEvent >= CFSM_EVENT_MAX)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    if (m_cfsState >= CFSM_STATE_MAX)
    {
        hrResult = TraceResult(E_FAIL);
        goto exit;
    }

    IxpAssert(NULL != c_pConnFSMEventHandlers[m_cfsState]);
    hrResult = (this->*c_pConnFSMEventHandlers[m_cfsState])(cfeEvent);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_HandleEvent



HRESULT CIMAPSync::_ConnFSM_Idle(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_IDLE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_Idle");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Don't need to do anything for this state
            break;

        case CFSM_EVENT_CMDAVAIL:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORCONN);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            // We don't care about no stinking errors (not in this state)
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_Idle, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_Idle



HRESULT CIMAPSync::_ConnFSM_WaitForConn(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORCONN == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForConn");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // We need to connect and authenticate. Do this even if we're already
            // connected (we will check if user changed connection settings)
            hrResult = SetConnectionState(CONNECT_STATE_CONNECT);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_CONNCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORSELECT);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForConn, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch


exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForConn



HRESULT CIMAPSync::_ConnFSM_WaitForSelect(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fGoToNextState = FALSE;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORSELECT == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForSelect");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Do we need to SELECT the current folder for this operation?
            if (_StoreOpToMinISS(m_sotCurrent) < issSelected)
            {
                // This operation does not require folder selection: ready to start operation
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_STARTOPERATION);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
            {
                // Issue the SELECT command for the current folder
                hrResult = _EnsureSelected();
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
                else if (STORE_S_NOOP == hrResult)
                    fGoToNextState= TRUE;
            }

            if (FALSE == fGoToNextState)
                break;

            // *** If fGoToNextState, FALL THROUGH ***

        case CFSM_EVENT_SELECTCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORHDRSYNC);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForSelect, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForSelect



HRESULT CIMAPSync::_ConnFSM_WaitForHdrSync(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult=S_OK;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORHDRSYNC == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForHdrSync");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Check if we're supposed to synchronize this folder
            if (0 != m_dwSyncToDo)
            {
                // Yup, send the synchronization commands
                Assert(0 == m_lSyncFolderRefCount);
                m_lSyncFolderRefCount = 0;
                hrResult = _SyncHeader();
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
                // No synchronization requested
                hrResult = STORE_S_NOOP;

            // If no synchronization requested, fall through and proceed to next state
            if (STORE_S_NOOP != hrResult)
                break; // Our work here is done

            // *** FALL THROUGH ***

        case CFSM_EVENT_HDRSYNCCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_STARTOPERATION);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForHdrSync, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForHdrSync



HRESULT CIMAPSync::_ConnFSM_StartOperation(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fMoreCmdsToSend;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_STARTOPERATION == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_StartOperation");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Launch operation
            hrResult = _LaunchOperation();
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            else if (STORE_S_NOOP == hrResult)
            {
                // This means success, but no operation launched. Proceed directly to "DONE"
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
            {
                // Proceed to the next state to wait for command completion
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFOROPERATIONDONE);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_StartOperation, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_StartOperation



HRESULT CIMAPSync::_ConnFSM_WaitForOpDone(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForOpDone");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // No need to do anything for initialization
            break;

        case CFSM_EVENT_OPERATIONCOMPLETE:
        case CFSM_EVENT_ERROR:
            // Proceed to next state
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForOpDone, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_WaitForOpDone



HRESULT CIMAPSync::_ConnFSM_OperationComplete(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_OPERATIONCOMPLETE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_OperationComplete");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Clean up and send OnComplete callback to caller
            hrResult = _OnOperationComplete();

            // Proceed back to the IDLE state
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_IDLE);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            // Ignore errors, we're on the way back to IDLE
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_OperationComplete, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_OperationComplete



HRESULT CIMAPSync::_ConnFSM_ChangeState(CONN_FSM_STATE cfsNewState)
{
    HRESULT hrResult;

    IxpAssert(m_cRef > 0);
    IxpAssert(cfsNewState < CFSM_STATE_MAX);
    TraceCall("CIMAPSync::_ConnFSM_ChangeState");

    if (CFSM_STATE_OPERATIONCOMPLETE == cfsNewState)
        m_fTerminating = TRUE;

    m_cfsPrevState = m_cfsState;
    m_cfsState = cfsNewState;
    hrResult = _ConnFSM_QueueEvent(CFSM_EVENT_INITIALIZE);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_ChangeState



HRESULT CIMAPSync::_ConnFSM_QueueEvent(CONN_FSM_EVENT cfeEvent)
{
    BOOL    fResult;
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(cfeEvent < CFSM_EVENT_MAX);
    TraceCall("CIMAPSync::_ConnFSM_QueueEvent");

    fResult = PostMessage(m_hwndConnFSM, WM_CFSM_EVENT, cfeEvent, 0);
    if (0 == fResult)
    {
        hrResult = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_QueueEvent



HRESULT CIMAPSync::_LaunchOperation(void)
{
    HRESULT hrResult = E_FAIL;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_STARTOPERATION == m_cfsState);
    TraceCall("CIMAPSync::_LaunchOperation");

    switch (m_sotCurrent)
    {
        case SOT_SYNC_FOLDER:
            IxpAssert(OLE_E_BLANK == m_hrOperationResult);
            hrResult = STORE_S_NOOP; // Nothing to do! We're already done!
            m_hrOperationResult = S_OK; // If we got this far we must be successful
            goto exit;

        default:
            // Do nothing for now
            break;
    } // switch

    // Launch Operation (for now, this just means to pump send queue)
    do
    {
        hrResult = _SendNextOperation(NOFLAGS);
        TraceError(hrResult);
    } while (S_OK == hrResult);

exit:
    return hrResult;
} // _LaunchOperation


HRESULT CIMAPSync::_OnOperationComplete(void)
{
    STOREERROR          seErrorInfo;
    STOREERROR         *pErrorInfo = NULL;
    HRESULT             hrTemp;
    HRESULT             hrOperationResult;
    IStoreCallback     *pCallback;
    STOREOPERATIONTYPE  sotCurrent;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_OPERATIONCOMPLETE == m_cfsState);

    // In some cases, CIMAPSync::Close does the OnComplete call for us
    if (SOT_INVALID == m_sotCurrent)
    {
        IxpAssert(NULL == m_pCurrentCB);
        IxpAssert(OLE_E_BLANK == m_hrOperationResult);
        return S_OK;
    }

    IxpAssert(OLE_E_BLANK != m_hrOperationResult);
    TraceCall("CIMAPSync::_OnOperationComplete");

    if (NULL != m_pCurrentCB && FAILED(m_hrOperationResult))
    {
        FillStoreError(&seErrorInfo, m_hrOperationResult, 0, NULL, NULL);
        pErrorInfo = &seErrorInfo;
    }

    // Ancient relic of the past: will be deleted when queue is removed
    FlushOperationQueue(issNotConnected, E_FAIL);

    // Remember a couple of things
    pCallback = m_pCurrentCB;
    sotCurrent = m_sotCurrent;
    hrOperationResult = m_hrOperationResult;

    // Reset all operation variables in case of re-entry during OnComplete call
    m_pCurrentCB = NULL;
    m_sotCurrent = SOT_INVALID;
    m_hrOperationResult = OLE_E_BLANK;
    m_fTerminating = FALSE;

    m_idCurrent = FOLDERID_INVALID;
    m_fSubscribe = FALSE;
    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);

    // Now we're ready to call OnComplete
    if (NULL != pCallback)
    {
        // This should be the ONLY call to IStoreCallback::OnComplete in this class!
        hrTemp = pCallback->OnComplete(sotCurrent, hrOperationResult, NULL, pErrorInfo);
        TraceError(hrTemp);

        // *** WARNING: At this point, we may be re-entered if OnComplete call puts up
        // window. Make no references to module vars!
        pCallback->Release();
    }

    return S_OK;
} // _OnOperationComplete



IMAP_SERVERSTATE CIMAPSync::_StoreOpToMinISS(STOREOPERATIONTYPE sot)
{
    IMAP_SERVERSTATE    issResult = issSelected;

    switch (sot)
    {
        case SOT_INVALID:
            IxpAssert(FALSE);
            break;

        case SOT_CONNECTION_STATUS:
        case SOT_PUT_MESSAGE:
        case SOT_SYNCING_STORE:
        case SOT_CREATE_FOLDER:
        case SOT_MOVE_FOLDER:
        case SOT_DELETE_FOLDER:
        case SOT_RENAME_FOLDER:
        case SOT_SUBSCRIBE_FOLDER:
        case SOT_UPDATE_FOLDER:
        case SOT_SYNCING_DESCRIPTIONS:
            issResult = issAuthenticated;
            break;

        case SOT_SYNC_FOLDER:
        case SOT_GET_MESSAGE:
        case SOT_COPYMOVE_MESSAGE:
        case SOT_SEARCHING:
        case SOT_DELETING_MESSAGES:
        case SOT_SET_MESSAGEFLAGS:
        case SOT_PURGING_MESSAGES:
            issResult = issSelected;
            break;

        default:
            IxpAssert(FALSE);
            break;
    } // switch

    return issResult;
} // _StoreOpToMinISS



LRESULT CALLBACK CIMAPSync::_ConnFSMWndProc(HWND hwnd, UINT uMsg,
                                                   WPARAM wParam, LPARAM lParam)
{
    LRESULT     lResult = 0;
    CIMAPSync  *pThis;
    HRESULT     hrTemp;

    pThis = (CIMAPSync *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
            IxpAssert(NULL == pThis);
            pThis = (CIMAPSync *)((CREATESTRUCT *)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
            lResult = 0;
            break;

        case WM_DESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            break;

        case WM_CFSM_EVENT:
            IxpAssert(wParam < CFSM_EVENT_MAX);
            IxpAssert(0 == lParam);
            IxpAssert(IsWindow(hwnd));

            hrTemp = pThis->_ConnFSM_HandleEvent((CONN_FSM_EVENT)wParam);
            if (FAILED(hrTemp))
            {
                TraceResult(hrTemp);
                pThis->m_hrOperationResult = hrTemp;
            }
            break;

        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lResult;
}




HRESULT CIMAPSync::_EnsureInited()
{
    if (!m_fInited)
        return CO_E_NOTINITIALIZED;

    if (!m_pTransport)
        return E_UNEXPECTED;

    if (m_sotCurrent != SOT_INVALID)
    {
        AssertSz(m_sotCurrent != SOT_INVALID, "IMAPSync was called into during a command-execution. Bug in server queue?");
        return E_UNEXPECTED;
    }

    return S_OK;
}

/*
 *  Function : EnsureSelected()
 *
 *  Purpose:    make sure we are in the selected folder state
 *              if we are selected, then we're done.
 *
 *
 */
HRESULT CIMAPSync::_EnsureSelected(void)
{
    HRESULT hr;
    LPSTR   pszDestFldrPath = NULL;

    TraceCall("CIMAPSync::_EnsureSelected");
    AssertSingleThreaded;

    IxpAssert(m_pStore);
    IxpAssert(m_idIMAPServer != FOLDERID_INVALID);

    // If current folder is already selected, no need to issue SELECT
    if (FOLDERID_INVALID != m_idSelectedFolder &&
        m_idSelectedFolder == m_idFolder)
    {
        hr = STORE_S_NOOP; // Success, but no SELECT command issued
        goto exit;
    }

    if (m_idFolder == FOLDERID_INVALID)
    {
        // noone has called SetFolder on us yet, let's bail
        // with a badfolder error
        hr = TraceResult(STORE_E_BADFOLDERNAME);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, m_idFolder, &pszDestFldrPath,
        NULL, NULL, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // We're about to issue a SELECT command, so clear operation queue
    // (it's filled with commands for previous folder)
    OnFolderExit();

    // Find out what translation mode we should be in
    hr = SetTranslationMode(m_idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pTransport->Select(tidSELECTION, (LPARAM) m_idFolder, this, pszDestFldrPath);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszDestFldrPath);
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    TraceCall("CIMAPSync::SetOwner");
    AssertSingleThreaded;

    ReplaceInterface(m_pDefCallback, pDefaultCallback);
    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetConnectionState(CONNECT_STATE csNewState)
{
    HRESULT hr;

    TraceCall("CIMAPSync::SetConnectionState");
    AssertSingleThreaded;

    m_csNewConnState = csNewState;
    if (CONNECT_STATE_CONNECT == csNewState)
    {
        hr = _Connect();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        m_fCreateSpecial = TRUE;
    }
    else if (CONNECT_STATE_DISCONNECT == csNewState)
    {
        hr = _Disconnect();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        AssertSz(FALSE, "What do you want?");
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: SynchronizeFolder
//
// Purpose:
//   This function is used to tell CIMAPSync what parts of the message
// list to synchronize with the IMAP server, and any special sync options.
// The call is treated as a STANDING ORDER, meaning that if this function
// is called to get new headers, CIMAPSync assumes that the caller is always
// interested in new headers. Therefore, the next time the IMAP server informs
// us of new headers, we download them.
//***************************************************************************
HRESULT CIMAPSync::SynchronizeFolder(DWORD dwFlags, DWORD cHeaders, IStoreCallback *pCallback)
{
    HRESULT     hr;

    TraceCall("CIMAPSync::SynchronizeFolder");
    AssertSingleThreaded;

    AssertSz(ISFLAGCLEAR(dwFlags, SYNC_FOLDER_CACHED_HEADERS) ||
        ISFLAGSET(dwFlags, SYNC_FOLDER_NEW_HEADERS),
        "Cannot currently sync cached headers without getting new headers as well");
    IxpAssert(0 == (dwFlags & ~(SYNC_FOLDER_ALLFLAGS)));

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Special-case SYNC_FOLDER_PURGE_DELETED. It doesn't really belong here
    // but it allows us to avoid adding a new function to IMessageServer.
    // Do not allow its presence to affect our standing orders
    if (SYNC_FOLDER_PURGE_DELETED & dwFlags)
    {
        // Need to set m_dwSyncFolderFlags with this flag because m_dwSyncToDo gets erased
        Assert(0 == (dwFlags & ~(SYNC_FOLDER_PURGE_DELETED)));
        dwFlags = m_dwSyncFolderFlags | SYNC_FOLDER_PURGE_DELETED;
    }

    m_dwSyncFolderFlags = dwFlags;
    m_dwSyncToDo = dwFlags | SYNC_FOLDER_NOOP;
    m_dwHighestCachedUID = 0;

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SYNC_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback)
{
    HRESULT hr;
    BOOL    fNeedMsgSeqNum = FALSE;

    TraceCall("CIMAPSync::GetMessage");
    AssertSingleThreaded;

    IxpAssert(MESSAGEID_INVALID != idMessage);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    SafeRelease(m_pstmBody);
    hr = CreatePersistentWriteStream(m_pFolder, &m_pstmBody, &m_faStream);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    m_idMessage = idMessage;
    m_fGotBody = FALSE;

    // To FETCH a message we need to translate MsgSeqNum to UID, so check if we can do it
    if (FALSE == ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
    {
        DWORD   dwMsgSeqNum;
        HRESULT hrTemp;

        // Both SYNC_FOLDER_NEW_HEADERS and SYNC_FOLDER_CACHED_HEADERS have to be
        // set to guarantee general MsgSeqNumToUID translation. Looks like we may
        // have to get the translation ourselves, but check if we already have it
        hrTemp = ImapUtil_UIDToMsgSeqNum(m_pTransport, (DWORD_PTR)idMessage, &dwMsgSeqNum);
        if (FAILED(hrTemp))
            fNeedMsgSeqNum = TRUE;
    }

    if (fNeedMsgSeqNum)
    {
        char    szFetchArgs[50];

        wsprintf(szFetchArgs, "%lu (UID)", idMessage);
        hr = _EnqueueOperation(tidBODYMSN, (LPARAM) idMessage, icFETCH_COMMAND,
            szFetchArgs, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        hr = _EnqueueOperation(tidBODY, (LPARAM) idMessage, icFETCH_COMMAND,
            NULL, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }


exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_GET_MESSAGE, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::PutMessage(FOLDERID idFolder,
                              MESSAGEFLAGS dwFlags,
                              LPFILETIME pftReceived,
                              IStream *pStream,
                              IStoreCallback *pCallback)
{
    HRESULT         hr;
    IMAP_MSGFLAGS   imfIMAPMsgFlags;
    LPSTR           pszDestFldrPath = NULL;
    APPEND_SEND_INFO *pAppendInfo = NULL;
    FOLDERINFO      fiFolderInfo;
    BOOL            fSuppressRelease = FALSE;

    TraceCall("CIMAPSync::PutMessage");
    AssertSingleThreaded;

    IxpAssert(FOLDERID_INVALID != m_idIMAPServer);
    IxpAssert(NULL != pStream);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr= SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a APPEND_SEND_INFO structure
    pAppendInfo = new APPEND_SEND_INFO;
    if (NULL == pAppendInfo)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }
    ZeroMemory(pAppendInfo, sizeof(APPEND_SEND_INFO));

    // Fill in the fields
    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, sizeof(m_szRootFolderPrefix));
    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszDestFldrPath, NULL,
        NULL, m_pStore, NULL, m_szRootFolderPrefix);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Convert flags to a string
    imfIMAPMsgFlags = DwConvertARFtoIMAP(dwFlags);
    hr = ImapUtil_MsgFlagsToString(imfIMAPMsgFlags, &pAppendInfo->pszMsgFlags, NULL);
    if (FAILED(hr))
    {
        // The show must go on! Default to no IMAP msg flags
        TraceResult(hr);
        pAppendInfo->pszMsgFlags = NULL;
        hr = S_OK; // Suppress error
    }

    // Get a date/time for INTERNALDATE attribute of this msg
    if (NULL == pftReceived)
    {
        SYSTEMTIME  stCurrentTime;

        // Substitute current date/time
        GetSystemTime(&stCurrentTime);
        SystemTimeToFileTime(&stCurrentTime, &pAppendInfo->ftReceived);
    }
    else
        pAppendInfo->ftReceived = *pftReceived;

    pAppendInfo->lpstmMsg = pStream;
    pStream->AddRef();

    // Check for the case where destination is a special folder whose creation was deferred
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        if (FOLDER_CREATEONDEMAND & fiFolderInfo.dwFlags)
        {
            CREATE_FOLDER_INFO *pcfi;

            Assert(FOLDER_NOTSPECIAL != fiFolderInfo.tySpecial);

            pcfi = new CREATE_FOLDER_INFO;
            if (NULL == pcfi)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            // Fill in all the fields
            pcfi->pszFullFolderPath = PszDupA(pszDestFldrPath);
            if (NULL == pcfi->pszFullFolderPath)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            pcfi->idFolder = FOLDERID_INVALID;
            pcfi->dwFlags = 0;
            pcfi->csfCurrentStage = CSF_INIT;
            pcfi->dwCurrentSfType = fiFolderInfo.tySpecial;
            pcfi->dwFinalSfType = fiFolderInfo.tySpecial;
            pcfi->lParam = (LPARAM) pAppendInfo;
            pcfi->pcoNextOp = PCO_APPENDMSG;

            hr = CreateNextSpecialFolder(pcfi, NULL);
            TraceError(hr); // CreateNextSpecialFolder deletes pcfi on its own if it fails
            fSuppressRelease = TRUE; // It also frees pAppendInfo if it fails

            m_pStore->FreeRecord(&fiFolderInfo);
            goto exit; // Don't send APPEND command until after entire CREATE operation
        }

        m_pStore->FreeRecord(&fiFolderInfo);
    }

    // We're ready to send the APPEND command!
    hr = _EnqueueOperation(tidUPLOADMSG, (LPARAM) pAppendInfo, icAPPEND_COMMAND,
        pszDestFldrPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (NULL != pszDestFldrPath)
        MemFree(pszDestFldrPath);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_PUT_MESSAGE, pCallback);
    else if (NULL != pAppendInfo && FALSE == fSuppressRelease)
    {
        SafeMemFree(pAppendInfo->pszMsgFlags);
        delete pAppendInfo;
    }

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetMessageFlags(LPMESSAGEIDLIST pList,
                                                     LPADJUSTFLAGS pFlags,
                                                     SETMESSAGEFLAGSFLAGS dwFlags,
                                                     IStoreCallback *pCallback)
{
    HRESULT hr;

    TraceCall("CIMAPSync::SetMessageFlags");
    AssertSingleThreaded;
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = _SetMessageFlags(SOT_SET_MESSAGEFLAGS, pList, pFlags, pCallback);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SET_MESSAGEFLAGS, pCallback);

    return hr;
}


HRESULT CIMAPSync::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    *pFlags = DwConvertIMAPtoARF(IMAP_MSG_ALLFLAGS);
    return S_OK;
}

//***************************************************************************
// Helper function to mark messages
//***************************************************************************
HRESULT CIMAPSync::_SetMessageFlags(STOREOPERATIONTYPE sotOpType,
                                    LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags,
                                    IStoreCallback *pCallback)
{
    HRESULT         hr;
    MARK_MSGS_INFO   *pMARK_MSGS_INFO = NULL;
    char            szFlagArgs[200];
    LPSTR           pszFlagList;
    DWORD           dwLen;
    LPSTR           p;
    IMAP_MSGFLAGS   imfFlags;
    DWORD           dw;
    ULONG           ul;

    TraceCall("CIMAPSync::_SetMessageFlags");
    AssertSingleThreaded;
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    // Construct a mark msg operation
    // Check the requested flag adjustments
    if (0 == pFlags->dwRemove && 0 == pFlags->dwAdd)
    {
        // Nothing to do here, exit with a smile
        hr = S_OK;
        goto exit;
    }

    if ((0 != pFlags->dwRemove && 0 != pFlags->dwAdd) ||
        (0 != (pFlags->dwRemove & pFlags->dwAdd)))
    {
        // IMAP can't do any of the following:
        //    1) add and removal of flags at the same time (NYI: takes 2 STORE cmds)
        //    2) add/removal of same flag (makes no sense)
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // If ARF_ENDANGERED is set, be sure to set ARF_READ so we don't mess up
    // unread counts as returned by STATUS command
    if (pFlags->dwAdd & ARF_ENDANGERED)
        pFlags->dwAdd |= ARF_READ;

    // Construct MARK_MSGS_INFO structure
    pMARK_MSGS_INFO = new MARK_MSGS_INFO;
    if (NULL == pMARK_MSGS_INFO)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    ZeroMemory(pMARK_MSGS_INFO, sizeof(MARK_MSGS_INFO));

    // Create a rangelist
    hr = CreateRangeList(&pMARK_MSGS_INFO->pMsgRange);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Remember these args so we can set the message flags after server confirmation
    pMARK_MSGS_INFO->afFlags = *pFlags;
    hr = CloneMessageIDList(pList, &pMARK_MSGS_INFO->pList);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pMARK_MSGS_INFO->sotOpType = sotOpType;

    // Get arguments for the STORE command
    if (0 != pFlags->dwRemove)
        szFlagArgs[0] = '-';
    else
        szFlagArgs[0] = '+';

    p = szFlagArgs + 1;
    p += wsprintf(p, "FLAGS.SILENT ");
    imfFlags = DwConvertARFtoIMAP(pFlags->dwRemove ? pFlags->dwRemove : pFlags->dwAdd);
    hr = ImapUtil_MsgFlagsToString(imfFlags, &pszFlagList, &dwLen);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    IxpAssert(dwLen < (sizeof(szFlagArgs) - (p - szFlagArgs)));
    lstrcpyn(p, pszFlagList, sizeof(szFlagArgs) - (int) (p - szFlagArgs));
    MemFree(pszFlagList);

    // Convert IDList to rangelist to submit to IIMAPTransport
    if (NULL != pList)
    {
        for (dw = 0; dw < pList->cMsgs; dw++)
        {
            HRESULT hrTemp;

            hrTemp = pMARK_MSGS_INFO->pMsgRange->AddSingleValue(PtrToUlong(pList->prgidMsg[dw]));
            TraceError(hrTemp);
        }
    }
    else
    {
        HRESULT hrTemp;

        // pList == NULL means to tackle ALL messages
        hrTemp = pMARK_MSGS_INFO->pMsgRange->AddRange(1, RL_LAST_MESSAGE);
        TraceError(hrTemp);
    }

    IxpAssert(SUCCEEDED(pMARK_MSGS_INFO->pMsgRange->Cardinality(&ul)) && ul > 0);

    // Send the command! (At last!)
    hr = _EnqueueOperation(tidMARKMSGS, (LPARAM) pMARK_MSGS_INFO, icSTORE_COMMAND,
        szFlagArgs, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CopyMessages(IMessageFolder *pDestFldr,
                                COPYMESSAGEFLAGS dwOptions,
                                LPMESSAGEIDLIST pList,
                                LPADJUSTFLAGS pFlags,
                                IStoreCallback *pCallback)
{
    HRESULT         hr;
    FOLDERID        idDestFldr;
    FOLDERINFO      fiFolderInfo;
    BOOL            fFreeFldrInfo = FALSE;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    TraceCall("CIMAPSync::CopyMoveMessages");
    AssertSingleThreaded;

    IxpAssert(FOLDERID_INVALID != m_idIMAPServer);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check if we can do an IMAP COPY command to satisfy this copy request
    hr = pDestFldr->GetFolderId(&idDestFldr);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pStore->GetFolderInfo(idDestFldr, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    fFreeFldrInfo = TRUE;

    GetFolderAccountId(&fiFolderInfo, szAccountId);

    if (0 == lstrcmpi(m_pszAccountID, szAccountId) && FOLDER_IMAP == fiFolderInfo.tyFolder)
    {
        IMAP_COPYMOVE_INFO *pCopyInfo;
        LPSTR               pszDestFldrPath;
        DWORD               dw;
        ULONG               ul;

        // This copy can be accomplished with an IMAP copy command!
        // Check args
        if (NULL != pFlags && (0 != pFlags->dwAdd || 0 != pFlags->dwRemove))
            // IMAP cannot set the flags of copied msg. We would either have to set
            // flags on source before copying, or go to destination folder and set flags
            TraceResult(E_INVALIDARG); // Record error but continue (error not fatal)

        // Find out what translation mode we should be in
        hr = SetTranslationMode(idDestFldr);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Construct CopyMoveInfo structure
        pCopyInfo = new IMAP_COPYMOVE_INFO;
        if (NULL == pCopyInfo)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        pCopyInfo->dwOptions = dwOptions;
        pCopyInfo->idDestFldr = idDestFldr;
        hr = CloneMessageIDList(pList, &pCopyInfo->pList);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        hr = CreateRangeList(&pCopyInfo->pCopyRange);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Convert IDList to rangelist to submit to IIMAPTransport
        if (NULL != pList)
        {
            for (dw = 0; dw < pList->cMsgs; dw++)
            {
                HRESULT hrTemp;

                hrTemp = pCopyInfo->pCopyRange->AddSingleValue(PtrToUlong(pList->prgidMsg[dw]));
                TraceError(hrTemp);
            }
        }
        else
        {
            HRESULT hrTemp;

            // pList == NULL means to tackle ALL messages
            hrTemp = pCopyInfo->pCopyRange->AddRange(1, RL_LAST_MESSAGE);
            TraceError(hrTemp);
        }

        IxpAssert(SUCCEEDED(pCopyInfo->pCopyRange->Cardinality(&ul)) && ul > 0);

        // Construct destination folder path
        hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idDestFldr, &pszDestFldrPath,
            NULL, NULL, m_pStore, NULL, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Send command to server
        hr = _EnqueueOperation(tidCOPYMSGS, (LPARAM) pCopyInfo, icCOPY_COMMAND,
            pszDestFldrPath, uiNORMAL_PRIORITY);
        MemFree(pszDestFldrPath);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // This is a standard (download from src-save to dest) copy: let caller do it
        hr = STORE_E_NOSERVERCOPY;
        goto exit; // Don't record this error value, it's expected
    }

exit:
    if (fFreeFldrInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_COPYMOVE_MESSAGE, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::DeleteMessages(DELETEMESSAGEFLAGS dwOptions,
                                                    LPMESSAGEIDLIST pList,
                                                    IStoreCallback *pCallback)
{
    ADJUSTFLAGS afFlags;
    HRESULT     hr;

    TraceCall("CIMAPSync::DeleteMessages");
    AssertSingleThreaded;
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    // This function currently only supports IMAP deletion model. Trashcan NYI.

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (dwOptions & DELETE_MESSAGE_UNDELETE)
    {
        afFlags.dwAdd = 0;
        afFlags.dwRemove = ARF_ENDANGERED;
    }
    else
    {
        afFlags.dwAdd = ARF_ENDANGERED;
        afFlags.dwRemove = 0;
    }

    hr = _SetMessageFlags(SOT_DELETING_MESSAGES, pList, &afFlags, pCallback);
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_DELETING_MESSAGES, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SynchronizeStore(FOLDERID idParent,
                                    DWORD dwFlags,
                                    IStoreCallback *pCallback)
{
    HRESULT hr = S_OK;

    TraceCall("CIMAPSync::SynchronizeStore");
    AssertSingleThreaded;

    IxpAssert(SOT_INVALID == m_sotCurrent);
    IxpAssert(NULL == m_pCurrentCB);

    // This function currently ignores the dwFlags argument
    m_cFolders = 0;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Force mailbox translation since we only issue LIST *
    hr = SetTranslationMode(FOLDERID_INVALID);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);
    m_sotCurrent = SOT_SYNCING_STORE;
    m_pCurrentCB = pCallback;
    if (NULL != pCallback)
        pCallback->AddRef();

    hr = CreateFolderHash(m_pStore, m_idIMAPServer, &m_pCurrentHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = MimeOleCreateHashTable(CHASH_BUCKETS, TRUE, &m_pListHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
    {
        // Set us up to find out root hierarchy char
        m_phcfHierarchyCharInfo = new HIERARCHY_CHAR_FINDER;
        if (NULL == m_phcfHierarchyCharInfo)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        ZeroMemory(m_phcfHierarchyCharInfo, sizeof(HIERARCHY_CHAR_FINDER));
    }

    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, sizeof(m_szRootFolderPrefix));

    hr = _StartFolderList((LPARAM)FOLDERID_INVALID);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }


exit:
    if (FAILED(hr))
    {
        m_sotCurrent = SOT_INVALID;
        m_pCurrentCB = NULL;
        m_fTerminating = FALSE;
        if (NULL != pCallback)
            pCallback->Release();
    }
    else
        hr = _BeginOperation(m_sotCurrent, m_pCurrentCB);

    return hr;
} // SynchronizeStore



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CreateFolder(FOLDERID idParent,
                                SPECIALFOLDER tySpecial,
                                LPCSTR pszName,
                                FLDRFLAGS dwFlags,
                                IStoreCallback *pCallback)
{
    HRESULT             hr;
    CHAR                chHierarchy;
    LPSTR               pszFullPath=NULL;
    CREATE_FOLDER_INFO  *pcfi=NULL;
    DWORD               dwFullPathLen;
    LPSTR               pszEnd;

    TraceCall("CIMAPSync::CreateFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Validate folder name
    hr = CheckFolderNameValidity(pszName);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idParent);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_FALSE == hr)
    {
        // Parent not translatable from UTF7. In such a case, we only allow creation
        // if child foldername is composed ENTIRELY of USASCII
        if (FALSE == isUSASCIIOnly(pszName))
        {
            // We can't create this folder: parent prohibits UTF7 translation
            hr = TraceResult(STORE_E_NOTRANSLATION);
            goto exit;
        }
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idParent, &pszFullPath, &dwFullPathLen,
        &chHierarchy, m_pStore, pszName, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pcfi = new CREATE_FOLDER_INFO;
    if (NULL == pcfi)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Fill in all the fields
    pcfi->pszFullFolderPath = pszFullPath;
    pcfi->idFolder = FOLDERID_INVALID;
    pcfi->dwFlags = 0;
    pcfi->csfCurrentStage = CSF_INIT;
    pcfi->dwCurrentSfType = FOLDER_NOTSPECIAL;
    pcfi->dwFinalSfType = FOLDER_NOTSPECIAL;
    pcfi->lParam = NULL;
    pcfi->pcoNextOp = PCO_NONE;

    // Send the CREATE command
    hr = _EnqueueOperation(tidCREATE, (LPARAM)pcfi, icCREATE_COMMAND, pszFullPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If there is a trailing HC (required to create folder-bearing folders on UW IMAP),
    // remove it from pszFullPath so that LIST and SUBSCRIBE do not carry it (IE5 bug #60054)
    pszEnd = CharPrev(pszFullPath, pszFullPath + dwFullPathLen);
    if (chHierarchy == *pszEnd)
    {
        *pszEnd = '\0';
        Assert(*CharPrev(pszFullPath, pszEnd) != chHierarchy); // Shouldn't get > 1 HC at end
    }

exit:
    if (FAILED(hr))
    {
        SafeMemFree(pszFullPath);
        delete pcfi;
    }
    else
        hr = _BeginOperation(SOT_CREATE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::MoveFolder(FOLDERID idFolder,
                                                FOLDERID idParentNew,
                                                IStoreCallback *pCallback)
{
    HRESULT hr;

    TraceCall("CIMAPSync::MoveFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = TraceResult(E_NOTIMPL);

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_MOVE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::RenameFolder(FOLDERID idFolder,
                                LPCSTR pszName,
                                IStoreCallback *pCallback)
{
    HRESULT     hr;
    FOLDERINFO  fiFolderInfo;
    LPSTR       pszOldPath = NULL;
    LPSTR       pszNewPath = NULL;
    char        chHierarchy;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Validate folder name
    hr = CheckFolderNameValidity(pszName);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_FALSE == hr)
    {
        // Folder not translatable from UTF7. In such a case, we only allow creation
        // if new foldername is composed ENTIRELY of USASCII. A bit conservative, yes
        // (if leaf node is only un-translatable part, we COULD rename), but I'm too
        // lazy to check for FOLDER_NOTRANSLATEUTF7 all the way to server node.
        if (FALSE == isUSASCIIOnly(pszName))
        {
            // We can't rename this folder: we assume parents prohibit UTF7 translation
            hr = TraceResult(STORE_E_NOTRANSLATION);
            goto exit;
        }
    }

    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check validity
    fFreeInfo = TRUE;
    IxpAssert(FOLDER_NOTSPECIAL == fiFolderInfo.tySpecial);
    IxpAssert('\0' != fiFolderInfo.pszName);
    IxpAssert('\0' != pszName);
    if (0 == lstrcmp(fiFolderInfo.pszName, pszName))
    {
        hr = E_INVALIDARG; // Nothing to do! Return error.
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszOldPath, NULL,
        &chHierarchy, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, fiFolderInfo.idParent, &pszNewPath,
        NULL, &chHierarchy, m_pStore, pszName, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = RenameFolderHelper(idFolder, pszOldPath, chHierarchy, pszNewPath);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_RENAME_FOLDER, pCallback);

    SafeMemFree(pszOldPath);
    SafeMemFree(pszNewPath);

    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::DeleteFolder(FOLDERID idFolder,
                                DELETEFOLDERFLAGS dwFlags,
                                IStoreCallback *pCallback)
{
    HRESULT             hr;
    DELETE_FOLDER_INFO *pdfi = NULL;
    LPSTR               pszPath = NULL;
    CHAR                chHierarchy;

    TraceCall("CIMAPSync::DeleteFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL,
        &chHierarchy, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a CreateFolderInfo structure
    if (!MemAlloc((LPVOID *)&pdfi, sizeof(DELETE_FOLDER_INFO)))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pdfi->pszFullFolderPath = pszPath;
    pdfi->cHierarchyChar = chHierarchy;
    pdfi->idFolder = idFolder;

    // Send the DELETE command
    hr = _EnqueueOperation(tidDELETEFLDR, (LPARAM)pdfi, icDELETE_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (FAILED(hr))
    {
        SafeMemFree(pszPath);
        SafeMemFree(pdfi);
    }
    else
        hr = _BeginOperation(SOT_DELETE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SubscribeToFolder(FOLDERID idFolder,
                                     BOOL fSubscribe,
                                     IStoreCallback *pCallback)
{
    HRESULT hr;
    LPSTR   pszPath = NULL;

    TraceCall("CIMAPSync::SubscribeToFolder");
    AssertSingleThreaded;
    IxpAssert(FOLDERID_INVALID == m_idCurrent);
    IxpAssert(FALSE == m_fSubscribe);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL, NULL,
        m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Send the SUBSCRIBE/UNSUBSCRIBE command
    m_idCurrent = idFolder;
    m_fSubscribe = fSubscribe;
    hr = _EnqueueOperation(tidSUBSCRIBE, 0, fSubscribe ? icSUBSCRIBE_COMMAND :
        icUNSUBSCRIBE_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszPath);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SUBSCRIBE_FOLDER, pCallback);

    return hr;
}


//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT     hr;
    LPSTR       pszPath = NULL;
    DWORD       dwCapabilities;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeFldrInfo = FALSE;

    TraceCall("CIMAPSync::GetFolderCounts");
    AssertSingleThreaded;
    IxpAssert(FOLDERID_INVALID != idFolder);
    IxpAssert(NULL != pCallback);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Perform some verification: folder cannot be \NoSelect, server must be IMAP4rev1
    // Unfortunately, we can't get capability unless we're currently connected
    hr = m_pTransport->IsState(IXP_IS_AUTHENTICATED);
    if (S_OK == hr)
    {
        hr = m_pTransport->Capability(&dwCapabilities);
        if (SUCCEEDED(hr) && 0 == (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1))
        {
            // This server does not support STATUS command, we don't support alternate
            // method of unread count update (eg, EXAMINE folder)
            hr = E_NOTIMPL;
            goto exit;
        }
    }
    // If not connected then we'll check capabilities during connection

    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        fFreeFldrInfo = TRUE;
        if (fiFolderInfo.dwFlags & (FOLDER_NOSELECT | FOLDER_NONEXISTENT))
        {
            // This folder cannot have an unread count because it cannot contain messages
            hr = TraceResult(STORE_E_NOSERVERSUPPORT);
            goto exit;
        }
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL, NULL,
        m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, sizeof(m_szRootFolderPrefix));
    hr = LoadSaveRootHierarchyChar(fLOAD_HC);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Send the STATUS command
    hr = _EnqueueOperation(tidSTATUS, (LPARAM)idFolder, icSTATUS_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszPath);
    if (fFreeFldrInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_UPDATE_FOLDER, pCallback);

    return hr;
}

STDMETHODIMP CIMAPSync::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}



HRESULT STDMETHODCALLTYPE CIMAPSync::ExpungeOnExit(void)
{
    HWND    hwndParent;
    HRESULT hrResult = S_OK;

    // Check if user wants us to purge on exit (only if no operations in progress)
    if (DwGetOption(OPT_IMAPPURGE))
    {
        hrResult = GetParentWindow(0, &hwndParent);
        if (SUCCEEDED(hrResult))
        {
            hrResult = PurgeMessageProgress(hwndParent);
            TraceError(hrResult);
        }
    }

    return hrResult;
} // ExpungeOnExit



HRESULT CIMAPSync::Cancel(CANCELTYPE tyCancel)
{
    // $TODO: Translate tyCancel into an HRESULT to return to the caller
    FlushOperationQueue(issNotConnected, STORE_E_OPERATION_CANCELED);
    _Disconnect();

    // The m_hrOperationResult and m_szOperationDetails/m_szOperationProblem
    // vars can be blown away by by _OnCmdComplete caused by disconnect
    m_hrOperationResult = STORE_E_OPERATION_CANCELED;

    // Verify that we are indeed terminating current operation: if not, FORCE IT!
    if (FALSE == m_fTerminating)
    {
        HRESULT hrTemp;

        IxpAssert(FALSE); // This should not happen: fix the problem
        hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_ERROR);
        TraceError(hrTemp);
    }

    return S_OK;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//***************************************************************************
//***************************************************************************

HRESULT CIMAPSync::_LoadAccountInfo()
{
    HRESULT         hr;
    FOLDERINFO      fi;
    FOLDERINFO      *pfiFree=NULL;
    IImnAccount     *pAcct=NULL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    TraceCall("CIMAPSync::_LoadAccountInfo");

    IxpAssert (m_idIMAPServer);
    IxpAssert (m_pStore);
    IxpAssert (g_pAcctMan);

    hr = m_pStore->GetFolderInfo(m_idIMAPServer, &fi);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    hr = GetFolderAccountId(&fi, szAccountId);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    m_pszAccountID = PszDupA(szAccountId);
    if (!m_pszAccountID)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // failure of the account name is recoverable
    pAcct->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName, sizeof(m_szAccountName));

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    ReleaseObj(pAcct);
    return hr;
}

HRESULT CIMAPSync::_LoadTransport()
{
    HRESULT             hr;
    TCHAR               szLogfilePath[MAX_PATH];
    TCHAR              *pszLogfilePath = NULL;
    IImnAccount        *pAcct=NULL;

    TraceCall("CIMAPSync::_LoadTransport");

    IxpAssert (g_pAcctMan);
    IxpAssert (m_pszAccountID);

    // Create and initialize IMAP transport
    hr = CreateIMAPTransport2(&m_pTransport);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check if logging is enabled
    if (DwGetOption(OPT_MAIL_LOGIMAP4))
    {
        char    szDirectory[MAX_PATH];
        char    szLogFileName[MAX_PATH];
        DWORD   cb;

        *szDirectory = 0;

        // Get the log filename
        cb = GetOption(OPT_MAIL_IMAP4LOGFILE, szLogFileName, sizeof(szLogFileName)/sizeof(TCHAR));
        if (0 == cb)
        {
            // Bring out the defaults, and blast it back into registry
            lstrcpy(szLogFileName, c_szDefaultImap4Log);
            SetOption(OPT_MAIL_IMAP4LOGFILE, (void *)c_szDefaultImap4Log,
                        lstrlen(c_szDefaultImap4Log) + sizeof(TCHAR), NULL, 0);
        }

        m_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
        pszLogfilePath = PathCombineA(szLogfilePath, szDirectory, szLogFileName);
    }

    hr = m_pTransport->InitNew(pszLogfilePath, this);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pTransport->SetDefaultCP(IMAP_MBOXXLATE_DEFAULT | IMAP_MBOXXLATE_VERBATIMOK, GetACP());
    TraceError(hr);

    hr = m_pTransport->EnableFetchEx(IMAP_FETCHEX_ENABLE);
    if (FAILED(hr))
    {
        // It would be easy for us to add code to handle irtUPDATE_MSG, but nothing is currently in place
        TraceResult(hr);
        goto exit;
    }

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Fill m_rInetServerInfo
    hr = m_pTransport->InetServerFromAccount(pAcct, &m_rInetServerInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    ReleaseObj(pAcct);
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_Connect(void)
{
    HRESULT         hr;
    IXPSTATUS       ixpCurrentStatus;
    INETSERVER      rServerInfo;
    BOOL            fForceReconnect = FALSE;
    IImnAccount    *pAcct;
    HRESULT         hrTemp;

    TraceCall("CIMAPSync::_Connect");

    IxpAssert (m_cRef > 0);
    IxpAssert (m_pTransport);

    // Check if any connection settings changed
    hrTemp = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        hrTemp = m_pTransport->InetServerFromAccount(pAcct, &rServerInfo);
        TraceError(hrTemp);
        if (SUCCEEDED(hrTemp))
        {
            // Check if anything changed
            if (m_rInetServerInfo.rasconntype != rServerInfo.rasconntype ||
                m_rInetServerInfo.dwPort != rServerInfo.dwPort ||
                m_rInetServerInfo.fSSL != rServerInfo.fSSL ||
                m_rInetServerInfo.fTrySicily != rServerInfo.fTrySicily ||
                m_rInetServerInfo.dwTimeout != rServerInfo.dwTimeout ||
                0 != lstrcmp(m_rInetServerInfo.szUserName, rServerInfo.szUserName) ||
                ('\0' != rServerInfo.szPassword[0] &&
                    0 != lstrcmp(m_rInetServerInfo.szPassword, rServerInfo.szPassword)) ||
                0 != lstrcmp(m_rInetServerInfo.szServerName, rServerInfo.szServerName) ||
                0 != lstrcmp(m_rInetServerInfo.szConnectoid, rServerInfo.szConnectoid))
            {
                CopyMemory(&m_rInetServerInfo, &rServerInfo, sizeof(m_rInetServerInfo));
                fForceReconnect = TRUE;
            }
        }
        pAcct->Release();
    }

    // Find out if we're already connected or in the middle of connecting
    hr = m_pTransport->GetStatus(&ixpCurrentStatus);
    if (FAILED(hr))
    {
        // We'll call IIMAPTransport::Connect and see what happens
        TraceResult(hr);
        hr = S_OK; // Suppress error
        ixpCurrentStatus = IXP_DISCONNECTED;
    }

    // If we're to force a reconnect and we're not currently disconnected, disconnect us
    if (fForceReconnect && IXP_DISCONNECTED != ixpCurrentStatus)
    {
        m_fReconnect = TRUE; // Prohibit abortion of current operation due to disconnect
        hrTemp = m_pTransport->DropConnection();
        TraceError(hrTemp);
        m_fReconnect = FALSE;
    }

    // Ask our client if we can connect. If no CB or if failure, we just try to connect
    // Make sure we call CanConnect after DropConnection above, to avoid msg pumping
    if (NULL != m_pCurrentCB)
    {
        hr = m_pCurrentCB->CanConnect(m_pszAccountID,
            SOT_PURGING_MESSAGES == m_sotCurrent ? CC_FLAG_DONTPROMPT : NOFLAGS);
        if (S_OK != hr)
        {
            // Make sure all non-S_OK success codes are treated as failures
            // Convert all error codes to HR_E_USER_CANCEL_CONNECT if we were purging-on-exit
            // This prevents error dialogs while purging-on-exit.
            hr = TraceResult(hr);
            if (SUCCEEDED(hr) || SOT_PURGING_MESSAGES == m_sotCurrent)
                hr = HR_E_USER_CANCEL_CONNECT;

            goto exit;
        }
    }

    // If we're already in the middle of connecting, do nothing and return successful HRESULT
    if (IXP_DISCONNECTED == ixpCurrentStatus || IXP_DISCONNECTING == ixpCurrentStatus ||
        fForceReconnect)
    {
        // Make sure m_rInetServerInfo is loaded with latest cached password from user
        // This allows reconnect without user intervention if user didn't save password
        GetPassword(m_rInetServerInfo.dwPort, m_rInetServerInfo.szServerName,
            m_rInetServerInfo.szUserName, m_rInetServerInfo.szPassword,
            sizeof(m_rInetServerInfo.szPassword));

        // We're neither connected nor in the process of connecting: start connecting
        hr = m_pTransport->Connect(&m_rInetServerInfo, iitAUTHENTICATE, iitDISABLE_ONCOMMAND);
    }
    else
    {
        // "Do Nothing" in the comment above now means to kick the FSM to the next state
        hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_CONNCOMPLETE);
        TraceError(hrTemp);
    }

exit:
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_Disconnect(void)
{
    HRESULT hr;
    IXPSTATUS   ixpCurrentStatus;

    TraceCall("CIMAPSync::_Disconnect");
    IxpAssert(m_cRef > 0);

    // Find out if we're already disconnected or in the middle of disconnecting
    hr = m_pTransport->GetStatus(&ixpCurrentStatus);
    if (FAILED(hr))
    {
        // We'll call IIMAPTransport::DropConnection and see what happens
        TraceResult(hr);
        hr = S_OK; // Suppress error
        ixpCurrentStatus = IXP_CONNECTED;
    }

    // If we're already in the middle of disconnecting, do nothing and return successful HRESULT
    if (IXP_DISCONNECTED != ixpCurrentStatus &&
        IXP_DISCONNECTING != ixpCurrentStatus && NULL != m_pTransport && FALSE == m_fDisconnecting)
    {
        m_fDisconnecting = TRUE;
        m_hrOperationResult = STORE_E_OPERATION_CANCELED;
        hr = m_pTransport->DropConnection();
    }

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_BeginOperation(STOREOPERATIONTYPE sotOpType,
                                   IStoreCallback *pCallback)
{
    HRESULT             hr;
    STOREOPERATIONINFO  soi;
    STOREOPERATIONINFO  *psoi=NULL;

    IxpAssert(SOT_INVALID != sotOpType);

    m_sotCurrent = sotOpType;
    ReplaceInterface(m_pCurrentCB, pCallback);
    m_hrOperationResult = OLE_E_BLANK; // Unitialized state
    m_szOperationProblem[0] = '\0';
    m_szOperationDetails[0] = '\0';
    m_fTerminating = FALSE;

    // Kickstart the connection state machine
    hr = _ConnFSM_QueueEvent(CFSM_EVENT_CMDAVAIL);
    if (FAILED(hr))
    {
        TraceResult(hr);
    }
    else
    {
        if (sotOpType == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.cbSize = sizeof(STOREOPERATIONINFO);
            soi.idMessage = m_idMessage;
            psoi = &soi;
        }

        if (pCallback)
            pCallback->OnBegin(sotOpType, psoi, this);

        hr = E_PENDING;
    }

    return hr;
}



//***************************************************************************
// Function: _EnqueueOperation
//
// Purpose:
//   This function enqueues IMAP operations for execution once we have
// entered the SELECTED state on the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - transaction ID identifying this operation.
//     This ID is always returned to CmdCompletionNotification, and possibly
//     returned to any untagged responses which result from the given cmd.
//   LPARAM lParam [in] - lParam associated with this transaction.
//   IMAP_COMMAND icCommandID [in] - this identifies the IMAP command the
//     caller wishes to send to the IMAP server.
//   LPSTR pszCmdArgs [in] - the command arguments. Pass in NULL if the
//     queued command has no arguments.
//   UINT uiPriority [in] - a priority associated with this IMAP command.
//     The value of "0" is highest priority. Before an IMAP command of
//     a given priority can be sent, there must be NO higher-priority cmds
//     waiting.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::_EnqueueOperation(WPARAM wParam, LPARAM lParam,
                                    IMAP_COMMAND icCommandID, LPCSTR pszCmdArgs,
                                    UINT uiPriority)
{
    IMAP_OPERATION *pioCommand;
    IMAP_OPERATION *pioPrev, *pioCurrent;
    HRESULT         hr = S_OK;

    TraceCall("CIMAPSync::_EnqueueOperation");
    IxpAssert(m_cRef > 0);

    // Construct a IMAP_OPERATION queue element for this command
    pioCommand = new IMAP_OPERATION;
    if (NULL == pioCommand)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }
    pioCommand->wParam = wParam;
    pioCommand->lParam = lParam;
    pioCommand->icCommandID = icCommandID;
    pioCommand->pszCmdArgs = PszDupA(pszCmdArgs);
    pioCommand->uiPriority = uiPriority;
    pioCommand->issMinimum = IMAPCmdToMinISS(icCommandID);
    IxpAssert(pioCommand->issMinimum >= issNonAuthenticated);

    // Refcount if this is a streamed operation
    if (tidRENAME == wParam ||
        tidRENAMESUBSCRIBE == wParam ||
        tidRENAMELIST == wParam ||
        tidRENAMERENAME == wParam ||
        tidRENAMESUBSCRIBE_AGAIN == wParam ||
        tidRENAMEUNSUBSCRIBE == wParam)
        ((CRenameFolderInfo *)lParam)->AddRef();

    // Insert element into the queue
    // Find a node which has lower priority than the cmd we want to enqueue
    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;
    while (NULL != pioCurrent && pioCurrent->uiPriority <= uiPriority)
    {
        // Advance both pointers
        pioPrev = pioCurrent;
        pioCurrent = pioCurrent->pioNextCommand;
    }

    // pioPrev now points to the insertion point
    if (NULL == pioPrev)
    {
        // Insert command at head of queue
        pioCommand->pioNextCommand = m_pioNextOperation;
        m_pioNextOperation = pioCommand;
    }
    else {
        // Insert command in middle/end of queue
        pioCommand->pioNextCommand = pioCurrent;
        pioPrev->pioNextCommand = pioCommand;
    }

    // Try to send immediately if we're in correct state
    if (CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState)
    {
        do {
            hr = _SendNextOperation(snoDO_NOT_DISPOSE);
            TraceError(hr);
        } while (S_OK == hr);
    }

exit:
    return hr;
}



//***************************************************************************
// Function: _SendNextOperation
//
// Purpose:
//   This function sends the next IMAP operation in the queue if the
// conditions are correct. Currently, these conditions are:
//     a) We are in the SELECTED state on the IMAP server
//     b) The IMAP operation queue is not empty
//
// Arguments:
//    DWORD dwFlags [in] - one of the following:
//      snoDO_NOT_DISPOSE - do not dispose of LPARAM if error occurs, typically
//        because EnqueueOperation will return error to caller thus causing
//        caller to dispose of data.
//
// Returns:
//   S_OK if there are more operations available to be sent. S_FALSE if no more
// IMAP operations can be sent at this time. Failure result if an error occured.
//***************************************************************************
HRESULT CIMAPSync::_SendNextOperation(DWORD dwFlags)
{
    IMAP_OPERATION *pioNextCmd;
    IMAP_OPERATION *pioPrev;
    HRESULT         hr;

    TraceCall("CIMAPSync::_SendNextOperation");
    IxpAssert(m_cRef > 0);

    // Check if conditions permit sending of an IMAP operation
    hr = m_pTransport->IsState(IXP_IS_AUTHENTICATED);
    if (S_OK != hr)
    {
        hr = S_FALSE; // No operations to send (YET)
        goto exit;
    }

    // Look for next eligible command
    hr = GetNextOperation(&pioNextCmd);
    if (STORE_S_NOOP == hr || FAILED(hr))
    {
        TraceError(hr);
        hr = S_FALSE;
        goto exit;
    }

    // Send it
    hr = S_OK;
    switch (pioNextCmd->icCommandID)
    {
        case icFETCH_COMMAND:
        {
            LPSTR pszFetchArgs;
            char szFetchArgs[CCHMAX_CMDLINE];

            // Check if this is a BODY FETCH. We have to construct args for body fetch
            if (tidBODY == pioNextCmd->wParam)
            {
                DWORD dwCapabilities;

                // Check if this is IMAP4 or IMAP4rev1 (RFC822.PEEK or BODY.PEEK[])
                IxpAssert(NULL == pioNextCmd->pszCmdArgs);
                hr = m_pTransport->Capability(&dwCapabilities);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    dwCapabilities = IMAP_CAPABILITY_IMAP4; // Carry on assuming IMAP4
                }

                wsprintf(szFetchArgs, "%lu (%s UID)", pioNextCmd->lParam,
                    (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1) ? "BODY.PEEK[]" : "RFC822.PEEK");
                pszFetchArgs = szFetchArgs;
            }
            else
            {
                IxpAssert(NULL != pioNextCmd->pszCmdArgs);
                pszFetchArgs = pioNextCmd->pszCmdArgs;
            }

            hr = m_pTransport->Fetch(pioNextCmd->wParam, pioNextCmd->lParam,
                this, NULL, USE_UIDS, pszFetchArgs); // We always use UIDs
            TraceError(hr);
        }
            break;

        case icSTORE_COMMAND:
        {
            MARK_MSGS_INFO   *pMARK_MSGS_INFO;

            pMARK_MSGS_INFO = (MARK_MSGS_INFO *) pioNextCmd->lParam;
            IxpAssert(tidMARKMSGS == pioNextCmd->wParam);
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            hr = m_pTransport->Store(pioNextCmd->wParam,
                pioNextCmd->lParam, this, pMARK_MSGS_INFO->pMsgRange,
                USE_UIDS, pioNextCmd->pszCmdArgs); // We always use UIDs
            TraceError(hr);
        }
        break;

        case icCOPY_COMMAND:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) pioNextCmd->lParam;
            IxpAssert(NULL != pCopyMoveInfo->pCopyRange);

            // Find out what translation mode we should be in
            hr = SetTranslationMode(pCopyMoveInfo->idDestFldr);
            if (FAILED(hr))
            {
                TraceResult(hr);
                break;
            }

            hr = m_pTransport->Copy(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pCopyMoveInfo->pCopyRange,
                USE_UIDS, pioNextCmd->pszCmdArgs); // We always use UIDs
            TraceError(hr);
        }
            break; // icCOPY_COMMAND

        case icCLOSE_COMMAND:
            IxpAssert(NULL == pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Close(pioNextCmd->wParam, pioNextCmd->lParam, this);
            TraceError(hr);
            break;

        case icAPPEND_COMMAND:
        {
            APPEND_SEND_INFO *pAppendInfo;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pAppendInfo = (APPEND_SEND_INFO *) pioNextCmd->lParam;
            hr = m_pTransport->Append(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs, pAppendInfo->pszMsgFlags,
                pAppendInfo->ftReceived, pAppendInfo->lpstmMsg);
            TraceError(hr);
        }
            break; // case icAPPEND_COMMAND

        case icLIST_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->List(pioNextCmd->wParam, pioNextCmd->lParam,
                this, "", pioNextCmd->pszCmdArgs); // Reference is always blank
            TraceError(hr);
            break; // case icLIST_COMMAND

        case icLSUB_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Lsub(pioNextCmd->wParam, pioNextCmd->lParam,
                this, "", pioNextCmd->pszCmdArgs); // Reference is always blank
            TraceError(hr);
            break; // case icLSUB_COMMAND

        case icCREATE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);

            hr = m_pTransport->Create(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icCREATE_COMMAND

        case icSUBSCRIBE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Subscribe(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icSUBSCRIBE_COMMAND

        case icDELETE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Delete(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icDELETE_COMMAND

        case icUNSUBSCRIBE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Unsubscribe(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icUNSUBSCRIBE_COMMAND

        case icRENAME_COMMAND:
        {
            CRenameFolderInfo *pRenameInfo;
            LPSTR pszOldFldrName;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pRenameInfo = (CRenameFolderInfo *) pioNextCmd->lParam;
            hr = m_pTransport->Rename(pioNextCmd->wParam, (LPARAM) pRenameInfo,
                this, pRenameInfo->pszRenameCmdOldFldrPath, pioNextCmd->pszCmdArgs);
            TraceError(hr);
        } // case icRENAME_COMMAND
            break; // case icRENAME_COMMAND

        case icSTATUS_COMMAND:
        {
            DWORD dwCapabilities;

            IxpAssert(FOLDERID_INVALID != (FOLDERID)pioNextCmd->lParam);

            // Have to check if this is an IMAP4rev1 server. If not, FAIL the Status operation
            hr = m_pTransport->Capability(&dwCapabilities);
            if (SUCCEEDED(hr) && 0 == (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1))
            {
                // Can't currently check unread count for non-IMAP4rev1 servers
                hr = STORE_E_NOSERVERSUPPORT;
            }
            else
            {
                hr = m_pTransport->Status(pioNextCmd->wParam, pioNextCmd->lParam,
                    this, pioNextCmd->pszCmdArgs, "(MESSAGES UNSEEN)");
            }
        }
            break;

        default:
            AssertSz(FALSE, "Someone queued an operation I can't handle!");
            break;
    }

    // Handle any errors encountered above
    if (FAILED(hr))
    {
        TraceResult(hr);

        // Free any non-NULL lParam's and call IStoreCallback::OnComplete
        if (0 == (dwFlags & snoDO_NOT_DISPOSE))
        {
            if ('\0' == m_szOperationDetails)
                // Fill in error information: error propagation causes IStoreCallback::OnComplete call
                LoadString(g_hLocRes, idsIMAPSendNextOpErrText, m_szOperationDetails,
                    sizeof(m_szOperationDetails));

            DisposeOfWParamLParam(pioNextCmd->wParam, pioNextCmd->lParam, hr);
        }
    }

    // Deallocate the imap operation
    if (NULL != pioNextCmd->pszCmdArgs)
        MemFree(pioNextCmd->pszCmdArgs);

    delete pioNextCmd;

exit:
    return hr;
}



//***************************************************************************
// Function: FlushOperationQueue
//
// Purpose:
//   This function frees the entire contents of the IMAP operation queue.
// Usually used by the CIMAPSync destructor, and whenever an error occurs
// which would prevent the sending of queued IMAP operations (eg, login
// failure).
//
// Arguments:
//   IMAP_SERVERSTATE issMaximum [in] - defines the maximum server state
//     currently allowed in the queue. For instance, if a select failed,
//     we would call FlushOperationQueue(issAuthenticated) to remove all
//     commands that require issSelected as their minimum state. To remove
//     all commands, pass in issNotConnected.
//***************************************************************************
void CIMAPSync::FlushOperationQueue(IMAP_SERVERSTATE issMaximum, HRESULT hrError)
{
    IMAP_OPERATION *pioCurrent;
    IMAP_OPERATION *pioPrev;

    IxpAssert(((int) m_cRef) >= 0); // Can be called by destructor

    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;
    while (NULL != pioCurrent)
    {
        // Check if current command should be deleted
        if (pioCurrent->issMinimum > issMaximum)
        {
            IMAP_OPERATION *pioDead;
            HRESULT         hr;

            // Current command level exceeds the maximum. Unlink from queue and delete
            pioDead = pioCurrent;
            if (NULL == pioPrev)
            {
                // Dequeue from head of queue
                m_pioNextOperation = pioCurrent->pioNextCommand;
                pioCurrent = pioCurrent->pioNextCommand;
            }
            else
            {
                // Dequeue from mid/end of queue
                pioPrev->pioNextCommand = pioCurrent->pioNextCommand;
                pioCurrent = pioCurrent->pioNextCommand;
            }

            // Free any non-NULL lParam's and call IStoreCallback::OnComplete
            if ('\0' == m_szOperationDetails)
                // Fill in error information: error propagation causes IStoreCallback::OnComplete call
                LoadString(g_hLocRes, idsIMAPSendNextOpErrText, m_szOperationDetails,
                    sizeof(m_szOperationDetails));

            DisposeOfWParamLParam(pioDead->wParam, pioDead->lParam, hrError);

            if (NULL != pioDead->pszCmdArgs)
                MemFree(pioDead->pszCmdArgs);

            delete pioDead;
        }
        else
        {
            // Current command is within maximum level. Advance pointers
            pioPrev = pioCurrent;
            pioCurrent = pioCurrent->pioNextCommand;
        }
    } // while

} // FlushOperationQueue



//***************************************************************************
//***************************************************************************
IMAP_SERVERSTATE CIMAPSync::IMAPCmdToMinISS(IMAP_COMMAND icCommandID)
{
    IMAP_SERVERSTATE    issResult;

    TraceCall("CIMAPSync::IMAPCmdToMinISS");
    switch (icCommandID)
    {
        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
        case icCREATE_COMMAND:
        case icDELETE_COMMAND:
        case icRENAME_COMMAND:
        case icSUBSCRIBE_COMMAND:
        case icUNSUBSCRIBE_COMMAND:
        case icLIST_COMMAND:
        case icLSUB_COMMAND:
        case icAPPEND_COMMAND:
        case icSTATUS_COMMAND:
            issResult = issAuthenticated;
            break;

        case icCLOSE_COMMAND:
        case icSEARCH_COMMAND:
        case icFETCH_COMMAND:
        case icSTORE_COMMAND:
        case icCOPY_COMMAND:
            issResult = issSelected;
            break;

        default:
            AssertSz(FALSE, "What command are you trying to send?");

            // *** FALL THROUGH ***

        case icLOGOUT_COMMAND:
        case icNOOP_COMMAND:
            issResult = issNonAuthenticated;
            break;
    }

    return issResult;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetNextOperation(IMAP_OPERATION **ppioOp)
{
    HRESULT         hr = S_OK;
    IMAP_OPERATION *pioCurrent;
    IMAP_OPERATION *pioPrev;

    TraceCall("CIMAPSync::GetNextOperation");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != ppioOp);

    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;

    while (NULL != pioCurrent)
    {
        // Check if we are able to send the current command
        if (pioCurrent->issMinimum <= m_issCurrent)
            break;

        // Advance pointers
        pioPrev = pioCurrent;
        pioCurrent = pioCurrent->pioNextCommand;
    }

    // Check if we found anything
    if (NULL == pioCurrent)
    {
        hr = STORE_S_NOOP; // Nothing to send at the moment
        goto exit;
    }

    // If we reached here, we found something. Dequeue operation.
    *ppioOp = pioCurrent;
    if (NULL == pioPrev)
    {
        // Dequeue from head of queue
        m_pioNextOperation = pioCurrent->pioNextCommand;
    }
    else
    {
        // Dequeue from mid/end of queue
        pioPrev->pioNextCommand = pioCurrent->pioNextCommand;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: DisposeofWParamLParam
//
// Purpose:
//   This function eliminates the wParam and lParam arguments of an IMAP
// operation in the event of failure.
//
// Arguments:
//   WPARAM wParam - the wParam of the failed IMAP operation.
//   LPARAM lPAram - the lParam of the failed IMAP operation.
//   HRESULT hr - the error condition that caused the IMAP op failure
//***************************************************************************
void CIMAPSync::DisposeOfWParamLParam(WPARAM wParam, LPARAM lParam, HRESULT hr)
{
    TraceCall("CIMAPSync::DisposeofWParamLParam");
    IxpAssert(m_cRef > 0);
    AssertSz(FAILED(hr), "If you didn't fail, why are you here?");

    switch (wParam)
    {
        case tidCOPYMSGS:
        case tidMOVEMSGS:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo;

            // Notify the user that the operation has failed, and free the structure
            pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) lParam;

            SafeMemFree(pCopyMoveInfo->pList);
            pCopyMoveInfo->pCopyRange->Release();
            delete pCopyMoveInfo;
            break;
        }

        case tidBODYMSN:
        case tidBODY:
            LoadString(g_hLocRes, idsIMAPBodyFetchFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            NotifyMsgRecipients(lParam, fCOMPLETED, NULL, hr, m_szOperationProblem);
            break; // case tidBODYMSN, tidBODY

        case tidMARKMSGS:
        {
            MARK_MSGS_INFO   *pMarkMsgInfo;

            // Notify the user that the operation has failed, and free the structure
            pMarkMsgInfo = (MARK_MSGS_INFO *) lParam;

            SafeMemFree(pMarkMsgInfo->pList);
            SafeRelease(pMarkMsgInfo->pMsgRange);
            delete pMarkMsgInfo;
            break;
        }
            break; // case tidMARKMSGS

        case tidFETCH_NEW_HDRS:
            IxpAssert(lParam == NULL);
            break;

        case tidFETCH_CACHED_FLAGS:
            IxpAssert(lParam == NULL);
            break;

        case tidNOOP:
            IxpAssert(lParam == NULL);
            break;

        case tidSELECTION:
            IxpAssert(lParam != NULL);
            break;

        case tidUPLOADMSG:
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;

            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);
            delete pAppendInfo;
        }
            break;

        case tidCREATE:
        case tidCREATELIST:
        case tidCREATESUBSCRIBE:
        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
        case tidSPECIALFLDRSUBSCRIBE:
        {
            CREATE_FOLDER_INFO *pcfiCreateInfo;

            pcfiCreateInfo = (CREATE_FOLDER_INFO *) lParam;

            MemFree(pcfiCreateInfo->pszFullFolderPath);
            if (NULL != pcfiCreateInfo->lParam)
            {
                switch (pcfiCreateInfo->pcoNextOp)
                {
                    case PCO_NONE:
                        AssertSz(FALSE, "Expected NULL lParam. Check for memleak.");
                        break;

                    case PCO_FOLDERLIST:
                        AssertSz(FOLDERID_INVALID == (FOLDERID) pcfiCreateInfo->lParam,
                            "Expected FOLDERID_INVALID lParam. Check for memleak.");
                        break;

                    case PCO_APPENDMSG:
                    {
                        APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) pcfiCreateInfo->lParam;

                        SafeMemFree(pAppendInfo->pszMsgFlags);
                        SafeRelease(pAppendInfo->lpstmMsg);
                        delete pAppendInfo;
                    }
                        break;

                    default:
                        AssertSz(FALSE, "Unhandled CREATE_FOLDER_INFO lParam. Check for memleak.");
                        break;
                } // switch
            }
            delete pcfiCreateInfo;

            break;
        }


        case tidDELETEFLDR:
        case tidDELETEFLDR_UNSUBSCRIBE:
            MemFree(((DELETE_FOLDER_INFO *)lParam)->pszFullFolderPath);
            MemFree((DELETE_FOLDER_INFO *)lParam);
            break; // case tidDELETEFLDR_UNSUBSCRIBE

        case tidSUBSCRIBE:
            IxpAssert(NULL == lParam);
            break;

        case tidRENAME:
        case tidRENAMESUBSCRIBE:
        case tidRENAMELIST:
        case tidRENAMERENAME:
        case tidRENAMESUBSCRIBE_AGAIN:
        case tidRENAMEUNSUBSCRIBE:
            ((CRenameFolderInfo *) lParam)->Release();
            break;

        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_CREATE:
        case tidHIERARCHYCHAR_LIST_C:
        case tidHIERARCHYCHAR_DELETE:
        case tidPREFIXLIST:
        case tidPREFIX_HC:
        case tidPREFIX_CREATE:
        case tidFOLDERLIST:
        case tidFOLDERLSUB:
        case tidSTATUS:
            break;

        default:
            AssertSz(NULL == lParam, "Is this a possible memory leak?");
            break;
    }
} // DisposeOfWParamLParam



//***************************************************************************
// Function: NotifyMsgRecipients
//
// Purpose:
//   This function sends notifications to all registered recipients of a
// given message UID. Currently handles IMC_BODYAVAIL and IMC_ARTICLEPROG
// messages.
//
// Arguments:
//   DWORD dwUID [in] - the UID identifying the message whose recipients
//     are to be updated.
//   BOOL fCompletion [in] - TRUE if we're done fetching the msg body.
//     FALSE if we're still in the middle of fetching (progress indication)
//   FETCH_BODY_PART *pFBPart [in] - fragment of FETCH body currently being
//     downloaded. Should always be NULL if fCompletion is TRUE.
//   HRESULT hrCompletion [in] - completion result. Should always be S_OK
//     if fCompletion is FALSE.
//   LPSTR pszDetails [in] - error message details for completion. Should
//     always be NULL unless fCompletion is TRUE and hrCompletion is a
//     failure code.
//***************************************************************************
void CIMAPSync::NotifyMsgRecipients(DWORD_PTR dwUID, BOOL fCompletion,
                                    FETCH_BODY_PART *pFBPart,
                                    HRESULT hrCompletion, LPSTR pszDetails)
{
    HRESULT hrTemp; // For recording non-fatal errors
    ADJUSTFLAGS         flags;
    MESSAGEIDLIST       list;

    TraceCall("CIMAPSync::NotifyMsgRecipients");
    IxpAssert(m_cRef > 0);
    IxpAssert(0 != dwUID);
    AssertSz(NULL == pFBPart || FALSE == fCompletion, "pFBPart must be NULL if fCompletion TRUE!");
    AssertSz(NULL != pFBPart || fCompletion, "pFBPart cannot be NULL if fCompletion FALSE!");
    AssertSz(NULL == pszDetails || fCompletion, "pszDetails must be NULL if fCompletion FALSE!");
    AssertSz(S_OK == hrCompletion || fCompletion, "hrCompletion must be S_OK if fCompletion FALSE!");
    IxpAssert(m_pCurrentCB || fCompletion);
    IxpAssert(m_pstmBody);
    IxpAssert(m_idMessage || FALSE == fCompletion);

    // If this is a failed completion, fill out a STOREERROR struct
    if (fCompletion && FAILED(hrCompletion))
    {
        if (IS_INTRESOURCE(pszDetails))
        {
            // pszDetails is actually a string resource, so load it up
            LoadString(g_hLocRes, PtrToUlong(pszDetails), m_szOperationDetails,
                ARRAYSIZE(m_szOperationDetails));
            pszDetails = m_szOperationDetails;
        }
        LoadString(g_hLocRes, idsIMAPDnldDlgDLFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
    }

    if (fCompletion)
    {
        if (SUCCEEDED(hrCompletion))
        {
            HRESULT hr;

            hr = CommitMessageToStore(m_pFolder, NULL, m_idMessage, m_pstmBody);
            if (FAILED(hr))
            {
                TraceResult(hr);
                LoadString(g_hLocRes, idsErrSetMessageStreamFailed, m_szOperationProblem,
                    ARRAYSIZE(m_szOperationProblem));
            }
            else
                m_faStream = 0;
        }
        else if (hrCompletion == STORE_E_EXPIRED)
        {
            list.cAllocated = 0;
            list.cMsgs = 1;
            list.prgidMsg = &m_idMessage;

            flags.dwAdd = ARF_ARTICLE_EXPIRED;
            flags.dwRemove = ARF_DOWNLOAD;

            Assert(m_pFolder);
            m_pFolder->SetMessageFlags(&list, &flags, NULL, NULL);
            //m_pFolder->SetMessageStream(m_idMessage, m_pstmBody);
        }

        SafeRelease(m_pstmBody);
        if (0 != m_faStream)
        {
            Assert(m_pFolder);
            m_pFolder->DeleteStream(m_faStream);
            m_faStream = 0;
        }
    }
    else
    {
        DWORD   dwCurrent;
        DWORD   dwTotal;
        ULONG   ulWritten;

        // Write this fragment to the stream
        IxpAssert(fbpBODY == pFBPart->lpFetchCookie1);
        hrTemp = m_pstmBody->Write(pFBPart->pszData, pFBPart->dwSizeOfData, &ulWritten);
        if (FAILED(hrTemp))
            m_hrOperationResult = TraceResult(hrTemp); // Make sure we don't commit stream
        else
            IxpAssert(ulWritten == pFBPart->dwSizeOfData);

        if (pFBPart->dwSizeOfData > 0)
            m_fGotBody = TRUE;

        // Indicate message download progress
        if (pFBPart->dwTotalBytes > 0)
        {
            dwCurrent = pFBPart->dwOffset + pFBPart->dwSizeOfData;
            dwTotal = pFBPart->dwTotalBytes;
            m_pCurrentCB->OnProgress(SOT_GET_MESSAGE, dwCurrent, dwTotal, NULL);
        }
    }
} // NotifyMsgRecipients


//***************************************************************************
// Function: OnFolderExit
//
// Purpose:
//   This function is called when a folder is exited (currently occurs only
// through a disconnect). It resets the module's folder-specific variables
// so that re-connection to the folder (or a different folder) cause
// carry-over of information from the previous session.
//***************************************************************************
void CIMAPSync::OnFolderExit(void)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::OnFolderExit");
    IxpAssert(m_cRef > 0);

    m_dwMsgCount = 0;
    m_fMsgCountValid = FALSE;
    m_dwNumHdrsDLed = 0;
    m_dwNumUnreadDLed = 0;
    m_dwNumHdrsToDL = 0;
    m_dwUIDValidity = 0;
    m_dwSyncToDo = 0; // Leave m_dwSyncFolderFlags as-is, so we can re-sync on re-connect
    m_dwHighestCachedUID = 0;
    m_rwsReadWriteStatus = rwsUNINITIALIZED;
    m_fNewMail = FALSE;
    m_fInbox = FALSE;
    m_fDidFullSync = FALSE;
    m_idSelectedFolder = FOLDERID_INVALID;

    // Clear MsgSeqNumToUID table
    hrTemp = m_pTransport->ResetMsgSeqNumToUID();
    TraceError(hrTemp);
}



//***************************************************************************
//***************************************************************************
void CIMAPSync::FillStoreError(LPSTOREERROR pErrorInfo, HRESULT hr,
                               DWORD dwSocketError, LPSTR pszProblem,
                               LPSTR pszDetails)
{
    DWORD   dwFlags = 0;

    TraceCall("CIMAPSync::FillStoreError");
    IxpAssert(((int) m_cRef) >= 0); // Can be called during destruction
    IxpAssert(NULL != pErrorInfo);

    // pszProblem/pszDetails = NULL means m_szOperationProblem/m_szOperationDetails already filled out
    // Use defaults if any of the text fields are blank
    if (NULL != pszProblem && IS_INTRESOURCE(pszProblem))
    {
        LoadString(g_hLocRes, PtrToUlong(pszProblem), m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
    }
    else if (NULL != pszProblem)
    {
        if ('\0' == *pszProblem)
            LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
        else
            lstrcpyn(m_szOperationProblem, pszProblem, ARRAYSIZE(m_szOperationProblem));
    }

    if (NULL != pszDetails && IS_INTRESOURCE(pszDetails))
    {
        LoadString(g_hLocRes, PtrToUlong(pszDetails), m_szOperationDetails, ARRAYSIZE(m_szOperationDetails));
    }
    else if (NULL != pszDetails)
    {
        if ('\0' == *pszDetails)
            m_szOperationDetails[0] = '\0';
        else
            lstrcpyn(m_szOperationDetails, pszDetails, ARRAYSIZE(m_szOperationDetails));
    }

    // If we are currently disconnected, it is unlikely that any additional operations
    // should be sent to the IMAP server: there's likely a connection error or user cancellation.
    if (STORE_E_OPERATION_CANCELED == hr || m_cfsPrevState <= CFSM_STATE_WAITFORCONN)
        dwFlags |= SE_FLAG_FLUSHALL;

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    pErrorInfo->hrResult = hr;
    pErrorInfo->uiServerError = 0; // No such thing in the IMAP protocol
    pErrorInfo->hrServerError = S_OK;
    pErrorInfo->dwSocketError = dwSocketError; // Oops, not propagated in IIMAPCallback::OnResponse
    pErrorInfo->pszProblem = m_szOperationProblem;
    pErrorInfo->pszDetails = m_szOperationDetails;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "IMAP";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_IMAP;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = dwFlags;
}



//***************************************************************************
// Function: Fill_MESSAGEINFO
//
// Purpose:
//   This function is no longer largely based on (shamelessly stolen) code
// from MsgIn.Cpp's. As Brett rewrote it to use MIMEOLE. Fingers crossed, kids...
// This function takes a FETCH_CMD_RESULTS_EX struct (which MUST
// have a header or a body) and fills out a MESSAGEINFO structure based on
// the information in the header.
//
// Arguments:
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - contains the results of
//     a FETCH response. This MUST contain either a header or a body.
//   MESSAGEINFO *pMsgInfo [out] - this function fills out the given
//     MESSAGEINFO with the information from the FETCH response. Note that
//     this function zeroes the destination, so the caller need not.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::Fill_MESSAGEINFO(const FETCH_CMD_RESULTS_EX *pFetchResults,
                                    MESSAGEINFO *pMsgInfo)
{
    // Locals
    HRESULT             hr = S_OK;
    LPSTR               lpsz;
    IMimePropertySet   *pPropertySet = NULL;
    IMimeAddressTable  *pAddrTable = NULL;
    ADDRESSPROPS        rAddress;
    IMSGPRIORITY        impPriority;
    PROPVARIANT         rVariant;
    LPSTREAM            lpstmRFC822;

    TraceCall("CIMAPSync::Fill_MESSAGEINFO");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(NULL != pMsgInfo);
    IxpAssert(TRUE == pFetchResults->bUID);

    // Initialize the destination
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));

    // Fill in fields that need no thought
    pMsgInfo->pszAcctId = PszDupA(m_pszAccountID);
    pMsgInfo->pszAcctName = PszDupA(m_szAccountName);

    // Deal with the easy FETCH_CMD_RESULTS_EX fields, first
    if (pFetchResults->bUID)
        pMsgInfo->idMessage = (MESSAGEID)((ULONG_PTR)pFetchResults->dwUID);

    if (pFetchResults->bMsgFlags)
        pMsgInfo->dwFlags = DwConvertIMAPtoARF(pFetchResults->mfMsgFlags);

    if (pFetchResults->bRFC822Size)
        pMsgInfo->cbMessage = pFetchResults->dwRFC822Size;

    if (pFetchResults->bInternalDate)
        pMsgInfo->ftReceived = pFetchResults->ftInternalDate;

    if (pFetchResults->bEnvelope)
    {
        hr= ReadEnvelopeFields(pMsgInfo, pFetchResults);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Now, it's time to parse the header (or partial header, if we only asked for certain fields)
    lpstmRFC822 = (LPSTREAM) pFetchResults->lpFetchCookie2;
    if (NULL == lpstmRFC822)
    {
        if (FALSE == pFetchResults->bEnvelope)
            hr = TraceResult(E_FAIL); // Hmm, no envelope, no header... sounds like failure!

        goto exit;
    }

    hr = MimeOleCreatePropertySet(NULL, &pPropertySet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = HrRewindStream(lpstmRFC822);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // call IPS::Load on the header, and get the parsed stuff out.
    hr = pPropertySet->Load(lpstmRFC822);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Don't ask for the following basic (non-derived) fields unless we did NOT get an envelope
    if (FALSE == pFetchResults->bEnvelope)
    {
        // Don't bother tracing non-fatal errors, as not all msgs will have all properties
        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszMessageId = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszSubject = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &lpsz);
        TraceError(hr); // Actually, this is odd
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszFromHeader = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        rVariant.vt = VT_FILETIME;
        hr = pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
        if (SUCCEEDED(hr))
            CopyMemory(&pMsgInfo->ftSent, &rVariant.filetime, sizeof(FILETIME));
    }

    // The following fields are not normally supplied via envelope
    // [PaulHi] 6/10/99
    // !!!Note that the IMAP server will not include these properties in the header download
    // unless they are listed in the request string.  See cszIMAPFetchNewHdrsI4r1 string
    // declared above!!!
    hr = MimeOleGetPropA(pPropertySet, STR_HDR_XMSOESREC, NOFLAGS, &lpsz);
    TraceError(hr); // Actually, this is odd
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszMSOESRec = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszReferences = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_XREF), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszXref = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    rVariant.vt = VT_UI4;
    hr = pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
    if (SUCCEEDED(hr))
        // Convert IMSGPRIORITY to ARF_PRI_*
        pMsgInfo->wPriority = (WORD)rVariant.ulVal;

    // Make sure every basic (ie, non-derived) string field has SOMETHING
    if (NULL == pMsgInfo->pszMessageId)
        pMsgInfo->pszMessageId = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszSubject)
        pMsgInfo->pszSubject = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszFromHeader)
        pMsgInfo->pszFromHeader = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszReferences)
        pMsgInfo->pszReferences = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszXref)
        pMsgInfo->pszXref = PszDupA (c_szEmpty);


    // Now that every basic string field is non-NULL, calculate DERIVED str fields
    pMsgInfo->pszNormalSubj = SzNormalizeSubject(pMsgInfo->pszSubject);
    if (NULL == pMsgInfo->pszNormalSubj)
        pMsgInfo->pszNormalSubj = pMsgInfo->pszSubject;

    // Only calculate "To" and "From" if we did NOT get an envelope
    if (FALSE == pFetchResults->bEnvelope)
    {
        // Get an address table
        hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAddrTable);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Split "From" field into a display name and email name
        rAddress.dwProps = IAP_FRIENDLY | IAP_EMAIL;
        hr = pAddrTable->GetSender(&rAddress);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszDisplayFrom = rAddress.pszFriendly;
            pMsgInfo->pszEmailFrom = rAddress.pszEmail;
        }

        // Split "To" field into a display name and email name
        hr = pAddrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszDisplayTo = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = pAddrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszEmailTo = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }
    }

    // If "Newsgroups" field is present, it supercedes the "To" field
    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        SafeMemFree(pMsgInfo->pszDisplayTo); // Free what's already there
        pMsgInfo->pszDisplayTo = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
        pMsgInfo->dwFlags |= ARF_NEWSMSG;
    }

    // Make sure that all derived fields are non-NULL
    if (NULL == pMsgInfo->pszDisplayFrom)
        pMsgInfo->pszDisplayFrom = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszEmailFrom)
        pMsgInfo->pszEmailFrom = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszDisplayTo)
        pMsgInfo->pszDisplayTo = PszDupA(c_szEmpty);

    // OK, if we get to here, we've decided to live with errors. Suppress errors.
    hr = S_OK;

exit:
    // Cleanup
    SafeRelease(pPropertySet);
    SafeRelease(pAddrTable);

    // Done
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ReadEnvelopeFields(MESSAGEINFO *pMsgInfo,
                                      const FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT     hrResult;
    PROPVARIANT rDecoded;

    // (1) Date
    pMsgInfo->ftSent = pFetchResults->ftENVDate;

    // (2) Subject
    rDecoded.vt = VT_LPSTR;
    if (FAILED(MimeOleDecodeHeader(NULL, pFetchResults->pszENVSubject, &rDecoded, NULL)))
        pMsgInfo->pszSubject = PszDupA(pFetchResults->pszENVSubject);
    else
        pMsgInfo->pszSubject = rDecoded.pszVal;

    if (NULL == pMsgInfo->pszSubject)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // (3) From
    hrResult = ConcatIMAPAddresses(&pMsgInfo->pszDisplayFrom, &pMsgInfo->pszEmailFrom,
        pFetchResults->piaENVFrom);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (4) Sender: IGNORE
    // (5) ReplyTo: IGNORE

    // (6) To
    hrResult = ConcatIMAPAddresses(&pMsgInfo->pszDisplayTo, &pMsgInfo->pszEmailTo,
        pFetchResults->piaENVTo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (7) Cc: IGNORE
    // (8) Bcc: IGNORE
    // (9) In-Reply-To: IGNORE

    // (10) MessageID
    pMsgInfo->pszMessageId = PszDupA(pFetchResults->pszENVMessageID);
    if (NULL == pMsgInfo->pszMessageId)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    return hrResult;
} // ReadEnvelopeFields



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ConcatIMAPAddresses(LPSTR *ppszDisplay, LPSTR *ppszEmailAddr,
                                       IMAPADDR *piaIMAPAddr)
{
    HRESULT     hrResult = S_OK;
    CByteStream bstmDisplay;
    CByteStream bstmEmail;
    BOOL        fPrependDisplaySeparator = FALSE;
    BOOL        fPrependEmailSeparator = FALSE;

    // Initialize output
    if (NULL != ppszDisplay)
        *ppszDisplay = NULL;

    if (NULL != ppszEmailAddr)
        *ppszEmailAddr = NULL;


    // Loop through all IMAP addresses
    while (NULL != piaIMAPAddr)
    {
        // Concatenate current email address to list of email addresses
        // Do email address first to allow substitution of email addr for missing display name
        if (NULL != ppszEmailAddr)
        {
            if (FALSE == fPrependEmailSeparator)
                fPrependEmailSeparator = TRUE;
            else
            {
                hrResult = bstmEmail.Write(c_szSemiColonSpace, 2, NULL);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }

            hrResult = ConstructIMAPEmailAddr(bstmEmail, piaIMAPAddr);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
        } // if (NULL != ppszEmailAddr)

        // Concatenate current display name to list of display names
        if (NULL != ppszDisplay)
        {
            PROPVARIANT rDecoded;
            LPSTR       pszName;
            int         iLen;

            if (FALSE == fPrependDisplaySeparator)
                fPrependDisplaySeparator = TRUE;
            else
            {
                hrResult = bstmDisplay.Write(c_szSemiColonSpace, 2, NULL);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }

            PropVariantInit(&rDecoded);
            rDecoded.vt = VT_LPSTR;
            if (FAILED(MimeOleDecodeHeader(NULL, piaIMAPAddr->pszName, &rDecoded, NULL)))
                pszName = StrDupA(piaIMAPAddr->pszName);
            else
                pszName = rDecoded.pszVal;

            if(FAILED(hrResult = MimeOleUnEscapeStringInPlace(pszName)))
                TraceResult(hrResult);

            iLen = lstrlen(pszName);
            if (0 != iLen)
                hrResult = bstmDisplay.Write(pszName, iLen, NULL);
            else
                // Friendly name is not available! Substitute email address
                hrResult = ConstructIMAPEmailAddr(bstmDisplay, piaIMAPAddr);

            if (rDecoded.pszVal)
                MemFree(rDecoded.pszVal); // Probably should be SafeMimeOleFree, but we also ignore above

            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
        } // if (NULL != ppszDisplay)

        // Advance pointer
        piaIMAPAddr = piaIMAPAddr->pNext;

    } // while


    // Convert stream to buffer for return to caller
    if (NULL != ppszDisplay)
    {
        hrResult = bstmDisplay.HrAcquireStringA(NULL, ppszDisplay, ACQ_DISPLACE);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

    if (NULL != ppszEmailAddr)
    {
        hrResult = bstmEmail.HrAcquireStringA(NULL, ppszEmailAddr, ACQ_DISPLACE);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

exit:
    return hrResult;
} // ConcatIMAPAddresses



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ConstructIMAPEmailAddr(CByteStream &bstmOut, IMAPADDR *piaIMAPAddr)
{
    HRESULT hrResult;

    hrResult = bstmOut.Write(piaIMAPAddr->pszMailbox, lstrlen(piaIMAPAddr->pszMailbox), NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = bstmOut.Write(c_szAt, 1, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = bstmOut.Write(piaIMAPAddr->pszHost, lstrlen(piaIMAPAddr->pszHost), NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_SyncHeader(void)
{
    HRESULT hr = S_OK;
    char    szFetchArgs[200];
    BOOL    fNOOP = TRUE;

    TraceCall("CIMAPSync::_SyncHeader");
    IxpAssert(m_cRef > 0);

    // Look at the flags to determine the next operation
    if (SYNC_FOLDER_NEW_HEADERS & m_dwSyncToDo)
    {
        // Remove this flag, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_NEW_HEADERS);

        // Check if there are any new messages to retrieve
        // Retrieve new headers iff > 0 msgs in this mailbox (Cyrus bug: sending
        // UID FETCH in empty mailbox results in terminated connection)
        // (NSCP v2.0 bug: no EXISTS resp when SELECT issued from selected state)
        if ((m_dwMsgCount > 0 || FALSE == m_fMsgCountValid) &&
            (FALSE == m_fDidFullSync || m_dwNumNewMsgs > 0))
        {
            DWORD dwCapability;

            // No need to send NOOP anymore
            m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);

            // New messages available! Send FETCH to retrieve new headers
            hr = GetHighestCachedMsgID(m_pFolder, &m_dwHighestCachedUID);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            hr = m_pTransport->Capability(&dwCapability);
            if (SUCCEEDED(dwCapability) && (IMAP_CAPABILITY_IMAP4rev1 & dwCapability))
                wsprintf(szFetchArgs, cszIMAPFetchNewHdrsI4r1, m_dwHighestCachedUID + 1);
            else
                wsprintf(szFetchArgs, cszIMAPFetchNewHdrsI4, m_dwHighestCachedUID + 1);

            hr = m_pTransport->Fetch(tidFETCH_NEW_HDRS, NULL, this,
                NULL, USE_UIDS, szFetchArgs); // We always use UIDs
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
            else
                ResetStatusCounts();

            // Reset progress indicator variables
            m_dwNumHdrsDLed = 0;
            m_dwNumUnreadDLed = 0;
            m_dwNumHdrsToDL = m_dwNumNewMsgs;
            m_dwNumNewMsgs = 0; // We're handling this now
            m_fNewMail = FALSE;

            m_lSyncFolderRefCount += 1;
            fNOOP = FALSE;
            goto exit; // Limit to one operation at a time, exit function now
        }
    }

    if (SYNC_FOLDER_CACHED_HEADERS & m_dwSyncToDo)
    {
        // Remove this flag, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_CACHED_HEADERS);

        // Check if we have any cached headers, and if we've already done flag update
        if (0 == m_dwHighestCachedUID)
        {
            // Either m_dwHighestCachedUID was never loaded, or it really is zero. Check.
            hr = GetHighestCachedMsgID(m_pFolder, &m_dwHighestCachedUID);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }

        if (FALSE == m_fDidFullSync && 0 != m_dwHighestCachedUID)
        {
            // No need to send NOOP anymore
            m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);

            wsprintf(szFetchArgs, cszIMAPFetchCachedFlags, m_dwHighestCachedUID);
            hr = m_pTransport->Fetch(tidFETCH_CACHED_FLAGS, NULL, this,
                NULL, USE_UIDS, szFetchArgs); // We always use UIDs
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
            else
                ResetStatusCounts();

            m_lSyncFolderRefCount += 1;
            fNOOP = FALSE;
            goto exit; // Limit to one operation at a time, exit function now
        }
    }

    if (SYNC_FOLDER_PURGE_DELETED & m_dwSyncToDo)
    {
        // Remove the purge flag. Also, no need to send NOOP anymore since EXISTS
        // and FETCH responses can be sent during EXPUNGE
        m_dwSyncToDo &= ~(SYNC_FOLDER_PURGE_DELETED | SYNC_FOLDER_NOOP);
        m_dwSyncFolderFlags &= ~(SYNC_FOLDER_PURGE_DELETED); // Not a standing order

        hr = m_pTransport->Expunge(tidEXPUNGE, 0, this);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        else
            ResetStatusCounts();

        fNOOP = FALSE;
        m_lSyncFolderRefCount += 1;
        goto exit; // Limit to one operation at a time, exit function now
    }

    // If we reached this point, ping svr for new mail/cached hdr updates
    // New mail/cached msg updates will be handled like any other unilateral response
    if (SYNC_FOLDER_NOOP & m_dwSyncToDo)
    {
        // Remove these flags, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);
        IxpAssert(0 == (m_dwSyncToDo & (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)));

        hr = m_pTransport->Noop(tidNOOP, NULL, this);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        else
            ResetStatusCounts();

        fNOOP = FALSE;
        m_lSyncFolderRefCount += 1;
        goto exit; // Limit to one operation at a time, exit function now
    }

    // Check if we had nothing left to do
    if (fNOOP)
        hr = STORE_S_NOOP;

exit:
    return hr;
} // _SyncHeader



//***************************************************************************
//***************************************************************************
void CIMAPSync::ResetStatusCounts(void)
{
    HRESULT     hrTemp;
    FOLDERINFO  fiFolderInfo;

    // We're about to do a full synchronization, so restore unread counts to
    // pre-STATUS response levels
    hrTemp = m_pStore->GetFolderInfo(m_idSelectedFolder, &fiFolderInfo);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        if (0 != fiFolderInfo.dwStatusMsgDelta || 0 != fiFolderInfo.dwStatusUnreadDelta)
        {
            // Make sure that we never cause counts to dip below 0
            if (fiFolderInfo.dwStatusMsgDelta > fiFolderInfo.cMessages)
                fiFolderInfo.dwStatusMsgDelta = fiFolderInfo.cMessages;

            if (fiFolderInfo.dwStatusUnreadDelta > fiFolderInfo.cUnread)
                fiFolderInfo.dwStatusUnreadDelta = fiFolderInfo.cUnread;

            fiFolderInfo.cMessages -= fiFolderInfo.dwStatusMsgDelta;
            fiFolderInfo.cUnread -= fiFolderInfo.dwStatusUnreadDelta;
            fiFolderInfo.dwStatusMsgDelta = 0;
            fiFolderInfo.dwStatusUnreadDelta = 0;

            Assert((LONG)fiFolderInfo.cMessages >= 0);
            Assert((LONG)fiFolderInfo.cUnread >= 0);
            hrTemp = m_pStore->UpdateRecord(&fiFolderInfo);
            TraceError(hrTemp);
        }
        m_pStore->FreeRecord(&fiFolderInfo);
    }
} // ResetStatusCounts



//***************************************************************************
// Function: CheckUIDValidity
//
// Purpose:
//   This function checks the value in m_dwUIDValidity against the
// UIDValidity in the message cache for this folder. If the two match, no
// action is taken. Otherwise, the message cache is emptied.
//***************************************************************************
HRESULT CIMAPSync::CheckUIDValidity(void)
{
    FOLDERUSERDATA  fudUserData;
    HRESULT         hr;

    TraceCall("CIMAPSync::CheckUIDValidity");
    IxpAssert(m_cRef > 0);

    // Load in UIDValidity of cache file
    hr = m_pFolder->GetUserData(&fudUserData, sizeof(fudUserData));
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Is our current cache file invalid?
    if (m_dwUIDValidity == fudUserData.dwUIDValidity)
        goto exit; // We're the same as ever

    // If we reached this point, the UIDValidity has changed
    // Take out the cache
    hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

    // Write the new UIDValidity to the cache
    fudUserData.dwUIDValidity = m_dwUIDValidity;
    hr = m_pFolder->SetUserData(&fudUserData, sizeof(fudUserData));
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: SyncDeletedMessages
//
// Purpose:
//   This function is called after the message cache is filled with all of
// the headers on the IMAP server (for this folder). This function deletes
// all messages from the message cache which no longer exist on the server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::SyncDeletedMessages(void)
{
    HRESULT hr;
    DWORD      *pdwMsgSeqNumToUIDArray = NULL;
    DWORD      *pdwCurrentServerUID;
    DWORD      *pdwLastServerUID;
    ULONG_PTR   ulCurrentCachedUID;
    DWORD       dwHighestMsgSeqNum;
    HROWSET     hRowSet = HROWSET_INVALID;
    HLOCK       hLockNotify=NULL;
    MESSAGEINFO miMsgInfo = {0};

    TraceCall("CIMAPSync::SyncDeletedMessages");
    IxpAssert(m_cRef > 0);

    // First, check for case where there are NO messages on server
    hr = m_pTransport->GetMsgSeqNumToUIDArray(&pdwMsgSeqNumToUIDArray, &dwHighestMsgSeqNum);
    if (FAILED(hr))
    {
        TraceResult(hr);
        pdwMsgSeqNumToUIDArray = NULL; // Just in case
        goto exit;
    }

    if (0 == dwHighestMsgSeqNum)
    {
        // No messages on server! Blow away the entire message cache
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
        TraceError(hr);
        goto exit;
    }

    // If we've reached this point, there are messages on the server and thus
    // we must delete messages from the cache which are no longer on server
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_OK != hr)
    {
        // There are 0 messages in cache. Our work here is done
        IxpAssert(S_FALSE == hr);
        goto exit;
    }

    // This forces all notifications to be queued (this is good since you do segmented deletes)
    m_pFolder->LockNotify(0, &hLockNotify);

    // Step through each UID in the cache and delete those which do not exist
    // in our Msg Seq Num -> UID table (which holds all UIDs currently on server)
    pdwCurrentServerUID = pdwMsgSeqNumToUIDArray;
    pdwLastServerUID = pdwMsgSeqNumToUIDArray + dwHighestMsgSeqNum - 1;
    while (S_OK == hr)
    {
        ulCurrentCachedUID = (ULONG_PTR) miMsgInfo.idMessage;

        // Advance pdwCurrentServerUID so its value is always >= ulCurrentCachedUID
        while (pdwCurrentServerUID < pdwLastServerUID &&
               ulCurrentCachedUID > *pdwCurrentServerUID)
            pdwCurrentServerUID += 1;

        // If *pdwCurrentServerUID != ulCurrentCachedUID, the message in our
        // cache has been deleted from the server
        if (ulCurrentCachedUID != *pdwCurrentServerUID)
        {
            MESSAGEIDLIST   midList;
            MESSAGEID       mid;

            // This message in our cache has been deleted from the server. Nuke it.
            // $REVIEW: Would probably be more efficient if we constructed MESSAGEID list
            // and deleted whole thing at once, but ask me again when I have time
            mid = (MESSAGEID) ulCurrentCachedUID;
            midList.cAllocated = 0;
            midList.cMsgs = 1;
            midList.prgidMsg = &mid;

            hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &midList, NULL, NULL);
            TraceError(hr); // Record error but otherwise continue
        }

        // Advance current cached UID
        m_pFolder->FreeRecord(&miMsgInfo);
        hr = m_pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    }
    IxpAssert(pdwCurrentServerUID <= pdwLastServerUID);

exit:
    m_pFolder->UnlockNotify(&hLockNotify);

    if (HROWSET_INVALID != hRowSet)
    {
        HRESULT hrTemp;

        // Record but otherwise ignore error
        hrTemp = m_pFolder->CloseRowset(&hRowSet);
        TraceError(hrTemp);
    }

    if (NULL != pdwMsgSeqNumToUIDArray)
        MemFree(pdwMsgSeqNumToUIDArray);

    return hr;
}



#define CMAX_DELETE_SEARCH_BLOCK 50

HRESULT CIMAPSync::DeleteHashedFolders(IHashTable *pHash)
{
    ULONG   cFound=0;
    LPVOID  *rgpv;

    TraceCall("CIMAPSync::DeleteHashedFolders");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pHash);

    pHash->Reset();
    while (SUCCEEDED(pHash->Next(CMAX_DELETE_SEARCH_BLOCK, &rgpv, &cFound)))
    {
        while(cFound--)
        {
            HRESULT hrTemp;

            hrTemp = DeleteFolderFromCache((FOLDERID)rgpv[cFound], fNON_RECURSIVE);
            TraceError(hrTemp);
        }

        SafeMemFree(rgpv);
    }
    return S_OK;
}



//***************************************************************************
// Function: DeleteFolderFromCache
//
// Purpose:
//   This function attempts to delete the specified folder from the
// folder cache. If the folder is a leaf folder, it may be deleted immediately.
// If the folder is an internal node, this function marks the folder for
// deletion, and deletes the internal node when it no longer has children.
// Regardless of whether the folder node is removed from the folder cache,
// the message cache for the given folder is blown away.
//
// Arguments:
//   FOLDERID idFolder [in] - the folder which you want to delete.
//   BOOL fRecursive [in] - TRUE if we should delete all child folders of the
//     victim. If FALSE, the victim is deleted only if it has no children.
//     Otherwise the victim is marked as \NoSelect and non-existent.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::DeleteFolderFromCache(FOLDERID idFolder, BOOL fRecursive)
{
    HRESULT     hr;
    HRESULT     hrTemp;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::DeleteFolderFromCache");

    // Check args and codify assumptions
    IxpAssert(m_cRef > 0);
    IxpAssert(FOLDERID_INVALID != idFolder);

    // Get some info about the node
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        if (DB_E_NOTFOUND == hr)
            hr = S_OK; // Deletion target already gone, don't confuse user out w/ err msgs
        else
            TraceResult(hr);

        goto exit;
    }

    fFreeInfo = TRUE;

    // OK, now we can get rid of the foldercache node based on the following rules:
    // 1) Non-listing of an interior node must not remove its inferiors: the interior node
    //    just becomes \NoSelect for us, and we delete it once it loses its children.
    // 2) Deletion of a leaf node removes the node and any deleted parents. (If a
    //    parent is deleted, we keep it around until it has no kids.)
    // 3) fRecursive TRUE means take no prisoners.

    // Check if we need to recurse on the children
    if (fRecursive)
    {
        IEnumerateFolders  *pEnum;
        FOLDERINFO          fiChildInfo={0};

        if (SUCCEEDED(m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pEnum)))
        {
            while (S_OK == pEnum->Next(1, &fiChildInfo, NULL))
            {
                hr = DeleteFolderFromCache(fiChildInfo.idFolder, fRecursive);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    break;
                }

                m_pStore->FreeRecord(&fiChildInfo);
            }

            m_pStore->FreeRecord(&fiChildInfo);

            pEnum->Release();

            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            // Re-load the current folder node
            m_pStore->FreeRecord(&fiFolderInfo);
            hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }

    }

    // Is this an interior node?
    if (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags)
    {
        IMessageFolder *pFolder;

        // It's an interior node. Awwwww, no nukes... make it \NoSelect,
        // and mark it for deletion as soon as it loses its kids
        fiFolderInfo.dwFlags |= FOLDER_NOSELECT | FOLDER_NONEXISTENT;
        fiFolderInfo.cMessages = 0;
        fiFolderInfo.cUnread = 0;
        fiFolderInfo.dwStatusMsgDelta = 0;
        fiFolderInfo.dwStatusUnreadDelta = 0;
        hr = m_pStore->UpdateRecord(&fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Plow the associated message cache
        hrTemp = m_pStore->OpenFolder(fiFolderInfo.idFolder, NULL, NOFLAGS, &pFolder);
        TraceError(hrTemp);
        if (SUCCEEDED(hrTemp))
        {
            hrTemp = pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
            TraceError(hrTemp);
            pFolder->Release();
        }
    }
    else
    {
        // It's a leaf node. Nuke it, AND its family. DeleteLeafFolder fills in
        // fiFolderInfo.idParent for use in RecalculateParentFlags call (no longer called)
        fiFolderInfo.idParent = idFolder;
        hr = DeleteLeafFolder(&fiFolderInfo.idParent);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}



//***************************************************************************
// Function: DeleteLeafFolder
//
// Purpose:
//   This function is used by DeleteFolderFromCache to delete a leaf folder.
// More than just a leaf blower, this function also checks if the parents of
// the given leaf node can be deleted.
//
// The reason we keep folder nodes around even though they haven't been
// listed is that it is possible on some IMAP servers to create folders whose
// parents aren't listed. For instance, "CREATE foo/bar" might not create foo,
// but "foo/bar" will be there. There has to be SOME path to that node, so
// when foo/bar goes, you can bet that we'll want to get rid of our "foo".
//
// Arguments:
//   FOLDERID *pidCurrent [in/out] - pass in the HFOLDER identifying the leaf
//     node to delete. The function returns a pointer to the closest existing
//     ancestor of the deleted node (several parent nodes may be deleted).
//
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::DeleteLeafFolder(FOLDERID *pidCurrent)
{
    HRESULT     hr;
    BOOL        fFirstFolder;
    FOLDERINFO  fiFolderInfo;

    // Check args and codify assumptions
    TraceCall("CIMAPSync::DeleteLeafFolder");
    IxpAssert(m_cRef > 0);

    // Initialize variables
    fFirstFolder = TRUE;

    // Loop until the folder is not a deletion candidate
    while (FOLDERID_INVALID != *pidCurrent && FOLDERID_ROOT != *pidCurrent &&
           m_idIMAPServer != *pidCurrent)
    {

        // Get the dirt on this node
        hr = m_pStore->GetFolderInfo(*pidCurrent, &fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Check if this folder is a deletion candidate. To be a deletion candidate,
        // it must either be the first folder we see (we assume the caller gave us a
        // leaf node to delete), or marked for deletion AND have no children left.
        if (FALSE == fFirstFolder && (0 == (FOLDER_NONEXISTENT & fiFolderInfo.dwFlags) ||
            (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags)))
            {
            m_pStore->FreeRecord(&fiFolderInfo);
            break;
            }

        // We've got some deletion to do
        // Unlink the leaf folder node from its parent folder
        AssertSz(0 == (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags),
            "Hey, what's the idea, orphaning child nodes?");
        hr = m_pStore->DeleteFolder(fiFolderInfo.idFolder,
            DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_DELETESPECIAL, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            TraceResult(hr);
            goto exit;
        }

        // Next stop: your mama
        *pidCurrent = fiFolderInfo.idParent;
        m_pStore->FreeRecord(&fiFolderInfo);
        fFirstFolder = FALSE;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: AddFolderToCache
//
// Purpose:
//   This function saves the given folder (fresh from
// _OnMailBoxList) to the folder cache. This code used to live
// in _OnMailBoxList but, that function got too big after I
// added hierarchy determination code.
//
// Arguments:
//   LPSTR pszMailboxName [in] - name of the mailbox as returned by LIST/LSUB
//   IMAP_MBOXFLAGS [in] - flags of mailbox as returned by LIST/LSUB
//   char cHierarchyChar [in] - hierarchy char returned by LIST/LSUB
//   DWORD dwAFTCFlags [in] - Set the following flags:
//     AFTC_SUBSCRIBED if folder is subscribed (eg, returned via LSUB)
//     AFTC_KEEPCHILDRENKNOWN to suppress removal of FOLDER_CHILDRENKNOWN
//     AFTC_NOTSUBSCRIBED if folder is no longer subscribed (NEVER set via
//       LIST, but instead at end of successful UNSUBSCRIBE command)
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::AddFolderToCache(LPSTR pszMailboxName,
                                    IMAP_MBOXFLAGS imfMboxFlags,
                                    char cHierarchyChar, DWORD dwAFTCFlags,
                                    FOLDERID *pFolderID, SPECIALFOLDER sfType)
{
    HRESULT             hr;
    BOOL                bResult;
    ADD_HIER_FLDR_OPTIONS  ahfo;
    BOOL                fValidPrefix;

    TraceCall("CIMAPSync::AddFolderToCache");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pszMailboxName);
    IxpAssert(NULL != pFolderID);

    // Create or find a folder node for this folder name
    // Fill in foldercache props. INBOX is always treated as a subscribed folder
    // Add new IMAP mbox flags, remove all IMAP mbox flags that we're not adding
    ahfo.sfType = sfType;
    ahfo.ffFlagAdd = DwConvertIMAPMboxToFOLDER(imfMboxFlags);
    ahfo.ffFlagRemove = DwConvertIMAPMboxToFOLDER(IMAP_MBOX_ALLFLAGS) & ~(ahfo.ffFlagAdd);
    ahfo.ffFlagRemove |= FOLDER_NONEXISTENT; // Always remove: folder must exist if we listed it
    ahfo.ffFlagRemove |= FOLDER_HIDDEN; // If we listed the folder, we no longer need to hide it
    ahfo.ffFlagRemove |= FOLDER_CREATEONDEMAND; // If we listed the folder, we no longer need to create it

    // Figure out which flags to add and remove
    if (ISFLAGSET(dwAFTCFlags, AFTC_SUBSCRIBED) || FOLDER_INBOX == sfType)
        ahfo.ffFlagAdd |= FOLDER_SUBSCRIBED;    // This folder is subscribed
    else if (ISFLAGSET(dwAFTCFlags, AFTC_NOTSUBSCRIBED))
        ahfo.ffFlagRemove |= FOLDER_SUBSCRIBED; // This folder is no longer subscribed

    if (AFTC_NOTRANSLATION & dwAFTCFlags)
        ahfo.ffFlagAdd |= FOLDER_NOTRANSLATEUTF7;
    else
        ahfo.ffFlagRemove |= FOLDER_NOTRANSLATEUTF7;

    if (IMAP_MBOX_NOINFERIORS & imfMboxFlags)
        // NoInferiors folders cannot have children, so we never have to ask
        ahfo.ffFlagAdd |= FOLDER_CHILDRENKNOWN;
    else if (ISFLAGCLEAR(dwAFTCFlags, AFTC_KEEPCHILDRENKNOWN))
        // Remove FOLDER_CHILDRENKNOWN from this fldr so we ask for its chldrn when it's expanded
        ahfo.ffFlagRemove |= FOLDER_CHILDRENKNOWN;

    hr = FindHierarchicalFolderName(pszMailboxName, cHierarchyChar,
        pFolderID, &ahfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    AssertSz(FOLDERID_INVALID != *pFolderID, "Hey, what does it take to get a folder handle?");

exit:
    return hr;
}



//***************************************************************************
// Function: RemovePrefixFromPath
//
// Purpose:
//   This function removes the prefix from the given mailbox path. If the
// given path is a special folder, this function removes all of the special
// folder path prefix except for the leaf node (eg, "foo/Sent Items/bar"
// becomes "Sent Items/bar").
//
// Arguments:
//   LPSTR pszPrefix [in] - the prefix to strip from pszMailboxName. Note
//     that this may not necessarily be the prefix stripped from pszMailboxName,
//     if we match a special folder path.
//   LPSTR pszMailboxName [in] - the full path to the mailbox, incl prefix
//   char cHierarchyChar [in] - used to interpret pszMailboxName.
//   LPBOOL pfValidPrefix [out] - returns TRUE if this mailbox name has a
//     valid prefix, FALSE otherwise. Pass NULL if not interested.
//   SPECIALFOLDER *psfType [out] - returns SPECIALFOLDER (eg, FOLDER_NOTSPECIAL,
//     FOLDER_INBOX) of folder. Pass NULL if not interested.
//
// Returns:
//   LPSTR pointing past the prefix and hierarchy character.
//***************************************************************************
LPSTR CIMAPSync::RemovePrefixFromPath(LPSTR pszPrefix, LPSTR pszMailboxName,
                                      char cHierarchyChar, LPBOOL pfValidPrefix,
                                      SPECIALFOLDER *psfType)
{
    LPSTR           pszSpecial = NULL;
    LPSTR           pszRFP = NULL;
    BOOL            fValidPrefix = FALSE;
    SPECIALFOLDER   sfType;

    TraceCall("CIMAPSync::RemovePrefixFromPath");
    IxpAssert(INVALID_HIERARCHY_CHAR != cHierarchyChar);

    // Check for special folder path prefixes
    pszSpecial = ImapUtil_GetSpecialFolderType(m_pszAccountID, pszMailboxName,
        cHierarchyChar, pszPrefix, &sfType);
    if (NULL != pszSpecial)
        fValidPrefix = TRUE;


    // If this is a special folder, no need to check for root folder prefix
    if (FOLDER_NOTSPECIAL != sfType)
    {
        IxpAssert(NULL != pszSpecial);
        pszMailboxName = pszSpecial;
        goto exit;
    }

    // Check for the root folder prefix
    if ('\0' != pszPrefix[0] && '\0' != cHierarchyChar)
    {
        int iResult, iPrefixLength;

        // Do case-INSENSITIVE compare (IE5 bug #59121). If we ask for Inbox/* we must be
        // able to handle receipt of INBOX/*. Don't worry about case-sensitive servers since
        // they will never return an RFP of different case than the one we specified
        iPrefixLength = lstrlen(pszPrefix);
        iResult = StrCmpNI(pszMailboxName, pszPrefix, iPrefixLength);
        if (0 == iResult)
        {
            // Prefix name found at front of this mailbox name! Remove it iff
            // it is followed immediately by hierarchy character
            if (cHierarchyChar == pszMailboxName[iPrefixLength])
            {
                pszRFP = pszMailboxName + iPrefixLength + 1; // Point past the hierarchy char
                fValidPrefix = TRUE;
            }
            else if ('\0' == pszMailboxName[iPrefixLength])
            {
                pszRFP = pszMailboxName + iPrefixLength;
                fValidPrefix = TRUE;
            }
        }
    }
    else
        fValidPrefix = TRUE;


    // We basically want to return the shortest mailbox name. For instance, in choosing
    // between "INBOX.foo" and "foo", we should choose "foo"
    IxpAssert(pszMailboxName > NULL && pszRFP >= NULL && pszSpecial >= NULL);
    if (NULL != pszRFP || NULL != pszSpecial)
    {
        IxpAssert(pszRFP >= pszMailboxName || pszSpecial >= pszMailboxName);
        pszMailboxName = max(pszRFP, pszSpecial);
    }

exit:
    if (NULL != pfValidPrefix)
        *pfValidPrefix = fValidPrefix;

    if (NULL != psfType)
        *psfType = sfType;

    return pszMailboxName;
}



//***************************************************************************
// Function: FindHierarchicalFolderName
//
// Purpose:
//   This function takes a mailbox name as returned by LIST/LSUB and
// determines whether the given mailbox already exists in the folder cache.
// If so, a handle to the folder is returned. If not, and the fCreate argument
// is TRUE, then the mailbox and any intermediate nodes are created, and a
// handle to the mailbox (leaf node) is returned.
//
// Arguments:
//   LPSTR lpszFolderPath [in] - the name of the mailbox as returned by
//     a LIST or LSUB response. This should NOT include the prefix!
//   char cHierarchyChar [in] - the hierarchy character used in
//     lpszFolderPath. Used to determine parenthood.
//   FOLDERID *pidTarget [out] - if the function is successful, a handle
//     to the folder is returned here.
//   ADD_HIER_FLDR_OPTIONS pahfoCreateInfo [in] - set to NULL if this function
//     should find the given lpszFolderPath, but NOT create the folder. Pass
//     in a ptr to a ADD_HIER_FLDR_OPTIONS structure if the folder should be
//     created. pahfoCreateInfo defines the dwImapFlags and sftype to use
//     if the folder has to be created.
//
// Returns:
//   HRESULT indicating success or failure. If successful, a handle to the
// desired folder is returned in the pidTarget parameter. There are two
// possible success results:
//     S_OK - found the folder, did not have to create
//     S_CREATED - folder was successfully created
//***************************************************************************
HRESULT CIMAPSync::FindHierarchicalFolderName(LPSTR lpszFolderPath,
                                              char cHierarchyChar,
                                              FOLDERID *pidTarget,
                                              ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo)
{
    char       *pszCurrentFldrName;
    FOLDERID    idCurrent, idPrev;
    HRESULT     hr;
    LPSTR       pszTok;
    LPSTR       pszIHateStrTok = NULL;
    char        szHierarchyChar[2];

    TraceCall("CIMAPSync::FindHierarchicalFolderName");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszFolderPath);
    IxpAssert(NULL != pidTarget);

    // Initialize variables
    *pidTarget = FOLDERID_INVALID;
    hr = S_OK;
    idPrev = FOLDERID_INVALID;
    idCurrent = m_idIMAPServer;
    szHierarchyChar[0] = cHierarchyChar;
    szHierarchyChar[1] = '\0';

#ifdef DEBUG
    // Make sure this fn is never called with a prefix (DEBUG-ONLY)
    // Note that false alarm is possible, eg, RFP=foo and folder="foo/foo/bar".
    BOOL    fValidPrefix;
    LPSTR   pszPostPrefix;

    pszPostPrefix = RemovePrefixFromPath(m_szRootFolderPrefix, lpszFolderPath,
        cHierarchyChar, &fValidPrefix, NULL);
    AssertSz(FALSE == fValidPrefix || pszPostPrefix == lpszFolderPath,
        "Make sure you've removed the prefix before calling this fn!");
#endif // DEBUG

    // Initialize pszCurrentFldrName to point to name of first-level mailbox node
    // $REVIEW: We now need to remove the reference portion of the LIST/LSUB cmd
    // from the mailbox name!
    pszIHateStrTok = StringDup(lpszFolderPath);
    pszTok = pszIHateStrTok;
    pszCurrentFldrName = StrTokEx(&pszTok, szHierarchyChar);

    // Loop through mailbox node names until we hit the leaf node
    while (NULL != pszCurrentFldrName)
    {
        LPSTR pszNextFldrName;

        // Pre-load the NEXT folder node so we know when we are at the leaf node
        pszNextFldrName = StrTokEx(&pszTok, szHierarchyChar);

        // Look for the current folder name
        idPrev = idCurrent;
        hr = GetFolderIdFromName(m_pStore, pszCurrentFldrName, idCurrent, &idCurrent);
        IxpAssert(SUCCEEDED(hr) || FOLDERID_INVALID == idCurrent);

        if (NULL == pahfoCreateInfo)
        {
            if (FOLDERID_INVALID == idCurrent)
                break; // Fldr doesn't exist and user doesn't want to create it
        }
        else
        {
            // Create desired folder, including intermediate nodes
            hr = CreateFolderNode(idPrev, &idCurrent, pszCurrentFldrName,
                pszNextFldrName, cHierarchyChar, pahfoCreateInfo);
            if (FAILED(hr))
                break;
        }

        // Advance to the next folder node name
        pszCurrentFldrName = pszNextFldrName;
    }


    // Return results
    if (SUCCEEDED(hr) && FOLDERID_INVALID != idCurrent)
    {
        *pidTarget = idCurrent;
    }
    else
    {
        IxpAssert(FOLDERID_INVALID == *pidTarget); // We set this at start of fn
        if (SUCCEEDED(hr))
            hr = DB_E_NOTFOUND; // Can't return success, dammit
    }

    SafeMemFree(pszIHateStrTok);
    return hr;
}



//***************************************************************************
// Function: CreateFolderNode
//
// Purpose:
//   This function is called when creating a new folder in the foldercache.
// It is called for every node from the root folder and the new folder.
// This function is responsible for creating the terminal node and any
// intermediate nodes. If these nodes already exist, this function is
// responsible for adjusting the FLDR_* flags to reflect the new folder
// that is about to be added.
//
// Arguments:
//   FOLDERID idPrev [in] - FOLDERID to parent of current node.
//   FOLDERID *pidCurrent [in/out] - FOLDERID to current node. If current node
//     exists, this is a valid FOLDERID. If the current node must be created,
//     the value here is FOLDERID_INVALID. In this case, the FOLDERID of the
//     created node is returned here.
//   LPSTR pszCurrentFldrName [in] - the name of the current folder node.
//   LPSTR pszNextFldrName [in] - the name of the next folder node. This is
//     NULL if the current node is the terminal node.
//   char cHierarchyChar [in] - hierarchy character for this folder path.
//     Used to save FLDINFO::bHierarchy.
//   ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo [in] - information used to create
//     the terminal folder node and update all of its parent nodes that
//     already exist.
//
// Returns:
//   HRESULT indicating success or failure. S_CREATED means a folder node
// was created.
//***************************************************************************
HRESULT CIMAPSync::CreateFolderNode(FOLDERID idPrev, FOLDERID *pidCurrent,
                                    LPSTR pszCurrentFldrName,
                                    LPSTR pszNextFldrName, char cHierarchyChar,
                                    ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::CreateFolderNode");
    IxpAssert(NULL != pahfoCreateInfo);
    IxpAssert(0 == (pahfoCreateInfo->ffFlagAdd & pahfoCreateInfo->ffFlagRemove));

    // If current folder name not found, we have to create it
    if (FOLDERID_INVALID == *pidCurrent)
    {
        // Initialize
        ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));

        // FIRST: Add folder to folder cache
        // Fill out a folderinfo structure (just use it as a scratchpad)
        fiFolderInfo.idParent = idPrev;
        fiFolderInfo.pszName = pszCurrentFldrName;
        fiFolderInfo.bHierarchy = cHierarchyChar;

        // If this is the last folder node name (ie, leaf node), use the
        // IMAP flags returned via the LIST/LSUB, and use the supplied
        // special folder type

        if (NULL == pszNextFldrName)
        {
            fiFolderInfo.tySpecial = pahfoCreateInfo->sfType;
            fiFolderInfo.dwFlags |= pahfoCreateInfo->ffFlagAdd;
            fiFolderInfo.dwFlags &= ~(pahfoCreateInfo->ffFlagRemove);

            if (fiFolderInfo.tySpecial == FOLDER_INBOX)
                fiFolderInfo.dwFlags |= FOLDER_DOWNLOADALL;
        }
        else
        {
            // Otherwise, here are the defaults
            // Non-listed folders are \NoSelect by default, and candidates for deletion
            fiFolderInfo.dwFlags = FOLDER_NOSELECT | FOLDER_NONEXISTENT;
            fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
        }

        // Add folder to folder cache
        hr = m_pStore->CreateFolder(NOFLAGS, &fiFolderInfo, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        *pidCurrent = fiFolderInfo.idFolder;
        hr = S_CREATED; // Tell the user we created this folder
    }
    else if (NULL == pszNextFldrName)
    {
        DWORD dwFlagsChanged = 0;
        BOOL  fChanged = FALSE;

        // Folder exists, check that its flags are correct
        hr = m_pStore->GetFolderInfo(*pidCurrent, &fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        fFreeInfo = TRUE;
        if (fiFolderInfo.bHierarchy != cHierarchyChar)
        {
            AssertSz(INVALID_HIERARCHY_CHAR == (char) fiFolderInfo.bHierarchy, "What's YOUR excuse?");
            fiFolderInfo.bHierarchy = cHierarchyChar;
            fChanged = TRUE;
        }

        if (NULL == pszNextFldrName && (fiFolderInfo.tySpecial != pahfoCreateInfo->sfType ||
            (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagAdd) != pahfoCreateInfo->ffFlagAdd ||
            (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagRemove) != 0))
        {
            DWORD dwFlagAddChange;
            DWORD dwFlagRemoveChange;

            // The terminal folder node exists, set everything given via pahfoCreateInfo
            // Check if anything changed, first

            if (pahfoCreateInfo->sfType == FOLDER_INBOX &&
                fiFolderInfo.tySpecial != pahfoCreateInfo->sfType)
                fiFolderInfo.dwFlags |= FOLDER_DOWNLOADALL;

            fiFolderInfo.tySpecial = pahfoCreateInfo->sfType;

            // Figure out which flags changed so we know if we need to recalculate parents
            dwFlagAddChange = (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagAdd) ^
                pahfoCreateInfo->ffFlagAdd;
            dwFlagRemoveChange = (~(fiFolderInfo.dwFlags) & pahfoCreateInfo->ffFlagRemove) ^
                pahfoCreateInfo->ffFlagRemove;
            dwFlagsChanged = dwFlagAddChange | dwFlagRemoveChange;

            fiFolderInfo.dwFlags |= pahfoCreateInfo->ffFlagAdd;
            fiFolderInfo.dwFlags &= ~(pahfoCreateInfo->ffFlagRemove);

            fChanged = TRUE;
        }

        // Set the folder properties
        if (fChanged)
        {
            hr = m_pStore->UpdateRecord(&fiFolderInfo);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}


//***************************************************************************
// Function: SetTranslationMode
//
// Purpose:
//   This function enables or disables mailbox translation in IIMAPTransport2,
// depending on whether the FOLDER_NOTRANSLATEUTF7 flags is set for this folder.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     S_OK - mailbox translation has been successfully enabled.
//     S_FALSE - mailbox translation has been successfully disabled.
//***************************************************************************
HRESULT CIMAPSync::SetTranslationMode(FOLDERID idFolderID)
{
    HRESULT     hrResult = S_OK;
    FOLDERINFO  fiFolderInfo = {0};
    DWORD       dwTranslateFlags;
    BOOL        fTranslate = TRUE;
    BOOL        fFreeInfo;

    TraceCall("CIMAPSync::SetTranslationMode");

    // Check for FOLDERID_INVALID (we get this during folder lists)
    // If FOLDERID_INVALID, assume we want to translate everything: leave fiFolderInfo at zero
    if (FOLDERID_INVALID != idFolderID)
    {
        hrResult = m_pStore->GetFolderInfo(idFolderID, &fiFolderInfo);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        fFreeInfo = TRUE;
    }
    else
    {
        Assert(0 == fiFolderInfo.dwFlags);
    }

    fTranslate = TRUE;
    dwTranslateFlags = IMAP_MBOXXLATE_DEFAULT | IMAP_MBOXXLATE_VERBATIMOK | IMAP_MBOXXLATE_RETAINCP;
    if (fiFolderInfo.dwFlags & FOLDER_NOTRANSLATEUTF7)
    {
        fTranslate = FALSE;
        dwTranslateFlags |= IMAP_MBOXXLATE_DISABLE;
        dwTranslateFlags &= ~(IMAP_MBOXXLATE_DEFAULT);
    }

    hrResult = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hrResult))
        hrResult = (fTranslate ? S_OK : S_FALSE);

    return hrResult;
} // SetTranslationMode



//***************************************************************************
//***************************************************************************
BOOL CIMAPSync::isUSASCIIOnly(LPCSTR pszFolderName)
{
    LPCSTR  psz;
    BOOL    fUSASCII = TRUE;

    psz = pszFolderName;
    while ('\0' != *psz)
    {
        if (0 != (*psz & 0x80))
        {
            fUSASCII = FALSE;
            break;
        }

        psz += 1;
    }

    return fUSASCII;
} // isUSASCIIOnly



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CheckFolderNameValidity(LPCSTR pszName)
{
    HRESULT hrResult = S_OK;

    if (NULL == pszName || '\0' == *pszName)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Figure out what our root hierarchy character is: assume that server does not
    // support multiple hierarchy characters
    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
    {
        hrResult = LoadSaveRootHierarchyChar(fLOAD_HC);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            hrResult = S_OK; // We can't say if this is valid or not, so just assume it is
            goto exit;
        }
    }

    if ('\0' == m_cRootHierarchyChar || INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
        goto exit; // Anything goes!

    while ('\0' != *pszName)
    {
        // No hierarchy characters are allowed in the folder name, except at the very end
        if (m_cRootHierarchyChar == *pszName && '\0' != *(pszName + 1))
        {
            // Figure out which HRESULT to use (we need to bring up the correct text)
            switch (m_cRootHierarchyChar)
            {
                case '/':
                    hrResult = STORE_E_IMAP_HC_NOSLASH;
                    break;

                case '\\':
                    hrResult = STORE_E_IMAP_HC_NOBACKSLASH;
                    break;

                case '.':
                    hrResult = STORE_E_IMAP_HC_NODOT;
                    break;

                default:
                    hrResult = STORE_E_IMAP_HC_NOHC;
                    break;
            }
            TraceResult(hrResult);
            goto exit;
        }

        // Advance pointer
        pszName += 1;
    }

exit:
    return hrResult;
}



//***************************************************************************
// Function: RenameFolderHelper
//
// Purpose:
//   This function is called by RenameFolder. This function is responsible
// for issuing the RENAME command for the folder which is to be renamed.
// If the folder to be renamed does not actually exist (eg, Cyrus server),
// this function recurses on the child folders until a real folder is found.
//
// Arguments:
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameFolderHelper(FOLDERID idFolder,
                                      LPSTR pszFolderPath,
                                      char cHierarchyChar,
                                      LPSTR pszNewFolderPath)
{
    HRESULT             hr;
    CRenameFolderInfo  *pRenameInfo = NULL;
    FOLDERINFO          fiFolderInfo;
    IEnumerateFolders  *pFldrEnum = NULL;
    BOOL                fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameFolderHelper");
    IxpAssert(m_cRef > 0);

    // Check if the folder actually exists on the IMAP server
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If current folder doesn't exist, recurse rename cmd on child folders
    fFreeInfo = TRUE;
    if (fiFolderInfo.dwFlags & FOLDER_NONEXISTENT) {
        FOLDERINFO  fiChildFldrInfo;

        // Perform rename on folder nodes which EXIST: recurse through children
        hr = m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pFldrEnum);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        hr = pFldrEnum->Next(1, &fiChildFldrInfo, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        while (S_OK == hr)
        {
            LPSTR   pszOldPath, pszNewPath;
            DWORD   dwLeafFolderLen, dwFolderPathLen, dwNewFolderPathLen;
            BOOL    fResult;

            // Calculate string sizes, + 2 for HC and null-term
            dwLeafFolderLen = lstrlen(fiChildFldrInfo.pszName);
            dwFolderPathLen = lstrlen(pszFolderPath);
            dwNewFolderPathLen = lstrlen(pszNewFolderPath);

            // Allocate space
            fResult = MemAlloc((void **)&pszOldPath, dwFolderPathLen + dwLeafFolderLen + 2);
            if (FALSE == fResult)
            {
                m_pStore->FreeRecord(&fiChildFldrInfo);
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            fResult = MemAlloc((void **)&pszNewPath, dwNewFolderPathLen + dwLeafFolderLen + 2);
            if (FALSE == fResult)
            {
                MemFree(pszOldPath);
                m_pStore->FreeRecord(&fiChildFldrInfo);
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            // Append current child's name to current path, new path
            lstrcpy(pszOldPath, pszFolderPath);
            *(pszOldPath + dwFolderPathLen) = cHierarchyChar;
            lstrcpy(pszOldPath + dwFolderPathLen + 1, fiChildFldrInfo.pszName);

            lstrcpy(pszNewPath, pszNewFolderPath);
            *(pszNewPath + dwNewFolderPathLen) = cHierarchyChar;
            lstrcpy(pszNewPath + dwNewFolderPathLen + 1, fiChildFldrInfo.pszName);

            // Recurse into the children, in hopes of finding an existing folder
            hr = RenameFolderHelper(fiChildFldrInfo.idFolder, pszOldPath, cHierarchyChar, pszNewPath);
            MemFree(pszOldPath);
            MemFree(pszNewPath);
            if (FAILED(hr))
            {
                m_pStore->FreeRecord(&fiChildFldrInfo);
                TraceResult(hr);
                goto exit;
            }

            // Load in the next child folder
            m_pStore->FreeRecord(&fiChildFldrInfo);
            hr = pFldrEnum->Next(1, &fiChildFldrInfo, NULL);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        } // while (S_OK == hr)

        goto exit; // We don't attempt to rename non-existent folders
    } // if (fiFolderInfo.dwImapFlags & FOLDER_NONEXISTENT)


    // Create a CRenameFolderInfo structure
    pRenameInfo = new CRenameFolderInfo;
    if (NULL == pRenameInfo)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Fill in all the fields
    pRenameInfo->pszFullFolderPath = StringDup(pszFolderPath);
    pRenameInfo->cHierarchyChar = cHierarchyChar;
    pRenameInfo->pszNewFolderPath = StringDup(pszNewFolderPath);
    pRenameInfo->idRenameFolder = idFolder;

    // Send the RENAME command
    pRenameInfo->pszRenameCmdOldFldrPath = StringDup(pszFolderPath);
    hr = _EnqueueOperation(tidRENAME, (LPARAM)pRenameInfo, icRENAME_COMMAND,
        pRenameInfo->pszNewFolderPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (NULL != pRenameInfo)
        pRenameInfo->Release();

    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hr;
} // RenameFolderHelper



//***************************************************************************
// Function: RenameTreeTraversal
//
// Purpose:
//   This function performs the requested operation on all child folders of
// the rename folder (specified in pRenameInfo->hfRenameFolder). For example,
// the tidRENAMESUBSCRIBE operation indicates that the entire renamed folder
// hierarchy should be subscribed.
//
// Arguments:
//   WPARAM wpOperation [in] - identifies the operation to perform on the
//     rename hierarchy. Current operations include:
//       tidRENAMESUBSCRIBE - subscribe new (renamed) folder hierarchy
//       tidRENAMESUBSCRIBE_AGAIN - same as tidRENAMESUBSCRIBE
//       tidRENAMERENAME - issue individual RENAME's for all old child folders
//                         (simulates an atomic rename)
//       tidRENAMELIST - list the FIRST child of the rename folder.
//       tidRENAMEUNSUBSCRIBE - unsubscribe old folder hierarchy.
//
//   CRenameFolderInfo [in] - the CRenameFolderInfo class associated with
//     the RENAME operation.
//   BOOL fIncludeRenameFolder [in] - TRUE if the rename folder (top node)
//     should be included in the operation, otherwise FALSE.
//
// Returns:
//   HRESULT indicating success or failure. S_FALSE is a possible result,
// indicating that recursion has occurred in RenameTreeTraversalHelper.
//***************************************************************************
HRESULT CIMAPSync::RenameTreeTraversal(WPARAM wpOperation,
                                       CRenameFolderInfo *pRenameInfo,
                                       BOOL fIncludeRenameFolder)
{
    HRESULT hrResult;
    LPSTR pszCurrentPath;
    DWORD dwSizeOfCurrentPath;
    FOLDERINFO fiFolderInfo;
    BOOL fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameTreeTraversal");
    IxpAssert(m_cRef > 0);

    // Construct the path name to renamed folder's parent, based on operation
    if (tidRENAMESUBSCRIBE == wpOperation ||
        tidRENAMESUBSCRIBE_AGAIN == wpOperation ||
        tidRENAMERENAME == wpOperation)
        pszCurrentPath = pRenameInfo->pszNewFolderPath;
    else
        pszCurrentPath = pRenameInfo->pszFullFolderPath;

    dwSizeOfCurrentPath = lstrlen(pszCurrentPath);

    // We need to get some details about renamed folder node to start the recursion
    hrResult = m_pStore->GetFolderInfo(pRenameInfo->idRenameFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }
    fFreeInfo = TRUE;

    // Start the mayhem
    hrResult = RenameTreeTraversalHelper(wpOperation, pRenameInfo, pszCurrentPath,
        dwSizeOfCurrentPath, fIncludeRenameFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hrResult;
} // RenameTreeTraversal



//***************************************************************************
// Function: RenameTreeTraversalHelper
//
// Purpose:
//   This function actually does the work for RenameTreeTraversal. This
// function is separate so that it can perform the necessary recursion to
// execute the desired operation on every child folder of the rename folder.
//
// Arguments:
//   WPARAM wpOperation [in] - same as for RenameTreeTraversal.
//   CRenameFolderInfo [in/out] - same as for RenameTreeTraversal. Member
//     variables of this class are updated as required in this function
//     (for instance, iNumListRespExpected is incremented for each LIST sent).
//   LPSTR pszCurrentFldrPath [in/out] - a string describing the full path to
//     the current folder. The first call to this function (from Rename-
//     TreeTraversal) is a full path to the rename folder. This function
//     modifies this buffer (adds leaf node names) as needed.
//   DWORD dwLengthOfCurrentPath [in] - length of pszCurrentFldrPath.
//   BOOL fIncludeThisFolder [in] - TRUE if this function should perform
//     the requested operation on the current node. Otherwise, FALSE.
//   FOLDERINFO *pfiCurrentFldrInfo [in] - contains information about the
//     current folder.
//
// Returns:
//   HRESULT indicating success or failure. S_FALSE is a possible return
// result, typically indicating that recursion has taken place.
//***************************************************************************
HRESULT CIMAPSync::RenameTreeTraversalHelper(WPARAM wpOperation,
                                             CRenameFolderInfo *pRenameInfo,
                                             LPSTR pszCurrentFldrPath,
                                             DWORD dwLengthOfCurrentPath,
                                             BOOL fIncludeThisFolder,
                                             FOLDERINFO *pfiCurrentFldrInfo)
{
    HRESULT             hrResult = S_OK;
    FOLDERINFO          fiFolderInfo;
    IEnumerateFolders  *pFldrEnum = NULL;

    TraceCall("CIMAPSync::RenameTreeTraversalHelper");
    IxpAssert(m_cRef > 0);

    // Execute the requested operation, if current folder is not suppressed
    // and if current folder actually exists
    if (fIncludeThisFolder && 0 == (pfiCurrentFldrInfo->dwFlags & FOLDER_NONEXISTENT))
    {
        switch (wpOperation)
        {
            case tidRENAMESUBSCRIBE:
            case tidRENAMESUBSCRIBE_AGAIN:
                hrResult = _EnqueueOperation(wpOperation, (LPARAM) pRenameInfo,
                    icSUBSCRIBE_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumSubscribeRespExpected += 1;
                break; // case tidRENAMESUBSCRIBE

            case tidRENAMELIST:
                // This operation is special-cased to send only ONE list command, a list cmd
                // for the first child fldr. The reason this operation is HERE is because this
                // operation used to list ALL the child fldrs, until I found that IIMAPTransport
                // couldn't resolve the ambiguities. (IIMAPTransport will eventually get queuing).
                IxpAssert(0 == pRenameInfo->iNumListRespExpected); // Send only ONE list cmd!
                hrResult = _EnqueueOperation(tidRENAMELIST, (LPARAM) pRenameInfo,
                    icLIST_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumListRespExpected += 1;
                goto exit; // Do not recurse any further into the folder hierarchy
                break; // case tidRENAMELIST

            case tidRENAMEUNSUBSCRIBE:
                hrResult = _EnqueueOperation(tidRENAMEUNSUBSCRIBE, (LPARAM) pRenameInfo,
                    icUNSUBSCRIBE_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumUnsubscribeRespExpected += 1;
                break; // case tidRENAMEUNSUBSCRIBE

            case tidRENAMERENAME: {
                LPSTR pszRenameCmdOldFldrPath;
                DWORD dwFullFolderPathLen, dwLeafNodeLen;
                LPSTR pszOldFldrPath;
                BOOL fResult;

                // Allocate a buffer for old folder path
                dwFullFolderPathLen = lstrlen(pRenameInfo->pszFullFolderPath);
                dwLeafNodeLen = lstrlen(RemovePrefixFromPath(
                    pRenameInfo->pszNewFolderPath, pszCurrentFldrPath,
                    pRenameInfo->cHierarchyChar, NULL, NULL));
                fResult = MemAlloc((void **)&pszOldFldrPath,
                    dwFullFolderPathLen + dwLeafNodeLen + 2);
                if (FALSE == fResult)
                {
                    hrResult = TraceResult(E_OUTOFMEMORY); // Abort, folder paths aren't getting shorter
                    goto exit;
                }

                // Construct old folder path (MUST be below rename folder level)
                MemFree(pRenameInfo->pszRenameCmdOldFldrPath);
                lstrcpy(pszOldFldrPath, pRenameInfo->pszFullFolderPath);
                *(pszOldFldrPath + dwFullFolderPathLen) = pfiCurrentFldrInfo->bHierarchy;
                lstrcpy(pszOldFldrPath + dwFullFolderPathLen + 1,
                    RemovePrefixFromPath(pRenameInfo->pszNewFolderPath,
                        pszCurrentFldrPath, pRenameInfo->cHierarchyChar, NULL, NULL));
                pRenameInfo->pszRenameCmdOldFldrPath = pszOldFldrPath;

                hrResult = _EnqueueOperation(tidRENAMERENAME, (LPARAM) pRenameInfo,
                    icRENAME_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumRenameRespExpected += 1;
            } // case todRENAMERENAME
                break; // case tidRENAMERENAME

            default:
                AssertSz(FALSE, "I don't know how to perform this operation.");
                hrResult = TraceResult(E_FAIL);
                goto exit;
        } // switch (wpOperation)
    } // if (fIncludeThisFolder)


    // Now, recurse upon all my children, if there are any
    if (0 == (FOLDER_HASCHILDREN & pfiCurrentFldrInfo->dwFlags))
        goto exit; // We're done!

    // Initialize the child-traversal-loop
    hrResult = m_pStore->EnumChildren(pfiCurrentFldrInfo->idFolder, fUNSUBSCRIBE, &pFldrEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    while (S_OK == hrResult)
    {
        LPSTR pszCurrentChild;
        DWORD dwLengthOfCurrentChild;
        BOOL fResult;

        // Construct path to current child
        dwLengthOfCurrentChild = dwLengthOfCurrentPath +
            lstrlen(fiFolderInfo.pszName) + 1; // HC = 1
        fResult = MemAlloc((void **)&pszCurrentChild,
            dwLengthOfCurrentChild + 1); // 1 for null-term
        if (FALSE == fResult)
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        lstrcpy(pszCurrentChild, pszCurrentFldrPath);
        *(pszCurrentChild + dwLengthOfCurrentPath) = pfiCurrentFldrInfo->bHierarchy;
        lstrcpy(pszCurrentChild + dwLengthOfCurrentPath + 1, fiFolderInfo.pszName);

        // Recurse on the child folder, NEVER suppress folders from here on in
        hrResult = RenameTreeTraversalHelper(wpOperation, pRenameInfo,
            pszCurrentChild, dwLengthOfCurrentChild, TRUE, &fiFolderInfo);
        MemFree(pszCurrentChild);
        if (FAILED(hrResult))
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            TraceResult(hrResult);
            goto exit;
        }

        m_pStore->FreeRecord(&fiFolderInfo);
        if (tidRENAMELIST == wpOperation)
            break; // Special case for LIST: only send ONE list cmd (for first child fldr)

        // Advance the loop
        hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    } // while

exit:
    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hrResult;
} // RenameTreeTraversalHelper



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SubscribeSubtree(FOLDERID idFolder, BOOL fSubscribe)
{
    HRESULT             hrResult;
    IEnumerateFolders  *pFldrEnum = NULL;
    FOLDERINFO          fiFolderInfo;

    TraceCall("CIMAPSync::SubscribeSubtree");
    IxpAssert(m_cRef > 0);
    IxpAssert(FOLDERID_INVALID != idFolder);

    // First subscribe the current node
    hrResult = m_pStore->SubscribeToFolder(idFolder, fSubscribe, NOSTORECALLBACK);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Now work on the children
    hrResult = m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pFldrEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    while (S_OK == hrResult)
    {
        // Recurse into children
        hrResult = SubscribeSubtree(fiFolderInfo.idFolder, fSubscribe);
        TraceError(hrResult); // Record error but otherwise continue

        // Advance to next child
        m_pStore->FreeRecord(&fiFolderInfo);
        hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
        TraceError(hrResult);
    }

exit:
    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hrResult;
}



//***************************************************************************
// Function: FindRootHierarchyChar
//
// Purpose:
//   This function is called to analyze hierarchy character information
// collected in m_phcfHierarchyCharInfo, and take appropriate action based
// on the analysis (for example, try to find the hierarchy character using
// a different method if the current method failed). Currently there are 3
// methods of finding a hierarchy character. I call these Plan A, B and C.
//      Plan A: Look for hierarchy char in folder hierarchy listing.
//      Plan B: Issue LIST c_szEmpty c_szEmpty
//      Plan C: Create a temp fldr (no HC's in name), list it, delete it
//      Plan Z: Give up and default HC to NIL. This is still under debate.
//
// Arguments:
//   BOOL fPlanA_Only [in] - TRUE if this function should execute plan A
//     only, and not execute plans B, C or Z.
//   LPARAM lParam [in] - lParam to use when issuing IMAP commands
//
// Returns:
//   If a hierarchy character is found, it is placed in m_cRootHierarchyChar.
//***************************************************************************
void CIMAPSync::FindRootHierarchyChar(BOOL fPlanA_Only, LPARAM lParam)
{
    HRESULT hr;

    TraceCall("CIMAPSync::FindRootHierarchyChar");
    IxpAssert(m_cRef > 0);
    AssertSz(INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar,
        "You want to find the root hierarchy char... but you ALREADY have one. Ah! Efficient.");

    if (NULL == m_phcfHierarchyCharInfo)
    {
        AssertSz(FALSE, "What's the idea, starting a folder DL without a hierarchy char finder?");
        return;
    }

    // Figure out what the hierarchy char is from the collected information
    AnalyzeHierarchyCharInfo();

    // If we haven't found the hierarchy character, launch plan B or C
    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar && FALSE == fPlanA_Only)
    {
        switch (m_phcfHierarchyCharInfo->hcfStage)
        {
            case hcfPLAN_A:
                // Didn't find in folder hierarchy DL (Plan A). Plan "B" is to issue <LIST c_szEmpty c_szEmpty>
                m_phcfHierarchyCharInfo->hcfStage = hcfPLAN_B;
                hr = _EnqueueOperation(tidHIERARCHYCHAR_LIST_B, lParam, icLIST_COMMAND,
                    c_szEmpty, uiNORMAL_PRIORITY);
                TraceError(hr);
                break; // case hcfPLAN_A

            case hcfPLAN_B:
            {
                // Didn't find in <LIST c_szEmpty c_szEmpty> (Plan B). Plan "C": attempt CREATE, LIST, DELETE
                // There's no folders on the server, so very little chance of conflict
                // $REVIEW: Localize fldr name when IMAP handles UTF-7. (idsIMAP_HCFTempFldr)
                lstrcpy(m_phcfHierarchyCharInfo->szTempFldrName, "DeleteMe");
                m_phcfHierarchyCharInfo->hcfStage = hcfPLAN_C;
                hr = _EnqueueOperation(tidHIERARCHYCHAR_CREATE, lParam, icCREATE_COMMAND,
                    m_phcfHierarchyCharInfo->szTempFldrName, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
                break; // case hcfPLAN_B

            default:
            case hcfPLAN_C:
                IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
                AssertSz(FALSE, "This server won't budge - I can't figure out hierarchy char");
                // $REVIEW: Should I put up a message box informing user of situation? Will they understand?
                // We'll just have to assume the hierarchy char is NIL
                // $REVIEW: Is this a good idea? What else can I do about it?
                m_cRootHierarchyChar = '\0';
                break; // case hcfPLAN_C
        }
    }

    // Finally, if we've found hierarchy character, or assumed a value in case
    // hcfPLAN_C above, stop the search and save character to disk
    if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
    {
        StopHierarchyCharSearch();
        hr = LoadSaveRootHierarchyChar(fSAVE_HC);
        TraceError(hr);
    }
}



//***************************************************************************
// Function: AnalyzeHierarchyCharInfo
//
// Purpose:
//   This function examines m_phcfHierarchyCharInfo and attempts to determine
// what the root hierarchy character is. The rules it uses are as follows:
// 1) If more than 1 Non-NIL, Non-"." (NNND), hierarchy char is indeterminate.
// 2) If one NNND-HC found, it is taken as HC. "." and NIL HC's are ignored.
// 3) If no NNND-HC's, but we saw a ".", then "." is HC.
// 4) If no NNND-HC's, no ".", but we saw a non-INBOX NIL, then NIL is HC.
//***************************************************************************
void CIMAPSync::AnalyzeHierarchyCharInfo(void)
{
    int     i;
    int     iNonNilNonDotCount;
    BYTE   *pbBitArray;

    TraceCall("CIMAPSync::AnalyzeHierarchyCharInfo");
    IxpAssert(m_cRef > 0);

    // First, count the number of non-NIL, non-"." hierarchy chars encountered
    iNonNilNonDotCount = 0;
    pbBitArray = m_phcfHierarchyCharInfo->bHierarchyCharBitArray;
    for (i = 0; i < sizeof(m_phcfHierarchyCharInfo->bHierarchyCharBitArray); i++)
    {
        if (0 != *pbBitArray)
        {
            BYTE bCurrentByte;
            int j;

            // Count the number of bits set in this byte
            bCurrentByte = *pbBitArray;
            IxpAssert(1 == sizeof(bCurrentByte)); // Must change code for > 1 byte at a time
            for (j=0; j<8; j++)
            {
                if (bCurrentByte & 0x01)
                {
                    iNonNilNonDotCount += 1;
                    m_cRootHierarchyChar = i*8 + j;
                }

                bCurrentByte >>= 1;
            }
        }

        // Advance the pointer
        pbBitArray += 1;
    }

    // Set the hierarchy character based on priority rules: '/' or '\', then '.', then NIL
    if (iNonNilNonDotCount > 1)
    {
        m_cRootHierarchyChar = INVALID_HIERARCHY_CHAR; // Which one WAS it?

        // Nuke all flags and start afresh
        AssertSz(FALSE, "Hey, lookee here! More than one NNND-HC! How quaint.");
        ZeroMemory(m_phcfHierarchyCharInfo->bHierarchyCharBitArray,
            sizeof(m_phcfHierarchyCharInfo->bHierarchyCharBitArray));
        m_phcfHierarchyCharInfo->fDotHierarchyCharSeen = FALSE;
        m_phcfHierarchyCharInfo->fNonInboxNIL_Seen = FALSE;
    }
    else if (0 == iNonNilNonDotCount)
    {
        // Hmmm, looks like we didn't find anything non-'.' or non-NIL
        IxpAssert(INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar); // Just paranoid
        if (m_phcfHierarchyCharInfo->fDotHierarchyCharSeen)
            m_cRootHierarchyChar = '.';
        else if (m_phcfHierarchyCharInfo->fNonInboxNIL_Seen)
            m_cRootHierarchyChar = '\0';

        // If we reach this point and INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar,
        // all flags must be 0, so no need to nuke as for iNonNilNonDotCount > 1 above
    }
    else
    {
        // We found a non-NIL, non-"." hierarchy char. This will take priority
        // over any NIL or "." hierarchy chars we encountered. STILL, I want to
        // know if we talk to a server who has both one NNND-HC and a "." HC.
        IxpAssert(1 == iNonNilNonDotCount);
        AssertSz(FALSE == m_phcfHierarchyCharInfo->fDotHierarchyCharSeen,
            "Take a look at THIS! A server with one NNND-HC and a '.' HC.");
    }
}



//***************************************************************************
// Function: StopHierarchyCharSearch
//
// Purpose:
//   This function stops future hierarchy character searches by freeing
// the m_phcfHierarchyCharInfo struct.
//***************************************************************************
void CIMAPSync::StopHierarchyCharSearch(void)
{
    TraceCall("CIMAPSync::StopHierararchyCharSearch");
    IxpAssert(m_cRef > 0);

    // Deallocate m_phcfHierarchyCharInfo
    if (NULL != m_phcfHierarchyCharInfo)
    {
        delete m_phcfHierarchyCharInfo;
        m_phcfHierarchyCharInfo = NULL;
    }
    else {
        AssertSz(FALSE, "No search for a root-lvl hierarchy character is in progress.");
    }
}



//***************************************************************************
// Function: LoadSaveRootHierarchyChar
//
// Arguments:
//   BOOL fSaveHC [in] - TRUE if we should save m_cRootHierarchyChar to
//     the root folder entry in the folder cache. FALSE to read
//     m_cRootHierarchyChar from the root folder entry in foldercache.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::LoadSaveRootHierarchyChar(BOOL fSaveHC)
{
    FOLDERINFO  fiRootFldrInfo;
    HRESULT     hr;
    FOLDERID    idCurrFldr;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::LoadSaveRootHierarchyChar");
    IxpAssert(m_cRef > 0);
    IxpAssert(m_pStore != NULL);

    // First thing we have to do is load fiFolderInfo with IMAP server node
    hr = m_pStore->GetFolderInfo(m_idIMAPServer, &fiRootFldrInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Now load or save m_cRootHierarchyChar as directed by user
    fFreeInfo = TRUE;
    if (fSaveHC)
    {
        // Save the hierarchy character to disk
        fiRootFldrInfo.bHierarchy = m_cRootHierarchyChar;
        hr = m_pStore->UpdateRecord(&fiRootFldrInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // Load the hierarchy character
        m_cRootHierarchyChar = fiRootFldrInfo.bHierarchy;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiRootFldrInfo);

    return hr;
}



//***************************************************************************
// Function: CreateNextSpecialFolder
//
// Purpose:
//   This function is called after the tidINBOXLIST operation. This function
// tries to create all IMAP special folders (Sent Items, Drafts, Deleted
// Items). If no more special folders need to be created, the
// post-tidINBOXLIST activities are executed (tidPREFIXLIST/tidBROWSESTART/
// tidFOLDERLIST).
//
// Arguments:
//   CREATE_FOLDER_INFO *pcfiCreateInfo [in] - pointer to CREATE_FOLDER_INFO
//     with properly set pcfiCreateInfo. This function will
//     MemFree pcfiCreateInfo->pszFullFolderPath and delete pcfiCreateInfo
//     when all special folders have been created.
//   LPBOOL pfCompletion [out] - returns TRUE if we are done creating special
//     folders.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::CreateNextSpecialFolder(CREATE_FOLDER_INFO *pcfiCreateInfo,
                                           LPBOOL pfCompletion)
{
    HRESULT     hr = S_OK;
    HRESULT     hrTemp;
    LPARAM      lParam = pcfiCreateInfo->lParam;
    char        szSpecialFldrPath[2*MAX_PATH + 3]; // Leave room for HC, null-term and asterisk
    BOOL        fDone = FALSE;
    BOOL        fPostOp = FALSE;
    BOOL        fSuppressRelease = FALSE;
    IXPSTATUS   ixpCurrentStatus;

    TraceCall("CIMAPSync::CreateNextSpecialFolder");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pcfiCreateInfo);
    IxpAssert(FOLDER_NOTSPECIAL != pcfiCreateInfo->dwCurrentSfType);
    IxpAssert(FOLDER_NOTSPECIAL != pcfiCreateInfo->dwFinalSfType);
    IxpAssert(FOLDER_OUTBOX != pcfiCreateInfo->dwCurrentSfType);
    IxpAssert(FOLDER_OUTBOX != pcfiCreateInfo->dwFinalSfType);
    IxpAssert(pcfiCreateInfo->dwFinalSfType <= FOLDER_MAX);
    IxpAssert(pcfiCreateInfo->dwCurrentSfType <= pcfiCreateInfo->dwFinalSfType);

    szSpecialFldrPath[0] = '\0';

    // If we're looking for root-lvl hierarchy char, maybe this listing will help
    if (NULL != m_phcfHierarchyCharInfo)
        FindRootHierarchyChar(fHCF_PLAN_A_ONLY, lParam);

    hrTemp = LoadSaveRootHierarchyChar(fLOAD_HC);
    TraceError(hrTemp);

    // Get the next folder path if we're in CSF_NEXTFOLDER or CSF_INIT stage
    while (CSF_NEXTFOLDER == pcfiCreateInfo->csfCurrentStage || CSF_INIT == pcfiCreateInfo->csfCurrentStage)
    {
        // If CSF_NEXTFOLDER, bump up current special folder type and check for done-ness
        if (CSF_NEXTFOLDER == pcfiCreateInfo->csfCurrentStage)
        {
            pcfiCreateInfo->dwCurrentSfType += 1;
            if (FOLDER_OUTBOX == pcfiCreateInfo->dwCurrentSfType)
                pcfiCreateInfo->dwCurrentSfType += 1; // Skip Outbox

            if (pcfiCreateInfo->dwCurrentSfType > pcfiCreateInfo->dwFinalSfType)
            {
                fDone = TRUE;
                break;
            }
        }

        hr = ImapUtil_SpecialFldrTypeToPath(m_pszAccountID,
            (SPECIALFOLDER) pcfiCreateInfo->dwCurrentSfType, NULL, m_cRootHierarchyChar,
            szSpecialFldrPath, sizeof(szSpecialFldrPath));

        if (SUCCEEDED(hr))
        {
            // Re-use current pcfiCreateInfo to launch next creation attempt
            if (NULL != pcfiCreateInfo->pszFullFolderPath)
                MemFree(pcfiCreateInfo->pszFullFolderPath);
            pcfiCreateInfo->idFolder = FOLDERID_INVALID;
            pcfiCreateInfo->pszFullFolderPath = StringDup(szSpecialFldrPath);
            pcfiCreateInfo->dwFlags = 0;
            pcfiCreateInfo->csfCurrentStage = CSF_LIST;
            break; // We're ready to create some special folders!
        }
        else if (CSF_INIT == pcfiCreateInfo->csfCurrentStage)
        {
            // Need to exit now on ANY failure, to avoid infinite loop
            fDone = TRUE;
            break;
        }
        else if (STORE_E_NOREMOTESPECIALFLDR == hr)
        {
            // Suppress error: current special folder is disabled or not supported on IMAP
            hr = S_OK;
        }
        else
        {
            TraceResult(hr); // Record but ignore unexpected error
        }

    } // while

    // Check for termination condition
    if (fDone)
        goto exit;

    // If we reach this point, we're ready to act on this special folder
    switch (pcfiCreateInfo->csfCurrentStage)
    {
        case CSF_INIT:
            // CSF_INIT should be resolved by loading a special fldr path and going to CSF_LIST!!
            hr = TraceResult(E_UNEXPECTED);
            break;

        case CSF_LIST:
            IxpAssert('\0' != szSpecialFldrPath[0]);

            if (FOLDER_INBOX == pcfiCreateInfo->dwCurrentSfType)
            {
                // For INBOX ONLY: Issue LIST <specialfldr>* to get subchildren of folder (and folder itself)
                lstrcat(szSpecialFldrPath, g_szAsterisk); // Append "*" to special folder name
            }

            pcfiCreateInfo->csfCurrentStage = CSF_LSUBCREATE;
            hr = _EnqueueOperation(tidSPECIALFLDRLIST, (LPARAM) pcfiCreateInfo,
                icLIST_COMMAND, szSpecialFldrPath, uiNORMAL_PRIORITY);
            TraceError(hr);
            break;

        case CSF_LSUBCREATE:
            // Check if the LIST operation returned the special folder path
            if (CFI_RECEIVEDLISTING & pcfiCreateInfo->dwFlags)
            {
                LPSTR pszPath;

                // Folder exists: Issue LSUB <specialfldr>* to get subscribed subchildren
                IxpAssert(NULL != pcfiCreateInfo->pszFullFolderPath &&
                    '\0' != pcfiCreateInfo->pszFullFolderPath[0]);

                if (FOLDER_INBOX == pcfiCreateInfo->dwCurrentSfType)
                {
                    // For INBOX only: Append "*" to special folder name
                    wsprintf(szSpecialFldrPath, "%s*", pcfiCreateInfo->pszFullFolderPath);
                    pszPath = szSpecialFldrPath;
                }
                else
                    pszPath = pcfiCreateInfo->pszFullFolderPath;

                pcfiCreateInfo->dwFlags = 0;
                pcfiCreateInfo->csfCurrentStage = CSF_CHECKSUB;
                hr = _EnqueueOperation(tidSPECIALFLDRLSUB, (LPARAM) pcfiCreateInfo,
                    icLSUB_COMMAND, pszPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            else
            {
                // Folder does not appear to exist: better create it
                pcfiCreateInfo->dwFlags = 0;
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = _EnqueueOperation(tidCREATE, (LPARAM)pcfiCreateInfo, icCREATE_COMMAND,
                    pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            break;

        case CSF_CHECKSUB:
            // Check if the LSUB operation returned the special folder path
            if (CFI_RECEIVEDLISTING & pcfiCreateInfo->dwFlags)
            {
                // Special folder is already subscribed, advance to next folder
                IxpAssert(FALSE == fDone);
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = CreateNextSpecialFolder(pcfiCreateInfo, &fDone);
                TraceError(hr);

                // BEWARE: do not access pcfiCreateInfo past this point, might be GONE
                fSuppressRelease = TRUE;
            }
            else
            {
                FOLDERID        idTemp;
                LPSTR           pszLocalPath;
                char            szInbox[CCHMAX_STRINGRES];
                SPECIALFOLDER   sfType;

                // Special folder not subscribed. Subscribe it!
                // We need to convert full path to local path. Local path = folder name as it appears in our cache
                pszLocalPath = ImapUtil_GetSpecialFolderType(m_pszAccountID,
                    pcfiCreateInfo->pszFullFolderPath, m_cRootHierarchyChar,
                    m_szRootFolderPrefix, &sfType);

                if (FOLDER_INBOX == sfType)
                {
                    // SPECIAL CASE: We need to replace INBOX with the localized name for INBOX
                    LoadString(g_hLocRes, idsInbox, szInbox, sizeof(szInbox));
                    pszLocalPath = szInbox;
                }

                // Remove special folder from unsubscribed folder list (ignore error)
                if (NULL != m_pListHash)
                {
                    hr = m_pListHash->Find(pszLocalPath, fREMOVE, (void **) &idTemp);
                    IxpAssert(FAILED(hr) || idTemp == pcfiCreateInfo->idFolder);
                }

                // Use full path here (not local path)
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = _EnqueueOperation(tidSPECIALFLDRSUBSCRIBE, (LPARAM)pcfiCreateInfo,
                    icSUBSCRIBE_COMMAND, pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            break;

        default:
            AssertSz(FALSE, "We are at an unknown stage!");
            hr = TraceResult(E_FAIL);
            break;
    }

exit:
    // At this point, do not access pcfiCreateInfo if fSuppressRelease is TRUE!!

    if (FAILED(hr))
        fDone = TRUE;

    // Check if we are done and there are post-create operations to perform
    if (FALSE == fSuppressRelease && PCO_NONE != pcfiCreateInfo->pcoNextOp)
    {
        IxpAssert(PCO_APPENDMSG == pcfiCreateInfo->pcoNextOp);
        if (fDone && SUCCEEDED(hr))
        {
            hr = _EnqueueOperation(tidUPLOADMSG, pcfiCreateInfo->lParam, icAPPEND_COMMAND,
                pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
            TraceError(hr);

            fPostOp = TRUE; // Returns *pfCompletion = FALSE but releases CREATE_FOLDER_INFO
        }
        else if (FAILED(hr))
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) pcfiCreateInfo->lParam;

            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);
            delete pAppendInfo;
        }
    }

    if (fDone && FALSE == fSuppressRelease)
    {
        EndFolderList();

        if (NULL != pcfiCreateInfo->pszFullFolderPath)
            MemFree(pcfiCreateInfo->pszFullFolderPath);

        delete pcfiCreateInfo;
    }

    if (NULL != pfCompletion)
        *pfCompletion = (fDone && FALSE == fPostOp);

    return hr;
}



// This is not the only place to start a folder list. For example,
// look at successful tidPREFIXLIST. Use this fn only where applicable.
HRESULT CIMAPSync::_StartFolderList(LPARAM lParam)
{
    HRESULT         hr = E_FAIL;
    IImnAccount    *pAcct;

    TraceCall("CIMAPSync::_StartFolderList");
    IxpAssert(m_cRef > 0);

    // If user started a folder list, we'll clear the AP_IMAP_DIRTY property
    // The goal is not to pester the user with refresh folder list dialogs
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    TraceError(hr);
    if (SUCCEEDED(hr))
    {
        DWORD dwSrc;

        hr = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwSrc);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            DWORD dwDest;

            AssertSz(0 == (dwSrc & ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY |
                IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY)), "Please update my dirty bits!");

            // Clear these dirty bits since folder refresh solves all of these problems
            dwDest = dwSrc & ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY |
                    IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);

            if (dwDest != dwSrc)
            {
                hr = pAcct->SetPropDw(AP_IMAP_DIRTY, dwDest);
                TraceError(hr);
                if (SUCCEEDED(hr))
                {
                    hr = pAcct->SaveChanges();
                    TraceError(hr);
                }
            }
        }

        pAcct->Release();
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode((FOLDERID) lParam);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Did user specify a root folder prefix?
    if ('\0' != m_szRootFolderPrefix[0])
    {
        // User-specified prefix exists. Check if prefix exists on IMAP server
        hr = _EnqueueOperation(tidPREFIXLIST, lParam, icLIST_COMMAND,
            m_szRootFolderPrefix, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // No root prefix folder, start folder refresh
        hr = _EnqueueOperation(tidFOLDERLIST, lParam, icLIST_COMMAND,
            g_szAsterisk, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    return hr;
}



//***************************************************************************
// Function: OnResponse
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::OnResponse(const IMAP_RESPONSE *pimr)
{
    HRESULT     hr=S_OK;

    TraceCall("CIMAPSync::OnResponse");
    AssertSingleThreaded;

    switch (pimr->irtResponseType)
    {
        case irtERROR_NOTIFICATION:
            AssertSz(FALSE, "Received IIMAPCallback(irtERROR_NOTIFICATION). Ignoring it.");
            break;

        case irtCOMMAND_COMPLETION:
            hr = _OnCmdComplete(pimr->wParam, pimr->lParam,
                                pimr->hrResult, pimr->lpszResponseText);
            break;

        case irtSERVER_ALERT:
            hr = _ShowUserInfo(MAKEINTRESOURCE(idsIMAPServerAlertTitle),
                                MAKEINTRESOURCE(idsIMAPServerAlertIntro),
                                pimr->lpszResponseText);
            break;

        case irtPARSE_ERROR:
            // Do not display PARSE errors to user. These are really just WARNINGS
            // and so no need to interrupt flow with these. Besides, UW IMAP puts up
            // tonnes of these when you ask for ENVELOPE and it feels that the msgs are mal-formed
            break;

        case irtMAILBOX_UPDATE:
            hr = _OnMailBoxUpdate(pimr->irdResponseData.pmcMsgCount);
            break;

        case irtDELETED_MSG:
            hr = _OnMsgDeleted(pimr->irdResponseData.dwDeletedMsgSeqNum);
            break;

        case irtFETCH_BODY:
            hr = _OnFetchBody(pimr->hrResult, pimr->irdResponseData.pFetchBodyPart);
            break;

        case irtUPDATE_MSG:
            AssertSz(FALSE, "We should no longer get irtUPDATE_MSG, but the extended version instead");
            break;

        case irtUPDATE_MSG_EX:
            hr = _OnUpdateMsg(pimr->wParam, pimr->hrResult, pimr->irdResponseData.pFetchResultsEx);
            break;

        case irtAPPLICABLE_FLAGS:
            hr = _OnApplFlags(pimr->wParam,
                                pimr->irdResponseData.imfImapMessageFlags);
            break;

        case irtPERMANENT_FLAGS:
            hr = _OnPermFlags(pimr->wParam,
                                pimr->irdResponseData.imfImapMessageFlags,
                                pimr->lpszResponseText);
            break;

        case irtUIDVALIDITY:
            hr = _OnUIDValidity(pimr->wParam,
                                pimr->irdResponseData.dwUIDValidity,
                                pimr->lpszResponseText);
            break;

        case irtREADWRITE_STATUS:
            hr = _OnReadWriteStatus(pimr->wParam,
                                    pimr->irdResponseData.bReadWrite,
                                    pimr->lpszResponseText);
            break;

        case irtTRYCREATE:
            _OnTryCreate(pimr->wParam, pimr->lpszResponseText);
            break;

        case irtSEARCH:
            hr = _OnSearchResponse(pimr->wParam,
                                    pimr->irdResponseData.prlSearchResults);
            break;

        case irtMAILBOX_LISTING:
            hr = _OnMailBoxList(pimr->wParam,
                                pimr->lParam,
                                pimr->irdResponseData.illrdMailboxListing.pszMailboxName,
                                pimr->irdResponseData.illrdMailboxListing.imfMboxFlags,
                                pimr->irdResponseData.illrdMailboxListing.cHierarchyChar,
                                IXP_S_IMAP_VERBATIM_MBOX == pimr->hrResult);
            break;

        case irtAPPEND_PROGRESS:
            IxpAssert(tidUPLOADMSG == pimr->wParam);
            hr = _OnAppendProgress(pimr->lParam,
                pimr->irdResponseData.papAppendProgress->dwUploaded,
                pimr->irdResponseData.papAppendProgress->dwTotal);
            break;

        case irtMAILBOX_STATUS:
            hr = _OnStatusResponse(pimr->irdResponseData.pisrStatusResponse);
            break;

        default:
            AssertSz(FALSE, "Received unknown IMAP response type via OnResponse");
            break;
    }

    TraceError(hr);
    return S_OK;    // never fail the OnResponse
}



//***************************************************************************
// Function: OnTimeout
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    HRESULT hr;
    AssertSingleThreaded;

    TraceCall("CIMAPSync::OnTimeout");
    IxpAssert(m_cRef > 0);

    if (NULL == m_pCurrentCB)
        return S_OK; // We'll just wait until the cows come home
    else
        return m_pCurrentCB->OnTimeout(&m_rInetServerInfo, pdwTimeout, IXP_IMAP);
}



//***************************************************************************
// Function: OnLogonPrompt
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnLogonPrompt(LPINETSERVER pInetServer,
                                 IInternetTransport *pTransport)
{
    BOOL    bResult;
    char    szPassword[CCHMAX_PASSWORD];
    HRESULT hr;
    HWND    hwnd;

    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, szPassword, sizeof(pInetServer->szPassword));
        return S_OK;
    }

    // Propagate call up to callback
    if (NULL == m_pCurrentCB)
        return S_FALSE;

    hr = m_pCurrentCB->OnLogonPrompt(pInetServer, IXP_IMAP);
    if (S_OK == hr)
    {
        // Cache password for future reference this session
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);
    }

    else if (S_FALSE == hr)
    {
        m_hrOperationResult = STORE_E_OPERATION_CANCELED;
        LoadString(g_hLocRes, IDS_IXP_E_USER_CANCEL, m_szOperationProblem,
            sizeof(m_szOperationProblem));
    }
    else if (FAILED(hr))
        m_hrOperationResult = hr;

    return hr;
}



//***************************************************************************
// Function: OnPrompt
// Description: See imnxport.idl for details.
//***************************************************************************
INT CIMAPSync::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption,
                        UINT uType, IInternetTransport *pTransport)
{
    INT     iResult=IDCANCEL;

    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    if (NULL != m_pCurrentCB)
    {
        HRESULT hr;

        hr = m_pCurrentCB->OnPrompt(hrError, pszText, pszCaption,
            uType, &iResult);
        TraceError(hr);
    }

    return iResult;
}



//***************************************************************************
// Function: OnStatus
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnStatus(IXPSTATUS ixpStatus, IInternetTransport *pTransport)
{
    HRESULT hrTemp;
    IStoreCallback *pCallback;

    TraceCall("CIMAPSync::OnStatus");
    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    if (NULL != m_pCurrentCB)
        pCallback = m_pCurrentCB;
    else
        pCallback = m_pDefCallback;

    // Report status to UI component
    if (NULL != pCallback)
    {
        hrTemp = pCallback->OnProgress(SOT_CONNECTION_STATUS, ixpStatus, 0,
            m_rInetServerInfo.szServerName);
        TraceError(hrTemp);
    }

    switch (ixpStatus)
    {
        case IXP_AUTHORIZED:
            m_issCurrent = issAuthenticated;

            // Clear any OnError's collected (typ. from one or more login rejections)
            m_hrOperationResult = OLE_E_BLANK;

            hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_CONNCOMPLETE);
            TraceError(hrTemp);
            break;

        case IXP_DISCONNECTED:
            // If we're disconnecting due to reconnect attempt, do not abort operation
            if (m_fReconnect)
            {
                // if we got disconnected reset the current and pending state
                OnFolderExit();
                m_issCurrent = issNotConnected;
                m_fDisconnecting = FALSE; // We are now done with disconnection
                break;
            }

            // Figure out if we were ever connected
            if (OLE_E_BLANK == m_hrOperationResult)
            {
                if (issNotConnected == m_issCurrent)
                    m_hrOperationResult = IXP_E_FAILED_TO_CONNECT;
                else
                    m_hrOperationResult = IXP_E_CONNECTION_DROPPED;
            }

            OnFolderExit();
            FlushOperationQueue(issNotConnected, m_hrOperationResult);

            // if we got disconnected reset the current and pending state
            m_issCurrent = issNotConnected;
            m_fDisconnecting = FALSE; // We are now done with disconnection

            // There is only one case where _OnCmdComplete doesn't get the chance
            // to issue the CFSM_EVENT_ERROR, and that's when we never even connect
            if (CFSM_STATE_WAITFORCONN == m_cfsState)
            {
                // Move state machine along to abort this operation and reset
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_ERROR);
                TraceError(hrTemp);
                m_fTerminating = TRUE; // CFSM_EVENT_ERROR should make us go to CFSM_STATE_OPERATIONCOMPLETE
            }
            break;

        case IXP_CONNECTED:
            // if we get the first 'connected' then we are not yet
            // AUTH'ed, so trasition into issNonAuthenticated if we
            // get authorized, we transition into Authenticated
            if (m_issCurrent == issNotConnected)
                m_issCurrent = issNonAuthenticated;
            break;
    }

    return S_OK; // Yippee, we have status
}



//***************************************************************************
// Function: OnError
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnError(IXPSTATUS ixpStatus, LPIXPRESULT pResult,
                           IInternetTransport *pTransport)
{
    AssertSingleThreaded;

    // Currently all OnError calls are due to logon/connection problems
    // Not much we can do: there's no way to show error outside of OnComplete

    // One thing we CAN do is to store error text. If we are disconnected next,
    // we will have something to show the user
    if (NULL != pResult->pszProblem)
        lstrcpyn(m_szOperationProblem, pResult->pszProblem, sizeof(m_szOperationProblem));

    if (NULL != pResult->pszResponse)
        lstrcpyn(m_szOperationDetails, pResult->pszResponse, sizeof(m_szOperationDetails));

    m_hrOperationResult = pResult->hrResult;

    // Ignore all errors except for the following:
    if (IXP_E_IMAP_LOGINFAILURE == pResult->hrResult)
    {
        HRESULT         hrTemp;
        HWND            hwndParent;

        hrTemp = GetParentWindow(0, &hwndParent);
        if (FAILED(hrTemp))
        {
            // Not much we can do here!
            TraceInfoTag(TAG_IMAPSYNC, _MSG("*** CIMAPSync::OnError received for %s operation",
                sotToSz(m_sotCurrent)));
        }
        else
        {
            STOREERROR  seErrorInfo;

            // Display error to user ourselves
            FillStoreError(&seErrorInfo, pResult->hrResult, pResult->dwSocketError, NULL, NULL);
            CallbackDisplayError(hwndParent, seErrorInfo.hrResult, &seErrorInfo);
        }
    }

    return S_OK;
} // OnError



//***************************************************************************
// Function: OnCommand
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnCommand(CMDTYPE cmdtype, LPSTR pszLine,
                             HRESULT hrResponse, IInternetTransport *pTransport)
{
    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    // We should never get this
    AssertSz(FALSE, "*** Received ITransportCallback::OnCommand callback!!!");
    return S_OK;
}




//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr = E_FAIL;

    AssertSingleThreaded;

    // Ask the callback recipient
    if (NULL != m_pCurrentCB)
    {
        hr = m_pCurrentCB->GetParentWindow(dwReserved, phwndParent);
        TraceError(hr);
    }
    else if (NULL != m_pDefCallback)
    {
        hr = m_pDefCallback->GetParentWindow(dwReserved, phwndParent);
        TraceError(hr);
    }

    if (FAILED(hr))
    {
        // We're not supposed to put up any UI
        *phwndParent = NULL;
    }

    return hr;
}

//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Args
    Assert(ppAccount);
    Assert(g_pAcctMan);
    Assert(m_pszAccountID);

    // Initialize
    *ppAccount = NULL;

    // Find the Account
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, ppAccount));

    // Set the server type
    *pdwServerType = SRV_IMAP;

exit:
    // Done
    return(hr);
}

//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_ShowUserInfo(LPSTR pszTitle, LPSTR pszText1, LPSTR pszText2)
{
    char            szTitle[CCHMAX_STRINGRES];
    char            szUserInfo[2 * CCHMAX_STRINGRES];
    LPSTR           p;
    HRESULT         hr;
    INT             iTemp;
    IStoreCallback *pCallback;

    TraceCall("CIMAPSync::_ShowUserInfo");
    AssertSingleThreaded;

    // Check args
    if (NULL == pszTitle || NULL == pszText1)
    {
        AssertSz(FALSE, "pszTitle and pszText1 cannot be NULL");
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    if (NULL != m_pCurrentCB)
        pCallback = m_pCurrentCB;
    else
        pCallback = m_pDefCallback;

    // Check if we have a callback to call
    if (NULL == pCallback)
        return S_OK; // Nothing to do here!

    if (IS_INTRESOURCE(pszTitle))
    {
        LoadString(g_hLocRes, PtrToUlong(pszTitle), szTitle, sizeof(szTitle));
        pszTitle = szTitle;
    }

    p = szUserInfo;
    if (IS_INTRESOURCE(pszText1))
        p += LoadString(g_hLocRes, PtrToUlong(pszText1), szUserInfo, sizeof(szUserInfo));

    if (NULL != pszText2)
    {
        if (IS_INTRESOURCE(pszText2))
            LoadString(g_hLocRes, PtrToUlong(pszText2), p, sizeof(szUserInfo) -
                (int) (p - szUserInfo));
        else
            lstrcpyn(p, pszText2, sizeof(szUserInfo) - (int) (p - szUserInfo));
    }

    hr = pCallback->OnPrompt(S_OK, szUserInfo, pszTitle, MB_OK, &iTemp);
    TraceError(hr);

exit:
    return hr;
}



//***************************************************************************
// Function: OnMailBoxUpdate
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnMailBoxUpdate(MBOX_MSGCOUNT *pNewMsgCount)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::OnMailBoxUpdate");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pNewMsgCount);

    // Handle EXISTS response - calculate number of new msgs, update m_dwMsgCount
    if (pNewMsgCount->bGotExistsResponse)
    {
        // Since we are guaranteed to get all EXPUNGE responses, and since
        // we decrement m_dwMsgCount for each EXPUNGE, number of new messages
        // is difference between current EXISTS count and m_dwMsgCount.
        if (m_fMsgCountValid)
        {
            if (pNewMsgCount->dwExists >= m_dwMsgCount)
                m_dwNumNewMsgs += pNewMsgCount->dwExists - m_dwMsgCount;
        }

        m_dwMsgCount = pNewMsgCount->dwExists;
        m_fMsgCountValid = TRUE;

        // Make sure msg seq num <-> UID table is proper size for this mbox
        // Record but otherwise ignore errors
        hrTemp = m_pTransport->ResizeMsgSeqNumTable(pNewMsgCount->dwExists);
        TraceError(hrTemp);
    }


    // New messages! Woo hoo!
    if (m_dwNumNewMsgs > 0)
    {
        m_dwSyncToDo |= (m_dwSyncFolderFlags & SYNC_FOLDER_NEW_HEADERS);
        hrTemp = _SyncHeader();
        TraceError(hrTemp);
    }
    return S_OK;
}



//***************************************************************************
// Function: _OnMsgDeleted
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnMsgDeleted(DWORD dwDeletedMsgSeqNum)
{
    DWORD           dwDeletedMsgUID, dwHighestMSN;
    HRESULT         hr;
    MESSAGEIDLIST   midList;
    MESSAGEID       mid;

    TraceCall("CIMAPSync::DeletedMsgNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(0 != dwDeletedMsgSeqNum);

    // Regardless of outcome, an EXPUNGE means there's one less msg - update vars
    if (m_fMsgCountValid)
        m_dwMsgCount -= 1;

    // Is this msg seq num within our translation range?
    hr = m_pTransport->GetHighestMsgSeqNum(&dwHighestMSN);
    if (SUCCEEDED(hr) && dwDeletedMsgSeqNum > dwHighestMSN)
        return S_OK; // We got an EXPUNGE for a hdr we've never DL'ed

    // Find out who got the axe
    hr = m_pTransport->MsgSeqNumToUID(dwDeletedMsgSeqNum, &dwDeletedMsgUID);
    if (FAILED(hr) || 0 == dwDeletedMsgUID)
    {
        // Failure here means we either got a bogus msg seq num, or we got an
        // EXPUNGE during SELECT (before the tidFETCH_CACHED_FLAGS transaction).
        // If the latter is true, it's no big deal since FETCHes will sync us up.
        TraceResult(E_FAIL); // Record but otherwise ignore error
        goto exit;
    }

    // Delete message from the cache. Note that we do not care about error
    // because even in case of error, we must resequence the table
    mid = (MESSAGEID)((DWORD_PTR)dwDeletedMsgUID);
    midList.cAllocated = 0;
    midList.cMsgs = 1;
    midList.prgidMsg = &mid;

    hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &midList, NULL, NULL);
    TraceError(hr);

exit:
    // Resequence our msg seq num <-> UID table
    hr = m_pTransport->RemoveSequenceNum(dwDeletedMsgSeqNum);
    TraceError(hr);
    return S_OK;
}



//***************************************************************************
// Function: _OnFetchBody
// Purpose: This function handles the irtFETCH_BODY response type of
//   IIMAPCallback::OnResponse.
//***************************************************************************
HRESULT CIMAPSync::_OnFetchBody(HRESULT hrFetchBodyResult,
                                FETCH_BODY_PART *pFetchBodyPart)
{
    LPSTREAM    lpstmRFC822; // Only used for RFC822.HEADER
    HRESULT     hr;

    TraceCall("CIMAPSync::_OnFetchBody");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchBodyPart);
    IxpAssert(NULL != pFetchBodyPart->pszBodyTag);
    IxpAssert(NULL != pFetchBodyPart->pszData);
    IxpAssert(0 != pFetchBodyPart->dwMsgSeqNum);

    // Initialize variables
    hr = S_OK;
    lpstmRFC822 = (LPSTREAM) pFetchBodyPart->lpFetchCookie2;

    // Check for (and deal with) failure
    if (FAILED(hrFetchBodyResult))
    {
        DWORD dwUID;

        TraceResult(hrFetchBodyResult);
        pFetchBodyPart->lpFetchCookie1 = fbpNONE;
        if (NULL != lpstmRFC822)
        {
            lpstmRFC822->Release();
            pFetchBodyPart->lpFetchCookie2 = NULL;
        }

        // Get the UID of this message
        hr = m_pTransport->MsgSeqNumToUID(pFetchBodyPart->dwMsgSeqNum, &dwUID);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        NotifyMsgRecipients(dwUID, fCOMPLETED, NULL, hrFetchBodyResult, NULL);
        goto exit;
    }

    // Identify this fetch body tag, if we haven't already
    if (fbpNONE == pFetchBodyPart->lpFetchCookie1)
    {
        // First check for incoming body, then check for incoming header
        if (0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "RFC822") ||
            0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "BODY[]"))
        {
            pFetchBodyPart->lpFetchCookie1 = fbpBODY;
        }
        else if (0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "RFC822.HEADER") ||
                 0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "BODY[HEADER.FIELDS"))
        {
            pFetchBodyPart->lpFetchCookie1 = fbpHEADER;

            // Create a stream
            IxpAssert(NULL == lpstmRFC822);
            hr = MimeOleCreateVirtualStream(&lpstmRFC822);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            pFetchBodyPart->lpFetchCookie2 = (LPARAM) lpstmRFC822;
        }
        else
        {
            AssertSz(FALSE, "What kind of tag is this?");
            pFetchBodyPart->lpFetchCookie1 = fbpUNKNOWN;
        }

    }

    // If this is a message body, update progress
    if (fbpBODY == pFetchBodyPart->lpFetchCookie1)
    {
        DWORD dwUID;

        hr = m_pTransport->MsgSeqNumToUID(pFetchBodyPart->dwMsgSeqNum, &dwUID);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        NotifyMsgRecipients(dwUID, fPROGRESS, pFetchBodyPart, S_OK, NULL);
    }

    // Append the data to a stream
    if (NULL != lpstmRFC822)
    {
        DWORD dwNumBytesWritten;

        IxpAssert(fbpHEADER == pFetchBodyPart->lpFetchCookie1);
        hr = lpstmRFC822->Write(pFetchBodyPart->pszData,
            pFetchBodyPart->dwSizeOfData, &dwNumBytesWritten);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        IxpAssert(dwNumBytesWritten == pFetchBodyPart->dwSizeOfData);
    }

exit:
    return S_OK;
}



//***************************************************************************
// Function: _OnUpdateMsg
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnUpdateMsg(WPARAM tid, HRESULT hrFetchCmdResult,
                                FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::UpdateMsgNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);

    // Keep our msg seq num <-> UID table up to date
    if (pFetchResults->bUID)
    {
        // Record error but otherwise ignore
        hrTemp = m_pTransport->UpdateSeqNumToUID(pFetchResults->dwMsgSeqNum,
            pFetchResults->dwUID);
        TraceError(hrTemp);
    }
    else
    {
        HRESULT hr;
        DWORD dwHighestMSN;

        // No UID w/ FETCH resp means this is unsolicited: check that we already have hdr
        hr = m_pTransport->GetHighestMsgSeqNum(&dwHighestMSN);
        TraceError(hr);
        if (SUCCEEDED(hr) && pFetchResults->dwMsgSeqNum > dwHighestMSN)
            goto exit; // Can't translate MsgSeqNum to UID, typ. because svr is reporting
                       // flag updates on msgs which we haven't had hdrs DL'ed yet. No prob,
                       // if svr reported EXISTS correctly, we should be DL'ing hdrs shortly

        // Either unsolicited FETCH, or server needs to learn to send UID for UID cmds
        hr = m_pTransport->MsgSeqNumToUID(pFetchResults->dwMsgSeqNum, &pFetchResults->dwUID);
        if (FAILED(hr) || 0 == pFetchResults->dwUID)
        {
            TraceResult(hr);
            goto exit;
        }
        else
            pFetchResults->bUID = TRUE;
    }

    // We classify our fetch responses as header downloads, body downloads,
    // and flag updates.
    if (pFetchResults->bEnvelope)
    {
        // We only get envelopes when we are asking for headers
        Assert(fbpBODY != pFetchResults->lpFetchCookie1);
        pFetchResults->lpFetchCookie1 = fbpHEADER;
    }

    switch (pFetchResults->lpFetchCookie1)
    {
        case fbpHEADER:
            UpdateMsgHeader(tid, hrFetchCmdResult, pFetchResults);
            break;

        case fbpBODY:
            UpdateMsgBody(tid, hrFetchCmdResult, pFetchResults);
            break;

        default:
            AssertSz(fbpNONE == pFetchResults->lpFetchCookie1, "Unhandled FetchBodyPart type");
            UpdateMsgFlags(tid, hrFetchCmdResult, pFetchResults);
            break;
    }


exit:
    // If we allocated a stream, free it
    if (NULL != pFetchResults->lpFetchCookie2)
        ((LPSTREAM)pFetchResults->lpFetchCookie2)->Release();

    return S_OK;
}



//***************************************************************************
// Function: UpdateMsgHeader
//
// Purpose:
//   This function takes a message header returned via FETCH response,
// caches it, and notifies the view.
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgHeader( WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT     hr;
    MESSAGEINFO miMsgInfo={0};

    TraceCall("CIMAPSync::UpdateMsgHeader");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpHEADER == pFetchResults->lpFetchCookie1);

    // Make sure we have everything we need
    if (FAILED(hrFetchCmdResult))
    {
        // Error on FETCH response, forget this header
        hr = TraceResult(hrFetchCmdResult);
        goto exit;
    }

    if (NULL == pFetchResults->lpFetchCookie2 && FALSE == pFetchResults->bEnvelope)
    {
        // I don't do ANYTHING without an RFC822.HEADER stream or envelope
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // First, check if we already have this header cached
    miMsgInfo.idMessage = (MESSAGEID)((DWORD_PTR)pFetchResults->dwUID);
    hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &miMsgInfo, NULL);
    if (DB_S_FOUND == hr)
    {
        // No need for alarm, we'll just swallow this header
        m_pFolder->FreeRecord(&miMsgInfo);
        goto exit; // We already have this header - we shouldn't have gotten this
                    // On some IMAP servers, if you UID FETCH <highestCachedUID + 1>:*
                    // you get a fetch response for highestCachedUID! Ignore this fetch result.
    }

    m_pFolder->FreeRecord(&miMsgInfo);

    // Cache this header, since it's not in our cache already
    hr = Fill_MESSAGEINFO(pFetchResults, &miMsgInfo);
    if (FAILED(hr))
    {
        FreeMessageInfo(&miMsgInfo); // There could be a couple of fields in there
        TraceResult(hr);
        goto exit;
    }

    hr = m_pFolder->InsertRecord(&miMsgInfo);
    if (SUCCEEDED(hr) && 0 == (ARF_READ & miMsgInfo.dwFlags))
        m_fNewMail = TRUE;

    FreeMessageInfo(&miMsgInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Bump up synchronize headers progress
    // Currently the only way we can get a hdr is through sync-up. Later on we'll
    // be able to get individual hdrs at which point this code should be updated
    if (TRUE)
    {
        DWORD dwNumExpectedMsgs;

        // Recalculate total number of expected messages
        if (m_fMsgCountValid &&
            m_dwMsgCount + m_dwNumHdrsDLed + 1 >= pFetchResults->dwMsgSeqNum)
        {
            IxpAssert(m_dwNumHdrsDLed < pFetchResults->dwMsgSeqNum);
            dwNumExpectedMsgs = m_dwMsgCount + m_dwNumHdrsDLed + 1 -
                pFetchResults->dwMsgSeqNum;
            if (dwNumExpectedMsgs != m_dwNumHdrsToDL)
            {
                // Record but otherwise ignore this fact
                TraceInfoTag(TAG_IMAPSYNC, _MSG("*** dwNumExpectedMsgs = %lu, m_dwNumHdrsToDL = %lu!",
                    dwNumExpectedMsgs, m_dwNumHdrsToDL));
            }
        }

        m_dwNumHdrsDLed += 1;
        if (pFetchResults->bMsgFlags && ISFLAGCLEAR(pFetchResults->mfMsgFlags, IMAP_MSG_SEEN))
            m_dwNumUnreadDLed += 1;

        if (NULL != m_pCurrentCB && SOT_SYNC_FOLDER == m_sotCurrent)
        {
            HRESULT hrTemp;

            hrTemp = m_pCurrentCB->OnProgress(SOT_SYNC_FOLDER,
                m_dwNumHdrsDLed, dwNumExpectedMsgs, m_pszFldrLeafName);
            TraceError(hrTemp);
        }
    }


exit:
    return hr;
}



//***************************************************************************
// Function: UpdateMsgBody
//
// Purpose:
//   This function takes a message body returned via FETCH response,
// caches it, and notifies all interested parties (there may be more
// than one).
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgBody(   WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    TraceCall("CIMAPSync::UpdateMsgBody");

    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpBODY == pFetchResults->lpFetchCookie1);

    // Record any fetch error
    TraceError(hrFetchCmdResult);

    // We used to call NotifyMsgRecipients(fCOMPLETED) here, but since we only
    // get one body at a time, we should defer to _OnCmdComplete. This is because
    // FETCH body responses have multiple failure modes: tagged OK with no body,
    // tagged NO with no body, tagged OK with literal of size 0 (Netscape). To
    // easily avoid calling NotifyMsgRecipients twice, don't call from here.

    // It's possible to have FETCH response with no body: If you fetch an expunged
    // msg from a Netscape svr, you get a literal of size 0. Check for this case.
    if (SUCCEEDED(hrFetchCmdResult) && FALSE == m_fGotBody)
        hrFetchCmdResult = STORE_E_EXPIRED;

    if (FAILED(hrFetchCmdResult) &&
       (SUCCEEDED(m_hrOperationResult) || OLE_E_BLANK == m_hrOperationResult))
    {
        // We don't have an error set yet. Record this error
        m_hrOperationResult = hrFetchCmdResult;
    }

    return S_OK;
}



//***************************************************************************
// Function: UpdateMsgFlags
//
// Purpose:
//   This function takes a message's flags returned via FETCH response,
// updates the cache, and notifies the view.
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgFlags(  WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     miMsgInfo;
    MESSAGEFLAGS    mfFlags;
    BOOL            fFreeMsgInfo = FALSE;


    TraceCall("CIMAPSync::UpdateMsgFlags");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpNONE == pFetchResults->lpFetchCookie1);
    IxpAssert(0 == pFetchResults->lpFetchCookie2);

    if (FAILED(hrFetchCmdResult))
    {
        // Error on FETCH response, forget this flag update
        hr = TraceResult(hrFetchCmdResult);
        goto exit;
    }

    // We expect that if there is no header and no body, that this is either
    // a solicited or unsolicited flag update
    if (FALSE == pFetchResults->bMsgFlags)
    {
        hr = S_OK; // We'll just ignore this fetch response. No need to wig out
        goto exit;
    }

    // Get the header for this message
    miMsgInfo.idMessage = (MESSAGEID)((DWORD_PTR)pFetchResults->dwUID);
    hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &miMsgInfo, NULL);
    if (DB_S_FOUND != hr)
    {
        TraceError(hr);
        goto exit;
    }

    // Convert IMAP flags to ARF_* flags
    fFreeMsgInfo = TRUE;
    mfFlags = miMsgInfo.dwFlags;
    mfFlags &= ~DwConvertIMAPtoARF(IMAP_MSG_ALLFLAGS); // Clear old IMAP flags
    mfFlags |= DwConvertIMAPtoARF(pFetchResults->mfMsgFlags); // Set IMAP flags

    // Are the new flags any different from our cached ones?
    if (mfFlags != miMsgInfo.dwFlags)
    {
        // Save new flags
        miMsgInfo.dwFlags = mfFlags;
        hr = m_pFolder->UpdateRecord(&miMsgInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    if (fFreeMsgInfo)
        m_pFolder->FreeRecord(&miMsgInfo);

    return hr;
}



//***************************************************************************
// Function: _OnApplFlags
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnApplFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags)
{
    TraceCall("CIMAPSync::_OnApplFlags");

    // Save flags and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    return S_OK;
}



//***************************************************************************
// Function: _OnPermFlags
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnPermFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::PermanentFlagsNotification");
    IxpAssert(m_cRef > 0);

    // Save flags and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    return S_OK;
}



//***************************************************************************
// Function: _OnUIDValidity
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnUIDValidity(WPARAM tid, DWORD dwUIDValidity, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::UIDValidityNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Save UIDVALIDITY and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    m_dwUIDValidity = dwUIDValidity;
    return S_OK;
}



//***************************************************************************
// Function: _OnReadWriteStatus
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnReadWriteStatus(WPARAM tid, BOOL bReadWrite, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::_OnReadWriteStatus");
    IxpAssert(NULL != lpszResponseText);

    // Save status and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.

    // I'm ignoring above statement because UW server sends READ-ONLY unilaterally.
    // Above statement isn't currently valid anyway, I don't re-use connection if
    // it's in the middle of SELECT (found out how bad it was after I tried it).

    // Look for READ-WRITE to READ-ONLY transition
    if (rwsUNINITIALIZED != m_rwsReadWriteStatus)
    {
        if (rwsREAD_WRITE == m_rwsReadWriteStatus && FALSE == bReadWrite)
        {
            HRESULT hrTemp;

            hrTemp = _ShowUserInfo(MAKEINTRESOURCE(idsAthenaMail),
                MAKEINTRESOURCE(idsIMAPFolderReadOnly), lpszResponseText);
            TraceError(hrTemp);
        }
    }

    // Save current read-write status for future reference
    if (bReadWrite)
        m_rwsReadWriteStatus = rwsREAD_WRITE;
    else
        m_rwsReadWriteStatus = rwsREAD_ONLY;

    return S_OK;
}



//***************************************************************************
// Function: TryCreateNotification
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnTryCreate(WPARAM tid, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::TryCreateNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Save response and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.

    return S_OK;
}



//***************************************************************************
// Function: SearchResponseNotification
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnSearchResponse(WPARAM tid, IRangeList *prlSearchResults)
{
    TraceCall("CIMAPSync::SearchResponseNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != prlSearchResults);

    // Process search response here (currently does nothing)
    return S_OK;
}



//***************************************************************************
// Function: OnCmdComplete
// Description: See imnxport.idl (this is part of IIMAPCallback).
//
// For a CIMAPFolder class to be useful, it must enter the SELECTED state
// on the IMAP server. This function is written so that entering the SELECTED
// state is done in an orderly fashion: First the login, then the SELECT
// command.
//
// Once we are in SELECTED state, we can send IMAP commands at any time.
//***************************************************************************
HRESULT CIMAPSync::_OnCmdComplete(WPARAM tid, LPARAM lParam, HRESULT hrCompletionResult,
                                  LPCSTR lpszResponseText)
{
    TCHAR               szFmt[CCHMAX_STRINGRES];
    IStoreCallback     *pCallback = NULL;
    STOREOPERATIONTYPE  sotOpType = SOT_INVALID;
    BOOL                fCompletion = FALSE;
    BOOL                fCreateDone = FALSE,
                        fDelFldrFromCache = FALSE,
                        fSuppressDetails = FALSE;
    HRESULT             hrTemp;

    TraceCall("CIMAPSync::CmdCompletionNotification");
    IxpAssert(NULL != lpszResponseText);

    // Initialize variables
    *szFmt = NULL;

    // If we got any new unread messages, play sound and update tray icon
    // Do it here instead of case tidFETCH_NEW_HDRS because if we were IDLE when we got
    // new mail, m_sotCurrent is SOT_INVALID and we exit on the next if-statement
    if (tidFETCH_NEW_HDRS == tid && m_fNewMail && m_fInbox &&
        (NULL != m_pDefCallback || NULL != m_pCurrentCB))
    {
        IStoreCallback *pCB;

        pCB = m_pDefCallback;
        if (NULL == pCB)
            pCB = m_pCurrentCB;

        hrTemp = pCB->OnProgress(SOT_NEW_MAIL_NOTIFICATION, m_dwNumUnreadDLed, 0, NULL);
        TraceError(hrTemp);
        m_fNewMail = FALSE; // We've notified user
    }

    // We want to do the following even if there is no current operation
    switch (tid)
    {
        case tidFETCH_NEW_HDRS:
        case tidFETCH_CACHED_FLAGS:
        case tidEXPUNGE:
        case tidNOOP:
            m_lSyncFolderRefCount -= 1;
            break;
    }

    // We don't do a thing if there is no current operation (typ. means OnComplete
    // already sent)
    if (SOT_INVALID == m_sotCurrent)
        return S_OK;

    // Find out if this is a significant command which just completed
    switch (tid)
    {
        case tidSELECTION:
            // Select failure results in failure of current operation (eg, SOT_GET_MESSAGE
            // or SOT_SYNC_FOLDER) but does not otherwise invoke a call to OnComplete

            // This transaction ID identifies our mailbox SELECT attempt
            if (SUCCEEDED(hrCompletionResult))
            {
                FOLDERINFO fiFolderInfo;

                m_issCurrent = issSelected;
                m_idSelectedFolder = m_idFolder;

                // Set m_fInbox for new mail notification purposes
                Assert(FALSE == m_fInbox); // Should only get set to TRUE in one place
                hrTemp = m_pStore->GetFolderInfo(m_idSelectedFolder, &fiFolderInfo);
                if (SUCCEEDED(hrTemp))
                {
                    if (FOLDER_INBOX == fiFolderInfo.tySpecial)
                        m_fInbox = TRUE;

                    m_pStore->FreeRecord(&fiFolderInfo);
                }

                // Check if cached messages are still applicable to this folder
                hrCompletionResult = CheckUIDValidity();
                if (FAILED(hrCompletionResult))
                {
                    fCompletion = TRUE;
                    LoadString(g_hLocRes, idsIMAPUIDValidityError, m_szOperationProblem, sizeof(m_szOperationProblem));
                    break;
                }

                // Restore to-do flags
                m_dwSyncToDo = m_dwSyncFolderFlags;
                Assert(0 == (SYNC_FOLDER_NOOP & m_dwSyncFolderFlags)); // Should not be a standing order
                if (ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
                    m_dwSyncToDo |= SYNC_FOLDER_NOOP; // Subsequent FULL sync's can be replaced with NOOP

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_SELECTCOMPLETE);
                TraceError(hrTemp);
            }
            else
            {
                // Report error to user
                fCompletion = TRUE;
                LoadString(g_hLocRes, idsIMAPSelectFailureTextFmt, szFmt, sizeof(szFmt));
                wsprintf(m_szOperationProblem, szFmt, m_pszFldrLeafName);
            }
            break; // case tidSELECTION


        case tidFETCH_NEW_HDRS:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // This transaction ID identifies our attempt to fetch new msg headers
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPNewMsgDLErrText,
                    m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            else
            {
                if (FALSE == m_fMsgCountValid)
                {
                    DWORD   dwCachedCount;

                    // Svr didn't give us EXISTS (typ. NSCP v2.0). Assume m_cFilled == EXISTS
                    hrTemp = m_pFolder->GetRecordCount(IINDEX_PRIMARY, &dwCachedCount);
                    TraceError(hrTemp); // Record error but otherwise ignore
                    if (SUCCEEDED(hrTemp))
                    {
                        m_dwMsgCount = dwCachedCount; // I sure hope this is correct!
                        m_fMsgCountValid = TRUE;
                    }
                }

                // Launch next synchronization operation
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, sizeof(m_szOperationProblem));
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidFETCH_NEW_HDRS


        case tidFETCH_CACHED_FLAGS:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // If any errors occurred, bail out
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPOldMsgUpdateFailure,
                    m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            else
            {
                // Delete all msgs deleted from server since last sync-up
                hrCompletionResult = SyncDeletedMessages();
                if (FAILED(hrCompletionResult))
                {
                    LoadString(g_hLocRes, idsIMAPMsgDeleteSyncErrText,
                        m_szOperationProblem, sizeof(m_szOperationProblem));
                }

                // Check we if we did a full sync
                if (ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
                    m_fDidFullSync = TRUE;

                // Launch next synchronization operation
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, sizeof(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidFETCH_CACHED_FLAGS

        case tidEXPUNGE:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // Launch next synchronization operation
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, sizeof(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidEXPUNGE

        case tidBODYMSN:
            if (SUCCEEDED(hrCompletionResult))
            {
                // We now have the MsgSeqNumToUID translation. Get the body
                hrCompletionResult = _EnqueueOperation(tidBODY, lParam, icFETCH_COMMAND,
                    NULL, uiNORMAL_PRIORITY);
                if (FAILED(hrCompletionResult))
                    TraceResult(hrCompletionResult);
                else
                    break;
            }

            // *** If tidBODYMSN failed, FALL THROUGH and code below will handle failure

        case tidBODY:
            // As commented in CIMAPSync::UpdateMsgBody, FETCH has many failure modes
            if (SUCCEEDED(hrCompletionResult))
            {
                if (OLE_E_BLANK != m_hrOperationResult && FAILED(m_hrOperationResult))
                    hrCompletionResult = m_hrOperationResult;
                else if (FALSE == m_fGotBody)
                    hrCompletionResult = STORE_E_EXPIRED;
            }

            // Load error info if this failed
            if (FAILED(hrCompletionResult))
                LoadString(g_hLocRes, idsIMAPBodyFetchFailed, m_szOperationProblem, sizeof(m_szOperationProblem));

            // Commit message body to stream (or not, depending on success/failure)
            NotifyMsgRecipients(lParam, fCOMPLETED, NULL, hrCompletionResult, m_szOperationProblem);

            m_fGotBody = FALSE;
            fCompletion = TRUE;
            break;

        case tidNOOP:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // Launch next synchronization operation
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, sizeof(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidNOOP


        case tidMARKMSGS:
        {
            MARK_MSGS_INFO   *pMarkMsgInfo = (MARK_MSGS_INFO *) lParam;

            // We're done now whether or not we succeeded/failed
            sotOpType = pMarkMsgInfo->sotOpType;
            pCallback = m_pCurrentCB;
            SafeRelease(pMarkMsgInfo->pMsgRange);
            // Defer freeing MessageIDList until we have time to use it
            fCompletion = TRUE;

            IxpAssert(NULL != pMarkMsgInfo);
            TraceError(hrCompletionResult);
            if (SUCCEEDED(hrCompletionResult))
            {

                // Update the IMessageFolder with the new server state
                hrCompletionResult = m_pFolder->SetMessageFlags(pMarkMsgInfo->pList,
                    &pMarkMsgInfo->afFlags, NULL, NULL);
                TraceError(hrCompletionResult);
            }

            SafeMemFree(pMarkMsgInfo->pList);
            delete pMarkMsgInfo;
        }
            break; // case tidMARKMSGS


        case tidCOPYMSGS:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) lParam;
            BOOL                fCopyDone;

            // Check if this is the last SELECT command we sent out
            IxpAssert(NULL != lParam);
            fCopyDone = FALSE;
            TraceError(hrCompletionResult);

            if (FALSE == fCopyDone && SUCCEEDED(hrCompletionResult) &&
                (COPY_MESSAGE_MOVE & pCopyMoveInfo->dwOptions))
            {
                ADJUSTFLAGS afFlags;

                // Delete source messages as part of the move
                afFlags.dwAdd = ARF_ENDANGERED;
                afFlags.dwRemove = 0;
                hrCompletionResult = _SetMessageFlags(SOT_COPYMOVE_MESSAGE, pCopyMoveInfo->pList,
                    &afFlags, m_pCurrentCB);
                if (E_PENDING == hrCompletionResult)
                {
                    hrCompletionResult = S_OK; // Suppress error
                }
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCopyDone = TRUE;
                }
            }
            else
                fCopyDone = TRUE;

            if (FAILED(hrCompletionResult))
            {
                // Inform user of the error
                IxpAssert(fCopyDone);
                LoadString(g_hLocRes, idsIMAPCopyMsgsFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }

            // Whether or not copy is done, we have to free the data
            SafeMemFree(pCopyMoveInfo->pList);
            SafeRelease(pCopyMoveInfo->pCopyRange);

            if (fCopyDone)
            {
                // Set up callback information for OnComplete
                sotOpType = SOT_COPYMOVE_MESSAGE;
                pCallback = m_pCurrentCB;
                fCompletion = TRUE;
            }

            delete pCopyMoveInfo;
        }
            break; // case tidCOPYMSGS


        case tidUPLOADMSG:
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;

            // We're done the upload, whether the APPEND succeeded or failed
            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);

            sotOpType = SOT_PUT_MESSAGE;
            pCallback = m_pCurrentCB;
            fCompletion = TRUE;
            delete pAppendInfo;

            // Inform the user of any errors
            if (FAILED(hrCompletionResult))
                LoadString(g_hLocRes, idsIMAPAppendFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
        }
            break; // case tidUPLOADMSG


        case tidPREFIXLIST:
        case tidPREFIX_HC:
        case tidPREFIX_CREATE:
        case tidFOLDERLIST:
        case tidFOLDERLSUB:
        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_CREATE:
        case tidHIERARCHYCHAR_LIST_C:
        case tidHIERARCHYCHAR_DELETE:
        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
        case tidSPECIALFLDRSUBSCRIBE:
            hrCompletionResult = DownloadFoldersSequencer(tid, lParam,
                hrCompletionResult, lpszResponseText, &fCompletion);
            break; // DownloadFoldersSequencer transactions

        case tidCREATE:
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // If CREATE returns tagged NO, folder may already exist. Issue LIST and find out!
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                {
                    pcfi->dwFlags |= CFI_CREATEFAILURE;
                    lstrcpyn(m_szOperationDetails, lpszResponseText, ARRAYSIZE(m_szOperationDetails));
                }

                // Add the folder to our foldercache, by listing it
                hrCompletionResult = _EnqueueOperation(tidCREATELIST, lParam, icLIST_COMMAND,
                    pcfi->pszFullFolderPath, uiNORMAL_PRIORITY);

                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCreateDone = TRUE;
                    LoadString(g_hLocRes, idsIMAPCreateListFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
                }
            }
            else
            {
                // If we failed, notify user and free the folder pathname string
                TraceResult(hrCompletionResult);
                if (NULL != lParam)
                    fCreateDone = TRUE;

                // Inform the user of the error.
                LoadString(g_hLocRes, idsIMAPCreateFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            break; // case tidCREATE


        case tidCREATELIST:
            if (SUCCEEDED(hrCompletionResult) &&
                (CFI_RECEIVEDLISTING & ((CREATE_FOLDER_INFO *)lParam)->dwFlags))
            {
                // We received a listing of this mailbox, so it's now cached. Subscribe it!
                hrCompletionResult = _EnqueueOperation(tidCREATESUBSCRIBE, lParam,
                    icSUBSCRIBE_COMMAND, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath,
                    uiNORMAL_PRIORITY);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCreateDone = TRUE;
                    LoadString(g_hLocRes, idsIMAPCreateSubscribeFailed,
                        m_szOperationProblem, sizeof(m_szOperationProblem));
                }
            }
            else
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // Check if we were issuing a LIST in response to a failed CREATE command
                if (CFI_CREATEFAILURE & pcfi->dwFlags)
                {
                    LoadString(g_hLocRes, idsIMAPCreateFailed,
                        m_szOperationProblem, sizeof(m_szOperationProblem));
                    fSuppressDetails = TRUE; // Use response line from previous CREATE failure
                    hrCompletionResult = IXP_E_IMAP_TAGGED_NO_RESPONSE;
                    fCreateDone = TRUE;
                    break;
                }

                TraceError(hrCompletionResult);
                if (SUCCEEDED(hrCompletionResult))
                {
                    // The LIST was OK, but no folder name returned. This may mean
                    // we've assumed an incorrect hierarchy character
                    AssertSz(FALSE, "You might have an incorrect hierarchy char, here.");
                    hrCompletionResult = TraceResult(E_FAIL);
                }

                // If we failed, notify user and free the folder pathname string
                if (NULL != lParam)
                    fCreateDone = TRUE;

                // Inform the user of the error.
                LoadString(g_hLocRes, idsIMAPCreateListFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            break; // case tidCREATELIST


        case tidCREATESUBSCRIBE:
            // Whether we succeeded or not, free the CREATE_FOLDER_INFO
            // (We're at the end of the create folder sequence)
            if (NULL != lParam)
                fCreateDone = TRUE;

            // Remove this folder from LISTed folder list, if we were listing folders (this
            // way the special folder we created doesn't get marked as unsubscribed)
            if (NULL != m_pListHash && NULL != lParam)
            {
                CREATE_FOLDER_INFO *pcfiCreateInfo = (CREATE_FOLDER_INFO *) lParam;
                FOLDERID            idTemp;

                hrTemp = m_pListHash->Find(
                    ImapUtil_ExtractLeafName(pcfiCreateInfo->pszFullFolderPath, m_cRootHierarchyChar),
                    fREMOVE, (void **) &idTemp);
                TraceError(hrTemp);
            }

            // Check for errors.
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPCreateSubscribeFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            else if (NULL != lParam)
            {
                // Update the subscription status on the folder
                IxpAssert(FOLDERID_INVALID != ((CREATE_FOLDER_INFO *)lParam)->idFolder);
                hrCompletionResult = m_pStore->SubscribeToFolder(
                    ((CREATE_FOLDER_INFO *)lParam)->idFolder, fSUBSCRIBE, NOSTORECALLBACK);
                TraceError(hrCompletionResult);
            }

            break; // case tidCREATESUBSCRIBE


        case tidDELETEFLDR:
            DELETE_FOLDER_INFO *pdfi;

            pdfi = (DELETE_FOLDER_INFO *)lParam;
            if (SUCCEEDED(hrCompletionResult))
            {
                // Unsubscribe the folder to complete the delete process
                _EnqueueOperation(tidDELETEFLDR_UNSUBSCRIBE, lParam, icUNSUBSCRIBE_COMMAND,
                    pdfi->pszFullFolderPath, uiNORMAL_PRIORITY);
            }
            else
            {
                // If I unsubscribe a failed delete, user might never realize he has this
                // folder kicking around. Therefore, don't unsubscribe.

                // We won't be needing this information, anymore
                if (pdfi)
                {
                    MemFree(pdfi->pszFullFolderPath);
                    MemFree(pdfi);
                }

                // Inform the user of the error
                IxpAssert(SOT_DELETE_FOLDER == m_sotCurrent);
                sotOpType = m_sotCurrent;
                pCallback = m_pCurrentCB;
                fCompletion = TRUE;
                LoadString(g_hLocRes, idsIMAPDeleteFldrFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            break; // case tidDELETEFLDR


        case tidDONT_CARE:
            hrCompletionResult = S_OK; // Suppress all error
            break;

        case tidDELETEFLDR_UNSUBSCRIBE:
            // This folder is already deleted, so even if unsubscribe fails, delete from cache
            fDelFldrFromCache = TRUE;

            // Inform the user of any errors
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPDeleteFldrUnsubFailed, m_szOperationProblem, sizeof(m_szOperationProblem));
            }
            break; // case tidDELETEFLDR_UNSUBSCRIBE

        case tidCLOSE:
            fCompletion = TRUE;
            OnFolderExit();
            m_issCurrent = issAuthenticated;
            hrCompletionResult = S_OK; // Suppress error
            break;

        case tidSUBSCRIBE:
        {
            UINT uiErrorFmtID; // In case of error

            uiErrorFmtID = 0;
            fCompletion = TRUE;
            if (SUCCEEDED(hrCompletionResult))
            {
                IxpAssert(FOLDERID_INVALID != m_idCurrent);

                // Update store subscription status
                hrCompletionResult = m_pStore->SubscribeToFolder(m_idCurrent, m_fSubscribe, NOSTORECALLBACK);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    uiErrorFmtID = m_fSubscribe ? idsIMAPSubscrAddErrorFmt :
                        idsIMAPUnsubRemoveErrorFmt;
                }
            }
            else
            {
                TraceResult(hrCompletionResult);
                uiErrorFmtID = m_fSubscribe ? idsIMAPSubscribeFailedFmt : idsIMAPUnsubscribeFailedFmt;
            }

            // Load error message, if an error occurred
            if (FAILED(hrCompletionResult))
            {
                FOLDERINFO  fiFolderInfo;

                LoadString(g_hLocRes, uiErrorFmtID, szFmt, sizeof(szFmt));
                hrTemp = m_pStore->GetFolderInfo(m_idCurrent, &fiFolderInfo);
                if (FAILED(hrTemp))
                {
                    // Time to lie, cheat and STEAL!!!
                    TraceResult(hrTemp);
                    ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
                    fiFolderInfo.pszName = PszDupA(c_szFolderV1);
                }
                wsprintf(m_szOperationProblem, szFmt, fiFolderInfo.pszName);
                m_pStore->FreeRecord(&fiFolderInfo);
            } // if (FAILED(hrCompletionResult))
        } // case tidSUBSCRIBE
            break; // case tidSUBSCRIBE


        case tidRENAME:
        case tidRENAMESUBSCRIBE:
        case tidRENAMELIST:
        case tidRENAMERENAME:
        case tidRENAMESUBSCRIBE_AGAIN:
        case tidRENAMEUNSUBSCRIBE:
            hrCompletionResult = RenameSequencer(tid, lParam, hrCompletionResult,
                lpszResponseText, &fCompletion);
            break; // Rename operations


        case tidSTATUS:
            IxpAssert(FOLDERID_INVALID != (FOLDERID)lParam);
            fCompletion = TRUE;

            if (FAILED(hrCompletionResult))
            {
                FOLDERINFO  fiFolderInfo;

                // Construct descriptive error message
                LoadString(g_hLocRes, idsGetUnreadCountFailureFmt, szFmt, sizeof(szFmt));
                if (SUCCEEDED(m_pStore->GetFolderInfo((FOLDERID) lParam, &fiFolderInfo)))
                {
                    wsprintf(m_szOperationProblem, szFmt, fiFolderInfo.pszName,
                        m_szAccountName);
                    m_pStore->FreeRecord(&fiFolderInfo);
                }
            }
            break;

        default:
            AssertSz(FALSE, "Unhandled transaction ID!");
            break; // default case
    }


    // If we've finished a create folder (success/failure), tell them he can nuke us, now
    if (fCreateDone)
    {
        CREATE_FOLDER_INFO *pcfiCreateInfo = (CREATE_FOLDER_INFO *)lParam;

        if (FOLDER_NOTSPECIAL == pcfiCreateInfo->dwFinalSfType)
        {
            IxpAssert(SOT_INVALID != m_sotCurrent);
            IxpAssert(PCO_NONE == pcfiCreateInfo->pcoNextOp); // Regular fldr creation no longer has any post-ops

            fCompletion = TRUE;
            pCallback = m_pCurrentCB;
            sotOpType = m_sotCurrent;

            MemFree(pcfiCreateInfo->pszFullFolderPath);
            delete pcfiCreateInfo;
        }
        else
        {
            // We trying to create all the special folders: move on to the next one
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = CreateNextSpecialFolder(pcfiCreateInfo, &fCompletion);
                TraceError(hrCompletionResult);
            }
        }
    }


    // If we've successfully deleted a folder, remove it from the foldercache
    if (fDelFldrFromCache)
    {
        DELETE_FOLDER_INFO *pdfi = (DELETE_FOLDER_INFO *)lParam;

        hrCompletionResult = DeleteFolderFromCache(pdfi->idFolder, fRECURSIVE);
        if (FAILED(hrCompletionResult))
            LoadString(g_hLocRes, idsErrDeleteCachedFolderFail, m_szOperationProblem, sizeof(m_szOperationProblem));

        MemFree(pdfi->pszFullFolderPath);
        MemFree(pdfi);

        IxpAssert(SOT_DELETE_FOLDER == m_sotCurrent);
        sotOpType = m_sotCurrent;
        pCallback = m_pCurrentCB;
        fCompletion = TRUE;
    }


    // Report command completion
    if (fCompletion)
    {
        CONN_FSM_EVENT  cfeEvent;

        // Report command completion
        if (FAILED(hrCompletionResult))
        {
            if (FALSE == fSuppressDetails)
                lstrcpyn(m_szOperationDetails, lpszResponseText, ARRAYSIZE(m_szOperationDetails));

            cfeEvent = CFSM_EVENT_ERROR;
        }
        else
            cfeEvent = CFSM_EVENT_OPERATIONCOMPLETE;

        m_fTerminating = TRUE; // Either event should make us go to CFSM_STATE_OPERATIONCOMPLETE
        m_hrOperationResult = hrCompletionResult;

        // Check for user-induced connection drop, replace with non-UI error code
        if (IXP_E_CONNECTION_DROPPED == hrCompletionResult && m_fDisconnecting)
            m_hrOperationResult = STORE_E_OPERATION_CANCELED;

        hrTemp = _ConnFSM_QueueEvent(cfeEvent);
        TraceError(hrTemp);

        // Might not want to do anything past this point, we might be all released

    }
    else if (CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState)
    {
        // *** TEMPORARY until we remove CIMAPSync queueing code
        do {
            hrTemp = _SendNextOperation(NOFLAGS);
            TraceError(hrTemp);
        } while (S_OK == hrTemp);
    }

    return S_OK;
} // _OnCmdComplete



//***************************************************************************
// Function: DownloadFoldersSequencer
//
// Purpose:
//   This function is a helper function for CmdCompletionNotification. I
// created it because the former function was getting big and unwieldy. I
// probably shouldn't have bothered, but now I'm too lazy to put it back.
// Besides, the comments for this function are going to be HUGE.
// This function contains all of the operations involved in a folder
// hierarchy download. In addition to the actual hierarchy download, this
// includes Root Folder Path (or Prefix) creation, and hierarchy character
// determination (often abbreviated HCF, where "F" is for Finding).
//
// Details: See the end of the module, where many details are provided.
//
// Arguments:
//   WPARAM tid [in] - the wParam associated with this operation.
//   LPARAM lParam [in] - the lParam associated with this operation, if any.
//   HRESULT hrCompletionResult [in] - HRESULT indicating success or failure
//     of the IMAP command.
//   LPSTR lpszResponseText [in] - response text associated with the tagged
//     response from the IMAP server.
//   LPBOOL pfCompletion [out] - set to TRUE if current operation is finished.
//
// Returns:
//   HRESULT indicating success or failure. This return value should be
// assigned to hrCompletionResult so that errors are displayed and the
// dialog taken down.
//***************************************************************************
HRESULT CIMAPSync::DownloadFoldersSequencer(const WPARAM wpTransactionID,
                                            const LPARAM lParam,
                                            HRESULT hrCompletionResult,
                                            const LPCSTR lpszResponseText,
                                            LPBOOL pfCompletion)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::CIMAPFolderMgr::DownloadFoldersSequencer");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);
    IxpAssert(SOT_SYNCING_STORE == m_sotCurrent || SOT_PUT_MESSAGE == m_sotCurrent);
    IxpAssert(NULL != pfCompletion);
    IxpAssert(FALSE == *pfCompletion);

    // Initialize variables
    m_szOperationProblem[0] = '\0';

    // Take action on the completion of certain commands
    switch (wpTransactionID)
    {
        case tidPREFIXLIST:
            AssertSz('\0' != m_szRootFolderPrefix[0], "You tried to list a blank folder. Brilliant.");
            if (SUCCEEDED(hrCompletionResult))
            {
                // If we're looking for root-lvl hierarchy char, maybe this listing will help
                if (NULL != m_phcfHierarchyCharInfo)
                    FindRootHierarchyChar(fHCF_PLAN_A_ONLY, lParam);

                if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
                {
                    AssertSz(FALSE == m_fPrefixExists, "This doesn't make sense. Where's my HC?");
                    // List top level of hierarchy for hierarchy char determination
                    hrCompletionResult = _EnqueueOperation(tidPREFIX_HC, lParam,
                        icLIST_COMMAND, g_szPercent, uiNORMAL_PRIORITY);
                    TraceError(hrCompletionResult);
                }
                else
                {
                    // We don't need to find HC - list the prefixed hierarchy or create prefix
                    if (m_fPrefixExists)
                    {
                        char szBuf[CCHMAX_IMAPFOLDERPATH+3];

                        // Prefix exists, so list it (only fixed buffers, so limited overflow risk)
                        wsprintf(szBuf, "%.512s%c*", m_szRootFolderPrefix, m_cRootHierarchyChar);
                        hrCompletionResult = _EnqueueOperation(tidFOLDERLIST, lParam,
                            icLIST_COMMAND, szBuf, uiNORMAL_PRIORITY);
                        TraceError(hrCompletionResult);
                    }
                    else
                    {
                        // Prefix doesn't exist, better create it
                        hrCompletionResult = CreatePrefix(m_szOperationProblem,
                            sizeof(m_szOperationProblem), lParam, pfCompletion);
                        TraceError(hrCompletionResult);
                    }
                }
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }
            break; // case tidPREFIXLIST


        case tidPREFIX_HC:
            if (SUCCEEDED(hrCompletionResult))
            {
                // If we're looking for root-lvl hierarchy char, maybe this listing will help
                AssertSz(NULL != m_phcfHierarchyCharInfo, "Why LIST % if you already KNOW HC?")
                FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                // If Plan A for LIST % was sufficient to find HC, create prefix
                if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
                {
                    hrCompletionResult = CreatePrefix(m_szOperationProblem,
                        sizeof(m_szOperationProblem), lParam, pfCompletion);
                    TraceError(hrCompletionResult);
                }
                // else - Plan B has already been launched. Wait for its completion.
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }
            break; // case tidPREFIX_HC


        case tidHIERARCHYCHAR_LIST_B:
            // I don't care if this succeeded or failed. FindRootHierarchyChar will launch Plan C,
            // if necessary. Suppress error-reporting due to failed tidHIERARCHYCHAR_LIST_B
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_B == m_phcfHierarchyCharInfo->hcfStage);
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress error-reporting - don't take down dialog
                else
                    break;
            }

            FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

            // If we found the hierarchy char, proceed with prefix OR special folder creation
            if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
            {
                hrCompletionResult = PostHCD(m_szOperationProblem,
                    sizeof(m_szOperationProblem), lParam, pfCompletion);
                TraceError(hrCompletionResult);
            }
            // else - Plan C has already been launched. Wait for its completion
            break; // case tidHIERARCHYCHAR_LIST_B


        case tidHIERARCHYCHAR_CREATE:
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
            if (SUCCEEDED(hrCompletionResult))
            {
                // Try to list the folder for its juicy hierarchy char
                hrCompletionResult = _EnqueueOperation(tidHIERARCHYCHAR_LIST_C, lParam,
                    icLIST_COMMAND, m_phcfHierarchyCharInfo->szTempFldrName,
                    uiNORMAL_PRIORITY);
                TraceError(hrCompletionResult);
            }
            else if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                // Try the next plan in the list (which should succeed), and create prefix/special fldrs
                TraceResult(hrCompletionResult);
                FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                AssertSz(NULL == m_phcfHierarchyCharInfo,
                    "HEY, you added a new hierarchy char search plan and you didn't TELL ME!?");
                hrCompletionResult = PostHCD(m_szOperationProblem,
                    sizeof(m_szOperationProblem), lParam, pfCompletion);
                TraceError(hrCompletionResult);
            }
            break; // case tidHIERARCHYCHAR_CREATE


        case tidHIERARCHYCHAR_LIST_C:
            // I don't care if this succeeded or failed. Defer check for hierarchy
            // char, we MUST delete the temp fldr, for now
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress default error-handling - don't take down dialog
                else
                    break;
            }

            hrCompletionResult = _EnqueueOperation(tidHIERARCHYCHAR_DELETE, lParam,
                icDELETE_COMMAND, m_phcfHierarchyCharInfo->szTempFldrName, uiNORMAL_PRIORITY);
            TraceError(hrCompletionResult);
            break; // case tidHIERARCHYCHAR_LIST_C


        case tidHIERARCHYCHAR_DELETE:
            if (FAILED(hrCompletionResult))
            {
                TraceError(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress error
                else
                    break;
            }
            // Look for hierarchy char - doesn't matter if delete failed, or not
            FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);
            AssertSz(NULL == m_phcfHierarchyCharInfo,
                "HEY, you added a new hierarchy char search plan and you didn't TELL ME!?");

            // Proceed with prefix/special folder creation (I assume I've found the hierarchy char)
            AssertSz(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar,
                "By this stage, I should have a HC - an assumed one, if necessary.");
            hrCompletionResult = PostHCD(m_szOperationProblem, sizeof(m_szOperationProblem),
                lParam, pfCompletion);
            TraceError(hrCompletionResult);
            break; // case tidHIERARCHYCHAR_DELETE


        case tidFOLDERLIST:
            if (SUCCEEDED(hrCompletionResult))
            {
                char szBuf[CCHMAX_IMAPFOLDERPATH+3];

                // Launch LSUB * or LSUB <prefix>/* as appropriate
                if ('\0' != m_szRootFolderPrefix[0])
                    // Construct prefix + * (only fixed buffers, so limited overflow risk)
                    wsprintf(szBuf, "%.512s%c*", m_szRootFolderPrefix, m_cRootHierarchyChar);
                else
                {
                    szBuf[0] = '*';
                    szBuf[1] = '\0';
                }

                hrCompletionResult = _EnqueueOperation(tidFOLDERLSUB, lParam,
                    icLSUB_COMMAND, szBuf, uiNORMAL_PRIORITY);
                TraceError(hrCompletionResult);
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }
            break; // case tidFOLDERLIST


        case tidPREFIX_CREATE:
            if (FAILED(hrCompletionResult))
            {
                char szFmt[2*CCHMAX_STRINGRES];

                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPPrefixCreateFailedFmt, szFmt, sizeof(szFmt));
                wsprintf(m_szOperationProblem, szFmt, m_szRootFolderPrefix);
                break;
            }

            // Check if we need to create special folders
            m_fPrefixExists = TRUE; // Make sure PostHCD creates special fldrs instead of the prefix
            hrCompletionResult = PostHCD(m_szOperationProblem, sizeof(m_szOperationProblem),
                lParam, pfCompletion);
            if (FAILED(hrCompletionResult) || FALSE == *pfCompletion)
            {
                // We're not ready to sync deleted folders just yet: special folders are being created
                break;
            }

            // If we reached this point, tidPREFIX_CREATE was successful:
            // Prefix was created. No need to list its hierarchy (it has none),
            // and we'll assume it can take Inferiors. We're DONE!

            // *** FALL THROUGH to tidFOLDERLSUB, to sync deleted folders ***

        case tidFOLDERLSUB:
            if (SUCCEEDED(hrCompletionResult))
            {
                if (NULL != m_phcfHierarchyCharInfo)
                    FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
                {
                    if (m_fCreateSpecial)
                    {
                        // We now have the hierarchy character (required to create special folders).
                        // Create special folders
                        hrCompletionResult = PostHCD(m_szOperationProblem, sizeof(m_szOperationProblem),
                            lParam, pfCompletion);
                        if (FAILED(hrCompletionResult))
                        {
                            TraceResult(hrCompletionResult);
                            break;
                        }
                    }
                    else
                    {
                        EndFolderList();

                        // Close the download folders dialog, IF we've found the hierarchy char
                        // If HC not found, Plan B has already been launched, so wait for its completion
                        if (FOLDERID_INVALID == (FOLDERID)lParam)
                        {
                            Assert(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar);
                            *pfCompletion = TRUE;
                        }
                    }
                } // if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
            } // if (SUCCEEDED(hrCompletionResult))
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }
            break; // case tidFOLDERLSUB

        case tidSPECIALFLDRSUBSCRIBE:
            // Regardless of success/failure, subscribe this special folder locally!
            hrTemp = m_pStore->SubscribeToFolder(((CREATE_FOLDER_INFO *)lParam)->idFolder,
                fSUBSCRIBE, NOSTORECALLBACK);
            TraceError(hrTemp);
            hrCompletionResult = S_OK; // Suppress error

            // *** FALL THROUGH ***

        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                hrCompletionResult = CreateNextSpecialFolder((CREATE_FOLDER_INFO *)lParam, pfCompletion);

            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsCreateSpecialFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }
            break; // case tidSPECIALFLDRLIST, tidSPECIALFLDRLSUB, tidSPECIALFLDRSUBSCRIBE


        default:
            AssertSz(FALSE, "Hey, why is DownloadFoldersSequencer getting called?");
            break; // default case
    }; // switch (wpTransactionID)

    if (FAILED(hrCompletionResult))
    {
        *pfCompletion = TRUE;
        DisposeOfWParamLParam(wpTransactionID, lParam, hrCompletionResult);
    }

    return hrCompletionResult;
} // DownloadFoldersSequencer

// Details for DownloadFoldersSequencer (1/16/97, raych)
// ------------------------------------
// DownloadFoldersSequencer implements a somewhat complicated flow of execution.
// For a map of the execution flow, you can either create one from the function,
// or look on pp. 658-659 of my logbook. In any case, you can basically divide
// the execution flow into two categories, one for a prefixed account (ie, one
// with a Root Folder Path), and the flow for a non-prefixed account.
//
// (12/02/1998): This code is getting unmaintainable, but previous attempts to
// clean it up failed due to insufficient time. If you get the chance to re-write
// then please do. The process is greatly simplified if we assume IMAP4rev1 servers
// because then hierarchy character determination becomes a straightforward matter.
//
// For a non-prefixed account, the longest possible path is:
// 1) tidFOLDERLSUB (LIST *), syncs deleted msgs
// 2) tidHIERARCHYCHAR_LIST_B   3) tidHIERARCHYCHAR_CREATE
// 4) tidHIERARCHYCHAR_LIST_C   5) tidHIERARCHYCHAR_DELETE
// 6) Special Folder Creation (END).
//
// For a prefixed account, where the prefix already exists:
// 1) tidPREFIXLIST - this WILL discover HC
// 2) tidFOLDERLSUB (LIST <PREFIX><HC>*), syncs deleted msgs
// 3) Special Folder Creation (END).
//
// For a prefixed account, where the prefix does not exist:
// 1) tidPREFIXLIST
// 2) tidPREFIX_HC              3) tidHIERARCHYCHAR_LIST_B
// 4) tidHIERARCHYCHAR_CREATE   5) tidHIERARCHYCHAR_LIST_C
// 6) tidHIERARCHYCHAR_DELETE   7) tidPREFIX_CREATE, syncs deleted msgs
// 8) Special Folder Creation (END).



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::PostHCD(LPSTR pszErrorDescription,
                           DWORD dwSizeOfErrorDescription,
                           LPARAM lParam, LPBOOL pfCompletion)
{
    HRESULT             hrResult;
    CREATE_FOLDER_INFO *pcfiCreateInfo;

    // First, we try to create the prefix
    hrResult = CreatePrefix(pszErrorDescription, dwSizeOfErrorDescription,
        lParam, pfCompletion);

    if (FAILED(hrResult) || (SUCCEEDED(hrResult) && FALSE == *pfCompletion))
    {
        // Either we successfully launched tidPREFIX_CREATE or something failed.
        // Return as if caller had called CreatePrefix directly.
        goto exit;
    }

    // At this point, CreatePrefix has told us that we do not need to create a prefix
    Assert(TRUE == *pfCompletion);
    Assert(SUCCEEDED(hrResult));

    // Start special folder creation
    pcfiCreateInfo = new CREATE_FOLDER_INFO;
    if (NULL == pcfiCreateInfo)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pcfiCreateInfo->pszFullFolderPath = NULL;
    pcfiCreateInfo->idFolder = FOLDERID_INVALID;
    pcfiCreateInfo->dwFlags = 0;
    pcfiCreateInfo->csfCurrentStage = CSF_INIT;
    pcfiCreateInfo->dwCurrentSfType = FOLDER_INBOX;
    pcfiCreateInfo->dwFinalSfType = FOLDER_MAX - 1;
    pcfiCreateInfo->lParam = (LPARAM) FOLDERID_INVALID;
    pcfiCreateInfo->pcoNextOp = PCO_NONE;

    hrResult = CreateNextSpecialFolder(pcfiCreateInfo, pfCompletion);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    m_fCreateSpecial = FALSE;

exit:
    return hrResult;
}



//***************************************************************************
// Function: CreatePrefix
//
// Purpose:
//   This function is called after the hierarchy character is found. If the
// user specified a prefix, this function creates it. Otherwise, it takes
// down the dialog box (since HC discovery is the last step for non-prefixed
// accounts).
//
// Arguments:
//   LPSTR pszErrorDescription [out] - if an error is encountered, this
//     function deposits a description into this output buffer.
//   DWORD dwSizeOfErrorDescription [in] - size of pszErrorDescription.
//   LPARAM lParam [in] - lParam to issue with IMAP command.
//
// Returns:
//   HRESULT indicating success or failure. This return value should be
// assigned to hrCompletionResult so that errors are displayed and the
// dialog taken down.
//***************************************************************************
HRESULT CIMAPSync::CreatePrefix(LPSTR pszErrorDescription,
                                DWORD dwSizeOfErrorDescription,
                                LPARAM lParam, LPBOOL pfCompletion)
{
    char    szBuf[CCHMAX_IMAPFOLDERPATH+2];
    HRESULT hr = S_OK;

    TraceCall("CIMAPSync::CreatePrefix");
    IxpAssert(m_cRef > 0);
    AssertSz(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar,
        "How do you intend to create a prefix when you don't know HC?");
    IxpAssert(NULL != pfCompletion);
    IxpAssert(FALSE == *pfCompletion);

    // Check if there IS a prefix to create
    if ('\0' == m_szRootFolderPrefix[0] || m_fPrefixExists)
    {
        // No prefix to create. We are done: we've discovered the hierarchy character
        *pfCompletion = TRUE;
        goto exit;
    }

    // Create the prefix
    if ('\0' != m_cRootHierarchyChar)
    {
        wsprintf(szBuf, "%.512s%c", m_szRootFolderPrefix, m_cRootHierarchyChar);
        hr = _EnqueueOperation(tidPREFIX_CREATE, lParam, icCREATE_COMMAND,
            szBuf, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // We have a prefix on a non-hierarchical IMAP server!
        LoadString(g_hLocRes, idsIMAPNoHierarchyLosePrefix,
            pszErrorDescription, dwSizeOfErrorDescription);
        hr = TraceResult(hrIMAP_E_NoHierarchy);
        goto exit;
    }

exit:
    return hr;
}



void CIMAPSync::EndFolderList(void)
{
    HRESULT hrTemp;

    // Folder DL complete: Delete any folders in foldercache which weren't LISTed
    // and unsubscribe any folders which weren't LSUBed
    if (NULL != m_pCurrentHash)
    {
        hrTemp = DeleteHashedFolders(m_pCurrentHash);
        TraceError(hrTemp);
    }

    if (NULL != m_pListHash)
    {
        hrTemp = UnsubscribeHashedFolders(m_pStore, m_pListHash);
        TraceError(hrTemp);
    }
}



//***************************************************************************
// Function: RenameSequencer
//
// Purpose:
//   This function is a helper function for CmdCompletionNotification. It
// contains all of the sequencing operations required to perform a folder
// rename. For details, see the end of the function.
//
// Arguments:
//   Same as for CmdCompletionNotification.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameSequencer(const WPARAM wpTransactionID,
                                   const LPARAM lParam,
                                   HRESULT hrCompletionResult,
                                   LPCSTR lpszResponseText,
                                   LPBOOL pfDone)
{
    CRenameFolderInfo *pRenameInfo;
    BOOL fRenameDone;

    TraceCall("CIMAPSync::RenameSequencer");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Initialize variables
    pRenameInfo = (CRenameFolderInfo *) lParam;
    fRenameDone = FALSE;
    *pfDone = FALSE;

    // Take action on the completion of certain commands
    switch (wpTransactionID)
    {
        case tidRENAME:
            if (SUCCEEDED(hrCompletionResult))
            {
                // Update the foldercache (ignore errors, it reports them itself)
                // Besides, user can hopefully fix foldercache errors by refreshing folderlist

                // Assume server did a hierarchical rename: if not, we fix
                hrCompletionResult = m_pStore->RenameFolder(pRenameInfo->idRenameFolder,
                    ImapUtil_ExtractLeafName(pRenameInfo->pszNewFolderPath,
                    pRenameInfo->cHierarchyChar), NOFLAGS, NOSTORECALLBACK);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    LoadString(g_hLocRes, idsIMAPRenameFCUpdateFailure, m_szOperationProblem,
                        sizeof(m_szOperationProblem));
                    fRenameDone = TRUE; // This puts a damper on things, yes?
                    break;
                }

                // Subscribe the renamed tree
                hrCompletionResult = RenameTreeTraversal(tidRENAMESUBSCRIBE,
                    pRenameInfo, fINCLUDE_RENAME_FOLDER);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    LoadString(g_hLocRes, idsIMAPRenameSubscribeFailed, m_szOperationProblem,
                        sizeof(m_szOperationProblem));
                    fRenameDone = TRUE;
                    break;
                }

                // List the old tree to see if it still exists (exclude renamed fldr)
                hrCompletionResult = RenameTreeTraversal(tidRENAMELIST,
                    pRenameInfo, fEXCLUDE_RENAME_FOLDER);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    // Let's reuse the string for folder list failure
                    LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem,
                        sizeof(m_szOperationProblem));
                }

                // Arm the trigger for Phase Two launch
                pRenameInfo->fPhaseOneSent = TRUE;
            } // if (SUCCEEDED(hrCompletionResult))
            else
            {
                // Inform the user of any errors
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPRenameFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
                fRenameDone = TRUE;
            }
            break; // case tidRENAME


        case tidRENAMESUBSCRIBE:
            // Count the number of failed subscriptions
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                pRenameInfo->iNumFailedSubs += 1;

                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress failure report
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Decrement subscribe response counter, Watch for phase 2 launch condition
            pRenameInfo->iNumSubscribeRespExpected -= 1;
            if (0 == pRenameInfo->iNumSubscribeRespExpected)
            {
                HRESULT hrTemp;

                // Theoretically, all subfolders of renamed folder are now subscribed
                hrTemp = SubscribeSubtree(pRenameInfo->idRenameFolder, fSUBSCRIBE);
                TraceError(hrTemp);
            }

            if (EndOfRenameFolderPhaseOne(pRenameInfo) && SUCCEEDED(hrCompletionResult))
            {
                // It is time to start the next phase of the operation
                hrCompletionResult = RenameFolderPhaseTwo(pRenameInfo,
                    m_szOperationProblem, sizeof(m_szOperationProblem));
                TraceError(hrCompletionResult);
            }
            break; // case tidRENAMESUBSCRIBE


        case tidRENAMELIST:
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress failure report
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of list responses returned. Watch for phase 2 launch condition
            pRenameInfo->iNumListRespExpected -= 1;
            if (EndOfRenameFolderPhaseOne(pRenameInfo) && SUCCEEDED(hrCompletionResult))
            {
                // It is time to start the next phase of the operation
                hrCompletionResult = RenameFolderPhaseTwo(pRenameInfo,
                    m_szOperationProblem, sizeof(m_szOperationProblem));
                TraceError(hrCompletionResult);
            }
            break; // case tidRENAMELIST

        case tidRENAMERENAME:
            // Failure will not be tolerated
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPAtomicRenameFailed, m_szOperationProblem,
                    sizeof(m_szOperationProblem));
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Decrement the (second) rename counts, watch for phase 2 launch condition
            pRenameInfo->iNumRenameRespExpected -= 1;
            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // tidRENAMERENAME


        case tidRENAMESUBSCRIBE_AGAIN:
            // Modify the number of failed subscriptions based on success
            if (SUCCEEDED(hrCompletionResult))
                pRenameInfo->iNumFailedSubs -= 1;
            else
                pRenameInfo->iNumFailedSubs += 1;

            hrCompletionResult = S_OK; // Suppress failure report
            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of subscribe responses returned, watch for end-of-operation
            pRenameInfo->iNumSubscribeRespExpected -= 1;
            if (0 == pRenameInfo->iNumSubscribeRespExpected)
            {
                // Theoretically, all subfolders of renamed folder are now subscribed
                hrCompletionResult = SubscribeSubtree(pRenameInfo->idRenameFolder, fSUBSCRIBE);
                TraceError(hrCompletionResult);
            }

            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // case tidRENAMESUBSCRIBE_AGAIN


        case tidRENAMEUNSUBSCRIBE:
            // Count the number of failed unsubscribe's, to report to user at end-of-operation
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                pRenameInfo->iNumFailedUnsubs += 1;
            }

            hrCompletionResult = S_OK; // Suppress failure report
            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of unsubscribe responses returned, watch for end-of-operation
            pRenameInfo->iNumUnsubscribeRespExpected -= 1;
            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // case tidRENAMEUNSUBSCRIBE

        default:
            AssertSz(FALSE, "This is not an understood rename operation.");
            break; // default case

    } // switch (wpTransactionID)

    // That's one less rename command pending from the server
    pRenameInfo->Release();

    *pfDone = fRenameDone;
    return hrCompletionResult;
} // RenameSequencer

// Details for RenameSequencer (2/4/97, raych)
// ---------------------------
// A rename operation includes the original rename, subscription tracking, and
// atomic rename simulation (for Cyrus servers). To perform this, the rename
// operation is divided into two phases:
//
// PHASE ONE:
//   1) Assume rename was atomic. Subscribe new (renamed) folder hierarchy.
//   2) List first child of old rename folder, to check if rename was in fact atomic.
//
// PHASE TWO:
//   1) If rename was not atomic, issue a RENAME for each child of rename folder
//      in order to SIMULATE an atomic rename. This does not check for collisions
//      in the renamed space.
//   2) If the rename was not atomic, try to subscribe the new (renamed) folder
//      hierarchy, again.
//   3) Unsubscribe the old folder hierarchy.
//
// What a pain.



//***************************************************************************
// Function: EndOfRenameFolderPhaseOne
//
// Purpose:
//   This function detects whether Phase One of the rename operation has
// completed.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//
// Returns:
//   TRUE if Phase One has ended, otherwise FALSE. Phase One cannot end
// if it has not been sent, yet.
//***************************************************************************
inline BOOL CIMAPSync::EndOfRenameFolderPhaseOne(CRenameFolderInfo *pRenameInfo)
{
    if (pRenameInfo->fPhaseOneSent &&
        pRenameInfo->iNumSubscribeRespExpected <= 0 &&
        pRenameInfo->iNumListRespExpected <= 0)
    {
        IxpAssert(0 == pRenameInfo->iNumSubscribeRespExpected);
        IxpAssert(0 == pRenameInfo->iNumListRespExpected);

        return TRUE; // This marks the end of phase one
    }
    else
        return FALSE;
} // EndOfRenameFolderPhaseOne



//***************************************************************************
// Function: EndOfRenameFolderPhaseTwo
//
// Purpose:
//   This function detects whether Phase Two of the rename operation has
// completed.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//
// Returns:
//   TRUE if Phase Two has ended, otherwise FALSE. Phase Two cannot end
// if it has not been sent, yet.
//***************************************************************************
inline BOOL CIMAPSync::EndOfRenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo)
{
    if (pRenameInfo->fPhaseTwoSent &&
        pRenameInfo->iNumRenameRespExpected <= 0 &&
        pRenameInfo->iNumSubscribeRespExpected <= 0 &&
        pRenameInfo->iNumUnsubscribeRespExpected <= 0)
    {
        IxpAssert(0 == pRenameInfo->iNumRenameRespExpected);
        IxpAssert(0 == pRenameInfo->iNumSubscribeRespExpected);
        IxpAssert(0 == pRenameInfo->iNumUnsubscribeRespExpected);

        return TRUE; // This marks the end of phase two
    }
    else
        return FALSE;
} // EndOfRenameFolderPhaseTwo



//***************************************************************************
// Function: RenameFolderPhaseTwo
//
// Purpose:
//   This function launches Phase Two of the RENAME operation.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//   LPSTR szErrorDescription [in] - if an error occurs, this function
//     deposits a desription in this buffer.
//   DWORD dwSizeOfErrorDescription [in] - size of szErrorDescription.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo,
                                        LPSTR szErrorDescription,
                                        DWORD dwSizeOfErrorDescription)
{
    HRESULT hrCompletionResult;

    // Rename subfolders, re-attempt subscription of renamed tree, exclude rename folder
    if (pRenameInfo->fNonAtomicRename)
    {
        hrCompletionResult = RenameTreeTraversal(tidRENAMERENAME,
            pRenameInfo, fEXCLUDE_RENAME_FOLDER);
        if (FAILED(hrCompletionResult))
        {
            TraceResult(hrCompletionResult);
            LoadString(g_hLocRes, idsIMAPAtomicRenameFailed, szErrorDescription,
                dwSizeOfErrorDescription);
            goto exit;
        }

        hrCompletionResult = RenameTreeTraversal(tidRENAMESUBSCRIBE_AGAIN,
            pRenameInfo, fEXCLUDE_RENAME_FOLDER);
        if (FAILED(hrCompletionResult))
        {
            TraceResult(hrCompletionResult);
            LoadString(g_hLocRes, idsIMAPRenameSubscribeFailed, szErrorDescription,
                dwSizeOfErrorDescription);
            goto exit;
        }
    }

    // Unsubscribe from the old tree, include rename folder
    hrCompletionResult = RenameTreeTraversal(tidRENAMEUNSUBSCRIBE,
        pRenameInfo, fINCLUDE_RENAME_FOLDER);
    if (FAILED(hrCompletionResult))
    {
        TraceResult(hrCompletionResult);
        LoadString(g_hLocRes, idsIMAPRenameUnsubscribeFailed, szErrorDescription,
            dwSizeOfErrorDescription);
        goto exit;
    }

    // Arm the trigger for end-of-operation launch
    pRenameInfo->fPhaseTwoSent = TRUE;

exit:
    return hrCompletionResult;
} // RenameFolderPhaseTwo



//***************************************************************************
// Function: _OnMailBoxList
// Description: Helper function for OnResponse.
//
// This function saves the information from the LIST/LSUB command to the
// folder cache. If the folder already exists in the folder cache, its
// mailbox flags are updated. If it does not exist, a handle (and message
// cache filename) are reserved for the folder, and it is entered into
// the folder cache. This function is also part of the hierarchy character
// determination code. If a hierarchy character is encountered during a
// folder hierarchy download, we assume this is the hierarchy character
// for root-level folders.
//
// Arguments:
//   WPARAM wpTransactionID [in] - the wParam of this operation (eg,
//     tidFOLDERLSUB or tidCREATELIST).
//   LPARAM lParam [in] - the lParam of this operation.
//   LPSTR pszMailboxName [in] - the mailbox name returned via the LIST
//     response, eg "INBOX".
//   IMAP_MBOXFLAGS imfMboxFlags [in] - the mailbox flags returned via the
//     LIST response, eg "\NoSelect".
//   char cHierarchyChar [in] - the hierarchy character returned via the
//     LIST response, eg '/'.
//***************************************************************************
HRESULT CIMAPSync::_OnMailBoxList(  WPARAM tid,
                                    LPARAM lParam,
                                    LPSTR pszMailboxName,
                                    IMAP_MBOXFLAGS imfMboxFlags,
                                    char cHierarchyChar,
                                    BOOL fNoTranslation)
{
    const DWORD dwProgressInterval = 1;

    HRESULT         hr = S_OK;
    FOLDERID        idNewFolder = FOLDERID_INVALID;
    FOLDERID        idTemp = FOLDERID_INVALID;
    BOOL            fHandledLPARAM = FALSE;
    LPSTR           pszLocalPath = NULL;
    BOOL            fValidPrefix;
    SPECIALFOLDER   sfType;
    BOOL            fFreeLocalPath = FALSE;

    TraceCall("CIMAPSync::_OnMailBoxList");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pszMailboxName);

    // Hierarchy-character determination code
    if (NULL != m_phcfHierarchyCharInfo)
    {
        switch (cHierarchyChar)
        {
            case '\0':
                // If our prefix is not INBOX, we MUST treat NIL as a valid hierarchy char
                if (tidPREFIXLIST == tid ||
                    0 != lstrcmpi(pszMailboxName, c_szInbox))
                    m_phcfHierarchyCharInfo->fNonInboxNIL_Seen = TRUE;
                break;

            case '.':
                m_phcfHierarchyCharInfo->fDotHierarchyCharSeen = TRUE;
                break;

            default:
                // Set the bit in the array which corresponds to this character
                m_phcfHierarchyCharInfo->bHierarchyCharBitArray[cHierarchyChar/8] |=
                    (1 << cHierarchyChar%8);
                break;
        }
    }


    // Remove prefix from full folder path
    pszLocalPath = RemovePrefixFromPath(m_szRootFolderPrefix, pszMailboxName,
        cHierarchyChar, &fValidPrefix, &sfType);

    // Replace leading INBOX with localized folder name
    const int c_iLenOfINBOX = 5; // Let me know if this changes
    Assert(lstrlen(c_szINBOX) == c_iLenOfINBOX);
    if (0 == StrCmpNI(pszLocalPath, c_szINBOX, c_iLenOfINBOX))
    {
        char cNextChar;

        cNextChar = pszLocalPath[c_iLenOfINBOX];
        if ('\0' == cNextChar || cHierarchyChar == cNextChar)
        {
            BOOL    fResult;
            int     iLocalizedINBOXLen;
            int     iNewPathLen;
            char    szInbox[CCHMAX_STRINGRES];
            LPSTR   pszNew;

            // We found INBOX or INBOX<HC>: replace INBOX with localized version
            Assert(FOLDER_INBOX == sfType || '\0' != cNextChar);
            iLocalizedINBOXLen = LoadString(g_hLocRes, idsInbox, szInbox, sizeof(szInbox));

            iNewPathLen = iLocalizedINBOXLen + lstrlen(pszLocalPath + c_iLenOfINBOX);
            fResult = MemAlloc((void **)&pszNew, iNewPathLen + 1);
            if (FALSE == fResult)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            lstrcpy(pszNew, szInbox);
            lstrcpy(pszNew + iLocalizedINBOXLen, pszLocalPath + c_iLenOfINBOX);

            pszLocalPath = pszNew;
            fFreeLocalPath = TRUE;
        }
    }

    // Add folder to foldercache if current operation warrants it (LIST only, ignore LSUB)
    switch (tid)
    {
        case tidSPECIALFLDRLIST:
        case tidFOLDERLIST:
        case tidCREATELIST:
            if (fValidPrefix && pszLocalPath[0] != '\0')
            {
                DWORD dwAFTCFlags;

                dwAFTCFlags = (fNoTranslation ? AFTC_NOTRANSLATION : 0);
                hr = AddFolderToCache(pszLocalPath, imfMboxFlags, cHierarchyChar,
                    dwAFTCFlags, &idNewFolder, sfType);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    goto exit;
                }
            }
    }


    // Tie up loose ends and exit
    switch (tid)
    {
        // Are we looking for a prefix listing?
        case tidPREFIXLIST:
            IxpAssert(0 == lstrcmpi(pszMailboxName, m_szRootFolderPrefix));
            m_fPrefixExists = TRUE;
            fHandledLPARAM = TRUE;
            goto exit; // Skip addition to foldercache


        case tidRENAMELIST:
            if (NULL != lParam)
            {
                // Well, looks like we have some subfolders to rename
                ((CRenameFolderInfo *)lParam)->fNonAtomicRename = TRUE;
                fHandledLPARAM = TRUE;
            }
            break;


        case tidSPECIALFLDRLIST:
        case tidFOLDERLIST:
        case tidCREATELIST:
            fHandledLPARAM = TRUE;

            // Only act on validly prefixed folders
            if (fValidPrefix && NULL != m_pCurrentHash)
            {
                // Remove LISTed folder from m_pCurrentHash (list of cached folders)
                hr = m_pCurrentHash->Find(pszLocalPath, fREMOVE, (void **)&idTemp);
                if (FAILED(hr))
                {
                    if (FOLDERID_INVALID != idNewFolder)
                        idTemp = idNewFolder;
                    else
                        idTemp = FOLDERID_INVALID;
                }

                // NOTE that it is possible for idTemp != idNewFolder. This occurs if
                // I change RFP from "" to "aaa" and there exists two folders, "bbb" and
                // "aaa/bbb". Believe it or not, this happened to me during rudimentary testing.
                // The correct folder to use in this case is idTemp, which is determined using FULL path

                // Record all LISTed folders in m_pListHash
                if (NULL != m_pListHash)
                {
                    hr = m_pListHash->Insert(pszLocalPath, idTemp, HF_NO_DUPLICATES);
                    TraceError(hr);
                }
            }

            if (tidCREATELIST != tid && FALSE == (tidSPECIALFLDRLIST == tid && NULL != lParam &&
                0 == lstrcmpi(pszMailboxName, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath)))
                break;

            // *** FALL THROUGH if tidCREATELIST, or tidSPECIALFLDRLIST and exact path match ***

            if (NULL != lParam)
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // Inform cmd completion that it's OK to send the subscribe cmd
                // Also record fldrID of new fldr so we can update store after successful subscribe
                pcfi->dwFlags |= CFI_RECEIVEDLISTING;
                pcfi->idFolder = idNewFolder;
                fHandledLPARAM = TRUE;
            }
            break;

        case tidSPECIALFLDRLSUB:
        case tidFOLDERLSUB:
            // Verify that we already received this folderpath via a LIST response
            // If we DID receive this folder via LIST, remove from m_pListHash
            fHandledLPARAM = TRUE;

            // Only act on validly prefixed folders
            if (fValidPrefix)
            {
                hr = m_pListHash->Find(pszLocalPath, fREMOVE, (void **)&idTemp);
                if (SUCCEEDED(hr))
                {
                    // This folder was received via LIST and thus it exists: subscribe it
                    if (FOLDERID_INVALID != idTemp)
                    {
                        hr = m_pStore->SubscribeToFolder(idTemp, fSUBSCRIBE, NOSTORECALLBACK);
                        TraceError(hr);
                    }
                }
                else
                {
                    DWORD   dwTranslateFlags;
                    HRESULT hrTemp;

                    // This folder was not returned via LIST. Destroy its punk ass
                    hrTemp = FindHierarchicalFolderName(pszLocalPath, cHierarchyChar,
                        &idTemp, pahfoDONT_CREATE_FOLDER);
                    if (SUCCEEDED(hrTemp))
                    {
                        // Do record result of this in hr because failure here is not cool
                        hr = DeleteFolderFromCache(idTemp, fNON_RECURSIVE);
                        TraceError(hr);
                    }
                    // if FAILED(hr), we probably never cached this folder, so ignore it

                    // Unsubscribe it regardless of whether it was in the foldercache
                    // If this folder is fNoTranslation, we have to disable translation for this
                    // call to UNSUBSCRIBE. Otherwise IIMAPTransport2 should already have translation enabled
                    hrTemp = S_OK;
                    if (fNoTranslation)
                    {
                        dwTranslateFlags = IMAP_MBOXXLATE_VERBATIMOK | IMAP_MBOXXLATE_RETAINCP |
                                           IMAP_MBOXXLATE_DISABLE;

                        hrTemp = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
                    }

                    if (SUCCEEDED(hrTemp))
                    {
                        hrTemp = _EnqueueOperation(tidDONT_CARE, 0, icUNSUBSCRIBE_COMMAND,
                            pszMailboxName, uiNORMAL_PRIORITY);
                        TraceError(hrTemp);
                    }

                    // Restore translation mode to default (luckily we always know translation mode
                    // of a folder list)
                    if (fNoTranslation)
                    {
                        dwTranslateFlags &= ~(IMAP_MBOXXLATE_DISABLE);
                        dwTranslateFlags |= IMAP_MBOXXLATE_DEFAULT;
                        hrTemp = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
                    }
                }
            }

            if (tidSPECIALFLDRLSUB == tid && NULL != lParam &&
                0 == (IMAP_MBOX_NOSELECT & imfMboxFlags))
            {
                // Inform cmd completion that there's no need to subscribe special folder
                if (0 == lstrcmpi(pszMailboxName, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath))
                    ((CREATE_FOLDER_INFO *)lParam)->dwFlags |= CFI_RECEIVEDLISTING;
            }
            break;

        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_LIST_C:
        case tidPREFIX_HC:
            fHandledLPARAM = TRUE;
            break;

        default:
            AssertSz(FALSE, "Unhandled LIST/LSUB operation");
            break;
    }

    // Provide progress indication
    if (SOT_SYNCING_STORE == m_sotCurrent && NULL != m_pCurrentCB)
    {
        // Update progress indication
        m_pCurrentCB->OnProgress(m_sotCurrent, ++m_cFolders, 0, m_szAccountName);
    }

exit:
    IxpAssert(NULL == lParam || fHandledLPARAM || FAILED(hr));
    if (fFreeLocalPath)
        MemFree(pszLocalPath);

    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_OnAppendProgress(LPARAM lParam, DWORD dwCurrent, DWORD dwTotal)
{
    APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;
    TraceCall("CIMAPSync::OnAppendProgress");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lParam);
    IxpAssert(SOT_PUT_MESSAGE == m_sotCurrent);

    if (NULL != m_pCurrentCB)
    {
        HRESULT hrTemp;
        hrTemp = m_pCurrentCB->OnProgress(SOT_PUT_MESSAGE, dwCurrent, dwTotal, NULL);
        TraceError(hrTemp);
    }
    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_OnStatusResponse(IMAP_STATUS_RESPONSE *pisrStatusInfo)
{
    HRESULT     hrResult;
    FOLDERID    idFolder;
    FOLDERINFO  fiFolderInfo;
    LPSTR       pszMailboxName;
    BOOL        fValidPrefix;
    LONG        lMsgDelta;
    LONG        lUnreadDelta;
    CHAR        szInbox[CCHMAX_STRINGRES];

    TraceCall("CIMAPSync::_OnStatusResponse");
    IxpAssert(m_cRef > 0);

    // Check that we have the data we need
    if (NULL == pisrStatusInfo ||
        NULL == pisrStatusInfo->pszMailboxName ||
        '\0' == pisrStatusInfo->pszMailboxName[0] ||
        FALSE == pisrStatusInfo->fMessages ||
        FALSE == pisrStatusInfo->fUnseen)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Figure out who this folder is (figure from path rather than module var FOLDERID for now)
    // Assume m_cRootHierarchyChar is HC for this mbox, because IMAP doesn't return it
    pszMailboxName = RemovePrefixFromPath(m_szRootFolderPrefix, pisrStatusInfo->pszMailboxName,
        m_cRootHierarchyChar, &fValidPrefix, NULL);
    AssertSz(fValidPrefix, "Foldercache can only select prefixed folders!");

    // bobn, QFE, 7/9/99
    // If we have the INBOX, we need to get the local name...
    if(0 == StrCmpI(pszMailboxName, c_szINBOX))
    {
        LoadString(g_hLocRes, idsInbox, szInbox, sizeof(szInbox));
        pszMailboxName = szInbox;
    }

    hrResult = FindHierarchicalFolderName(pszMailboxName, m_cRootHierarchyChar,
        &idFolder, pahfoDONT_CREATE_FOLDER);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Calculate the number of messages and unread added by this STATUS response
    Assert(sizeof(DWORD) == sizeof(LONG));
    lMsgDelta = ((LONG)pisrStatusInfo->dwMessages) - ((LONG)fiFolderInfo.cMessages);
    lUnreadDelta = ((LONG)pisrStatusInfo->dwUnseen) - ((LONG)fiFolderInfo.cUnread);

    // If this is INBOX, we might just send a new mail notification
    if (FOLDER_INBOX == fiFolderInfo.tySpecial && lUnreadDelta > 0 && NULL != m_pCurrentCB)
    {
        HRESULT hrTemp;

        hrTemp = m_pCurrentCB->OnProgress(SOT_NEW_MAIL_NOTIFICATION, lUnreadDelta, 0, NULL);
        TraceError(hrTemp);
    }

    // Update counts, and update delta so we can un-apply STATUS changes when re-syncing
    fiFolderInfo.cMessages = pisrStatusInfo->dwMessages;
    fiFolderInfo.cUnread = pisrStatusInfo->dwUnseen;
    fiFolderInfo.dwStatusMsgDelta = ((LONG)fiFolderInfo.dwStatusMsgDelta) + lMsgDelta;
    fiFolderInfo.dwStatusUnreadDelta = ((LONG)fiFolderInfo.dwStatusUnreadDelta) + lUnreadDelta;
    hrResult = m_pStore->UpdateRecord(&fiFolderInfo);
    m_pStore->FreeRecord(&fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}



//===========================================================================
// CRenameFolderInfo Class
//===========================================================================
// The CRenameFolderInfo class used to be a structure (much like
// AppendSendInfo). However, the RENAME operation was the first to
// stream IMAP commands without waiting for completion (no sequencing). This
// meant that if any errors occurred while IMAP commands were still in the
// air, the structure had to wait until the last command came back from the
// server. This was most easily done via AddRef/Release. A class was born.
//
// In the event that a send error occurred, this class is responsible for
// issuing the WM_IMAP_RENAMEDONE window message to the caller.

//***************************************************************************
// Function: CRenameFolderInfo (Constructor)
//***************************************************************************
CRenameFolderInfo::CRenameFolderInfo(void)
{
    pszFullFolderPath = NULL;
    cHierarchyChar = INVALID_HIERARCHY_CHAR;
    pszNewFolderPath = NULL;
    idRenameFolder = FOLDERID_INVALID;
    iNumSubscribeRespExpected = 0;
    iNumListRespExpected = 0;
    iNumRenameRespExpected = 0;
    iNumUnsubscribeRespExpected = 0;
    iNumFailedSubs = 0;
    iNumFailedUnsubs = 0;
    fNonAtomicRename = 0;
    pszRenameCmdOldFldrPath = NULL;
    fPhaseOneSent = FALSE;
    fPhaseTwoSent = FALSE;

    hrLastError = S_OK;
    pszProblem = NULL;
    pszDetails = NULL;

    m_lRefCount = 1;
} // CRenameFolderInfo;



//***************************************************************************
// Function: ~CRenameFolderInfo (Destructor)
//***************************************************************************
CRenameFolderInfo::~CRenameFolderInfo(void)
{
    IxpAssert(0 == m_lRefCount);

    MemFree(pszFullFolderPath);
    MemFree(pszNewFolderPath);
    MemFree(pszRenameCmdOldFldrPath);
    SafeMemFree(pszProblem);
    SafeMemFree(pszDetails);
} // ~CRenameFolderInfo



//***************************************************************************
// Function: AddRef (same one that you already know and love)
//***************************************************************************
long CRenameFolderInfo::AddRef(void)
{
    IxpAssert(m_lRefCount > 0);

    m_lRefCount += 1;
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release (same one that you already know and love)
//***************************************************************************
long CRenameFolderInfo::Release(void)
{
    IxpAssert(m_lRefCount > 0);

    m_lRefCount -= 1;

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release



//***************************************************************************
//***************************************************************************
BOOL CRenameFolderInfo::IsDone(void)
{
    if (m_lRefCount > 1)
        return FALSE;
    else
    {
        IxpAssert(1 == m_lRefCount);
        return TRUE;
    }
}



//***************************************************************************
//***************************************************************************
HRESULT CRenameFolderInfo::SetError(HRESULT hrResult, LPSTR pszProblemArg,
                                    LPSTR pszDetailsArg)
{
    HRESULT hr = S_OK;

    TraceCall("CRenameFolderInfo::SetError");
    IxpAssert(FAILED(hrResult));

    hrLastError = hrResult;
    SafeMemFree(pszProblem);
    SafeMemFree(pszDetails);
    if (NULL != pszProblemArg)
    {
        pszProblem = PszDupA(pszProblemArg);
        if (NULL == pszProblem)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

    if (NULL != pszDetailsArg)
    {
        pszDetails = PszDupA(pszDetailsArg);
        if (NULL == pszDetails)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\http\httputil.h ===
/*
 *  h t t p u t i l. h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Utility functions used to implement http mail.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _HTTPUTIL_H
#define _HTTPUTIL_H

void Http_FreeTargetList(LPHTTPTARGETLIST pTargets);

HRESULT Http_NameFromUrl(LPCSTR pszUrl, LPSTR pszBuffer, DWORD *pdwBufferLen);

HRESULT Http_AddMessageToFolder(IMessageFolder *pFolder,
                                LPSTR pszAcctId,
                                LPHTTPMEMBERINFO pmi,
                                MESSAGEFLAGS dwFlags,
                                LPSTR pszUrl,
                                LPMESSAGEID pidMessage);

HRESULT Http_SetMessageStream(IMessageFolder *pFolder, 
                              MESSAGEID idMessage, 
                              IStream *pStream,
                              LPFILEADDRESS pfa,
                              BOOL fSetDisplayProps);
#endif // _HTTPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\imap\imapute.cpp ===
/*
 *    imaputil.cpp
 *
 *    Purpose:
 *        Implements IMAP utility functions
 *
 *    Owner:
 *        Raych
 *
 *    Copyright (C) Microsoft Corp. 1996
 */


//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "imapute.h"
#include "storutil.h"
#include "imapsync.h"


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
DWORD ImapUtil_ReverseSentence(LPSTR pszSentence, char cDelimiter);
void ImapUtil_ReverseString(LPSTR pszStart, LPSTR pszEnd);


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
const char c_szIMAP_MSG_ANSWERED[] = "Answered";
const char c_szIMAP_MSG_FLAGGED[] = "Flagged";
const char c_szIMAP_MSG_DELETED[] = "Deleted";
const char c_szIMAP_MSG_DRAFT[] = "Draft";
const char c_szIMAP_MSG_SEEN[] = "Seen";
const char c_szBACKSLASH[] = "\\";

typedef struct tagIMFToStr_LUT {
    IMAP_MSGFLAGS imfValue;
    LPCSTR pszValue;
} IMFTOSTR_LUT;

const IMFTOSTR_LUT g_IMFToStringLUT[] = {
    {IMAP_MSG_ANSWERED, c_szIMAP_MSG_ANSWERED},
    {IMAP_MSG_FLAGGED, c_szIMAP_MSG_FLAGGED},
    {IMAP_MSG_DELETED, c_szIMAP_MSG_DELETED},
    {IMAP_MSG_SEEN, c_szIMAP_MSG_SEEN},
    {IMAP_MSG_DRAFT, c_szIMAP_MSG_DRAFT}};



//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

//***************************************************************************
// Function: ImapUtil_MsgFlagsToString
//
// Purpose:
//   This function converts a IMAP_MSGFLAGS register to its string
// equivalent. For instance, IMAP_MSG_SEEN is converted to "(\Seen)".
//
// Arguments:
//   IMAP_MSGFLAGS imfSource [in] - IMAP_MSGFLAGS register to convert to
//     string.
//   LPSTR *ppszDestination [out] - the string equivalent is returned here.
//     If imfSource is 0, NULL is returned here. Otherwise, a string buffer
//     is returned which the caller must MemFree when he is done with it.
//   DWORD *pdwLengthOfDestination [out] - the length of *ppszDestination.
//     Pass in NULL if not interested.
//
// Returns:
//   HRESULT indicating success or failure. Remember that it is possible
// for a successful HRESULT to be returned, even is *ppszDestination is NULL.
//***************************************************************************
HRESULT ImapUtil_MsgFlagsToString(IMAP_MSGFLAGS imfSource,
                                  LPSTR *ppszDestination,
                                  DWORD *pdwLengthOfDestination)
{
    CByteStream         bstmOutput;
    HRESULT             hrResult;
    const IMFTOSTR_LUT *pCurrent;
    const IMFTOSTR_LUT *pLastEntry;
    BOOL                fFirstFlag;

    TraceCall("ImapUtil_MsgFlagsToString");
    Assert(NULL != ppszDestination);
    AssertSz(0 == (imfSource & ~IMAP_MSG_ALLFLAGS), "Quit feeding me garbage.");

    // Codify assumptions
    Assert(IMAP_MSG_ALLFLAGS == 0x0000001F);

    *ppszDestination = NULL;
    if (NULL != pdwLengthOfDestination)
        *pdwLengthOfDestination = 0;

    if (0 == (imfSource & IMAP_MSG_ALLFLAGS))
        return S_OK; // Nothing to do here!

    hrResult = bstmOutput.Write("(", 1, NULL);
    if (FAILED(hrResult))
        goto exit;

    fFirstFlag = TRUE;
    pCurrent = g_IMFToStringLUT;
    pLastEntry = pCurrent + sizeof(g_IMFToStringLUT)/sizeof(IMFTOSTR_LUT) - 1;
    while (pCurrent <= pLastEntry) {

        if (imfSource & pCurrent->imfValue) {
            // Prepend a space to flag, if necessary
            if (FALSE == fFirstFlag) {
                hrResult = bstmOutput.Write(g_szSpace, 1, NULL);
                if (FAILED(hrResult))
                    goto exit;
            }
            else
                fFirstFlag = FALSE;

            // Output the backslash
            hrResult = bstmOutput.Write(c_szBACKSLASH,
                sizeof(c_szBACKSLASH) - 1, NULL);
            if (FAILED(hrResult))
                goto exit;

            // Output string associated with this IMAP flag
            hrResult = bstmOutput.Write(pCurrent->pszValue,
                lstrlen(pCurrent->pszValue), NULL);
            if (FAILED(hrResult))
                goto exit;
        } // if (imfSource & pCurrent->imfValue)

        // Advance current pointer
        pCurrent += 1;
    } // while

    hrResult = bstmOutput.Write(")", 1, NULL);
    if (FAILED(hrResult))
        goto exit;

    hrResult = bstmOutput.HrAcquireStringA(pdwLengthOfDestination,
        ppszDestination, ACQ_DISPLACE);

exit:
    return hrResult;
} // IMAPMsgFlagsToString



//***************************************************************************
// Function: ImapUtil_FolderIDToPath
//
// Purpose:
//   This function takes the given FolderID and returns the full path
// (including prefix) to the folder. The caller may also choose to append
// a string to the path.
//
// Arguments:
//   FolderID idFolder [in] - FolderID to convert into a full path.
//   char **ppszPath [out] - a full path to idFolder is returned here.
//   LPDWORD pdwPathLen [out] - if non-NULL, the length of *ppszPath is
//     returned here.
//   char *pcHierarchyChar [out] - the hierarchy char used to interpret
//     *ppszPath is returned here.
//   CFolderCache *pFldrCache [in] - a CFolderCache to use to generate
//     the path.
//   LPCSTR pszAppendStr [in] - this can be NULL if the caller does not need
//     to append a string to the path. Otherwise, a hierarchy character is
//     appended to the path and this string is appended after the HC. This
//     argument is typically used to tack a wildcard to the end of the path.
//   LPCSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT ImapUtil_FolderIDToPath(FOLDERID idServer, FOLDERID idFolder, char **ppszPath,
                                LPDWORD pdwPathLen, char *pcHierarchyChar,
                                IMessageStore *pFldrCache, LPCSTR pszAppendStr,
                                LPCSTR pszRootFldrPrefix)
{
    FOLDERINFO  fiPath;
    HRESULT     hrResult;
    CByteStream bstmPath;
    DWORD       dwLengthOfPath;
    LPSTR       pszEnd;
    char        szRootFldrPrefix[MAX_PATH];
    char        szAccount[CCHMAX_ACCOUNT_NAME];
    BOOL        fAppendStrHC = FALSE,
                fFreeFldrInfo = FALSE;
    BOOL        fSpecialFldr = FALSE;
    DWORD       dwLen;
    
    TraceCall("ImapUtil_FolderIDToPath");
    
    if (FOLDERID_INVALID == idFolder || FOLDERID_INVALID == idServer)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Build full path to current folder in reverse (leaf->root)
    // Limited buffer overflow risk since user input limited to MAX_PATH

    // Start off with target folder (leaf) and return its HC if so requested
    hrResult = pFldrCache->GetFolderInfo(idFolder, &fiPath);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    fFreeFldrInfo = TRUE;

    GetFolderAccountId(&fiPath, szAccount);

    if (NULL != pcHierarchyChar)
    {
        Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        *pcHierarchyChar = (char) fiPath.bHierarchy;
    }

    // Append anything the user asked us to (will be at end of str after reversal)
    if (NULL != pszAppendStr)
    {
        char    szBuf[MAX_PATH + 1];

        // First, have to reverse the append string itself, in case it contains HC's
        Assert(lstrlen(pszAppendStr) < sizeof(szBuf));
        lstrcpyn(szBuf, pszAppendStr, sizeof(szBuf));
        dwLen = ImapUtil_ReverseSentence(szBuf, fiPath.bHierarchy);

        hrResult = bstmPath.Write(szBuf, dwLen, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
        fAppendStrHC = TRUE;
    }

    // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
    if (NULL == pszRootFldrPrefix)
    {
        ImapUtil_LoadRootFldrPrefix(szAccount, szRootFldrPrefix, sizeof(szRootFldrPrefix));
        pszRootFldrPrefix = szRootFldrPrefix;
    }
    else
        // Copy to our buffer because we're going to reverse the RFP
        lstrcpyn(szRootFldrPrefix, pszRootFldrPrefix, sizeof(szRootFldrPrefix));

    // Proceed to root
    while (FALSE == fSpecialFldr && idServer != fiPath.idFolder)
    {
        LPSTR pszFolderName;

        Assert(FOLDERID_INVALID != fiPath.idFolder);
        Assert(FOLDERID_ROOT != fiPath.idParent);

        if (fAppendStrHC)
        {
            // Separate append str from path with HC
            Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            fAppendStrHC = FALSE;
        }

        // Expand folder name to full path if this is a special folder
        if (FOLDER_NOTSPECIAL != fiPath.tySpecial)
        {
            char szSpecialFldrPath[MAX_PATH * 2 + 2]; // Room for HC and null-term

            fSpecialFldr = TRUE;
            hrResult = ImapUtil_SpecialFldrTypeToPath(szAccount, fiPath.tySpecial,
                szRootFldrPrefix, fiPath.bHierarchy, szSpecialFldrPath, sizeof(szSpecialFldrPath));
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }

            // Reverse special folder path so we can append it. It will be reversed back to normal
            // There should be no trailing HC's
            //Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            dwLen = ImapUtil_ReverseSentence(szSpecialFldrPath, fiPath.bHierarchy);
            Assert(dwLen == 0 || fiPath.bHierarchy !=
                *(CharPrev(szSpecialFldrPath, szSpecialFldrPath + dwLen)));
            pszFolderName = szSpecialFldrPath;
        }
        else
            pszFolderName = fiPath.pszName;

        // Write folder name to stream
        hrResult = bstmPath.Write(pszFolderName, lstrlen(pszFolderName), NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        //Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        pFldrCache->FreeRecord(&fiPath);
        fFreeFldrInfo = FALSE;

        hrResult = pFldrCache->GetFolderInfo(fiPath.idParent, &fiPath);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
        fFreeFldrInfo = TRUE;

    } // while


    if (FALSE == fSpecialFldr && '\0' != szRootFldrPrefix[0])
    {
        if (fAppendStrHC)
        {
            // Separate append str from path with HC
            Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            fAppendStrHC = FALSE;
        }

        // Reverse root folder path so we can append it. It will be reversed back to normal
        // There should be no trailing HC's (ImapUtil_LoadRootFldrPrefix guarantees this)
        Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        dwLen = ImapUtil_ReverseSentence(szRootFldrPrefix, fiPath.bHierarchy);
        Assert(dwLen == 0 || fiPath.bHierarchy !=
            *(CharPrev(szRootFldrPrefix, szRootFldrPrefix + dwLen)));

        hrResult = bstmPath.Write(szRootFldrPrefix, dwLen, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

    // OK, path won't get any larger. Acquire mem buffer so we can reverse it
    hrResult = bstmPath.HrAcquireStringA(&dwLengthOfPath, ppszPath, ACQ_DISPLACE);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Blow away trailing hierarchy character or it becomes leading HC
    pszEnd = CharPrev(*ppszPath, *ppszPath + dwLengthOfPath);
    Assert('%' == *pszEnd || (BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
    if (*pszEnd == (char) fiPath.bHierarchy)
        *pszEnd = '\0';

    // Reverse the 'sentence' (HC is delimiter) to get path
    dwLen = ImapUtil_ReverseSentence(*ppszPath, fiPath.bHierarchy);
    if (NULL != pdwPathLen)
        *pdwPathLen = dwLen;

exit:
    if (fFreeFldrInfo)
        pFldrCache->FreeRecord(&fiPath);

    return hrResult;
} // ImapUtil_FolderIDToPath



//***************************************************************************
// Function: ImapUtil_ReverseSentence
//
// Purpose:
//   This function reverses the words in the given sentence, where words are
// separated by the given delimiter. For instance, "one two three" with space
// as the delimiter is returned as "three two one".
//
// Arguments:
//   LPSTR pszSentence [in/out] - the sentence to be reversed. The sentence
//     is reversed in place.
//   char cDelimiter [in] - the character separating the words in the
//     sentence.
//
// Returns:
//   DWORD indicating length of reversed sentence.
//***************************************************************************
DWORD ImapUtil_ReverseSentence(LPSTR pszSentence, char cDelimiter)
{
    LPSTR pszStartWord, psz;
    Assert(NULL != pszSentence);
    BOOL fFoundDelimiter;
    BOOL fSkipByte = FALSE;

    TraceCall("ImapUtil_ReverseSentence");

    if ('\0' == cDelimiter)
        return 0; // Nothing to reverse

    // Check if first character is a delimiter
    if (cDelimiter != *pszSentence) {
        pszStartWord = pszSentence;
        psz = pszSentence;
        fFoundDelimiter = FALSE;
    }
    else {
        // Skip first delimiter char (it will be reversed at end of fn)
        pszStartWord = pszSentence + 1;
        psz = pszSentence + 1;
        fFoundDelimiter = TRUE;
    }

    // First, reverse each word in the sentence
    while (1) {
        char cCurrent = *psz;

        if (fSkipByte) {
            fSkipByte = FALSE;
            if ('\0' != cCurrent)
                psz += 1;
            continue;
        }

        if (cDelimiter == cCurrent || '\0' == cCurrent) {
            // We've gone past a word! Reverse it!
            ImapUtil_ReverseString(pszStartWord, psz - 1);
            pszStartWord = psz + 1; // Set us up for next word
            fFoundDelimiter = TRUE;
        }

        if ('\0' == cCurrent)
            break;
        else {
            if (IsDBCSLeadByteEx(GetACP(), cCurrent))
                fSkipByte = TRUE;
            psz += 1;
        }
    } // while (1)

    // Now reverse the entire sentence string (psz points to null-terminator)
    if (fFoundDelimiter && psz > pszSentence)
        ImapUtil_ReverseString(pszSentence, psz - 1);

    return (DWORD) (psz - pszSentence);
} // ImapUtil_ReverseSentence



//***************************************************************************
// Function: ImapUtil_ReverseString
//
// Purpose:
//   This function reverses the given string in-place
//
// Arguments:
//   LPSTR pszStart [in/out] - start of the string to be reversed.
//   LPSTR pszEnd [in/out] - the end of the string to be reversed.
//***************************************************************************
void ImapUtil_ReverseString(LPSTR pszStart, LPSTR pszEnd)
{
    TraceCall("ImapUtil_ReverseString");
    Assert(NULL != pszStart);
    Assert(NULL != pszEnd);

    while (pszStart < pszEnd) {
        char cTemp;

        // Swap characters
        cTemp = *pszStart;
        *pszStart = *pszEnd;
        *pszEnd = cTemp;

        // Advance pointers
        pszStart += 1;
        pszEnd -= 1;
    } // while
} // ImapUtil_ReverseString



//***************************************************************************
// Function: ImapUtil_SpecialFldrTypeToPath
//
// Purpose:
//   This function returns the path for the given special folder type.
//
// Arguments:
//   LPSTR pszAccountID [in] - ID of IMAP account where special folder resides.
//   SPECIALFOLDER sfType [in] - the special folder whose path should be returned
//     (eg, FOLDER_SENT).
//   LPCSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//   LPSTR pszPath [out] - pointer to a buffer to receieve the special folder
//     path.
//   DWORD dwSizeOfPath [in] - size of buffer pointed to by pszPath.
//
// Returns:
//   HRESULT indicating success or failure. This can include:
//
//     STORE_E_NOREMOTESPECIALFLDR: indicates the given special folder has
//       been disabled by the user for this IMAP server.
//***************************************************************************
HRESULT ImapUtil_SpecialFldrTypeToPath(LPCSTR pszAccountID, SPECIALFOLDER sfType,
                                       LPSTR pszRootFldrPrefix, char cHierarchyChar,
                                       LPSTR pszPath, DWORD dwSizeOfPath)
{
    HRESULT         hrResult;
    IImnAccount    *pAcct = NULL;
    DWORD           dw;
    int             iLen;

    TraceCall("ImapUtil_SpecialFldrTypeToPath");
    AssertSz(dwSizeOfPath >= MAX_PATH * 2 + 2, "RFP + Special Folder Path = Big Buffer, Dude"); // Room for HC, null-term

    *pszPath = '\0'; // Initialize
    switch (sfType)
    {
        case FOLDER_INBOX:
            lstrcpyn(pszPath, c_szINBOX, dwSizeOfPath);
            hrResult = S_OK;
            break;


        case FOLDER_SENT:
        case FOLDER_DRAFT:
            hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
            if (FAILED(hrResult))
                break;

            hrResult = pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw);
            if (FAILED(hrResult))
                break;
            else if (FALSE == dw) {
                hrResult = STORE_E_NOREMOTESPECIALFLDR;
                break;
            }

            // First prepend the root folder prefix
            // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
            if (NULL == pszRootFldrPrefix)
                ImapUtil_LoadRootFldrPrefix(pszAccountID, pszPath, dwSizeOfPath);
            else
                lstrcpyn(pszPath, pszRootFldrPrefix, dwSizeOfPath);

            iLen = lstrlen(pszPath);
            if (iLen > 0 && (DWORD)iLen + 1 < dwSizeOfPath)
            {
                pszPath[iLen] = cHierarchyChar;
                iLen += 1;
                pszPath[iLen] = '\0';
            }

            hrResult = pAcct->GetPropSz(FOLDER_SENT == sfType ?
                AP_IMAP_SENTITEMSFLDR : AP_IMAP_DRAFTSFLDR, pszPath + iLen,
                dwSizeOfPath - iLen);
            break;

        case FOLDER_DELETED:
        case FOLDER_ERRORS:
        case FOLDER_JUNK:
        case FOLDER_MSNPROMO:
        case FOLDER_OUTBOX:
        case FOLDER_BULKMAIL:
            hrResult = STORE_E_NOREMOTESPECIALFLDR;
            break;

        default:
            AssertSz(FALSE, "Invalid special folder type!");
            hrResult = E_INVALIDARG;
            break;
    } // switch (sfType)


    if (NULL != pAcct)
        pAcct->Release();

    // Check for blank path
    if (SUCCEEDED(hrResult) && '\0' == *pszPath)
        hrResult = STORE_E_NOREMOTESPECIALFLDR;
 
    return hrResult;
} // ImapUtil_SpecialFldrTypeToPath



//***************************************************************************
// Function: ImapUtil_LoadRootFldrPrefix
//
// Purpose:
//   This function loads the "Root Folder Path" option from the account
// manager. The Root Folder Path (prefix) identifies the parent of all of
// the user's folders. Thus, the Root Folder Path forms a prefix for all
// mailboxes which are not INBOX.
//
// Arguments:
//   LPCTSTR pszAccountID [in] - ID of the account
//   LPSTR pszRootFolderPrefix [out] - destination for Root Folder Path
//   DWORD dwSizeofPrefixBuffer [in] - size of buffer pointed to by
//     pszRootFolderPrefix.
//***************************************************************************
void ImapUtil_LoadRootFldrPrefix(LPCTSTR pszAccountID,
                                 LPSTR pszRootFolderPrefix,
                                 DWORD dwSizeofPrefixBuffer)
{
    IImnAccount *pAcct;
    HRESULT hrResult;
    LPSTR pLastChar;

    Assert(NULL != pszAccountID);
    Assert(NULL != pszRootFolderPrefix);
    Assert(0 != dwSizeofPrefixBuffer);

    // Initialize variables
    pAcct = NULL;
    pszRootFolderPrefix[0] = '\0'; // If we can't find a prefix, default to NONE

    // Get the prefix from the account manager
    hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
    if (FAILED(hrResult))
        goto exit;

    hrResult = pAcct->GetPropSz(AP_IMAP_ROOT_FOLDER, pszRootFolderPrefix,
        dwSizeofPrefixBuffer);
    if (FAILED(hrResult))
        goto exit;


    // OK, we now have the root folder prefix. Strip trailing hierarchy chars,
    // since we probably don't know server HC when we try to list the prefix
    pLastChar = CharPrev(pszRootFolderPrefix, pszRootFolderPrefix + lstrlen(pszRootFolderPrefix));
    while (pLastChar >= pszRootFolderPrefix &&
          ('/' == *pLastChar || '\\' == *pLastChar || '.' == *pLastChar)) {
        *pLastChar = '\0'; // Bye-bye, potential hierarchy char
        pLastChar = CharPrev(pszRootFolderPrefix, pLastChar);
    } // while

exit:
    if (NULL != pAcct)
        pAcct->Release();
} // ImapUtil_LoadRootFldrPrefix



//***************************************************************************
// Function: ImapUtil_GetSpecialFolderType
//
// Purpose:
//   This function takes the given account name and folder path, and
// determines whether the path points to a special IMAP folder. Note that
// although it is possible for a path to represent more than one type of
// IMAP special folder, only ONE special folder type is returned (based
// on evaluation order).
//
// Arguments:
//   LPSTR pszAccountID [in] - ID of the IMAP account whose special folder
//     paths we want to compare pszFullPath to.
//   LPSTR pszFullPath [in] - path to a potential special folder residing on
//     the pszAccountID account.
//   char cHierarchyChar [in] - hierarchy char used to interpret pszFullPath.
//   LPSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//   SPECIALFOLDER *psfType [out] - the special folder type of given folder
//     (eg, FOLDER_NOTSPECIAL, FOLDER_SENT). Pass NULL if not interested.
//
// Returns:
//   LPSTR pointing to leaf name of special folder path. For instance, if
// the Drafts folder is set to "one/two/three/Drafts" and this function is
// called to process "one/two/three/Drafts/foo", then this function will
// return "Drafts/foo". If no match is found, NULL is returned.
//***************************************************************************
LPSTR ImapUtil_GetSpecialFolderType(LPSTR pszAccountID, LPSTR pszFullPath,
                                    char cHierarchyChar, LPSTR pszRootFldrPrefix,
                                    SPECIALFOLDER *psfType)
{
    HRESULT         hrResult;
    SPECIALFOLDER   sfType = FOLDER_NOTSPECIAL;
    BOOL            fSpecialFldrPrefix = FALSE;
    IImnAccount    *pAccount = NULL;
    DWORD           dw;
    int             iLeafNameOffset = 0;
    int             iTmp;
    int             iLen;
    char            sz[MAX_PATH * 2 + 2]; // Room for HC plus null-term

    Assert(INVALID_HIERARCHY_CHAR != cHierarchyChar);

    // First check if this is INBOX or one of its children
    iLen = lstrlen(c_szInbox);
    if (0 == StrCmpNI(pszFullPath, c_szInbox, iLen) &&
        (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
    {
        fSpecialFldrPrefix = TRUE;
        iLeafNameOffset = 0; // "INBOX" is always the leaf name
        if ('\0' == pszFullPath[iLen])
        {
            sfType = FOLDER_INBOX; // Exact match for "INBOX"
            goto exit;
        }
    }

    hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAccount);
    if (FAILED(hrResult))
        goto exit;

#ifdef DEBUG
    hrResult = pAccount->GetServerTypes(&dw);
    Assert(SUCCEEDED(hrResult) && (SRV_IMAP & dw));
#endif // DEBUG

    hrResult = pAccount->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw);
    if (SUCCEEDED(hrResult) && dw)
    {
        int iLenRFP;

        // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
        if (NULL == pszRootFldrPrefix)
            ImapUtil_LoadRootFldrPrefix(pszAccountID, sz, sizeof(sz));
        else
            lstrcpyn(sz, pszRootFldrPrefix, sizeof(sz));

        iLenRFP = lstrlen(sz);
        if (iLenRFP > 0 && (DWORD)iLenRFP + 1 < sizeof(sz))
        {
            sz[iLenRFP] = cHierarchyChar;
            iLenRFP += 1;
            sz[iLenRFP] = '\0';
        }

        hrResult = pAccount->GetPropSz(AP_IMAP_SENTITEMSFLDR, sz + iLenRFP, sizeof(sz) - iLenRFP);
        if (SUCCEEDED(hrResult))
        {
            iLen = lstrlen(sz);
            if (0 == StrCmpNI(sz, pszFullPath, iLen) &&
                (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
            {
                fSpecialFldrPrefix = TRUE;
                iTmp = (int) (ImapUtil_ExtractLeafName(sz, cHierarchyChar) - sz);
                iLeafNameOffset = max(iTmp, iLeafNameOffset);
                if ('\0' == pszFullPath[iLen])
                {
                    sfType = FOLDER_SENT; // Exact match for Sent Items
                    goto exit;
                }
            }
        }

        hrResult = pAccount->GetPropSz(AP_IMAP_DRAFTSFLDR, sz + iLenRFP, sizeof(sz) - iLenRFP);
        if (SUCCEEDED(hrResult))
        {
            iLen = lstrlen(sz);
            if (0 == StrCmpNI(sz, pszFullPath, iLen) && 
                (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
            {
                fSpecialFldrPrefix = TRUE;
                iTmp = (int) (ImapUtil_ExtractLeafName(sz, cHierarchyChar) - sz);
                iLeafNameOffset = max(iTmp, iLeafNameOffset);
                if ('\0' == pszFullPath[iLen])
                {
                    sfType = FOLDER_DRAFT; // Exact match for Drafts folder
                    goto exit;
                }
            }
        }
    } // if (AP_IMAP_SVRSPECIALFLDRS)

exit:
    if (NULL != pAccount)
        pAccount->Release();

    if (NULL != psfType)
        *psfType = sfType;

    if (fSpecialFldrPrefix)
        return pszFullPath + iLeafNameOffset;
    else
        return NULL;
} // ImapUtil_GetSpecialFolderType



//***************************************************************************
// Function: ImapUtil_ExtractLeafName
//
// Purpose:
//   This function takes an IMAP folder path and extracts the leaf node name.
//
// Arguments:
//   LPSTR pszFolderPath [in] - a string containing the IMAP folder path.
//   char cHierarchyChar [in] - the hierarchy char used in pszFolderPath.
//
// Returns:
//   A pointer to the leaf node name in pszFolderPath. The default return
// value is pszFolderPath, if no hierarchy characters were found.
//***************************************************************************
LPSTR ImapUtil_ExtractLeafName(LPSTR pszFolderPath, char cHierarchyChar)
{
    LPSTR pszLastHierarchyChar, p;

    // Find out where the last hierarchy character lives
    pszLastHierarchyChar = pszFolderPath;
    p = pszFolderPath;
    while ('\0' != *p) {
        if (cHierarchyChar == *p)
            pszLastHierarchyChar = p;

        p += 1;
    }

    // Adjust pszLastHierarchyChar to point to leaf name
    if (cHierarchyChar == *pszLastHierarchyChar)
        return pszLastHierarchyChar + 1;
    else
        return pszFolderPath;
} // ImapUtil_ExtractLeafName



HRESULT ImapUtil_UIDToMsgSeqNum(IIMAPTransport *pIMAPTransport, DWORD_PTR dwUID,
                                LPDWORD pdwMsgSeqNum)
{
    HRESULT hrTemp;
    DWORD  *pdwMsgSeqNumToUIDArray = NULL;
    DWORD   dwHighestMsgSeqNum;
    DWORD   dw;
    BOOL    fFound = FALSE;

    TraceCall("ImapUtil_UIDToMsgSeqNum");

    if (NULL == pIMAPTransport || 0 == dwUID)
    {
        TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Quickly check the highest MSN
    hrTemp = pIMAPTransport->GetHighestMsgSeqNum(&dwHighestMsgSeqNum);
    if (FAILED(hrTemp) || 0 == dwHighestMsgSeqNum)
    {
        TraceError(hrTemp);
        goto exit;
    }

    // OK, no more laziness, we gotta do a linear search now
    hrTemp = pIMAPTransport->GetMsgSeqNumToUIDArray(&pdwMsgSeqNumToUIDArray,
        &dwHighestMsgSeqNum);
    if (FAILED(hrTemp))
    {
        TraceResult(hrTemp);
        goto exit;
    }

    Assert(dwHighestMsgSeqNum > 0);
    for (dw = 0; dw < dwHighestMsgSeqNum; dw++)
    {
        // Look for match or overrun
        if (0 != pdwMsgSeqNumToUIDArray[dw] && dwUID <= pdwMsgSeqNumToUIDArray[dw])
        {
            if (dwUID == pdwMsgSeqNumToUIDArray[dw])
            {
                if (NULL != pdwMsgSeqNum)
                    *pdwMsgSeqNum = dw + 1;

                fFound = TRUE;
            }
            break;
        }
    } // for


exit:
    SafeMemFree(pdwMsgSeqNumToUIDArray);

    if (fFound)
        return S_OK;
    else
        return E_FAIL;
} // ImapUtil_UIDToMsgSeqNum



// *** REMOVE THIS after Beta-2! This sets the AP_IMAP_DIRTY flag if no IMAP special folders
// found after OE4->OE5 migration. We can then prompt user to refresh folder list.
void ImapUtil_B2SetDirtyFlag(void)
{
    IImnAccountManager *pAcctMan = NULL;
    IImnEnumAccounts   *pAcctEnum = NULL;
    IImnAccount        *pAcct = NULL;
    HRESULT             hrResult;

    TraceCall("ImapUtil_B2SetDirtyFlag");

    // Enumerate through all accounts. Set AP_IMAP_DIRTY flag on all IMAP accounts
    hrResult = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctMan->Init(NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctMan->Enumerate(SRV_IMAP, &pAcctEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctEnum->GetNext(&pAcct);
    while (SUCCEEDED(hrResult))
    {
        DWORD   dwIMAPDirty;

        hrResult = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwIMAPDirty);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            dwIMAPDirty = 0;
        }

        // Mark this IMAP account as dirty so we prompt user to refresh folder list
        dwIMAPDirty |= (IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
        hrResult = pAcct->SetPropDw(AP_IMAP_DIRTY, dwIMAPDirty);
        TraceError(hrResult); // Record but otherwise ignore result

        hrResult = pAcct->SaveChanges();
        TraceError(hrResult); // Record but otherwise ignore result

        // Get next account
        SafeRelease(pAcct);
        hrResult = pAcctEnum->GetNext(&pAcct);
    }

exit:
    SafeRelease(pAcctMan);
    SafeRelease(pAcctEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\http\httpserv.h ===
/*
 *  h t t p s e r v . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Derives from IMessageServer to implement HTTPMail-specific 
 *           store communication.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _HTTPSERV_H
#define _HTTPSERV_H

#include "tmap.h"
#include "simpstr.h"

class CFolderList;

class CHTTPMailServer;
typedef HRESULT (CHTTPMailServer::*PFNHTTPOPFUNC)(void);
typedef HRESULT (CHTTPMailServer::*PFNHTTPRESPFUNC)(LPHTTPMAILRESPONSE pResponse);

typedef struct tagHTTPSTATEFUNCS
{
    PFNHTTPOPFUNC   pfnOp;      // operation function
    PFNHTTPRESPFUNC pfnResp;    // response function
} HTTPSTATEFUNCS, *LPHTTPSTATEFUNCS;

typedef struct tagMARKEDMESSAGE
{
    MESSAGEID       idMessage;
    MESSAGEFLAGS    dwFlags;
    BOOL            fMarked;
} MARKEDMESSAGE, *LPMARKEDMESSAGE;

typedef struct tagNEWMESSAGEINFO
{
    LPSTR           pszUrlComponent;
} NEWMESSAGEINFO, *LPNEWMESSAGEINFO;

#define HTTPCOPYMOVE_OUTOFSPACE     0x00000001
#define HTTPCOPYMOVE_ERROR          0x00000002

typedef struct tagHTTPOPERATION
{
    STOREOPERATIONTYPE      tyOperation;
    const HTTPSTATEFUNCS    *pfnState;
    BOOL                    fCancel;
    BOOL                    fStateWillAdvance;
    BOOL                    fNotifiedComplete;
    int                     iState;
    int                     cState;
    IStoreCallback          *pCallback;

    DWORD                   dwOptions;

    long                    lIndex;

    FOLDERID                idFolder;
    SYNCFOLDERFLAGS         dwSyncFlags;
    CFolderList             *pFolderList;

    IMessageFolder          *pMessageFolder;

    LPSTR                   pszProblem;

    LPSTR                   pszDestFolderUrl;
    LPSTR                   pszDestUrl;

    MESSAGEID               idMessage;
    FILEADDRESS             faStream;
    IStream                 *pMessageStream;

    TMap<CSimpleString, MARKEDMESSAGE>  *pmapMessageId;
    CSortedArray            *psaNewMessages;

    LPSTR                   pszFolderName;
    LPSTR                   pszAdUrl;

    FLDRFLAGS               dwFldrFlags;

    MESSAGEFLAGS            dwMsgFlags;

    // folder synchronization
    DWORD                   cMessages;
    DWORD                   cUnread;

    // setmessage flags
    BOOL                    fMarkRead;
    DWORD                   dwSetFlags;
    IPropPatchRequest       *pPropPatchRequest;
    DWORD                   dwIndex;
    LPMESSAGEIDLIST         pIDList;
    HROWSET                 hRowSet;

    // batch copy move errors
    DWORD                   dwCopyMoveErrorFlags;

    // delete message junk for
    // dealing with servers that
    // don't support message deletion (Hotmail)
    DELETEMESSAGEFLAGS      dwDelMsgFlags;
    BOOL                    fFallbackToMove;
    LPHTTPTARGETLIST        pTargets;

    MESSAGEID               idPutMessage;
    STOREERROR              error;
    DWORD                   dwMinPollingInterval;

} HTTPOPERATION, *LPHTTPOPERATION;

class CHTTPMailServer : public IMessageServer, IHTTPMailCallback, public IOperationCancel
{
public:
    //----------------------------------------------------------------------
    // Construction/Destruction
    //----------------------------------------------------------------------
    CHTTPMailServer(void);
    ~CHTTPMailServer(void);

private:
    // intentionally umimplemented copy constructor
    // and assignment operator
    CHTTPMailServer(const CHTTPMailServer& other);
    CHTTPMailServer& operator=(const CHTTPMailServer& other);

public: 
    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageServer Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder (SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback  *pCallback);
    STDMETHODIMP GetMessage (MESSAGEID idMessage, IStoreCallback  *pCallback);
    STDMETHODIMP PutMessage (FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream  *pStream, IStoreCallback  *pCallback);        
    STDMETHODIMP CopyMessages (IMessageFolder  *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteMessages (DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback  *pCallback);
    STDMETHODIMP SetMessageFlags (LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore (FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP CreateFolder (FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP MoveFolder (FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback);
    STDMETHODIMP RenameFolder (FOLDERID idFolder, LPCSTR pszName, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteFolder (FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP SubscribeToFolder (FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback);
    STDMETHODIMP GetMinPollingInterval(IStoreCallback   *pCallback);
    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IHTTPMailCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPHTTPMAILRESPONSE      pResponse);

    STDMETHODIMP GetParentWindow(
            HWND                    *phwndParent);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel);

    // ----------------------------------------------------------------------------
    // Private Implementation
    // ----------------------------------------------------------------------------
public:
    // ----------------------------------------------------------------------------
    // Operations
    // ----------------------------------------------------------------------------
    HRESULT Connect(void);
    HRESULT GetMsgFolderRoot(void);
    HRESULT BuildFolderUrl(void);
    HRESULT ListFolders(void);
    HRESULT AutoListFolders(void);
    HRESULT PurgeFolders(void);
    HRESULT ListHeaders(void);
    HRESULT PurgeMessages(void);
    HRESULT ResetMessageCounts(void);
    HRESULT GetMessage(void);
    HRESULT CreateFolder(void);
    HRESULT RenameFolder(void);
    HRESULT DeleteFolder(void);
    HRESULT CreateSetFlagsRequest(void);
    HRESULT SetMessageFlags(void);
    HRESULT ApplyFlagsToStore(void);
    HRESULT DeleteMessages(void);
    HRESULT DeleteFallbackToMove(void);
    HRESULT PurgeDeletedFromStore(void);
    HRESULT PutMessage(void);
    HRESULT AddPutMessage(void);
    HRESULT CopyMoveMessage(void);
    HRESULT BatchCopyMoveMessages(void);
    HRESULT FinalizeBatchCopyMove(void);
    HRESULT GetAdBarUrlFromServer(void);
    HRESULT GetMinPollingInterval(void);

    // ----------------------------------------------------------------------------
    // Response Handlers
    // ----------------------------------------------------------------------------
    HRESULT HandleListFolders(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleListHeaders(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleGetMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleGetMsgFolderRoot(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleCreateFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleRenameFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleDeleteFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleMemberErrors(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleDeleteFallbackToMove(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandlePutMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleCopyMoveMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleBatchCopyMoveMessages(LPHTTPMAILRESPONSE pResponse);

private:
    // ----------------------------------------------------------------------------
    // Other stuff(tm)
    // ----------------------------------------------------------------------------
    BOOL _CreateWnd(void);
    static LRESULT _WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT _BeginDeferredOperation(void);

    HRESULT _DoOperation(void);
    void _FreeOperation(BOOL fValidState = TRUE);

    HRESULT _DoCopyMoveMessages(STOREOPERATIONTYPE sot, IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback);

    HRESULT _LoadAccountInfo(IImnAccount *pAcct);
    HRESULT _LoadTransport(void);

    void    _Disconnect(void);
    BOOL    _FConnected(void) { return m_fConnected; }
    void    _SetConnected(BOOL fConnected) { if (m_fConnected) _Disconnect(); m_fConnected = fConnected; }

    HRESULT _CreateMessageIDMap(TMap<CSimpleString, MARKEDMESSAGE> **ppMap);
    HRESULT _HrBuildMapAndTargets(LPMESSAGEIDLIST pList, HROWSET hRowSet, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, TMap<CSimpleString, MARKEDMESSAGE> **ppMap, LPHTTPTARGETLIST *ppTargets);
    SPECIALFOLDER _TranslateHTTPSpecialFolderType(HTTPM