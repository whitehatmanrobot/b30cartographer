{
	TCHAR szMapiSvcFile[MAX_PATH+20];

	//get mapisvc.inf path
	if (!GetSystemDirectory(szMapiSvcFile, MAX_PATH))
		return(FALSE);
	lstrcat(szMapiSvcFile, TEXT("\\mapisvc.inf"));

	//check return buffer size
	if ((ULONG)lstrlen(szMapiSvcFile) + 1 > cchBuf)
		return(FALSE);

	//copy to return bufffer and return OK
	lstrcpy(lpszBuf, szMapiSvcFile);
	return(TRUE);

} //FGetMapiSvcFile


//+-------------------------------------------------------------------------
//
//  Function: FRemoveMQXPIfExists
//
//  Synopsis: Remove mapi transport (w/o file copy) if it exists  
//
//--------------------------------------------------------------------------
void 
FRemoveMQXPIfExists()
{
	TCHAR szMapiSvcFile[MAX_PATH];
	ULONG ulTmp, ulLines;
	LPMQXPMapiSvcLine lpLine;
		
	//
	// Get mapisvc.inf path
	//
	if (!FGetMapiSvcFile(szMapiSvcFile, MAX_PATH))
		return;

	//
	// Remove each line from mapisvc file
	//
	lpLine = g_MQXPMapiSvcLines;
	ulLines = sizeof(g_MQXPMapiSvcLines)/sizeof(MQXPMapiSvcLine);
	for (ulTmp = 0; ulTmp < ulLines; ulTmp++)
	{
		WritePrivateProfileString(lpLine->lpszSection, lpLine->lpszKey, NULL, szMapiSvcFile);
		lpLine++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocminst.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocminst.cpp

Abstract:

    Code to install Falcon

Author:

    Doron Juster  (DoronJ)  02-Aug-97

Revision History:

    Shai Kariv    (ShaiK)   14-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "ocmres.h"
#include "privque.h"
#include <lmcons.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <rt.h>
#include <Ev.h>
#include <mqnames.h>
#include "mqexception.h"

#include "ocminst.tmh"

BOOL
GetServiceState(
    IN  const TCHAR *szServiceName,
    OUT       DWORD *dwServiceState ) ;

BOOL
GenerateSubkeyValue(
    IN     const BOOL    fWriteToRegistry,
    IN     const TCHAR  * szEntryName,
    IN OUT       TCHAR  * szValueName,
    IN OUT       HKEY    &hRegKey,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    ) ;


//
// From comerror.cpp
//
int
vsDisplayMessage(
    IN const HWND    hdlg,
    IN const UINT    uButtons,
    IN const UINT    uTitleID,
    IN const UINT    uErrorID,
    IN const DWORD   dwErrorCode,
    IN const va_list argList);


//+-------------------------------------------------------------------------
//
//  Function: Msmq1InstalledOnCluster
//
//  Synopsis: Checks if MSMQ 1.0 was installed on a cluster
//
//--------------------------------------------------------------------------
BOOL
Msmq1InstalledOnCluster()
{
    DebugLogMsg(L"Checking if MSMQ 1.0 is installed in the cluster...");

    HKEY  hRegKey;
    LONG rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  FALCON_REG_KEY,
                  0,
                  KEY_READ,
                  &hRegKey
                  );
    if (ERROR_SUCCESS != rc)
    {
        DebugLogMsg(L"The Falcon registry key could not be opened for reading. MSMQ 1.0 is assumed to be not installed in the cluster.");
        return FALSE;
    }

    TCHAR szClusterName[MAX_PATH];
    DWORD dwNumBytes = sizeof(szClusterName);
    rc = RegQueryValueEx(
             hRegKey,
             FALCON_CLUSTER_NAME_REGNAME,
             0,
             NULL,
             (PBYTE)(PVOID)szClusterName,
             &dwNumBytes
             );
    RegCloseKey(hRegKey);

    return (ERROR_SUCCESS == rc);

} // Msmq1InstalledOnCluster


VOID
RemoveMsmqServiceEnvironment(
    VOID
    )
/*++

Routine Description:

    Delete the environment registry value from msmq service SCM database
    (registry). Needed for upgrade on cluster.

Arguments:

    None

Return Value:

    None

--*/
{
    DebugLogMsg(L"Deleting the Message Queuing service environment...");

    LPCWSTR x_SERVICES_KEY = L"System\\CurrentControlSet\\Services";

    CAutoCloseRegHandle hServicesKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             x_SERVICES_KEY,
                             0,
                             KEY_READ,
                             &hServicesKey
                             ))
    {
        DebugLogMsg(L"The Services registry key could not be opened.");
        return;
    }

    CAutoCloseRegHandle hMsmqServiceKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                             hServicesKey,
                             QM_DEFAULT_SERVICE_NAME,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hMsmqServiceKey
                             ))
    {
        DebugLogMsg(L"The MSMQ service registry key in the SCM database could not be opened.");
        return;
    }

    if (ERROR_SUCCESS != RegDeleteValue(hMsmqServiceKey, L"Environment"))
    {
        DebugLogMsg(L"The Message Queuing Environment registry value could not be deleted from the SCM database.");
        return;
    }

    DebugLogMsg(L"The Message Queuing service environment was deleted successfully.");

} //RemoveMsmqServiceEnvironment


//+-------------------------------------------------------------------------
//
//  Function: UpgradeMsmq
//
//  Synopsis: Performs upgrade installation on top of MSMQ 1.0
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
static
BOOL
UpgradeMsmq()
{
    DebugLogMsg(L"Upgrading Message Queuing...");
    TickProgressBar(IDS_PROGRESS_UPGRADE);

    //
    // Delete msmq1 obsolete directories.
    // These calls would fail if files were left in the directories.
    //
    RemoveDirectory(g_szMsmq1SdkDebugDir);
    RemoveDirectory(g_szMsmq1SetupDir);

    if (g_fServerSetup)
    {
        TCHAR szDir[MAX_PATH];
        _stprintf(szDir, TEXT("%s%s"), g_szMsmqDir, OCM_DIR_INSTALL);
        DeleteFilesFromDirectoryAndRd(szDir);

        //
        // Remove MSMQ 1.0 installaion share
        //
        HINSTANCE hNetAPI32DLL;
        HRESULT hResult = StpLoadDll(TEXT("NETAPI32.DLL"), &hNetAPI32DLL);
        if (!FAILED(hResult))
        {
            //
            // Obtain a pointer to the function for deleting a share
            //
            typedef NET_API_STATUS
                (NET_API_FUNCTION *FUNCNETSHAREDEL)(LPWSTR, LPWSTR, DWORD);
            FUNCNETSHAREDEL pfNetShareDel =
                (FUNCNETSHAREDEL)GetProcAddress(hNetAPI32DLL, "NetShareDel");
            if (pfNetShareDel != NULL)
            {
                NET_API_STATUS dwResult = pfNetShareDel(NULL, MSMQ1_INSTALL_SHARE_NAME, 0);
                UNREFERENCED_PARAMETER(dwResult);
            }

            FreeLibrary(hNetAPI32DLL);
        }
    }

    DebugLogMsg(L"Getting the Message Queuing Start menu program group...");

    TCHAR szGroup[MAX_PATH] ;
    lstrcpy( szGroup, MSMQ_ACME_SHORTCUT_GROUP );
    MqReadRegistryValue(
        OCM_REG_MSMQ_SHORTCUT_DIR,
        sizeof(szGroup),
        (PVOID) szGroup
        );

    DebugLogMsg(L"The Message Queuing Start menu program group:");
    DebugLogMsg(szGroup);

    DeleteStartMenuGroup(szGroup);


    //
    // Reform MSMQ service dependencies
    //
    if (!g_fDependentClient && (0 == (g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE)))
    {
        DebugLogMsg(L"Upgrading a non-dependent client from non-Windows 9x, reforming service dependencies...");
        UpgradeServiceDependencies();
    }

    switch (g_dwDsUpgradeType)
    {
        case SERVICE_PEC:
        case SERVICE_PSC:
        {
            if (!Msmq1InstalledOnCluster())
            {
                DisableMsmqService();
                RegisterMigrationForWelcome();
            }
            break;
        }

        case SERVICE_BSC:
            break;

        default:
            break;
    }

    if ((g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE) && !g_fDependentClient)
    {
        //
        // Upgrading Win95 to NT 5.0 - register the MSMQ service
        //
        DebugLogMsg(L"Upgrading a non-dependent client from Windows 9x, installing the service and driver...");

        if (!InstallMSMQService())
            return FALSE;
        g_fMSMQServiceInstalled = TRUE ;

        if (!InstallDeviceDrivers())
            return FALSE;
    }

    if (Msmq1InstalledOnCluster() && !g_fDependentClient)
    {
        //
        // Upgrade on cluster - the msmq service and driver have to be deleted
        // here because their environment is set to be cluster aware.
        // The msmq-post-cluster-upgrade-wizard will create them with
        // normal environment, in the context of the node.
        //
        DebugLogMsg(L"MSMQ 1.0 was installed in the cluster. Delete the  service/driver and register for CYS.");

        RemoveService(MSMQ_SERVICE_NAME);
        RemoveDeviceDrivers();
        RegisterWelcome();

        if (g_dwDsUpgradeType == SERVICE_PEC  ||
            g_dwDsUpgradeType == SERVICE_PSC  ||
            g_dwDsUpgradeType == SERVICE_BSC)
        {
            DebugLogMsg(L"A Message Queuing directory service server upgrade was detected in the cluster. Downgrading to a routing server...");

            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 1;

        }
    }

    //
    // Update type of MSMQ in registry
    //

    MqWriteRegistryValue( MSMQ_MQS_DSSERVER_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeDs);

    MqWriteRegistryValue( MSMQ_MQS_ROUTING_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeFrs);

    if (g_fDependentClient)
    {
        //
        // Dependent client cannot serve as supporting server, even when installed on NTS
        //
        g_dwMachineTypeDepSrv = 0;
    }

    MqWriteRegistryValue( MSMQ_MQS_DEPCLINTS_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeDepSrv);


    if (!g_fDependentClient)
    {
        //
        // install PGM driver
        //
        if (!InstallPGMDeviceDriver())
            return FALSE;
    }

    DebugLogMsg(L"The upgrade is completed!");
    return TRUE;

} // UpgradeMsmq


bool
InstallOnDomain(
    OUT BOOL  *pfObjectCreated
    )
/*++

Routine Description:

    Handles DS operations when machine is joined to domain

Arguments:

    None

Return Value:

    true iff successful

--*/
{
    *pfObjectCreated = TRUE ;

    //
    // First do installation of MSMQ DS Server
    //
    if (g_fServerSetup && g_dwMachineTypeDs)
    {
        DebugLogMsg(L"Installing a Message Queuing directory service server...");

        TickProgressBar();
        if (!CreateMSMQServiceObject())    // in the DS
            return false;
    }

    //
    // Determine whether the MSMQ Configurations object exists in the DS.
    // If it exists, get its Machine and Site GUIDs.
    //
    TickProgressBar();
    GUID guidMachine, guidSite;
    BOOL fMsmq1Server = FALSE;
    LPWSTR pwzMachineName = NULL;
    BOOL bUpdate = FALSE;
    if (!LookupMSMQConfigurationsObject(&bUpdate, &guidMachine, &guidSite, &fMsmq1Server, &pwzMachineName))
    {
        return false;
    }
    if (g_fContinueWithDsLess)
    {
        return TRUE;
    }

    BOOL fObjectCreated = TRUE ;

    if (bUpdate)
    {
        //
        // MSMQ Configurations object exists in the DS.
        // We need to update it.
        //
        DebugLogMsg(L"Updating the MSMQ Configuration object...");
        if (!UpdateMSMQConfigurationsObject(pwzMachineName, guidMachine, guidSite, fMsmq1Server))
            return false;
    }
    else
    {
        //
        // MSMQ Configurations object doesn't exist in the DS.
        // We need to create one.
        //
        DebugLogMsg(L"Creating an MSMQ Configuration object...");
        if (!CreateMSMQConfigurationsObject( &guidMachine,
                                             &fObjectCreated,
                                              fMsmq1Server ))
        {
            return false;
        }
    }

    *pfObjectCreated = fObjectCreated ;
    if (fObjectCreated)
    {
        //
        // Create local security cache for this machine
        //
        if (!StoreMachineSecurity(guidMachine))
            return false;
    }

    return true;

} //InstallOnDomain


bool
InstallOnWorkgroup(
    VOID
    )
/*++

Routine Description:

    Handles installation when machine is joined to workgroup

Arguments:

    None

Return Value:

    true iff successful

--*/
{
    ASSERT(("we must be on workgroup or ds-less here", IsWorkgroup() || g_fDsLess));

    if (!MqWriteRegistryValue(
        MSMQ_MQS_REGNAME,
        sizeof(DWORD),
        REG_DWORD,
        &g_dwMachineType
        ))
    {
        ASSERT(("failed to write MQS value to registry", 0));
    }

    if (!MqWriteRegistryValue(
             MSMQ_MQS_DSSERVER_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeDs
             )                        ||
        !MqWriteRegistryValue(
             MSMQ_MQS_ROUTING_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeFrs
             )                        ||
        !MqWriteRegistryValue(
             MSMQ_MQS_DEPCLINTS_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeDepSrv
             ))
    {
        ASSERT(("failed to write MSMQ type bits to registry", 0));
    }

    GUID guidQM = GUID_NULL;
    for (;;)
    {
        RPC_STATUS rc = UuidCreate(&guidQM);
        if (rc == RPC_S_OK)
        {
            break;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
        {
            return false;
        }
    }
    if (!MqWriteRegistryValue(
        MSMQ_QMID_REGNAME,
        sizeof(GUID),
        REG_BINARY,
        (PVOID)&guidQM
        ))
    {
        ASSERT(("failed to write QMID value to registry", 0));
    }

    SetWorkgroupRegistry();

    if (g_fDsLess)
    {
        DWORD dwAlwaysWorkgroup = 1;
        if (!MqWriteRegistryValue(
            MSMQ_ALWAYS_WORKGROUP_REGNAME,
            sizeof(DWORD),
            REG_DWORD,
            (PVOID) &dwAlwaysWorkgroup
            ))
        {
            ASSERT(("failed to write Always Workgroup value in registry", 0));
        }
    }

    return true;

} //InstallOnWorkgroup


static void pWaitForCreateOfConfigObject()
{
    CAutoCloseRegHandle hKey = NULL ;
    CAutoCloseHandle hEvent = CreateEvent(
                                   NULL,
                                   FALSE,
                                   FALSE,
                                   NULL
                                   );
    if (!hEvent)
    {
        throw bad_win32_error(GetLastError());
    }

    HKEY hKeyTmp = NULL ;
    BOOL fTmp = GenerateSubkeyValue(
                             FALSE,
                             MSMQ_CONFIG_OBJ_RESULT_KEYNAME,
                             NULL,
                             hKeyTmp
                             );
    if (!fTmp || !hKeyTmp)
    {
        throw bad_win32_error(GetLastError());
    }

    hKey = hKeyTmp ;

    for(;;)
    {
        ResetEvent(hEvent) ;
        LONG rc = RegNotifyChangeKeyValue(
                       hKey,
                       FALSE,   // bWatchSubtree
                       REG_NOTIFY_CHANGE_LAST_SET,
                       hEvent,
                       TRUE
                       );
        if (rc != ERROR_SUCCESS)
        {
            throw bad_win32_error(GetLastError());
        }

        DWORD wait = WaitForSingleObject( hEvent, 300000 ) ;
        UNREFERENCED_PARAMETER(wait);
        //
        // Read the hresult left by the msmq service in registry.
        //
        HRESULT hrSetup = MQ_ERROR ;
        MqReadRegistryValue(
            MSMQ_CONFIG_OBJ_RESULT_REGNAME,
            sizeof(DWORD),
            &hrSetup
            );
        if(SUCCEEDED(hrSetup))
        {
            return;
        }

        if(hrSetup != MQ_ERROR_WAIT_OBJECT_SETUP)
        {
            ASSERT (wait == WAIT_OBJECT_0);
            throw bad_hresult(hrSetup);
        }
        //
        // See bug 4474.
        // It probably takes the msmq service lot of time to
        // create the object. See of the service is still
        // running. If yes, then keep waiting.
        //
        DWORD dwServiceState = FALSE ;
        BOOL fGet = GetServiceState(
                        MSMQ_SERVICE_NAME,
                        &dwServiceState
                        ) ;
        if (!fGet || (dwServiceState == SERVICE_STOPPED))
        {
            throw bad_win32_error(GetLastError());
        }
    }
}
//+----------------------------------------------------------------------
//
//  BOOL  WaitForCreateOfConfigObject()
//
//  Wait until msmq service create the msmqConfiguration object after
//  it boot.
//
//+----------------------------------------------------------------------

HRESULT  WaitForCreateOfConfigObject(BOOL  *pfRetry )
{
    *pfRetry = FALSE ;

    //
    // Wait until the msmq service create the msmq configuration
    // object in active directory. We're waiting on registry.
    // When msmq terminate its setup phase, it updates the
    // registry with hresult.
    //
    try
    {
        pWaitForCreateOfConfigObject();
        return MQ_OK;

    }
    catch(bad_win32_error&)
	{
        *pfRetry = (MqDisplayErrorWithRetry(
                    IDS_MSMQ_FAIL_SETUP_NO_SERVICE,
                    MQ_ERROR_WAIT_OBJECT_SETUP
                    ) == IDRETRY);
        return MQ_ERROR_WAIT_OBJECT_SETUP;
    }
    catch(bad_hresult& e)
	{
        ASSERT(e.error() != MQ_ERROR_WAIT_OBJECT_SETUP);
        *pfRetry = (MqDisplayErrorWithRetry(
                    IDS_MSMQ_FAIL_SETUP_NO_OBJECT,
                    e.error()
                    ) == IDRETRY);

        return e.error();
    }
}

//+------------------------------------
//
//  BOOL  _RunTheMsmqService()
//
//+------------------------------------

BOOL  _RunTheMsmqService( IN BOOL  fObjectCreated )
{
    BOOL fRetrySetup = FALSE ;

    do
    {
        HRESULT hrSetup = MQ_ERROR_WAIT_OBJECT_SETUP ;

        if (!fObjectCreated)
        {
            //
            // Reset error value in registry. If msmq service won't
            // set it, then we don't want a success code to be there
            // from previous setups.
            //
            MqWriteRegistryValue( MSMQ_CONFIG_OBJ_RESULT_REGNAME,
                                  sizeof(DWORD),
                                  REG_DWORD,
                                 &hrSetup ) ;
        }

        if (!RunService(MSMQ_SERVICE_NAME))
        {
            return FALSE;
        }
        else if (!fObjectCreated)
        {
            hrSetup = WaitForCreateOfConfigObject( &fRetrySetup ) ;

            if (FAILED(hrSetup) && !fRetrySetup)
            {
                return FALSE ;
            }
        }
    }
    while (fRetrySetup) ;

    return TRUE ;
}


static void ResetCertRegisterFlag()
/*++

Routine Description:
    Reset CERTIFICATE_REGISTERD_REGNAME for the user that is running setup.
	This function is called when MQRegisterCertificate failed.
	CERTIFICATE_REGISTERD_REGNAME might be set if we previously uninstall msmq.
	reset CERTIFICATE_REGISTERD_REGNAME ensure that we try again on next logon.

Arguments:
	None

Return Value:
	None
--*/
{
	CAutoCloseRegHandle hMqUserReg;

    DWORD dwDisposition;
    LONG lRes = RegCreateKeyEx(
						FALCON_USER_REG_POS,
						FALCON_USER_REG_MSMQ_KEY,
						0,
						TEXT(""),
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hMqUserReg,
						&dwDisposition
						);

    ASSERT(lRes == ERROR_SUCCESS);

    if (hMqUserReg != NULL)
    {
		DWORD Value = 0;
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(Value);

		lRes = RegSetValueEx(
					hMqUserReg,
					CERTIFICATE_REGISTERD_REGNAME,
					0,
					dwType,
					(LPBYTE) &Value,
					dwSize
					);

		ASSERT(lRes == ERROR_SUCCESS);
	}

}


VOID
RegisterCertificate(
    VOID
    )
/*++

Routine Description:

    Register msmq internal certificate.
    Ignore errors.

Arguments:

    None

Return Value:

    None.

--*/
{
    CAutoFreeLibrary hMqrt;
    if (FAILED(StpLoadDll(MQRT_DLL, &hMqrt)))
    {
        return;
    }

    typedef HRESULT (APIENTRY *MQRegisterCertificate_ROUTINE) (DWORD, PVOID, DWORD);


    MQRegisterCertificate_ROUTINE pfMQRegisterCertificate =
        (MQRegisterCertificate_ROUTINE)
                          GetProcAddress(hMqrt, "MQRegisterCertificate") ;

    ASSERT(("GetProcAddress failed for MQRT!MQRegisterCertificate",
            pfMQRegisterCertificate != NULL));

    if (pfMQRegisterCertificate)
    {
        //
        // This function will fail if setup run form local user account.
        // That's ok, by design!
        // Ignore MQ_ERROR_NO_DS - we may get it if service is not up yet - on
        // next logon we will retry.
        //
        HRESULT hr = pfMQRegisterCertificate(MQCERT_REGISTER_ALWAYS, NULL, 0);
        //
        // add more logging
        //
        if (FAILED(hr))
        {
			//
			// Need to reset the user flag that indicate that the certificate was registered on logon
			// This might be leftover from previous msmq installation.
			// uninstall don't clear this user flag.
			// so when we failed here to create new certificate,
			// next logon should try and create it.
			// removing this flag ensure that we will retry to create the certificate.
			//
			ResetCertRegisterFlag();

            if (hr == MQ_ERROR_NO_DS)
            {
                DebugLogMsg(L"MQRegisterCertificate failed with the error MQ_ERROR_NO_DS. The queue manager will try to register the certificate when you log on again.");
            }

            WCHAR wszMsg[1000];
            wsprintf(wszMsg, L"MQRegisterCertificate failed, return error %x", hr);
            DebugLogMsg(wszMsg);
        }

        ASSERT(("MQRegisterCertificate failed",
               (SUCCEEDED(hr) || (hr == MQ_ERROR_ILLEGAL_USER) || (hr == MQ_ERROR_NO_DS)) )) ;
    }

} //RegisterCertificate


VOID
RegisterCertificateOnLogon(
    VOID
    )
/*++

Routine Description:

    Register mqrt.dll to launch on logon and register
    internal certificate. This way every logon user will
    have internal certificate registered automatically.

    Ignore errors.

Arguments:

    None

Return Value:

    None.

--*/
{
    DWORD dwDisposition = 0;
    CAutoCloseRegHandle hMqRunReg = NULL;

    LONG lRes = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("software\\microsoft\\windows\\currentVersion\\Run"),
                    0,
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hMqRunReg,
                    &dwDisposition
                    );
    ASSERT(lRes == ERROR_SUCCESS) ;
    if (lRes == ERROR_SUCCESS)
    {
        DWORD dwType = REG_SZ ;
        DWORD dwSize = sizeof(DEFAULT_RUN_INT_CERT) ;

        lRes = RegSetValueEx(
                   hMqRunReg,
                   RUN_INT_CERT_REGNAME,
                   0,
                   dwType,
                   (LPBYTE) DEFAULT_RUN_INT_CERT,
                   dwSize
                   ) ;
        ASSERT(lRes == ERROR_SUCCESS) ;
    }
} //RegisterCertificateOnLogon


VOID
VerifyMsmqAdsObjects(
    VOID
    )
/*++

Routine Description:

    Check for MSMQ objects in Active Directory.
    If not found, popup a warning about replication delays.

    Ignore other errors.

Arguments:

    None

Return Value:

    None.

--*/
{
    PROPID      propId = PROPID_QM_OS;
    PROPVARIANT propVar;

    propVar.vt = VT_NULL;

    //
    // try DNS format
    //
    HRESULT hr;
    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_wcsMachineNameDns,
				1,
				&propId,
				&propVar
				);

    if (SUCCEEDED(hr))
    {
        return;
    }

    //
    // try NET BEUI format
    //
    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_wcsMachineName,
				1,
				&propId,
				&propVar
				);

    if (SUCCEEDED(hr))
    {
        return;
    }

    if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Ignore other errors (e.g. security permission, ds went offline, qm went down)
        //
        return;
    }

	va_list list;
	memset(&list, 0, sizeof(list));
    vsDisplayMessage(NULL,  MB_OK | MB_TASKMODAL, g_uTitleID, IDS_REPLICATION_DELAYS_WARNING, 0, list);

} // VerifyMsmqAdsObjects


//+-------------------------------------------------------------------------
//
//  Function: InstallMsmq
//
//  Synopsis: Handles all installation operations
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
static
BOOL
InstallMsmq()
{
    BOOL fSuccess;

    DebugLogMsg(L"Installing Message Queuing...");
    TickProgressBar(IDS_PROGRESS_INSTALL);

    if (!g_fDependentClient)
    {
        //
        // Register service and driver
        //
        if (!InstallMachine())
        {
            return FALSE;
        }

        BOOL fObjectCreated = TRUE ;

        //
        // Cache the OS type in registry.
        // Workgroup and independent client need it, so they later
        // create the msmqConfiguration object in DS.
        //
        BOOL fRegistry = MqWriteRegistryValue( MSMQ_OS_TYPE_REGNAME,
                                               sizeof(DWORD),
                                               REG_DWORD,
                                              &g_dwOS ) ;
        UNREFERENCED_PARAMETER(fRegistry);
        ASSERT(fRegistry) ;

        if (IsWorkgroup() || g_fDsLess)
        {
            DebugLogMsg(L"Installing Message Queuing in workgroup mode...");
            if (!InstallOnWorkgroup())
                return FALSE;
        }
        else
        {
            //
            // We're on machine that joined the domain.
            // If the "workgroup" flag in registry is on, turn it off.
            // It could have been turned on by previous unsuccessfull
            // setup, or left in registry when removing previous
            // installation of msmq.
            //
            DWORD dwWorkgroup = 0;
            if (MqReadRegistryValue( MSMQ_WORKGROUP_REGNAME,
                                     sizeof(dwWorkgroup),
                                    (PVOID) &dwWorkgroup ))
            {
                if (dwWorkgroup != 0)
                {
                    dwWorkgroup = 0;
                    if (!MqWriteRegistryValue( MSMQ_WORKGROUP_REGNAME,
                                               sizeof(DWORD),
                                               REG_DWORD,
                                               (PVOID) &dwWorkgroup ))
                    {
                        ASSERT(("failed to turn off Workgroup value", 0));
                    }
                }
            }

            if (!InstallOnDomain( &fObjectCreated ))
                return FALSE;

            if (g_fContinueWithDsLess)
            {
                g_fDsLess = TRUE;      // we continue in ds less mode
                fObjectCreated = TRUE; //return to initial state
                DebugLogMsg(L"Installing Message Queuing in workgroup mode...");
                if (!InstallOnWorkgroup())
                    return FALSE;
            }
        }

        BOOL fRunService = _RunTheMsmqService( fObjectCreated ) ;
        if (!fRunService)
        {
            return FALSE ;
        }

        if (!IsWorkgroup() && !g_fDsLess)
        {
            VerifyMsmqAdsObjects();
        }
    }
    else
    {
        ASSERT(INSTALL == g_SubcomponentMsmq[eMSMQCore].dwOperation); // Internal error, we should not be here

        //
        // Dependent client installation.
        // Create a guid and store it as QMID. Necessary for licensing.
        //
        GUID guidQM = GUID_NULL;
        for (;;)
        {
            RPC_STATUS rc = UuidCreate(&guidQM);
            if (rc == RPC_S_OK)
            {
                break;
            }

            if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
            {
                return FALSE;
            }
        }
        fSuccess = MqWriteRegistryValue(
                       MSMQ_QMID_REGNAME,
                       sizeof(GUID),
                       REG_BINARY,
                       (PVOID) &guidQM
                       );
        ASSERT(fSuccess);

        //
        // Store the remote QM machine in registry
        //
        DWORD dwNumBytes = (lstrlen(g_wcsServerName) + 1) * sizeof(TCHAR);
        fSuccess = MqWriteRegistryValue(
                       RPC_REMOTE_QM_REGNAME,
                       dwNumBytes,
                       REG_SZ,
                       (PVOID) g_wcsServerName
                       );

        ASSERT(fSuccess);
    }


    TickProgressBar(IDS_PROGRESS_CONFIG);

    UnregisterWelcome();

    return TRUE;

} // InstallMsmq

bool
CompleteUpgradeOnCluster(
    VOID
    )
/*++

Routine Description:

    Handle upgrade on cluster from NT 4 / Win2K beta3

Arguments:

    None

Return Value:

    true - The operation was successful.

    false - The operation failed.

--*/
{
    //
    // Convert old msmq cluster resources
    //
    if (!UpgradeMsmqClusterResource())
    {
        return false;
    }


    //
    // Prepare for clean installation of msmq on the node:
    //
    // * reset globals
    // * create msmq directory
    // * create msmq mapping directory
    // * reset registry values
    // * clean old msmq service environment
    //

    g_fMSMQAlreadyInstalled = FALSE;
    g_fUpgrade = FALSE;

    _tcscpy(g_szMsmqDir, _T(""));
    SetDirectories();
    if (!StpCreateDirectory(g_szMsmqDir))
    {
        return FALSE;
    }

   HRESULT hr = CreateMappingFile();
    if (FAILED(hr))
    {
        return FALSE;
    }

    HKEY hKey = NULL;
    TCHAR szValueName[255] = _T("");
    if (GenerateSubkeyValue(TRUE, MSMQ_QMID_REGNAME, szValueName, hKey))
    {
        ASSERT(("should be valid handle to registry key here!",  hKey != NULL));
        RegDeleteValue(hKey, szValueName);
        RegCloseKey(hKey);
    }

    RegDeleteKey(FALCON_REG_POS, MSMQ_REG_SETUP_KEY);

    TCHAR szCurrentServer[MAX_REG_DSSERVER_LEN] = _T("");
    if (MqReadRegistryValue(MSMQ_DS_CURRENT_SERVER_REGNAME, sizeof(szCurrentServer), szCurrentServer))
    {
        if (_tcslen(szCurrentServer) < 1)
        {
            //
            // Current MQIS server is blank. Take the first server from the server list.
            //
            TCHAR szServer[MAX_REG_DSSERVER_LEN] = _T("");
            MqReadRegistryValue(MSMQ_DS_SERVER_REGNAME, sizeof(szServer), szServer);

            ASSERT(("must have server list in registry", _tcslen(szServer) > 0));

            TCHAR szBuffer[MAX_REG_DSSERVER_LEN] = _T("");
            _tcscpy(szBuffer, szServer);
            TCHAR * psz = _tcschr(szBuffer, _T(','));
            if (psz != NULL)
            {
                (*psz) = _T('\0');
            }
            _tcscpy(szCurrentServer, szBuffer);
        }

        ASSERT(("must have two leading bits", _tcslen(szCurrentServer) > 2));
        _tcscpy(g_wcsServerName, &szCurrentServer[2]);
    }

    RemoveMsmqServiceEnvironment();

    TickProgressBar(IDS_PROGRESS_INSTALL);
    return true;

} //CompleteUpgradeOnCluster


//+-------------------------------------------------------------------------
//
//  Function: MqOcmInstall
//
//  Synopsis: Called by MsmqOcm() after files copied
//
//--------------------------------------------------------------------------
DWORD
MqOcmInstall(IN const TCHAR * SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        return NO_ERROR;
    }

    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    //
    // we need to install specific subcomponent
    //
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }

        if (g_SubcomponentMsmq[i].dwOperation != INSTALL)
        {
            //
            // this component was not selected to install
            //
            return NO_ERROR;
        }

        if ( (g_SubcomponentMsmq[i]).pfnInstall == NULL)
        {
            ASSERT(("There is no specific installation function", 0));
            return NO_ERROR ;
        }

        if (g_fOnlyRegisterMode)
        {
            //
            // GUI mode + MSMQ is not installed
            // only set registry to 1 in order to install this component later, when
            // Configure Your Server will run. Register for Welcome for MSMQ Core
            // as it was before.
            //
            if (i == eMSMQCore)
            {
                //
                // Register for Welcome.
                //
                RegisterWelcome();
            }
            RegisterSubcomponentForWelcome (i);
            return NO_ERROR ;
        }

        //
        //  we need to install this subcomponent
        //

        //
        // if MSMQ Core already installed at the previous installation
        // we need to load common dlls
        // if MSMQ Core is selected at this installation
        // it will be installed the first and LoadMsmqCommonDlls
        // will be called from InstallMsmqCore
        //
        if (g_SubcomponentMsmq[eMSMQCore].fIsInstalled)
        {
            BOOL fRes = LoadMsmqCommonDlls();
            if (!fRes)
            {
                DWORD dwErr = GetLastError();
                MqDisplayError( g_hPropSheet, IDS_STR_INSTALL_FAIL, dwErr, SubcomponentId) ;
                return dwErr;
            }
        }
        else if (i != eMSMQCore)
        {
            //
            // MSMQ Core is not installed and this subcomponent
            // is NOT MSMQ Core!
            // It is wrong situation: MSMQ Core must be installed
            // FIRST since all subcomponents depends on it.
            //
            // It can happen if
            // MSMQ Core installation failed and then
            // setup for the next component was called.
            //
            return MQ_ERROR;
        }

        if (i == eHTTPSupport)
        {
            //
            // XP RTM:
            // we have to install HTTP support later since this
            // subcomponent depends on IIS service that will be
            // installed in OC_CLEANUP phase. So we need to postpone
            // our HTTP support installation
            //
            // XP SP1:
            //
            // Windows bug 643790.
            // msmq+http installation cannot register iis extension if
            // smtp is also installed.
            // By iis recommendation, move registration code from oc_cleanup
            // to oc_copmlete, and test if iisadmin is running, instead
            // of testing for w3svc.
            //
            if (// HTTP Support subcomponent was selected
                g_SubcomponentMsmq[eHTTPSupport].dwOperation == INSTALL &&
                // only if MSMQ Core is installed successfully
                g_SubcomponentMsmq[eMSMQCore].fIsInstalled &&
                // we are not at GUI mode process
                !g_fOnlyRegisterMode)
            {
               //
               // Try to configure msmq iis extension
               //
               BOOL f = InstallIISExtension();

               if (!f)
               {
                  //
                  // warning to the log file that MSMQ will not support http
                  // messages was printed in ConfigureIISExtension().
                  // Anyway we don't fail the setup because of this failure
                  //
               }
               else
               {
                  FinishToInstallSubcomponent (eHTTPSupport);
                  if (g_fWelcome)
                  {
                      UnregisterSubcomponentForWelcome (eHTTPSupport);
                  }
               }
            }
            return NO_ERROR ;
        }

        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"Installing the %s subcomponent...", SubcomponentId);
        DebugLogMsg(wszMsg);

        BOOL fRes = g_SubcomponentMsmq[i].pfnInstall();
        if (fRes)
        {
            FinishToInstallSubcomponent (i);
            if (g_fWelcome)
            {
                UnregisterSubcomponentForWelcome (i);
            }
        }
        else
        {
            WCHAR wszMsg[1000];
            wsprintf(wszMsg, L"The %s subcomponent could not be installed.", SubcomponentId);
            DebugLogMsg(wszMsg);
        }
        return NO_ERROR;
    }

    ASSERT (("Subcomponent for installation is not found", 0));
    return NO_ERROR ;
}

//+-------------------------------------------------------------------------
//
//  Function: InstallMsmqCore()
//
//  Synopsis: Install MSMQ core subcomponent
//
//--------------------------------------------------------------------------
BOOL
InstallMsmqCore()
{

    static BOOL fAlreadyInstalled = FALSE ;
    if (fAlreadyInstalled)
    {
        //
        // We're called more than once
        //
        return NO_ERROR ;
    }
    fAlreadyInstalled = TRUE ;

    if (g_hPropSheet)
    {
        //
        // Disable back/next buttons while we're installing.
        //
        PropSheet_SetWizButtons(g_hPropSheet, 0) ;
    }


    g_fCoreSetupSuccess = FALSE;

    if (g_fWelcome && Msmq1InstalledOnCluster())
    {
        if (!CompleteUpgradeOnCluster())
        {
            return FALSE;
        }
    }

    //
    // Create eventlog registry for MSMQ and MSMQTriggers services
    //
    WCHAR wszMessageFile[MAX_PATH];
    try
    {
        wsprintf(wszMessageFile, L"%s\\%s", g_szSystemDir, MQUTIL_DLL_NAME);
        EvSetup(MSMQ_SERVICE_NAME, wszMessageFile);

        wsprintf(wszMessageFile, L"%s\\%s", g_szSystemDir, MQUTIL_DLL_NAME);
        EvSetup(TRIG_SERVICE_NAME, wszMessageFile);
    }
    catch(const exception&)
	{
        //
        // ISSUE-2001/03/01-erez   Using GetLastError in catch
        // This should be replaced with a specifc exception by Cm and pass the
        // last error. e.g., use bad_win32_error class.
        //
        MqDisplayError(NULL, IDS_EVENTLOG_REGISTRY_ERROR, GetLastError(), MSMQ_SERVICE_NAME, wszMessageFile);
        return FALSE;
	}

    //
    // From this point on we perform install or upgrade operations.
    // The MSMQ files are already on disk.
    // This is a good point to load and keep open handles
    // to common MSMQ DLLs.
    // We unload these DLLs at the end of the install/upgrade path.
    //
    if (!LoadMsmqCommonDlls())
    {
        return FALSE;
    }


	//
	// These registry values are should be set on both fresh install
	// and upgrade, and before service is started.
	//
    DWORD dwStatus = MSMQ_SETUP_FRESH_INSTALL;
    if (g_fMSMQAlreadyInstalled)
    {
        dwStatus = MSMQ_SETUP_UPGRADE_FROM_NT;
    }
    if (0 != (g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE))
    {
        dwStatus = MSMQ_SETUP_UPGRADE_FROM_WIN9X;
    }
    MqWriteRegistryValue(MSMQ_SETUP_STATUS_REGNAME, sizeof(DWORD), REG_DWORD, &dwStatus);

    MqWriteRegistryValue(
        MSMQ_ROOT_PATH,
        (lstrlen(g_szMsmqDir) + 1) * sizeof(TCHAR),
        REG_SZ,
        g_szMsmqDir
        );

    MqOcmInstallPerfCounters() ;

	//
	// Set DsEnvironment registry defaults if needed
	//
	if(!DsEnvSetDefaults())
	{
		return false;
	}

    if (IsWorkgroup() || g_fDsLess)
    {
        //
        // we have to set Workgroup registry before ADInit since
        // this function uses the flag.
        //
        if (!SetWorkgroupRegistry())
        {
            return false;
        }
    }

	if (g_fUpgrade)
    {
        g_fCoreSetupSuccess = UpgradeMsmq();
    }
    else
    {
        if (!LoadDSLibrary(FALSE))
        {
            return false;
        }

        g_fCoreSetupSuccess = InstallMsmq();

        if (g_fServerSetup && g_dwMachineTypeDs)
        {
            MQDSSrvLibrary(FREE);
        }
        else
        {
            MQDSCliLibrary(FREE);
        }
    }          	

    if (!g_fCoreSetupSuccess)
    {
        if (g_fMSMQServiceInstalled ||
            g_fDriversInstalled )
        {
           //
           // remove msmq and mqds service and driver (if already installed).
           //
           RemoveServices();

           RemoveDeviceDrivers();
        }

    MqOcmRemovePerfCounters();
    }
    else
    {
        //
        // The code below is common to fresh install and upgrade.
        //
        DebugLogMsg(L"Starting operations which are common to a fresh installation and an upgrade...");

        RegisterCertificateOnLogon();

        //
        // Write to registry what type of MSMQ was just installed (server, client, etc.)
        //
        DWORD dwType = g_fDependentClient ? OCM_MSMQ_DEP_CLIENT_INSTALLED : OCM_MSMQ_IND_CLIENT_INSTALLED;
        if (g_fServerSetup)
        {
            dwType = OCM_MSMQ_SERVER_INSTALLED;
            switch (g_dwMachineType)
            {
                case SERVICE_DSSRV:
                    dwType |= OCM_MSMQ_SERVER_TYPE_BSC;
                    break;

                case SERVICE_PEC:  // PEC and PSC downgrade to FRS on cluster upgrade
                case SERVICE_PSC:
                case SERVICE_SRV:
                    dwType |= OCM_MSMQ_SERVER_TYPE_SUPPORT;
                    break;

                case SERVICE_RCS:
                    dwType = OCM_MSMQ_RAS_SERVER_INSTALLED;
                    break;

                case SERVICE_NONE:
                    //
                    // This can be valid only when installing DS server which is not FRS
                    //
                    ASSERT(g_dwMachineTypeDs && !g_dwMachineTypeFrs);
                    break;

                default:
                    ASSERT(0); // Internal error. Unknown server type.
                    break;
            }
        }

        BOOL bSuccess = MqWriteRegistryValue(
                            REG_INSTALLED_COMPONENTS,
                            sizeof(DWORD),
                            REG_DWORD,
                            (PVOID) &dwType,
                            /* bSetupRegSection = */TRUE
                            );
        ASSERT(bSuccess);

        //
        // Write to registry build info. This registry value also marks a successful
        // installation and mqrt.dll checks for it in order to enable its loading.
        //
        TCHAR szPreviousBuild[MAX_STRING_CHARS] = {0};
        DWORD dwNumBytes = sizeof(szPreviousBuild[0]) * (sizeof(szPreviousBuild) - 1);

        if (MqReadRegistryValue(MSMQ_CURRENT_BUILD_REGNAME, dwNumBytes, szPreviousBuild))
        {
            dwNumBytes = sizeof(szPreviousBuild[0]) * (lstrlen(szPreviousBuild) + 1);
            MqWriteRegistryValue(MSMQ_PREVIOUS_BUILD_REGNAME, dwNumBytes, REG_SZ, szPreviousBuild);
        }

        TCHAR szBuild[MAX_STRING_CHARS];
        _stprintf(szBuild, TEXT("%d.%d.%d"), rmj, rmm, rup);
        dwNumBytes = (lstrlen(szBuild) + 1) * sizeof(TCHAR);
        bSuccess = MqWriteRegistryValue(
                       MSMQ_CURRENT_BUILD_REGNAME,
                       dwNumBytes,
                       REG_SZ,
                       szBuild
                       );
        ASSERT(bSuccess);

        //
        // Now that mqrt.dll enables its loading we can call code that loads it.
        //

        RegisterActiveX(TRUE) ;

        RegisterSnapin(TRUE);

        if (!g_fUpgrade && !IsWorkgroup() && !g_fDsLess)
        {
            RegisterCertificate();
        }
    }

    return g_fCoreSetupSuccess ;

} //InstallMsmqCore

//+-------------------------------------------------------------------------
//
//  Empty installation function: everything was done in Install/Remove
//  MSMQ Core
//
//--------------------------------------------------------------------------

BOOL
InstallLocalStorage()
{
    //
    // do nothing
    //
    return TRUE;
}

BOOL
UnInstallLocalStorage()
{
    //
    // do nothing
    //
    return TRUE;
}

BOOL
InstallRouting()
{
    //
    // do nothing
    //
    return TRUE;
}

BOOL
UnInstallRouting()
{
    //
    // do nothing
    //
    return TRUE;
}

BOOL
InstallADIntegrated()
{
    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
    {
        //
        // it is the first installation of MSMQ
        //
        if (g_fContinueWithDsLess)
        {
            //
            // it means that user decided to install ds-less mode
            // since he failed to access AD
            //
            return FALSE;
        }
        return TRUE;
    }

    //
    // MSMQ Core already installed
    // To install AD Integrated:
    //      Remove "AlwaysWithoutDs" registry
    //      Ask user to reboot the computer
    //
    TCHAR buffer[MAX_PATH];
    _stprintf(buffer, TEXT("%s\\%s"), FALCON_REG_KEY, MSMQ_SETUP_KEY);
    CAutoCloseRegHandle hRegKey;
    HRESULT hResult = RegOpenKeyEx(
                            FALCON_REG_POS,
                            buffer,
                            0,
                            KEY_ALL_ACCESS,
                            &hRegKey);

    if (ERROR_SUCCESS != hResult)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, buffer);

        TCHAR szMsg[256];
        _stprintf(szMsg, TEXT("The %s registry key could not be opened. Return code: %x"),
            FALCON_REG_KEY, hResult);
        DebugLogMsg(szMsg);

        return FALSE;
    }

    hResult = RegDeleteValue(
                            hRegKey,
                            ALWAYS_WITHOUT_DS_NAME);
    if (ERROR_SUCCESS != hResult)
    {
        TCHAR szMsg[256];
        _stprintf(szMsg, TEXT("The %s registry value could not be deleted. Return code: %x"),
            ALWAYS_WITHOUT_DS_NAME, hResult);
        DebugLogMsg(szMsg);

        return FALSE;
    }

    MqDisplayWarning (NULL, IDS_ADINTEGRATED_INSTALL_WARN, 0);

    return TRUE;
}

BOOL
UnInstallADIntegrated()
{
    //
    // do nothing
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmmode.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmmode.cpp

Abstract:

    Code to handle setup mode.

Author:

    Doron Juster  (DoronJ)  31-Jul-97

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmmode.tmh"

BOOL g_fMQDSServiceWasActualSelected = FALSE;
BOOL g_fRoutingSupportWasActualSelected = FALSE;
BOOL g_fHTTPSupportWasActualSelected = FALSE;

//+-------------------------------------------------------------------------
//
//  Function: MqOcmQueryState 
//
//  Synopsis: Returns to OCM the component state (on/off)
//
//--------------------------------------------------------------------------
DWORD
MqOcmQueryState(
    IN const UINT_PTR uWhichState,
    IN const TCHAR    *SubcomponentId
    )
{        
    if (g_fCancelled)
        return SubcompUseOcManagerDefault;

    if (SubcomponentId == NULL)
    {        
        return SubcompUseOcManagerDefault;     
    }

    if (OCSELSTATETYPE_FINAL == uWhichState)
    {
        //
        // We are called after COMPLETE_INSTALLATION.
        // Should report our final state to OCM.              
        //
        // we need to return the status of the specific subcomponent
        // after its installation
        //
        return GetSubcomponentFinalState (SubcomponentId);      
    }               

    if (g_fWelcome)
    {   
        /*	
        g_SetupMode = (g_fMSMQAlreadyInstalled ? DONOTHING : INSTALL);

        if (Msmq1InstalledOnCluster())
        {
            g_SetupMode = INSTALL;
        }
        */

        //
        // When running from Welcome always install MSMQ
        // For that we have to return OFF for original state and
        // "Welcome" state for current state.
        // In GUI mode user selects MSMQ installation. All selected
        // components are set in "welcome" registry.
        // Now, when user run Configure MSMQ, OCM calls us to get
        // original state. OFF means that component was not installed.
        // Then OCM calls us again to get current subcomponent state.
        // We can return  the value that was defined in registry.
        // So, subcomponent mode is defined.
        //
        if (OCSELSTATETYPE_ORIGINAL == uWhichState)
        {
            return SubcompOff;
        }

        if (OCSELSTATETYPE_CURRENT == uWhichState)
        {
            DWORD dwWelcomeState = GetSubcomponentWelcomeState (SubcomponentId);
            return dwWelcomeState;
        }
    }

    //
    // We are here only in Add/Remove mode or unattended setup
    //
    DWORD dwInitialState = GetSubcomponentInitialState(SubcomponentId); 

    //
    // uWhichState is OCSELSTATETYPE_ORIGINAL or OCSELSTATETYPE_CURRENT
    // 

    if (OCSELSTATETYPE_ORIGINAL == uWhichState)
    {
        //
        // it is right for both attended and unattended setup
        // It is impossible to return SubcompUseOcManagerDefault since
        // for msmq_HTTPSupport OCM Subcomponents registry can be wrong
        // (we install HTTPSupport at the end after final subcomponent
        // state returning to OCM). So it is better to use our setup registry
        //
        return dwInitialState;
    }

    //
    // uWhichState is OCSELSTATETYPE_CURRENT
    //
    if (g_fBatchInstall)
    {    
        //
        // in such case OCM takes flags ON/OFF from unattended file
        //
        return SubcompUseOcManagerDefault;
    }
    
    //
    // according to the dwInitialState state of that subcomponent
    // will be shown in UI
    //
    return dwInitialState;     

} // MqOcmQueryState

//+-------------------------------------------------------------------------
//
//  Function: DefineDefaultSelection
//
//  Synopsis: Define default subcomponent state
//
//--------------------------------------------------------------------------
DWORD DefineDefaultSelection (
    IN const DWORD_PTR  dwActualSelection,
    IN OUT BOOL        *pbWasActualSelected
    )
{
    if (OCQ_ACTUAL_SELECTION == dwActualSelection)
    {
        //
        // actual selection: accept this change
        //
        *pbWasActualSelected = TRUE;
        return 1;
    }

    //
    // parent was selected: default is do not install subcomponent
    //       
    if (!(*pbWasActualSelected))
    {    
        return 0;            
    }
        
    //
    // we can be here if subcomponent was actually selected but 
    // OCM calls us for such event twice: when the component is actually
    // selected and then when it changes state of the parent.
    // So, in this case accept changes, but reset the flag.
    // We need to reset the flag for the scenario: select some 
    // subcomponents, return to the parent, unselect the parent and then
    // select parent again. In such case we have to put default again.
    //
    *pbWasActualSelected = FALSE;
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function: IsInstallationAccepted
//
//  Synopsis: Verify if it is allowed to install the subcomponent
//
//--------------------------------------------------------------------------
DWORD IsInstallationAccepted(
    IN const UINT       SubcomponentIndex, 
    IN const DWORD_PTR  dwActualSelection)
{
    if (g_fDependentClient &&
        SubcomponentIndex != eMSMQCore)
    {
        //
        // do not accept any selection if dependent client is
        // already installed
        //
        if ((OCQ_ACTUAL_SELECTION == dwActualSelection) || g_fBatchInstall)
        {
            MqDisplayError(NULL, IDS_ADD_SUBCOMP_ON_DEPCL_ERROR, 0);                
        }                
        return 0;
    }
            
    //
    // do not accept selection for Routing
    // if MSMQ Core already installed
    //            
    if (g_SubcomponentMsmq[eMSMQCore].fInitialState == TRUE &&
        // MSMQ Core installed
        SubcomponentIndex == eRoutingSupport &&
        // this subcomponent is Routing Support 
        g_SubcomponentMsmq[eRoutingSupport].fInitialState == FALSE
        // Routing support was not installed before
        )
    {           
        MqDisplayError(NULL, IDS_CHANGEROUTING_STATE_ERROR, 0);                 
        return 0;
    }            

    DWORD dwRet;    

    switch (SubcomponentIndex)
    {
    case eMSMQCore:              
    case eLocalStorage:
    case eTriggersService:    
    case eADIntegrated:
        //
        // always accept this selection
        //
        dwRet = 1;
        break;        

    case eHTTPSupport: 
        if (MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS)
        {
            //
            // always accept HTTP support selection on server
            //
            dwRet = 1;
        }
        else
        {
            dwRet = DefineDefaultSelection (dwActualSelection, 
                                            &g_fHTTPSupportWasActualSelected);
        }

        break;

    case eRoutingSupport:
        if (IsWorkgroup() && !g_fOnlyRegisterMode)
        {
            dwRet = 0;
            if (OCQ_ACTUAL_SELECTION == dwActualSelection)
            {
                MqDisplayError(NULL, IDS_ROUTING_ON_WORKGROUP_ERROR, 0);
            }
        }
        else
        {
            dwRet = DefineDefaultSelection (dwActualSelection, 
                                        &g_fRoutingSupportWasActualSelected);                      
        }
        break;
        
    case eMQDSService  :
        if (IsWorkgroup() && !g_fOnlyRegisterMode)
        {
            dwRet = 0;
            if (OCQ_ACTUAL_SELECTION == dwActualSelection)
            {
                MqDisplayError(NULL, IDS_MQDS_ON_WORKGROUP_ERROR, 0);
            }
        }
        else
        {
            dwRet = DefineDefaultSelection (dwActualSelection, 
                                        &g_fMQDSServiceWasActualSelected);                        
        }
        break;

    default :
        ASSERT(0);
        dwRet = 0;
        break;
    }
             
    return dwRet;            
}

//+-------------------------------------------------------------------------
//
//  Function: IsRemovingAccepted
//
//  Synopsis: Verify if it is allowed to remove the subcomponent
//
//--------------------------------------------------------------------------
DWORD IsRemovingAccepted( 
    IN const UINT       SubcomponentIndex, 
    IN const DWORD_PTR  dwActualSelection,
    IN const UINT       uMsgId)
{
    if (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == FALSE)
    {
        //            
        // it was not installed, so do nothing, accept all
        //
        return 1;
    }
          
    switch (SubcomponentIndex)
    {
    case eMSMQCore:                
                                   
        if (OCQ_ACTUAL_SELECTION == dwActualSelection)
        {             
            if (MqAskContinue(uMsgId, IDS_UNINSTALL_AREYOUSURE_TITLE, TRUE))
            {                   
                return 1;                   
            }
            else
            {                    
                return 0;
            }
        }                
    
    case eMQDSService:
    case eTriggersService: 
    case eHTTPSupport:
        return 1;        

    case eRoutingSupport:
        if (OCQ_ACTUAL_SELECTION == dwActualSelection)
        {            
            MqDisplayError(NULL, IDS_CHANGEROUTING_STATE_ERROR, 0);        
            return 0;
        }
        else
        {                
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }     

    case eLocalStorage:
        if (OCQ_ACTUAL_SELECTION == dwActualSelection)
        {
            MqDisplayError(NULL, IDS_CHANGE_LOCAL_STORAGE_STATE, 0); 
            return 0;
        }
        else
        {
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }   

    case eADIntegrated:
        if (OCQ_ACTUAL_SELECTION == dwActualSelection)
        {            
            MqDisplayError(NULL, IDS_REMOVE_AD_INTEGRATED, 0); 
            return 0;
        }
        else
        {
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }  

    default:

        ASSERT(0);
        break;
    }  //end switch
        
    return 0;       
}

//+-------------------------------------------------------------------------
//
//  Function: MqOcmQueryChangeSelState
//
//  Synopsis: Set selection state for each component
//
//--------------------------------------------------------------------------
DWORD MqOcmQueryChangeSelState (
    IN const TCHAR      *SubcomponentId,    
    IN const UINT_PTR    iSelection,
    IN const DWORD_PTR   dwActualSelection)
{
    DWORD dwRetCode = 1;    //by default accept state changes        
    UINT uMsgId = IDS_UNINSTALL_AREYOUSURE_MSG;
    if (g_fDependentClient)
    {
      uMsgId = IDS_DEP_UNINSTALL_AREYOUSURE_MSG;
    }     

    //
    // Do not change in this code dwOperation value in this code!
    // It will be done later (in function SetOperationForSubcomponents)
    // for all subcomponents when all selection will be defined by user    
    // Here we have to save the initial state of dwOperation to handle
    // correctly subcomponent selection (Routing or Local Storage)
    //

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }                
        
        //
        // we found this subcomponent
        //        

        if (iSelection) //subcomponent is selected
        {                                   
            //
            // we need to install subcomponent
            //  
            dwRetCode = IsInstallationAccepted(i, dwActualSelection);                        
              
            if (dwRetCode)
            {
                WCHAR wszMsg[1000];
                wsprintf(wszMsg, L"The %s subcomponent is selected for installation.",
                    SubcomponentId);
                DebugLogMsg(wszMsg);            
            }            

            return dwRetCode;
        }
        
        //
        // User tries to unselect this subcomponent
        //        
        dwRetCode = IsRemovingAccepted(i, dwActualSelection, uMsgId);       
   
        if (dwRetCode)
        {
            WCHAR wszMsg[1000];
            wsprintf(wszMsg, L"The %s subcomponent is unselected and will be removed.",
                SubcomponentId);
            DebugLogMsg(wszMsg);
        }
        
        return dwRetCode;
        
    }   //end for

    //
    // we are here if parent (msmq) was selected/ deselected
    //
    if (iSelection) //install msmq
    {
        return 1;
    }

    //
    // remove all msmq
    //    
    if (g_SubcomponentMsmq[eMSMQCore].fInitialState == FALSE)
    {
        //
        // it was not installed
        //
        return 1;
    }

    if (OCQ_ACTUAL_SELECTION != dwActualSelection)
    {            
        dwRetCode = 1;
    }
    else if (MqAskContinue(uMsgId, IDS_UNINSTALL_AREYOUSURE_TITLE, TRUE))
    {         
        dwRetCode = 1;
    }
    else
    {         
        dwRetCode = 0;
    }      
        
    return dwRetCode;
} // MqOcmQueryChangeSelState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmperf.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmperf.cpp

Abstract:

    Handle installation and removal of performance counters

Author:

    Doron Juster  (DoronJ)   6-Oct-97  

Revision History:

	Shai Kariv    (ShaiK)   15-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmperf.tmh"

//+-------------------------------------------------------------------------
//
//  Function: UnloadCounters 
//
//  Synopsis: Uninstalls performance counters  
//
//--------------------------------------------------------------------------
void 
UnloadCounters()
{
	//
	// Unload the performance counters
	//
    TCHAR szCommand[MAX_STRING_CHARS];

    _stprintf(szCommand, TEXT("unlodctr MSMQ"));
    RunProcess(szCommand);

    _stprintf(szCommand, TEXT("unlodctr MQ1SYNC"));
    RunProcess(szCommand);

} //UnloadCounters


//+-------------------------------------------------------------------------
//
//  Function: LoadCounters 
//
//  Synopsis: Installs performance counters  
//
//--------------------------------------------------------------------------
void 
LoadCounters()
{
    //
    // Load the performance counters
    //
	DWORD dwExitCode;
    SetCurrentDirectory(g_szSystemDir);

    TCHAR szCommand[MAX_STRING_CHARS];

    _stprintf(szCommand, TEXT("lodctr mqperf.ini"));

	if (RunProcess(szCommand, &dwExitCode))
    {
        //
        // Check if the performance counters were loaded successfully
        //
        if (dwExitCode != 0)
    	{
    		MqDisplayError(NULL, IDS_COUNTERSLOAD_ERROR, dwExitCode);
    	}
    }
} //LoadCounters


//+-------------------------------------------------------------------------
//
//  Function: HandlePerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
static 
BOOL  
HandlePerfCounters(
	TCHAR *pOp, 
	BOOL *pNoOp = NULL)
{
    if (g_fDependentClient)
    {        
        DebugLogMsg(L"This Message Queuing computer is a dependent client. There is no need to install performance counters.");

        if (pNoOp)
        {
            *pNoOp = TRUE ;
        }
        return TRUE ;
    }

    
    UnloadCounters() ;  
    
    DebugLogMsg(L"Setting registry values for the performance counters...");

    if (!SetupInstallFromInfSection( 
		NULL,
        g_ComponentMsmq.hMyInf,
        pOp,
        SPINST_REGISTRY,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        NULL,
        NULL ))
	{        
        DebugLogMsg(L"The registry values for the performance counters could not be set.");
		return FALSE;
	}
    
    DebugLogMsg(L"The registry values for the performance counters were set successfully.");
    return TRUE ;

} //HandlePerfCounters


//+-------------------------------------------------------------------------
//
//  Function: MqOcmInstallPerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
BOOL  
MqOcmInstallPerfCounters()
{    
    DebugLogMsg(L"Installing performance counters.");

    BOOL fNoOp = FALSE ;

    if (!HandlePerfCounters(OCM_PERF_ADDREG, &fNoOp))
    {
        return FALSE ;
    }
    if (fNoOp)
    {
        return TRUE ;
    }

    LoadCounters() ;
    
    DebugLogMsg(L"The performance counters were installed successfully.");
    return TRUE ;

} //MqOcmInstallPerfCounters


//+-------------------------------------------------------------------------
//
//  Function: MqOcmRemovePerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
BOOL  
MqOcmRemovePerfCounters()
{
    return HandlePerfCounters(OCM_PERF_DELREG) ;

} //MqOcmRemovePerfCounters
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocminit.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocminit.cpp

Abstract:

    Code for initialization of OCM setup.

Author:

    Doron Juster  (DoronJ)   7-Oct-97  

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "Cm.h"
#include "cancel.h"

#include "ocminit.tmh"

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

//+-------------------------------------------------------------------------
//
//  Function:   SetDirectories
//
//  Synopsis:   Generate MSMQ specific directory names and set directory IDs
//
//--------------------------------------------------------------------------
DWORD
SetDirectories(
    VOID
    )
{    
    DebugLogMsg(L"Setting Message Queuing folders...");

    DWORD err = 0;

    //
    // Set root dir for MSMQ
    //
    if (_tcslen(g_szMsmqDir) < 1)
    {
        GetSystemDirectory(g_szMsmqDir, sizeof(g_szMsmqDir)/sizeof(g_szMsmqDir[0]));
	    lstrcat(g_szMsmqDir, DIR_MSMQ);
    }
    
    DebugLogMsg(L"Setting folder ID for the Message Queuing folder:");
    DebugLogMsg(g_szMsmqDir);
    if (!SetupSetDirectoryId( g_ComponentMsmq.hMyInf, idMsmqDir, g_szMsmqDir ))
    {
        err = GetLastError();

        return err;
    }


    //
    // Set the exchange connector dir of MSMQ1 / MSMQ2-beta2
    // Do we need it for Whistler?
    //
    TCHAR szXchangeDir[MAX_PATH];                                        
    lstrcpy( szXchangeDir, g_szMsmqDir);
    lstrcat( szXchangeDir, OCM_DIR_MSMQ_SETUP_EXCHN);    
    DebugLogMsg(L"Setting the folder ID for the Message Queuing Exchange Connector folder (beta2):");
    DebugLogMsg(szXchangeDir);
    if (!SetupSetDirectoryId( g_ComponentMsmq.hMyInf, idExchnConDir, szXchangeDir))
    {
        err = GetLastError();


        return err;
    }

    //
    // Set the storage dir
    //
    lstrcpy(g_szMsmqStoreDir, g_szMsmqDir);                                     
    lstrcat(g_szMsmqStoreDir, DIR_MSMQ_STORAGE);    
    DebugLogMsg(L"Setting the folder ID for the Message Queuing storage folder:");
    DebugLogMsg(g_szMsmqStoreDir);
    if (!SetupSetDirectoryId( g_ComponentMsmq.hMyInf, idStorageDir, g_szMsmqStoreDir))
    {
        err = GetLastError();

        return err;
    }

    //
    // Set the web dir
    //
    lstrcpy(g_szMsmqWebDir, g_szMsmqDir);                                        
    lstrcat(g_szMsmqWebDir, DIR_MSMQ_WEB);    
    DebugLogMsg(L"Setting the folder ID for the Message Queuing Web folder:");
    DebugLogMsg(g_szMsmqWebDir);
    if (!SetupSetDirectoryId( g_ComponentMsmq.hMyInf, idWebDir, g_szMsmqWebDir))
    {
        err = GetLastError();

        return err;
    }

    //
    // Set the mapping dir
    //
    lstrcpy(g_szMsmqMappingDir, g_szMsmqDir);                                        
    lstrcat(g_szMsmqMappingDir, DIR_MSMQ_MAPPING);    
    DebugLogMsg(L"Setting the folder ID for the Message Queuing mapping folder:");
    DebugLogMsg(g_szMsmqMappingDir);
    if (!SetupSetDirectoryId( g_ComponentMsmq.hMyInf, idMappingDir, g_szMsmqMappingDir))
    {
        err = GetLastError();

        return err;
    }

    //
    // Set directories for MSMQ1 files
    //

    lstrcpy(g_szMsmq1SetupDir, g_szMsmqDir);
    lstrcat(g_szMsmq1SetupDir, OCM_DIR_SETUP);    
    DebugLogMsg(L"Setting the folder ID for the MSMQ 1.0 setup folder:");
    DebugLogMsg(g_szMsmq1SetupDir);
    if (!SetupSetDirectoryId(g_ComponentMsmq.hMyInf, idMsmq1SetupDir, g_szMsmq1SetupDir))
    {
        err = GetLastError();

        return err;
    }

    lstrcpy(g_szMsmq1SdkDebugDir, g_szMsmqDir);
    lstrcat(g_szMsmq1SdkDebugDir, OCM_DIR_SDK_DEBUG);    
    DebugLogMsg(L"Setting the folder ID for the MSMQ 1.0 SDK debug folder:");
    DebugLogMsg(g_szMsmq1SdkDebugDir);
    if (!SetupSetDirectoryId(g_ComponentMsmq.hMyInf, idMsmq1SDK_DebugDir, g_szMsmq1SdkDebugDir))
    {
        err = GetLastError();

        return err;
    }
    
    DebugLogMsg(L"Setting the Message Queuing folder IDs was completed successfully!");
    return NO_ERROR;

} // SetDirectories


//+-------------------------------------------------------------------------
//
//  Function:   CheckMsmqK2OnCluster
//
//  Synopsis:   Checks if we're upgrading MSMQ 1.0 K2 on cluster to NT 5.0.
//              This is special because of bug 2656 (registry corrupt).
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckMsmqK2OnCluster()
{    
    DebugLogMsg(L"Checking for an upgrade from MSMQ 1.0 k2 in the cluster...");

    //
    // Check in registry if there is MSMQ installation on cluster
    //
    if (!Msmq1InstalledOnCluster())
    {        
        DebugLogMsg(L"MSMQ 1.0 is not installed in the cluster");
        return TRUE;
    }

    //
    // Read the persistent storage directory from registry.
    // MSMQ directory will be one level above it.
    // This is a good enough workaround since storage directory is
    // always on a cluster shared disk.
    //
    if (!MqReadRegistryValue(
             MSMQ_STORE_PERSISTENT_PATH_REGNAME,
             sizeof(g_szMsmqDir),
             (PVOID) g_szMsmqDir
             ))
    {        
        DebugLogMsg(L"The persistent storage path could not be read from the registry. MSMQ 1.0 was not found");
        return TRUE;
    }

    TCHAR * pChar = _tcsrchr(g_szMsmqDir, TEXT('\\'));
    if (pChar)
    {
        *pChar = TEXT('\0');
    }

    //
    // Read type of MSMQ from MachineCache\MQS
    //
    DWORD dwType = SERVICE_NONE;
    if (!MqReadRegistryValue(
             MSMQ_MQS_REGNAME,
             sizeof(DWORD),
             (PVOID) &dwType
             ))
    {
        //
        // MSMQ installed but failed to read its type
        //
        MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
        return FALSE;
    }

    g_dwMachineType = dwType;
    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_fDependentClient = FALSE;

    switch (dwType)
    {
        case SERVICE_PEC:
        case SERVICE_PSC:
        case SERVICE_BSC:
            g_dwDsUpgradeType = dwType;
            g_dwMachineTypeDs = 1;
            g_dwMachineTypeFrs = 1;
            //
            // Fall through
            //
        case SERVICE_SRV:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 1;
            break;

        case SERVICE_RCS:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 0;
            break;

        case SERVICE_NONE:
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 0;
            break;

        default:
            MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
    }

    return TRUE;

} //CheckMsmqK2OnCluster


//+-------------------------------------------------------------------------
//
//  Function:   CheckWin9xUpgrade
//
//  Synopsis:   Checks if we're upgrading Win9x with MSMQ 1.0 to NT 5.0.
//              Upgrading Win9x is special because registry settings
//              can not be read during GUI mode. Therefore we use a special
//              migration DLL during the Win95 part of NT 5.0 upgrade.
//
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckWin9xUpgrade()
{    
    DebugLogMsg(L"Checking for an upgrade from Windows 9x...");

    //
    // If this is not OS upgrade from Win95, we got nothing to do here
    //
    if (!(g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE))
    {
        return TRUE;
    }

    //
    // Generate the info file name (under %WinDir%).
    // The file was created by MSMQ migration DLL during the
    // Win95 part of NT 5.0 upgrade.
    //
    TCHAR szWindowsDir[MAX_PATH];
    TCHAR szMsmqInfoFile[MAX_PATH];

    GetSystemWindowsDirectory(  
        szWindowsDir, 
        sizeof(szWindowsDir)/sizeof(szWindowsDir[0])
        );
    _stprintf(szMsmqInfoFile, TEXT("%s\\%s"), szWindowsDir, MQMIG95_INFO_FILENAME);

    //
    // MQMIG95_INFO_FILENAME (msmqinfo.txt) is actually a .ini file. However we do not read it using 
    // GetPrivateProfileString because it is not trustable in GUI-mode setup 
    // (YoelA - 15-Mar-99)
    //
    FILE *stream = _tfopen(szMsmqInfoFile, TEXT("r"));
    if (0 == stream)
    {
        //
        // Info file not found. That means MSMQ 1.0 is not installed
        // on this machine. Log it.
        // 
        MqDisplayError(NULL, IDS_MSMQINFO_NOT_FOUND_ERROR, 0);
        return TRUE;
    }

    //
    // First line should be [msmq]. Check it.
    //
    TCHAR szToken[MAX_PATH], szType[MAX_PATH];
    //
    // "[%[^]]s" - Read the string between '[' and ']' (start with '[', read anything that is not ']')
    //
    int iScanResult = _ftscanf(stream, TEXT("[%[^]]s"), szToken);
    if ((iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF) ||
        (_tcscmp(szToken, MQMIG95_MSMQ_SECTION) != 0))
    {
        //
        // File is currupted. Either a pre-mature EOF, or first line is not [msmq[
        //
        MqDisplayError(NULL, IDS_MSMQINFO_HEADER_ERROR, 0);
        return TRUE;

    }

    //
    // The first line is in format "directory = xxxx". We first prepate a format string,
    // And then read according to that format.
    // The format string will look like "] directory = %[^\r\n]s" - start with ']' (last 
    // character in header), then whitespaces (newlines, etc), then 'directory =', and
    // from then take everything till the end of line (not \r or \n).
    //
    TCHAR szInFormat[MAX_PATH];
	_stprintf(szInFormat,  TEXT("] %s = %%[^\r\n]s"), MQMIG95_MSMQ_DIR);
	iScanResult = _ftscanf(stream, szInFormat, g_szMsmqDir);
    if (iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF)
    {
        //
        // We did not find the "directory =" section. file is corrupted
        //
        MqDisplayError(NULL, IDS_MSMQINFO_DIRECTORY_KEY_ERROR, 0);
        return TRUE;
    }

    //
    // The second line is in format "type = xxx" (after white spaces)
    //
    _stprintf(szInFormat,  TEXT(" %s = %%[^\r\n]s"), MQMIG95_MSMQ_TYPE);
    iScanResult =_ftscanf(stream, szInFormat, szType);
    if (iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF)
    {
        //
        // We did not find the "type =" section. file is corrupted
        //
        MqDisplayError(NULL, IDS_MSMQINFO_TYPE_KEY_ERROR, 0);
        return TRUE;
    }

    fclose( stream );
    //
    // At this point we know that MSMQ 1.0 is installed on the machine,
    // and we got its root directory and type.
    //
    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = TRUE;
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_dwMachineType = SERVICE_NONE;
    g_dwMachineTypeDs = 0;
    g_dwMachineTypeFrs = 0;
    g_fDependentClient = OcmStringsEqual(szType, MQMIG95_MSMQ_TYPE_DEP);
    MqDisplayError(NULL, IDS_WIN95_UPGRADE_MSG, 0);

    return TRUE;

} // CheckWin9xUpgrade


//+-------------------------------------------------------------------------
//
//  Function:   CheckMsmqAcmeInstalled
//
//  Synopsis:   Checks if MSMQ 1.0 (ACME) is installed on this computer.
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckMsmqAcmeInstalled()
{    
    DebugLogMsg(L"Checking for installed components of MSMQ 1.0 ACME setup...");

    //
    // Open ACME registry key
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_ALL_ACCESS,
                  &hKey 
                  );
    if (rc != ERROR_SUCCESS)
    {        
        DebugLogMsg(L"The ACME registry key could not be opened. MSMQ 1.0 ACME was not found.");
        return TRUE;
    }

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile, *p;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            ASSERT(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            p = CharNext(pFile);
            if (OcmStringsEqual(p, ACME_STF_NAME))
            {
                //
                // Found. Cut the STF file name from the full path name.
                //
                *pFile = TEXT('\0') ;
                bFound = TRUE;                
                DebugLogMsg(L"MSMQ 1.0 ACME was found.");

                //
                // Delete the MSMQ entry
                //
                RegDeleteValue(hKey, szValueName); 
            }
            else
            {
                pFile = CharNext(pFile) ;
            }

        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found.
        //        
        DebugLogMsg(L"MSMQ 1.0 ACME was not found.");
        return TRUE;
    }

    //
    // Remove the "setup" subdirectory from the path name.
    //
    pFile = _tcsrchr(szValueData, TEXT('\\')) ;
    p = CharNext(pFile);
    *pFile = TEXT('\0') ;
    if (!OcmStringsEqual(p, ACME_SETUP_DIR_NAME))
    {
        //
        // That's a problem. It should have been "setup".
        // Consider ACME installation to be corrupted (not completed successfully).
        //        
        DebugLogMsg(L"MSMQ 1.0 ACME is corrupted");
        return TRUE;
    }

    lstrcpy( g_szMsmqDir, szValueData);

    //
    // Check MSMQ type (client, server etc.)
    //
    DWORD dwMsmqType;
    BOOL bResult = MqReadRegistryValue(
                       MSMQ_ACME_TYPE_REG,
                       sizeof(DWORD),
                       (PVOID) &dwMsmqType
                       );
    if (!bResult)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        //
        MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
        return FALSE;
    }

    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_dwMachineType = SERVICE_NONE;
    g_dwMachineTypeDs = 0;
    g_dwMachineTypeFrs = 0;
    g_fDependentClient = FALSE;
    switch (dwMsmqType)
    {
        case MSMQ_ACME_TYPE_DEP:
        {
            g_fDependentClient = TRUE;
            break;
        }
        case MSMQ_ACME_TYPE_IND:
        {
            break;
        }
        case MSMQ_ACME_TYPE_RAS:
        {
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineType = SERVICE_RCS;
            break;
        }
        case MSMQ_ACME_TYPE_SRV:
        {
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            DWORD dwServerType = SERVICE_NONE;
            bFound = MqReadRegistryValue(
                         MSMQ_MQS_REGNAME,
                         sizeof(DWORD),
                         (PVOID) &dwServerType
                         );
            switch (dwServerType)
            {
                case SERVICE_PEC:
                case SERVICE_PSC:
                case SERVICE_BSC:
                {
                    g_dwMachineType = SERVICE_DSSRV;
                    g_dwDsUpgradeType = dwServerType;
                    g_dwMachineTypeDs = 1;
                    g_dwMachineTypeFrs = 1;
                    break;
                }    
                case SERVICE_SRV:
                {
                    g_dwMachineType = SERVICE_SRV;
                    g_dwMachineTypeDs = 0;
                    g_dwMachineTypeFrs = 1;
                    break;
                }
                default:
                {
                    //
                    // Unknown MSMQ 1.0 server type. 
                    //
                    MqDisplayError(NULL, IDS_MSMQ1SERVERUNKNOWN_ERROR, 0);
                    return FALSE;
                    break ;
                }
            }
            break;
        }
        default:
        {
            //
            // Unknown MSMQ 1.0 type
            //
            MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
        }
    }

    return TRUE;

} // CheckMsmqAcmeInstalled


//+-------------------------------------------------------------------------
//
//  Function:   CheckInstalledComponents
//
//  Synopsis:   Checks if MSMQ is already installed on this computer
//
//  Returns:    BOOL dependes on success. The result is stored in 
//              g_fMSMQAlreadyInstalled.
//
//--------------------------------------------------------------------------
static
BOOL
CheckInstalledComponents()
{
    g_fMSMQAlreadyInstalled = FALSE;
    g_fUpgrade = FALSE;
    DWORD dwOriginalInstalled = 0;
    
    DebugLogMsg(L"Checking for installed components...");

    if (MqReadRegistryValue( 
            REG_INSTALLED_COMPONENTS,
            sizeof(DWORD),
            (PVOID) &dwOriginalInstalled,
            /* bSetupRegSection = */TRUE
            ))
    {
        //
        // MSMQ 2.0 Beta 3 or later is installed.
        // Read MSMQ type and directory from registry
        //
        // Note: to improve performance (shorten init time) we can do these
        // reads when we actually need the values (i.e. later, not at init time).
        //
                
        DebugLogMsg(L"Message Queuing 2.0 Beta3 or later is installed");

        if (!MqReadRegistryValue(
                 MSMQ_ROOT_PATH,
                 sizeof(g_szMsmqDir),
                 (PVOID) g_szMsmqDir
                 ))
        {
            if (!MqReadRegistryValue(
                     REG_DIRECTORY,
                     sizeof(g_szMsmqDir),
                     (PVOID) g_szMsmqDir,
                     /* bSetupRegSection = */TRUE
                     ))
            {
                
                MqDisplayError(NULL, IDS_MSMQROOTNOTFOUND_ERROR, 0); 
                return FALSE;
            }
        }
  
        if (!MqReadRegistryValue(
                 MSMQ_MQS_DSSERVER_REGNAME,
                 sizeof(DWORD),
                 (PVOID)&g_dwMachineTypeDs
                 )                             ||
            !MqReadRegistryValue(
                 MSMQ_MQS_ROUTING_REGNAME,
                 sizeof(DWORD),
                 (PVOID)&g_dwMachineTypeFrs
                 ))
        {
            //
            // This could be okay if dependent client is installed
            //
            if (OCM_MSMQ_DEP_CLIENT_INSTALLED != (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK))
            {
                MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
                return FALSE;
            }
        }

        g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));        
        g_fMSMQAlreadyInstalled = TRUE;
        g_fServerSetup = FALSE;
        g_uTitleID = IDS_STR_CLI_ERROR_TITLE ;
        g_dwMachineType = SERVICE_NONE;
        g_fDependentClient = FALSE;
        switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
        {
            case OCM_MSMQ_DEP_CLIENT_INSTALLED:
                g_fDependentClient = TRUE;
                break;

            case OCM_MSMQ_IND_CLIENT_INSTALLED:
                break;
            
            case OCM_MSMQ_SERVER_INSTALLED:
                g_fServerSetup = TRUE;
                g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
                switch (dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK)
                {
                    case OCM_MSMQ_SERVER_TYPE_PEC:
                    case OCM_MSMQ_SERVER_TYPE_PSC:
                    case OCM_MSMQ_SERVER_TYPE_BSC:
                        g_dwMachineType = SERVICE_DSSRV;
                        break;

                    case OCM_MSMQ_SERVER_TYPE_SUPPORT:
                        g_dwMachineType = SERVICE_SRV;
                        break ;

                    default:
                        //
						// Beta3 and later, this is ok if DS without FRS installed. 
						// In such case this MSMQ machine is presented to "old" MSMQ machines
						// as independent client.
						//
						if (g_dwMachineTypeDs && !g_dwMachineTypeFrs)
						{
							g_dwMachineType = SERVICE_NONE;
							break;
						}

                        MqDisplayError(NULL, IDS_MSMQSERVERUNKNOWN_ERROR, 0);
						return FALSE;
                        break ;
                }
                break;
            
            case OCM_MSMQ_RAS_SERVER_INSTALLED:
                g_fServerSetup = TRUE;
                g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
                g_dwMachineType = SERVICE_RCS;
                break;

            default:
                MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
                return FALSE;
                break;
        }

        return TRUE;

    } // MSMQ beta 3 or later


#ifndef _DEBUG
    //
    // If we're not in OS setup, don't check older versions (beta2, msmq1, etc).
    // This is a *little* less robust (we expect the user to upgrade msmq only thru OS
    // upgrade), but decrease init time (ShaiK, 25-Oct-98)
    //
    // In we are running as a post-upgrade-on-cluster wizard, do check for old versions.
    //
    if (!g_fWelcome || !Msmq1InstalledOnCluster())
    {
        if (0 != (g_ComponentMsmq.Flags & SETUPOP_STANDALONE))
        {            
            DebugLogMsg(L"Message Queuing 2.0 Beta3 or later is NOT installed. Skipping check for other versions...");            
            DebugLogMsg(L"Consider Message Queuing NOT installed on this computer.");
            return TRUE;
        }
    }
#endif //_DEBUG

    if (MqReadRegistryValue( 
            OCM_REG_MSMQ_SETUP_INSTALLED,
            sizeof(DWORD),
            (PVOID) &dwOriginalInstalled
            ))
    {
        //
        // MSMQ 2.0 beta2 or MSMQ 1.0 k2 is installed.
        // Read MSMQ type and directory from registry
        //
        
        DebugLogMsg(L"Message Queuing 2.0 Beta2 or MSMQ 1.0 k2 is installed.");

        if (!MqReadRegistryValue(
                 OCM_REG_MSMQ_DIRECTORY,
                 sizeof(g_szMsmqDir),
                 (PVOID) g_szMsmqDir
                 ))
        {
            MqDisplayError(NULL, IDS_MSMQROOTNOTFOUND_ERROR, 0); 
            return FALSE;
        }
        
        g_fMSMQAlreadyInstalled = TRUE;
        g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
        g_fServerSetup = FALSE;
        g_uTitleID = IDS_STR_CLI_ERROR_TITLE ;
        g_dwMachineType = SERVICE_NONE;
        g_dwMachineTypeDs = 0;
        g_dwMachineTypeFrs = 0;
        g_fDependentClient = FALSE;
        switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
        {
            case OCM_MSMQ_DEP_CLIENT_INSTALLED:
                g_fDependentClient = TRUE;
                break;

            case OCM_MSMQ_IND_CLIENT_INSTALLED:
                break;

            case OCM_MSMQ_SERVER_INSTALLED:
                g_fServerSetup = TRUE;
                g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
                switch (dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK)
                {
                    case OCM_MSMQ_SERVER_TYPE_PEC:
                        g_dwDsUpgradeType = SERVICE_PEC;
                        g_dwMachineType   = SERVICE_DSSRV;
                        g_dwMachineTypeDs = 1;
                        g_dwMachineTypeFrs = 1;
                        break;

                    case OCM_MSMQ_SERVER_TYPE_PSC:
                        g_dwDsUpgradeType = SERVICE_PSC;
                        g_dwMachineType   = SERVICE_DSSRV;
                        g_dwMachineTypeDs = 1;
                        g_dwMachineTypeFrs = 1;
                        break;

                    case OCM_MSMQ_SERVER_TYPE_BSC:
                        g_dwDsUpgradeType = SERVICE_BSC;
                        g_dwMachineType = SERVICE_DSSRV;
                        g_dwMachineTypeDs = 1;
                        g_dwMachineTypeFrs = 1;
                        break;

                    case OCM_MSMQ_SERVER_TYPE_SUPPORT:
                        g_dwMachineType = SERVICE_SRV;
                        g_dwMachineTypeFrs = 1;
                        break ;

                    default:
                        MqDisplayError(NULL, IDS_MSMQSERVERUNKNOWN_ERROR, 0);
                        return FALSE;
                        break ;
                }
                break;
            
            case OCM_MSMQ_RAS_SERVER_INSTALLED:
                g_fServerSetup = TRUE;
                g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
                g_dwMachineType = SERVICE_RCS;
                break;

            default:
                MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
                return FALSE;
                break;
        }

        TCHAR szMsmqVersion[MAX_STRING_CHARS] = {0};
        if (MqReadRegistryValue(
                OCM_REG_MSMQ_PRODUCT_VERSION,
                sizeof(szMsmqVersion),
                (PVOID) szMsmqVersion
                ))
        {
            //
            // Upgrading MSMQ 2.0 beta 2, don't upgrade DS
            //
            g_dwDsUpgradeType = 0;
        }

        return TRUE;

    } // MSMQ 2.0 or MSMQ 1.0 k2


    //
    // Check if MSMQ 1.0 (ACME) is installed
    //
    BOOL bRetCode = CheckMsmqAcmeInstalled();
    if (g_fMSMQAlreadyInstalled)
        return bRetCode;
    
    //
    // Special case: check if this is MSMQ 1.0 on Win9x upgrade
    //
    bRetCode = CheckWin9xUpgrade();
    if (g_fMSMQAlreadyInstalled)
        return bRetCode;
    
    //
    // Special case: workaround for bug 2656, registry corrupt for msmq1 k2 on cluster
    //
    return CheckMsmqK2OnCluster();

} // CheckInstalledComponents

static bool s_fInitCancelThread = false;

//+-------------------------------------------------------------------------
//
//  Function:   MqOcmInitComponent
//
//  Synopsis:   Called by MsmqOcm() on OC_INIT_COMPONENT
//
//  Arguments:  ComponentId    -- name of the MSMQ component
//              Param2         -- pointer to setup info struct
//
//  Returns:    Win32 error code
//
//--------------------------------------------------------------------------
DWORD 
MqOcmInitComponent( 
    IN     const LPCTSTR ComponentId,
    IN OUT       PVOID   Param2 )
{        
    DebugLogMsg(L"Starting initialization...");

    //
    // Store per component info
    //
    PSETUP_INIT_COMPONENT pInitComponent = (PSETUP_INIT_COMPONENT)Param2;
    g_ComponentMsmq.hMyInf = pInitComponent->ComponentInfHandle;
    g_ComponentMsmq.dwProductType = pInitComponent->SetupData.ProductType;
    g_ComponentMsmq.HelperRoutines = pInitComponent->HelperRoutines;
    g_ComponentMsmq.Flags = pInitComponent->SetupData.OperationFlags;
    lstrcpy( g_ComponentMsmq.SourcePath, pInitComponent->SetupData.SourcePath );
    lstrcpy( g_ComponentMsmq.ComponentId, ComponentId );

    TCHAR sz[100];              
    DebugLogMsg(L"Dump of OCM flags:"); 
    _stprintf(sz, _T("%s=0x%x"), _T("ProductType"), pInitComponent->SetupData.ProductType);
    DebugLogMsg(sz);
    _stprintf(sz, _T("%s=0x%x"), _T("OperationFlags"), pInitComponent->SetupData.OperationFlags);
    DebugLogMsg(sz);
    _stprintf(sz, _T("%s=%s"), _T("SourcePath"), pInitComponent->SetupData.SourcePath);
    DebugLogMsg(sz);
    _stprintf(sz, _T("%s=%d"), _T("ComponentId"), ComponentId);
    DebugLogMsg(sz);  
    
    if (!s_fInitCancelThread)
    {
        g_CancelRpc.Init();
        s_fInitCancelThread = true;
    }

    if (INVALID_HANDLE_VALUE == g_ComponentMsmq.hMyInf)
    {
       g_fCancelled = TRUE;       
       DebugLogMsg(L"The value of the handle for Msmqocm.inf is invalid. Setup will not continue.");
       return NO_ERROR;
    }

    if (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE))
    {
        //
        // OS setup - don't show UI
        //        
        DebugLogMsg(L"OS setup. Switching to unattended mode...");
        g_fBatchInstall = TRUE;
    }

    //
    // Check if wer'e in unattended mode.
    //
    if (g_ComponentMsmq.Flags & SETUPOP_BATCH)
    {
        g_fBatchInstall = TRUE;
        lstrcpy( g_ComponentMsmq.szUnattendFile, pInitComponent->SetupData.UnattendFile );
        
        DebugLogMsg(L"Unattended mode. The unattended answer file is:");
        DebugLogMsg(g_ComponentMsmq.szUnattendFile);
    }

    //
    // Append layout inf file to our inf file
    //
    SetupOpenAppendInfFile( 0, g_ComponentMsmq.hMyInf, 0 );

    //
    // Check if MSMQ is already installed on this machine.
    // Result is stored in g_fMSMQAlreadyInstalled.
    //
    if (!CheckInstalledComponents())
    {        
        DebugLogMsg(L"An error occurred during the checking for installed components. Setup will not continue.");
        g_fCancelled = TRUE;
        return NO_ERROR;
    }

    if (g_fWelcome && Msmq1InstalledOnCluster() && g_dwMachineTypeDs != 0)
    {
        //
        // Running as a post-cluster-upgrade wizard.
        // MSMQ DS server should downgrade to routing server.
        //
        g_dwMachineTypeDs = 0;
        g_dwMachineTypeFrs = 1;
        g_dwMachineType = SERVICE_SRV;
    }

    //
    // On fresh install on non domain controller,
    // default is installing independent client.
    //
    if (!g_fMSMQAlreadyInstalled && !g_dwMachineTypeDs)
    {
        g_fServerSetup = FALSE;
        g_fDependentClient = FALSE;
        g_dwMachineTypeFrs = 0;
    }

    if (!InitializeOSVersion())
    {        
        DebugLogMsg(L"An error occurred in getting the operating system information. Setup will not continue.");
        g_fCancelled = TRUE;
        return NO_ERROR;
    }

    //
    // init number of subcomponent that is depending on platform
    //
    if (MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS)
    {
        g_dwSubcomponentNumber = g_dwAllSubcomponentNumber;
    }
    else
    {
        g_dwSubcomponentNumber = g_dwClientSubcomponentNumber;
    }
   
    _stprintf(sz, TEXT("The number of subcomponents is %d"), g_dwSubcomponentNumber);
    DebugLogMsg(sz);    

    //
    // User must have admin access rights to run this setup
    //
    if (!CheckServicePrivilege())
    {
        g_fCancelled = TRUE;
        MqDisplayError(NULL, IDS_SERVICEPRIVILEGE_ERROR, 0);        
        return NO_ERROR;
    }  

    if ((0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE)) && !g_fMSMQAlreadyInstalled)
    {
        //
        // GUI mode + MSMQ is not installed
        //       
        g_fOnlyRegisterMode = TRUE;        
        DebugLogMsg(L"GUI mode and Message Queuing is not installed.");
    }
    
    DebugLogMsg(L"Initialization was completed successfully!");
    
    return NO_ERROR ;

} //MqOcmInitComponent

bool
MqInit()
/*++

Routine Description:

    Handles "lazy initialization" (init as late as possible to shorten OCM startup time)

Arguments:

    None

Return Value:

    None

--*/
{
    static bool fBeenHere = false;
    static bool fLastReturnCode = true;
    if (fBeenHere)
    {
        return fLastReturnCode;
    }
    fBeenHere = true;
    
    DebugLogMsg(L"Starting late initialization...");

    GetSystemDirectory( 
        g_szSystemDir,
        sizeof(g_szSystemDir) / sizeof(g_szSystemDir[0])
        );
    
    DWORD dwNumChars = sizeof(g_wcsMachineName) / sizeof(g_wcsMachineName[0]);
    GetComputerName(g_wcsMachineName, &dwNumChars);

    dwNumChars = sizeof(g_wcsMachineNameDns) / sizeof(g_wcsMachineNameDns[0]);
    GetComputerNameEx(ComputerNameDnsFullyQualified, g_wcsMachineNameDns, &dwNumChars);       

    //
    // Create and set MSMQ directories
    //
    DWORD dwResult = SetDirectories();
    if (NO_ERROR != dwResult)
    {        
        DebugLogMsg(L"An error occurred in setting the folders. Setup will not continue.");
        g_fCancelled = TRUE;
        fLastReturnCode = false;
        return fLastReturnCode;
    }

    //
    // initialize to use Ev.lib later. We might need it to use registry function 
    // in setup code too.
    //
    CmInitialize(HKEY_LOCAL_MACHINE, L"");
    
    DebugLogMsg(L"Late initialization was completed successfully!");
    fLastReturnCode = true;
    return fLastReturnCode;

}//MqInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmreg.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmreg.cpp

Abstract:

    Registry related code for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmreg.tmh"

//+-------------------------------------------------------------------------
//
//  Function:  GenerateSubkeyValue
//
//  Synopsis:  Creates a subkey in registry
//
//+-------------------------------------------------------------------------

BOOL
GenerateSubkeyValue(
    IN     const BOOL    fWriteToRegistry,
    IN     const TCHAR  * szEntryName,
    IN OUT       TCHAR  * szValueName,
    IN OUT       HKEY    &hRegKey,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    )
{
    //
    // Store the full subkey path and value name
    //
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    if (bSetupRegSection)
    {
        _stprintf(szKeyName, TEXT("%s\\%s"), MSMQ_REG_SETUP_KEY, szEntryName);
    }

    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    if (szValueName)
    {
        lstrcpy(szValueName, _tcsinc(pLastBackslash));
        lstrcpy(pLastBackslash, TEXT(""));
    }

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HRESULT hResult = RegCreateKeyEx(
        FALCON_REG_POS,
        szKeyName,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hRegKey,
        &dwDisposition);

    if (hResult != ERROR_SUCCESS && fWriteToRegistry)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        FALCON_REG_POS_DESC, szKeyName);
        return FALSE;
    }

    return TRUE;
} // GenerateSubkeyValue


//+-------------------------------------------------------------------------
//
//  Function:  MqWriteRegistryValue
//
//  Synopsis:  Sets a MSMQ value in registry (under MSMQ key)
//
//+-------------------------------------------------------------------------
BOOL
MqWriteRegistryValue(
    IN const TCHAR  * szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
    TCHAR szValueName[256] = {_T("")};
    HKEY hRegKey;

    if (!GenerateSubkeyValue( TRUE, szEntryName, szValueName, hRegKey, bSetupRegSection))
        return FALSE;

    //
    // Set the requested registry value
    //
    HRESULT hResult = RegSetValueEx( hRegKey, szValueName, 0, dwValueType,
                                    (BYTE *)pValueData, dwNumBytes);
    RegFlushKey(hRegKey);

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              szEntryName);
    }

    RegCloseKey(hRegKey);

    return (hResult == ERROR_SUCCESS);

} //MqWriteRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:  MqReadRegistryValue
//
//  Synopsis:  Gets a MSMQ value from registry (under MSMQ key)
//
//+-------------------------------------------------------------------------
BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
    TCHAR szValueName[256] = {_T("")};
    HKEY hRegKey;

    if (!GenerateSubkeyValue( FALSE, szEntryName, szValueName, hRegKey, bSetupRegSection))
        return FALSE;

    //
    // Get the requested registry value
    //
    HRESULT hResult = RegQueryValueEx( hRegKey, szValueName, 0, NULL,
                                      (BYTE *)pValueData, &dwNumBytes);

    RegCloseKey(hRegKey);

    return (hResult == ERROR_SUCCESS);

} //MqReadRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:  RegDeleteKeyWithSubkeys
//
//  Synopsis:
//
//+-------------------------------------------------------------------------
DWORD
RegDeleteKeyWithSubkeys(
    IN const HKEY    hRootKey,
    IN const LPCTSTR szKeyName)
{
    //
    // Open the key to delete
    //
    HKEY hRegKey;
    RegOpenKeyEx(hRootKey, szKeyName, 0,
                 KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, &hRegKey);

    //
    // Recursively delete all subkeys of the key
    //
    TCHAR szSubkeyName[512] = {_T("")};
    DWORD dwNumChars;
    HRESULT hResult = ERROR_SUCCESS;
    do
    {
        //
        // Check if the key has any subkeys
        //
        dwNumChars = 512;
        hResult = RegEnumKeyEx(hRegKey, 0, szSubkeyName, &dwNumChars,
                               NULL, NULL, NULL, NULL);

        //
        // Delete the subkey
        //
        if (hResult == ERROR_SUCCESS)
        {
            hResult = RegDeleteKeyWithSubkeys(hRegKey, szSubkeyName);
        }

    } while (hResult == ERROR_SUCCESS);

    //
    // Close the key
    //
    RegCloseKey(hRegKey);

    //
    // If there are no more subkeys, delete the key itself
    //
    if (hResult == ERROR_NO_MORE_ITEMS)
    {
        hResult = RegDeleteKey(hRootKey, szKeyName);
    }

    return hResult;

} //RegDeleteKeyWithSubkeys


//+--------------------------------------------------------------
//
// Function: StoreServerPathInRegistry
//
// Synopsis: Writes server name in registry
//
//+--------------------------------------------------------------
BOOL
StoreServerPathInRegistry(
    IN const TCHAR * szServerName
    )
{
    //
    // No need to do that for dependent client
    //
    if (!g_fServerSetup && g_fDependentClient)
        return TRUE;

    TCHAR szServerPath[128] = {_T("")};
    _stprintf(szServerPath, TEXT("11%s"), szServerName);
    DWORD dwNumBytes = (lstrlen(szServerPath) + 1) *
                       sizeof(TCHAR);
    if (!MqWriteRegistryValue( MSMQ_DS_SERVER_REGNAME, dwNumBytes, REG_SZ, szServerPath))
    {
        return FALSE;
    }

    if (!MqWriteRegistryValue(MSMQ_DS_CURRENT_SERVER_REGNAME, dwNumBytes, REG_SZ, szServerPath))
    {
        return FALSE;
    }

	if(!WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_MQIS))
    {
        return FALSE;
    }

    return TRUE;

} //StoreServerPathInRegistry


//+-------------------------------------------------------------------------
//
//  Function:   RegisterWelcome
//
//  Synopsis:   Registers this setup for Configure Your Server page.
//              We use CYS in 2 scenarios:
//              1. When MSMQ is selected in GUI mode.
//              2. When MSMQ is upgraded on Cluster.
//
//--------------------------------------------------------------------------
BOOL
RegisterWelcome()
{
    //
    // Create the ToDoList\MSMQ key
    //
    DWORD dwDisposition;
    HKEY hKey;
    HRESULT hResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        WELCOME_TODOLIST_MSMQ_KEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, WELCOME_TODOLIST_MSMQ_KEY);
        return FALSE;
    }

    //
    // Set the MSMQ values
    //
    CResString strWelcomeTitleData(IDS_WELCOME_TITLE_DATA);
    if (Msmq1InstalledOnCluster() && !g_fDependentClient)
    {
        strWelcomeTitleData.Load(IDS_WELCOME_TITLE_CLUSTER_UPGRADE);
    }
    hResult = RegSetValueEx(
        hKey,
        WELCOME_TITLE_NAME,
        0,
        REG_SZ,
        (PBYTE)strWelcomeTitleData.Get(),
        sizeof(TCHAR) * (lstrlen(strWelcomeTitleData.Get()) + 1)
        );

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_TITLE_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    LPTSTR szConfigCommand = TEXT("sysocmgr.exe");
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_COMMAND_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigCommand,
        sizeof(TCHAR) * (lstrlen(szConfigCommand) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_COMMAND_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    TCHAR szConfigArgs[MAX_STRING_CHARS];
    lstrcpy(szConfigArgs, TEXT("/i:mqsysoc.inf /x"));
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_ARGS_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigArgs,
        sizeof(TCHAR) * (lstrlen(szConfigArgs) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_ARGS_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    RegCloseKey(hKey);

    //
    // Flag in MSMQ registry that MSMQ files are already on disk.
    // This is true both wheh msmq is selected in GUI mode and when
    // upgrading on Cluster.
    //
    DWORD dwCopied = 1;
    MqWriteRegistryValue(MSMQ_FILES_COPIED_REGNAME, sizeof(DWORD), REG_DWORD, &dwCopied, TRUE);

    return TRUE;

} // RegisterWelcome


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterWelcome
//
//  Synopsis:   Unregisters this setup from Welcome UI
//
//--------------------------------------------------------------------------
BOOL
UnregisterWelcome()
{
    return (ERROR_SUCCESS == RegDeleteKey(
                                 HKEY_LOCAL_MACHINE,
                                 WELCOME_TODOLIST_MSMQ_KEY
                                 ));

} // UnregisterWelcome


//+-------------------------------------------------------------------------
//
//  Function:   RegisterMigrationForWelcome
//
//  Synopsis:   Registers the migration utility for Welcome UI
//
//--------------------------------------------------------------------------
BOOL
RegisterMigrationForWelcome()
{
    //
    // Create the ToDoList\MSMQ key
    //
    DWORD dwDisposition;
    HKEY hKey;
    HRESULT hResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        WELCOME_TODOLIST_MSMQ_KEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, WELCOME_TODOLIST_MSMQ_KEY);
        return FALSE;
    }

    //
    // Set the MSMQ values
    //
    CResString strWelcomeTitleData(IDS_MIGRATION_WELCOME_TITLE_DATA);
    hResult = RegSetValueEx(
        hKey,
        WELCOME_TITLE_NAME,
        0,
        REG_SZ,
        (PBYTE)strWelcomeTitleData.Get(),
        sizeof(TCHAR) * (lstrlen(strWelcomeTitleData.Get()) + 1)
        );

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_TITLE_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    TCHAR szConfigCommand[MAX_STRING_CHARS];
    lstrcpy(szConfigCommand, g_szSystemDir);
    lstrcat(szConfigCommand, TEXT("\\"));
    lstrcat(szConfigCommand, MQMIG_EXE);
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_COMMAND_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigCommand,
        sizeof(TCHAR) * (lstrlen(szConfigCommand) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_COMMAND_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;

} // RegisterMigrationForWelcome

//+-------------------------------------------------------------------------
//
//  Function:   SetRegistryValue
//
//  Synopsis:   Set Registry Value
//
//--------------------------------------------------------------------------
BOOL SetRegistryValue (IN const HKEY    hKey, 
                       IN const TCHAR   *pszEntryName,
                       IN const DWORD   dwNumBytes,
                       IN const DWORD   dwValueType,
                       IN const PVOID   pValueData)
{
    HRESULT hResult = RegSetValueEx(
                            hKey,
                            pszEntryName,
                            0,
                            dwValueType,
                            (BYTE *)pValueData,
                            dwNumBytes
                            );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              pszEntryName
              );          
          return FALSE;
    }

    
    RegFlushKey(hKey);        

    return TRUE;
} //SetRegistryValue

//+-------------------------------------------------------------------------
//
//  Function:   RegisterPGMDriver
//
//  Synopsis:   Registers pgm driver
//
//--------------------------------------------------------------------------
BOOL RegisterPGMDriver()
{
    //
    // Create the 
    // System \ CurrentControlSet \ Services \ PGM \ Parameters \ Winsock key
    //
    TCHAR buffer[256];
    _stprintf(buffer, TEXT("%s\\%s\\%s\\%s"),
            SERVICES_ROOT_REG,
            PGM_DRIVER_NAME,
            PARAMETERS_REG,
            WINSOCK_REG );

    DWORD dwDisposition;
    CAutoCloseRegHandle hPGMKey;

    HRESULT hResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        buffer,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hPGMKey,
        &dwDisposition
        );
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, buffer);
        return FALSE;
    }
    
    TCHAR szDllPath[MAX_PATH];
    _stprintf(szDllPath,TEXT("%s\\%s"), g_szSystemDir, PGM_DLL);            
    BOOL f = SetRegistryValue (
                    hPGMKey, 
                    PGM_DLL_REGKEY,
                    sizeof(TCHAR) * (lstrlen(szDllPath) + 1),
                    REG_EXPAND_SZ,
                    PVOID (szDllPath));
    if (!f)
    {
        return FALSE;
    }

    DWORD dwMaxSockAddressLength = 0x10;
    f = SetRegistryValue (
                    hPGMKey, 
                    PGM_MAXSOCKLENGTH_REGKEY,
                    sizeof(DWORD),
                    REG_DWORD,
                    &dwMaxSockAddressLength);
    if (!f)
    {
        return FALSE;
    }

    DWORD dwMinSockAddressLength = 0x10;
    f = SetRegistryValue (
                    hPGMKey, 
                    PGM_MINSOCKLENGTH_REGKEY,
                    sizeof(DWORD),
                    REG_DWORD,
                    &dwMinSockAddressLength);
    if (!f)
    {
        return FALSE;
    }

    DWORD Mapping[] = { 0x2, 0x3, 0x2, 0x4, 0x71, 0x2, 0x1, 0x71 };
    DWORD dwSize = sizeof(Mapping);    
    f = SetRegistryValue (
                    hPGMKey, 
                    PGM_MAPPING_REGKEY,
                    dwSize,
                    REG_BINARY,
                    (PVOID) Mapping);
    if (!f)
    {
        return FALSE;
    }  

    //
    // Open the 
    // System \ CurrentControlSet \ Services \ Winsock \ Parameters key
    //    
    CAutoCloseRegHandle hWinsockKey;

    _stprintf(buffer, TEXT("%s\\%s\\%s"),
            SERVICES_ROOT_REG,
            WINSOCK_REG,
            PARAMETERS_REG);
    
    hResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                buffer,
                0L,
                KEY_ALL_ACCESS,
                &hWinsockKey);
  
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, buffer);
        return FALSE;
    }

    BYTE  ch ;
    dwSize = sizeof(BYTE) ;
    DWORD dwType = REG_MULTI_SZ ;
    hResult = RegQueryValueEx(hWinsockKey,
                         TRANSPORTS_REGKEY,
                         NULL,
                         &dwType,
                         (BYTE*)&ch,
                         &dwSize) ;
    if (hResult != ERROR_MORE_DATA)
    {   
        return FALSE;
    }
    
    P<WCHAR> pBuf = new WCHAR[ dwSize + 2 ] ;
    hResult = RegQueryValueEx(hWinsockKey,
                         TRANSPORTS_REGKEY,
                         NULL,
                         &dwType,
                         (BYTE*) &pBuf[0],
                         &dwSize) ;
    if (hResult != ERROR_SUCCESS)
    {      
        return FALSE;
    }        
    
    //
    // Look for the string PGM_DRIVER_NAME.
    // The REG_MULTI_SZ set of strings terminate with two
    // nulls. This condition is checked in the "while".
    //
    DWORD dwNewSize = dwSize + sizeof(TCHAR) * (lstrlen(PGM_DRIVER_NAME) + 2);
    P<WCHAR> pNewBuf = new WCHAR[ dwNewSize ];
    memset (pNewBuf, 0, dwNewSize);

    WCHAR *pVal = pBuf ;
    WCHAR *pNewVal = pNewBuf;
    
    while(*pVal)
    {
        if (_wcsicmp(PGM_DRIVER_NAME, pVal) == 0)
        {           
            return TRUE;
        }
        wcscpy(pNewVal, pVal);        
        pNewVal = pNewVal + wcslen(pNewVal) + 1 ;
        pVal = pVal + wcslen(pVal) + 1 ;
    }

    //
    // we have to add PGM_DRIVER_NAME to Transport registry key
    //
    wcscpy(pNewVal, PGM_DRIVER_NAME);
     
    f = SetRegistryValue (
                    hWinsockKey, 
                    TRANSPORTS_REGKEY,
                    dwNewSize,
                    REG_MULTI_SZ,
                    (PVOID) pNewBuf);
    if (!f)
    {
        return FALSE;
    }
    
    return TRUE;

} //RegisterPGMDriver

//+-------------------------------------------------------------------------
//
//  Function:   RemovePGMRegistry
//
//  Synopsis:   Remove pgm driver from WInsock registry
//
//--------------------------------------------------------------------------
BOOL RemovePGMRegistry()
{
    //
    // Open the 
    // System \ CurrentControlSet \ Services \ Winsock \ Parameters key
    //   
    CAutoCloseRegHandle hKey;
    TCHAR buffer[256];

    _stprintf(buffer, TEXT("%s\\%s\\%s"),
            SERVICES_ROOT_REG,
            WINSOCK_REG,
            PARAMETERS_REG);
    
    HRESULT hResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                buffer,
                0L,
                KEY_ALL_ACCESS,
                &hKey);
  
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, buffer);
        return FALSE;
    }

    BYTE  ch ;
    DWORD dwSize = sizeof(BYTE) ;
    DWORD dwType = REG_MULTI_SZ ;
    hResult = RegQueryValueEx(hKey,
                         TRANSPORTS_REGKEY,
                         NULL,
                         &dwType,
                         (BYTE*)&ch,
                         &dwSize) ;
    if (hResult != ERROR_MORE_DATA)
    {        
        return FALSE;
    }
    
    P<WCHAR> pBuf = new WCHAR[ dwSize + 2 ] ;
    hResult = RegQueryValueEx(hKey,
                         TRANSPORTS_REGKEY,
                         NULL,
                         &dwType,
                         (BYTE*) &pBuf[0],
                         &dwSize) ;
    if (hResult != ERROR_SUCCESS)
    {        
        return FALSE;
    }
    
    //
    // Look for the string PGM_DRIVER_NAME and remove it from the list.
    // The REG_MULTI_SZ set of strings terminate with two
    // nulls. This condition is checked in the "while".
    //    
    P<WCHAR> pNewBuf = new WCHAR[ dwSize ];
    memset (pNewBuf, 0, dwSize);
    DWORD dwNewSize = 0;

    WCHAR *pVal = pBuf ;
    WCHAR *pNewVal = pNewBuf;
    
    BOOL fFound = FALSE;
    while(*pVal)
    {
        if (_wcsicmp(PGM_DRIVER_NAME, pVal) != 0)
        {            
            wcscpy(pNewVal, pVal);    
            dwNewSize = dwNewSize + sizeof(TCHAR) * (lstrlen(pNewVal) + 1);
            pNewVal = pNewVal + wcslen(pNewVal) + 1 ;            
        }
        else
        {
            fFound = TRUE;
        }
        pVal = pVal + wcslen(pVal) + 1 ;
    }

    if (!fFound)
    {
        return TRUE;
    }

    //
    // add the second '\0' at the end
    //
    dwNewSize+= sizeof(TCHAR);

    //
    // we have to remove PGM_DRIVER_NAME from Transport registry key
    //    
     
    BOOL f = SetRegistryValue (
                    hKey, 
                    TRANSPORTS_REGKEY,
                    dwNewSize,
                    REG_MULTI_SZ,
                    (PVOID) pNewBuf);
    if (!f)
    {
        return FALSE;
    }
 
    return TRUE;
}

BOOL RemoveRegistryKeyFromSetup (IN const LPCTSTR szRegistryEntry)
{
    CAutoCloseRegHandle hSetupRegKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                            FALCON_REG_POS, 
                            MSMQ_REG_SETUP_KEY, 
                            0, 
                            KEY_ALL_ACCESS, 
                            &hSetupRegKey))
    {    
        TCHAR szMsg[256];
        _stprintf(szMsg, TEXT("The %s registry key could not be opened."),
            MSMQ_REG_SETUP_KEY);
        DebugLogMsg(szMsg);    

        return FALSE;
    }

    if (ERROR_SUCCESS != RegDeleteValue(
                            hSetupRegKey, 
                            szRegistryEntry))
    { 
        TCHAR szMsg[256];
        _stprintf(szMsg, TEXT("The %s registry value could not be deleted."),
            szRegistryEntry);
        DebugLogMsg(szMsg);
     
        return FALSE;
    }

    return TRUE;

} //RemoveRegistryKeyFromSetup

BOOL
SetWorkgroupRegistry()
{
    DWORD dwWorkgroup = 1;
    if (!MqWriteRegistryValue(
        MSMQ_WORKGROUP_REGNAME,
        sizeof(DWORD),
        REG_DWORD,
        (PVOID) &dwWorkgroup
        ))
    {
        ASSERT(("failed to write Workgroup value in registry", 0));
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\msmqocm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    msmqocm.h

Abstract:

    Master header file for NT5 OCM setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


#ifndef _MSMQOCM_H
#define _MSMQOCM_H

#include "stdh.h"
#include "comreg.h"
#include "ocmnames.h"
#include "service.h"
#include "setupdef.h"

#include <activeds.h>
#include <shlwapi.h>
#include <autorel.h>    //auto release pointer definition
#include <autorel2.h>
#include <exception>    //exception class definition
#include "ad.h"
#include <mqcast.h>

//++-------------------------------------------------------
//
// Globals declaration
//
//-------------------------------------------------------++
extern WCHAR      g_wcsMachineName[MAX_PATH];
extern WCHAR      g_wcsMachineNameDns[MAX_PATH];
extern HINSTANCE  g_hResourceMod;
extern HINSTANCE  g_hMqutil;

extern BOOL       g_fMSMQAlreadyInstalled;
extern SC_HANDLE  g_hServiceCtrlMgr;
extern BOOL       g_fMSMQServiceInstalled;
extern BOOL       g_fDriversInstalled;
extern BOOL       g_fNeedToCreateIISExtension;
extern HWND       g_hPropSheet ;

extern DWORD      g_dwMachineType ;
extern DWORD      g_dwMachineTypeDs;
extern DWORD      g_dwMachineTypeFrs;
extern DWORD      g_dwMachineTypeDepSrv;

extern BOOL       g_fDependentClient ;
extern BOOL       g_fServerSetup ;
extern BOOL       g_fDsLess;
extern BOOL       g_fContinueWithDsLess;

extern BOOL       g_fCancelled ;
extern BOOL       g_fUpgrade ;
extern DWORD      g_dwDsUpgradeType;
extern BOOL       g_fBatchInstall ;
extern BOOL       g_fWelcome;
extern BOOL       g_fOnlyRegisterMode ;
extern BOOL       g_fWrongConfiguration;

extern TCHAR      g_szMsmqDir[MAX_PATH];
extern TCHAR      g_szMsmqStoreDir[MAX_PATH];
extern TCHAR      g_szMsmq1SetupDir[MAX_PATH];
extern TCHAR      g_szMsmq1SdkDebugDir[MAX_PATH];
extern TCHAR      g_szMsmqWebDir[MAX_PATH];
extern TCHAR      g_szMsmqMappingDir[MAX_PATH];

extern UINT       g_uTitleID  ;
extern TCHAR      g_wcsServerName[ MAX_PATH ] ;
extern TCHAR      g_szSystemDir[MAX_PATH];

extern BOOL       g_fDomainController;
extern DWORD      g_dwOS;
extern BOOL       g_fAlreadyAnsweredToServerAuthentication;
extern BOOL       g_fUseServerAuthen ;
extern BOOL       g_fCoreSetupSuccess;

extern const char g_szMappingSample[];


//++-----------------------------------------------------------
//
// Structs and classes
//
//-----------------------------------------------------------++

//
// Component info sent by OC Manager (per component data)
//
struct SPerComponentData
{
    TCHAR              ComponentId[ MAX_PATH ];
    HINF               hMyInf;
    DWORDLONG          Flags;
    LANGID             LanguageId;
    TCHAR              SourcePath[MAX_PATH];
    TCHAR              szUnattendFile[MAX_PATH];
    OCMANAGER_ROUTINES HelperRoutines;
    DWORD              dwProductType;
};
extern SPerComponentData g_ComponentMsmq;

typedef BOOL (WINAPI*  Install_HANDLER)();
typedef BOOL (WINAPI*  Remove_HANDLER)();

struct SSubcomponentData
{
    TCHAR       szSubcomponentId[MAX_PATH];
    
    //TRUE if it was installed when we start THIS setup, otherwise FALSE
    BOOL        fInitialState;  
    //TRUE if user select it to install, FALSE to remove
    BOOL        fIsSelected;    
    //TRUE if it was installed successfully during THIS setup
    //FALSE if it was removed
    BOOL        fIsInstalled;
    DWORD       dwOperation;
    
    //
    // function to install and remove subcomponent
    //
    Install_HANDLER  pfnInstall;
    Remove_HANDLER   pfnRemove;
};
extern SSubcomponentData g_SubcomponentMsmq[];
extern DWORD g_dwSubcomponentNumber;
extern DWORD g_dwAllSubcomponentNumber;
extern DWORD g_dwClientSubcomponentNumber;

//
// The order is important! It must suit to the subcomponent order
// in g_SubcomponentMsmq[]
// NB! eRoutingSupport must be FIRST server subcomponents since according 
// to that number g_dwClientSubcomponentNumber is calculated
//
typedef enum {
    eMSMQCore = 0,
    eLocalStorage,
    eTriggersService,
    eHTTPSupport,
    eADIntegrated,
    eRoutingSupport,
    eMQDSService    
} SubcomponentIndex;

//
// String handling class
//
class CResString
{
public:
    CResString() { m_Buf[0] = 0; }

    CResString( UINT strIDS )
    {
        m_Buf[0] = 0;
        LoadString(
            g_hResourceMod,
            strIDS,
            m_Buf,
            sizeof m_Buf / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        m_Buf[0] = 0;
        LoadString(
            g_hResourceMod,
            strIDS,
            m_Buf,
            sizeof(m_Buf) / sizeof(TCHAR)
            );
        return ( 0 != m_Buf[0] );
    }

    TCHAR * const Get() { return m_Buf; }

private:
    TCHAR m_Buf[MAX_STRING_CHARS];
};


//++------------------------------------------------------------
//
//  Functions prototype
//
//------------------------------------------------------------++

//
// OCM request handlers
//
DWORD
MqOcmInitComponent(
    IN     const LPCTSTR ComponentId,
    IN OUT       PVOID   Param2
    ) ;

BOOL
MqOcmRemoveInstallation(IN     const TCHAR  * SubcomponentId);

DWORD
MqOcmRequestPages(
    IN     const TCHAR               *ComponentId,
    IN     const WizardPagesType     WhichOnes,
    IN OUT       SETUP_REQUEST_PAGES *SetupPages
    ) ;

DWORD
MqOcmCalcDiskSpace(
    IN     const BOOL    bInstall,
    IN     const TCHAR  * SubcomponentId,
    IN OUT       HDSKSPC &hDiskSpaceList
    );

DWORD
MqOcmQueueFiles(
    IN     const TCHAR  * SubcomponentId,
    IN OUT       HSPFILEQ hFileList
    );

DWORD
MqOcmQueryState(
    IN const UINT_PTR uWhichState,
    IN const TCHAR    *SubcomponentId
    );

DWORD MqOcmQueryChangeSelState (
    IN const TCHAR      *SubcomponentId,    
    IN const UINT_PTR    iSelection,
    IN const DWORD_PTR   dwActualSelection
    );

//
// Registry routines
//
void
MqOcmReadRegConfig() ;

BOOL
StoreServerPathInRegistry(
    IN const TCHAR * szServerName
    );

BOOL
MqSetupInstallRegistry();

BOOL
MqSetupRemoveRegistry();

BOOL
MqWriteRegistryValue(
    IN const TCHAR  * szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    );

BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    );

DWORD
RegDeleteKeyWithSubkeys(
    IN const HKEY    hRootKey,
    IN const LPCTSTR szKeyName);

BOOL
RegisterWelcome();

BOOL
RegisterMigrationForWelcome();

BOOL
UnregisterWelcome();

BOOL 
RemoveRegistryKeyFromSetup (
    IN const LPCTSTR szRegistryEntry);

BOOL
SetWorkgroupRegistry();

//
// Installation routines
//
DWORD
MqOcmInstall(IN const TCHAR * SubcomponentId);

BOOL
InstallMachine();

void
RegisterActiveX(
    IN const BOOL bRegister
    );

void
RegisterSnapin(
    IN const BOOL fRegister
    );
void
RegisterDll(
    BOOL fRegister,
    BOOL f32BitOnWin64,
	LPCTSTR szDllName
    );
void
UnregisterMailoaIfExists(
    void
    );

bool
UpgradeMsmqClusterResource(
    VOID
    );

bool 
TriggersInstalled(
    bool * pfMsmq3TriggersInstalled
    );

BOOL
InstallMSMQTriggers (
	void
	);

BOOL
UnInstallMSMQTriggers (
	void
	);

BOOL
InstallMsmqCore(
    void
    );

BOOL 
RemoveMSMQCore(
    void
    );

BOOL
InstallLocalStorage(
    void
    );

BOOL
UnInstallLocalStorage(
    void
    );

BOOL
InstallRouting(
    void
    );

BOOL
UnInstallRouting(
    void
    );

BOOL
InstallADIntegrated(
    void
    );

BOOL
UnInstallADIntegrated(
    void
    );

//
// IIS Extension routines
//
BOOL
InstallIISExtension();

BOOL 
UnInstallIISExtension();

//
// Operating System routines
//
BOOL
InitializeOSVersion() ;

BOOL
IsNTE();

//
// Service handling routines
//

BOOL
CheckServicePrivilege();

BOOL
InstallService(
    LPCWSTR szDisplayName,
    LPCWSTR szServicePath,
    LPCWSTR szDependencies,
    LPCWSTR szServiceName,
    LPCWSTR szDescription
    );

BOOL
RunService(
	IN LPTSTR szServiceName
	);

void
RemoveServices();  // Remove MSMQ

BOOL
RemoveService(
    IN const PTCHAR szServiceName
    );

BOOL
StopService(
    IN const TCHAR * szServiceName
    );

BOOL
InstallDeviceDrivers();

BOOL
RemoveDeviceDrivers();

BOOL
InstallMSMQService();

BOOL
DisableMsmqService();

BOOL
UpgradeServiceDependencies();

BOOL
InstallMQDSService();

BOOL
UnInstallMQDSService();

BOOL
GetServiceState(
    IN  const TCHAR *szServiceName,
    OUT       DWORD *pdwServiceState
    );

BOOL 
InstallPGMDeviceDriver();

BOOL
RegisterPGMDriver();

BOOL
RemovePGMRegistry();

//
// DS handling routines
//
BOOL
MQDSCliLibrary(
    IN const UCHAR uOperation,
    IN const BOOL  fInitServerAuth =FALSE);

BOOL
MQDSSrvLibrary(
    IN const UCHAR uOperation
    );

bool WriteDsEnvRegistry(DWORD dwDsEnv);

bool DsEnvSetDefaults();

BOOL
LoadDSLibrary(
    BOOL bUpdate = TRUE
    ) ;

BOOL
CreateMSMQServiceObject(
    IN UINT uLongLive = MSMQ_DEFAULT_LONG_LIVE
    ) ;

BOOL
CreateMSMQConfigurationsObject(
    OUT GUID *pguidMachine,
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server
    );

BOOL
UpdateMSMQConfigurationsObject(
    IN LPCWSTR pMachineName,
    IN const GUID& guidMachine,
    IN const GUID& guidSite,
    IN BOOL fMsmq1Server
    );

BOOL
GetMSMQServiceGUID(
    OUT GUID *pguidMSMQService
    );

BOOL
GetSiteGUID();

BOOL
LookupMSMQConfigurationsObject(
    IN OUT BOOL *pbFound,
       OUT GUID *pguidMachine,
       OUT GUID *pguidSite,
       OUT BOOL *pfMsmq1Server,
       OUT LPWSTR * ppMachineName
       );

void
FRemoveMQXPIfExists();

//
// Error handling routines
//
int
_cdecl
MqDisplayError(
    IN const HWND  hdlg,
    IN const UINT  uErrorID,
    IN const DWORD dwErrorCode,
    ...);

int
_cdecl
MqDisplayErrorWithRetry(
    IN const UINT  uErrorID,
    IN const DWORD dwErrorCode,
    ...);

int 
_cdecl 
MqDisplayErrorWithRetryIgnore(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...);

BOOL
_cdecl
MqAskContinue(
    IN const UINT uProblemID,
    IN const UINT uTitleID,
    IN const BOOL bDefaultContinue,
    ...);

int 
_cdecl 
MqDisplayWarning(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...);

void
LogMessage(
    IN const TCHAR * szMessage
    );

void
DebugLogMsg(
    IN LPCTSTR psz
    );


//
// Property pages routines
//
inline
int
SkipWizardPage(
    IN const HWND hdlg
    )
{
    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
    return 1; //Must return 1 for the page to be skipped
}

INT_PTR
CALLBACK
MsmqTypeDlgProcWks(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
MsmqTypeDlgProcSrv(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
MsmqServerNameDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
WelcomeDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
FinalDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
MsmqSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

//
// Utilities and misc
//
DWORD
SetDirectories(
    VOID
    );

BOOL
StpCreateDirectory(
    IN const TCHAR * lpPathName
    );

BOOL
StpCreateWebDirectory(
    IN const TCHAR * lpPathName
    );

BOOL
IsDirectory(
    IN const TCHAR * szFilename
    );

HRESULT
StpLoadDll(
    IN  const LPCTSTR   szDllName,
    OUT       HINSTANCE *pDllHandle
    );

BOOL 
SetRegistryValue (
    IN const HKEY    hKey, 
    IN const TCHAR   *pszEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData
    );

BOOL
MqOcmInstallPerfCounters();

BOOL
MqOcmRemovePerfCounters();

HRESULT 
CreateMappingFile();

// Five minute timeout for process termination
#define PROCESS_DEFAULT_TIMEOUT  ((DWORD)INFINITE)
BOOL
RunProcess(
    IN  const LPTSTR szCommandLine,
    OUT       DWORD  *pdwExitCode   = NULL,
    IN  const DWORD  dwTimeOut      = PROCESS_DEFAULT_TIMEOUT,
    IN  const DWORD  dwCreateFlag   = DETACHED_PROCESS,
    IN  const BOOL   fPumpMessages  = FALSE
    );

void
SetRegsvrCommand(
    IN BOOL bRegister,
    IN BOOL b32BitOnWin64,
    IN LPCTSTR pszServer,
    IN LPTSTR pszBuff,
    IN DWORD cchBuff
    );

VOID 
ReadINIKey(
    LPCWSTR szKey, 
    DWORD  dwNumChars, 
    LPWSTR szKeyValue
    );

inline
void
TickProgressBar(
    IN const UINT uProgressTextID = 0
    )
{
    if (uProgressTextID != 0)
    {
        CResString szProgressText(uProgressTextID);
        g_ComponentMsmq.HelperRoutines.SetProgressText(
            g_ComponentMsmq.HelperRoutines.OcManagerContext,
            szProgressText.Get()
            ) ;
    }
    else
    {
        g_ComponentMsmq.HelperRoutines.TickGauge(g_ComponentMsmq.HelperRoutines.OcManagerContext) ;
    }
};

void
DeleteFilesFromDirectoryAndRd(
    LPCWSTR szDirectory
    );

void
GetGroupPath(
    IN const LPCTSTR szGroupName,
    OUT      LPTSTR  szPath
    );

VOID
DeleteStartMenuGroup(
    IN LPCTSTR szGroupName
    );

BOOL
StoreMachineSecurity(
    IN const GUID &guidMachine
    );

bool
StoreDefaultMachineSecurity();

BOOL
Msmq1InstalledOnCluster();

bool
IsWorkgroup();

bool
MqInit();

bool
IsLocalSystemCluster(
    VOID
    );

bool
LoadMsmqCommonDlls(
    VOID
    );

VOID
FreeMsmqCommonDlls(
    VOID
    );

//
// Function to handle subcomponents
//
BOOL 
RegisterSubcomponentForWelcome (
    DWORD SubcomponentIndex
    );

BOOL 
UnregisterSubcomponentForWelcome (
    DWORD SubcomponentIndex
    );

DWORD
GetSubcomponentWelcomeState (
    IN const TCHAR    *SubcomponentId
    );

BOOL
FinishToRemoveSubcomponent (
    DWORD SubcomponentIndex
    );

BOOL
FinishToInstallSubcomponent (
    DWORD SubcomponentIndex
    );

DWORD 
GetSubcomponentInitialState(
    IN const TCHAR    *SubcomponentId
    );

DWORD 
GetSubcomponentFinalState (
    IN const TCHAR    *SubcomponentId
    );

void
SetOperationForSubcomponents ();

DWORD 
GetSetupOperationBySubcomponentName (
    IN const TCHAR    *SubcomponentId
    );

void
VerifySubcomponentDependency();


#ifdef DEBUG
#ifdef _WIN64
void __cdecl DbgPrintf(const char* format, ...);
#define DBG_PRINT(x) DbgPrintf x
#else //!_WIN64
#define DBG_PRINT(x)
#endif //_WIN64
#else //!DEBUG
#define DBG_PRINT(x)
#endif //DEBUG

#endif  //#ifndef _MSMQOCM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\qm2qm_c_.c ===
#pragma warning(push, 3)
#include <qm2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmsrv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmsrv.cpp

Abstract:

    Code for ocm setup of server.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmsrv.tmh"

//+--------------------------------------------------------------
//
// Function: CreateMSMQServiceObject
//
// Synopsis: Creates MSMQ Service object in the DS (if not exists)
//
//+--------------------------------------------------------------
BOOL
CreateMSMQServiceObject(
	UINT uLongLive /* = MSMQ_DEFAULT_LONG_LIVE */
	)
{
	//
	// Lookup the object in the DS
	//
	GUID guidMSMQService;
	if (!GetMSMQServiceGUID(&guidMSMQService))
	    return FALSE; // Failed to lookup


    if (GUID_NULL == guidMSMQService)
	{
		//
		// MSMQ Service object does not exist. Create a new one.
		//
		PROPID      propIDs[] = {PROPID_E_LONG_LIVE};
		const DWORD nProps = sizeof(propIDs) / sizeof(propIDs[0]);
		PROPVARIANT propVariants[nProps] ;
		DWORD       iProperty = 0 ;

		propVariants[iProperty].vt = VT_UI4;
		propVariants[iProperty].ulVal = uLongLive ;
		iProperty++ ;

		ASSERT( iProperty == nProps);
		HRESULT hResult;
        do
        {
            hResult = ADCreateObject(
                        eENTERPRISE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        NULL,
                        NULL,
                        nProps,
                        propIDs,
                        propVariants,
                        NULL
                        );
            if(SUCCEEDED(hResult))
                break;

        }while (MqDisplayErrorWithRetry(
                            IDS_OBJECTCREATE_ERROR,
                            hResult
                            ) == IDRETRY);

		if (FAILED(hResult))
		{
			return FALSE;
		}
	}

    return TRUE;

} //CreateMSMQServiceObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\process.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    Handle creation of processes.

Author:


Revision History:

	Shai Kariv    (ShaiK)   15-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "process.tmh"

//+-------------------------------------------------------------------------
//
//  Function:  WaitInMessageLoop
//
//  Synopsis:  
//
//+-------------------------------------------------------------------------
BOOL  
WaitInMessageLoop( HANDLE hProc )
{
    for (;;)
    {
        HANDLE h = hProc ;

        DWORD result = MsgWaitForMultipleObjects( 1,
                                                  &h,
                                                  FALSE,
                                                  INFINITE,
                                                  QS_ALLINPUT ) ;
        if (result == WAIT_OBJECT_0)
        {
            //
            // Our process terminated.
            //
            return TRUE ;
        }
        else if (result == (WAIT_OBJECT_0 + 1))
        {
            // Read all of the messages in this next loop,
            // removing each message as we read it.
            //
            MSG msg ;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT)
                {
                    // If it's a quit message, we're out of here.
                    return FALSE ;
                }
                else
                {
                   // Otherwise, dispatch the message.
                   DispatchMessage(&msg);
                }
            }
        }
        else
        {
           return FALSE ;
        }
    }
} //WaitInMessageLoop


//+-------------------------------------------------------------------------
//
//  Function:  RunProcess
//
//  Synopsis:  Creates and starts a process
//
//+-------------------------------------------------------------------------
BOOL
RunProcess(
	IN  const LPTSTR szCommandLine,
    OUT       DWORD  *pdwExitCode  /* = NULL*/,
	IN  const DWORD  dwTimeOut     /* = PROCESS_DEFAULT_TIMEOUT*/,
    IN  const DWORD  dwCreateFlag  /* = DETACHED_PROCESS*/,
    IN  const BOOL   fPumpMessages /* = FALSE*/)
{
    if (fPumpMessages && (dwTimeOut != INFINITE))
    {
       //
       // unsupported combination.
       //
       return FALSE ;
    }

    //
    // Initialize the process and startup structures
    //
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_MINIMIZE ;

    //
    // Create the process
    //
    BOOL bProcessSucceeded = FALSE;
    BOOL bProcessCompleted = TRUE ;

    if (!CreateProcess( NULL,
                        szCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        dwCreateFlag,
                        NULL,
                        NULL,
                        &infoStartup,
                        &infoProcess ))
    {
        MqDisplayError(NULL, IDS_PROCESSCREATE_ERROR, GetLastError(), szCommandLine);
        return FALSE;
    }

    //
    // Wait for the process to terminate within the timeout period
    //
    if (fPumpMessages)
    {
       bProcessCompleted =  WaitInMessageLoop( infoProcess.hProcess ) ;
    }
    else if
     (WaitForSingleObject(infoProcess.hProcess, dwTimeOut) != WAIT_OBJECT_0)
    {
       bProcessCompleted =  FALSE ;
    }

    if (!bProcessCompleted)
    {
        MqDisplayError(
			NULL, 
			IDS_PROCESSCOMPLETE_ERROR,
			0,
            dwTimeOut/60000, 
			szCommandLine);
    }
    else
    {
       //
       // Obtain the termination status of the process
       //
       if ((pdwExitCode != NULL) &&
            !GetExitCodeProcess(infoProcess.hProcess, pdwExitCode))
       {
           MqDisplayError(NULL, IDS_PROCESSEXITCODE_ERROR, GetLastError(), szCommandLine);
       }

       //
       // No error occurred
       //
       else
       {
           bProcessSucceeded = TRUE;
       }
    }

    //
    // Close the thread and process handles
    //
    CloseHandle(infoProcess.hThread);
    CloseHandle(infoProcess.hProcess);

    return bProcessSucceeded;

} //RunProcess


//+-------------------------------------------------------------------------
//
//  Function:  SetRegsvrCommand
//
//  Synopsis:  Creates a regsvr command (different for win32 on win64)
//
//+-------------------------------------------------------------------------
void
SetRegsvrCommand(
    BOOL bRegister,
    BOOL b32BitOnWin64,
    LPCTSTR pszServer,
    LPTSTR pszBuff,
    DWORD cchBuff
	)
{
    TCHAR szPrefixDir[MAX_PATH+100];
    szPrefixDir[0] = TEXT('\0');

    if (b32BitOnWin64)
    {
      //
      // for 32 bit on win64 set szPrefixDir to syswow64 dir
      //
      HRESULT hr = SHGetFolderPath(NULL, CSIDL_SYSTEMX86, NULL, 0, szPrefixDir);
      UNREFERENCED_PARAMETER(hr);
      ASSERT(SUCCEEDED(hr));
      PathAddBackslash(szPrefixDir);
    }
    //
    // prepare the command, leave room for NULL terminator
    //
    ASSERT(cchBuff > 0);
    if (bRegister)
    {
      _sntprintf(pszBuff, cchBuff-1, SERVER_INSTALL_COMMAND, szPrefixDir, szPrefixDir, pszServer);
    }
    else
    {
      _sntprintf(pszBuff, cchBuff-1, SERVER_UNINSTALL_COMMAND, szPrefixDir, szPrefixDir, pszServer);
    }
    //
    // always set NULL terminator
    //
    pszBuff[cchBuff-1] = TEXT('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmremov.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmremov.cpp

Abstract:

    Code to remove a Falcon installation

Author:

    Doron Juster  (DoronJ)  02-Aug-97   

Revision History:

    Shai Kariv    (ShaiK)   22-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmremov.tmh"

struct
{
    TCHAR * szRegistryKey;
    TCHAR cStoragePrefix;
    TCHAR szDirectory[MAX_PATH];
}
s_descStorageTypes[] = {
    {MSMQ_STORE_RELIABLE_PATH_REGNAME, 'R'},
    {MSMQ_STORE_PERSISTENT_PATH_REGNAME, 'P'},
    {MSMQ_STORE_JOURNAL_PATH_REGNAME, 'J'},
    {MSMQ_STORE_LOG_PATH_REGNAME, 'L'},
};

const UINT s_uNumTypes = sizeof(s_descStorageTypes) / sizeof(s_descStorageTypes[0]);


//+-------------------------------------------------------------------------
//
//  Function: GetGroupPath
//
//  Synopsis: Gets the start menu Programs item path
//
//--------------------------------------------------------------------------
void 
GetGroupPath(
    IN const LPCTSTR szGroupName, 
    OUT      LPTSTR  szPath
    )
{    
    DebugLogMsg(L"Geting the start menu Programs item path.");

    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;

    SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms);

    SHGetPathFromIDList(pidlPrograms, szPath);
    
    DebugLogMsg(L"The group path is:");
    DebugLogMsg(szPath);

    nLen = lstrlen(szPath);
    if (szGroupName)
    {
        if (szPath[nLen-1] != _T('\\'))
        {
           lstrcat(szPath, _T("\\"));
        }
        lstrcat(szPath, szGroupName);
    }
    
    DebugLogMsg(L"The full path is:");
    DebugLogMsg(szPath);

} // GetGroupPath


//+-------------------------------------------------------------------------
//
//  Function: DeleteStartMenuGroup
//
//  Synopsis: Removes MSMQ 1.0 shortcuts from start menu
//
//--------------------------------------------------------------------------
VOID
DeleteStartMenuGroup(
    IN LPCTSTR szGroupName
    )
{    
    DebugLogMsg(L"About to delete StartMenuGroup");
    DebugLogMsg(L"szGroupName:");
    DebugLogMsg(szGroupName);

    TCHAR szPath[MAX_PATH] = {_T("")};
    GetGroupPath(szGroupName, szPath);

    DeleteFilesFromDirectoryAndRd(szPath);

    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);

} // DeleteStartMenuGroup


//+-------------------------------------------------------------------------
//
//  Function: DeleteMSMQConfigurationsObject 
//
//  Synopsis: Deletes MSMQ Configurations object from the DS
//
//--------------------------------------------------------------------------
static 
BOOL 
DeleteMSMQConfigurationsObject()
{
    DWORD dwWorkgroup = 0;
    if (MqReadRegistryValue(
            MSMQ_WORKGROUP_REGNAME,
            sizeof(dwWorkgroup),
            (PVOID) &dwWorkgroup
            ))
    {
        if (1 == dwWorkgroup)
            return TRUE;
    }

    BOOL bDeleted = FALSE;

    //
    // Load and initialize the DS library
    //
    if (!LoadDSLibrary())
        return (!g_fMSMQAlreadyInstalled); // It's OK if not installed

    //
    // Obtain the GUID of this QM from the DS
    //
    TickProgressBar();
    PROPID propID = PROPID_QM_MACHINE_ID;
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_wcsMachineName,
                    1, 
                    &propID, 
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MACHINEREMOTEGETID_ERROR,
                        hResult
                        ) == IDRETRY);

    if (SUCCEEDED(hResult))
    { 
        //
        // Delete the MSMQ Configuration object from the DS
        //
        TickProgressBar();
        for (;;)
        {
            hResult = ADDeleteObjectGuid(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							propVariant.puuid
							);

            if (FAILED(hResult))
            {
                UINT uErrorId = g_fServerSetup ? IDS_SERVER_MACHINEDELETE_ERROR : IDS_MACHINEDELETE_ERROR;
                if (MQDS_E_MSMQ_CONTAINER_NOT_EMPTY == hResult)
                {
                    //
                    // The MSMQ Configuration object container is not empty.
                    //
                    uErrorId = g_fServerSetup ? IDS_SERVER_MACHINEDELETE_NOTEMPTY_ERROR : IDS_MACHINEDELETE_NOTEMPTY_ERROR;
                }
                if (IDRETRY == MqDisplayErrorWithRetry(uErrorId, hResult))
                    continue;
            }
            break;
        }

        
        if (SUCCEEDED(hResult))
        {
            bDeleted = TRUE;
        }
    }

    //
    // Free the DS library
    //
    if (g_fServerSetup && g_dwMachineTypeDs)
        MQDSSrvLibrary(FREE);
    else
        MQDSCliLibrary(FREE);


    return bDeleted;

} //DeleteMSMQConfigurationsObject


//+-------------------------------------------------------------------------
//
//  Function: DeleteFilesFromDirectoryAndRd 
//
//  Synopsis: Deletes all the files from the specified directory. Remove the directory
//            if it is empty and not in use (RemoveDirectory function called at the end)
//
//--------------------------------------------------------------------------
void 
DeleteFilesFromDirectoryAndRd( 
    LPCWSTR szDirectory
    )
{    
    DebugLogMsg(L"Removing files in folder:");
    DebugLogMsg(szDirectory);

    WIN32_FIND_DATA FoundFileData;

    WCHAR  strCurrentPath[MAX_PATH];
    swprintf ( strCurrentPath, L"%s\\*", szDirectory);
    HANDLE hFindFile = FindFirstFile(strCurrentPath, &FoundFileData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        RemoveDirectory(szDirectory);
        return;
    }

    do
    {
        if (FoundFileData.cFileName[0] == '.')
            continue;
        //
        // Make the file read /write
        //
        if (FoundFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
        {
            SetFileAttributes( 
                FoundFileData.cFileName,
                FILE_ATTRIBUTE_NORMAL
                );
        }
        WCHAR  strCurrentFile[MAX_PATH];
        swprintf ( strCurrentFile, L"%s\\%s",szDirectory,FoundFileData.cFileName);
 
        //
        //directory:
        //
        if (FoundFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {                                                  
            DeleteFilesFromDirectoryAndRd(strCurrentFile);
        }
        //
        //file:
        //
        else
        {
           if(!DeleteFile(strCurrentFile))
           {
                DebugLogMsg(L"DeleteFile failed for:");
                DebugLogMsg(strCurrentFile);
           }

        }
    }
    while (FindNextFile(hFindFile, &FoundFileData));

    FindClose(hFindFile);
    RemoveDirectory(szDirectory);

} 


//+-------------------------------------------------------------------------
//
//  Function: MqSetupDeleteStorageFiles 
//
//  Synopsis:  
//
//--------------------------------------------------------------------------
static 
BOOL 
MqSetupDeleteStorageFiles(VOID)
{
//    TCHAR szFirstFileTemplate[MAX_PATH] = {_T("")};

    //
    // Initialize path of storage folders (read from registry).
    //
    for (UINT uType = 0; uType < s_uNumTypes ; uType++ )
    {
        s_descStorageTypes[uType].szDirectory[0] = TEXT('\0') ;
        //
        // Otain the directory associated with the storage type
        // Note: Errors are ignored - we simply proceed to the next directory
        //
        MqReadRegistryValue( 
            s_descStorageTypes[uType].szRegistryKey,
            sizeof(s_descStorageTypes[0].szDirectory),
            s_descStorageTypes[uType].szDirectory);
    }

    //
    // Remove all the storage files associated with each registry value
    //

    for ( uType = 0 ; uType < s_uNumTypes ; uType++ )
    {
        //
        // Obtain the directory associated with the storage type
        //
        if (s_descStorageTypes[uType].szDirectory[0] == TEXT('\0'))
        {
            continue;
        }

        //
        // Delete all the files in the directory 
        //
        DeleteFilesFromDirectoryAndRd(
            s_descStorageTypes[uType ].szDirectory
            );                           
    }

    return TRUE;

} //MqSetupDeleteStorageFiles


//+-------------------------------------------------------------------------
//
//  Function: RemoveInstallationInternal 
//
//  Synopsis: (Note: We ignore errors)  
//
//--------------------------------------------------------------------------
static 
BOOL  
RemoveInstallationInternal()
{
    //
    // Delete MSMQ 1.0 shortcuts from Start menu, if exist
    //
    TCHAR szGroup[MAX_PATH] ;
    lstrcpy( szGroup, MSMQ_ACME_SHORTCUT_GROUP );
    MqReadRegistryValue(
        OCM_REG_MSMQ_SHORTCUT_DIR,
        sizeof(szGroup),
        (PVOID) szGroup
        );
    
    DeleteStartMenuGroup(szGroup) ;

    //
    // Remove the performance counters.
    //
    BOOL fSuccess =  MqOcmRemovePerfCounters() ;
    ASSERT(fSuccess) ;

    //
    // Unregister the ActiveX object.
    //
    RegisterActiveX(FALSE) ;


    //
    // Unregister the mqsnapin DLL
    //
    RegisterSnapin(/* fRegister = */FALSE);

    //
    // Remove MSMQ replication service (if exists)
    //
    TickProgressBar();
    if (!StopService(MQ1SYNC_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing replication service could not be stopped.");
        ASSERT(("Failed to stop replication service", 0));
    }

    if (!RemoveService(MQ1SYNC_SERVICE_NAME))
    {
        DebugLogMsg(L"The Message Queuing replication service could not be deleted.");        
        ASSERT(("Failed to delete replication service", 0));
    }

    //
    // Remove msmq and mqds services and driver
    //
    TickProgressBar();
    
    RemoveServices();
    
    RemoveDeviceDrivers() ;
    
    //
    // Remove files (storage and others)
    //
    TickProgressBar();
    MqSetupDeleteStorageFiles();

    TickProgressBar();
    if (g_fServerSetup && g_dwMachineTypeDs)
    {
        //
        // Remove MSMQ DS server
        //
        fSuccess = DeleteMSMQConfigurationsObject();
    }
    else if (!g_fDependentClient)
    {
        //
        // Remove MSMQ independent client
        //
        fSuccess = DeleteMSMQConfigurationsObject() ;
    }
    else
    {
        //
        // Dependent client. Nothing to do.
        //
    }  

    return TRUE ;

} //RemoveInstallationInternal



//+-------------------------------------------------------------------------
//
//  Function: MqOcmRemoveInstallation 
//
//  Note:     We ignore errors
//
//--------------------------------------------------------------------------
BOOL  
MqOcmRemoveInstallation(IN     const TCHAR  * SubcomponentId)
{    
    if (SubcomponentId == NULL)
    {
        return NO_ERROR;
    }    

    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }                  

        //
        // verify if we need to remove this subcomponent
        //
        if (g_SubcomponentMsmq[i].dwOperation != REMOVE)
        {
            //
            // do nothing: this component was not selected for removing
            //
            return NO_ERROR;
        }
        
        //
        // We found this subcomponent in the array
        //
        if (g_SubcomponentMsmq[i].pfnRemove == NULL)
        {           
            ASSERT(("There is no specific removing function", 0));
            return NO_ERROR ; 
        }

        //
        // only in this case we have to remove it
        //               
        
        //
        // BUGBUG: we have to check that MSMQ Core must be removed 
        // the last!
        //      
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"The %s subcomponent was removed.", SubcomponentId);        
        DebugLogMsg(wszMsg);           

        BOOL fRes = g_SubcomponentMsmq[i].pfnRemove();
        
        //
        // remove registry in any case
        //
        FinishToRemoveSubcomponent (i); 
        if (fRes)
        {
            //
            // subcomponent was removed successfully
            //                                     
        }
        else
        {
            //
            // if removing failed we have to remove registry anyway
            // since we can't leave half-removed component as
            // "installed" (if there is registry entry we assume that
            // subcomponent is installed)
            //
            WCHAR wszMsg[1000];
            wsprintf(wszMsg, L"The %s subcomponent could not be removed.", SubcomponentId);
            DebugLogMsg(wszMsg);          
        }              
        return NO_ERROR;
    }    
        

    ASSERT (("Subcomponent for removing is not found", 0));
    return NO_ERROR; //BUGBUG: what to return
}

BOOL RemoveMSMQCore()
{
    static BOOL fAlreadyRemoved = FALSE ;

    if (fAlreadyRemoved)
    {
        //
        // We're called more than once.
        //
        return NO_ERROR ;
    }
    fAlreadyRemoved = TRUE ;
    
    DebugLogMsg(L"Removing Message Queuing...");
    TickProgressBar(IDS_PROGRESS_REMOVE);		

    BOOL fRes =  RemoveInstallationInternal() ;

    //
    // Cleanup registry. Registry is needed when deleting storage files
    // so do it only after files were deleted.
    //
    RegDeleteKey(FALCON_REG_POS, MSMQ_REG_SETUP_KEY);
    RegDeleteKeyWithSubkeys(FALCON_REG_POS, FALCON_REG_KEY);
    RegDeleteKey(FALCON_REG_POS, FALCON_REG_MSMQ_KEY) ;

    LPCTSTR x_RUN_KEY = _T("software\\microsoft\\windows\\currentVersion\\Run\\");
    CAutoCloseRegHandle hKey;
    if (ERROR_SUCCESS == RegOpenKeyEx(FALCON_REG_POS, x_RUN_KEY, 0, KEY_ALL_ACCESS, &hKey))
    {
        RegDeleteValue(hKey, RUN_INT_CERT_REGNAME);
    }    

    UnregisterWelcome();

    DeleteFilesFromDirectoryAndRd(g_szMsmqDir);

    return fRes ;

} //RemoveMSMQCore()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ostype.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ostype.cpp

Abstract:

    Code to detect type of Operating System.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>

#include "ostype.tmh"

DWORD g_dwOS = MSMQ_OS_NONE;


//+-------------------------------------------------------------------------
//
//  Function:  IsNTE
//
//  Synopsis:  Tells if the OS is NT Enterprise Server
//
//+-------------------------------------------------------------------------
BOOL 
IsNTE()
{
    HKEY  hKey ;
	static BOOL  fIsNTE = FALSE;
	static BOOL  fBeenHereAlready = FALSE;

	if (fBeenHereAlready)
		return fIsNTE;

	fBeenHereAlready = TRUE;

    LONG lResult = RegOpenKeyEx( 
		HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        0L,
        KEY_READ,
        &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        BYTE  ch ;
        DWORD dwSize = sizeof(BYTE) ;
        DWORD dwType = REG_MULTI_SZ ;
        lResult = RegQueryValueEx( 
			hKey,
            TEXT("ProductSuite"),
            NULL,
            &dwType,
            (BYTE*)&ch,
            &dwSize) ;

        if (ERROR_MORE_DATA == lResult)
		{ 
			TCHAR *pBuf = new TCHAR[ dwSize + 2 ] ;
            lResult = RegQueryValueEx( 
				hKey,
                TEXT("ProductSuite"),
                NULL,
                &dwType,
                (BYTE*) &pBuf[0],
                &dwSize) ;

            if (ERROR_SUCCESS == lResult)
			{
                //
                // Look for the string "Enterprise".
                // The REG_MULTI_SZ set of strings terminate with two
                // nulls. This condition is checked in the "while".
                //
                TCHAR *pVal = pBuf ;
                while(*pVal)
                {
                    if (OcmStringsEqual(TEXT("Enterprise"), pVal))
                    {
                        fIsNTE = TRUE;
                        break;
                    }
                    pVal = pVal + lstrlen(pVal) + 1 ;
                }
				delete [] pBuf;
            }
		}					  
	}
	    
    RegCloseKey(hKey);

	return fIsNTE;
                  
} //IsNTE


//+-------------------------------------------------------------------------
//
//  Function:  InitializeOSVersion
//
//  Synopsis:  Gets OS information
//
//+-------------------------------------------------------------------------
BOOL 
InitializeOSVersion()
{
    OSVERSIONINFO infoOS;
    infoOS.dwOSVersionInfoSize = sizeof(infoOS);
    GetVersionEx(&infoOS);

    ASSERT(("OS must be Windows NT", 
            infoOS.dwPlatformId == VER_PLATFORM_WIN32_NT  && infoOS.dwMajorVersion >= 5));    

    DebugLogMsg(L"Initializing OS Version.");
    TCHAR sz[100];
    _stprintf(sz, _T("%s=0x%x"), _T("ProductType"), g_ComponentMsmq.dwProductType);
    DebugLogMsg(sz);    
    
    switch (g_ComponentMsmq.dwProductType)
    {
        case PRODUCT_WORKSTATION: 
            g_dwOS = MSMQ_OS_NTW;
            break;
            
        case PRODUCT_SERVER_SECONDARY: 
        case PRODUCT_SERVER_PRIMARY:  
            //
            // For fresh install g_dwMachineTypeDs should be set according to
            // subcomponent selection and not according to product type
            //
            //
            // Fall through
            //
        case PRODUCT_SERVER_STANDALONE:
            g_dwOS = MSMQ_OS_NTS;
            g_dwMachineTypeDepSrv = 1;
            break;
            
        default:          
            ASSERT(0); 
            return FALSE;
            break;
    }
    
	//
	// In case of NT Server, check if it's an Enterprise Server
	//
	if (MSMQ_OS_NTS == g_dwOS)
	{
		g_dwOS = IsNTE() ? MSMQ_OS_NTE : MSMQ_OS_NTS;
	}    

    return TRUE ;

} //InitializeOSVersion

#ifdef DEBUG
#ifdef _WIN64
void __cdecl DbgPrintf(const char* format, ...)
{
    char buffer[1024];

    va_list va;
    va_start(va, format);
    int x = _vsnprintf(buffer, sizeof(buffer) - 1, format, va);
    buffer[sizeof(buffer) - 1] = '\0';
    va_end(va);
    OutputDebugStringA(buffer);
}
#endif //_WIN64
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmutil.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmutil.cpp

Abstract:

    utility code for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <clusapi.h>
#include <mqexception.h>

#include "ocmutil.tmh"

TCHAR g_szSystemDir[MAX_PATH] = {_T("")};   // system32 directory
TCHAR g_szMsmqDir[MAX_PATH] = {TEXT("")} ;  // Root directory for MSMQ
TCHAR g_szMsmqStoreDir[MAX_PATH];
TCHAR g_szMsmq1SetupDir[MAX_PATH];
TCHAR g_szMsmq1SdkDebugDir[MAX_PATH];
TCHAR g_szMsmqWebDir[MAX_PATH];
TCHAR g_szMsmqMappingDir[MAX_PATH];


//+-------------------------------------------------------------------------
//
//  Function:   StpLoadDll
//
//  Synopsis:   Handle library load.
//
//--------------------------------------------------------------------------
HRESULT
StpLoadDll(
    IN  const LPCTSTR   szDllName,
    OUT       HINSTANCE *pDllHandle)
{
    HINSTANCE hDLL = LoadLibrary(szDllName);
    *pDllHandle = hDLL;
    if (hDLL == NULL)
    {
        MqDisplayError(NULL, IDS_DLLLOAD_ERROR, GetLastError(), szDllName);
        return MQ_ERROR;
    }
    else
    {
        return MQ_OK;
    }
} //StpLoadDll


static bool GetUserSid(LPWSTR UserName, PSID* ppSid)
/*++
Routine Description:
	Get sid corresponding to user name.

Arguments:
	UserName - user name	
	ppSid - pointer to PSID

Returned Value:
	true if success, false otherwise	

--*/
{
	*ppSid = NULL;

    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE su;

	//
	// Get buffer size.
	//
    BOOL fSuccess = LookupAccountName( 
						NULL,
						UserName,
						NULL,
						&dwSidSize,
						NULL,
						&dwDomainSize,
						&su 
						);

    if (fSuccess || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
		DWORD gle = GetLastError();
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"GetUserSid(): LookupAccountName Failed to get sid for user = %ls, gle = 0x%x", UserName, gle);
        DebugLogMsg(wszMsg);                                
        return false;
    }

	//
	// Get sid and domain information.
	//
    AP<BYTE> pSid = new BYTE[dwSidSize];
    AP<WCHAR> szRefDomain = new WCHAR[dwDomainSize];

    fSuccess = LookupAccountName( 
					NULL,
					UserName,
					pSid,
					&dwSidSize,
					szRefDomain,
					&dwDomainSize,
					&su 
					);

    if (!fSuccess)
    {
		DWORD gle = GetLastError();
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"GetUserSid(): LookupAccountName Failed to get sid for user = %ls, gle = 0x%x", UserName, gle);
        DebugLogMsg(wszMsg);                                
        return false;
    }

    ASSERT(su == SidTypeUser);

	*ppSid = pSid.detach();

	return true;
}


static bool GetIusrMachineSid(PSID* ppIusrMachineSid)
/*++
Routine Description:
	Get IUSR_MACHINE sid

Arguments:
	ppIusrMachineSid - pointer to IUSR_MACHINE SID

Returned Value:
	true if success, false otherwise	

--*/
{
	//
	// Get computer name (netbios)
	//
	WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD ComputerNameLen = MAX_COMPUTERNAME_LENGTH;
	BOOL fSuccess = GetComputerName(ComputerName , &ComputerNameLen);
	if(!fSuccess)
	{
		DWORD gle = GetLastError();
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"GetIusrMachineSid(): GetComputerName Failed, gle = 0x%x", gle);
        DebugLogMsg(wszMsg);                                
		return false;
	}

	//
	// Get IUSR_MACHINE string
	//
	AP<WCHAR> IusrMachineName = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1 + wcslen(L"IUSR_")];
    swprintf(
         IusrMachineName,
         L"%s%s",
         L"IUSR_",
         ComputerName
         );

	//
	// Get IUSR_MACHINE sid
	//
	return GetUserSid(IusrMachineName, ppIusrMachineSid);
}


static bool GetLocalAdminSid(PSID* ppAdminSid)
/*++
Routine Description:
	Get Local Admin sid

Arguments:
	ppAdminSid - pointer to Admin Sid

Returned Value:
	true if success, false otherwise	

--*/
{
    //
    // Get the SID of the local administrators group.
    //
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                ppAdminSid
                ))
    {
        return false;
    }
	return true;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetDirectorySecurity
//
//  Synopsis:   Configure security on the folder such that any file will have
//              full control for the local admin group and no access for others.
//
//--------------------------------------------------------------------------
VOID
SetDirectorySecurity(
	LPCTSTR pFolder,
	bool fWebDirPermission
    )
{

	AP<BYTE> pIusrMachineSid;
	if(fWebDirPermission)
	{
		//
		// Ignore errors, only write tracing to msmqinst
		//
		if(!GetIusrMachineSid(reinterpret_cast<PSID*>(&pIusrMachineSid)))
		{
			WCHAR wszMsg[1000];
			wsprintf(wszMsg, L"Failed to get IUSR_MACHINE sid, this means internet guest account permission will not be set on msmq web direcory %ls, as a result https messages to this machines will failed till IUSR_MACHINE permissions will be added to msmq web dir", pFolder);
			DebugLogMsg(wszMsg);                                
		}
	}

    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
	if(!GetLocalAdminSid(&pAdminSid))
    {
        return;
    }

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    DWORD dwDaclSize = sizeof(ACL) +
					  (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
					  GetLengthSid(pAdminSid);

	if(pIusrMachineSid != NULL)
	{
		dwDaclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
					  GetLengthSid(pIusrMachineSid);

	}

	P<ACL> pDacl = (PACL)(char*) new BYTE[dwDaclSize];

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAceEx(pDacl, ACL_REVISION, OBJECT_INHERIT_ACE, FILE_ALL_ACCESS, pAdminSid) ||
		//
		// if pIusrMachineSid we will Add AllowAce with FILE_GENERIC_WRITE permissions for IUSR_MACHINE
		//
		((pIusrMachineSid != NULL) && !AddAccessAllowedAceEx(pDacl, ACL_REVISION, OBJECT_INHERIT_ACE, FILE_GENERIC_WRITE, pIusrMachineSid)) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(pFolder, DACL_SECURITY_INFORMATION, &SD))
    {
		DWORD gle = GetLastError();
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"SetDirectorySecurity(): Failed to set security descriptor for folder = %ls, gle = 0x%x", pFolder, gle);
        DebugLogMsg(wszMsg);                                
        FreeSid(pAdminSid);
        return;
    }

    WCHAR wszMsg[1000];
    wsprintf(wszMsg, L"succesfully set security descriptor for folder = %ls", pFolder);
    DebugLogMsg(wszMsg);                                

    FreeSid(pAdminSid);

} //SetDirectorySecurity


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateDirectoryInternal
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
static
BOOL
StpCreateDirectoryInternal(
    IN const TCHAR * lpPathName,
	IN bool fWebDirPermission
    )
{
    if (!CreateDirectory(lpPathName, 0))
    {
        DWORD dwError = GetLastError();
        if (dwError != ERROR_ALREADY_EXISTS)
        {
            WCHAR wszMsg[1000];
            wsprintf(wszMsg, L"Failed to create %ls directory, gle = 0x%x", lpPathName, dwError);
            DebugLogMsg(wszMsg);                                
            MqDisplayError(NULL, IDS_COULD_NOT_CREATE_DIRECTORY, dwError, lpPathName);
            return FALSE;
        }
    }

    SetDirectorySecurity(lpPathName, fWebDirPermission);

    return TRUE;

} //StpCreateDirectoryInternal


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateDirectory
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
BOOL
StpCreateDirectory(
    IN const TCHAR * lpPathName
    )
{
	return StpCreateDirectoryInternal(
				lpPathName, 
				false	// fWebDirPermission
				);
} //StpCreateDirectory


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateWebDirectory
//
//  Synopsis:   Handle web directory creation.
//
//--------------------------------------------------------------------------
BOOL
StpCreateWebDirectory(
    IN const TCHAR * lpPathName
    )
{
	return StpCreateDirectoryInternal(
				lpPathName, 
				true	// fWebDirPermission
				);
} //StpCreateWebDirectory


static
void 
UpdateWebDirectorySecurity()
/*++

Routine Description:
    This function is called on upgrade,
	MSMQ Web directory security will be reset if http subcomponent is already installed 
	and the upgrade is from build earlier than 1007.
	in this case we need to reset Web Directory security in order not to break https upon upgrade.
	  
	NOTE: This function assume that MSMQ_CURRENT_BUILD_REGNAME holds the previous build number.

Arguments:
    None

Return Value:
    None

--*/
{
	ASSERT(g_fUpgrade);

	//
	// Check if HTTP_SUPPORT_SUBCOMP is installed
	//
	if(GetSubcomponentInitialState(HTTP_SUPPORT_SUBCOMP) == SubcompOff)
	{
	    return;
	}

	//
	// ISSUE-2001/07/12-ilanh every upgrade of operation system change the security descriptor of
	// msmq web directory (on every directory under windows).
	// in order not to break https we need to reset msmq web directory security
	// when the OS will fixed this behaviour, we need to reset msmq web directory security only if the upgrade is from
	// msmq builds earlier than 1007.
	// The code that check if previous build < 1007 is comment out 
	//

#if 0
	//
	// Check if build number < 1007
	// ISSUE-2001/07/11-ilanh should initialize PreviousBuild number at setup startup and hold it as global
	// Note: MSMQ_CURRENT_BUILD_REGNAME is changed in InstallMsmqCore() to the new version
	// this function is called before InstallMsmqCore() so it still hold the previous build number
	//

	WCHAR szPreviousBuild[MAX_STRING_CHARS] = {0};
    DWORD dwNumBytes = sizeof(szPreviousBuild[0]) * (sizeof(szPreviousBuild) - 1);

    if (!MqReadRegistryValue(MSMQ_CURRENT_BUILD_REGNAME, dwNumBytes, szPreviousBuild))
    {
	    DebugLogMsg(L"UpdateWebDirectorySecurity(): Failed to read previous build number from registry");
		return;
    }

	DWORD PreviousBuildNumber;
	int Count = swscanf(szPreviousBuild, L"5.1.%d", &PreviousBuildNumber);
	if(Count == 0)
	{
	    DebugLogMsg(L"UpdateWebDirectorySecurity(): Failed to get Build Number");
		return;
	}

	if(PreviousBuildNumber >= 1007)
	{
		//
		// In build 1007 we start use msmq web directory security for https access check.
		// Should not reset Web directory security when upgrading from build >= 1007
		//
		return;
	}

	//
	// If we get here it means:
	// 1) HTTP_SUPPORT_SUBCOMP is installed
	// 2) Upgrade from build < 1007
	// In build 1007 we start use msmq web directory security for https access check (bug 7979)
	// In order not to break https upon upgrade from earlier builds than 1007 we need to reset Web directory security
	//
#endif

    DebugLogMsg(L"Reset Message Queuing Web directory security");

    SetDirectorySecurity(
		g_szMsmqWebDir, 
		true	 // fWebDirPermission
		);

	return;
}  // UpdateWebDirectorySecurity


//+-------------------------------------------------------------------------
//
//  Function:   IsDirectory
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
IsDirectory(
    IN const TCHAR * szFilename
    )
{
    DWORD attr = GetFileAttributes(szFilename);

    if ( 0xffffffff == attr )
    {
        return FALSE;
    }

    return ( 0 != ( attr & FILE_ATTRIBUTE_DIRECTORY ) );

} //IsDirectory


//+-------------------------------------------------------------------------
//
//  Function:   MqOcmCalcDiskSpace
//
//  Synopsis:   Calculates disk space for installing/removing MSMQ component
//
//--------------------------------------------------------------------------
DWORD
MqOcmCalcDiskSpace(
    IN     const BOOL    bInstall,
    IN     const TCHAR  * SubcomponentId,
    IN OUT       HDSKSPC &hDiskSpaceList)
{
    BOOL bSuccess;
    DWORD dwRetCode = NO_ERROR;
    const LONGLONG x_lExtraDiskSpace = FALCON_DEFAULT_LOGMGR_SIZE  + (10*1024*1024);

    if (g_fCancelled)
        return NO_ERROR;

    if (bInstall)
    {
        //
        // Add the files space
        //
        bSuccess = SetupAddInstallSectionToDiskSpaceList(
            hDiskSpaceList,
            g_ComponentMsmq.hMyInf,
            0,
            SubcomponentId,
            0,
            0);

        //
        // Add some extra disk space for MSMQ logger etc.
        // Note: the following is an undocumented Setup API.
        // I passed "X:" as the Drive Root according to TedM tip
        // (ShaiK, 21-Jan-98).
        //
        bSuccess = SetupAdjustDiskSpaceList(
            hDiskSpaceList,
            _T("X:"),
            x_lExtraDiskSpace,
            NULL,
            0
            );
    }

    else
    {
        //
        // Remove the files space
        //
        bSuccess = SetupRemoveInstallSectionFromDiskSpaceList(
            hDiskSpaceList,
            g_ComponentMsmq.hMyInf,
            0,
            SubcomponentId,
            0,
            0
            );

        //
        // Remove the extra disk space
        // Note: the following is an undocumented Setup API.
        // I passed "X:" as the Drive Root according to TedM tip
        // (ShaiK, 21-Jan-98).
        //
        bSuccess = SetupAdjustDiskSpaceList(
            hDiskSpaceList,
            _T("X:"),
            -x_lExtraDiskSpace,
            NULL,
            0
            );
    }

    dwRetCode = bSuccess ? NO_ERROR : GetLastError();

    return dwRetCode;

} // MqOcmCalcDiskSpace


//+-------------------------------------------------------------------------
//
//  Function:   MqOcmQueueFiles
//
//  Synopsis:   Performs files queueing operations
//
//--------------------------------------------------------------------------
DWORD
MqOcmQueueFiles(
   IN     const TCHAR  * SubcomponentId,
   IN OUT       HSPFILEQ hFileList
   )
{
    DWORD dwRetCode = NO_ERROR;
    BOOL  bSuccess = TRUE;  
   
    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    if (g_fWelcome)
    {
        if (Msmq1InstalledOnCluster())
        {
            //
            // Running as a cluster upgrade wizard, files are already on disk.
            //
            return NO_ERROR;
        }

        //
        // MSMQ files may have already been copied to disk
        // (when msmq is selected in GUI mode, or upgraded).
        //
        DWORD dwCopied = 0;
        MqReadRegistryValue(MSMQ_FILES_COPIED_REGNAME, sizeof(DWORD), &dwCopied, TRUE);

        if (dwCopied != 0)
        {
            return NO_ERROR;
        }
    }

    //
    // we perform file operation only for MSMQCore subcomponent
    //
    if (REMOVE == g_SubcomponentMsmq[eMSMQCore].dwOperation)
    {
        //
        // do nothing: we do not remove binaries from the computer
        //
        return NO_ERROR;        
    }

    //
    // we perform file operation only for MSMQCore subcomponent
    //
    if (INSTALL == g_SubcomponentMsmq[eMSMQCore].dwOperation)
    {
        //
        // Check if this upgrade on cluster
        //
        BOOL fUpgradeOnCluster = g_fUpgrade && Msmq1InstalledOnCluster();
        
        if (fUpgradeOnCluster)
        {            
            DebugLogMsg(L"Upgrading Message Queuing in the cluster...");
        }

        if (!fUpgradeOnCluster)
        {
            if (!StpCreateDirectory(g_szMsmqDir))
            {
                return GetLastError();
            }
            
            //
            // create mapping dir and file
            //
            HRESULT hr = CreateMappingFile();
            if (FAILED(hr))
            {
                return hr;
            }
        }        

        //
        // On upgrade, delete old MSMQ files.
        // First delete files from system directory.
        //
        if (g_fUpgrade)
        {
			//
			// Check if we need to update Web Directory security
			//
			UpdateWebDirectorySecurity();

#ifndef _WIN64
            // 
            // Before deleting MSMQ Mail files below (Msmq2Mail, Msmq2ExchConnFile), unregister them
            //
            FRemoveMQXPIfExists();            
            DebugLogMsg(L"MSMQ MAPI Transport was removed during the upgrade to Windows XP");
            UnregisterMailoaIfExists();
            DebugLogMsg(L"The MSMQ Mail COM DLL was unregistered during the upgrade to Windows XP");
            
#endif //!_WIN64
            
            bSuccess = SetupInstallFilesFromInfSection(
                g_ComponentMsmq.hMyInf,
                0,
                hFileList,
                UPG_DEL_SYSTEM_SECTION,
                NULL,
                SP_COPY_IN_USE_NEEDS_REBOOT
                );
            if (!bSuccess)
                MqDisplayError(
                NULL,
                IDS_SetupInstallFilesFromInfSection_ERROR,
                GetLastError(),
                UPG_DEL_SYSTEM_SECTION,
                TEXT("")
                );

            //
            // Secondly, delete files from MSMQ directory (forget it if we're on cluster,
            // 'cause we don't touch the shared disk)
            //
            if (!fUpgradeOnCluster)
            {
                bSuccess = SetupInstallFilesFromInfSection(
                    g_ComponentMsmq.hMyInf,
                    0,
                    hFileList,
                    UPG_DEL_PROGRAM_SECTION,
                    NULL,
                    SP_COPY_IN_USE_NEEDS_REBOOT
                    );
                if (!bSuccess)
                    MqDisplayError(
                    NULL,
                    IDS_SetupInstallFilesFromInfSection_ERROR,
                    GetLastError(),
                    UPG_DEL_PROGRAM_SECTION,
                    TEXT("")
                    );
            }
        }                
    }

    dwRetCode = bSuccess ? NO_ERROR : GetLastError();

    return dwRetCode;

} // MqOcmQueueFiles


//+-------------------------------------------------------------------------
//
//  Function:   RegisterSnapin
//
//  Synopsis:   Registers or unregisters the mqsnapin DLL
//
//--------------------------------------------------------------------------
void
RegisterSnapin(
    BOOL fRegister
    )
{    
    DebugLogMsg(L"Registering the Message Queuing snap-in...");

    for (;;)
    {
        try
        {
            RegisterDll(
                fRegister,
                FALSE,
                SNAPIN_DLL
                );
            DebugLogMsg(L"The Message Queuing snap-in was registered successfully.");
            break;
        }
        catch(bad_win32_error e)
        {
        if (MqDisplayErrorWithRetry(
                IDS_SNAPINREGISTER_ERROR,
                e.error()
                ) != IDRETRY)
            {
                break;
            }

        }
    }
} // RegisterSnapin


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterMailoaIfExists
//
//  Synopsis:   Unregisters the mqmailoa DLL if exists
//
//--------------------------------------------------------------------------
void
UnregisterMailoaIfExists(
    void
    )
{
    RegisterDll(
        FALSE,
        FALSE,
        MQMAILOA_DLL
        );
}




bool
IsWorkgroup()
/*++

Routine Description:

    Checks if this machines is joined to workgroup / domain

Arguments:

    None

Return Value:

    true iff we're in workgroup, false otherwise (domain)

--*/
{
    static bool fBeenHere = false;
    static bool fWorkgroup = true;
    if (fBeenHere)
        return fWorkgroup;
    fBeenHere = true;

    LPWSTR pBuf = NULL ;
    NETSETUP_JOIN_STATUS status;
    NET_API_STATUS rc = NetGetJoinInformation(
                            NULL,
                            &pBuf,
                            &status
                            );
    ASSERT(("NetGetJoinInformation() failed, not enough memory",NERR_Success == rc));

    if (NERR_Success != rc)
        return fWorkgroup; // Defaulted to true

    if (NetSetupDomainName == status)
    {
        fWorkgroup = false;

        DWORD dwNumBytes = (lstrlen(pBuf) + 1) * sizeof(TCHAR);
        BOOL fSuccess = MqWriteRegistryValue(
                                MSMQ_MACHINE_DOMAIN_REGNAME,
                                dwNumBytes,
                                REG_SZ,
                               (PVOID) pBuf ) ;
        UNREFERENCED_PARAMETER(fSuccess);
        ASSERT(fSuccess) ;
    }
    else
    {
        ASSERT(("unexpected machine join status", status <= NetSetupWorkgroupName));
    }

    if (pBuf)
    {
        NetApiBufferFree(pBuf);
    }

    return fWorkgroup;

}//IsWorkgroup


bool
IsLocalSystemCluster(
    VOID
    )
{
    typedef bool (*IsCluster_fn) (VOID);

    ASSERT(("invalid handle to mqutil.dll", g_hMqutil != NULL));

    IsCluster_fn pfn = (IsCluster_fn)GetProcAddress(g_hMqutil, "SetupIsLocalSystemCluster");
    if (pfn == NULL)
    {
        MqDisplayError(NULL, IDS_DLLGETADDRESS_ERROR, 0, _T("SetupIsLocalSystemCluster"), MQUTIL_DLL);

        return false;
    }

    bool fCluster = pfn();
    return fCluster;

} //IsLocalSystemCluster


VOID
APIENTRY
SysprepDeleteQmId(
    VOID
    )
/*++

Routine Description:

    This routine is called from sysprep tool before
    starting duplication of the disk. It is called 
    regardless of msmq being installed or not.

    The only thing we need to do is delete the QM 
    guid from registry (if it exists there).

    Note: do not raise UI in this routine.

Arguments:

    None.

Return Value:

    None. (sysprep ignores our return code)

--*/
{
    CAutoCloseRegHandle hParamKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(FALCON_REG_POS, FALCON_REG_KEY, 0, KEY_ALL_ACCESS, &hParamKey))
    {
        return;
    }

    DWORD dwSysprep = 1;
    if (ERROR_SUCCESS != RegSetValueEx(
                             hParamKey, 
                             MSMQ_SYSPREP_REGNAME, 
                             0, 
                             REG_DWORD, 
                             reinterpret_cast<PBYTE>(&dwSysprep), 
                             sizeof(DWORD)
                             ))
    {
        return;
    }

    TCHAR szMachineCacheKey[255] = _T("");
    _stprintf(szMachineCacheKey, _T("%s\\%s"), FALCON_REG_KEY, _T("MachineCache"));

    CAutoCloseRegHandle hMachineCacheKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(FALCON_REG_POS, szMachineCacheKey, 0, KEY_ALL_ACCESS, &hMachineCacheKey))
    {
        return;
    }

    if (ERROR_SUCCESS != RegDeleteValue(hMachineCacheKey, _T("QMId")))
    {
        return;
    }

} //SysprepDeleteQmId

HRESULT 
CreateMappingFile()
/*++

Routine Description:

    This routine creates mapping directory and sample mapping file.
    It called when files are copied or from CompleteUpgradeOnCluster routine.   
    
    It fixes bug 6116 and upgrade on cluster problem: it is impossible to copy
    this file since mapping directory does not yet exists. Now we create 
    directory and create the file from resource, so we don't need copy operation.

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = MQ_OK;
    
    if (!StpCreateDirectory(g_szMsmqMappingDir))
    {
        return GetLastError();
    }

    TCHAR szMappingFile[MAX_PATH];
    _stprintf(szMappingFile, TEXT("%s\\%s"), g_szMsmqMappingDir, MAPPING_FILE);
    
    //
    // Create the mapping file
    //
    HANDLE hMapFile = CreateFile(
                          szMappingFile, 
                          GENERIC_WRITE, 
                          FILE_SHARE_READ, 
                          NULL, 
                          CREATE_ALWAYS,    //overwrite the file if it already exists
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL
                          );
    if (hMapFile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hMapFile, 0, NULL, FILE_END);
        // use strlen since g_szMappingSample is ANSI string
        DWORD dwNumBytes = numeric_cast<DWORD>(strlen(g_szMappingSample)) * sizeof(g_szMappingSample[0]);
        WriteFile(hMapFile, g_szMappingSample, dwNumBytes, &dwNumBytes, NULL);
        CloseHandle(hMapFile);
    }
    else
    {
        hr = GetLastError();
        MqDisplayError(NULL, IDS_CREATE_MAPPING_FILE_ERROR, 
                        hr, szMappingFile);
    }

    return hr;

} // CreateMappingFile


//+-------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Synopsis:   Registers or unregisters given DLL
//
//--------------------------------------------------------------------------
void
RegisterDll(
    BOOL fRegister,
    BOOL f32BitOnWin64,
	LPCTSTR szDllName
    )
{
    //
    // Always unregister first
    //
    TCHAR szCommand[MAX_STRING_CHARS];
    SetRegsvrCommand(
        FALSE,
        f32BitOnWin64,
        szDllName,
        szCommand,
        sizeof(szCommand)/sizeof(TCHAR)
        );
    DWORD dwExitCode;
    BOOL fSuccess = RunProcess(szCommand, &dwExitCode);
    if (!fSuccess)
        ASSERT(0);
    //
    // Register the dll on install
    //
    if (!fRegister)
        return;

    SetRegsvrCommand(
        TRUE ,
        f32BitOnWin64,
        szDllName,
        szCommand,
        sizeof(szCommand)/sizeof(TCHAR)
        );
    fSuccess = RunProcess(szCommand, &dwExitCode);
    if (fSuccess && (dwExitCode == 0))
    {
        DebugLogMsg(L"The DLL was registered successfully.");
        return;
    }
    
    throw bad_win32_error(dwExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\service.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    service.h

Abstract:

    Service related definitions

Author:

	Shai Kariv    (ShaiK)   22-May-98

--*/


#ifndef _SERVICE_H
#define _SERVICE_H

//
// Service related strings
//
#define MSMQ_DRIVER_NAME        TEXT("MQAC")
#define MSMQ_DRIVER_PATH        TEXT("drivers\\mqac.sys")
#define MSMQ_SERVICE_NAME       TEXT("MSMQ")
#define MQ1SYNC_SERVICE_NAME    TEXT("MQ1SYNC")
#define MSMQ_SERVICE_PATH       TEXT("mqsvc.exe")
#define MQ1SYNC_SERVICE_PATH    TEXT("mq1sync.exe")
#define RPC_SERVICE_NAME        TEXT("RPCSS")
#define DTC_SERVICE_NAME        TEXT("MSDTC")
#define SERVER_SERVICE_NAME     TEXT("LanmanServer")
#define LMS_SERVICE_NAME        TEXT("NtLmSsp")
#define SAM_SERVICE_NAME        TEXT("SamSs")
#define IISADMIN_SERVICE_NAME   TEXT("IISADMIN")
#define MQDS_SERVICE_NAME       TEXT("MQDS")
#define MQDS_SERVICE_PATH       TEXT("mqdssvc.exe")
#define TRIG_SERVICE_NAME       TEXT("MSMQTriggers")
#define TRIG_SERVICE_PATH       TEXT("mqtgsvc.exe")

#define PGM_DRIVER_NAME         TEXT("RMCAST")
#define PGM_DRIVER_PATH         TEXT("drivers\\RMCast.sys")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\service.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    Code to handle the MSMQ service.

Author:


Revision History:

    Shai Kariv    (ShaiK)   14-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <tlhelp32.h>

#include "service.tmh"

LPCWSTR xMSMQ_SERVICE_DISPLAY_NAME = L"Message Queuing";

//+--------------------------------------------------------------
//
// Function: CheckServicePrivilege
//
// Synopsis: Check if user has privileges to access Service Manager
//
//+--------------------------------------------------------------
BOOL
CheckServicePrivilege()
{
    if (!g_hServiceCtrlMgr) //not yet initialized
    {
        //
        // Check if the user has full access to the service control manager
        //
        g_hServiceCtrlMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (!g_hServiceCtrlMgr)
        {
            return FALSE;
        }
    }

    return TRUE;

} //CheckServicePrivilege


//+--------------------------------------------------------------
//
// Function: RemoveService
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
RemoveService(
    IN const PTCHAR szServiceName
    )
{
    //
    // Open a handle to the service
    //
    SC_HANDLE hService = OpenService(g_hServiceCtrlMgr, szServiceName,
                                     SERVICE_ALL_ACCESS);

    if (!hService)
    {
        DWORD dwError = GetLastError();
        if (ERROR_SERVICE_DOES_NOT_EXIST == dwError)
        {
            return TRUE;
        }
        else
        {
            MqDisplayError(NULL, IDS_SERVICEDELETE_ERROR, GetLastError(), szServiceName);
            return FALSE;
        }
    }

    //
    // Mark the service for deletion
    //
    if (!DeleteService(hService))
    {
        if (ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
        {
            MqDisplayError(NULL, IDS_SERVICEDELETE_ERROR, GetLastError(), szServiceName);
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    //
    // Close the service handle (and lower its reference count to 0 so
    // the service will get deleted)
    //
    CloseServiceHandle(hService);
    return TRUE;

} //RemoveService


//+--------------------------------------------------------------
//
// Function: FormMSMQDependencies
//
// Synopsis: Tells on which other services the MSMQ relies
//
//+--------------------------------------------------------------
static
void
FormMSMQDependencies( OUT TCHAR *szDependencies)
{
    //
    // The service depends on the MSMQ device driver
    //
    lstrcpy(szDependencies, MSMQ_DRIVER_NAME);
    szDependencies += lstrlen(MSMQ_DRIVER_NAME) + 1;

    //
    // The service depends on the PGM device driver
    //
    lstrcpy(szDependencies, PGM_DRIVER_NAME);
    szDependencies += lstrlen(PGM_DRIVER_NAME) + 1;

    //
    // The service depends on the Lanman Server service
    //
    lstrcpy(szDependencies, SERVER_SERVICE_NAME);
    szDependencies += lstrlen(SERVER_SERVICE_NAME) + 1;

    //
    // The service depends on the NT Lanman Security support provider
    //
    lstrcpy(szDependencies, LMS_SERVICE_NAME);
    szDependencies += lstrlen(LMS_SERVICE_NAME) + 1;

    //
    // On servers, the service depends on the Security Accounts Manager
    // (in order to wait for DS to start)
    //
    if (g_dwOS != MSMQ_OS_NTW)
    {
        lstrcpy(szDependencies, SAM_SERVICE_NAME);
        szDependencies += lstrlen(SAM_SERVICE_NAME) + 1;
    }

    //
    // The service always depends on RPC
    //
    lstrcpy(szDependencies, RPC_SERVICE_NAME);
    szDependencies += lstrlen(RPC_SERVICE_NAME) + 1;    
    
    //
    // On cluster, the msmq service doesnt depend on msdtc service.
    //
    if (!Msmq1InstalledOnCluster() &&
        !IsLocalSystemCluster())
    {
        lstrcpy(szDependencies, DTC_SERVICE_NAME);
        szDependencies += lstrlen(DTC_SERVICE_NAME) + 1;
    }


    lstrcpy(szDependencies, TEXT(""));

} //FormMSMQDependencies

//+--------------------------------------------------------------
//
// Function: FormMQDSServiceDependencies
//
// Synopsis: Tells on which other services the DS service relies
//
//+--------------------------------------------------------------
static
void
FormMQDSServiceDependencies( OUT TCHAR *szDependencies)
{
    //
    // The service depends on the MSMQ service
    //
    lstrcpy(szDependencies, MSMQ_SERVICE_NAME);
    szDependencies += lstrlen(MSMQ_SERVICE_NAME) + 1;

    lstrcpy(szDependencies, TEXT(""));

} //FormMQDSServiceDependencies

static
BOOL
SetServiceDescription(
    SC_HANDLE hService,
    LPCWSTR pDescription
    )
{
    SERVICE_DESCRIPTION ServiceDescription;
    ServiceDescription.lpDescription = const_cast<LPWSTR>(pDescription);

    return ChangeServiceConfig2(
               hService,
               SERVICE_CONFIG_DESCRIPTION,
               &ServiceDescription
               );
} //SetServiceDescription

//+--------------------------------------------------------------
//
// Function: InstallService
//
// Synopsis: Installs service
//
//+--------------------------------------------------------------
BOOL
InstallService(
        LPCWSTR szDisplayName,
        LPCWSTR szServicePath,
        LPCWSTR szDependencies,
        LPCWSTR szServiceName,
        LPCWSTR szDescription
        )
{        
    //
    // Form the full path to the service
    //
    TCHAR szFullServicePath[MAX_PATH] = {_T("")};
    _stprintf(szFullServicePath, TEXT("%s\\%s"),
              g_szSystemDir,
              szServicePath);    

    //
    // Determine the service type
    //
#ifndef _DEBUG
#define SERVICE_TYPE    SERVICE_WIN32_OWN_PROCESS
#else
#define SERVICE_TYPE    SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS
#endif

    //
    // Create the service   
    //        
    DWORD dwStartType = IsLocalSystemCluster() ? SERVICE_DEMAND_START : SERVICE_AUTO_START;
    
    SC_HANDLE hService = CreateService(
        g_hServiceCtrlMgr,
        szServiceName,
        szDisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_TYPE,
        dwStartType,
        SERVICE_ERROR_NORMAL,
        szFullServicePath,
        NULL,
        NULL,
        szDependencies,
        NULL,
        NULL
        );

    if (hService == NULL)
    {
        if (ERROR_SERVICE_EXISTS != GetLastError())
        {
            MqDisplayError(
                NULL,
                IDS_SERVICECREATE_ERROR,
                GetLastError(),
                szServiceName
                );
            return FALSE;
        }

        //
        // Service already exists.
        // This should be ok. But just to be on the safe side,
        // reconfigure the service (ignore errors here).
        //
        hService = OpenService(g_hServiceCtrlMgr, szServiceName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
        {
            return TRUE;
        }

        ChangeServiceConfig(
            hService,
            SERVICE_TYPE,
            dwStartType,
            SERVICE_ERROR_NORMAL,
            szFullServicePath,
            NULL,
            NULL,
            szDependencies,
            NULL,
            NULL,
            szDisplayName
            );
    }

    if (hService)
    {       
        SetServiceDescription(hService, szDescription);
        CloseServiceHandle(hService);
    }

    return TRUE;

} //InstallService


//+--------------------------------------------------------------
//
// Function: InstallMSMQService
//
// Synopsis: Installs the MSMQ service
//
//+--------------------------------------------------------------
BOOL
InstallMSMQService()
{    
    DebugLogMsg(L"Installing the Message Queuing service...");

    //
    // Form the dependencies of the service
    //
    TCHAR szDependencies[256] = {_T("")};
    FormMSMQDependencies(szDependencies);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_MSMQ_SERVICE_DESCRIPTION);        
    
    BOOL fRes = InstallService(
                    xMSMQ_SERVICE_DISPLAY_NAME,
                    MSMQ_SERVICE_PATH,
                    szDependencies,
                    MSMQ_SERVICE_NAME,
                    strDesc.Get()
                    );

    return fRes; 

} //InstallMSMQService


//+--------------------------------------------------------------
//
// Function: RunService
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
RunService(LPTSTR szServiceName)
{
    TickProgressBar();

    SC_HANDLE hService = OpenService(
        g_hServiceCtrlMgr,
        szServiceName, 
        SERVICE_START
        );
    if (!hService || !StartService(hService, 0, NULL))
    {
        if (ERROR_SERVICE_ALREADY_RUNNING != GetLastError())
        {
            MqDisplayError(
                NULL,
                IDS_SERVICESTART_ERROR,
                GetLastError(),
                szServiceName 
                );

            if (hService)
            {
                CloseServiceHandle(hService);
            }
            
            return FALSE;
        }
    }

    //
    // Close the service handle
    //
    CloseServiceHandle(hService);

    return TRUE;

} //RunService


//+--------------------------------------------------------------
//
// Function: GetServiceState
//
// Synopsis: Determines if a service is running
//
//+--------------------------------------------------------------

BOOL
GetServiceState(
    LPCWSTR szServiceName,
    DWORD*  pdwServiceStatus
    )
{
    //
    // Open a handle to the service
    //
    SERVICE_STATUS statusService;
    CServiceHandle hService(OpenService(
								g_hServiceCtrlMgr,
								szServiceName,
								SERVICE_QUERY_STATUS
								));

    if (hService == NULL)
    {
        DWORD dwError = GetLastError();

        if (ERROR_SERVICE_DOES_NOT_EXIST == dwError)
		{
			*pdwServiceStatus = SERVICE_STOPPED;
            return TRUE;
		}

        MqDisplayError(NULL, IDS_SERVICEOPEN_ERROR, dwError, szServiceName);
        return FALSE;
    }

    //
    // Obtain the service status
    //
    if (!QueryServiceStatus(hService, &statusService))
    {
        MqDisplayError(NULL, IDS_SERVICEGETSTATUS_ERROR, GetLastError(), szServiceName);
        return FALSE;
    }

    //
    // Determine if the service is not stopped
    //
    *pdwServiceStatus = statusService.dwCurrentState;

    return TRUE;

} // GetServiceState


//+--------------------------------------------------------------
//
// Function: WaitForServiceToStart
//
// Synopsis: Wait for a service in a pending state to stop/start
//
//+--------------------------------------------------------------
BOOL
WaitForServiceToStart(
	SC_HANDLE hService,
	LPCWSTR pServiceName
	)
{
    SERVICE_STATUS statusService;

	for (;;)
	{
		Sleep(WAIT_INTERVAL);
		if (!QueryServiceStatus(hService, &statusService))
		{
			MqDisplayError(
				NULL,
				IDS_SERVICEGETSTATUS_ERROR,
				GetLastError(),
				pServiceName
				);

			return FALSE;
		}

		//
		// If we wait for service to start, wait until it starts or stops completely
		//
		if (statusService.dwCurrentState == SERVICE_STOPPED ||
			statusService.dwCurrentState == SERVICE_RUNNING)
		{
			return TRUE;
		}

		//
		// FALCON1-Bug8069-2001/05/30-nelak 
		// limit wait time, and display error with retry
		//
	}
}


//+--------------------------------------------------------------
//
// Function: WaitForServiceToStop
//
// Synopsis: Wait for a service in a pending state to stop/start
//
//+--------------------------------------------------------------
BOOL
WaitForServiceToStop(
	SC_HANDLE hService,
	LPCWSTR pServiceName
	)
{
    SERVICE_STATUS statusService;
    DWORD dwWait = 0;

	for (;;)
	{
		Sleep(WAIT_INTERVAL);
		dwWait += WAIT_INTERVAL;
		if (!QueryServiceStatus(hService, &statusService))
		{
			MqDisplayError(
				NULL,
				IDS_SERVICEGETSTATUS_ERROR,
				GetLastError(),
				pServiceName
				);

			return FALSE;
		}

		//
		// If we wait for service to stop, wait until it is really stopped
		//
		if (statusService.dwCurrentState == SERVICE_STOPPED)
		{
			return TRUE;
		}

		if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
		{
			if (IDRETRY ==
				MqDisplayErrorWithRetry(
					IDS_WAIT_FOR_STOP_TIMEOUT_EXPIRED,
					0,
					MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES
					))
			{
				dwWait = 0;
			}
			else
			{
				return FALSE;
			}
		}
	}
}


//+--------------------------------------------------------------
//
// Function: OcpStopServiceInternal
//
// Synopsis:
//
//+--------------------------------------------------------------

static
BOOL
OcpStopServiceInternal(
    LPCWSTR pServiceName
    )
{
    //
    // If service is not running, we're finished
    //
    DWORD dwServiceState = FALSE;
    if (!GetServiceState(pServiceName, &dwServiceState))
        return FALSE;

    if (dwServiceState == SERVICE_STOPPED)
        return TRUE;

    //
    // Open a handle to the service
    //
    CServiceHandle hService(OpenService(
									g_hServiceCtrlMgr,
									pServiceName,
									SERVICE_STOP | SERVICE_QUERY_STATUS
									));

    if (hService == NULL)
    {
        MqDisplayError(
            NULL,
            IDS_SERVICEOPEN_ERROR,
            GetLastError(),
            pServiceName
            );
        return FALSE;
    }

	//
	// If service is in START_PENDING state, wait for 
	// it to start, and then send stop signal
	//
	if (dwServiceState == SERVICE_START_PENDING)
	{
		if (!WaitForServiceToStart(hService, pServiceName))
		{
			return FALSE;
		}
	}

	//
	// Send stop signal to the service if it is not 
	// already stopping
	//
	if (dwServiceState != SERVICE_STOP_PENDING)
	{
		SERVICE_STATUS statusService;
		if (!ControlService(hService, SERVICE_CONTROL_STOP, &statusService))
		{
			DWORD dwError = GetLastError();
			if (dwError != ERROR_SERVICE_NOT_ACTIVE)
			{
				MqDisplayError(NULL, IDS_SERVICESTOP_ERROR, dwError, pServiceName);
				return FALSE;
			}
		}
	}

	//
	// Wait until the service has stopped running
	//
    BOOL fRet = WaitForServiceToStop(hService, pServiceName);
	return fRet;
}


//+--------------------------------------------------------------
//
// Function: OcpStopDependentSrvices
//
// Synopsis:
//
//+--------------------------------------------------------------

static
BOOL
OcpStopDependentSrvices(LPCWSTR szServiceName)
{
    //
    // If service is not running, we're finished
    //
    DWORD dwServiceState = FALSE;
    if (!GetServiceState(szServiceName, &dwServiceState))
        return FALSE;

    if (dwServiceState == SERVICE_STOPPED)
        return TRUE;

    //
    // Open a handle to the service
    //
    CServiceHandle hService(OpenService(
                                g_hServiceCtrlMgr,
                                szServiceName, 
                                SERVICE_ENUMERATE_DEPENDENTS
                                ));

    if (hService == NULL)
    {
        DWORD le = GetLastError();

        MqDisplayError(
            NULL,
            IDS_SERVICEOPEN_ERROR,
            le,
            szServiceName
            );
        return FALSE;
    }

    //
    // First we call EnumDependentServices just to get BytesNeeded.
    //
    DWORD BytesNeeded;
    DWORD NumberOfEntries;
    BOOL fSucc = EnumDependentServices(
                    hService,
                    SERVICE_ACTIVE,
                    NULL,
                    0,
                    &BytesNeeded,
                    &NumberOfEntries
                    );

    DWORD le = GetLastError();
	if (BytesNeeded == 0)
    {
        return TRUE;
    }
    
    ASSERT(!fSucc);
    if( le != ERROR_MORE_DATA)
    {
        MqDisplayError(
            NULL,
            IDS_ENUM_SERVICE_DEPENDENCIES,
            le,
            szServiceName
            );
        
        return FALSE;
    }

    AP<BYTE> pBuffer = new BYTE[BytesNeeded];

    ENUM_SERVICE_STATUS * pDependentServices = reinterpret_cast<ENUM_SERVICE_STATUS*>(pBuffer.get());
    fSucc = EnumDependentServices(
                hService,
                SERVICE_ACTIVE,
                pDependentServices,
                BytesNeeded,
                &BytesNeeded,
                &NumberOfEntries
                );

    if(!fSucc)
    {
        MqDisplayError(
            NULL,
            IDS_ENUM_SERVICE_DEPENDENCIES,
            GetLastError(),
            szServiceName
            );
       
        return FALSE;
    }

    for (DWORD ix = 0; ix < NumberOfEntries; ++ix)
    {
        if(!OcpStopServiceInternal(pDependentServices[ix].lpServiceName))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

//+--------------------------------------------------------------
//
// Function: StopService
//
// Synopsis:
//
//+--------------------------------------------------------------

BOOL
StopService(
    LPCWSTR szServiceName
    )
{
    if(!OcpStopDependentSrvices(szServiceName))
    {
        return FALSE;
    }

    if(!OcpStopServiceInternal(szServiceName))
    {
        return FALSE;
    }
    return TRUE;
}


//+--------------------------------------------------------------
//
// Function: RemoveServices
//
// Synopsis: Stops and deletes the MQDS and MSMQ services
//
//+--------------------------------------------------------------
void
RemoveServices()
{       
    if (!StopService(MSMQ_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing service could not be stopped.");
        ASSERT(("failed to stop MSMQ service", 0));
    }

    if (!RemoveService(MSMQ_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing service could not be removed.");
        ASSERT(("failed to remove MSMQ service", 0));
    }    
} //RemoveServices


//+--------------------------------------------------------------
//
// Function: DisableMsmqService
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
DisableMsmqService()
{    
    DebugLogMsg(L"Disabling the Message Queuing service...");

    //
    // Open a handle to the service
    //
    SC_HANDLE hService = OpenService(
                             g_hServiceCtrlMgr,
                             MSMQ_SERVICE_NAME,
                             SERVICE_ALL_ACCESS
                             );

    if (!hService)
    {
        MqDisplayError(NULL, IDS_SERVICE_NOT_EXIST_ON_UPGRADE_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        return FALSE;
    }

    //
    // Set the start mode to be disabled
    //
    if (!ChangeServiceConfig(
             hService,
             SERVICE_NO_CHANGE ,
             SERVICE_DISABLED,
             SERVICE_NO_CHANGE,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL
             ))
    {
        MqDisplayError(NULL, IDS_SERVICE_CHANGE_CONFIG_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        CloseHandle(hService);
        return FALSE;
    }

    CloseHandle(hService);
    return TRUE;

} // DisableMsmqService


//+--------------------------------------------------------------
//
// Function: UpgradeServiceDependencies
//
// Synopsis: Reform MSMQ service dependencies on upgrade to NT5
//
//+--------------------------------------------------------------
BOOL
UpgradeServiceDependencies()
{
    //
    // Open a handle to the service
    //
    SC_HANDLE hService = OpenService(
        g_hServiceCtrlMgr,
        MSMQ_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService)
    {
        MqDisplayError(NULL, IDS_SERVICE_NOT_EXIST_ON_UPGRADE_ERROR,
            GetLastError(), MSMQ_SERVICE_NAME);
        return FALSE;
    }

    //
    // Set the new dependencies
    //
    TCHAR szDependencies[256] = {_T("")};
    FormMSMQDependencies(szDependencies);
 
    if (!ChangeServiceConfig(
             hService,
             SERVICE_NO_CHANGE,
             SERVICE_NO_CHANGE,
             SERVICE_NO_CHANGE,
             NULL,
             NULL,
             NULL,
             szDependencies,
             NULL,
             NULL,
             xMSMQ_SERVICE_DISPLAY_NAME
             ))
    {
        MqDisplayError(NULL, IDS_SERVICE_CHANGE_CONFIG_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        CloseServiceHandle(hService);
        return FALSE;
    }

    CResString strDesc(IDS_MSMQ_SERVICE_DESCRIPTION);
    SetServiceDescription(hService, strDesc.Get());

    CloseServiceHandle(hService);
    return TRUE;

} // UpgradeServiceDependencies

//+-------------------------------------------------------------------------
//
//  Function: InstallMQDSService
//
//  Synopsis: Install MQDS Service
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
MQDSServiceSetup()
{    
    DebugLogMsg(L"Installing the Message Queuing Downlevel Client Support service...");

    //
    // Form the dependencies of the service
    //
    TCHAR szDependencies[256] = {_T("")};
    FormMQDSServiceDependencies(szDependencies);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_MQDS_SERVICE_DESCRIPTION);        

    LPCWSTR xMQDS_SERVICE_DISPLAY_NAME = L"Message Queuing Downlevel Client Support";
    BOOL fRes = InstallService(
                    xMQDS_SERVICE_DISPLAY_NAME,
                    MQDS_SERVICE_PATH,
                    szDependencies,
                    MQDS_SERVICE_NAME,
                    strDesc.Get()
                    );

    return fRes;   
}

//+-------------------------------------------------------------------------
//
//  Function: InstallMQDSService
//
//  Synopsis: MQDS Service Setup: install it and if needed to run it
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
InstallMQDSService()
{   
    //
    // we install this service only on servers!
    //
    ASSERT(("MQDS Service must be installed on the server", 
        MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS));
    
    //
    // do not install MQDS on dependent client
    //
    ASSERT(("Unable to install MQDS Service on Dependent Client", 
        !g_fDependentClient));
       
    //
    // In fresh install user select this subcomponent using UI or 
    // unattended file. For upgrade we install this service ONLY on
    // the former DS servers.
    //
    ASSERT(("Upgrade mode: MQDS Service must be installed on the former DS servers", 
        !g_fUpgrade || (g_fUpgrade && g_dwMachineTypeDs)));            


    TickProgressBar(IDS_PROGRESS_INSTALL_MQDS);

    
    if (!MQDSServiceSetup())
    {        
        DebugLogMsg(L"The Message Queuing Downlevel Client Support service could not be installed.");
        return FALSE;
    }

    if ( g_fUpgrade                || // do not start services 
                                      // if upgrade mode        
        IsLocalSystemCluster()        // do not start service on
                                      // cluster machine (MSMQ is not
                                      // started)
        )
    {
        return TRUE;
    }
        
    if (!RunService(MQDS_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing Downlevel Client Support service could not be started.");
        //
        // to clean up because of failure
        //
        RemoveService(MQDS_SERVICE_NAME);    
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: UnInstallMQDSService
//
//  Synopsis: MQDS Service Uninstall: stop and remove MQDS service
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
UnInstallMQDSService()
{
    TickProgressBar(IDS_PROGRESS_REMOVE_MQDS);
    if (!StopService(MQDS_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing Downlevel Client Support service could not be stopped.");
        ASSERT(("failed to stop MQDS service", 0));
        return FALSE;
    }

    if (!RemoveService(MQDS_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing Downlevel Client Support service could not be removed.");
        ASSERT(("failed to remove MQDS service", 0));
        return FALSE;
    }    

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\stdh.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file for NT5 OCM setup.

Author:

	Shai Kariv    (ShaiK)   05-Jan-98

Revision History:


--*/

#ifndef _STDH_H
#define _STDH_H

#include <_stdh.h>
#include <mqwin64a.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <shlobj.h>

#include <_mqini.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <mqtypes.h>
#include <dsproto.h>
#include <mqsec.h>
#include <_secutil.h>
#include "_mqdef.h"
#include <_mqreg.h>
#include <uniansi.h>
#include "version.h"

#include "ocmres.h"  
#include "list_mac.h"
#include "list.h"

#endif //_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\stdh.cpp ===
//
// stdh.cpp
//

#include "msmqocm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\servname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    servname.cpp

Abstract:

    Handle input of server name and check if server available
    and is of the proper type.

Author:

    Doron Juster  (DoronJ)  15-Sep-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "qm2qm.h"
#include "dscomm.h"

#include "servname.tmh"

extern "C" void __RPC_FAR * __RPC_USER midl_user_allocate(size_t cBytes)
{
    return new char[cBytes];
}

extern "C" void  __RPC_USER midl_user_free (void __RPC_FAR * pBuffer)
{
    delete[] pBuffer;
}

static RPC_STATUS s_ServerStatus = RPC_S_OK ;
static HWND       s_hwndWait = 0;
static BOOL       s_fWaitCancelPressed = FALSE;
static BOOL       s_fRpcCancelled = FALSE ;
TCHAR             g_wcsServerName[ MAX_PATH ] = TEXT("") ;

// Two minutes, in milliseconds.
static const DWORD sx_dwTimeToWaitForServer = 120000;

// Display the progress bar half a second after starting rpc.
static const DWORD sx_dwTimeUntilWaitDisplayed = 500;

// This error code is returned in the RPC code of dscommk2.mak
#define  RPC_ERROR_SERVER_NOT_MQIS  0xc05a5a5a

BOOL  g_fUseServerAuthen = FALSE ;

//+------------------------------------------
//
//  void ReadSecuredCommFromIniFile()
//
//+------------------------------------------

void ReadSecuredCommFromIniFile()
{
    //
    // Read the server authentication key from answer file
    //
    TCHAR szSecComm[MAX_STRING_CHARS] = {0};
    try
    {
        ReadINIKey(
            L"ServerAuthenticationOnly",
            sizeof(szSecComm) / sizeof(szSecComm[0]),
            szSecComm
            );
        //
        // Only if it exists and equals 'true', server authentication
        // is a must
        //
        g_fUseServerAuthen = OcmStringsEqual(szSecComm, L"TRUE");

        MqWriteRegistryValue( 
            MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
            sizeof(DWORD),
            REG_DWORD,
            &g_fUseServerAuthen 
            );
    }
    catch(exception)
    {
    }
}

//+-------------------------------------------
//
// RPC_STATUS  _PingServerOnProtocol()
//
//+-------------------------------------------

RPC_STATUS _PingServerOnProtocol()
{
    ASSERT(g_wcsServerName[0] != '\0');
    //
    // Create RPC binding handle.
    // Use the dynamic port for querying the server.
    //
    _TUCHAR  *pszStringBinding = NULL;
    _TUCHAR  *pProtocol  = (_TUCHAR*) TEXT("ncacn_ip_tcp") ;
    RPC_STATUS status = RpcStringBindingCompose(
            NULL,  // pszUuid,
            pProtocol,
            (_TUCHAR*) g_wcsServerName,
            NULL, // lpwzRpcPort,
            NULL, // pszOptions,
            &pszStringBinding
            );
    if (status != RPC_S_OK)
    {
        return status ;
    }

    handle_t hBind ;
    status = RpcBindingFromStringBinding(
        pszStringBinding,
        &hBind
        );

    //
    // We don't need the string anymore.
    //
    RPC_STATUS rc = RpcStringFree(&pszStringBinding) ;
    ASSERT(rc == RPC_S_OK);

    if (status != RPC_S_OK)
    {
        //
        // this protocol is not supported.
        //
        return status ;
    }

    status = RpcMgmtSetCancelTimeout(0);
    ASSERT(status == RPC_S_OK);

    if (!s_fRpcCancelled)
    {
        __try
        {
            DWORD dwPort = 0 ;

            if (g_fDependentClient)
            {
                //
                // Dependent client can be served by an FRS, which is not MQDSSRV
                // server. So call its QM, not its MQDSSRV.
                //
                dwPort = RemoteQMGetQMQMServerPort(hBind, TRUE /*IP*/);
            }
            else
            {
                dwPort = S_DSGetServerPort(hBind, TRUE /*IP*/) ;
            }

            ASSERT(dwPort != 0) ;
            status =  RPC_S_OK ;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = RpcExceptionCode();
        }
    }

    if (!s_fRpcCancelled  &&
        (!g_fDependentClient && (status == RPC_S_SERVER_UNAVAILABLE)))
    {
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT(status == RPC_S_OK);

        __try
        {
            //
            // We didn't find an MQIS server. See if the machine name is
            // a routing server and display an appropriate error.
            //
            DWORD dwPort = RemoteQMGetQMQMServerPort(hBind, TRUE /*IP*/) ;
            UNREFERENCED_PARAMETER(dwPort);
            status =  RPC_ERROR_SERVER_NOT_MQIS ;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = RpcExceptionCode();
        }
    }

    rc = RpcBindingFree(&hBind);
    ASSERT(rc == RPC_S_OK);

    return status ;

} // _PingServerOnProtocol()

//+--------------------------------------------------------------
//
// Function: PingAServer
//
// Synopsis:
//
//+--------------------------------------------------------------

RPC_STATUS PingAServer()
{
    RPC_STATUS status = _PingServerOnProtocol();

    return status;
}

//+--------------------------------------------------------------
//
// Function: PingServerThread
//
// Synopsis: Thread to ping the server, to see if it is available
//
//+--------------------------------------------------------------

DWORD WINAPI
PingServerThread(LPVOID lpV)
{
    s_ServerStatus = PingAServer();
    return 0 ;

} // PingServerThread

//+--------------------------------------------------------------
//
// Function: MsmqWaitDlgProc
//
// Synopsis: Dialog procedure for the Wait dialog
//
//+--------------------------------------------------------------
INT_PTR
CALLBACK
MsmqWaitDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    )
{
    switch( msg )
    {
    case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case IDCANCEL:
                {
                    s_fWaitCancelPressed = TRUE;
                    return FALSE;
                }
            }
        }
        break;

    case WM_INITDIALOG:
        {
            SendDlgItemMessage(
                hdlg,
                IDC_PROGRESS,
                PBM_SETRANGE,
                0,
                MAKELPARAM(0, sx_dwTimeToWaitForServer/50)
                );
        }
        break;

    default:
        return DefWindowProc(hdlg, msg, wParam, lParam);
        break;
    }
    return (FALSE);

} // MsmqWaitDlgProc


//+--------------------------------------------------------------
//
// Function: DisplayWaitWindow
//
// Synopsis:
//
//+--------------------------------------------------------------
static
void
DisplayWaitWindow(
    HWND hwndParent,
    DWORD dwTimePassed
    )
{
    ASSERT(!g_fBatchInstall);
    static int iLowLimit;
    static int iHighLimit;

    if (0 == s_hwndWait)
    {
        s_hwndWait = CreateDialog(
            g_hResourceMod ,
            MAKEINTRESOURCE(IDD_WAIT),
            hwndParent,
            MsmqWaitDlgProc
            );
        ASSERT(s_hwndWait);

        if (s_hwndWait)
        {
            ShowWindow(s_hwndWait, TRUE);
        }

        s_fWaitCancelPressed = FALSE;

        //
        // Store the range limits of the progress bar
        //
        PBRANGE pbRange;
        SendDlgItemMessage(
            s_hwndWait,
            IDC_PROGRESS,
            PBM_GETRANGE,
            0,
            (LPARAM)(PPBRANGE)&pbRange
            );
        iLowLimit = pbRange.iLow;
        iHighLimit = pbRange.iHigh;
    }
    else
    {
        int iPos = (dwTimePassed / 50);
        while (iPos >= iHighLimit)
            iPos %= (iHighLimit - iLowLimit);
        SendDlgItemMessage(
            s_hwndWait,
            IDC_PROGRESS,
            PBM_SETPOS,
            iPos,
            0
            );
    }
}


//+--------------------------------------------------------------
//
// Function: DestroyWaitWindow
//
// Synopsis: Kills the Wait dialog
//
//+--------------------------------------------------------------
static
void
DestroyWaitWindow()
{
    if(s_hwndWait)
    {
        DestroyWindow(s_hwndWait);
        s_hwndWait = 0;
    }
} // DestroyWaitWindow


//+--------------------------------------------------------------
//
// Function: CheckServer
//
// Synopsis: Checks if server is valid
//
// Returns:  1 if succeeded, -1 if failed (so as to prevent the
//           wizard from continuing to next page)
//
//+--------------------------------------------------------------
static
int
CheckServer(
    IN const HWND   hdlg
    )
{
    static BOOL    fRpcMgmt = TRUE ;
    static DWORD   s_dwStartTime ;
    static BOOL    s_fCheckServer = FALSE ;
    static HANDLE  s_hThread = NULL ;

    ASSERT(!g_fBatchInstall);

    if (fRpcMgmt)
    {
        RPC_STATUS status = RpcMgmtSetCancelTimeout(0);
        UNREFERENCED_PARAMETER(status);
        ASSERT(status == RPC_S_OK);
        fRpcMgmt = FALSE ;
    }

    if (s_fCheckServer)
    {

        BOOL fAskRetry = FALSE ;
        DWORD dwTimePassed = (GetTickCount() - s_dwStartTime);

        if ((!s_fWaitCancelPressed) && dwTimePassed < sx_dwTimeToWaitForServer)
        {
            if (dwTimePassed > sx_dwTimeUntilWaitDisplayed)
            {
                DisplayWaitWindow(hdlg, dwTimePassed);
            }

            DWORD dwWait = WaitForSingleObject(s_hThread, 0) ;
            ASSERT(dwWait != WAIT_FAILED) ;

            if (dwWait == WAIT_OBJECT_0)
            {
                CloseHandle(s_hThread) ;
                s_hThread = NULL ;
                DestroyWaitWindow();
                s_fCheckServer = FALSE ;

                if (s_ServerStatus == RPC_S_OK)
                {
                    //
                    // Server exist. go on.
                    //
                }
                else
                {
                    fAskRetry = TRUE ;
                }
            }
            else
            {
                //
                // thread not terminated yet.
                //
                MSG msg ;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg) ;
                    DispatchMessage(&msg) ;
                }
                Sleep(50) ;
                PropSheet_PressButton(GetParent(hdlg),
                    PSBTN_NEXT) ;
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
                return -1 ;
            }
        }
        else
        {
            DisplayWaitWindow(hdlg, sx_dwTimeToWaitForServer) ;
            s_fWaitCancelPressed = FALSE;
            //
            // thread run too much time. Kill it.
            //
            ASSERT(s_hThread) ;
            __try
            {
                s_fRpcCancelled = TRUE ;
                RpcCancelThread(s_hThread) ;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            fAskRetry = TRUE ;
            s_fCheckServer = FALSE ;

            //
            // wait 30 seconds until thread terminate.
            //
            DWORD dwWait = WaitForSingleObject(s_hThread, 30000) ;
            UNREFERENCED_PARAMETER(dwWait);
            DestroyWaitWindow();
            ASSERT(dwWait == WAIT_OBJECT_0) ;

            CloseHandle(s_hThread) ;
            s_hThread = NULL ;
        }

        BOOL fRetry = FALSE ;

        if (fAskRetry && g_fDependentClient)
        {
            //
            // Here "NO" means go on and use server although
            // it's not reachable.
            //
            if (!MqAskContinue(IDS_STR_REMOTEQM_NA, g_uTitleID, TRUE))
            {
                fRetry = TRUE ;
            }
        }
        else if (fAskRetry)
        {
            UINT iErr = IDS_SERVER_NOT_AVAILABLE ;
            if (s_ServerStatus ==  RPC_ERROR_SERVER_NOT_MQIS)
            {
                iErr = IDS_REMOTEQM_NOT_SERVER ;
            }
            UINT i = MqDisplayError(hdlg, iErr, 0) ;
            UNREFERENCED_PARAMETER(i);
            fRetry = TRUE ;
        }

        if (fRetry)
        {
            //
            // Try another server. Present one is not available.
            //
            PropSheet_SetWizButtons(GetParent(hdlg),
                (PSWIZB_BACK | PSWIZB_NEXT)) ;
            lstrcpy(g_wcsServerName, TEXT("")) ;
            SetDlgItemText(
                hdlg,
                IDC_EDIT_ServerName,
                g_wcsServerName
                ) ;
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
            return -1 ;
        }
    }
    else // s_fCheckServer
    {
        //
        // In attended mode, get the server name from the Edit control.
        // In unattended mode, it was read earlier from the answer file.
        //
        if (!g_fBatchInstall)
        {
            GetDlgItemText(
                hdlg,
                IDC_EDIT_ServerName,
                g_wcsServerName,
                sizeof(g_wcsServerName) / sizeof(g_wcsServerName[0])
                );
        }

        ASSERT(g_wcsServerName);
        if (lstrlen(g_wcsServerName) < 1)
        {
            //
            // Server name must be supplied.
            //
            UINT i = MqDisplayError(hdlg, IDS_STR_MUST_GIVE_SERVER, 0);
            UNREFERENCED_PARAMETER(i);
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
            return -1 ;
        }
        else
        {
            s_fRpcCancelled = FALSE ;

            //
            // Check if server available.
            // Disable the back/next buttons.
            //
            DWORD dwID ;
            s_hThread = CreateThread( NULL,
                0,
                (LPTHREAD_START_ROUTINE) PingServerThread,
                (LPVOID) NULL,
                0,
                &dwID ) ;
            ASSERT(s_hThread) ;
            if (s_hThread)
            {
                s_dwStartTime = GetTickCount() ;
                s_fCheckServer = TRUE ;
                s_fWaitCancelPressed = FALSE;
                PropSheet_PressButton(GetParent(hdlg), PSBTN_NEXT) ;
                PropSheet_SetWizButtons(GetParent(hdlg), 0) ;
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
                return -1 ;
            }
        }
    }

    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );

    return (1);

} //CheckServer

//+--------------------------------------------------------------
//
// Function: FindServerIsAdsInternal
//
// Note: this is a thread entry point. It must be WINAPI and
//       accept a pointer to void.
//
//+--------------------------------------------------------------

DWORD WINAPI
FindServerIsAdsInternal(LPVOID lpV)
{
    DWORD dwDsEnv = ADRawDetection();

    if (dwDsEnv == MSMQ_DS_ENVIRONMENT_PURE_AD)
    {
        if (WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_PURE_AD))
        {
            return 1;
        }
    }
    return 0;
}

//+--------------------------------------------------------------
//
// Function: FindServerIsAds
//
// Synopsis:
//
//+--------------------------------------------------------------

BOOL
FindServerIsAds(
    IN const HWND hdlg
    )
{
    DWORD dwExitCode = 0;

    //
    // In unattended mode just find the server
    //
    if (g_fBatchInstall)
    {
        return FindServerIsAdsInternal(NULL);
    }

    //
    // In attended mode display progress message.
    // Create a thread to look for server.
    //
    DWORD dwID;
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FindServerIsAdsInternal,
        (LPVOID) NULL,
        0,
        &dwID
        );
    ASSERT(hThread);
    if (!hThread)
        return FALSE;

    //
    // Disable back/next buttons and take start time
    //
    DWORD dwStartTime = GetTickCount() ;
    s_fWaitCancelPressed = FALSE;
    PropSheet_SetWizButtons(GetParent(hdlg), 0) ;

    //
    // Display progress bar until server found or user cancels
    //
    BOOL fServerFound = FALSE;
    for (;;)
    {
        if (!s_fWaitCancelPressed)
        {
            DWORD dwTimePassed = GetTickCount() - dwStartTime;
            DisplayWaitWindow(hdlg, dwTimePassed);

            DWORD dwWait = WaitForSingleObject(hThread, 0) ;
            ASSERT(dwWait != WAIT_FAILED) ;

            if (dwWait == WAIT_OBJECT_0)
            {
                //
                // Thread terminated, get its exit code
                //
                GetExitCodeThread(hThread, &dwExitCode);
                fServerFound = (1 == dwExitCode);
                break;
            }
            else
            {
                //
                // Thread not terminated yet.
                //
                MSG msg ;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg) ;
                    DispatchMessage(&msg) ;
                }
                Sleep(50) ;
            }
        }
        else
        {
            //
            // User pressed Cancel. Kill the thread.
            //
            ASSERT(hThread);
            if (!TerminateThread(hThread, dwExitCode))
                ASSERT(0);
            break;
        }
    }

    s_fWaitCancelPressed = FALSE;
    DestroyWaitWindow();
    CloseHandle(hThread) ;

    return fServerFound;

} // FindServerIsAds


bool
SkipOnClusterUpgrade(
    VOID
    )
/*++

Routine Description:

    Check if the server name page should be skipped in the
    case of upgrading msmq on cluster.

    When upgrading PEC/PSC/BSC on cluster, MQIS is migarted
    to a remote Windows XP domain controller.
    The upgraded PEC/PSC/BSC is downgraded to a routing server during
    upgrade. Then after logon to Win2K the post-cluster-upgrade wizard
    runs and should find this remote domain controller which serves as
    msmq ds server (either find it automatically or ask user).

Arguments:

    None

Return Value:

    true - Skip the server name page and logic (i.e. we run as a 
           post-cluster-upgrade wizard for client or routing server).

    false - Do not skip the server name page.

--*/
{
    if (!g_fWelcome         || 
        !Msmq1InstalledOnCluster())
    {
        //
        // Not running as post-cluster-upgrade wizard.
        //
        return false;
    }

    DWORD dwMqs = SERVICE_NONE;
    MqReadRegistryValue(MSMQ_MQS_REGNAME, sizeof(DWORD), &dwMqs);

    if (dwMqs == SERVICE_PEC ||
        dwMqs == SERVICE_PSC ||
        dwMqs == SERVICE_BSC)
    {
        //
        // Upgrade of PEC/PSC/BSC
        //
        return false;
    }

    return true;

} //SkipOnClusterUpgrade


//+--------------------------------------------------------------
//
// Function: MsmqServerNameDlgProc
//
// Synopsis:
//
//+--------------------------------------------------------------
INT_PTR
CALLBACK
MsmqServerNameDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam )
{
    static HWND s_hSecComm = NULL;
    static HWND s_hEditServer = NULL;
    static HWND s_hServerDescription = NULL;
    int iSuccess = 0;    

    switch( msg )
    {
        case WM_INITDIALOG:
        {
            //
            // at this point user already select/ unselect all needed
            // subcomponent. We can define setup operation for each subcomponent
            //
            SetOperationForSubcomponents ();
            g_hPropSheet = GetParent(hdlg);

            MqWriteRegistryValue( MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
                                  sizeof(DWORD),
                                  REG_DWORD,
                                 &g_fUseServerAuthen ) ;
          
            iSuccess = 1;
            break;
        }

        case WM_COMMAND:
        {
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                LRESULT lResult;
                switch (LOWORD(wParam))
                {                                   
                    case IDC_CHECK_SEC_COMM:
                        //
                        // Read the SecComm status
                        //
                        lResult = SendMessage(
                            s_hSecComm,
                            BM_GETCHECK,
                            0,
                            0) ;
                        g_fUseServerAuthen = (lResult == BST_CHECKED) ;

                        //
                        // save in registry.
                        //
                        MqWriteRegistryValue(
                                    MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
                                    sizeof(DWORD),
                                    REG_DWORD,
                                   &g_fUseServerAuthen ) ;

                        break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            iSuccess = 0;

            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {                          
                BOOL fSkipPage = FALSE ;
                BOOL fServerNameInAnswerFile = FALSE;
                BOOL fAskAboutServer = FALSE;
                if (g_fDependentClient)
                {
                    //
                    // in case of Dep. Client INSTALLATION we have to show this page
                    // NB! we can be here if Dep. Client was installed and we are
                    // going to REMOVE MSMQ. In this case we do NOT show this page.
                    //
                    fAskAboutServer = 
                        (INSTALL == g_SubcomponentMsmq[eMSMQCore].dwOperation);
                }
                else
                {
                    //
                    // if user selects to add AD Integration we have to show this page
                    //
                    fAskAboutServer = 
                        (INSTALL == g_SubcomponentMsmq[eADIntegrated].dwOperation);
                }

                if (g_fCancelled           ||
                    !fAskAboutServer       ||                 
                    g_fUpgrade             ||
                    !MqInit()              ||
                    IsWorkgroup()          ||
                    SkipOnClusterUpgrade() 
                    )
                {
                    fSkipPage = TRUE;
                }
                else
                {                    
                    if (g_fBatchInstall)
                    {
                        fSkipPage = TRUE;
                        
                        //
                        // g_fDsLess flag is already defined in 
                        // SetSubcomponentsOperation
                        //
                      
                        //
                        // Read server name from INI file.
                        //
                        TCHAR szServerKey[255] = _T("ControllerServer");
                        
                        BOOL required = FALSE;
                        if (g_fDependentClient)
                        {
                            //
                            // For dependent client, look for the SupporingServer key.
                            //
                            _tcscpy(szServerKey, _T("SupportingServer"));
                            required = TRUE;
                        }
                        try
                        {
                            ReadINIKey(
                                szServerKey,
                                sizeof(g_wcsServerName)/sizeof(g_wcsServerName[0]),
                                g_wcsServerName       
                                );
                            fServerNameInAnswerFile = TRUE;
                            StoreServerPathInRegistry(g_wcsServerName);
                        }
                        catch(exception)
                        {
                            if (required)
                            {
                                MqDisplayError(
                                    NULL,
                                    IDS_UNATTEN_NO_SUPPORTING_SERVER,
                                    0
                                    );

                                g_fCancelled = TRUE;
                                iSuccess = SkipWizardPage(hdlg);
                                break;
                            }
                        }
                        //
                        // Read server authentication flag (secured comm).
                        //
                        ReadSecuredCommFromIniFile() ;                     
                    }

                    //
                    // Detect DS environment - find if environment is AD
                    //
                    if (!g_fDependentClient)
                    {                      
                        BOOL bFound = FALSE;
                        if (g_fBatchInstall && !fServerNameInAnswerFile)
                        {
                            bFound = FindServerIsAdsInternal(NULL);
                            if (!bFound)
                            {
                                MqDisplayError(NULL, IDS_UNATTEND_SERVER_NOT_FOUND_ERROR, 0);
                                g_fCancelled = TRUE;
                            }
                        }
                        if (!g_fBatchInstall)
                        {
                            bFound = FindServerIsAds(hdlg);
                        }
                        if (bFound)
                        {
                            fSkipPage = TRUE;
                        }
                    }
                  
                    if (g_fBatchInstall && fServerNameInAnswerFile)
                    {
                        //
                        // Unattended. Ping MSMQ server.
                        //
                        RPC_STATUS rc = PingAServer();
                        if (RPC_S_OK != rc)
                        {
                            //
                            // Log the failure. Continue only for dep client.
                            //
                            if (g_fDependentClient)
                            {
                                MqAskContinue(IDS_STR_REMOTEQM_NA, g_uTitleID, TRUE);
                            }
                            else
                            {
                                g_fCancelled = TRUE;
                                UINT iErr = IDS_SERVER_NOT_AVAILABLE ;
                                if (RPC_ERROR_SERVER_NOT_MQIS == rc)
                                    iErr = IDS_REMOTEQM_NOT_SERVER ;
                                MqDisplayError(NULL, iErr, 0) ;
                            }
                        }                        
                    }
                }

                if (fSkipPage)
                {
                    iSuccess = SkipWizardPage(hdlg);
                    break;
                }
                else
                {                            
                    s_hSecComm = GetDlgItem(hdlg, IDC_CHECK_SEC_COMM) ;
                    s_hEditServer = GetDlgItem(hdlg, IDC_EDIT_ServerName);
                    s_hServerDescription = GetDlgItem(hdlg, IDC_SpecifyServerDescription);
                    
                    EnableWindow(s_hEditServer, TRUE);
                    EnableWindow(s_hServerDescription, TRUE);
                    EnableWindow(s_hSecComm, TRUE);
                    
                    WPARAM wParam = BST_UNCHECKED ;
                    if (g_fUseServerAuthen)
                    {
                        wParam = BST_CHECKED ;
                    }
                    SendMessage(s_hSecComm, BM_SETCHECK, wParam, 0) ;                    

                    UINT uTitleId = IDS_RS_TITLE_SERVER;
                    UINT uPageTitleId = IDS_IND_PAGE_TITLE_SERVER;
                    if (!g_fServerSetup)
                    {
                        uTitleId = g_fDependentClient ? 
                            IDS_DEP_TITLE_SERVER : IDS_IND_TITLE_SERVER;
                        uPageTitleId = g_fDependentClient ? 
                            IDS_DEP_PAGE_TITLE_SERVER : IDS_IND_PAGE_TITLE_SERVER;
                    }
                    CResString strTitle(uTitleId);
                    CResString strPageTitle(uPageTitleId);

                    SetDlgItemText(
                        hdlg,
                        IDC_STATIC_SERVER_NAME,
                        strTitle.Get()
                        );

                    SetDlgItemText(
                        hdlg,
                        IDC_PageTitle,
                        strPageTitle.Get()
                        );

                    HWND hPageTitle = GetDlgItem(hdlg, IDC_PageTitle);
                    EnableWindow(hPageTitle, TRUE);

                    if (g_fDependentClient)
                    {                                                
                        ShowWindow(s_hSecComm, FALSE);
                    }
                    else
                    {                                                
                        EnableWindow(s_hSecComm, TRUE);
                    }

                    PropSheet_SetWizButtons(GetParent(hdlg),                                        
                                        (PSWIZB_NEXT)) ;
                }
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_WIZFINISH:
              case PSN_QUERYCANCEL:
              case PSN_WIZBACK:
                  SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                  iSuccess = 1;
                  break;

              case PSN_WIZNEXT:
                  {                                        
                      ASSERT(!g_fBatchInstall);
                      GetDlgItemText(hdlg, IDC_EDIT_ServerName, g_wcsServerName,
                          sizeof(g_wcsServerName)/sizeof(g_wcsServerName[0]));
                      
                      //
                      // Remove white spaces from g_wcsServerName
                      // We can do an in-place (destructive) copy since we remove
                      // characters and never add.
                      //
                      DWORD dwInCharIndex=0, dwOutCharIndex=0;
                      while(g_wcsServerName[dwInCharIndex] != 0)
                      {
                          if (!_istspace(g_wcsServerName[dwInCharIndex]))
                          {
                              g_wcsServerName[dwOutCharIndex] = g_wcsServerName[dwInCharIndex];
                              dwOutCharIndex++;
                          }
                          dwInCharIndex++;
                      }
                      g_wcsServerName[dwOutCharIndex] = 0;
                      
                      iSuccess = CheckServer(hdlg);
                      if (iSuccess==1)
                      {
                          //
                          // DS DLL needs the server name in registry
                          //
                          StoreServerPathInRegistry(g_wcsServerName);
                      }                  
                  }
                  break;
            }
            break;
        }

        default:
        {
            iSuccess = 0;
            break;
        }
    }

    return iSuccess;

} // MsmqServerNameDlgProc



//
// Stub functions for the DS client side RPC interface
// These functions are never called as Setup does not initiate a DS
// call that will trigger these callbacks.
//


/* [callback] */
HRESULT
S_DSQMSetMachinePropertiesSignProc( 
    /* [size_is][in] */ BYTE *abChallenge,
    /* [in] */ DWORD dwCallengeSize,
    /* [in] */ DWORD dwContext,
    /* [length_is][size_is][out][in] */ BYTE *abSignature,
    /* [out][in] */ DWORD *pdwSignatureSize,
    /* [in] */ DWORD dwSignatureMaxSize
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}


/* [callback] */
HRESULT
S_DSQMGetObjectSecurityChallengeResponceProc( 
    /* [size_is][in] */ BYTE *abChallenge,
    /* [in] */ DWORD dwCallengeSize,
    /* [in] */ DWORD dwContext,
    /* [length_is][size_is][out][in] */ BYTE *abCallengeResponce,
    /* [out][in] */ DWORD *pdwCallengeResponceSize,
    /* [in] */ DWORD dwCallengeResponceMaxSize
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}


/* [callback] */
HRESULT
S_InitSecCtx( 
    /* [in] */ DWORD dwContext,
    /* [size_is][in] */ UCHAR *pServerbuff,
    /* [in] */ DWORD dwServerBuffSize,
    /* [in] */ DWORD dwClientBuffMaxSize,
    /* [length_is][size_is][out] */ UCHAR *pClientBuff,
    /* [out] */ DWORD *pdwClientBuffSize
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\triggers.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    triggers.cpp

Abstract:

    Handles MSMQ Triggers Setup.

Author:

    Nela Karpel    (NelaK)   20-Aug-2000

Revision History:


--*/

#include "msmqocm.h"
#include <comdef.h>
#include <autorel2.h>
#include "service.h"
#include <mqtg.h>
#include <mqexception.h>
#include "comadmin.tlh"
#include "mqnames.h"
#include "ev.h"

#include "triggers.tmh"


//+-------------------------------------------------------------------------
//
//  Function:   RegisterTriggersDlls
//
//  Synopsis:   Registers or unregisters the mqtrig DLL
//
//--------------------------------------------------------------------------
void
RegisterTriggersDlls(
	const BOOL fRegister
	)
{
	//
	// Register Triggers Objects DLL
	//
	if ( fRegister )
	{		
        DebugLogMsg(L"Registering the Triggers Objects DLL...");
	}
	else
	{		
        DebugLogMsg(L"Unregistering the Triggers Objects DLL...");
	}
    LPWSTR szDllName = MQTRIG_DLL;
    try
    {
        RegisterDll(
            fRegister,
            FALSE,
            MQTRIG_DLL
            );

	        //
	        // Register Cluster Resource DLL only on 
	        // Advanced Server (ADS). Do not unregister.
	        //

	    if ( g_dwOS == MSMQ_OS_NTE && fRegister )
	    {		
            DebugLogMsg(L"Registering the Triggers Cluster DLL...");
            szDllName = MQTGCLUS_DLL;
            RegisterDll(
                fRegister,
                FALSE,
                MQTGCLUS_DLL
                );
	    }
    }
    catch(bad_win32_error e)
    {
        MqDisplayError(
            NULL, 
            IDS_TRIGREGISTER_ERROR,
            e.error(),
            szDllName
            );
    	throw exception();
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   CreateTriggersKey
//
//  Synopsis:   Creates Triggers subkey
//
//--------------------------------------------------------------------------
void
CreateTriggersKey (
    IN     const TCHAR  * szEntryName,
    IN OUT       HKEY    &hRegKey
	)
{
	DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
						REGKEY_TRIGGER_POS,
						szEntryName,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hRegKey,
						&dwDisposition
						);

    if (lResult != ERROR_SUCCESS)
	{
		MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, lResult, FALCON_REG_POS_DESC, szEntryName);		
		throw exception();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRegValue
//
//  Synopsis:   Sets registry value under Triggers subkey
//
//--------------------------------------------------------------------------
void
SetTriggersRegValue (
	IN HKEY& hKey,
    IN const TCHAR* szValueName,
    IN DWORD dwValueData
	)
{
    LONG lResult = RegSetValueEx( 
						hKey,
						szValueName,
						0,
						REG_DWORD,
						(BYTE *)&dwValueData,
						sizeof(DWORD)
						);

    RegFlushKey(hKey);

	if (lResult != ERROR_SUCCESS)
	{
		MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, lResult, szValueName);
		throw exception();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateTriggersRegSection
//
//  Synopsis:   Creates registry section with triggers parameters
//
//--------------------------------------------------------------------------
void
CreateTriggersRegSection (
	void
	)
{
	HKEY hKey;

	//
	// Write Configuration parametes to registry
	//
	CreateTriggersKey( REGKEY_TRIGGER_PARAMETERS, hKey );

	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_INITIAL_THREADS, CONFIG_PARM_DFLT_INITIAL_THREADS );
	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_MAX_THREADS, CONFIG_PARM_DFLT_MAX_THREADS );
	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_INIT_TIMEOUT, CONFIG_PARM_DFLT_INIT_TIMEOUT );
	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE, CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE );
	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_PRODUCE_TRACE_INFO, CONFIG_PARM_DFLT_PRODUCE_TRACE_INFO );
	SetTriggersRegValue( hKey, CONFIG_PARM_NAME_WRITE_TO_LOGQ, CONFIG_PARM_DFLT_WRITE_TO_LOGQ );


	RegCloseKey( hKey );

	//
	// Create key for triggers\rules data
	//
	TCHAR szRegPath[MAX_REGKEY_NAME_SIZE];

	_tcscpy( szRegPath, REGKEY_TRIGGER_PARAMETERS );
	_tcscat( szRegPath, REG_SUBKEY_TRIGGERS );
	CreateTriggersKey( szRegPath, hKey );
	RegCloseKey( hKey );

	_tcscpy( szRegPath, REGKEY_TRIGGER_PARAMETERS );
	_tcscat( szRegPath, REG_SUBKEY_RULES );
	CreateTriggersKey( szRegPath, hKey );
	RegCloseKey( hKey );
}

//+--------------------------------------------------------------
//
// Function: FormTriggersServiceDependencies
//
// Synopsis: Tells on which other services the Triggers service relies
//
//+--------------------------------------------------------------
static
void
FormTriggersServiceDependencies( OUT TCHAR *szDependencies)
{
    //
    // The service depends on the MSMQ service
    //
    lstrcpy(szDependencies, MSMQ_SERVICE_NAME);
    szDependencies += lstrlen(MSMQ_SERVICE_NAME) + 1;

    lstrcpy(szDependencies, TEXT(""));

} //FormTriggersServiceDependencies


//+-------------------------------------------------------------------------
//
//  Function:   InstallTriggersService
//
//  Synopsis:   Creates MSMQ Triggers service
//
//--------------------------------------------------------------------------
void
InstallTriggersService(
	void
	)
{    
    DebugLogMsg(L"Installing the Triggers service...");

    //
    // Form the dependencies of the service
    //
    TCHAR szDependencies[256] = {_T("")};
    FormTriggersServiceDependencies(szDependencies);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_TRIG_SERVICE_DESCRIPTION);        

    LPCWSTR xTRIGGERS_SERVICE_DISPLAY_NAME = L"Message Queuing Triggers";
    BOOL fRes = InstallService(
                    xTRIGGERS_SERVICE_DISPLAY_NAME,
                    TRIG_SERVICE_PATH,
                    szDependencies,
                    TRIG_SERVICE_NAME,
                    strDesc.Get()
                    );

    if ( !fRes )
	{
		throw exception();   
	}
}


//+-------------------------------------------------------------------------
//
//  Function: MQTrigServiceSetup
//
//  Synopsis: MSMQ Triggers Service Setup: install it and if needed to run it
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
void
MSMQTriggersServiceSetup()
{
    //
    // do not install triggers on dependent client
    //
    ASSERT(("Unable to install Message Queuing Triggers Service on Dependent Client", 
        !g_fDependentClient));

    InstallTriggersService();

    if (g_fUpgrade)
	{
        return;
    }
        
    if (!RunService(TRIG_SERVICE_NAME))
    {
		throw exception();
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteTriggersRegSection
//
//  Synopsis:   Deletes registry section with triggers parameters
//
//--------------------------------------------------------------------------
VOID
DeleteTriggersRegSection (
	void
	)
{
	RegDeleteKeyWithSubkeys(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS);
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveTriggersService
//
//  Synopsis:   Unregisters MSMQ Triggers Service
//
//--------------------------------------------------------------------------
BOOL
RemoveTriggersService (
	void
	)
{
    if (!StopService(TRIG_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing Triggers service could not be stopped.");
		return FALSE;
    }

    if (!RemoveService(TRIG_SERVICE_NAME))
    {        
        DebugLogMsg(L"The Message Queuing Triggers service could not be deleted.");
		return FALSE;    
	}

	return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetComponentsCollection
//
//  Synopsis:   Create Components collection for application
//
//--------------------------------------------------------------------------
ICatalogCollectionPtr
GetComponentsCollection(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApplication
	)
{
		//
		// Get the Key of MQTriggersApp application
		//
		_variant_t vKey;
		pApplication->get_Key(&vKey);

		//
		// Get components colletion associated with MQTriggersApp application
		//
		ICatalogCollectionPtr pCompCollection = pAppCollection->GetCollection(L"Components", vKey);

		pCompCollection->Populate();

		return pCompCollection.Detach();
}


//+-------------------------------------------------------------------------
//
//  Function:   IsTriggersComponentInstalled
//
//  Synopsis:   Check if triggers component is installed for given 
//				appllication
//
//--------------------------------------------------------------------------
bool
IsTriggersComponentInstalled(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApp
	)
{
	ICatalogCollectionPtr pCompCollection = GetComponentsCollection(pAppCollection, pApp);

	long count;
	pCompCollection->get_Count(&count);

	for ( int i = 0; i < count; i++ )
	{
		ICatalogObjectPtr pComp = pCompCollection->GetItem(i);

		_variant_t vDllName;
		pComp->get_Value(L"DLL", &vDllName);

		//
		// Form the full path to the service
		//
		WCHAR szFullDllPath[MAX_PATH];
		wsprintf(szFullDllPath, L"%s\\%s", g_szSystemDir, MQTRXACT_DLL);

		if ( _wcsicmp(vDllName.bstrVal, szFullDllPath) == 0 )
		{
			return true;
		}
	}

	return false;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterComponentInComPlus
//
//  Synopsis:   Transactional object registration
//
//--------------------------------------------------------------------------
void
UnregisterComponentInComPlus(
	VOID
	)
{
	try
	{
		//
		// Create AdminCatalog Obect - The top level administration object
		//
		ICOMAdminCatalogPtr pCatalog;

		HRESULT hr = pCatalog.CreateInstance(__uuidof(COMAdminCatalog));
		if ( FAILED(hr) )
		{
			throw _com_error(hr);
		}

		//
		// Get Applications Collection
		//
		ICatalogCollectionPtr pAppCollection = pCatalog->GetCollection(L"Applications");
		pAppCollection->Populate();

		long count;
		pAppCollection->get_Count(&count);

		//
		// Go through the applications, find MQTriggersApp and delete it
		//
		for ( int i = 0; i < count; i++ )
		{
			ICatalogObjectPtr pApp = pAppCollection->GetItem(i);

			_variant_t vName;
			pApp->get_Name(&vName);

			if ( _wcsicmp(vName.bstrVal, xTriggersComplusApplicationName) == 0 )
			{
				if ( IsTriggersComponentInstalled(pAppCollection, pApp) )
				{
					pAppCollection->Remove(i);
					break;
				}
			}
		}

		pAppCollection->SaveChanges();
	}
	catch(_com_error& e)
	{
		MqDisplayError(NULL, IDS_COMPLUS_UNREGISTER_ERROR, e.Error());
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   TriggersInstalled
//
//  Synopsis:   Check installation of triggers, either Resource Kit triggers 
//              or MSMQ 3.0 triggers.
//
//--------------------------------------------------------------------------
bool 
TriggersInstalled(
    bool * pfMsmq3TriggersInstalled
    )
{
    WCHAR DebugMsg[255];
    DebugLogMsg(L"Opening triggers service for query configuration...");
    CServiceHandle hService(OpenService(g_hServiceCtrlMgr, TRIG_SERVICE_NAME, SERVICE_QUERY_CONFIG));
    if (hService == NULL)
    {
        DWORD rc = GetLastError();
        wsprintf(DebugMsg, L"Failed to open triggers service (error=%d), assuming triggers service does not exist", rc);
        DebugLogMsg(DebugMsg);
        ASSERT(rc == ERROR_SERVICE_DOES_NOT_EXIST);
        return false;
    }

    DebugLogMsg(L"Query configuration of the triggers service...");
    BYTE ConfigData[4096];
    QUERY_SERVICE_CONFIG * pConfigData = reinterpret_cast<QUERY_SERVICE_CONFIG*>(&ConfigData);
    DWORD BytesNeeded;
    BOOL rc = QueryServiceConfig(hService, pConfigData, sizeof(ConfigData), &BytesNeeded);
    wsprintf(DebugMsg, L"Query configuration status=%d", rc);
    DebugLogMsg(DebugMsg);
    ASSERT(("Query triggers service configuration must succeed at this point", rc));

    if (wcsstr(pConfigData->lpBinaryPathName, TRIG_SERVICE_PATH) != NULL)
    {
        DebugLogMsg(L"Triggers service binary file is MSMQ 3.0 triggers binary");
        if (pfMsmq3TriggersInstalled != NULL)
        {
            (*pfMsmq3TriggersInstalled) = true;
        }
        return true;
    }

    DebugLogMsg(L"Triggers service binary file is not MSMQ 3.0 binary");
    if (pfMsmq3TriggersInstalled != NULL)
    {
        (*pfMsmq3TriggersInstalled) = false;
    }
    return true;
}


//+-------------------------------------------------------------------------
//
//  Function:   UpgradeResourceKitTriggersRegistry
//
//  Synopsis:   Upgrade Resource Kit triggers database in registry
//
//--------------------------------------------------------------------------
static
void
UpgradeResourceKitTriggersRegistry(
    void
    )
{
    WCHAR TriggersListKey[255];
    wsprintf(TriggersListKey, L"%s%s", REGKEY_TRIGGER_PARAMETERS, REG_SUBKEY_TRIGGERS);
    WCHAR DebugMsg[255];
    wsprintf(DebugMsg, L"Opening registry key '%s' for enumeration...", TriggersListKey);
    DebugLogMsg(DebugMsg);

    LONG rc;
    CAutoCloseRegHandle hKey;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TriggersListKey, 0, KEY_ENUMERATE_SUB_KEYS, &hKey);
    if (rc != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, rc, FALCON_REG_POS_DESC, TriggersListKey);
        throw exception();
    }

    DebugLogMsg(L"Enumerating triggers definitions registry keys...");
    for (DWORD ix = 0; ; ++ix)
    {
        WCHAR SubkeyName[255];
        DWORD SubkeyNameLength = TABLE_SIZE(SubkeyName);
        rc = RegEnumKeyEx(hKey, ix, SubkeyName, &SubkeyNameLength, NULL, NULL, NULL, NULL);
        if (rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA)
        {
            wsprintf(DebugMsg, L"Failed to enumerate subkeys (error=%d), assuming no more subkeys to enumerate", rc);
            DebugLogMsg(DebugMsg);
            return;
        }

        WCHAR TriggerDefinitionKey[255];
        wsprintf(TriggerDefinitionKey, L"%s\\%s", TriggersListKey, SubkeyName);
        wsprintf(DebugMsg, L"Opening registry key '%s' for set value...", TriggerDefinitionKey);
        DebugLogMsg(DebugMsg);
        CAutoCloseRegHandle hKey1;
        rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TriggerDefinitionKey, 0, KEY_SET_VALUE, &hKey1);
        if (rc != ERROR_SUCCESS)
        {
            MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, rc, TriggerDefinitionKey);
            throw exception();
        }

        DebugLogMsg(L"Setting value 'MsgProcessingType' to 0...");
        DWORD Zero = 0;
        rc = RegSetValueEx(hKey1, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, REG_DWORD, reinterpret_cast<BYTE*>(&Zero), sizeof(DWORD));
        wsprintf(DebugMsg, L"Setting 'MsgProcessingType' for key '%s', status=%d", TriggerDefinitionKey, rc);
        DebugLogMsg(DebugMsg);
        ASSERT(("Setting registry value must succeed here", rc == ERROR_SUCCESS));
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveResourceKitTriggersProgramFiles
//
//  Synopsis:   Remove the program files of Resource Kit triggers
//
//--------------------------------------------------------------------------
static
void
RemoveResourceKitTriggersProgramFiles(
    void
    )
{
    DebugLogMsg(L"Query registry for the ProgramFiles directory...");
    WCHAR DebugMsg[255];
    CAutoCloseRegHandle hKey;
    LONG rc;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion", 0, KEY_QUERY_VALUE, &hKey);
    if (rc != ERROR_SUCCESS)
    {
        wsprintf(DebugMsg, L"Failed to get the ProgramFiles directory (error=%d), proceed with upgrade anyway", rc);
        DebugLogMsg(DebugMsg);
        return;
    }

    WCHAR Path[MAX_PATH];
    DWORD cbPath = sizeof(Path);
    rc = RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, NULL, reinterpret_cast<BYTE*>(Path), &cbPath);
    if (rc != ERROR_SUCCESS)
    {
        wsprintf(DebugMsg, L"Failed to query the ProgramFilesDir registry value (error=%d), proceed with upgrade anyway", rc);
        DebugLogMsg(DebugMsg);
        return;
    }

    wcscat(Path, L"\\MSMQ Triggers");
    DeleteFilesFromDirectoryAndRd(Path);
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveResourceKitTriggersFromAddRemovePrograms
//
//  Synopsis:   Unregister Resource Kit triggers from ARP control panel applet
//
//--------------------------------------------------------------------------
static
void
RemoveResourceKitTriggersFromAddRemovePrograms(
    void
    )
{
    DebugLogMsg(L"Removing Resource Kit triggers from Add/Remove Programs control panel applet...");
    WCHAR DebugMsg[255];

    LONG rc;
    rc = RegDeleteKey(
             HKEY_LOCAL_MACHINE, 
             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Management\\ARPCache\\MSMQ Triggers"
             );
    if (rc != ERROR_SUCCESS)
    {
        wsprintf(DebugMsg, L"Failed to delete registry key 'ARPCache\\MSMQ Triggers', error=%d, proceed anyway", rc);
        DebugLogMsg(DebugMsg);
    }

    rc = RegDeleteKey(
             HKEY_LOCAL_MACHINE, 
             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSMQ Triggers"
             );
    if (rc != ERROR_SUCCESS)
    {
        wsprintf(DebugMsg, L"Failed to delete registry key 'Uninstall\\MSMQ Triggers', error=%d, proceed anyway", rc);
        DebugLogMsg(DebugMsg);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   UpgradeResourceKitTriggers
//
//  Synopsis:   Upgrade Resource Kit triggers:
//              Unregister reskit triggers DLLs,
//              Upgrade reskit triggers database in registry,
//              Remove reskit triggers service,
//              Remove reskit triggers program file,
//              Remove reskit triggers from Add/Remove Programs.
//              MSMQ 3.0 triggers DLLs and service are registered afterwards by caller.
//
//--------------------------------------------------------------------------
static
void 
UpgradeResourceKitTriggers( 
    void
    )
{
    DebugLogMsg(L"Stopping the Resource Kit triggers service...");
    if (!StopService(TRIG_SERVICE_NAME))
    {
        DebugLogMsg(L"Failed to stop the Resource Kit triggers service");
        throw exception();
    }

    DebugLogMsg(L"Resource Kit triggers service is stopped, unregistering Resource Kit triggers DLLs...");
    try
    {
        RegisterDll(FALSE, FALSE, L"TRIGOBJS.DLL");
        DebugLogMsg(L"Successfully unregistered Resource Kit triggers COM object");
        RegisterDll(FALSE, FALSE, L"TRIGSNAP.DLL");
        DebugLogMsg(L"Successfully unregistered Resource Kit triggers Snap-In");
    }
    catch(bad_win32_error e)
    {
        DebugLogMsg(L"Failed to unregister Resource Kit triggers DLLs, proceed with upgrade anyway");
    }

    DebugLogMsg(L"Upgrading Resource Kit triggers database in registry");
    UpgradeResourceKitTriggersRegistry();

    DebugLogMsg(L"Uninstalling the Resource Kit triggers service...");
    if (!RemoveService(TRIG_SERVICE_NAME))
    {
        DebugLogMsg(L"Failed to uninstall the Resource Kit triggers service");
        throw exception();
    }

    RemoveResourceKitTriggersProgramFiles();

    RemoveResourceKitTriggersFromAddRemovePrograms();
}


//+-------------------------------------------------------------------------
//
//  Function:   InstallMSMQTriggers
//
//  Synopsis:   Main installation routine
//
//--------------------------------------------------------------------------
BOOL
InstallMSMQTriggers (
	void
	)
{
    TickProgressBar(IDS_PROGRESS_INSTALL_TRIGGERS);

	//
	// Initialize COM for use of COM+ APIs.
	// Done in this context to match the place of com errors catching.
	//
	try
	{
        if (g_fUpgrade)
        { 
            bool fMsmq3TriggersInstalled;
            bool rc = TriggersInstalled(&fMsmq3TriggersInstalled);
            DBG_USED(rc);
            ASSERT(("OS upgrade, triggers must be installed at this point", rc));

            if (fMsmq3TriggersInstalled)
            {
                DebugLogMsg(L"MSMQ 3.0 triggers service is installed, only re-register DLLs");
                RegisterTriggersDlls(TRUE);
                return TRUE;
            }
          
            //
            // Handle unregisteration and upgrade of Resource Kit triggres and fall thru
            //
            UpgradeResourceKitTriggers();
        }


        CreateTriggersRegSection();
	
		RegisterTriggersDlls(TRUE);				

		MSMQTriggersServiceSetup();

		return TRUE;
	}
	catch(const _com_error&)
	{	
	}
	catch(const exception&)
	{
	}

	RemoveTriggersService();
	RegisterTriggersDlls(FALSE);
	DeleteTriggersRegSection();
	CoUninitialize();
	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnInstallMSMQTriggers
//
//  Synopsis:   Main installation routine
//
//--------------------------------------------------------------------------
BOOL
UnInstallMSMQTriggers (
	void
	)
{
    TickProgressBar(IDS_PROGRESS_REMOVE_TRIGGERS);

	if (!RemoveTriggersService())
    {
        return FALSE;
    }

	CoInitialize(NULL);

	RegisterTriggersDlls(FALSE);

	DeleteTriggersRegSection();

	UnregisterComponentInComPlus();

	CoUninitialize();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\setupdef.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    setupdef.h

Abstract:

    Various definitions.

Author:


--*/

#ifndef __SETUPDEF_H
#define __SETUPDEF_H

#define SERVICE_DSSRV  SERVICE_BSC

//
// Setup modes
//
#define INSTALL     (1)
#define DONOTHING   (2)  // Re-install or Re-remove
#define REMOVE      (3)

//
//
// Definitions for directories
//
#define  OCM_DIR_DRIVERS             TEXT("\\drivers")          // Under system32
#define  OCM_DIR_MSMQ_SETUP_EXCHN    TEXT("\\setup\\exchconn")  // Under MSMQ root
#define  OCM_DIR_WIN_HELP            TEXT("\\help")             // Under winnt
#define LQS_SUBDIRECTORY_NAME TEXT("LQS") //BugBug: should be global,and used by setup and qm\lqs.cpp

//
// Definition for iis extension
//
#define PARENT_PATH             TEXT("/LM/W3Svc/1/Root/")
#define ROOT                    TEXT("/")
#define MSMQ_IISEXT_NAME        TEXT("MSMQ")
#define DEFAULT_WEB_SERVER_PATH TEXT("/LM/W3Svc/1")

//
// Definitions for MSMQ 1.0
//
#define  OCM_DIR_SDK                 TEXT("\\sdk")
#define  OCM_DIR_SDK_DEBUG           TEXT("\\sdk\\debug")
#define  OCM_DIR_SETUP               TEXT("\\setup")
#define  OCM_DIR_INSTALL             TEXT("\\install")
#define  MSMQ_ACME_SHORTCUT_GROUP    TEXT("Microsoft Message Queue")
#define  MSMQ1_INSTALL_SHARE_NAME    TEXT("msmqinst")

//
// Maximum string size
//
#define MAX_STRING_CHARS 1024

//
// Locale aware strings compare
//
#define  OcmStringsEqual(str1, str2)   (0 == CompareStringsNoCase(str1, str2))

//
// Operations to be performed on the DS libraries
//
#define INITIALIZE  0
#define LOAD        1
#define FREE        2

#define LOG_FILENAME            TEXT("msmqinst.log")

//
// DLL names
//
#define MQUTIL_DLL   TEXT("MQUTIL.DLL")
#define MQSEC_DLL    TEXT("MQSEC.DLL")
#define ACTIVEX_DLL  TEXT("MQOA.DLL")
#define MQRT_DLL     TEXT("MQRT.DLL")
#define SNAPIN_DLL   TEXT("MQSNAP.DLL")
#define MQMAILOA_DLL TEXT("MQMAILOA.DLL")
#define MQMIG_EXE    TEXT("MQMIG.EXE")
#define MQISE_DLL    TEXT("MQISE.DLL")

#define MQTRIG_DLL	 TEXT("MQTRIG.DLL")
#define MQTRXACT_DLL TEXT("mqgentr.dll")
#define MQTGCLUS_DLL TEXT("mqtgclus.dll")

#define PGM_DLL      TEXT("WshRm.dll")

#define MAPPING_FILE TEXT("sample_map.xml")

//
// Definitions for MSMQ Win95 migration DLL
//

//
// Note: MQMIG95_INFO_FILENAME used to be a .ini file. Its extension 
// changed to .txt to work around a problem in GUI mode setup (.ini files "disappear")
// - Bug #4221, YoelA, 15-Mar-99
//
#define  MQMIG95_INFO_FILENAME     TEXT("msmqinfo.txt")
#define  MQMIG95_MSMQ_SECTION      TEXT("msmq")
#define  MQMIG95_MSMQ_DIR          TEXT("directory")
#define  MQMIG95_MSMQ_TYPE         TEXT("type")
#define  MQMIG95_MSMQ_TYPE_IND     TEXT("IND")
#define  MQMIG95_MSMQ_TYPE_DEP     TEXT("DEP")

//
// Useful macros
//
#define SERVER_INSTALL_COMMAND   TEXT("%sregsvr32.exe -s %s%s")
#define SERVER_UNINSTALL_COMMAND TEXT("%sregsvr32.exe -s -u %s%s")


//
// Service stop / start intervals
//
#define MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES 10
#define WAIT_INTERVAL 100

//
// Setup subcomponents
//
#define MSMQ                    TEXT("msmq")
#define MSMQ_CORE_SUBCOMP       TEXT("msmq_Core")
#define MQDSSERVICE_SUBCOMP     TEXT("msmq_MQDSService")
#define TRIGGERS_SUBCOMP        TEXT("msmq_TriggersService")
#define HTTP_SUPPORT_SUBCOMP    TEXT("msmq_HTTPSupport")
#define AD_INTEGRATED_SUBCOMP   TEXT("msmq_ADIntegrated")
#define ROUTING_SUBCOMP         TEXT("msmq_RoutingSupport")
#define LOCAL_STORAGE_SUBCOMP   TEXT("msmq_LocalStorage")

#endif // __SETUPDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\upgclus.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgclus.cpp

Abstract:

    Handle upgrade of MSMQ cluster resource from NT 4 and Windows 2000 Beta3

Author:

    Shai Kariv  (shaik)  26-May-1999

Revision History:


--*/

#include "msmqocm.h"
#include "ocmres.h"
#include "upgclus.h"

#include "upgclus.tmh"

class CClusterUpgradeException
{
};

#pragma warning(disable: 4702) //C4702: unreachable code

static
VOID
DisplayMessage(
    UINT  title, 
    UINT  msg,
    ...
    )
/*++

Routine Description:

    Display information message to user while upgrading msmq cluster resources.

Arguments:

    title - ID of title string for the message.

    msg - ID of body string for the message.

Return Value:

    None.

--*/
{
    va_list args;
    va_start(args, msg);

    vsDisplayMessage(NULL,  MB_OK | MB_TASKMODAL, title, msg, 0, args);

    va_end(args);

} //DisplayMessage


VOID
LoadClusapiDll(
    HINSTANCE * phClusapiDll
    )
/*++

Routine Description:

    Load clusapi.dll and get addresses of common cluster APIs

Arguments:

    phClusapiDll - points to clusapi.dll handle, on output.

Return Value:

    None.

--*/
{
    if (FAILED(StpLoadDll(L"clusapi.dll", phClusapiDll)))
    {
        throw CClusterUpgradeException();
    }

    pfOpenCluster      = (OpenCluster_ROUTINE)GetProcAddress(*phClusapiDll, "OpenCluster");
    ASSERT(pfOpenCluster != NULL);

    pfCloseCluster     = (CloseCluster_ROUTINE)GetProcAddress(*phClusapiDll, "CloseCluster");
    ASSERT(pfCloseCluster != NULL);

    pfClusterOpenEnum  = (ClusterOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterOpenEnum");
    ASSERT(pfClusterOpenEnum != NULL);

    pfClusterEnum      = (ClusterEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterEnum");
    ASSERT(pfClusterEnum != NULL);

    pfClusterCloseEnum = (ClusterCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterCloseEnum");
    ASSERT(pfClusterCloseEnum != NULL);

    pfCloseClusterResource = (CloseClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "CloseClusterResource");
    ASSERT(pfCloseClusterResource != NULL);

    pfCloseClusterGroup = (CloseClusterGroup_ROUTINE)GetProcAddress(*phClusapiDll, "CloseClusterGroup");
    ASSERT(pfCloseClusterGroup != NULL);

    pfClusterResourceControl = (ClusterResourceControl_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceControl");
    ASSERT(pfClusterResourceControl != NULL);

    pfOpenClusterResource = (OpenClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OpenClusterResource");
    ASSERT(pfOpenClusterResource != NULL);

    pfClusterGroupEnum = (ClusterGroupEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupEnum");
    ASSERT(pfClusterGroupEnum != NULL);

    pfClusterGroupOpenEnum = (ClusterGroupOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupOpenEnum");
    ASSERT(pfClusterGroupOpenEnum != NULL);

    pfClusterGroupCloseEnum = (ClusterGroupCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupCloseEnum");
    ASSERT(pfClusterGroupCloseEnum != NULL);

    pfOpenClusterGroup = (OpenClusterGroup_ROUTINE)GetProcAddress(*phClusapiDll, "OpenClusterGroup");
    ASSERT(pfOpenClusterGroup != NULL);

    pfCreateClusterResourceType = (CreateClusterResourceType_ROUTINE)GetProcAddress(*phClusapiDll, "CreateClusterResourceType");
    ASSERT(pfCreateClusterResourceType != NULL);

    pfCreateClusterResource = (CreateClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "CreateClusterResource");
    ASSERT(pfCreateClusterResource != NULL);

    pfOnlineClusterResource = (OnlineClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OnlineClusterResource");
    ASSERT(pfOnlineClusterResource != NULL);

    pfDeleteClusterResource = (DeleteClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "DeleteClusterResource");
    ASSERT(pfDeleteClusterResource != NULL);

    pfOfflineClusterResource = (OfflineClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OfflineClusterResource");
    ASSERT(pfOfflineClusterResource != NULL);

    pfDeleteClusterResourceType = (DeleteClusterResourceType_ROUTINE)GetProcAddress(*phClusapiDll, "DeleteClusterResourceType");
    ASSERT(pfDeleteClusterResourceType != NULL);

    pfClusterResourceOpenEnum = (ClusterResourceOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceOpenEnum");
    ASSERT(pfClusterResourceOpenEnum != NULL);

    pfClusterResourceEnum = (ClusterResourceEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceEnum");
    ASSERT(pfClusterResourceEnum != NULL);

    pfAddClusterResourceDependency = (AddClusterResourceDependency_ROUTINE)GetProcAddress(*phClusapiDll, "AddClusterResourceDependency");
    ASSERT(pfAddClusterResourceDependency != NULL);

    pfRemoveClusterResourceDependency = (RemoveClusterResourceDependency_ROUTINE)GetProcAddress(*phClusapiDll, "RemoveClusterResourceDependency");
    ASSERT(pfRemoveClusterResourceDependency != NULL);

    pfClusterResourceCloseEnum = (ClusterResourceCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceCloseEnum");
    ASSERT(pfClusterResourceCloseEnum != NULL);
} //LoadClusapiDll


HCLUSTER
OpenClusterWithRetry(
    VOID
    )
/*++

Routine Description:

    Wrapper for OpenCluster.
    Retry until success or user aborts.

Arguments:

    None.

Return Value:

    HCLUSTER as returned by OpenCluster.

--*/
{
    for (;;)
    {
        HCLUSTER hCluster = OpenCluster(NULL);
        if (hCluster != NULL)
        {
            return hCluster;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenCluster_ERR, GetLastError()))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterWithRetry


HGROUP
OpenClusterGroupWithRetry(
    HCLUSTER hCluster,
    LPCWSTR  pwzGroupName
    )
/*++

Routine Description:

    Wrapper for OpenClusterGroupWithRetry.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    pwzGroupName - The name of the group to open.

Return Value:

    HGROUP as returned by OpenClusterGroup.

--*/
{
    for (;;)
    {
        HGROUP hGroup = OpenClusterGroup(hCluster, pwzGroupName);
        if (hGroup != NULL)
        {
            return hGroup;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenClusterGroup_ERR, GetLastError(), pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterGroupWithRetry


HRESOURCE
OpenClusterResourceWithRetry(
    HCLUSTER hCluster,
    LPCWSTR  pwzResourceName
    )
/*++

Routine Description:

    Wrapper for OpenClusterResource.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    pwzResourceName - Name of resource to open.

Return Value:

    HRESOURCE as returned by OpenClusterResource.

--*/
{
    for (;;)
    {
        HRESOURCE hResource = OpenClusterResource(hCluster, pwzResourceName);
        if (hResource != NULL)
        {
            return hResource;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenClusterResource_ERR, GetLastError(), pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterResourceWithRetry


HCLUSENUM
ClusterOpenEnumWithRetry(
    HCLUSTER hCluster,
    DWORD    dwType
    )
/*++

Routine Description:

    Wrapper for ClusterOpenEnum.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    dwType   - Type of objects to be enumerated.

Return Value:

    HCLUSENUM as returned by ClusterOpenEnum.

--*/
{
    for (;;)
    {
        HCLUSENUM hClusEnum = ClusterOpenEnum(hCluster, dwType);
        if (hClusEnum != NULL)
        {
            return hClusEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_Enumerate_ERR, GetLastError()))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterOpenEnumWithRetry


HGROUPENUM
ClusterGroupOpenEnumWithRetry(
    LPCWSTR pwzGroupName,
    HGROUP  hGroup,
    DWORD   dwType
    )
/*++

Routine Description:

    Wrapper for ClusterGroupOpenEnum..
    Retry until success or user aborts.

Arguments:

    pwzGroupName - Name of group to open enumerator for.

    hGroup - Handle to group to open enumerator for.

    dwType - Type of objects to enumerate.

Return Value:

    HGROUPENUM as returned by ClusterGroupOpenEnum.

--*/
{
    for (;;)
    {
        HGROUPENUM hGroupEnum = ClusterGroupOpenEnum(hGroup, dwType);
        if (hGroupEnum != NULL)
        {
            return hGroupEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateGroup_ERR, GetLastError(), pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterGroupOpenEnumWithRetry


HRESENUM
ClusterResourceOpenEnumWithRetry(
    LPCWSTR   pwzResourceName,
    HRESOURCE hResource,
    DWORD     dwType
    )
/*++

Routine Description:

    Wrapper for ClusterResourceOpenEnum..
    Retry until success or user aborts.

Arguments:

    pwzResourceName - Name of resource to open enumerator for.

    hResource - Handle to resource to open enumerator for.

    dwType - Type of objects to enumerate.

Return Value:

    HRESENUM as returned by ClusterResourceOpenEnum.

--*/
{
    for (;;)
    {
        HRESENUM hResEnum = ClusterResourceOpenEnum(hResource, dwType);
        if (hResEnum != NULL)
        {
            return hResEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateResource_ERR, GetLastError(), pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterResourceOpenEnumWithRetry


DWORD
ClusterEnumWithRetry(
    HCLUSENUM hClusEnum,
    DWORD     dwIndex,
    LPDWORD   lpdwType,
    AP<WCHAR> &pwzName,
    LPDWORD   lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    hClusEnum - Enumeration handle.

    dwIndex - Index of the object to return.

    lpdwType - On output, points to type of object returned.

    pwzName - On output, points to pointer to name of returned object.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterEnum(hClusEnum, dwIndex, lpdwType, pwzName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzName.free();
            cbName = (*lpcbName) + 1;
            pwzName = new WCHAR[cbName];
            if (pwzName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_Enumerate_ERR, status))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterEnumWithRetry


DWORD
ClusterGroupEnumWithRetry(
    LPCWSTR    pwzGroupName,
    HGROUPENUM hGroupEnum,
    DWORD      dwIndex,
    LPDWORD    lpdwType,
    AP<WCHAR> &pwzResourceName,
    LPDWORD    lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterGroupEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    pwzGroupName - Name of group to enumerate thru.

    hGroupEnum - Group enumeration handle.

    dwIndex - Index of the resource to return.

    lpdwType - On output, points to type of object returned.

    pwzResourceName - On output, points to pointer to name of returned resource.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterGroupEnum(hGroupEnum, dwIndex, lpdwType, pwzResourceName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzResourceName.free();
            cbName = (*lpcbName) + 1;
            pwzResourceName = new WCHAR[cbName];
            if (pwzResourceName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateGroup_ERR, status, pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterGroupEnumWithRetry


DWORD
ClusterResourceEnumWithRetry(
    LPCWSTR  pwzResource,
    HRESENUM hResEnum,
    DWORD    dwIndex,
    LPDWORD  lpdwType,
    AP<WCHAR> &pwzName,
    LPDWORD  lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterResourceEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    pwzResource - Points to name of resource to enumerate on.

    hResEnum - Enumeration handle.

    dwIndex - Index of the object to return.

    lpdwType - On output, points to type of object returned.

    pwzName - On output, points to pointer to name of returned object.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterResourceEnum(hResEnum, dwIndex, lpdwType, pwzName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzName.free(); 
            cbName = (*lpcbName) + 1;
            pwzName = new WCHAR[cbName];
            if (pwzName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateResource_ERR, status, pwzResource))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterResourceEnumWithRetry


VOID
RemoveRegistryCheckpointWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResourceName,
    LPWSTR    pwzCheckpoint
    )
/*++

Routine Description:

    Delete registry checkpoint for a resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of the resource to operate on.

    pwzResourceName - Points to name of the resource to operate on.

    pwzCheckpoint - Points to name of registry checkpoint.

Return Value:

    None.

--*/
{ 
    for (;;)
    {
        DWORD cbReturnedSize = 0;
        DWORD status = ClusterResourceControl(
            hResource, 
            NULL, 
            CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
            pwzCheckpoint,
            numeric_cast<DWORD> ((wcslen(pwzCheckpoint) + 1) * sizeof(WCHAR)),
            NULL,
            0,
            &cbReturnedSize
            );
        if (status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_DelRegistryCp_ERR, status, pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }
} //RemoveRegistryCheckpointWithRetry


VOID
BringOnlineNewResourceWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResourceName
    )
/*++

Routine Description:

    Issue an online request for the new msmq resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of msmq resource to bring online.

    pwzResourceName - Points to name of msmq resource to bring online.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = OnlineClusterResource(hResource);
        if (status == ERROR_SUCCESS || status == ERROR_IO_PENDING)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OnlineResource_ERR, status, pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }
} //BringOnlineNewResourceWithRetry


VOID
DeleteOldResourceWithRetry(
    HRESOURCE hResource
    )
/*++

Routine Description:

    Delete the old msmq resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of old msmq resource to delete.

Return Value:

    None.

--*/
{
    //
    // Resource should be offline now, but try anyway.
    //
    OfflineClusterResource(hResource);

    for (;;)
    {
        DWORD status = DeleteClusterResource(hResource);
        if (status == ERROR_SUCCESS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_ClusterUpgradeDeleteResource_ERR, status))
        {
            throw CClusterUpgradeException();
        }
    }
} //DeleteOldResourceWithRetry


VOID
DeleteOldResourceTypeWithRetry(
    VOID
    )
/*++

Routine Description:

    Delete the old msmq resource type (Microsoft Message Queue Server).
    Retry until success or user aborts.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    CResString strOldType(IDS_ClusterResourceOldTypeName);
    for (;;)
    {
        DWORD status = DeleteClusterResourceType(hCluster, L"Microsoft Message Queue Server");
        if (status == ERROR_SUCCESS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_DeleteResourceType_ERR, status, strOldType.Get()))
        {
            throw CClusterUpgradeException();
        }
    }
} //DeleteOldResourceTypeWithRetry


VOID
AddClusterResourceDependencyWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResource,
    HRESOURCE hDependsOn,
    LPCWSTR   pwzDependsOn
    )
/*++

Routine Description:

    Wrapper for AddClusterResourceDependency.
    Retry until success or user aborts.

Arguments:

    hResource - Handle to the dependent resource.

    pwzResource - Name of the dependent resource.

    hDependsOn - Handle to the resource that the resource identified by hResource should depend on.

    pwzDependsOn - Name of the resource that the resource identified by hResource should depend on.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = AddClusterResourceDependency(hResource, hDependsOn);
        if (status == ERROR_SUCCESS || status == ERROR_DEPENDENCY_ALREADY_EXISTS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_AddClusterResourceDependency_ERR, status, pwzResource,
                                               pwzDependsOn))
        {
            throw CClusterUpgradeException();
        }
    }
} //AddClusterResourceDependencyWithRetry


VOID
RemoveClusterResourceDependencyWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResource,
    HRESOURCE hDependsOn,
    LPCWSTR   pwzDependsOn
    )
/*++

Routine Description:

    Wrapper for RemoveClusterResourceDependency.
    Retry until success or user aborts.

Arguments:

    hResource - Handle to the dependent resource.

    pwzResourc - Name of the dependent resource.

    hDependsOn - Handle to the resource that the resource identified by hResource currently depends on.

    pwzDependsOn - Name of the resource that the resource identified by hResource currently depends on.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = RemoveClusterResourceDependency(hResource, hDependsOn);
        if (status == ERROR_SUCCESS || status == ERROR_DEPENDENCY_NOT_FOUND)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_RemoveClusterResourceDependency_ERR, status,
                                               pwzResource, pwzDependsOn))
        {
            throw CClusterUpgradeException();
        }
    }
} //RemoveClusterResourceDependency







static
bool
GenerateStrongCryptoKey(
    VOID
    )
/*++

Routine Description:

    Handle bug 430413: Must generate 128 bit crypto key for the old
    MSMQ resource to properly report its type.

Arguments:

    None

Return Value:

    true - Strong crypto key for msmq was successfully generated.

    false - Strong crypto key for msmq was not generated, either b/c
            the system is not 128 bit or some other failure accured.

--*/
{
    HCRYPTPROV hProv = NULL;
    if (!CryptAcquireContext( 
            &hProv,
            MSMQ_CRYPTO128_DEFAULT_CONTAINER,
            MS_ENHANCED_PROV,
            PROV_RSA_FULL,
            CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET
            ))
    {
        //
        // Failed to generate new key container.
        // Maybe it already exists. Try to open it.
        //
        if (!CryptAcquireContext( 
                &hProv,
                MSMQ_CRYPTO128_DEFAULT_CONTAINER,
                MS_ENHANCED_PROV,
                PROV_RSA_FULL,
                CRYPT_MACHINE_KEYSET
                ))
        {
            //
            // Failed to open key container.
            // Probably system is not 128 bit.
            //
            return false;
        }
    }

    HCRYPTKEY hKeyxKey = NULL;
    if (CryptGenKey(hProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hKeyxKey))
    {
        CryptDestroyKey(hKeyxKey);
    }
    else
    {
        ASSERT(("CryptGenKey failed for AT_KEYEXCHANGE!", 0));
    }
    
    HCRYPTKEY hSignKey = NULL;
    if (CryptGenKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hSignKey))
    {
        CryptDestroyKey(hSignKey);
    }
    else
    {
        ASSERT(("CryptGenKey failed for AT_SIGNATURE!", 0));
    }
    
    CryptReleaseContext(hProv, 0);
    return true;

} // GenerateStrongCryptoKey


HRESOURCE
OpenResourceOfSpecifiedType(
    LPCWSTR pwzResource,
    LPCWSTR pwzType 
    )
/*++

Routine Description:

    Check if the specified resource is of the specified type.

Arguments:

    pwzResource - The name of the resource to check.

    pwzType - The type to check.

Return Value:

    HRESOURCE of the specified resource.

    NULL - The resource is not of the specified type.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    CClusterResource hResource(OpenClusterResourceWithRetry(hCluster, pwzResource));

    ASSERT(("assuming length of type name < 255", wcslen(pwzType) < 255));
    WCHAR wzTypeName[255] = L"";

    for (;;)
    {
        DWORD cbReturnedSize = 0;
        DWORD status = ClusterResourceControl(
            hResource, 
            NULL, 
            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
            NULL,
            0,
            wzTypeName,
            sizeof(wzTypeName),
            &cbReturnedSize
            );

        if (status == ERROR_SUCCESS)
        {
            if (OcmStringsEqual(wzTypeName, pwzType))
            {
                return hResource.detach();
            }

            return NULL;
        }

        if (status == ERROR_MORE_DATA)
        {
            return NULL;
        }

        if (OcmStringsEqual(L"Microsoft Message Queue Server", pwzType))
        {
            //
            // Bug 430413: Fail to query old msmq resource for its type, 
            // if system is 128 bit. 
            // Fix: Generate 128 bit key and ask user to reboot.
            //
            if (GenerateStrongCryptoKey())
            {
                MqDisplayError(NULL, IDS_STRONG_CRYPTO_ERROR, 0);
                throw CClusterUpgradeException();
            }
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_QUERY_RESOURCE_TYPE_ERR, status, pwzResource))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenResourceOfSpecifiedType


HRESOURCE
OpenOldMsmqResourceInGroup(
    HCLUSTER hCluster,
    LPCWSTR  pwzGroupName,
    HGROUP * phGroup,
    LPWSTR   pwzOldResource
    )
/*++

Routine Description:

    Enumerate the resources in the group to locate
    the old msmq resource.

Arguments:

    hCluster - handle to this cluster.

    pwzGroupName - Name of the group to iterate thru.

    phGroup  - on output, points to the group handle of the group to search thru.

    pwzOldResource - on output, points to name of old msmq resource.

Return Value:

    HRESOURCE of the old msmq resource.

    NULL - The old msmq resource was not found in the group.

--*/
{
    CClusterGroup hGroup(OpenClusterGroupWithRetry(hCluster, pwzGroupName));

    CGroupEnum hEnum(ClusterGroupOpenEnumWithRetry(pwzGroupName, hGroup, CLUSTER_GROUP_ENUM_CONTAINS));

    AP<WCHAR> pwzResourceName = new WCHAR[255];
    if (pwzResourceName.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbResourceName = 255 * sizeof(WCHAR);
    DWORD dwIndex = 0;
    DWORD dwType = CLUSTER_GROUP_ENUM_CONTAINS;
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbResourceName;
        status = ClusterGroupEnumWithRetry(pwzGroupName, hEnum, dwIndex++, &dwType, pwzResourceName, 
                                           &cbTmp);
        if (cbTmp > cbResourceName)
        {
            cbResourceName = cbTmp;
        }

        ASSERT(status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS);

        if (status == ERROR_SUCCESS)
        {
            HRESOURCE hResource = OpenResourceOfSpecifiedType(pwzResourceName.get(), L"Microsoft Message Queue Server");
            if (hResource != NULL)
            {
                *phGroup = hGroup.detach();
                wcscpy(pwzOldResource, pwzResourceName.get());
                return hResource;
            }
        }
    }

    return NULL;

} //OpenOldMsmqResourceInGroup


HRESOURCE
OpenOldMsmqResourceInCluster(
    HGROUP * phGroup,
    LPWSTR   pwzOldResource
    )
/*++

Routine Description:

    Enumerate the groups in the cluster to locate
    the old msmq resource and its cluster group.

Arguments:

    phGroup - on output, points to handle of the group of old msmq resource.

    pwzOldResource - on output, points to name of old msmq resource.

Return Value:

    HRESOURCE of old msmq resource.

    NULL - The old msmq resource was not found.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    CClusterEnum hEnum(ClusterOpenEnumWithRetry(hCluster, CLUSTER_ENUM_GROUP));

    TickProgressBar(IDS_SearchOldResource_PROGRESS);

    DWORD dwIndex = 0;
    AP<WCHAR> pwzGroupName = new WCHAR[255];
    if (pwzGroupName.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbGroupName = 255 * sizeof(WCHAR);
    DWORD dwType = CLUSTER_ENUM_GROUP;
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbGroupName;
        status = ClusterEnumWithRetry(hEnum, dwIndex++, &dwType, pwzGroupName, &cbTmp);
        if (cbTmp > cbGroupName)
        {
            cbGroupName = cbTmp;
        }

        ASSERT(status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS);

        if (status == ERROR_SUCCESS)
        {
            HRESOURCE hRes = OpenOldMsmqResourceInGroup(hCluster, pwzGroupName.get(), phGroup, pwzOldResource);
            if (hRes != NULL)
            {
                return hRes;
            }
        }
    }

    return NULL;

} //OpenOldMsmqResourceInCluster


HRESOURCE
CreateClusterResourceWithRetry(
    LPCWSTR pwzOldResource,
    HGROUP  hGroup,
    LPWSTR  pwzNewResource
    )
/*++

Routine Description:

    Create a new msmq cluster resource.
    The name of the new resource is based on the
    name of the old one.

Arguments:

    pwzOldResource - Name of old msmq resource.

    hGroup - Handle to group in which to create the resource.

    pwzNewResource - On output, name of new msmq resource.

Return Value:

    HRESOURCE of the created resource, as returned by CreateClusterResource..

--*/
{
    wcscpy(pwzNewResource, pwzOldResource);

    for (;;)
    {
        CResString strSuffix(IDS_ClusterUpgrade_ResourceNameSuffix);
        wcscat(pwzNewResource, strSuffix.Get());

        HRESOURCE hResource = CreateClusterResource(hGroup, pwzNewResource, L"MSMQ", 0);
        if (hResource != NULL)
        {
            DisplayMessage(IDS_ClusterUpgradeMsgTitle, IDS_NewResourceCreateOk, pwzNewResource);
            return hResource;
        }

        if (ERROR_DUPLICATE_SERVICE_NAME == GetLastError())
        {
            //
            // This newly generated name is already occupied by some other resource.
            // If this other resource is of the new msmq type, than just open a handle
            // to it. This scenario could be as a result of 2 nodes running concurrently
            // this wizard, or re-run of this wizard after crash.
            //
            hResource = OpenResourceOfSpecifiedType(pwzNewResource, L"MSMQ");
            if (hResource != NULL)
            {
                return hResource;
            }

            continue;
        }

        CResString strType(IDS_ClusterTypeName);
        if (IDRETRY != MqDisplayErrorWithRetry(IDS_CreateResource_ERR, GetLastError(), pwzNewResource,
                                               strType.Get()))
        {
            throw CClusterUpgradeException();
        }
    }
} //CreateClusterResourceWithRetry


VOID
WINAPI
CloneRegistryStringValue(
    HKEY    hKey,
    LPCWSTR pwzValueName
    )
/*++

Routine Description:

    Copy registry string value from main msmq registry to registry of
    new msmq resource.

Arguments:

    hKey - Handle to registry key to copy on.

    pwzValueName - Points to registry value name to copy.

Return Value:

    None.

--*/
{
    WCHAR wzValueData[255] = L"";
    if (!MqReadRegistryValue(pwzValueName, sizeof(wzValueData), wzValueData))
    {
        return;
    }

    DWORD status = RegSetValueEx(
                       hKey, 
                       pwzValueName, 
                       0, 
                       REG_SZ, 
                       reinterpret_cast<BYTE*>(wzValueData),  
                       numeric_cast<DWORD> ((wcslen(wzValueData) + 1) * sizeof(WCHAR))
                       );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, status, pwzValueName);
        throw CClusterUpgradeException();
    }
} //CloneRegistryStringValue


VOID
WINAPI
CloneRegistryDwordValue(
    HKEY    hKey,
    LPCWSTR pwzValueName
    )
/*++

Routine Description:

    Copy registry DWORD value from main msmq registry to registry of
    new msmq resource.

Arguments:

    hKey - Handle to registry key to copy on.

    pwzValueName - Points to registry value name to copy.

Return Value:

    None.

--*/
{
    DWORD dwValue = 0;
    if (!MqReadRegistryValue(pwzValueName, sizeof(DWORD), &dwValue))
    {
        return;
    }

    DWORD status = RegSetValueEx(
                       hKey, 
                       pwzValueName, 
                       0, 
                       REG_DWORD, 
                       reinterpret_cast<BYTE*>(&dwValue), 
                       sizeof(DWORD)
                       );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, status, pwzValueName);
        throw CClusterUpgradeException();
    }
} //CloneRegistryDwordValue


VOID
CloneRegistryValues(
    LPCWSTR pwzNewResource
    )
/*++

Routine Description:

    Copy registry values from main msmq registry to registry of
    new msmq resource.

Arguments:

    pwzNewResource - Points to name of new msmq resource.

Return Value:

    None.

--*/
{
    //
    // Compose the registry key for clustered qm.
    // This code should be identical to the code in mqclus.dll .
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQ$";
    WCHAR wzServiceName[200] = L""; 
    wcscpy(wzServiceName, x_SERVICE_PREFIX);
    wcsncat(wzServiceName, pwzNewResource, STRLEN(wzServiceName) - wcslen(x_SERVICE_PREFIX));

    WCHAR wzFalconRegSection[200 + 100];
    swprintf(wzFalconRegSection, L"%s%s%s\\", FALCON_CLUSTERED_QMS_REG_KEY, wzServiceName, 
             FALCON_REG_KEY_PARAM);

    CAutoCloseRegHandle hKey;  
    LONG status = RegOpenKeyEx(
                      FALCON_REG_POS, 
                      wzFalconRegSection, 
                      0, 
                      KEY_ALL_ACCESS,
                      &hKey
                      );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, status, FALCON_REG_POS_DESC, wzFalconRegSection);
        throw CClusterUpgradeException();
    }

    typedef VOID (WINAPI *HandlerRoutine) (HKEY, LPCWSTR); 

    struct RegEntry 
    {
        LPCWSTR        pwzValueName;
        HandlerRoutine handler;
    };

    RegEntry RegMap[] = {
    // Value Name                         |   Handler Routine
    //------------------------------------|------------------------------------|
    {MSMQ_SETUP_STATUS_REGNAME,              CloneRegistryDwordValue},
    {MSMQ_ROOT_PATH,                         CloneRegistryStringValue}, 
    {MSMQ_STORE_RELIABLE_PATH_REGNAME,       CloneRegistryStringValue},
    {MSMQ_STORE_PERSISTENT_PATH_REGNAME,     CloneRegistryStringValue},
    {MSMQ_STORE_JOURNAL_PATH_REGNAME,        CloneRegistryStringValue},
    {MSMQ_STORE_LOG_PATH_REGNAME,            CloneRegistryStringValue},
    {FALCON_XACTFILE_PATH_REGNAME,           CloneRegistryStringValue},
    {MSMQ_TRANSACTION_MODE_REGNAME,          CloneRegistryStringValue},
    {MSMQ_SEQ_ID_REGNAME,                    CloneRegistryDwordValue},
    {MSMQ_MESSAGE_ID_LOW_32_REGNAME,         CloneRegistryDwordValue},
    {MSMQ_MESSAGE_ID_HIGH_32_REGNAME,        CloneRegistryDwordValue},
    {FALCON_LOGDATA_CREATED_REGNAME,         CloneRegistryDwordValue}
    };

    for (DWORD ix = 0; ix < sizeof(RegMap)/sizeof(RegMap[0]); ++ix)
    {
        RegMap[ix].handler(hKey, RegMap[ix].pwzValueName);
    }
} //CloneRegistryValues


VOID
MoveDependencies(
    HRESOURCE hNewResource,
    LPCWSTR   pwzNewResource,
    HRESOURCE hOldResource,
    LPCWSTR   pwzOldResource
    )
/*++

Routine Description:

    Move dependencies from the old msmq resource to the new one.

Arguments:

    hNewResource - Handle of new msmq resource.

    pwzNewResource - Name of new msmq resource.

    hOldResource - Handle of old msmq resource.

    pwzOldResource - Name of old msmq resource.

Return Value:

    None.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    TickProgressBar(IDS_ConfigureNewResource_PROGRESS);

    //
    // Copy dependencies of old resource
    //

    DWORD dwEnum = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hEnumDepend(ClusterResourceOpenEnumWithRetry(pwzOldResource, hOldResource, dwEnum));

    DWORD dwIndex = 0;
    AP<WCHAR> pwzDepend = new WCHAR[255];
    if (pwzDepend.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbDepend = 255 * sizeof(WCHAR);
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbDepend;
        status = ClusterResourceEnumWithRetry(pwzOldResource, hEnumDepend, dwIndex++, &dwEnum, pwzDepend, 
                                              &cbTmp);
        if (cbTmp > cbDepend)
        {
            cbDepend = cbTmp;
        }

        if (status == ERROR_SUCCESS)
        {
            CClusterResource hResourceDepend(OpenClusterResourceWithRetry(hCluster, pwzDepend.get()));
            AddClusterResourceDependencyWithRetry(hNewResource, pwzNewResource, hResourceDepend, pwzDepend.get());
        }
    }

    //
    // Move dependencies that old resource provides to the new resource
    //

    dwEnum = CLUSTER_RESOURCE_ENUM_PROVIDES;
    CResourceEnum hEnumProvide(ClusterResourceOpenEnumWithRetry(pwzOldResource, hOldResource, dwEnum));

    dwIndex = 0;
    AP<WCHAR> pwzProvide = new WCHAR[255];
    if (pwzProvide.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbProvide = 255 * sizeof(WCHAR);
    status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbProvide;
        status = ClusterResourceEnumWithRetry(pwzOldResource, hEnumProvide, dwIndex++, &dwEnum, pwzProvide, 
                                              &cbTmp);
        if (cbTmp > cbProvide)
        {
            cbProvide = cbTmp;
        }

        if (status == ERROR_SUCCESS)
        {
            CClusterResource hResourceProvide(OpenClusterResourceWithRetry(hCluster, pwzProvide.get()));
            AddClusterResourceDependencyWithRetry(hResourceProvide, pwzProvide.get(), hNewResource, pwzNewResource);
            RemoveClusterResourceDependencyWithRetry(hResourceProvide, pwzProvide.get(), hOldResource, pwzOldResource);
        }
    }
} //MoveDependencies


VOID
CreateNewMsmqResource(
    HRESOURCE hOldResource,
    LPCWSTR   pwzOldResource,
    HGROUP    hGroup
    )
/*++

Routine Description:

    Handle creation of new msmq cluster resource, based on the name
    of the old one.

Arguments:

    hOldResource - Handle of old msmq resource.

    pwzOldResource - Points to name of the old msmq resource.

    hGroup - Handle of group of old msmq resource.

Return Value:

    HRESOURCE of the new msmq cluster resource.

--*/
{
    TickProgressBar(IDS_CreateNewResource_PROGRESS);

    WCHAR wzNewResource[255] = L"";
    CClusterResource hNewResource(CreateClusterResourceWithRetry(pwzOldResource, hGroup, wzNewResource));
    
    MoveDependencies(hNewResource, wzNewResource, hOldResource, pwzOldResource);

    CloneRegistryValues(wzNewResource);
    
    BringOnlineNewResourceWithRetry(hNewResource, wzNewResource);

    DisplayMessage(IDS_ClusterUpgradeMsgTitle, IDS_NewResourceOnlineOk, wzNewResource);

} //CreateNewMsmqResource


bool
UpgradeMsmqClusterResource(
    VOID
    )
/*++

Routine Description:

    Handle upgrade of MSMQ cluster resource from NT 4 and Windows 2000 Beta3

Arguments:

    None

Return Value:

    true - operation was successful.

    false - operation failed.

--*/
{
    ASSERT(Msmq1InstalledOnCluster());
    TickProgressBar(IDS_UpgradeMsmqClusterResource_PROGRESS);

    try
    {
        CAutoFreeLibrary hClusapiDll;
        LoadClusapiDll(&hClusapiDll);

        WCHAR wzOldResource[255] = L"";
        CClusterGroup hGroup;
        CClusterResource hOldResource(OpenOldMsmqResourceInCluster(&hGroup, wzOldResource));
        if (hOldResource == NULL)
        {
            //
            // Old resource was not found. We are done.
            //
            return true;
        }
        
        TickProgressBar(IDS_ClusterUpgradeFixRegistry_PROGRESS);
        
        RemoveRegistryCheckpointWithRetry(hOldResource, wzOldResource, L"Software\\Microsoft\\MSMQ");
        RemoveRegistryCheckpointWithRetry(hOldResource, wzOldResource, L"Software\\Microsoft\\MSMQ\\Parameters");
        RemoveRegistryCheckpointWithRetry(hOldResource, wzOldResource, L"Software\\Microsoft\\Cryptography\\MachineKeys\\MSMQ");

        CreateNewMsmqResource(hOldResource, wzOldResource, hGroup);

        DeleteOldResourceWithRetry(hOldResource);

        DeleteOldResourceTypeWithRetry();
    }
    catch(const CClusterUpgradeException&)
    {
        MqDisplayError(NULL, IDS_UpgradeClusterFail_ERR, 0);
        return false;
    }

    return true;

} //UpgradeMsmqClusterResource

#pragma warning(default: 4702) //C4702: unreachable code
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\subcomp.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    subcomp.cpp

Abstract:

    Code to handle subcomponents of MSMQ setup.

Author:

    Tatiana Shubin  (TatianaS)  21-Sep-00

Revision History:
	

--*/

#include "msmqocm.h"

#include "subcomp.tmh"

#define WELCOME_PREFIX  L"Welcome_"

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentStateFromRegistry
//
//  Synopsis: Returns SubcompOn if subcomponent is defined in registry
//              when this setup is started
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentStateFromRegistry( IN const TCHAR   *SubcomponentId,
                                        IN const TCHAR   *szRegName)
{           
    ASSERT(SubcomponentId);

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }
        
        //
        // we found subcomponent in array
        //
        DWORD dwState = 0;    

        if (MqReadRegistryValue(
                szRegName,                
                sizeof(DWORD),
                (PVOID) &dwState,
                /* bSetupRegSection = */TRUE
                ))
        {
            //
            // registry key is found, it means that this subcomponent
            // was installed early
            //
            g_SubcomponentMsmq[i].fInitialState = TRUE;
            return SubcompOn;
        }
        else
        {
            //
            // registry key is not found
            //
            g_SubcomponentMsmq[i].fInitialState = FALSE;
            return SubcompOff;
        }    
    }
    return SubcompOff;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentWelcomeState
//
//  Synopsis: Returns SubcompOn if subcomponent was selected in GUI mode
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentWelcomeState (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    } 

    TCHAR szRegName[256];
    _stprintf(szRegName, L"%s%s", WELCOME_PREFIX, SubcomponentId);        

    DWORD dwWelcomeState = GetSubcomponentStateFromRegistry(SubcomponentId, szRegName);
    return dwWelcomeState;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentInitialState
//
//  Synopsis: Returns SubcompOn if subcomponent is already installed
//              when this setup is started
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentInitialState(IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    } 
    DWORD dwInitialState = GetSubcomponentStateFromRegistry(SubcomponentId, SubcomponentId);
    return dwInitialState;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentFinalState
//
//  Synopsis: Returns SubcompOn if subcomponent is successfully installed
//              during this setup
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentFinalState (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    }    

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }
        
        //
        // we found subcomponent in array
        //
        if (g_SubcomponentMsmq[i].fIsInstalled)
        {
            //
            // it means that this subcomponent was installed 
            // successfully
            //               
            return SubcompOn;
        }
        else
        {
            //
            // this subcomponent was not installed
            //           
            return SubcompOff;
        }    
    }

    return SubcompOff;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSetupOperationForSubcomponent
//
//  Synopsis: Return setup operation for the specific subcomponent
//
//--------------------------------------------------------------------------
DWORD GetSetupOperationForSubcomponent (DWORD SubcomponentIndex)
{
    if ( (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == TRUE) &&
         (g_SubcomponentMsmq[SubcomponentIndex].fIsSelected == FALSE) )
    {
        return REMOVE;
    }

    if ( (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == FALSE) &&
         (g_SubcomponentMsmq[SubcomponentIndex].fIsSelected == TRUE) )
    {
        return INSTALL;
    }

    return DONOTHING;
}

//+-------------------------------------------------------------------------
//
//  Function: SetOperationForSubcomponent
//
//  Synopsis: All flags for specific subcomponent are set here.
//
//--------------------------------------------------------------------------
void SetOperationForSubcomponent (DWORD SubcomponentIndex)
{    
    DWORD dwErr;
    WCHAR wszMsg[1000];

    BOOL fInitialState = g_ComponentMsmq.HelperRoutines.QuerySelectionState(
                                g_ComponentMsmq.HelperRoutines.OcManagerContext,
                                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                                OCSELSTATETYPE_ORIGINAL
                                ) ;
    if (fInitialState)
    {
        g_SubcomponentMsmq[SubcomponentIndex].fInitialState = TRUE;

        wsprintf(wszMsg, L"The subcomponent %s was selected initially",
            g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
        DebugLogMsg(wszMsg);
    }
    else
    {
        dwErr = GetLastError();
        if (dwErr == NO_ERROR)
        {
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState = FALSE;
                      
            wsprintf(wszMsg, L"The subcomponent %s was NOT selected initially",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
            DebugLogMsg(wszMsg);
        }
        else
        {                    
            ASSERT(("initial status for subcomponent is unknown", dwErr));
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState = FALSE;
            
            wsprintf(wszMsg, L"The initial status of the %s subcomponent is unknown. Error code: %x.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, dwErr);
            DebugLogMsg(wszMsg);            
        }    
    }   // fInitialState

    BOOL fCurrentState;     
    fCurrentState =  g_ComponentMsmq.HelperRoutines.QuerySelectionState(
                                g_ComponentMsmq.HelperRoutines.OcManagerContext,
                                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                                OCSELSTATETYPE_CURRENT
                                ) ;    

    if (fCurrentState)
    {
        g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = TRUE;
            
        wsprintf(wszMsg, L"The subcomponent %s is selected currently",
            g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
        DebugLogMsg(wszMsg);
    }
    else 
    {
        dwErr = GetLastError();
        if (dwErr == NO_ERROR)
        {
            g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = FALSE;

            wsprintf(wszMsg, L"The subcomponent %s is NOT selected currently",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
            DebugLogMsg(wszMsg);
        }
        else
        {          
            //         
            // set IsSelected flag to the same state as InitialState flag: so
            // we are sure that we do NOTHING with this subcomponent
            //
            ASSERT(("current status for subcomponent is unknown", dwErr));
            g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = 
                g_SubcomponentMsmq[SubcomponentIndex].fInitialState;

            wsprintf(wszMsg, L"The current status of the %s subcomponent is unknown. Error code: %x.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, dwErr);
            DebugLogMsg(wszMsg);
        }   
    }
    
    
    DWORD dwOperation = GetSetupOperationForSubcomponent (SubcomponentIndex);

    TCHAR wszMode[256];
    if (dwOperation == INSTALL)
    {
        wcscpy(wszMode, TEXT("INSTALL"));
    }
    else if (dwOperation == REMOVE)
    {
        wcscpy(wszMode, TEXT("REMOVE"));
    }
    else
    {
        wcscpy(wszMode, TEXT("DO NOTHING"));
    }
    
    wsprintf(wszMsg, L"The current mode for the %s subcomponent is %s.",
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, wszMode);
    DebugLogMsg(wszMsg); 

    g_SubcomponentMsmq[SubcomponentIndex].dwOperation = dwOperation;
    if (dwOperation == DONOTHING)
    {
        //
        // it means that status was not changed and the final state will 
        // be equal to the initial state
        //
        g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = 
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState;
    }
    else
    {
        //
        // if we need to install/ remove this subcomponent
        // this flag will be updated by removing/installation
        // function that is defined for this component.
        // Now set to FALSE: will be set correct value after the install/remove
        //
        g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = FALSE;
    }
}        

//+-------------------------------------------------------------------------
//
//  Function: RegisterSubcomponentForWelcome
//
//  Synopsis: Register subcomponent to install it later in "Welcome" mode
//
//--------------------------------------------------------------------------
BOOL RegisterSubcomponentForWelcome (DWORD SubcomponentIndex)
{
    DWORD dwValue = 1;
    TCHAR RegKey[256];
    _stprintf(RegKey, L"%s%s", WELCOME_PREFIX, 
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
    MqWriteRegistryValue(
                RegKey,
                sizeof(DWORD),
                REG_DWORD,
                &dwValue,
                TRUE //bSetupRegSection 
                );

    g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = TRUE;
     
    TCHAR szMsg[256];
    _stprintf(szMsg, TEXT("The %s subcomponent is registered for Welcome."), 
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
    DebugLogMsg(szMsg);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: UnregisterSubcomponentForWelcome
//
//  Synopsis: Unregister subcomponent in "Welcome" mode if it was installed
//              successfully
//
//--------------------------------------------------------------------------
BOOL UnregisterSubcomponentForWelcome (DWORD SubcomponentIndex)
{
    TCHAR RegKey[256];
    _stprintf(RegKey, L"%s%s", WELCOME_PREFIX, 
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);

    if (!RemoveRegistryKeyFromSetup (RegKey))
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: FinishToRemoveSubcomponent
//
//  Synopsis: Clean subcomponent registry if removing was succesfully
//
//--------------------------------------------------------------------------
BOOL FinishToRemoveSubcomponent (DWORD SubcomponentIndex)
{    
    if (!RemoveRegistryKeyFromSetup (g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId))
    {
        return FALSE;
    }

    g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = FALSE;

    TCHAR szMsg[256];
    _stprintf(szMsg, TEXT("The %s subcomponent was removed successfully."),
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
    DebugLogMsg(szMsg);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: FinishToInstallSubcomponent
//
//  Synopsis: Set subcomponent registry if installation was succesfully
//
//--------------------------------------------------------------------------
BOOL FinishToInstallSubcomponent (DWORD SubcomponentIndex)
{
    DWORD dwValue = 1;
    MqWriteRegistryValue(
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                sizeof(DWORD),
                REG_DWORD,
                &dwValue,
                TRUE //bSetupRegSection 
                );

    g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = TRUE;
    
    TCHAR szMsg[256];
    _stprintf(szMsg, TEXT("The %s subcomponent was installed successfully."),
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);
    DebugLogMsg(szMsg);

    if (SubcomponentIndex != eHTTPSupport)
    {
        return TRUE;
    }

    //
    // If this subcomponent is http support and it was installed it means
    // that installation was performed at the CLEANUP setup phase and
    // general OC Manager registry is not set for it (that registry set 
    // when OC_QUERY_STATE was called). We have to set that registry
    // manually since in unattended setup it is only way to know what is the
    // initial state of the subcomponent, so we need to have there real value
    //

    //
    //
    // set OCM registry for HTTP support subcomponent to 1
    //

    //
    // BUGBUG: it is unclear why, but the code below does not work!
    //
    /*
    CAutoCloseRegHandle hKey;                
    HRESULT hResult = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            OCM_SUBCOMPONENTS_REG,
                            0L,
                            KEY_ALL_ACCESS,
                            &hKey);
    
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, OCM_SUBCOMPONENTS_REG);                    
    }
    else
    {      
        DWORD dwValue = 1;    
        BOOL f = SetRegistryValue (
                    hKey, 
                    // ocm keeps all entries in lower case
                    _tcslwr(g_SubcomponentMsmq[eHTTPSupport].szSubcomponentId),
                    sizeof(DWORD),
                    REG_DWORD,
                    &dwValue);       
    }
*/
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: LogSelectedComponents
//
//  Synopsis: Only in debug version log selected components to the file
//
//--------------------------------------------------------------------------
void
LogSelectedComponents()
{   
    DebugLogMsg(TEXT("Final selecton:"));
    TCHAR wszMode[256];
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (g_SubcomponentMsmq[i].dwOperation == INSTALL)
        {
            wcscpy(wszMode, TEXT("INSTALL"));
        }
        else if (g_SubcomponentMsmq[i].dwOperation == REMOVE)
        {
            wcscpy(wszMode, TEXT("REMOVE"));
        }
        else
        {
            wcscpy(wszMode, TEXT("DO NOTHING"));
        }     

        TCHAR wszMsg[1000];
        wsprintf(wszMsg, L"The current mode for the %s subcomponent is %s.",
            g_SubcomponentMsmq[i].szSubcomponentId, wszMode);
        DebugLogMsg(wszMsg);
    }

    return;
}

//+-------------------------------------------------------------------------
//
//  Function: SetSubcomponentForUpgrade
//
//  Synopsis: This function called in Upgrade mode to define which 
//              subcomponent has to be installed
//
//--------------------------------------------------------------------------
void
SetSubcomponentForUpgrade()
{
    //
    // MSMQ Core must be installed always
    //
    g_SubcomponentMsmq[eMSMQCore].fInitialState = FALSE;
    g_SubcomponentMsmq[eMSMQCore].fIsSelected = TRUE;
    g_SubcomponentMsmq[eMSMQCore].dwOperation = INSTALL;

    if (g_fDependentClient)
    {
        LogSelectedComponents();
        return;
    }
   
    //
    // Install independent client/ server
    //
    g_SubcomponentMsmq[eLocalStorage].fInitialState = FALSE;
    g_SubcomponentMsmq[eLocalStorage].fIsSelected = TRUE;
    g_SubcomponentMsmq[eLocalStorage].dwOperation = INSTALL;

    //
    // Install triggers
    //
    if (TriggersInstalled(NULL))
    {
        g_SubcomponentMsmq[eTriggersService].fInitialState = FALSE; 
        g_SubcomponentMsmq[eTriggersService].fIsSelected = TRUE;
        g_SubcomponentMsmq[eTriggersService].dwOperation = INSTALL;
    }

    WCHAR DebugMsg[255];
    wsprintf(
        DebugMsg, 
        L"Triggers subcomponent installation status: InitialState=%d, IsSelected=%d, Operation=%d",
        g_SubcomponentMsmq[eTriggersService].fInitialState,
        g_SubcomponentMsmq[eTriggersService].fIsSelected,
        g_SubcomponentMsmq[eTriggersService].dwOperation
        );
    DebugLogMsg(DebugMsg);

    DWORD dwAlwaysWorkgroup;
    if (!MqReadRegistryValue( MSMQ_ALWAYS_WORKGROUP_REGNAME,
                             sizeof(dwAlwaysWorkgroup),
                            (PVOID) &dwAlwaysWorkgroup ))    
    {
        //
        // install AD Integrated
        //
        g_SubcomponentMsmq[eADIntegrated].fInitialState = FALSE;
        g_SubcomponentMsmq[eADIntegrated].fIsSelected = TRUE;
        g_SubcomponentMsmq[eADIntegrated].dwOperation = INSTALL;
    }

    if (IsWorkgroup())
    {
        //
        // if it is setup on workgroup install only ind. client
        //
        LogSelectedComponents();
        return;
    }

    if (g_dwMachineTypeDs)
    {
        //
        // install MQDS service on the former DS Servers
        //
        g_SubcomponentMsmq[eMQDSService].fInitialState = FALSE;
        g_SubcomponentMsmq[eMQDSService].fIsSelected = TRUE;
        g_SubcomponentMsmq[eMQDSService].dwOperation = INSTALL;
    }

    if (MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS)
    {
        //
        // install HTTP support on servers
        //
        g_SubcomponentMsmq[eHTTPSupport].fInitialState = FALSE;
        g_SubcomponentMsmq[eHTTPSupport].fIsSelected = TRUE;
        g_SubcomponentMsmq[eHTTPSupport].dwOperation = INSTALL;
    }    

    if(g_dwMachineTypeFrs)
    {
        //
        // install routing support on former routing servers
        //
        g_SubcomponentMsmq[eRoutingSupport].fInitialState = FALSE;
        g_SubcomponentMsmq[eRoutingSupport].fIsSelected = TRUE;
        g_SubcomponentMsmq[eRoutingSupport].dwOperation = INSTALL;
    }
   
    LogSelectedComponents();
}

//+-------------------------------------------------------------------------
//
//  Function: SetSetupDefinitions()
//
//  Synopsis: Set global flags those define machine type and AD integration
//              This code was in wizpage.cpp, function TypeButtonToMachineType
//              in the previous setup
//
//--------------------------------------------------------------------------
void 
SetSetupDefinitions()
{
    //
    // Note: this code is called on unattneded scenarios too!
    //
    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == REMOVE)
    {
        //
        // do nothing: MSMQ will be removed, all these globals flags were
        // defined in ocminit.cpp.
        // In old scenario (without subcomponents)
        // we skip all pages and did not call function
        // TypeButtonToMachineType
        //
        return;
    }

    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == DONOTHING)
    {
        //
        // do nothing: MSMQ Core is already installed, 
        // all these globals flags were defined in ocminit.cpp.
        // Currently we don't have special code for this scenario.
        // May be in the future when it will be possible to add/remove
        // routing support/ local storage always (not only at the 
        // first installation) we add some code here
        //
        return;
    }

    ASSERT (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL);   
    
    //
    // It is first MSMQ installation
    //
    if (g_SubcomponentMsmq[eLocalStorage].dwOperation == DONOTHING)
    {
        //
        // it is the first installation since MSMQCore will be installed
        // and Local Storage was not selected: it means user like to 
        // install Dependent Client
        //        

        ASSERT(("dep client on domain controller not supported", !g_dwMachineTypeDs));
        ASSERT(("dep client on workgroup not supported", !IsWorkgroup() ));
#ifdef _WIN64
        {
        ASSERT(("dep client on 64bit computer not supported", 0));
        }
#endif
        g_dwMachineType = SERVICE_NONE ;
        g_dwMachineTypeFrs = 0;
        g_fServerSetup = FALSE ;
        g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
        g_fDependentClient = TRUE ;       
        return;
    }

    //
    // Ind. Client/ server will be installed
    //
    g_fDependentClient = FALSE ;
    g_fServerSetup = TRUE ;
    g_uTitleID = IDS_STR_SRV_ERROR_TITLE;    
    //
    //  For fresh install, g_dwMachineTypeDs is set only if the user had selected
    //  MQDS service componant and not according to product type
    //
    if ( g_dwMachineTypeDs == 0)   // don't override upgrade selections
    {
        if (g_SubcomponentMsmq[eMQDSService].dwOperation == INSTALL) 
        {
            g_dwMachineTypeDs = 1;
        }
    }
   
    if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == INSTALL)
    {      
        //
        // routing server will be installed
        //
        ASSERT(("routing on workgroup not supported", !IsWorkgroup() ));
        g_dwMachineType = g_dwMachineTypeDs ? SERVICE_DSSRV : SERVICE_SRV ;
        g_dwMachineTypeFrs = 1;     
    }
    else // at least eLocalStorage was selected (otherwise Dep. Client case)
    {
        //
        // independent client will be installed
        //
        ASSERT (g_SubcomponentMsmq[eLocalStorage].dwOperation == INSTALL);   
    
        g_dwMachineType = SERVICE_NONE ;
        g_dwMachineTypeFrs = 0;     
        g_fServerSetup = g_dwMachineTypeDs ? TRUE : FALSE ;
        g_uTitleID = g_dwMachineTypeDs ? IDS_STR_SRV_ERROR_TITLE : IDS_STR_CLI_ERROR_TITLE;      
    }  
            
    //
    // AD Integration
    //    
    if (g_SubcomponentMsmq[eADIntegrated].dwOperation == DONOTHING)
    {        
        g_fDsLess = TRUE;     
    }

}

//+-------------------------------------------------------------------------
//
//  Function: ValidateSelection
//
//  Synopsis: Validate if selection was correct. Unfortunately, we can leave
//              selection window with incorrect values (scenario: remove all
//              and then add what we want)
//              NB: this function called for both attended 
//              and unattended modes
//
//--------------------------------------------------------------------------
void ValidateSelection()
{            
    #ifdef _WIN64
    {    
        if (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
        {            
            //
            // It is impossible to install Dep. Client on 64 bit machine.
            // So, MSMQCore means here to install Ind. Client.
            // Just set operation to INSTALL for LocalStorage subcomponent 
            // to keep all internal setup logic.
            //
            g_SubcomponentMsmq[eLocalStorage].dwOperation = INSTALL;            
            g_SubcomponentMsmq[eLocalStorage].fIsSelected = TRUE;            
        }
    }
    #endif   
    
    if (g_fOnlyRegisterMode)
    {
        //
        // GUI mode and MSMQ is not installed. Accept any selection. 
        // We verify it later, in Welcome mode.
        //
        return;
    }

    CResString strParam;    
    //
    // Workgroup problem
    //    
    if (IsWorkgroup())
    {        
        if (g_SubcomponentMsmq[eLocalStorage].dwOperation == DONOTHING &&
            g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install Dep. Client on Workgroup
            //    
            strParam.Load(IDS_DEP_ON_WORKGROUP_WARN);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());           
            g_fCancelled = TRUE;
            return;            
        }
      
        if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install Routing on Workgroup
            //
            strParam.Load(IDS_ROUTING_ON_WORKGROUP_ERROR);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());
            g_fCancelled = TRUE;
            return;                 
        }

        if(g_SubcomponentMsmq[eMQDSService].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install MQDS Service on Workgroup
            //
            strParam.Load(IDS_MQDS_ON_WORKGROUP_ERROR);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());
            g_fCancelled = TRUE;
            return;
        }                
    }

    if (g_SubcomponentMsmq[eMSMQCore].dwOperation != DONOTHING)
    {
        //
        // MSMQ Core will be installed/ removed: 
        // all selection are acceptable
        // 
        return;
    }

    if (g_SubcomponentMsmq[eMSMQCore].fInitialState == FALSE)
    {
        //
        // MSMQ Core was not installed and will not be installed
        // (since we are here if operation DONOTHING)
        //
        return;
    }

    //
    // We are here if MSMQ Core is already installed and will not be removed
    //

    //
    // "MSMQ already installed" problem
    //

    //
    // verify that state for routing and local storage is not changed    
    //
    if (g_SubcomponentMsmq[eRoutingSupport].dwOperation != DONOTHING)
    {
        strParam.Load(IDS_CHANGEROUTING_STATE_ERROR);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;      
    }

    if (g_SubcomponentMsmq[eLocalStorage].dwOperation != DONOTHING)
    {
        strParam.Load(IDS_CHANGE_LOCAL_STORAGE_STATE);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;             
    }      
    
    //
    // verify that AD integrated will not be removed
    //
    if (g_SubcomponentMsmq[eADIntegrated].dwOperation == REMOVE)
    {
        strParam.Load(IDS_REMOVE_AD_INTEGRATED);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;
    }       

    return;
}

//+-------------------------------------------------------------------------
//
//  Function: SetOperationForSubcomponents
//
//  Synopsis: Called when all subcomponents are already selected. Set 
//              operation for each subcomponent
//
//--------------------------------------------------------------------------
void
SetOperationForSubcomponents ()
{
    //
    // do it only once at the start. We arrive here in the cleanup phase
    // too, but we have to save initial selection in order to install
    // HTTP support (at clean up phase) if it was selected.    
    //    
    static BOOL s_fBeenHere = FALSE;

    if (s_fBeenHere)
        return;

    s_fBeenHere = TRUE;

    if (g_fUpgrade)
    {
        SetSubcomponentForUpgrade();
        return;
    }    
    
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        SetOperationForSubcomponent (i);
    }        

    ValidateSelection();
    if (g_fCancelled)
    {
        if (g_fWelcome)
        {
            UnregisterWelcome();
            g_fWrongConfiguration = TRUE;
            for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
            {
                UnregisterSubcomponentForWelcome (i);
            }  
        }        
        DebugLogMsg(L"An incorrect configuration was selected. Setup will not continue.");    
        return;
    }

    SetSetupDefinitions();    
    
    LogSelectedComponents();    
    
    return;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSetupOperationBySubcomponentName
//
//  Synopsis: Return setup operation for the specific subcomponent
//
//--------------------------------------------------------------------------
DWORD GetSetupOperationBySubcomponentName (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return DONOTHING;
    }

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }

        return (g_SubcomponentMsmq[i].dwOperation);        
    }
    
    ASSERT(("The subcomponent is not found", 0));
    return DONOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\upgclus.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgclus.h

Abstract:

    Header for upgrade of MSMQ cluster resource from NT 4 and Windows 2000 Beta3

Author:

    Shai Kariv  (shaik)  26-May-1999

Revision History:


--*/

#ifndef _MSMQOCM_UPGCLUS_H_
#define _MSMQOCM_UPGCLUS_H_


#include <clusapi.h>
#include <resapi.h>
#include <autorel3.h>


typedef HCLUSTER   (WINAPI *OpenCluster_ROUTINE)               (LPCWSTR);
typedef BOOL       (WINAPI *CloseCluster_ROUTINE)              (HCLUSTER);
typedef HCLUSENUM  (WINAPI *ClusterOpenEnum_ROUTINE)           (HCLUSTER, DWORD);
typedef DWORD      (WINAPI *ClusterEnum_ROUTINE)               (HCLUSENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef DWORD      (WINAPI *ClusterCloseEnum_ROUTINE)          (HCLUSENUM);
typedef BOOL       (WINAPI *CloseClusterResource_ROUTINE)      (HRESOURCE);
typedef BOOL       (WINAPI *CloseClusterGroup_ROUTINE)         (HGROUP);
typedef HRESOURCE  (WINAPI *OpenClusterResource_ROUTINE)       (HCLUSTER, LPCWSTR);
typedef DWORD      (WINAPI *ClusterGroupEnum_ROUTINE)          (HGROUPENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef HGROUPENUM (WINAPI *ClusterGroupOpenEnum_ROUTINE)      (HGROUP, DWORD);
typedef DWORD      (WINAPI *ClusterGroupCloseEnum_ROUTINE)     (HGROUPENUM);     
typedef HGROUP     (WINAPI *OpenClusterGroup_ROUTINE)          (HCLUSTER, LPCWSTR);
typedef DWORD      (WINAPI *CreateClusterResourceType_ROUTINE) (HCLUSTER, LPCWSTR, LPCWSTR, LPCWSTR, DWORD, DWORD);
typedef HRESOURCE  (WINAPI *CreateClusterResource_ROUTINE)     (HGROUP, LPCWSTR, LPCWSTR, DWORD);
typedef DWORD      (WINAPI *OnlineClusterResource_ROUTINE)     (HRESOURCE);
typedef DWORD      (WINAPI *DeleteClusterResource_ROUTINE)     (HRESOURCE);
typedef DWORD      (WINAPI *OfflineClusterResource_ROUTINE)    (HRESOURCE);
typedef DWORD      (WINAPI *DeleteClusterResourceType_ROUTINE) (HCLUSTER, LPCWSTR);
typedef HRESENUM   (WINAPI *ClusterResourceOpenEnum_ROUTINE)   (HRESOURCE, DWORD);
typedef DWORD      (WINAPI *ClusterResourceEnum_ROUTINE)       (HRESENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef DWORD      (WINAPI *ClusterResourceCloseEnum_ROUTINE)  (HRESENUM);
typedef DWORD      (WINAPI *AddClusterResourceDependency_ROUTINE)    (HRESOURCE, HRESOURCE);
typedef DWORD      (WINAPI *RemoveClusterResourceDependency_ROUTINE) (HRESOURCE, HRESOURCE);
typedef DWORD      (WINAPI *ClusterResourceControl_ROUTINE)    (HRESOURCE, HNODE, DWORD, LPVOID, DWORD, 
                                                                LPVOID, DWORD, LPDWORD);


OpenCluster_ROUTINE               pfOpenCluster               = NULL;
CloseCluster_ROUTINE              pfCloseCluster              = NULL;
ClusterOpenEnum_ROUTINE           pfClusterOpenEnum           = NULL;
ClusterEnum_ROUTINE               pfClusterEnum               = NULL;
ClusterCloseEnum_ROUTINE          pfClusterCloseEnum          = NULL;
CloseClusterResource_ROUTINE      pfCloseClusterResource      = NULL;
CloseClusterGroup_ROUTINE         pfCloseClusterGroup         = NULL;
ClusterResourceControl_ROUTINE    pfClusterResourceControl    = NULL;
OpenClusterResource_ROUTINE       pfOpenClusterResource       = NULL;
ClusterGroupEnum_ROUTINE          pfClusterGroupEnum          = NULL;
ClusterGroupOpenEnum_ROUTINE      pfClusterGroupOpenEnum      = NULL;
ClusterGroupCloseEnum_ROUTINE     pfClusterGroupCloseEnum     = NULL;
OpenClusterGroup_ROUTINE          pfOpenClusterGroup          = NULL;
CreateClusterResourceType_ROUTINE pfCreateClusterResourceType = NULL;
CreateClusterResource_ROUTINE     pfCreateClusterResource     = NULL;
OnlineClusterResource_ROUTINE     pfOnlineClusterResource     = NULL;
DeleteClusterResource_ROUTINE     pfDeleteClusterResource     = NULL;
OfflineClusterResource_ROUTINE    pfOfflineClusterResource    = NULL;
DeleteClusterResourceType_ROUTINE pfDeleteClusterResourceType = NULL;
ClusterResourceOpenEnum_ROUTINE   pfClusterResourceOpenEnum   = NULL;
ClusterResourceEnum_ROUTINE       pfClusterResourceEnum       = NULL;
ClusterResourceCloseEnum_ROUTINE  pfClusterResourceCloseEnum  = NULL;
AddClusterResourceDependency_ROUTINE    pfAddClusterResourceDependency    = NULL;
RemoveClusterResourceDependency_ROUTINE pfRemoveClusterResourceDependency = NULL;


HCLUSTER
WINAPI
OpenCluster(
    IN LPCWSTR lpszClusterName
    )
{
    ASSERT(("pointer to OpenCluster not initialized!", pfOpenCluster != NULL));
    return pfOpenCluster(lpszClusterName);

} //OpenCluster


BOOL
WINAPI
CloseCluster(
    IN HCLUSTER hCluster
    )
{
    ASSERT(("pointer to CloseCluster not initialized!", pfCloseCluster != NULL));
    return pfCloseCluster(hCluster);

} //CloseCluster


HCLUSENUM
WINAPI
ClusterOpenEnum(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterOpenEnum not initialized!", pfClusterOpenEnum != NULL));
    return pfClusterOpenEnum(hCluster, dwType);

} //ClusterOpenEnum


DWORD
WINAPI
ClusterEnum(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterEnum not initialized!", pfClusterEnum != NULL));
    return pfClusterEnum(hEnum, dwIndex, lpdwType, lpszName, lpcchName);

} //ClusterEnum


DWORD
WINAPI
ClusterCloseEnum(
    IN HCLUSENUM hEnum
    )
{
    ASSERT(("pointer to ClusterCloseEnum not initialized!", pfClusterCloseEnum != NULL));
    return pfClusterCloseEnum(hEnum);

} //ClusterCloseEnum


BOOL
WINAPI
CloseClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to CloseClusterResource not initialized!", pfCloseClusterResource != NULL));
    return pfCloseClusterResource(hResource);

} //CloseClusterResource


BOOL
WINAPI
CloseClusterGroup(
    IN HGROUP hGroup
    )
{
    ASSERT(("pointer to CloseClusterGroup not initialized!", pfCloseClusterGroup != NULL));
    return pfCloseClusterGroup(hGroup);

} //CloseClusterGroup


DWORD
WINAPI
ClusterResourceControl(
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD lpcbBytesReturned
    )
{
    ASSERT(("pointer to ClusterResourceControl not initialized!", pfClusterResourceControl != NULL));
    return pfClusterResourceControl(hResource, hHostNode, dwControlCode, lpInBuffer, cbInBufferSize,
                                    lpOutBuffer, cbOutBufferSize, lpcbBytesReturned);
} //ClusterResourceControl


HRESOURCE
WINAPI
OpenClusterResource(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    )
{
    ASSERT(("pointer to OpenClusterResource not initialized!", pfOpenClusterResource != NULL));
    return pfOpenClusterResource(hCluster, lpszResourceName);

} //OpenClusterResource


DWORD
WINAPI
ClusterGroupEnum(
    IN HGROUPENUM hGroupEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszResourceName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterGroupEnum not initialized!", pfClusterGroupEnum != NULL));
    return pfClusterGroupEnum(hGroupEnum, dwIndex, lpdwType, lpszResourceName, lpcchName);

} //ClusterGroupEnum


HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    IN HGROUP hGroup,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterGroupOpenEnum not initialized!", pfClusterGroupOpenEnum != NULL));
    return pfClusterGroupOpenEnum(hGroup, dwType);

} //ClusterGroupOpenEnum


DWORD
WINAPI
ClusterGroupCloseEnum(
    IN HGROUPENUM hGroupEnum
    )
{
    ASSERT(("pointer to ClusterGroupCloseEnum not initialized!", pfClusterGroupCloseEnum != NULL));
    return pfClusterGroupCloseEnum(hGroupEnum);

} //ClusterGroupCloseEnum


HGROUP
WINAPI
OpenClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )
{
    ASSERT(("pointer to OpenClusterGroup not initialized!", pfOpenClusterGroup != NULL));
    return pfOpenClusterGroup(hCluster, lpszGroupName);

} //OpenClusterGroup


DWORD
WINAPI
CreateClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    )
{
    ASSERT(("pointer to CreateClusterResourceType not initialized!", pfCreateClusterResourceType != NULL));
    return pfCreateClusterResourceType(hCluster, lpszResourceTypeName, lpszDisplayName, lpszResourceTypeDll,
                                       dwLooksAlivePollInterval, dwIsAlivePollInterval);
} //CreateClusterResourceType


HRESOURCE
WINAPI
CreateClusterResource(
    IN HGROUP hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags
    )
{
    ASSERT(("pointer to CreateClusterResource not initialized!", pfCreateClusterResource != NULL));
    return pfCreateClusterResource(hGroup, lpszResourceName, lpszResourceType, dwFlags);

} //CreateClusterResource


DWORD
WINAPI
OnlineClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to OnlineClusterResource not initialized!", pfOnlineClusterResource != NULL));
    return pfOnlineClusterResource(hResource);

} //OnlineClusterResource


DWORD
WINAPI
DeleteClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to DeleteClusterResource not initialized!", pfDeleteClusterResource != NULL));
    return pfDeleteClusterResource(hResource);

} //DeleteClusterResource


DWORD
WINAPI
OfflineClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to OfflineClusterResource not initialized!", pfOfflineClusterResource != NULL));
    return pfOfflineClusterResource(hResource);

} //OfflineClusterResource


DWORD
WINAPI
DeleteClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    )
{
    ASSERT(("pointer to DeleteClusterResourceType not initialized!", pfDeleteClusterResourceType != NULL));
    return pfDeleteClusterResourceType(hCluster, lpszResourceTypeName);

} //DeleteClusterResourceType


HRESENUM
WINAPI
ClusterResourceOpenEnum(
    IN HRESOURCE hResource,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterResourceOpenEnum not initialized!", pfClusterResourceOpenEnum != NULL));
    return pfClusterResourceOpenEnum(hResource, dwType);

} //ClusterResourceOpenEnum

DWORD
WINAPI
ClusterResourceEnum(
    IN HRESENUM hResEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterResourceEnum not initialized!", pfClusterResourceEnum != NULL));
    return pfClusterResourceEnum(hResEnum, dwIndex, lpdwType, lpszName, lpcchName);

} //ClusterResourceEnum

DWORD
WINAPI
ClusterResourceCloseEnum(
    IN HRESENUM hResEnum
    )
{
    ASSERT(("pointer to ClusterResourceCloseEnum not initialized!", pfClusterResourceCloseEnum != NULL));
    return pfClusterResourceCloseEnum(hResEnum);

} //ClusterResourceCloseEnum


DWORD
WINAPI
AddClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )
{
    ASSERT(("pointer to AddClusterResourceDependency not initialized!", pfAddClusterResourceDependency != NULL));
    return pfAddClusterResourceDependency(hResource, hDependsOn);

} //AddClusterResourceDependency

DWORD
WINAPI
RemoveClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )
{
    ASSERT(("pointer to RemoveClusterResourceDependency not initialized!", pfRemoveClusterResourceDependency != NULL));
    return pfRemoveClusterResourceDependency(hResource, hDependsOn);

} //RemoveClusterResourceDependency


//
// From comerror.cpp
//
int 
vsDisplayMessage(
    IN const HWND    hdlg,
    IN const UINT    uButtons,
    IN const UINT    uTitleID,
    IN const UINT    uErrorID,
    IN const DWORD   dwErrorCode,
    IN const va_list argList);

#endif //_MSMQOCM_UPGCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\wizpage.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wizpage.cpp

Abstract:

    Handle wizard pages for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


#include "msmqocm.h"

#include "wizpage.tmh"

// from getmqds.h
HRESULT  APIENTRY  GetNt4RelaxationStatus(ULONG *pulRelax) ;

HWND  g_hPropSheet = NULL ;

HFONT g_hTitleFont = 0;

//+--------------------------------------------------------------
//
// Function: CreatePage
//
// Synopsis: Creates property page
//
//+--------------------------------------------------------------
static
HPROPSHEETPAGE
CreatePage(
    IN const int     nID,
    IN const DLGPROC pDlgProc,
    IN const TCHAR  * szTitle,
    IN const TCHAR  * szSubTitle,
    IN BOOL          fFirstOrLast
    )
{
    PROPSHEETPAGE Page;
    memset(&Page, 0, sizeof(Page)) ;

    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    if (fFirstOrLast)
    {
        Page.dwFlags |= PSP_HIDEHEADER;
    }
    Page.hInstance = (HINSTANCE)g_hResourceMod;
    Page.pszTemplate = MAKEINTRESOURCE(nID);
    Page.pfnDlgProc = pDlgProc;
    Page.pszHeaderTitle = _tcsdup(szTitle);
    Page.pszHeaderSubTitle = _tcsdup(szSubTitle);

    HPROPSHEETPAGE PageHandle = CreatePropertySheetPage(&Page);

    return(PageHandle);

} //CreatePage

//+--------------------------------------------------------------
//
// Function: SetTitleFont
//
// Synopsis: Set font for the title in the welcome/ finish page
//
//+--------------------------------------------------------------
static void SetTitleFont(IN HWND hdlg)
{
    HWND hTitle = GetDlgItem(hdlg, IDC_TITLE);
         
    if (g_hTitleFont == 0)
    {
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        //
        // Create the title font
        //
        CResString strFontName( IDS_TITLE_FONTNAME );        
        CResString strFontSize( IDS_TITLE_FONTSIZE );        
        
        INT iFontSize = _wtoi( strFontSize.Get() );

        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        lstrcpy(TitleLogFont.lfFaceName, strFontName.Get());

        HDC hdc = GetDC(NULL); //gets the screen DC        
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72;
        g_hTitleFont = CreateFontIndirect(&TitleLogFont);
        ReleaseDC(NULL, hdc);
    }

    BOOL fRedraw = TRUE;
    SendMessage( 
          hTitle,               //(HWND) hWnd, handle to destination window 
          WM_SETFONT,           // message to send
          (WPARAM) &g_hTitleFont,   //(WPARAM) wParam, handle to font
          (LPARAM) &fRedraw     //(LPARAM) lParam, redraw option
        );
            
} //SetTitleFont

//+-------------------------------------------------------------------------
//
//  Function:   MqOcmRequestPages
//
//  Synopsis:   Handles the OC_REQUEST_PAGES interface routine.
//
//  Arguments:  [ComponentId] - supplies id for component. This routine
//                              assumes that this string does NOT need to
//                              be copied and will persist!
//              [WhichOnes]   - supplies type of pages fo be supplied.
//              [SetupPages]  - receives page handles.
//
//  Returns:    Count of pages returned, or -1 if error, in which case
//              SetLastError() will have been called to set extended error
//              information.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------
DWORD
MqOcmRequestPages(
    IN     const TCHAR               *ComponentId,
    IN     const WizardPagesType     WhichOnes,
    IN OUT       SETUP_REQUEST_PAGES *SetupPages )
{
    HPROPSHEETPAGE pPage = NULL ;
    DWORD          iPageIndex = 0 ;
    DWORD          dwNumofPages = 0 ;

#define  ADD_PAGE(dlgId, dlgProc, szTitle, szSubTitle, fFirstOrLast)                        \
            pPage = CreatePage(dlgId, /*(DLGPROC)*/dlgProc, szTitle, szSubTitle,fFirstOrLast) ; \
            if (!pPage) goto OnError ;                                                      \
            SetupPages->Pages[iPageIndex] = pPage;                                          \
            iPageIndex++ ;

    if (g_fCancelled)
        return 0;

    if ((0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE)) && !g_fUpgrade)
    {
        //
        // NT5 fresh install. Don't show dialog pages.
        //
        return 0;
    }

    if ( WizPagesWelcome == WhichOnes && g_fWelcome)
    {
        if (SetupPages->MaxPages < 1)
            return 1;

        CResString strTitle(IDS_WELCOME_PAGE_TITLE);
        CResString strSubTitle(IDS_WELCOME_PAGE_SUBTITLE);
        ADD_PAGE(IDD_Welcome, WelcomeDlgProc, strTitle.Get(), strSubTitle.Get(), TRUE);
        return 1;
    }

    if ( WizPagesFinal == WhichOnes && g_fWelcome)
    {
        if (SetupPages->MaxPages < 1)
            return 1;

        CResString strTitle(IDS_FINAL_PAGE_TITLE);
        CResString strSubTitle(IDS_FINAL_PAGE_SUBTITLE);
        ADD_PAGE(IDD_Final, FinalDlgProc, strTitle.Get(), strSubTitle.Get(), TRUE);
        return 1;
    }

    if ( WizPagesEarly == WhichOnes )
    {
        const UINT x_uMaxServerPages = 3;

        if (SetupPages->MaxPages < x_uMaxServerPages)
        {
            return x_uMaxServerPages ;
        }
      
        CResString strTitle(IDS_ServerName_PAGE_TITLE);
        CResString strSubTitle(IDS_ServerName_PAGE_SUBTITLE);
        ADD_PAGE(IDD_ServerName, MsmqServerNameDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

		strTitle.Load(IDS_Security_PAGE_TITLE);
		strSubTitle.Load(IDS_Security_PAGE_SUBTITLE);
		ADD_PAGE(IDD_Security, MsmqSecurityDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

        dwNumofPages = iPageIndex ;
    }

    return  dwNumofPages ;

OnError:
    ASSERT(0) ;
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return((DWORD)(-1));

#undef  ADD_PAGE
} //MqOcmRequestPages


//+-------------------------------------------------------------------------
//
//  Function:   WelcomeDlgProc
//
//  Synopsis:   Dialog procedure for the welcome page
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
WelcomeDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    )
{    
    int iSuccess = 0;
    switch( msg )
    {
        case WM_INITDIALOG:        
            SetTitleFont(hdlg);            
            break;        

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    if (g_fCancelled || !g_fWelcome)
                    {
                        iSuccess = SkipWizardPage(hdlg);
                        break;
                    }
                    PropSheet_SetWizButtons(GetParent(hdlg), 0) ;
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT) ;
                }

                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;
                }
            }
            break;
        }
    }

    return iSuccess;

} // WelcomeDlgProc



//+-------------------------------------------------------------------------
//
//  Function:   FinalDlgProc
//
//  Synopsis:   Dialog procedure for the final page
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
FinalDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    )
{
    int iSuccess = 0;
    switch( msg )
    {
        case WM_INITDIALOG:        
            SetTitleFont(hdlg);            
            break;  

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    if (!g_fWelcome)
                    {
                        iSuccess = SkipWizardPage(hdlg);
                        break;
                    }

                    CResString strStatus(IDS_SUCCESS_INSTALL);                    
                    if (g_fWrongConfiguration)
                    {
                        strStatus.Load(IDS_WELCOME_WRONG_CONFIG_ERROR);                       
                    }
                    else if (!g_fCoreSetupSuccess)
                    {
                        //
                        // g_fCoreSetupSuccess is set only in MSMQ Core.
                        // But we have this page only in upgrade mode, in CYS
                        // wizard where MSMQ Core is selected to be installed
                        // always. It means that we have correct value for
                        // this flag.
                        //
                        strStatus.Load(IDS_STR_GENERAL_INSTALL_FAIL);                        
                    }                    
                    SetDlgItemText(hdlg, IDC_SuccessStatus, strStatus.Get());

                    PropSheet_SetWizButtons(GetParent(hdlg), 0) ;
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_FINISH) ;
                }

                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;
                }
            }
            break;
        }
    }

    return iSuccess;

} // FinalDlgProc



//+-------------------------------------------------------------------------
//
//  Function:   MsmqSecurityDlgProc
//
//  Synopsis:   Dialog procedure for selection of MSMQ security model on DC
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
MsmqSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
	)
{
    int iSuccess = 0;

    switch( msg )
    {
        case WM_INITDIALOG:
        {
            g_hPropSheet = GetParent(hdlg);
            iSuccess = 1;
            break;
        }

        case WM_COMMAND:
        {
            if ( BN_CLICKED == HIWORD(wParam) )
            {
				DWORD dwAllow = 0;
                switch (LOWORD(wParam))
                {
                    case IDC_RADIO_STRONG:
						dwAllow = 0;
						MqWriteRegistryValue(MSMQ_ALLOW_NT4_USERS_REGNAME, sizeof(DWORD),
							                 REG_DWORD, &dwAllow);
                        break;

                    case IDC_RADIO_WEAK:
						dwAllow = 1;
						MqWriteRegistryValue(MSMQ_ALLOW_NT4_USERS_REGNAME, sizeof(DWORD),
							                 REG_DWORD, &dwAllow);
                        break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            iSuccess = 0;

            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {   
                  //
                  // show this page only when MQDS subcomponent
                  // is selected for installation
                  //
                  if (g_fCancelled           ||
                      INSTALL != g_SubcomponentMsmq[eMQDSService].dwOperation ||
                      g_fUpgrade             ||
                      !MqInit()              ||
                      !g_dwMachineTypeDs     ||
                      g_fWelcome && Msmq1InstalledOnCluster()
                      )
                  {
                      iSuccess = SkipWizardPage(hdlg);
                      break;
                  }                  

                  if (g_fBatchInstall)
                  {
                      //
                      // Unattended. Read security model from INI file.
                      // Default is strong.
                      //
                      TCHAR szSecurity[MAX_STRING_CHARS];
                      try
                      {
                          ReadINIKey(
                              L"SupportLocalAccountsOrNT4",
                              sizeof(szSecurity) / sizeof(szSecurity[0]),
                              szSecurity
                              );
                          if (OcmStringsEqual(szSecurity, _T("TRUE")))
                          {
							  DWORD dwAllow = 1;
							  MqWriteRegistryValue(
                                  MSMQ_ALLOW_NT4_USERS_REGNAME,
                                  sizeof(DWORD),
                                  REG_DWORD,
                                  &dwAllow
                                  );
                          }
                      }
                      catch(exception)
                      {
                      }
                            
                      iSuccess = SkipWizardPage(hdlg);
                      break;
                  }

                  //
                  // Check if the relaxation flag was already set. If so,
                  // do not display this page.
                  //
                  ULONG ulRelax = MQ_E_RELAXATION_DEFAULT ;
                  HRESULT hr = GetNt4RelaxationStatus(&ulRelax) ;
                  if (SUCCEEDED(hr) &&
                      (ulRelax != MQ_E_RELAXATION_DEFAULT))
                  {
                      //
                      // Relaxation bit already set. Do not display this
                      // page. This page should be displayed only on first
                      // setup of a MSMQ on domain controller,
                      // enterptise-wide.
                      //
                      iSuccess = SkipWizardPage(hdlg);
                      break;
                  }

                  CResString strPageDescription(IDS_SECURITY_PAGE_DESCRIPTION);

                  SetDlgItemText(
                        hdlg,
                        IDC_SECURITY_PAGE_DESCRIPTION,
                        strPageDescription.Get()
                        );

				  DWORD dwAllow = 0;
				  MqWriteRegistryValue( MSMQ_ALLOW_NT4_USERS_REGNAME,
                                        sizeof(DWORD),
                                        REG_DWORD,
                                       &dwAllow) ;
                  CheckRadioButton(
                      hdlg,
                      IDC_RADIO_STRONG,
                      IDC_RADIO_WEAK,
                      IDC_RADIO_STRONG
                      );

                  //
                  // Accept activation
                  //
                  // it is the first page, disable BACK button
                  PropSheet_SetWizButtons(GetParent(hdlg), (PSWIZB_NEXT)) ;
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_WIZBACK:
              case PSN_WIZFINISH:
              case PSN_QUERYCANCEL:

                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;

              case PSN_WIZNEXT:
              {
                  SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                  iSuccess = 1;
                  break;
              }
            }
            break;
        }
        default:
        {
            iSuccess = 0;
            break;
        }
    }

    return iSuccess;

} // MsmqSecurityDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\spx\gethost.h ===
/*++

Module Name:

    gethost.h

Abstract:

    IPX-specific stuff.

Author:

    Jeff Roberts (jroberts)  15-Nov-1995

Revision History:

     15-Nov-1995     jroberts

        Created this module.

--*/

#ifndef  _GETHOST_H_
#define  _GETHOST_H_

// Milliseconds const
UINT CACHE_EXPIRATION_TIME = (10 * 60 * 1000);
//const UINT CACHE_SIZE            = DEBUG_MIN(2,8);

RPC_STATUS
IpxNameToAddress(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    );

RPC_STATUS
AddServerToCache(
    char  * Name,
    SOCKADDR_IPX * Address
    );

BOOL
FindServerInCache(
    char  * Name,
    SOCKADDR_IPX * Address,
    unsigned * Time
    );

void
CachedServerContacted(
    char  * Name
    );

BOOL
CachedServerNotContacted(
    char  * Name
    );




#endif //  _GETHOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\win.95\migrate\migrate.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.cpp

Abstract:

    Handles upgrade of Win9x + MSMQ 1.0 to W2K/XP

Author:

    Shai Kariv  (ShaiK)  22-Apr-98

--*/

#include <windows.h>
#include <winuser.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>
#include <assert.h>
#include <autorel2.h>
#include "uniansi.h"
#define  MQUTIL_EXPORT
#include "mqtypes.h"
#include "_mqdef.h"

#include "..\..\msmqocm\setupdef.h"
#include "..\..\msmqocm\comreg.h"
#include "resource.h"

//
// Info needed for Win95 migration
//
#define PRODUCT_ID     TEXT("Microsoft Message Queuing Services")
#define COMPANY        TEXT("Microsoft Corporation")
#define SUPPORT_NUMBER TEXT("1-800-936-3500 (USA Only)")
#define SUPPORT_URL    TEXT("http://go.microsoft.com/fwlink/?LinkId=803")
#define INSTRUCTIONS   TEXT("Please contact Microsoft Technical Support for assistance with this problem.")
typedef struct {
	CHAR	CompanyName[256];
	CHAR	SupportNumber[256];
	CHAR	SupportUrl[256];
	CHAR	InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

//
// Name of log file
//
TCHAR g_szLogPath[MAX_PATH];

//
// HINSTANCE of this module
//
HINSTANCE g_hInstance = NULL;


//+--------------------------------------------------------------
//
// Function: LogMessage
//
// Synopsis: Writes a message to a log file, for debugging.
//
//+--------------------------------------------------------------
void
LogMessage(
    LPCTSTR msg,
    DWORD   ErrorCode
	)
{
    TCHAR message[1000];
    lstrcpy(message, msg);

    if (ErrorCode != 0)
    {
        TCHAR err[20];
        _itoa(ErrorCode, err, 16);
        lstrcat(message, err);
    }

	//
	// Open the log file
	//
	HANDLE hLogFile = CreateFile(
		                  g_szLogPath, 
						  GENERIC_WRITE, 
						  FILE_SHARE_READ, 
						  NULL, 
						  OPEN_ALWAYS,
		                  FILE_ATTRIBUTE_NORMAL, 
						  NULL
						  );
	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		//
		// Append the message to the end of the log file
		//
		lstrcat(message, _T("\r\n"));
		SetFilePointer(hLogFile, 0, NULL, FILE_END);
		DWORD dwNumBytes = lstrlen(message) * sizeof(message[0]);
		WriteFile(hLogFile, message, dwNumBytes, &dwNumBytes, NULL);
		CloseHandle(hLogFile);
	}
} // LogMessage


//+-------------------------------------------------------------------------
//
//  Function:    SaveMsmqInfo
//
//  Description: Saves root directory of MSMQ and MSMQ type (dependent
//               or independent client) in a tmp file. This file
//               will later be read during GUI mode, by msmqocm.dll,
//               to get the info.
//
//--------------------------------------------------------------------------
static
LONG
SaveMsmqInfo(
	IN const LPTSTR szMsmqDir,
	IN const BOOL   fDependentClient
	)
{
	//
	// Generate the info file name (under %WinDir%)
	//
	TCHAR szMsmqInfoFile[MAX_PATH];
	GetWindowsDirectory(
		szMsmqInfoFile, 
		sizeof(szMsmqInfoFile)/sizeof(szMsmqInfoFile[0])
		);
	_stprintf(szMsmqInfoFile, TEXT("%s\\%s"), szMsmqInfoFile, MQMIG95_INFO_FILENAME);

	//
	// Open the file for write. First delete old file if exists.
	//
	DeleteFile(szMsmqInfoFile); 
	HANDLE hFile = CreateFile(
		               szMsmqInfoFile, 
					   GENERIC_WRITE, 
					   FILE_SHARE_READ, 
					   NULL, 
					   OPEN_ALWAYS,
					   FILE_ATTRIBUTE_NORMAL, 
					   NULL
					   );
	if (INVALID_HANDLE_VALUE == hFile)
    {
        DWORD gle = GetLastError();
        LogMessage(_T("Failed to open MSMQINFO.TXT for writing, error 0x"), gle);
		return gle;
    }

	//
	// Create MSMQ section and write the info
	//
	TCHAR szBuffer[MAX_STRING_CHARS];
	
	_stprintf(szBuffer, TEXT("[%s]\r\n"), MQMIG95_MSMQ_SECTION);
	DWORD dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
	BOOL bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);

    DWORD gle = GetLastError();
	if (bSuccess)
	{
		_stprintf(szBuffer, TEXT("%s = %s\r\n"), MQMIG95_MSMQ_DIR, szMsmqDir);
		dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
		bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);
        gle = GetLastError();
	}
    else
    {
        LogMessage(_T("Failed to write the MSMQ folder in MSMQINFO.TXT, error 0x"), gle);
    }
	
	if (bSuccess)
	{
		_stprintf(szBuffer, TEXT("%s = %s\r\n"), MQMIG95_MSMQ_TYPE,
			fDependentClient ? MQMIG95_MSMQ_TYPE_DEP : MQMIG95_MSMQ_TYPE_IND);
		dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
		bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);
        gle = GetLastError();
        if (!bSuccess)
            LogMessage(_T("Failed to write the MSMQ type (flavor) in MSMQINFO.TXT, error 0x"), gle);
	}
	
	CloseHandle(hFile);

	return (bSuccess ? ERROR_SUCCESS : gle);

} // SaveMsmqInfo


//+-------------------------------------------------------------------------
//
//  Function:    MqReadRegistryValue
//
//  Description: Reads values from MSMQ registry section
//
//--------------------------------------------------------------------------
static
LONG
MqReadRegistryValue(
    IN     const LPCTSTR szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData
	)
{
    TCHAR szMsg[1024];

	// 
	// Parse the entry to detect key name and value name
	//
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    TCHAR szValueName[256] = {_T("")};
	lstrcpy(szValueName, _tcsinc(pLastBackslash));
	lstrcpy(pLastBackslash, TEXT(""));

	//
	// Open the key for read
	//
	HKEY  hRegKey;
	LONG rc = RegOpenKeyEx(
		          HKEY_LOCAL_MACHINE,
				  szKeyName,
				  0,
				  KEY_READ,
				  &hRegKey
				  );
	if (ERROR_SUCCESS != rc)
	{
        lstrcpy(szMsg, _T("Failed to open MSMQ registry key '"));
        lstrcat(szMsg, szKeyName);
        lstrcat(szMsg, _T("', error 0x"));
        LogMessage(szMsg, rc);
		return rc;
	}

	//
	// Get the value data
	//
    rc = RegQueryValueEx( 
		     hRegKey, 
			 szValueName, 
			 0, 
			 NULL,
             (PBYTE)pValueData, 
			 &dwNumBytes
			 );
	if (ERROR_SUCCESS != rc)
	{
        lstrcpy(szMsg, _T("Failed to query MSMQ registry value '"));
        lstrcat(szMsg, szValueName);
        lstrcat(szMsg, _T("', error 0x"));
        LogMessage(szMsg, rc);
		return rc;
	}

    RegCloseKey(hRegKey);
	return ERROR_SUCCESS;

} // MqReadRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqAcmeInstalled
//
//  Description: Detetcs\msmq\src\ac\init ACME installation of MSMQ 1.0
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqAcmeInstalled(
	OUT LPTSTR pszMsmqDir,
	OUT BOOL   *pfDependentClient
	)
{
    TCHAR szMsg[1024];

    //
    // Open ACME registry key for read
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_READ,
                  &hKey 
                  );
	if (rc != ERROR_SUCCESS)
    {
		//
		// MSMQ 1.0 (ACME) not installed. Get out of here.
		//
        LogMessage(_T("Failed to open ACME registry key (assuming MSMQ 1.0 ACME is not installed), error 0x"), rc);
		return ERROR_NOT_INSTALLED;
	}

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile, *p ;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            assert(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            p = CharNext(pFile);
            if (OcmStringsEqual(p, ACME_STF_NAME))
            {
                //
                // Found. Cut the STF file name from the full path name.
                //
                _stprintf(
                    szMsg, 
                    _T("The following MSMQ entry was found in the ACME section of the registry: %s"), 
                    szValueData
                    );
                LogMessage(szMsg, 0);
                *pFile = TEXT('\0') ;
                bFound = TRUE;
            }
            else
            {
                pFile = CharNext(pFile) ;
            }

        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found (there's no ACME installation
		// of MSMQ 1.0 on this machine).
        //
        LogMessage(_T("No MSMQ entry was found in the ACME section of the registry."), 0);
        return ERROR_NOT_INSTALLED;
    }

    //
    // Remove the "setup" subdirectory from the path name.
    //
    pFile = _tcsrchr(szValueData, TEXT('\\')) ;
    p = CharNext(pFile);
    *pFile = TEXT('\0') ;
    if (!OcmStringsEqual(p, ACME_SETUP_DIR_NAME))
    {
        //
        // That could be a problem. It should have been "setup".
        //
        _stprintf(szMsg, 
            _T("Warning: Parsing the MSMQ 1.0 entry in the ACME section of the registry gave '%s,"
            "' while '%s' was expected."),
            p,
            ACME_SETUP_DIR_NAME
            );
        LogMessage(szMsg, 0);
    }

	//
	// Store MSMQ root directory.
	//
    _stprintf(szMsg, _T("The MSMQ 1.0 ACME folder is %s."), szValueData);
    LogMessage(szMsg, 0);
	if (pszMsmqDir)
        lstrcpy(pszMsmqDir, szValueData);

    //
    // Get MSMQ type: Dependent or Independent Client
    //
    DWORD dwMsmqType;
    rc = MqReadRegistryValue(
             MSMQ_ACME_TYPE_REG,
			 sizeof(DWORD),
			 (PVOID) &dwMsmqType
			 );
    if (ERROR_SUCCESS != rc)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        // Consider ACME installation to be corrupted (not completed successfully).
        //
        LogMessage(_T("Failed to read the MSMQ type (flavor) from the registry, error 0x"), rc);
        return ERROR_NOT_INSTALLED;
    }

	BOOL fDependentClient;
    switch (dwMsmqType)
    {
        case MSMQ_ACME_TYPE_DEP:
        {
            fDependentClient = TRUE;
            break;
        }
        case MSMQ_ACME_TYPE_IND:
        {
			fDependentClient = FALSE;
            break;
        }

        default:
        {
            //
            // Unknown MSMQ 1.0 type
            // Consider ACME installation to be corrupted 
			// (not completed successfully).
			//
            LogMessage(_T("The MSMQ type (flavor) is unknown, error 0x"), dwMsmqType);
            return ERROR_NOT_INSTALLED;
            break;
        }
    }

	//
	// At this point we know that MSMQ 1.0 was installed by ACME,
	// and we got its root dir and type.
	//
    _stprintf(szMsg, _T("The MSMQ 1.0 computer is %s."), 
        fDependentClient ? _T("a dependent client") : _T("an independent client"));
    LogMessage(szMsg, 0);
	if (pfDependentClient)
		*pfDependentClient = fDependentClient;
    return ERROR_SUCCESS;

} // CheckMsmqAcmeInstalled


//+-------------------------------------------------------------------------
//
//  Function:   CheckInstalledComponents
//
//--------------------------------------------------------------------------
static
LONG
CheckInstalledComponents(
	OUT LPTSTR pszMsmqDir,
	OUT BOOL   *pfDependentClient
	)
{
    TCHAR szMsg[1024];

    //
    // Look in MSMQ registry section for InstalledComponents value.
    // If it exists, MSMQ 1.0 (K2) is installed.
    //
	DWORD dwOriginalInstalled;
	LONG rc = MqReadRegistryValue( 
      		      OCM_REG_MSMQ_SETUP_INSTALLED,
				  sizeof(DWORD),
				  (PVOID) &dwOriginalInstalled
				  );

	TCHAR szMsmqDir[MAX_PATH];
	BOOL fDependentClient = FALSE;
    if (ERROR_SUCCESS != rc)
    {
        //
		// MSMQ 1.0 (K2) not installed.
        // Check if MSMQ 1.0 (ACME) is installed.
        //
        LogMessage(_T("MSMQ 1.0 K2 was not found (trying MSMQ 1.0 ACME), error 0x"), rc);
        rc = CheckMsmqAcmeInstalled(szMsmqDir, &fDependentClient);
		if (ERROR_SUCCESS != rc)
		{
			// 
			// MSMQ 1.0 is not installed on this machine.
			// Get out of here.
			//
            LogMessage(_T("MSMQ 1.0 ACME was not found, error 0x"), rc);
			return ERROR_NOT_INSTALLED;
		}
    }
	else 
	{
		//
		// MSMQ 1.0 (K2) is installed. 
		// Get its root directory.
		//
        LogMessage(_T("MSMQ 1.0 K2 was found."), 0);
		rc = MqReadRegistryValue(
			     OCM_REG_MSMQ_DIRECTORY,
				 sizeof(szMsmqDir),
				 (PVOID) szMsmqDir
				 );
		if (ERROR_SUCCESS != rc)
		{
			//
			// MSMQ registry section is messed up. 
			// Consider K2 installation to be corrupt
			// (not completed successfully).
			//
            LogMessage(_T("Failed to read the MSMQ folder from the registry, error 0x"), rc);
			return ERROR_NOT_INSTALLED;
		}
        _stprintf(szMsg, TEXT("The MSMQ folder is %s."), szMsmqDir);
        LogMessage(szMsg, 0);
		
		//
		// Get type of MSMQ (K2): Dependent or Independent Client
		//
		switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
		{
            case OCM_MSMQ_IND_CLIENT_INSTALLED:
			{
				fDependentClient = FALSE;
				break;
			}
            case OCM_MSMQ_DEP_CLIENT_INSTALLED:
			{
				fDependentClient = TRUE;
				break;
			}
            default:
			{
				//
				// Unexpected MSMQ type.
				// Consider K2 installation to be corrupt
				// (not completed successfully).
				//
                LogMessage(
                    _T("The type of MSMQ computer is unknown, error 0x"), 
                    dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK
                    );
				return ERROR_NOT_INSTALLED;
				break;
			}
		}
	}

	//
	// At this point we know that MSMQ 1.0 was installed by
	// ACME or K2, and we got the root dir and type of MSMQ 1.0
	//
	if (pszMsmqDir)
	    lstrcpy(pszMsmqDir, szMsmqDir);
	if (pfDependentClient)
		*pfDependentClient = fDependentClient;

    _stprintf(szMsg, TEXT("The MSMQ computer is %s."), 
        fDependentClient ? TEXT("a dependent client") : TEXT("an independent client"));
    LogMessage(szMsg, 0);

	return ERROR_SUCCESS;

} // CheckInstalledComponents


//+--------------------------------------------------------------
//
// Function: RemoveDirectoryTree
//
// Synopsis: Remove the specified folder including files/subfolders
//
//+--------------------------------------------------------------
void
RemoveDirectoryTree(
    LPCTSTR Directory
    )
{
    TCHAR msg[MAX_PATH * 2] = _T("Removing folder ");
    lstrcat(msg, Directory);
    LogMessage(msg, 0);

    TCHAR szTemplate[MAX_PATH] = _T("");
    lstrcpy(szTemplate, Directory);
    lstrcat(szTemplate, _T("\\*.*"));

    WIN32_FIND_DATA finddata;
    CFindHandle hEnum(FindFirstFile(szTemplate, &finddata));
    
    if (hEnum == INVALID_HANDLE_VALUE)
    {
        RemoveDirectory(Directory);
        return;
    }

    do
    {
        if (finddata.cFileName[0] == _T('.'))
        {
            continue;
        }

        TCHAR FullPath[MAX_PATH] = _T("");
        lstrcpy(FullPath, Directory);
        lstrcat(FullPath, _T("\\"));
        lstrcat(FullPath, finddata.cFileName);

        if (0 != (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            RemoveDirectoryTree(FullPath);
            continue;
        }

        DeleteFile(FullPath);
    }
    while (FindNextFile(hEnum, &finddata));
    
    RemoveDirectory(Directory);

} //RemoveDirectoryTree


//+-------------------------------------------------------------------------
//
//  Function:   RemoveStartMenuShortcuts
//
//  Description: Remove MSMQ shortcuts from the Start menu
//
//--------------------------------------------------------------------------
static
void
RemoveStartMenuShortcuts(
    void
    )
{
    //
    // Default folder of StartMenu/Programs is %windir%\Start Menu\Programs
    //
    TCHAR folder[MAX_PATH];
    GetWindowsDirectory(folder, sizeof(folder)/sizeof(folder[0]));
    lstrcat(folder, _T("\\Start Menu\\Programs"));

    //
    // Read from registry if alternate folder is used
    //
    HKEY hKey;
    LONG rc;
    rc = RegOpenKeyEx(
             HKEY_USERS, 
             _T(".Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
             0,
             KEY_READ,
             &hKey
             );
    if (rc != ERROR_SUCCESS)
    {
        LogMessage(_T("Failed to open registry key 'HKEY_USERS\\Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders' for read, error 0x"), rc);
    }
    else
    {
        DWORD size = sizeof(folder);
        rc = RegQueryValueEx(hKey, _T("Programs"), NULL, NULL, reinterpret_cast<PBYTE>(folder), &size);
        RegCloseKey(hKey);
        if (rc != ERROR_SUCCESS)
        {
            LogMessage(_T("Failed to query registry value 'HKEY_USERS\\Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Programs' for read, error 0x"), rc);
        }
    }

    //
    // Append MSMQ group subfolder to StartMenu\Programs
    //
    TCHAR MsmqGroup[MAX_PATH] = MSMQ_ACME_SHORTCUT_GROUP;
    MqReadRegistryValue(MSMQ_ACME_SHORTCUT_GROUP, sizeof(MsmqGroup), MsmqGroup);
    lstrcat(folder, _T("\\"));
    lstrcat(folder, MsmqGroup);

    //
    // Remove the entire MSMQ group shortcuts from the start menu
    //
    RemoveDirectoryTree(folder);
    
} // RemoveStartMenuShortcuts


//+-------------------------------------------------------------------------
//
//  Function:   IsWindowsPersonal
//
//  Description: Check if upgrade to Windows Personal
//
//--------------------------------------------------------------------------
static
bool
IsWindowsPersonal(
    LPCTSTR InfFilename
    )
{
    //
    // Open migrate.inf
    //
    HINF hInf = SetupOpenInfFile(InfFilename, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
    {
        DWORD err = GetLastError();
        LogMessage(_T("SetupOpenInfFile failed, error 0x"), err);
        return false;
    }

    //
    // Read the SetupSKU key in the [Version] section
    //
    TCHAR buffer[250];
    DWORD size = sizeof(buffer)/sizeof(buffer[0]);
    BOOL rc = SetupGetLineText(NULL, hInf, _T("Version"), _T("SetupSKU"), buffer, size, NULL);

    //
    // Close migrate.inf
    //
    SetupCloseInfFile(hInf);
    
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("SetupGetLineText failed, error "), err);
        return false;
    }

    TCHAR msg[250] = _T("SetupSKU is ");
    lstrcat(msg, buffer);
    LogMessage(msg, 0);

    return (lstrcmp(buffer, _T("Personal")) == 0);

} // IsWindowsPersonal


//+-------------------------------------------------------------------------
//
//  Function:   HandleWindowsPersonal
//
//  Description: Called on upgrade to Windows Personal. Issue compatibility
//               warning.
//
//--------------------------------------------------------------------------
static
LONG
HandleWindowsPersonal(
    LPCTSTR InfFilename
    )
{
    //
    // Register incompatability warning in [Incompatible Messages] section in the form:
    // MessageQueuing="Message Queuing is not supported on Windows XP Personal"
    //
    TCHAR Warning[250];
    LoadString(g_hInstance, IDS_COMPAT_WARNING, Warning, sizeof(Warning)/sizeof(Warning[0]));

    TCHAR Warning1[250] = _T("\"");
    lstrcat(Warning1, Warning);
    lstrcat(Warning1, _T("\""));

    BOOL rc;
    rc = WritePrivateProfileString(_T("Incompatible Messages"), _T("MessageQueuing"), Warning1, InfFilename);
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("WritePrivateProfileString in [Incompatible Messages] failed, error "), err);
        return err;
    }

    //
    // Create a [MessageQueuing] section only for the compatability warning to work.
    // Register one MSMQ file in the [MessageQueuing] section in the form:
    // "C:\Windows\System\MQRT.DLL"=File
    //
    TCHAR SystemDirectory[MAX_PATH];
    GetSystemDirectory(SystemDirectory, sizeof(SystemDirectory)/sizeof(SystemDirectory[0]));
    TCHAR FullFilename[MAX_PATH * 2] = _T("\"");
    lstrcat(FullFilename, SystemDirectory);
    lstrcat(FullFilename, _T("\\MQRT.DLL\""));
    rc = WritePrivateProfileString(_T("MessageQueuing"), FullFilename, _T("File"), InfFilename);
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("WritePrivateProfileString in [MessageQueuing] failed, error "), err);
        return err;
    }

    WritePrivateProfileString(NULL, NULL, NULL, InfFilename);
    return ERROR_SUCCESS;

} // HandleWindowsPersonal


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL 
DllMain(
	IN const HANDLE DllHandle,
    IN const DWORD  Reason,
    IN const LPVOID Reserved 
	)
{
	UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )    
    {
        case DLL_PROCESS_ATTACH:
            
            g_hInstance = (HINSTANCE) DllHandle;

            //
            // Initialize log file
            //
            
            GetWindowsDirectory(g_szLogPath, sizeof(g_szLogPath)/sizeof(g_szLogPath[0]));
            lstrcat(g_szLogPath, TEXT("\\mqw9xmig.log"));
            DeleteFile(g_szLogPath);

            SYSTEMTIME time;
            GetLocalTime(&time);
            TCHAR szTime[MAX_STRING_CHARS];
            _stprintf(szTime, TEXT("  %u-%u-%u %u:%u:%u:%u \r\n"), time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute,
                time.wSecond, time.wMilliseconds);
            TCHAR szMsg[1024];
            lstrcpy(szMsg, TEXT("MSMQ migration"));
            lstrcat(szMsg, szTime);
            LogMessage(szMsg, 0);
            break; 

        default:
            break;
    }

    return TRUE;

} // DllMain


//+-------------------------------------------------------------------------
//
//  Function:   QueryVersion
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
QueryVersion(
	OUT LPCSTR *ProductID,
	OUT LPUINT DllVersion,
	OUT LPINT *CodePageArray,	OPTIONAL
	OUT LPCSTR *ExeNamesBuf,	OPTIONAL
	OUT PVENDORINFO *VendorInfo
	)
{
    static CHAR	ProductIDBuff[256];
    if (0 == LoadString(g_hInstance, IDS_PRODUCT_ID, ProductIDBuff, sizeof(ProductIDBuff)/sizeof(TCHAR)))
    {
        lstrcpy(ProductIDBuff, PRODUCT_ID);
    }
    *ProductID = ProductIDBuff;

    *DllVersion = 1;
	*CodePageArray = NULL;
	*ExeNamesBuf = NULL;

    static VENDORINFO MyVendorInfo;
    if (0 == LoadString(g_hInstance, IDS_COMPANY, MyVendorInfo.CompanyName, sizeof(MyVendorInfo.CompanyName)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.CompanyName, COMPANY);
    }
    if (0 == LoadString(g_hInstance, IDS_SUPPORT_NUMBER, MyVendorInfo.SupportNumber, sizeof(MyVendorInfo.SupportNumber)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.SupportNumber, SUPPORT_NUMBER);
    }

    lstrcpy(MyVendorInfo.SupportUrl, SUPPORT_URL);

    if (0 == LoadString(g_hInstance, IDS_INSTRUCTIONS, MyVendorInfo.InstructionsToUser, sizeof(MyVendorInfo.InstructionsToUser)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.InstructionsToUser, INSTRUCTIONS);
    }	
    *VendorInfo = &MyVendorInfo;

    return CheckInstalledComponents(NULL, NULL);

} // QueryVersion 


//+-------------------------------------------------------------------------
//
//  Function:   Initialize9x 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
Initialize9x(
    LPCSTR WorkingDirectory,
    LPCSTR /*SourceDirectories*/,
    LPCSTR /*MediaDirectory*/
    )
{
    //
    // If MSMQ not installed do nothing
    //
	TCHAR MsmqDirectory[MAX_PATH];
	BOOL  fDependentClient;
    LONG rc = CheckInstalledComponents(MsmqDirectory, &fDependentClient);
    if (rc != ERROR_SUCCESS)
	{
        return rc;
    }

    //
    // Remove MSMQ from the Start menu
    //
    RemoveStartMenuShortcuts();
    
    //
    // Generate full filename for migrate.inf
    //
    TCHAR InfFilename[MAX_PATH];
    lstrcpy(InfFilename, WorkingDirectory);
    lstrcat(InfFilename, _T("\\migrate.inf"));

    //
    // For Windows Personal: generate compatibility warning so the user can decide
    // to cancel or proceed the OS upgrade.
    // Return without saving MSMQ information for later use by msmqocm.dll,
    // thus effectively MSMQ will be uninstalled if user proceeds with the upgrade.
    //
    if (IsWindowsPersonal(InfFilename))
    {
        rc = HandleWindowsPersonal(InfFilename);
        if (rc != ERROR_SUCCESS)
        {
            return rc;
        }

        return ERROR_SUCCESS;
    }

    //
    // Save MSMQ registry information for later use by msmqocm.dll (which handles
    // MSMQ upgrade).
    //
	rc = SaveMsmqInfo(MsmqDirectory, fDependentClient);
    if (rc != ERROR_SUCCESS)
    {
        return rc;
    }

    return ERROR_SUCCESS;

} // Initialize9x

	
//+-------------------------------------------------------------------------
//
//  Function:   MigrateUser9x
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateUser9x(
    HWND, 
    LPCSTR,
    HKEY, 
    LPCSTR, 
    LPVOID
    )
{
    return ERROR_SUCCESS;

} // MigrateUser9x


//+-------------------------------------------------------------------------
//
//  Function:   MigrateSystem9x 
//
//--------------------------------------------------------------------------
LONG 
CALLBACK 
MigrateSystem9x(
    HWND, 
    LPCSTR,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateSystem9x 


//+-------------------------------------------------------------------------
//
//  Function:   InitializeNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
InitializeNT(
    LPCWSTR,
    LPCWSTR,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // InitializeNT


//+-------------------------------------------------------------------------
//
//  Function:   MigrateUserNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateUserNT(
    HINF,
    HKEY,
    LPCWSTR, 
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateUserNT


//+-------------------------------------------------------------------------
//
//  Function:   MigrateSystemNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateSystemNT(
    HINF,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateSystemNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\spx\spx_stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard include file for QM componenet

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <mqprops.h>
#include <mqtypes.h>
#include <_mqdef.h>
#include <mqutil.h>
#include <cs.h>

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\win.95\migrate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//

#define IDS_PRODUCT_ID                  101
#define IDS_COMPANY                     102
#define IDS_SUPPORT_NUMBER              103
#define IDS_INSTRUCTIONS                105
#define IDS_COMPAT_WARNING              106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           201
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\accomp.h ===
//this is a headrs file that was created to make ac header (packet.h for example) files compiled
//by modules in this project.
#ifndef ACCOMPILE_H
#define ACCOMPILE_H

typedef int BOOL;
#define IO_MQAC_INCREMENT           2
extern "C" 
{
#include <ntddk.h>
#include <ntp.h>
}

#include <mqsymbls.h>
#include <actempl.h>
#include <debug.h>



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\spx\spxgeth.cpp ===
/*++

Module Name:

    gethost.c

Abstract:

    Maps a server name to SPX address by consulting the Netware Bindery.
    Attach/Detach/FindFileServer, and ReadPropertyValue were all borrowed
    from the SQL 6.0 code base.

Author:

    Jeff Roberts (jroberts)  20-Nov-1995

Revision History:

     20-Nov-1995     jroberts

        Took code from AndreasK of SQL Server, and modified it for RPC.
     8-sep-98
     updating code to support several addresses of local host ( taken from
     ipxname.cxx)

--*/

#include "spx_stdh.h"

#define CRITICAL_SECTION_WRAPPER CRITICAL_SECTION

#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <nspapi.h>
#include <rpc.h>

#include <stdio.h>


ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#include "gethost.h"

#define MAX_FILESRVS            5               /* try 5 servers (chicago uses this same number) */
#define WINSOCKET_MAJOR         1               /* Highest WinSocket version we can use is 1.1 */
#define WINSOCKET_MINOR         1
#define SOCKADDR        struct sockaddr

/*****  NETWARE MAGIC NUMBERS   *****/

#define NSPROTO_NCP (NSPROTO_IPX+0x11)

/* NCP Request Types */
#define CREATE_CONN_REQTYPE             0x1111
#define DESTROY_CONN_REQYPE             0x5555
#define GENERAL_REQTYPE                 0x2222

/* NCP Request Codes */
#define NCP_SCAN_BINDERY                0x17
#define NCP_END_OF_TASK                 0x18
#define NCP_LOGOUT                      0x19
#define NCP_NEG_BUFFER_SIZE             0x21

/* NCP Function codes */
#define SCAN_BINDERY_FUNC               0x37
#define READ_PROP_VALUE_FUNC            0x3D

/* SAP protocol request codes */
#define SAP_GENERAL_QUERY                0x0100  /* general query hi-lo   */
#define SAP_GENERAL_RESPONSE             0x0200  /* general response hi-lo            */
#define SAP_NEAREST_QUERY                0x0300  /* nearest query hi-lo   */
#define SAP_NEAREST_RESPONSE             0x0400  /* nearest response hi-lo   */


/* Socket Numbers       */
#define NCP_SOCKET                       0x5104  /* SAP socket hi-lo              */
#define SAP_SOCKET                       0x5204  /* SAP socket hi-lo              */
#define GUEST_SOCKET                     0x1840

/* SAP Service Types */
#define FILE_SERVER                      0x0400  /* netware file server hi-lo     */
#define SNA_SERVER                       0x4404  /* SNA Server type 0x0444        */
#define BRIDGE_SERVER                    0x2400

#define SAP_SERVICE_STOPPED              0x1000  /* invalid hub count, hi-lo      */
#define SAP_TIMEOUT                      60000   /* SAP timeout, one minute       */
#define NCP_CONNECTION_ERROR             0x15    /* connection error mask         */

#define BINDERY_FAILURE                  0x00FF  /* bindery call failed           */

#define RPC_SAP_TYPE                    0x0640

#define SWAP(x) (USHORT)(((((USHORT)x)<<8)&0xFF00) | ((((USHORT)x)>>8)&0x00FF))

typedef struct
{
  CSADDR_INFO   info;
  SOCKADDR_IPX  addr1;
  SOCKADDR_IPX  addr2;
} CSADDR_BUFFER;


#pragma pack(1)

typedef struct _sip_entry
{
    char           server_name[48];
    unsigned long  network;
    char           node[6];
    unsigned short socket;
    unsigned short hops;
} SIP_ENTRY;

typedef struct _sip             /* Service Information Packet */
{
    unsigned short response_type;
    unsigned short server_type;
    SIP_ENTRY      entries[7];
} SIP;

typedef struct          /* Service Query Packet */
{
    unsigned short query_type;
    unsigned short server_type;
} SQP;

typedef struct  /* NCP Request Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char req_code;

} NCPHDR;

typedef struct  /* NCP Response Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char ret_code;
    unsigned char conn_status;
} NCPRSP;

typedef struct  /* Scan Bindery Request */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned long  last_id;
    unsigned short obj_type;
    unsigned char sstring[49];
} SCANREQ;
#define SCANSIZE        56

typedef struct  /* Scan Bindery Response */
{
    NCPRSP hdr;
    unsigned long  obj_id;
    unsigned short obj_type;
    unsigned char  obj_name[48];
    unsigned char  obj_status;
    unsigned char  sec_status;
    unsigned char  status_flags;
} SCANRSP;

typedef struct  /* Read Propery Value */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned short obj_type;
    unsigned char  obj_name[49];
    unsigned char  seg_no;
    unsigned char  prop_name[17];
} RVALREQ;
#define RVALSIZE        70

typedef struct  /* Read Propery Value Response */
{
    NCPRSP hdr;
    unsigned char  prop_value[128];
    unsigned char  more_flag;
    unsigned char  prop_flags;
} RVALRSP;

#pragma pack()


struct
{
    SOCKADDR_IPX nsRemote[MAX_FILESRVS];    /* Remote IPX addresses                 */
    unsigned     ServerCount;               /* number of valid entries in nsRemote  */
    unsigned     ActiveServer;              /* index of the the address in use      */
    SOCKET       s;                         /* Socket handle                        */
    unsigned short ConnectionId;
    union
    {
        NCPHDR       nhHeader;              /* Last NCP header sent                 */
        char         Bytes[1024];
    };
    char         RcvBuffer[1024];
}
nsStatus;

typedef struct IPXAddress
{
   char                 network[4];
   char                 node[6];
   unsigned short       socket;
} IPXAddress;


int     FindFileServers();
BOOL    AttachToFileServer();
BOOL    ConnectToActiveServer();
BOOL    DetachFromActiveServer();
int     SendPacket( SOCKET, char *, int, SOCKADDR *, DWORD );
USHORT  ReadPropertyValue( char *, USHORT, char *, USHORT, UCHAR *,
                          UCHAR *, UCHAR * );
int
NcpTransaction(
    int iSize
    );

extern unsigned char chtob( unsigned char c1, unsigned char c2 );

unsigned char chtob( unsigned char c1, unsigned char c2 )
/* Convert two hex digits (stored as ascii) into one byte. */

{
   unsigned char out;

   if (c1 >= '0' && c1 <= '9')
      out = (c1 - '0') << 4;
   else
   {
      if (c1 >= 'a' && c1 <= 'f')
     out = (c1 - 'a' + 10) << 4;
      else if (c1 >= 'A' && c1 <= 'F')
     out = (c1 - 'A' + 10) << 4;
      else
     out = 0;
   }

   if (c2 >= '0' && c2 <= '9')
      out |= c2 -'0';
   else
   {
      if (c2 >= 'a' && c2 <= 'f')
     out |= c2 - 'a' + 10;
      else if (c2 >= 'A' && c2 <= 'F')
     out |= c2 - 'A' + 10;
      else
         out = 0;
   }

   return out;
}



DWORD
InitializeCriticalSectionWrapper(
    CRITICAL_SECTION * Mutex
    )
{
    DWORD Status = RPC_S_OK;

    __try
        {
        InitializeCriticalSection(Mutex);
        }
    __except ( EXCEPTION_EXECUTE_HANDLER )
        {
        Status = GetExceptionCode();
        }

    return Status;
}

DWORD
DeleteCriticalSectionWrapper(
    CRITICAL_SECTION * Mutex
    )
{
    DWORD Status = RPC_S_OK;

    __try
        {
        DeleteCriticalSection(Mutex);
        }
    __except ( EXCEPTION_EXECUTE_HANDLER )
        {
        Status = GetExceptionCode();
        }

    return Status;
}

DWORD
EnterCriticalSectionWrapper(
    CRITICAL_SECTION * Mutex
    )
{
    DWORD Status = RPC_S_OK;

    __try
        {
        EnterCriticalSection(Mutex);
        }
    __except ( EXCEPTION_EXECUTE_HANDLER )
        {
        Status = GetExceptionCode();
        }

    return Status;
}

DWORD
LeaveCriticalSectionWrapper(
    CRITICAL_SECTION * Mutex
    )
{
    DWORD Status = RPC_S_OK;

    __try
        {
        LeaveCriticalSection(Mutex);
        }
    __except ( EXCEPTION_EXECUTE_HANDLER )
        {
        Status = GetExceptionCode();
        }

    ASSERT(!Status);

    return Status;
}


BOOL
AttachToFileServer(
    )
//**************************************************************************
//
// This function creates an attachment between an NT workstation and
// a Novell Netware file server.
//
// Params:
//      USHORT *pConectionID - Receives the connection ID for the newly
//                             attached file server
//                             LOBYTE(ConnectionID) = conn_no_low
//                             HIBYTE(ConnectionID) = conn_no_high
//
// Return Values:
//
//      TRUE  - successful
//      FALSE - unsuccessful
//
//***************************************************************************
{
    unsigned i;

    SOCKET s;
    SOCKADDR_IPX nsAddr;
    unsigned Timeout;

    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_NCP );
    if ( s == INVALID_SOCKET )
        {
        return FALSE;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 3000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
    {
        closesocket(s);
        return FALSE;
    }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if (SOCKET_ERROR == bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
    {
        closesocket(s);
        return FALSE;
    }

    nsStatus.s = s;

    /* Find the nearest file server. */

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader.conn_no_low + (nsStatus.nhHeader.conn_no_high << 8);
                return TRUE;
                }
            }
        }

    FindFileServers();

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader.conn_no_low + (nsStatus.nhHeader.conn_no_high << 8);
                return TRUE;
                }
            }
        }

    closesocket(s);
    nsStatus.s = 0;

    return FALSE;
}


int
FindFileServers(
    )
/****************************************************************************/
/*                                                                          */
/* This function uses the SAP (Service Advertise Protocol) Find Nearest     */
/* query to find a netware file server.                                     */
/*                                                                          */
/* Returns:                                                                 */
/*      Number of servers found (0 - MAX_FILESRVS)                          */
/*                                                                          */
/****************************************************************************/
{
    SOCKET s;
    BOOL bBcst;
    SQP sqp;
    SIP sip;
    unsigned Timeout;

    SOCKADDR_IPX raddr;
    SOCKADDR_IPX nsAddr;


    //
    // Create a socket for the SAP broadcast.
    //
    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_IPX );
    if( s == INVALID_SOCKET )
        {
        return 0;
        }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if(SOCKET_ERROR ==  bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
        {
        closesocket(s);
        return 0;
        }

    //
    // Enable broadcasts.
    //
    bBcst = TRUE;
    if (SOCKET_ERROR ==  setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&bBcst, sizeof(BOOL)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 2000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Build a SAP query packet.
    //
    sqp.query_type = SAP_NEAREST_QUERY;
    sqp.server_type = FILE_SERVER;

    raddr.sa_family = AF_NS;
    *((unsigned long UNALIGNED *) &raddr.sa_netnum) = 0;
    memset( &raddr.sa_nodenum, 0xff, 6 );
    raddr.sa_socket = SAP_SOCKET;

    //
    // Send the SAP request.
    //
    if (SOCKET_ERROR == sendto( s, (char *) &sqp, sizeof(SQP), 0, (SOCKADDR *) &raddr, sizeof(SOCKADDR_IPX) ))
        {
        closesocket(s);
        return 0;
        }

    //
    // Collate responses.
    //
    nsStatus.ServerCount = 0;
    do
        {
        unsigned length;

irrelevant_packet:

        length = recvfrom(s, (char *) &sip, sizeof(sip), 0, 0, 0);
        if (SOCKET_ERROR == length)
            {
            break;
            }

        //
        // IPX router spec says find nearest responses can contain only one
        // entry.
        //
        if (length != sizeof(sip) - sizeof(sip.entries) + sizeof(SIP_ENTRY))
            {
            goto irrelevant_packet;
            }

        if (sip.response_type != SAP_NEAREST_RESPONSE)
            {
            goto irrelevant_packet;
            }

        if (sip.server_type != FILE_SERVER)
            {
            goto irrelevant_packet;
            }

        nsStatus.nsRemote[nsStatus.ServerCount].sa_family = AF_NS;
        nsStatus.nsRemote[nsStatus.ServerCount].sa_socket = NCP_SOCKET;
        memcpy( &nsStatus.nsRemote[nsStatus.ServerCount].sa_netnum,
                &sip.entries[0].network,
                sizeof(sip.entries[0].network)+sizeof(sip.entries[0].node)
                );
        }
    while ( ++nsStatus.ServerCount < MAX_FILESRVS );

    closesocket(s);
    return nsStatus.ServerCount;
}


BOOL
ConnectToActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function creates a NCP connection between the local workstation     */
/* and the specified file server. It sends the following NCP packets to     */
/* the file server:                                                         */
/*      1. Create Connection                                                */
/*      2. Negotiate Buffer Size                                            */
/*                                                                          */
/* Params:                                                                  */
/*      SOCKADDR_IPX *ipxDest     - server's IPX address                    */
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE    - SUCCEEDED                                                 */
/*      FALSE   - FAILED                                                    */
/*                                                                          */
/****************************************************************************/
{
    NCPHDR *pnhReq;
    NCPRSP *pnrResp;
    BOOL fSuccess;

    //
    // Build a CREATE_CONNECTION request.
    //
    memset( &nsStatus.nhHeader, '\0', sizeof(NCPHDR));

    pnhReq = &nsStatus.nhHeader;
    pnhReq->req_type = CREATE_CONN_REQTYPE;
    pnhReq->seq_no = 0;                     /* reset sequence number */
    pnhReq->conn_no_low = 0xFF;             /* no connection yet     */
    pnhReq->conn_no_high = 0xFF;            /* no connection yet     */
    pnhReq->task_no = 0;
    pnhReq->req_code = 0;

    //
    // Send the packet and wait for response.
    //
    fSuccess = FALSE;
    if (SOCKET_ERROR != NcpTransaction(sizeof(NCPHDR)) )
        {
        /* Save our connection number, it is used in all the subsequent */
        /* NCP packets.                                                                                                 */
        pnrResp = (NCPRSP *)nsStatus.RcvBuffer;
        if ( pnrResp->ret_code == 0 )
            {
            nsStatus.nhHeader.conn_no_low = pnrResp->conn_no_low;
            nsStatus.nhHeader.conn_no_high = pnrResp->conn_no_high;

            fSuccess = TRUE;
            }
        }

    return fSuccess;
}


BOOL
DetachFromActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function logs out the bindery object and detaches the workstation   */
/* from the specified file server.                                          */
/*                                                                          */
/* Params:                                                                  */
/*      none
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE       - Always                                                    */
/*                                                                          */
/****************************************************************************/
{

    if (0 == nsStatus.s)
        {
        return TRUE;
        }

    nsStatus.nhHeader.req_type = DESTROY_CONN_REQYPE;
    nsStatus.nhHeader.seq_no++;
    nsStatus.nhHeader.req_code = 0;

    NcpTransaction(sizeof(NCPHDR));

    closesocket( nsStatus.s );
    nsStatus.s = 0;

    return TRUE;
}


USHORT
ReadPropertyValue(
    char *ObjectName,
    USHORT ObjectType,
    char *PropertyName,
    USHORT SegmentNumber,
    UCHAR *PropertyValue,
    UCHAR *MoreSegments,
    UCHAR *PropertyFlags
    )
{
/*++

Routine Description:



Arguments:



Return Value:



--*/

    RVALREQ *pReq;
    RVALRSP *pRsp;
    int iRet;

    if ( !nsStatus.s )
        {
        return BINDERY_FAILURE;
        }

    /* Build a SCAN_BINDERY request */
    pReq = (RVALREQ *) &nsStatus.nhHeader;
    pReq->hdr.seq_no++;
    pReq->hdr.req_code = NCP_SCAN_BINDERY;
    pReq->hdr.req_type = GENERAL_REQTYPE;
    pReq->func_code = READ_PROP_VALUE_FUNC;
    pReq->length = SWAP(RVALSIZE);

    pReq->obj_type = SWAP(ObjectType);
    memset( pReq->obj_name, '\0', sizeof(pReq->obj_name));
    strcpy( (char *)pReq->obj_name+1, ObjectName );
    pReq->obj_name[0] = (UCHAR)(sizeof(pReq->obj_name)-1);
    pReq->seg_no = (UCHAR)SegmentNumber;
    memset( pReq->prop_name, '\0', sizeof(pReq->prop_name));
    strcpy( (char *)pReq->prop_name+1, PropertyName );
    pReq->prop_name[0] = (UCHAR)strlen(PropertyName);

    /* Send the request and wait for response */
    iRet = NcpTransaction(sizeof(RVALREQ));

    /* If OK set output parameter values from the response packet */
    if ( iRet != SOCKET_ERROR )
        {
        pRsp = (RVALRSP *) nsStatus.RcvBuffer;
        if ( pRsp->hdr.ret_code == 0 )
            {
            *MoreSegments = pRsp->more_flag;
            *PropertyFlags = pRsp->prop_flags;
            memcpy( PropertyValue, pRsp->prop_value, sizeof(pRsp->prop_value));
            }

        return((USHORT)pRsp->hdr.ret_code);
        }

    return(BINDERY_FAILURE);
}


int
NcpTransaction(
    int iSize
    )
{
/*++

Routine Description:

    Send an NCP request to the active file server and wait for a response.
    Most necessary data has been stored in the nsStatus structure by
    the caller.

Arguments:

    iSize - size of buffer to send.

Return Value:

    SOCKET_ERROR if the fn failed,
    anything else if successful

--*/

    NCPRSP * pRsp;
    SOCKADDR_IPX SockAddr;
    int SockAddrLength;
    int Bytes;
    int Attempts = 0;

    /* Send the packet and retry three times if the response doesn't */
    /* arrive within the specified timeout                           */

    SockAddrLength = sizeof(SOCKADDR_IPX);
    pRsp = (NCPRSP *) nsStatus.RcvBuffer;

    do
        {
        if (SOCKET_ERROR == sendto( nsStatus.s,
                                    (char *) &nsStatus.nhHeader,
                                    iSize,
                                    0,
                                    (SOCKADDR *) &nsStatus.nsRemote[nsStatus.ActiveServer],
                                    sizeof(SOCKADDR_IPX)
                                    ))
            {
            return SOCKET_ERROR;
            }

irrelevant_packet:

        Bytes = recvfrom( nsStatus.s,
                         nsStatus.RcvBuffer,
                         sizeof(nsStatus.RcvBuffer),
                         0,
                         (SOCKADDR *) &SockAddr,
                         &SockAddrLength
                         );

        //
        // If we get a packet, compare the source address and sequence #.
        // We also compare the connection number except on the initial
        // connection request.
        //
        if (Bytes != SOCKET_ERROR)
            {
            if (0 != memcmp(SockAddr.sa_nodenum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_nodenum,
                            6))
                {
                goto irrelevant_packet;
                }

            if (0 != memcmp(SockAddr.sa_netnum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_netnum,
                            4))
                {
                goto irrelevant_packet;
                }

            if (nsStatus.nhHeader.req_type != CREATE_CONN_REQTYPE)
                {
                if (pRsp->conn_no_low != nsStatus.nhHeader.conn_no_low ||
                    pRsp->conn_no_high != nsStatus.nhHeader.conn_no_high)
                    {
                    goto irrelevant_packet;
                    }
                }

            if (pRsp->seq_no != nsStatus.nhHeader.seq_no )
                {
                goto irrelevant_packet;
                }
            }
        }
    while ( Bytes == SOCKET_ERROR && WSAGetLastError() == WSAETIMEDOUT && ++Attempts < 3 );

    return Bytes;
}


GUID SERVICE_TYPE = { 0x000b0640, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } };

RPC_STATUS
spx_get_host_by_name(
            SOCKADDR_IPX * netaddr,
  IN OUT    int *      pcNetAddr, 
            char*      host,
            int        protocol,
            unsigned   Timeout,
            unsigned * CacheTime
    )
// This routine takes a host name or address as a string and returns it
// as a SOCKADDR_IPX structure.  It accepts a NULL string for the local
// host address.  This routine works for SPX addresses.
{
    int             length;
    int             i;
    //
    // First see if the address is local.
    //
    if (host == 0 || *host == 0)
    {
        static BOOL s_fIpxAddrValid = FALSE;
        const int cMaxIpxAddresses = 10;
        static SOCKADDR_IPX s_IpxAddr[ cMaxIpxAddresses];
        static int s_cIpxAddr = 0;
        //
        // Use the cached local address, if valid.
        //
        if (s_fIpxAddrValid == TRUE)
        {
            int cMaxResult = ( s_cIpxAddr < *pcNetAddr)? s_cIpxAddr :  *pcNetAddr;
            for ( int i = 0; i < cMaxResult; i++)
            {
                memcpy(netaddr[i].sa_netnum, s_IpxAddr[i].sa_netnum, sizeof(s_IpxAddr[i].sa_netnum));
                memcpy(netaddr[i].sa_nodenum, s_IpxAddr[i].sa_nodenum, sizeof(s_IpxAddr[i].sa_nodenum));
            }
            *pcNetAddr = cMaxResult;

            return(RPC_S_OK);
        }

        //
        // Figure out the loopback address, not a easy task on IPX.
        //

        SOCKET sock;

        sock = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
        if (sock == INVALID_SOCKET)
        {
            //
            switch(GetLastError())
            {
                case WSAEAFNOSUPPORT:
                case WSAEPROTONOSUPPORT:
                    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
                    break;

                case WSAENOBUFS:
                case WSAEMFILE:
                    return(RPC_S_OUT_OF_MEMORY);
                    break;

                default:    
                    ASSERT(0);
                    return(RPC_S_OUT_OF_MEMORY);
                    break;
                }
            }

        // zero-out the netnum and nodenum members
        memset(netaddr->sa_netnum, 0, sizeof(netaddr->sa_netnum));
        memset(netaddr->sa_nodenum, 0, sizeof(netaddr->sa_nodenum));
        netaddr->sa_family = AF_IPX;

        if ( bind(sock, (PSOCKADDR)netaddr, sizeof(SOCKADDR_IPX)) == SOCKET_ERROR)
        {
            closesocket(sock);
            return(RPC_S_OUT_OF_RESOURCES);
        }

        //
        // Get the number of adapters => cAdapters.
        //
        int cAdapters = 0;
        int cbOpt = sizeof(cAdapters);

        if(getsockopt(sock, NSPROTO_IPX,
            IPX_MAX_ADAPTER_NUM, (char*) &cAdapters, &cbOpt) == SOCKET_ERROR)
        {
            return RPC_S_OUT_OF_RESOURCES;
        }

        //
        // Add each IPX address to the list of IPX addresses
        //
        int iAdapter = 0 ;
        int iNextToFill = 0;
        int cMaxResult = ( cAdapters < *pcNetAddr)? cAdapters: *pcNetAddr;
        for(  ; iAdapter < cMaxResult ; iAdapter++ )
        {
            IPX_ADDRESS_DATA  addressAdapter;

            memset(&addressAdapter, 0, sizeof(addressAdapter));

            // Specify which adapter to check.
            addressAdapter.adapternum = iAdapter ;
            int cbOpt = sizeof(addressAdapter);

            // Get information for the current adapter.
            if (getsockopt(sock, NSPROTO_IPX, IPX_ADDRESS,
                     (char*) &addressAdapter, &cbOpt ))
            {
               ASSERT(0) ;
            }
            else
            {
                // 
                // Verify that it is not a duplicate address.
                // The code in the QM assumes that each address will be returned once
                //
                BOOL fDuplicate = FALSE;
                for ( int j = 0; j < iNextToFill; j++)
                {
                    if ( memcmp( &(netaddr[j].sa_netnum),
                          addressAdapter.netnum,
                          IPX_ADDRESS_LEN) == 0)
                    {
                        //
                        //  a duplicate address, ignore
                        //
                        fDuplicate = TRUE;
                        break;
                    }
                }
                if (fDuplicate)
                {
                    continue;
                }

                //
                // Keep 
                //
                  memcpy( &(netaddr[iNextToFill].sa_netnum),
                          addressAdapter.netnum,
                          IPX_ADDRESS_LEN);
                  iNextToFill++;
            }
        }
        *pcNetAddr = iNextToFill;
        // Update cache

        cMaxResult = ( iNextToFill < cMaxIpxAddresses)? iNextToFill :  cMaxIpxAddresses;
        for ( int i = 0; i < cMaxResult; i++)
        {
            memcpy(s_IpxAddr[i].sa_netnum, netaddr[i].sa_netnum, sizeof(s_IpxAddr[i].sa_netnum));
            memcpy(s_IpxAddr[i].sa_nodenum, netaddr[i].sa_nodenum, sizeof(s_IpxAddr[i].sa_nodenum));
        }
        s_cIpxAddr = cMaxResult;
        s_fIpxAddrValid = TRUE;

        closesocket(sock);

        return(RPC_S_OK);

    }


    // Verify the length of the host name.
    length = strlen(host);

    // If no address was specified, look up the local address.
    if (length == 0)
    {
        return ( RPC_S_SERVER_UNAVAILABLE );
    }
    // If the name starts with ~, convert it directly to a network address.
    else if (host[0] == '~')
        {
        if (length != 21)
            return RPC_S_SERVER_UNAVAILABLE;

        for (i = 0; i < 4; i++)
            netaddr->sa_netnum[i] = chtob( host[2*i + 1], host[2*i + 2] );
        for (i = 0; i < 6; i++)
            netaddr->sa_nodenum[i] = chtob( host[2*i + 9], host[2*i + 10] );

        *CacheTime = GetTickCount();
        }

    // Quit if the name is too long.
    else if (length > MAX_COMPUTERNAME_LENGTH)
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    else
        {
        //
        // Look up the server in the name cache.
        //
        if (TRUE == FindServerInCache(host, netaddr, CacheTime))
            {
            *pcNetAddr = 1;
            return RPC_S_OK;
            }

        //
        // Gotta go look for it.
        //
        *CacheTime = GetTickCount();
        *pcNetAddr = 1; 
        return IpxNameToAddress(host, netaddr, Timeout);
        }

    return RPC_S_OK;
}


CRITICAL_SECTION_WRAPPER FileServerMutex;

#ifndef MQWIN95

BOOL fCsnwCheckCompleted  = FALSE;
BOOL fCsnwInstalled       = FALSE;

DWORD
GetCsnwStatus(
    LPSERVICE_STATUS pServiceStatus
    )
{
    SC_HANDLE ServiceController;
    SC_HANDLE Csnw;

    ServiceController = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (NULL == ServiceController)
        {
        return GetLastError();
        }

    Csnw = OpenService (ServiceController, L"NWCWorkstation", SERVICE_QUERY_STATUS);
    if (NULL == Csnw)
        {
        CloseServiceHandle(ServiceController);
        return GetLastError();
        }

    if (FALSE == QueryServiceStatus (Csnw, pServiceStatus))
        {
        CloseServiceHandle(ServiceController);
        CloseServiceHandle(Csnw);

        return GetLastError();
        }

    CloseServiceHandle(ServiceController);
    CloseServiceHandle(Csnw);

    return 0;
}


void
CheckForCsnw(
    )
/*++

Routine Description:

   Asks the service controller whether Client Services for Netware is installed.

Arguments:

    none

Return Value:

    no explicit return value

    updates fKnowCsnwInstallState and fCsnwInstalled

--*/

{
    DWORD Status;
    SERVICE_STATUS ServiceStatus;

    Status = GetCsnwStatus(&ServiceStatus);

    if (Status && Status != ERROR_SERVICE_DOES_NOT_EXIST)
        {
        return;
        }

    if (!Status)
        {
        if (ServiceStatus.dwCurrentState == SERVICE_RUNNING          ||
            ServiceStatus.dwCurrentState == SERVICE_START_PENDING    ||
            ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING )
            {
            fCsnwInstalled = TRUE;
            }
        }

    fCsnwCheckCompleted  = TRUE;
}


RPC_STATUS
LookupViaRnr(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    CSADDR_BUFFER csaddr[2];
    int           num;
    int           protocol_list[2];
    DWORD         csaddr_size = sizeof(csaddr);
    WCHAR         wcMachineName[MAX_COMPUTERNAME_LENGTH];

    wsprintf(wcMachineName,L"%S", Name);
    protocol_list[0] = NSPROTO_IPX ;
    protocol_list[1] = 0;
    num = GetAddressByName( NS_SAP, &SERVICE_TYPE, wcMachineName, protocol_list,
                            0, FALSE, &csaddr, &csaddr_size,
                            NULL, 0 );
    if (num <= 0)
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    memcpy( Address, csaddr[0].info.RemoteAddr.lpSockaddr, sizeof(SOCKADDR_IPX) );
    AddServerToCache(Name, Address);

    return RPC_S_OK;
}

#endif


RPC_STATUS
LookupViaBindery(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    USHORT      NwStatus;
    UCHAR       MoreSegments;
    UCHAR       PropertyFlags;
    UCHAR       buffer[128];

    RPC_STATUS  Status;

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Find a Netware server and connect to it.
    //
    if (FALSE == AttachToFileServer())
        {
        LeaveCriticalSectionWrapper(&FileServerMutex);

        return RPC_S_SERVER_UNAVAILABLE;
        }

    //
    // Read from the bindery.
    //
    NwStatus = ReadPropertyValue( Name,
                                  RPC_SAP_TYPE,
                                  "NET_ADDRESS",
                                  1,
                                  buffer,
                                  &MoreSegments,
                                  &PropertyFlags
                                  );

    //
    // Disconnect from the file server.
    //
    DetachFromActiveServer();

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (!NwStatus)
        {
        Address->sa_family = AF_IPX;
        memcpy(&Address->sa_netnum, buffer, 12);
        AddServerToCache(Name, Address);
        return RPC_S_OK;
        }

    return RPC_S_SERVER_UNAVAILABLE;
}


RPC_STATUS
IpxNameToAddress(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    RPC_STATUS Status = RPC_S_OK;

#ifndef MQWIN95

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    if (!fCsnwCheckCompleted)
        {
        CheckForCsnw();
        }

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (fCsnwInstalled)
        {
        Status = LookupViaRnr(Name, Address, Timeout);
        }
    else
        {
        Status = LookupViaBindery(Name, Address, Timeout);
        if (Status != RPC_S_OK)
            {
            Status = LookupViaRnr(Name, Address, Timeout);
            }
        }
#else

    Status = LookupViaBindery(Name, Address, Timeout);

#endif

    return Status;
}


#define CACHE_LENGTH 8

struct
{
    char         Name[16];
    SOCKADDR_IPX Address;
    unsigned     Time;
}
ServerCache[CACHE_LENGTH];

CRITICAL_SECTION_WRAPPER CacheMutex;
LONG InitCount = 0;

CCriticalSection    g_csSPX;

RPC_STATUS
InitializeSpxCache(
    )
{
    static BOOL s_fCacheInitialized = FALSE;

    CS Lock(g_csSPX);
    if ( s_fCacheInitialized)
    {
        return RPC_S_OK;
    }
    RPC_STATUS Status;

    Status = InitializeCriticalSectionWrapper(&CacheMutex);

    if (!Status)
        {
        Status = InitializeCriticalSectionWrapper(&FileServerMutex);

        if (Status)
            {
            DeleteCriticalSectionWrapper(&CacheMutex);
            }
        else
            {
                s_fCacheInitialized = TRUE;
            }
        }

    return Status;
}


RPC_STATUS
AddServerToCache(
    char  * Name,
    SOCKADDR_IPX * Address
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Check second time; it may have been added while we waited for the mutex.
    //
    for (i=0; i < CACHE_LENGTH; ++i)
        {
        if (0 == _strnicmp(ServerCache[i].Name, Name, 16))
            {
            LeaveCriticalSectionWrapper(&CacheMutex);
            return RPC_S_OK;
            }
        }

    //
    // If it is not in the table, try to find an empty entry to fill.
    //
    if (i == CACHE_LENGTH)
        {
        for (i=0; i < CACHE_LENGTH; ++i)
            {
            if (ServerCache[i].Name[0] == '\0')
                {
                break;
                }
            }
        }

    //
    // If all entries are full, overwrite the oldest one.
    //
    if (i == CACHE_LENGTH)
        {
        unsigned long BestTime = ~0UL;
        unsigned BestIndex = 0;

        for (i=0; i < CACHE_LENGTH; ++i)
            {
            if (ServerCache[i].Time <= BestTime)
                {
                BestTime = ServerCache[i].Time;
                BestIndex = i;
                }
            }

        i = BestIndex;
        }

    //
    // Update the entry's information.
    //
    strcpy(ServerCache[i].Name, Name);
    memcpy(&ServerCache[i].Address, Address, sizeof(SOCKADDR_IPX));

    ServerCache[i].Time = GetTickCount();

    LeaveCriticalSectionWrapper(&CacheMutex);

    return RPC_S_OK;
}


BOOL
FindServerInCache(
    char  * Name,
    SOCKADDR_IPX * Address,
    unsigned * Time
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return FALSE;
        }

    for (i=0; i < CACHE_LENGTH; ++i)
        {
        if (0 == _stricmp(ServerCache[i].Name, Name))
            {
            memcpy(Address, &ServerCache[i].Address, sizeof(SOCKADDR_IPX));
            *Time = ServerCache[i].Time;

            LeaveCriticalSectionWrapper(&CacheMutex);

            return TRUE;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\apdump.cpp ===
//implemantation of class CAPDumpable
#include "apdump.h"
#include "dfactory.h"

//contructor that get hold of Idumpable* the class should release
CAPDumpable::CAPDumpable(Idumpable* dumpable):m_dumpable(dumpable)
{
}

//operator-> that return the managed object pointer
Idumpable* CAPDumpable::operator->()const
{
  return m_dumpable;
}

//return the embedded objec pointer
Idumpable* CAPDumpable::get()const
{
  return m_dumpable;
}

//delete the managed object 
CAPDumpable::~CAPDumpable()
{
	CdumpableFactory::Delete(m_dumpable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\callback.h ===
//this header file define the type that needed for few calss to do
// call back calls
#ifndef CALLBACK_H
#define CALLBACK_H
typedef void (*DUMPABLE_CALLBACK_ROUTINE)( char *,...);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\apdump.h ===
//class that manage the release of Idumpable object

#ifndef APDUMP_H
#define APDUMP_H

class Idumpable;

class CAPDumpable 
{
public:
    CAPDumpable(Idumpable*);
    ~CAPDumpable();
	Idumpable* operator->()const;
	Idumpable* get()const ;
private:
	Idumpable* m_dumpable;
	CAPDumpable& operator=(const& CAPDumpable);
    CAPDumpable(const& CAPDumpable); 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dbgobj.h ===
//header file for abstract class Idbgobj that make abstraction
// of the object content given to dll extendsion by ntsd or kd
#ifndef DBGOBJ_H
#define DBGOBJ_H

class IDbgobj
{
public:
    IDbgobj(unsigned long RealAddress):m_RealAddress(RealAddress){}
	virtual unsigned long Read(char* buffer,unsigned long len)const =0;
	virtual unsigned long GetRealAddress()const{return m_RealAddress;}
    virtual ~IDbgobj(){};
private:
    unsigned long m_RealAddress;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dccursor.h ===
//this is the header file for class ccursor that implements
// Idumpable for MSMQ CCursor object

#ifndef DUMPABLECCURSOR_H
#define DUMPABLECCURSOR_H

//project spesific header
#include "dumpable.h"

class CCursorDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CCursorDumpable::CCursorDumpable(const char* Name,char* QEntry,unsigned long Realaddress);
    ~CCursorDumpable();

private:
	  char* m_CCursor;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\common.cpp ===
//this file implements class CommonOutput

//project spesific headers
#include "accomp.h"
#include "common.h"


/*============================= F U N C T I O N =============================*
 *  Function CCommonOutPut::DisplayMemberPointer
 *
 *  PURPOSE    : display member (of base ) information
 *
 *  PARAMETERS : IN  - DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine - callback routine to use for printing
 *               IN  - const char* Title - the title of the member - uasally the member name  
 *               IN  - const char* Type - the type pf the member
 *               IN  - const void* Value - the address of the memeber
 *
 *  REMARK :- this function uses the given lpOutputRoutine to print member information.
 *            it print the information in one line without '\n'
 */  
void CCommonOutPut::DisplayMemberPointer(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,
							 const char* Title,
							 const char* Type,
							 const char* Value,
							 unsigned long size)
{
	if(size == 0)
    {
      lpOutputRoutine("%s %s %s",Title,Type,Value);
    }
	else
    {
      lpOutputRoutine("%s %s %s  size=0x%x",Title,Type,Value,size);
    }
	fflush(stdout);
}




/*============================= F U N C T I O N =============================*
 *  Function CCommonOutPut::DisplayMemberPointer
 *
 *  PURPOSE    : display member (of base ) information + '\n'
 *
 *  PARAMETERS : IN  - DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine - callback routine to use for printing
 *               IN  - const char* Title - the title of the member - uasally the member name  
 *               IN  - const char* Type - the type pf the member
 *               IN  - const void* Value - the address of the memeber
 *
 *  REMARK :- this function does exaclly what DisplayMemberPointer does but it append   '\n' at the end
 */  
void CCommonOutPut::DisplayMemberPointerLine(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,
							 const char* Title,
							 const char* Type,
							 const char* Value,
							 unsigned long size)
{
   DisplayMemberPointer(lpOutputRoutine,Title,Type,Value,size);
   lpOutputRoutine("\n");
}

/*============================= F U N C T I O N =============================*
 *  Function CCommonOutPut::DisplayClassTitle
 *
 *  PURPOSE    : display title about given class
 *
 *  PARAMETERS : IN  - DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine - callback routine to use for printing
 *               IN  - const char* const char* ClassName - name of the class  
 *               IN  - long ClassSize - the size of the class
 *
 */  
void CCommonOutPut::DisplayClassTitle(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,
								 const char* ClassName,
								 long ClassSize
								 )
{
  lpOutputRoutine("class %s size = 0x%x\n",ClassName,ClassSize);
  fflush(stdout);
}
/*============================= F U N C T I O N =============================*
 *  Function CCommonOutPut::DisplayArray
 *
 *  PURPOSE    : skip over array and Display its members
 *
 *  PARAMETERS : IN  - DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine - callback routine to use for printing
 *               IN  - const pS const arr[],
 *               IN  - the size of the array
 *
 */  
void CCommonOutPut::DisplayArray(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine, 
								 const pS const arr[],
								 long length)
{
	for (unsigned  i = 0; i < length; i++) 
	{
		CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
	                                    arr[ i ]->get_field(),
										arr[ i ]->get_type(),
										arr[ i ]->get_val().c_str(),
										arr[ i ]->get_size()
										 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\common.h ===
//header file for commonoutput cals that implements all kind of
// common printing function that all dumpable object can uses
#ifndef COMMONOUTPUT_H
#define COMMONOUTPUT_H

//project spesific headers
#include "callback.h"

//standart
#include <sstream>

//os opesific
#include <guiddef.h>

//
// example: 
// pS arr[]=
// {
//					  <type>  <mem name> ,  [size] , <value>
//
//		new SS<ULONG>("ULONG","OpenCount",sizeof(ULONG),Share->OpenCount),
//		new SS<ULONG>("ULONG","Readers",Share->Readers)
// }
// and print all the class-memebrs in a bunch
// for(..i..) 
// CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
//		                                    arr[ i ]->get_field(),
//											arr[ i ]->get_type(),
//											arr[ i ]->get_val().c_str(),
//											arr[ i ]->get_size());
//
//
class S { 
private:
	const char* m_field; 
	const char* m_type; 
	unsigned long m_size;
public:
	S(const char *f,const char *t, unsigned long s):m_field(f),m_type(t),m_size(s){};
	virtual ~S()
	{
	  m_field=0;
      m_type=0;
	};
	
	virtual const std::string &get_val() const = 0;

	const char* get_field() const { return m_field; }
	const char* get_type() const { return m_type; }
	const unsigned long get_size() const { return m_size; }
};
typedef S* pS;
template <class T> class SS : public S { 
public:
	std::string m_val; 
	SS(const char *f,const char *t,T v):S(f,t,0)
	{
		m_val = CCommonOutPut::ToStr(v);
	}
	SS(const char *f,const char *t,unsigned long s, T v):S(f,t,s)
	{
		m_val = CCommonOutPut::ToStr(v);
	}
	const std::string &get_val() const { return m_val; }
};



class CCommonOutPut
{	
public:
	static void DisplayMemberPointer(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,const char* Title,const char* Type,const char* Value,unsigned long size=0);
	static void DisplayMemberPointerLine(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,const char* Title,const char* Type,const char* Value,unsigned long size=0);
	static void DisplayClassTitle(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine,const char* ClassName, long ClassSize);
	static void DisplayArray(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine, const pS const *arr, long length);
	template <class T> static void Cleanup(T *arr, long length) 
	{
		for (long i = 0; i < length; i++) 
			delete arr[i];
	}

  	template <class T> static std::string ToStr(const T& val)
	{
      	std::ostringstream str;
		str<<std::hex<<"0x"<<val;
  	    return str.str();
    }
    template <> static std::string ToStr(const GUID& val)
	{
	  std::ostringstream str; 
	  str.fill('0');
	  str<<std::hex;
	  str.width(8);
	  str<<val.Data1<<"-";
	  str.width(4);
      str<<val.Data2<<"-";
	  str.width(4);
      str<<val.Data3<<"-";
      str.width(2);
	  str<<unsigned long(val.Data4[0]);
	  str.width(2);
      str<<unsigned long(val.Data4[1])<<"-";
	  for (int i=2;i<8;i++)
      {
        str.width(2);
        str<<unsigned long(val.Data4[i]);
      }
	  return str.str();
    } 
    template <> static std::string ToStr(const __int64 & val)
	{
      std::ostringstream str; 
	  str.fill('0');
	  str.width(8);
	  const int* buf=reinterpret_cast<const int*>(&val);
      str<<std::hex<<buf[1];
	  str.width(8);
	  str<<std::hex<<buf[0];
	  return str.str();
	} 

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dccursor.cpp ===
// implements  CQEntryDumpable class

//project spesific headers
#include "dccursor.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public
#include "cursor.h"

/*============================= F U N C T I O N =============================*
 *  Function CCursorDumpable::CCursorDumpable
 *
 *  PURPOSE    : constract CCursorDumpable class
 *
 *  PARAMETERS : IN - Name - the name of the class
 *               IN  - QueueBase* QBase - pointer QueueBase object  
 *               IN  - unsigned long Realaddress - object real address 
 */
CCursorDumpable::CCursorDumpable(const char* Name,char* Cursor,unsigned long Realaddress):
                 Idumpable(Realaddress,sizeof(CCursor)),
                 m_Name(Name),m_CCursor(Cursor)
{

}

//destructor
CCursorDumpable::~CCursorDumpable()
{
  delete[] m_CCursor;
}
/*============================= F U N C T I O N =============================*
 *  Function CQBaseDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq CQueueBase object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object contetnt using debugger supplied function
 *           given in lpExtensionApis parameter.  IRP
 */
void CCursorDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    CCursor* aCursor=reinterpret_cast<CCursor*>(m_CCursor);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

	
	//CObject - base
	//for displaying base class address we get help from the compiler derive-base casting.
	//for example if class A : Public B and we have A* a and we want to know the address
	// of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
	// is reposible for placing the correct value in b according to the position of B object in A object
	CObject*  Object=reinterpret_cast<CCursor*>(GetRealAddress());
	CCommonOutPut::DisplayMemberPointerLine(
		lpOutputRoutine,
		"base - ",
		"CObject",
		CCommonOutPut::ToStr(Object).c_str(),
		sizeof(CObject));	

   	const pS const arr[]=
	{
		new SS<ULONG>("CPrioList<CPacket>::Iterator","m_current",sizeof(CPrioList<CPacket>::Iterator),GetRealAddress()+offsetof(CCursor,m_current)),//CIRPList QBase->m_readers),
		new SS<const struct _FILE_OBJECT *>("const FILE_OBJECT*","m_owner",aCursor->m_owner),
		new SS<ULONG>("ULONG","m_hRemoteCursor",aCursor->m_hRemoteCursor),
		new SS<BOOL>("BOOL","m_fValidPosition",aCursor->m_fValidPosition),
		new SS<HANDLE>("HANDLE","m_handle",aCursor->m_handle),
	};
	
	CCommonOutPut::DisplayArray(lpOutputRoutine, arr, sizeof(arr) / sizeof(pS));

	CCommonOutPut::Cleanup(arr, sizeof(arr) / sizeof(pS));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dfactory.h ===
// this is the header file for dumpablefactory class.
// this class is responsible to create the correct dumpable object according
// to the parameters it gets.

#ifndef DUMPABLEFALCOTY_H
#define DUMPABLEFALCOTY_H

//project spesific
#include "callback.h"
class Idumpable;
class IDbgobj;

class CdumpableFactory
{
public:
	static Idumpable* Create(const char* ClassName,const IDbgobj* Dbgobj,unsigned long* err);
	static void ListSupportedClasses(DUMPABLE_CALLBACK_ROUTINE);
    static void  Delete(Idumpable* pDumpable);      
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dfactory.cpp ===
//implamantation of class dumpablefactory.cpp

//os headers
#include <winerror.h>

//project spesific
#include "dfactory.h"
#include "dumpable.h"
#include "dpacket.h"
#include "dqentry.h"
#include "dqueue.h"
#include "duqueue.h"
#include "dobject.h"
#include "dshare.h"
#include "dqbase.h"
#include "dbgobj.h"
#include "dccursor.h"
#include "dirp.h"
#include "accomp.h"
#include "dqprops.h"
#include "mqrtsize.h"
#include "dqpropid.h"
#include "dmpropid.h"
#include "dpropvar.h"

//msmq headers
#include <Packet.h>
#include <queue.h>
//#include <mqtypes.h>
//#include <wtypes.h>
//#include <mq.h>

//standart headers
#include <string.h>

extern DUMPABLE_CALLBACK_ROUTINE g_lpOutputRoutine;


/////// constants /////////////////////
const char* const CPACKET_CLASS_NAME = "CPacket";
const char* const CENTRY_CLASS_NAME="CQEntry";
const char* const COBJECT_CLASS_NAME="CObject";
const char* const CQUEUE_CLASS_NAME="CQueue";
const char* const CUSERQUEUE_CLASS_NAME="CUserQueue";
const char* const SHARE_ACCESS_CLASS_NAME="SHARE_ACCESS";
const char* const QUEUEBASE_CLASS_NAME="CQueueBase";
const char* const CCURSOR_CLASS_NAME="CCursor";
const char* const IRP_CLASS_NAME="IRP";
const char* const MQQUEUEPROPS_CLASS_NAME="MQQUEUEPROPS";
const char* const QUEUEPROPID_CLASS_NAME="QUEUEPROPID";
const char* const MSGPROPID_CLASS_NAME="MSGPROPID";
const char* const MQPROPVARIANT_CLASS_NAME="MQPROPVARIANT";
const char* const S_CLASS_ARR[]={CPACKET_CLASS_NAME,
                                 CENTRY_CLASS_NAME,
								 COBJECT_CLASS_NAME,
								 CQUEUE_CLASS_NAME,
								 CUSERQUEUE_CLASS_NAME,
								 SHARE_ACCESS_CLASS_NAME,
								 QUEUEBASE_CLASS_NAME,
								 CCURSOR_CLASS_NAME,
								 IRP_CLASS_NAME,
								 MQQUEUEPROPS_CLASS_NAME,
								 QUEUEPROPID_CLASS_NAME,
								 MSGPROPID_CLASS_NAME
								}; 


/*============================= F U N C T I O N =============================*
 *  Function CdumpableFactory::Create
 *
 *  PURPOSE    : creating dumpable object according to given class name and object pointer
 *
 *  PARAMETERS : IN  - const char* ClassName  - the name of the object class
 *               IN  - unsigned long ObjPtr - pointer to the object  
 *               OUT - unsigned long* err - WIN32 error code
 *
 *         
 *
 *  RETURNS    : pointer to Idumpable object or 0 if class is not supported
 *  REMARK :- the user should call CdumpableFactory::Delete to free memory allocated by this function
 */  

Idumpable* CdumpableFactory::Create(const char* ClassName,const IDbgobj* Dbgobj ,unsigned long* err )
{
  *err=ERROR_FILE_NOT_FOUND;
  


  //Cpacket
  if(stricmp(ClassName,CPACKET_CLASS_NAME)==0)
  {
	   char* CpBuffer=new char[sizeof(CPacket)];
       *err=Dbgobj->Read(CpBuffer,sizeof(CPacket));
	   if(*err == 0)
       {
          return new CpacketDumpable(ClassName,CpBuffer,Dbgobj->GetRealAddress());
       }
  }

  //CQentry
  if(stricmp(ClassName,CENTRY_CLASS_NAME)==0)
  {
	   char* CQEntryBuffer=new char[sizeof(CQEntry)];
       *err=Dbgobj->Read(CQEntryBuffer,sizeof(CQEntry));
	   if(*err == 0)
       {
	     return new CQEntryDumpable(ClassName,CQEntryBuffer,Dbgobj->GetRealAddress());
       }
  }

  //Cobject
  if(stricmp(ClassName,COBJECT_CLASS_NAME)==0)
  {
	   char* CObjectBuffer=new char[sizeof(CObject)];
       *err=Dbgobj->Read(CObjectBuffer,sizeof(CObject));
	   if(*err == 0)
       {
	     return new CObjectDumpable(ClassName,CObjectBuffer,Dbgobj->GetRealAddress());
       }
  }

  //Cqueue
  if(stricmp(ClassName,CQUEUE_CLASS_NAME)==0)
  {
	   char* CQueuetBuffer=new char[sizeof(CQueue)];
       *err=Dbgobj->Read(CQueuetBuffer,sizeof(CQueue));
	   if(*err == 0)
       {
	     return new CqueuetDumpable(ClassName,CQueuetBuffer,Dbgobj->GetRealAddress());
       }
  }

  //CUserqueue
  if(stricmp(ClassName,CUSERQUEUE_CLASS_NAME)==0)
  {
	  
    
	   char* CUserQueuetBuffer=new char[sizeof(CUserQueue)];
       *err=Dbgobj->Read(CUserQueuetBuffer,sizeof(CUserQueue));
	   if(*err == 0)
       {
	     return new CUserQueueDumpable(ClassName,CUserQueuetBuffer,Dbgobj->GetRealAddress());
       }
  }
	
  // SHARE_ACCESS
  if(stricmp(ClassName,SHARE_ACCESS_CLASS_NAME)==0)
  {
	   char* ShareAccesstBuffer=new char[sizeof(SHARE_ACCESS)];
       *err=Dbgobj->Read(ShareAccesstBuffer,sizeof(SHARE_ACCESS));
	   if(*err == 0)
       {
	     return new DShareDumpable(ClassName,ShareAccesstBuffer,Dbgobj->GetRealAddress());
       }
  }

  // CQueueBase
  if(stricmp(ClassName,QUEUEBASE_CLASS_NAME)==0)
  {
	   char* CQueueBasetBuffer=new char[sizeof(CQueueBase)];
       *err=Dbgobj->Read(CQueueBasetBuffer,sizeof(CQueueBase));
	   if(*err == 0)
       {
	     return new CQBaseDumpable(ClassName,CQueueBasetBuffer,Dbgobj->GetRealAddress());
       }
  }
  
  // CCursor
  if(stricmp(ClassName,CCURSOR_CLASS_NAME)==0)
  {
	   char* CCursortBuffer=new char[sizeof(CCursor)];
       *err=Dbgobj->Read(CCursortBuffer,sizeof(CCursor));
	   if(*err == 0)
       {
	     return new CCursorDumpable(ClassName,CCursortBuffer,Dbgobj->GetRealAddress());
       }
  }
  
  // IRP_CLASS_NAME
  if(stricmp(ClassName,IRP_CLASS_NAME)==0)
  {
	   char* IrptBuffer=new char[sizeof(IRP)];
       *err=Dbgobj->Read(IrptBuffer,sizeof(IRP));
	   if(*err == 0)
       {
	     return new IrpDumpable(ClassName,IrptBuffer,Dbgobj->GetRealAddress());
       }
  }


  //MQQUEUEPROPS_CLASS_NAME
  if(stricmp(ClassName,MQQUEUEPROPS_CLASS_NAME)==0)
  {
       char* MQQUEUEPROPSBuffer=new char[CMQRTsize::GetMQQUEUEPROPSsize()];
	  *err=Dbgobj->Read(MQQUEUEPROPSBuffer,CMQRTsize::GetMQQUEUEPROPSsize());
	   if(*err == 0)
       {
	     return new CMQQUEUEPROPSDumpable(ClassName,MQQUEUEPROPSBuffer,Dbgobj->GetRealAddress());
       }
  }


  //MSGPROPID_CLASS_NAME
   if(stricmp(ClassName,MSGPROPID_CLASS_NAME)==0)
   {
       char* MSGPROPIDBuffer=new char[CMQRTsize::GetMSGPROPIDsize()];
	  *err=Dbgobj->Read(MSGPROPIDBuffer,CMQRTsize::GetMSGPROPIDsize());
	   if(*err == 0)
       {
	     return new CMSGPROPIDDumpable(ClassName,
			                           MSGPROPIDBuffer,
									   Dbgobj->GetRealAddress());
       }
   }

   // PROPVARIANT _CLASS_NAME
   if(stricmp(ClassName, MQPROPVARIANT_CLASS_NAME)==0)
   {
       char*  PROPVARIANTBuffer=new char[ CMQRTsize::GetMQPROPVARIANTsize() ];
	   *err=Dbgobj->Read( PROPVARIANTBuffer, CMQRTsize::GetMQPROPVARIANTsize() );
	   if(*err == 0)
       {
	     return new CPROPVARIANTDumpable(ClassName, 
										 PROPVARIANTBuffer, 
										 Dbgobj->GetRealAddress());
       }
   }

  

  // 
  //
  //
  return 0;
		
}

/*============================= F U N C T I O N =============================*
 *  Function CdumpableFactory::ListSupportedClasses
 *
 *  PURPOSE    : list all classes supported by CdumpableFactory
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print results.
 *  REMARK : The function prints using lpOutputRoutine all the names of classes supported .
 */
void CdumpableFactory::ListSupportedClasses(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)
{
  for(unsigned long i=0;i<sizeof(S_CLASS_ARR) /  sizeof  (S_CLASS_ARR[0]);i++ )
  {
    lpOutputRoutine("%s\n",S_CLASS_ARR[i]);
  }
  fflush(stdout);
}


/*============================= F U N C T I O N =============================*
 *  Function CdumpableFactory::Delete
 *
 *  PURPOSE    : deleting Dumpable object created by CdumpableFactory::Create
 *
 *  PARAMETERS : IN  -  Idumpable* pDumpable  
 */
void  CdumpableFactory::Delete(Idumpable* pDumpable)
{
    delete pDumpable; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dirp.h ===
//this is the header file for class ccursor that implements
// Idumpable for MSMQ CCursor object

#ifndef DUMPABLEIRP_H
#define DUMPABLEIRP_H

//project spesific header
#include "dumpable.h"

class IrpDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	IrpDumpable::IrpDumpable(const char* Name,char* Irp,unsigned long Realaddress);
    ~IrpDumpable();

private:
	  char* m_Irp;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dmpropid.h ===
//header file for class CMSGPROPIDDumpable the implements Idumpable for
// dumping msmq MSGPROPID objects

#ifndef MPROPID_H
#define MPROPID_H

//project spesific header
#include "dumpable.h"


class CMSGPROPIDDumpable : public Idumpable
{
  public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CMSGPROPIDDumpable(const char* Name,char* msgpropid,unsigned long Realaddress);
    ~CMSGPROPIDDumpable();


private:
	  char* m_msgpropid;
	  const char* const m_Name;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dobject.h ===
// Idumpable for MSMQ Cobject class

#ifndef DUMPABLEOBJECT_H
#define DUMPABLEOBJECT_H

//project spesific header
#include "dumpable.h"


//forward declarations
class CObject;



class CObjectDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CObjectDumpable(const char* Name, char* obj,unsigned long Realaddress);
    ~CObjectDumpable();
private:
	  char* m_Object;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dobject.cpp ===
// implemets CObjectDumpable class

//project spesific
#include "accomp.h"
#include "dobject.h"
#include "common.h"

//msmq headers
#include <object.h>


/*============================= F U N C T I O N =============================*
 *  Function CpacketDumpable::CpacketDumpable
 *
 *  PURPOSE    : constract CpacketDumpable class
 *
 *  PARAMETERS :  IN  - const char* Name - class name
 *                IN  - char* obj  - pointer CObject object  
 *                IN  - unsigned long Realaddress - the numeric value of the original pointer
 */
CObjectDumpable::CObjectDumpable(const char* Name, char* obj,unsigned long Realaddress):
                                Idumpable(Realaddress,sizeof(CObject)),
								m_Name(Name),
								m_Object(obj)
{

}


/*============================= F U N C T I O N =============================*
 *  Function CObjectDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of Cobject object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CObjectDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    CObject* Object = reinterpret_cast<CObject*>(m_Object);

	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());
    
	//m_ref
	ULONG ref=Object->m_ref;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_ref","ULONG",CCommonOutPut::ToStr(ref).c_str());


	//m_link
	unsigned long	link=GetRealAddress()+offsetof(CObject,m_link);
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_link","LIST_ENTRY",CCommonOutPut::ToStr(link).c_str(),sizeof(LIST_ENTRY));

}

//destructor
CObjectDumpable::~CObjectDumpable()
{
	delete[] m_Object;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dirp.cpp ===
// implements  CQEntryDumpable class

//project spesific headers
#include "dirp.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public
#include <ntddk.h>

/*============================= F U N C T I O N =============================*
 *  Function IrpDumpable::IrpDumpable
 *
 *  PURPOSE    : constract IrpDumpable class
 *
 *  PARAMETERS : IN - Name - the name of the class
 *               IN  - QueueBase* QBase - pointer QueueBase object  
 *               IN  - unsigned long Realaddress - object real address 
 */
IrpDumpable::IrpDumpable(const char* Name,char* Irp,unsigned long Realaddress):
                        Idumpable(Realaddress,sizeof(IRP)),
						m_Name(Name),
						m_Irp(Irp)
{
}

//destructor
IrpDumpable::~IrpDumpable()
{
  delete[] m_Irp;
}
/*============================= F U N C T I O N =============================*
 *  Function CQBaseDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq CQueueBase object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object contetnt using debugger supplied function
 *           given in lpExtensionApis parameter.  IRP
 */
void IrpDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    IRP* anIrp=reinterpret_cast<IRP*>(m_Irp);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());
#pragma warning(disable:4800)  
try
{
   	const pS const arr[]=
	{
		new SS<PKEVENT>("KEVENT*","UserEvent",anIrp->UserEvent),
		new SS<PIO_STATUS_BLOCK>("IO_STATUS_BLOCK*","UserIosb",anIrp->UserIosb),
		new SS<ULONG>("CCHAR","AllocationFlags",anIrp->AllocationFlags),
		new SS<ULONG>("CCHAR","ApcEnvironment",anIrp->ApcEnvironment),
		new SS<ULONG>("KIRQL","CancelIrql",anIrp->CancelIrql),
		new SS<bool>("BOOLEAN","Cancel",anIrp->Cancel),
		new SS<ULONG>("CHAR","CurrentLocation",anIrp->CurrentLocation),
		new SS<ULONG>("CHAR","StackCount",anIrp->StackCount),
		new SS<bool>("BOOLEAN","PendingReturned",anIrp->PendingReturned),
		new SS<ULONG>("KPROCESSOR_MODE","RequestorMode",anIrp->RequestorMode),
		new SS<PMDL>("PMDL","MdlAddress",anIrp->MdlAddress),
		new SS<USHORT>("USHORT","Size",anIrp->Size),
		new SS<CSHORT>("CSHORT","Type",anIrp->Type),
		new SS<PVOID>("PVOID","UserBuffer",anIrp->UserBuffer),
		new SS<ULONG>("IO_STATUS_BLOCK","IoStatus",sizeof(IO_STATUS_BLOCK),GetRealAddress()+offsetof(IRP,IoStatus)),//CIRPList QBase->m_readers), 
		new SS<ULONG>("LIST_ENTRY","ThreadListEntry",sizeof(LIST_ENTRY),GetRealAddress()+offsetof(IRP,ThreadListEntry)),//CIRPList QBase->m_readers),
		new SS<_IRP*>("_IRP*","::AssociatedIrp.MasterIrp",anIrp->AssociatedIrp.MasterIrp),
		new SS<LONG>("LONG","::AssociatedIrp.IrpCount",anIrp->AssociatedIrp.IrpCount),
		new SS<PVOID>("PVOID","::AssociatedIrp.SystemBuffer",anIrp->AssociatedIrp.SystemBuffer),
		new SS<PIO_APC_ROUTINE>("IO_APC_ROUTINE*","::Tail::Overlay::AsynchronousParameters.UserApcRoutine",anIrp->Overlay.AsynchronousParameters.UserApcRoutine),
		new SS<PVOID>("PVOID","::Overlay::AsynchronousParameters.UserApcContext",anIrp->Overlay.AsynchronousParameters.UserApcContext),
		new SS<PDRIVER_CANCEL>("PDRIVER_CANCEL","CancelRoutine",anIrp->CancelRoutine),
		new SS<ULONG>("LARGE_INTEGER","::Overlay.AllocationSize",sizeof(LARGE_INTEGER),GetRealAddress()+offsetof(IRP,Overlay.AllocationSize)),
		new SS<PVOID>("PVOID","::Tail.CompletionKey",anIrp->Tail.CompletionKey),
		new SS<PVOID>("PVOID","::Tail.CompletionKey",anIrp->Tail.CompletionKey), 
		new SS<ULONG>("KAPC","::Tail.Apc",sizeof(KAPC),GetRealAddress()+offsetof(IRP,Tail.Apc)),
		new SS<PFILE_OBJECT>("PFILE_OBJECT","::Tail::Overlay.OriginalFileObject",anIrp->Tail.Overlay.OriginalFileObject),
		new SS<ULONG>("KDEVICE_QUEUE_ENTRY","::Tail::Overlay.DeviceQueueEntry",sizeof(KDEVICE_QUEUE_ENTRY ),GetRealAddress()+offsetof(IRP,Tail.Overlay.DeviceQueueEntry)),
		new SS<PVOID>("PVOID","::Tail::Overlay.DriverContext[4]",anIrp->Tail.Overlay.DriverContext),
		new SS<PETHREAD>("PETHREAD","::Tail::Overlay.Thread",anIrp->Tail.Overlay.Thread),
		new SS<PVOID>("PCHAR","::Tail::Overlay.AuxiliaryBuffer",anIrp->Tail.Overlay.AuxiliaryBuffer), ////////////
		new SS<ULONG>("LIST_ENTRY","::Tail::Overlay.ListEntry",sizeof(LIST_ENTRY),GetRealAddress()+offsetof(IRP,Tail.Overlay.ListEntry)),
		new SS<ULONG>("struct _IO_STACK_LOCATION *","::Tail::Overlay.CurrentStackLocation",sizeof(LIST_ENTRY),GetRealAddress()+offsetof(IRP,Tail.Overlay.CurrentStackLocation)),
		new SS<ULONG>("ULONG","::Tail::Overlay.PacketType",anIrp->Tail.Overlay.PacketType),
		new SS<PFILE_OBJECT>("PFILE_OBJECT","::Tail::Overlay.OriginalFileObject",anIrp->Tail.Overlay.OriginalFileObject)
	};
#pragma warning(default:4800) 

	CCommonOutPut::DisplayArray(lpOutputRoutine, arr, sizeof(arr) / sizeof(pS));

	CCommonOutPut::Cleanup(arr, sizeof(arr) / sizeof(pS));
}
catch(std::bad_alloc&)
{
//	CCommonOutPut::Cleanup<pS>(arr, sizeof(arr) / sizeof(pS));
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dpacket.cpp ===
//this module that implements class CpacketDumpable packet class



//project spesific headers
#include "accomp.h"
#include "dpacket.h"
#include "common.h"

//msmq headers
#include <packet.h>


#include <sstream>



/*============================= F U N C T I O N =============================*
 *  Function CpacketDumpable::CpacketDumpable
 *
 *  PURPOSE    : constract CpacketDumpable class
 *
 *  PARAMETERS :  IN  - const char* Name - class name
 *                IN  - char* Packet Packet - pointer msmq packet    
 *                IN  - unsigned long Realaddress - the numeric value of the original pointer
 */
CpacketDumpable::CpacketDumpable(const char* Name, char* Packet,unsigned long Realaddress):
								Idumpable(Realaddress,sizeof(CPacket)),
								m_Name(Name),
								m_Packet(Packet)
{

}

/*============================= F U N C T I O N =============================*
 *  Function CpacketDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq packet object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CpacketDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());
	CQEntry* QEntry=reinterpret_cast<CPacket*>(GetRealAddress());

	//for displaying base class address we get help from the compiler derive-base casting.
   //for example if class A : Public B and we have A* a and we want to know the address
   // of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
   // is reposible for placing the correct value in b according to the position of B object in A object
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"base - ","CQEntry",CCommonOutPut::ToStr(QEntry).c_str(),sizeof(CQEntry));
}

//destructor
CpacketDumpable::~CpacketDumpable()
{
  delete[] m_Packet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dpacket.h ===
//this is the header file for class CpacketDumpable that implements
// Idumpable for MSMQ packet object

#ifndef DUMPABLEPACKET_H
#define DUMPABLEPACKET_H

//project spesific header
#include "dumpable.h"




class CpacketDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CpacketDumpable(const char* Name, char* Packet,unsigned long Realaddress);
	~CpacketDumpable();
private:
	  char* m_Packet;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dmpropid.cpp ===
//implementation of class CMSGPROPIDDumpable declared in dmpropid.h

//project spesific headers
#include "dmpropid.h"
#include "common.h"

//os spesific headers
#include <windows.h>
#include <mq.h>

#pragma warning(disable :4786)
#include <map>
using namespace std;

const  char* const PROPID_M_CLASS_STR="PROPID_M_CLASS"; 
const  char* const PROPID_M_MSGID_STR="PROPID_M_MSGID";
const  char* const PROPID_M_CORRELATIONID_STR="PROPID_M_CORRELATIONID";
const  char* const PROPID_M_PRIORITY_STR="PROPID_M_PRIORITY";
const  char* const PROPID_M_DELIVERY_STR="PROPID_M_DELIVERY"; 
const  char* const PROPID_M_ACKNOWLEDGE_STR="PROPID_M_ACKNOWLEDGE"; 
const  char* const PROPID_M_JOURNAL_STR="PROPID_M_JOURNAL"; 
const  char* const PROPID_M_APPSPECIFIC_STR="PROPID_M_APPSPECIFIC"; 
const  char* const PROPID_M_BODY_STR="PROPID_M_BODY"; 
const  char* const PROPID_M_BODY_SIZE_STR="PROPID_M_BODY_SIZE"; 
const  char* const PROPID_M_LABEL_STR="PROPID_M_LABEL"; 
const  char* const PROPID_M_LABEL_LEN_STR="PROPID_M_LABEL_LEN"; 
const  char* const PROPID_M_TIME_TO_REACH_QUEUE_STR="PROPID_M_TIME_TO_REACH_QUEUE"; 
const  char* const PROPID_M_TIME_TO_BE_RECEIVED_STR="PROPID_M_TIME_TO_BE_RECEIVED"; 
const  char* const PROPID_M_RESP_QUEUE_STR="PROPID_M_RESP_QUEUE"; 
const  char* const PROPID_M_RESP_QUEUE_LEN_STR="PROPID_M_RESP_QUEUE_LEN"; 
const  char* const PROPID_M_ADMIN_QUEUE_STR="PROPID_M_ADMIN_QUEUE"; 
const  char* const PROPID_M_ADMIN_QUEUE_LEN_STR="PROPID_M_ADMIN_QUEUE_LEN"; 
const  char* const PROPID_M_VERSION_STR="PROPID_M_VERSION"; 
const  char* const PROPID_M_SENDERID_STR="PROPID_M_SENDERID"; 
const  char* const PROPID_M_SENDERID_LEN_STR="PROPID_M_SENDERID_LEN"; 
const  char* const PROPID_M_SENDERID_TYPE_STR="PROPID_M_SENDERID_TYPE"; 
const  char* const PROPID_M_PRIV_LEVEL_STR="PROPID_M_PRIV_LEVEL"; 
const  char* const PROPID_M_AUTH_LEVEL_STR="PROPID_M_AUTH_LEVEL"; 
const  char* const PROPID_M_AUTHENTICATED_STR="PROPID_M_AUTHENTICATED"; 
const  char* const PROPID_M_HASH_ALG_STR="PROPID_M_HASH_ALG"; 
const  char* const PROPID_M_ENCRYPTION_ALG_STR="PROPID_M_ENCRYPTION_ALG"; 
const  char* const PROPID_M_SENDER_CERT_STR="PROPID_M_SENDER_CERT"; 
const  char* const PROPID_M_SENDER_CERT_LEN_STR="PROPID_M_SENDER_CERT_LEN"; 
const  char* const PROPID_M_SRC_MACHINE_ID_STR="PROPID_M_SRC_MACHINE_ID"; 
const  char* const PROPID_M_SENTTIME_STR="PROPID_M_SENTTIME"; 
const  char* const PROPID_M_ARRIVEDTIME_STR="PROPID_M_ARRIVEDTIME"; 
const  char* const PROPID_M_DEST_QUEUE_STR="PROPID_M_DEST_QUEUE"; 
const  char* const PROPID_M_DEST_QUEUE_LEN_STR="PROPID_M_DEST_QUEUE_LEN"; 
const  char* const PROPID_M_EXTENSION_STR="PROPID_M_EXTENSION"; 
const  char* const PROPID_M_EXTENSION_LEN_STR="PROPID_M_EXTENSION_LEN"; 
const  char* const PROPID_M_SECURITY_CONTEXT_STR="PROPID_M_SECURITY_CONTEXT"; 
const  char* const PROPID_M_CONNECTOR_TYPE_STR="PROPID_M_CONNECTOR_TYPE"; 
const  char* const PROPID_M_XACT_STATUS_QUEUE_STR="PROPID_M_XACT_STATUS_QUEUE"; 
const  char* const PROPID_M_XACT_STATUS_QUEUE_LEN_STR="PROPID_M_XACT_STATUS_QUEUE_LEN"; 
const  char* const PROPID_M_TRACE_STR="PROPID_M_TRACE"; 
const  char* const PROPID_M_BODY_TYPE_STR="PROPID_M_BODY_TYPE"; 
const  char* const PROPID_M_DEST_SYMM_KEY_STR="PROPID_M_DEST_SYMM_KEY";
const  char* const PROPID_M_DEST_SYMM_KEY_LEN_STR="PROPID_M_DEST_SYMM_KEY_LEN";
const  char* const PROPID_M_SIGNATURE_STR="PROPID_M_SIGNATURE";
const  char* const PROPID_M_SIGNATURE_LEN_STR="PROPID_M_SIGNATURE_LEN";
const  char* const PROPID_M_PROV_TYPE_STR="PROPID_M_PROV_TYPE";
const  char* const PROPID_M_PROV_NAME_STR="PROPID_M_PROV_NAME";
const  char* const PROPID_M_PROV_NAME_LEN_STR="PROPID_M_PROV_NAME_LEN";
const  char* const PROPID_M_FIRST_IN_XACT_STR="PROPID_M_FIRST_IN_XACT";
const  char* const PROPID_M_LAST_IN_XACT_STR="PROPID_M_LAST_IN_XACT";
const  char* const PROPID_M_XACTID_STR="PROPID_M_XACTID";
const  char* const PROPID_M_AUTHENTICATED_EX_STR="PROPID_M_AUTHENTICATED_EX";




/*============================= F U N C T I O N =============================*
 *  Function CMSGPROPIDDumpable::CMSGPROPIDDumpable
 *
 *  PURPOSE    : constract CMSGPROPIDDumpable class
 *
 *  PARAMETERS :  IN  - const char* Name - class name
 *                IN  - char* msgpropid - pointer msmq MSGPROPID object    
 *                IN  - unsigned long Realaddress - the numeric value of the original pointer
 */
CMSGPROPIDDumpable::CMSGPROPIDDumpable(const char* Name,char* msgpropid,unsigned long Realaddress):
								Idumpable(Realaddress,sizeof(MSGPROPID)),
								m_Name(Name),
								m_msgpropid(msgpropid)
{

}

/*============================= F U N C T I O N =============================*
 *  Function CMSGPROPIDDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq MSGPROPID object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the MSGPROPID object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CMSGPROPIDDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
  map<int,const char* > MsgPropsMap;	
	
  MsgPropsMap[PROPID_M_CLASS]=PROPID_M_CLASS_STR;
  MsgPropsMap[PROPID_M_MSGID]=PROPID_M_MSGID_STR;
  MsgPropsMap[PROPID_M_CORRELATIONID]=PROPID_M_CORRELATIONID_STR;
  MsgPropsMap[PROPID_M_PRIORITY]=PROPID_M_PRIORITY_STR;
  MsgPropsMap[PROPID_M_DELIVERY]=PROPID_M_DELIVERY_STR;
  MsgPropsMap[PROPID_M_ACKNOWLEDGE]=PROPID_M_ACKNOWLEDGE_STR;
  MsgPropsMap[PROPID_M_JOURNAL]=PROPID_M_JOURNAL_STR;
  MsgPropsMap[PROPID_M_APPSPECIFIC]=PROPID_M_APPSPECIFIC_STR;
  MsgPropsMap[PROPID_M_BODY]=PROPID_M_BODY_STR; 
  MsgPropsMap[PROPID_M_BODY_SIZE]=PROPID_M_BODY_SIZE_STR; 
  MsgPropsMap[PROPID_M_LABEL]=PROPID_M_LABEL_STR;    
  MsgPropsMap[PROPID_M_LABEL_LEN]=PROPID_M_LABEL_LEN_STR;   
  MsgPropsMap[PROPID_M_TIME_TO_REACH_QUEUE]=PROPID_M_TIME_TO_REACH_QUEUE_STR;   
  MsgPropsMap[PROPID_M_TIME_TO_BE_RECEIVED]=PROPID_M_TIME_TO_BE_RECEIVED_STR;   
  MsgPropsMap[PROPID_M_RESP_QUEUE]=PROPID_M_RESP_QUEUE_STR;   
  MsgPropsMap[PROPID_M_RESP_QUEUE_LEN]=PROPID_M_RESP_QUEUE_LEN_STR;   
  MsgPropsMap[PROPID_M_ADMIN_QUEUE]=PROPID_M_ADMIN_QUEUE_STR;   
  MsgPropsMap[PROPID_M_ADMIN_QUEUE_LEN]=PROPID_M_ADMIN_QUEUE_LEN_STR;   
  MsgPropsMap[PROPID_M_VERSION]=PROPID_M_VERSION_STR;   
  MsgPropsMap[PROPID_M_SENDERID]=PROPID_M_SENDERID_STR;   
  MsgPropsMap[PROPID_M_SENDERID_LEN]=PROPID_M_SENDERID_LEN_STR;   
  MsgPropsMap[PROPID_M_SENDERID_TYPE]=PROPID_M_SENDERID_TYPE_STR;   
  MsgPropsMap[PROPID_M_PRIV_LEVEL]=PROPID_M_PRIV_LEVEL_STR;   
  MsgPropsMap[PROPID_M_AUTH_LEVEL]=PROPID_M_AUTH_LEVEL_STR; 
  MsgPropsMap[PROPID_M_AUTHENTICATED]=PROPID_M_AUTHENTICATED_STR; 
  MsgPropsMap[PROPID_M_HASH_ALG]=PROPID_M_HASH_ALG_STR; 
  MsgPropsMap[PROPID_M_ENCRYPTION_ALG]=PROPID_M_ENCRYPTION_ALG_STR; 
  MsgPropsMap[PROPID_M_SENDER_CERT]=PROPID_M_SENDER_CERT_STR; 
  MsgPropsMap[PROPID_M_SENDER_CERT_LEN]=PROPID_M_SENDER_CERT_LEN_STR; 
  MsgPropsMap[PROPID_M_SRC_MACHINE_ID]=PROPID_M_SRC_MACHINE_ID_STR; 
  MsgPropsMap[PROPID_M_SENTTIME]=PROPID_M_SENTTIME_STR; 
  MsgPropsMap[PROPID_M_ARRIVEDTIME]=PROPID_M_ARRIVEDTIME_STR; 
  MsgPropsMap[PROPID_M_DEST_QUEUE]=PROPID_M_DEST_QUEUE_STR; 
  MsgPropsMap[PROPID_M_DEST_QUEUE_LEN]=PROPID_M_DEST_QUEUE_LEN_STR; 
  MsgPropsMap[PROPID_M_EXTENSION]=PROPID_M_EXTENSION_STR; 
  MsgPropsMap[PROPID_M_EXTENSION_LEN]=PROPID_M_EXTENSION_LEN_STR; 
  MsgPropsMap[PROPID_M_SECURITY_CONTEXT]=PROPID_M_SECURITY_CONTEXT_STR; 
  MsgPropsMap[PROPID_M_CONNECTOR_TYPE]=PROPID_M_CONNECTOR_TYPE_STR; 
  MsgPropsMap[PROPID_M_XACT_STATUS_QUEUE]=PROPID_M_XACT_STATUS_QUEUE_STR; 
  MsgPropsMap[PROPID_M_XACT_STATUS_QUEUE_LEN]=PROPID_M_XACT_STATUS_QUEUE_LEN_STR; 
  MsgPropsMap[PROPID_M_TRACE]=PROPID_M_TRACE_STR; 
  MsgPropsMap[PROPID_M_BODY_TYPE]=PROPID_M_BODY_TYPE_STR; 
  MsgPropsMap[PROPID_M_DEST_SYMM_KEY]=PROPID_M_DEST_SYMM_KEY_STR; 
  MsgPropsMap[PROPID_M_DEST_SYMM_KEY_LEN]=PROPID_M_DEST_SYMM_KEY_LEN_STR; 
  MsgPropsMap[PROPID_M_SIGNATURE]=PROPID_M_SIGNATURE_STR; 
  MsgPropsMap[PROPID_M_SIGNATURE_LEN]=PROPID_M_SIGNATURE_LEN_STR; 
  MsgPropsMap[PROPID_M_PROV_TYPE]=PROPID_M_PROV_TYPE_STR; 
  MsgPropsMap[PROPID_M_PROV_NAME]=PROPID_M_PROV_NAME_STR; 
  MsgPropsMap[PROPID_M_PROV_NAME_LEN]=PROPID_M_PROV_NAME_LEN_STR; 
  MsgPropsMap[PROPID_M_FIRST_IN_XACT]=PROPID_M_FIRST_IN_XACT_STR; 
  MsgPropsMap[PROPID_M_LAST_IN_XACT]=PROPID_M_LAST_IN_XACT_STR; 
  MsgPropsMap[PROPID_M_XACTID]=PROPID_M_XACTID_STR; 
  //MsgPropsMap[PROPID_M_AUTHENTICATED_EX]=PROPID_M_AUTHENTICATED_EX_STR; 

  MSGPROPID* msgpropid=reinterpret_cast<MSGPROPID*>(m_msgpropid);
	

  const char* msgpropstr=MsgPropsMap[*msgpropid];
  if(msgpropstr == 0)
  {
      msgpropstr="unknown";
  }

  CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                   "MSGPROPID",
										    CCommonOutPut::ToStr((*msgpropid)).c_str(),
											msgpropstr
											);
	                              
       											
}




//destructor
CMSGPROPIDDumpable::~CMSGPROPIDDumpable()
{
  delete[] m_msgpropid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqbase.h ===
//this is the header file for class CQBaseDumpable that implements
// Idumpable for MSMQ CQueueBase object

#ifndef DUMPABLEQBASE_H
#define DUMPABLEQBASE_H

//project spesific header
#include "dumpable.h"

class CQBaseDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CQBaseDumpable::CQBaseDumpable(const char* Name,char* QEntry,unsigned long Realaddress);
    ~CQBaseDumpable();

private:
	  char* m_QBase;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqentry.h ===
//this is the header file for class CQEntryDumpable that implements
// Idumpable for MSMQ CQEntry object

#ifndef DUMPABLEQENTRY_H
#define DUMPABLEQENTRY_H

//project spesific header
#include "dumpable.h"




class CQEntry;

class CQEntryDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CQEntryDumpable::CQEntryDumpable(const char* Name,char* QEntry,unsigned long Realaddress);
    ~CQEntryDumpable();

private:
	  char* m_QEntry;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqpropid.h ===
//this is the header file for class CQPROPIDDumpable that implements
// Idumpable for QUEUEPROPID object

#ifndef DQPROPID_H
#define DQPROPID_H

//project spesific header
#include "dumpable.h"

class CQPROPIDDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CQPROPIDDumpable(const char* Name,char* queueid,unsigned long Realaddress);
    ~CQPROPIDDumpable();

private:
	  char* m_queueid;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqbase.cpp ===
// implements  CQEntryDumpable class

//project spesific headers
#include "dqbase.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public
#include "qbase.h"

/*============================= F U N C T I O N =============================*
 *  Function CQBaseDumpable::CQBaseDumpable
 *
 *  PURPOSE    : constract CQBaseDumpable class
 *
 *  PARAMETERS : IN - Name - the name of the class
 *               IN  - QueueBase* QBase - pointer QueueBase object  
 *               IN  - unsigned long Realaddress - object real address 
 */
CQBaseDumpable::CQBaseDumpable(const char* Name,char* QBase,unsigned long Realaddress):
				Idumpable(Realaddress,sizeof(CQueueBase)),
				m_Name(Name),
				m_QBase(QBase)
{

}

//destructor
CQBaseDumpable::~CQBaseDumpable()
{
  delete[] m_QBase;
}
/*============================= F U N C T I O N =============================*
 *  Function CQBaseDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq CQueueBase object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object contetnt using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CQBaseDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    CQueueBase * QBase=reinterpret_cast<CQueueBase*>(m_QBase);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

	
	//CObject - base
	//for displaying base class address we get help from the compiler derive-base casting.
	//for example if class A : Public B and we have A* a and we want to know the address
	// of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
	// is reposible for placing the correct value in b according to the position of B object in A object
	CObject*  Object=reinterpret_cast<CQueueBase*>(GetRealAddress());
	CCommonOutPut::DisplayMemberPointerLine(
		lpOutputRoutine,
		"base - ",
		"CObject",
		CCommonOutPut::ToStr(Object).c_str(),
		sizeof(CObject));	

   	const pS const arr[]=
	{
		new SS<CGroup*>("CGroup*","m_owner",QBase->m_owner),
		new SS<ULONG>("CIRPList","m_readers",sizeof(CIRPList),GetRealAddress()+offsetof(CQueueBase,m_readers)),//CIRPList QBase->m_readers),
		new SS<ULONG>("ULONG","m_bfClosed",QBase->m_bfClosed),
		new SS<ULONG>("ULONG","m_bfTransactional",QBase->m_bfTransactional),
		new SS<ULONG>("ULONG","m_bfUnknownQueueType",QBase->m_bfUnknownQueueType),
	};
	
	CCommonOutPut::DisplayArray(lpOutputRoutine, arr, sizeof(arr) / sizeof(pS));

	CCommonOutPut::Cleanup(arr, sizeof(arr) / sizeof(pS));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqueue.cpp ===
//implements class CqueuetDumpable

//mproject spesific headers
#include "dqueue.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public
#include <queue.h>

//contructor
CqueuetDumpable::CqueuetDumpable(const char* Name, char* Queue,unsigned long Realaddress):
				 Idumpable(Realaddress,sizeof(CQueue)),
				 m_Name(Name),
				 m_Queue(Queue)
{

}

/*============================= F U N C T I O N =============================*
 *  Function CqueuetDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq CQueue object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the CQueue object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CqueuetDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    CQueue* Queue=reinterpret_cast<CQueue*>(m_Queue);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

    //UserQueue - base
	//for displaying base class address we get help from the compiler derive-base casting.
    //for example if class A : Public B and we have A* a and we want to know the address
    // of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
    // is reposible for placing the correct value in b according to the position of B object in A object
	CUserQueue* UserQueue=reinterpret_cast<CQueue*>(GetRealAddress());
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "base - ",
		                                    "CUserQueue",
											 CCommonOutPut::ToStr(UserQueue).c_str(),
											 sizeof(CUserQueue));

	//m_pJournalQueue - member
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_pJournalQueue",
		                                    "CQueue*",
											 CCommonOutPut::ToStr(Queue->m_pJournalQueue).c_str()
											 );

	//  m_packets - member
    CPrioList<CPacket>* Plist=reinterpret_cast<CPrioList<CPacket>* >(GetRealAddress()+offsetof(CQueue,m_packets)); 
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_packets",
		                                    "CPrioList<CPacket>",
											 CCommonOutPut::ToStr(Plist).c_str(),
											 sizeof(CPrioList<CPacket>));



	//m_bfTargetQueue - member
	   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfTargetQueue",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfTargetQueue).c_str());

      
      // m_bfDeleted  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfDeleted",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfDeleted).c_str());


		// m_bfStore  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfStore",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfStore).c_str());

		// m_bfArrivalTime  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfArrivalTime",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfArrivalTime).c_str());

		// m_bfJournal  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfJournal",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfJournal).c_str());

	   // m_bfSilent  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfSilent",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfSilent).c_str());

		 // m_bfSeqCorrected  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfSeqCorrected",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfSeqCorrected).c_str());

		
		 // m_bfXactForeign  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfXactForeign",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfXactForeign).c_str());

		
		 // m_bfAuthenticate  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_bfAuthenticate",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_bfAuthenticate).c_str());

		 // m_quota  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_quota",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_quota).c_str());

		// m_quota_used  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_quota_used",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_quota_used).c_str());

		// m_count  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_count",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_count).c_str());

		// m_base_priorit  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_base_priority",
		                                        "ULONG",
											     CCommonOutPut::ToStr(Queue->m_base_priority).c_str());

		// m_gQMID  - member
	    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_gQMID",
		                                         "GUID",
											     CCommonOutPut::ToStr(Queue->m_gQMID).c_str(),
												 sizeof(GUID));
        // m_gConnectorQM - member
		 CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                        "m_gConnectorQM",
		                                         "GUID",
											     CCommonOutPut::ToStr(Queue->m_gConnectorQM).c_str(),
												 sizeof(GUID));

		 //QueueCounters* m_pQueueCounters - member
		  QueueCounters* pQueueCounters=reinterpret_cast<QueueCounters*>(GetRealAddress()+offsetof(CQueue,m_pQueueCounters)); 
	      CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_pQueueCounters",
		                                    "QueueCounters*",
											 CCommonOutPut::ToStr(pQueueCounters).c_str(),
											 sizeof(QueueCounters));

		   // m_ulPrivLevel - member
		   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_ulPrivLevel",
		                                           "ULONG",
											        CCommonOutPut::ToStr(Queue->m_ulPrivLevel).c_str());

		   
		   // m_ulPrevN - member
		   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_ulPrevN",
		                                           "ULONG",
											        CCommonOutPut::ToStr(Queue->m_ulPrevN).c_str());

		    // m_ulSeqN - member
		   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_ulSeqN",
		                                           "ULONG",
											        CCommonOutPut::ToStr(Queue->m_ulSeqN).c_str());

		    // m_liSeqID - member
		   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_liSeqID",
		                                           "LONGULONG",
											        CCommonOutPut::ToStr(Queue->m_liSeqID).c_str());

           
		   //  m_ulAckSeqN - member
		     CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_ulAckSeqN",
		                                           "ULONG",
											        CCommonOutPut::ToStr(Queue->m_ulAckSeqN).c_str());

			 // LONGLONG m_liAckSeqID - memeber
			 CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                           "m_liAckSeqID",
		                                           "LONGULONG",
											        CCommonOutPut::ToStr(Queue->m_liAckSeqID).c_str());
             
			 
			 // m_pLastPacket - member
			 	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_pLastPacket",
		                                    "CPacket*",
											 CCommonOutPut::ToStr(Queue->m_pLastPacket).c_str()
											 );

       

}

//destructor
CqueuetDumpable::~CqueuetDumpable()
{
  delete[] m_Queue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqentry.cpp ===
// implements  CQEntryDumpable class




//project spesific headers
#include "dqentry.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public
#include "qentry.h"

/*============================= F U N C T I O N =============================*
 *  Function CQEntryDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq CQEntry object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the Cpacket object contetnt using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CQEntryDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    CQEntry*  QEntry = reinterpret_cast<CQEntry*>(m_QEntry);

   CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

   //CObject - base
   //for displaying base class address we get help from the compiler derive-base casting.
   //for example if class A : Public B and we have A* a and we want to know the address
   // of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
   // is reposible for placing the correct value in b according to the position of B object in A object
   CObject*  Object=reinterpret_cast<CQEntry*>(GetRealAddress());
   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"base - ","CObject",CCommonOutPut::ToStr(Object).c_str(),sizeof(CObject));

   //m_pAllocator - member
   CMMFAllocator* pAllocator=QEntry->m_pAllocator;
   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pAllocator*","CMMFAllocator",CCommonOutPut::ToStr(pAllocator).c_str());

   // m_pbh - member
   CAllocatorBlock* pbh=QEntry->m_pbh;
   CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pbh","CAllocatorBlock*",CCommonOutPut::ToStr(pbh).c_str());

	//m_pQueue - member
	CQueue* Queue=QEntry->m_pQueue;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pQueue","CQueue*",CCommonOutPut::ToStr(Queue).c_str());

	//m_pXact - member
	CTransaction* pXact=QEntry->m_pXact;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pXact","CTransaction*",CCommonOutPut::ToStr(pXact).c_str());

	//m_ulTimeout - member
	ULONG ulTimeout=QEntry->m_ulTimeout;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_ulTimeout","ULONG",CCommonOutPut::ToStr(ulTimeout).c_str());

    //m_pTargetQueue - member
	CQueue* pTargetQueue=QEntry->m_pTargetQueue;
    CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pTargetQueue","CQueue*",CCommonOutPut::ToStr(pTargetQueue).c_str());

	//m_pOtherPacket - member
	CPacket* pOtherPacket=QEntry->m_pOtherPacket;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_pOtherPacket","CPacket*",CCommonOutPut::ToStr(pOtherPacket).c_str());

	// m_bfFinalClass  -member
	ULONG bfFinalClass=QEntry->m_bfFinalClass;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfFinalClass","ULONG",CCommonOutPut::ToStr(bfFinalClass).c_str());

	//m_bfRundown - member
    ULONG bfRundown=QEntry->m_bfRundown;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfRundown","ULONG",CCommonOutPut::ToStr(bfRundown).c_str());


	//m_bfRevoked  - member  
	ULONG bfRevoked=QEntry->m_bfRevoked;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfRevoked","ULONG",CCommonOutPut::ToStr(bfRevoked).c_str());

	//m_bfReceived - member
    ULONG bfReceived  = QEntry->m_bfReceived;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfReceived","ULONG",CCommonOutPut::ToStr(bfReceived).c_str());

	// m_bfWriterPending - member
    ULONG bfWriterPending  = QEntry->m_bfWriterPending;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfWriterPending","ULONG",CCommonOutPut::ToStr(bfWriterPending).c_str());

    //m_bfTimeoutIssued - member
	ULONG bfTimeoutIssued=QEntry->m_bfTimeoutIssued;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfTimeoutIssued","ULONG",CCommonOutPut::ToStr(bfTimeoutIssued).c_str());

	// m_bfTimeoutTarget  -member
	ULONG bfTimeoutTarget=QEntry->m_bfTimeoutTarget;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfTimeoutTarget","ULONG",CCommonOutPut::ToStr(bfTimeoutTarget).c_str());

	//m_bfArrivalAckIssued - member 
	ULONG bfArrivalAckIssued= QEntry->m_bfArrivalAckIssued;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfArrivalAckIssued","ULONG",CCommonOutPut::ToStr(bfArrivalAckIssued).c_str());

	// m_bfStorageIssued -  member
    ULONG bfStorageIssued  =  QEntry->m_bfStorageIssued;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfStorageIssued","ULONG",CCommonOutPut::ToStr(bfStorageIssued).c_str());

	// m_bfStorageCompleted - member
	ULONG bfStorageCompleted=QEntry->m_bfStorageCompleted;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfStorageCompleted","ULONG",CCommonOutPut::ToStr(bfStorageCompleted).c_str());

	//m_bfDeleteStorageIssued - member
    ULONG bfDeleteStorageIssued=QEntry->m_bfDeleteStorageIssued;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfDeleteStorageIssued","ULONG",CCommonOutPut::ToStr(bfDeleteStorageIssued).c_str());

	// m_bfOtherPacket  - member
	ULONG bfOtherPacket=QEntry->m_bfOtherPacket;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfOtherPacket","ULONG",CCommonOutPut::ToStr(bfOtherPacket).c_str());

	//m_bfCachedFlagsSet - member
	ULONG bfCachedFlagsSet=QEntry->m_bfCachedFlagsSet;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfCachedFlagsSet","ULONG",CCommonOutPut::ToStr(bfCachedFlagsSet).c_str());

    //m_bfInSoruceMachine - member
	ULONG bfInSoruceMachine=QEntry->m_bfInSoruceMachine;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfInSoruceMachine","ULONG",CCommonOutPut::ToStr(bfInSoruceMachine).c_str());

	//m_bfOrdered    - member
    ULONG bfOrdered=QEntry->m_bfOrdered;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfOrdered","ULONG",CCommonOutPut::ToStr(bfOrdered).c_str());

	//m_bfSourceJournal - member
	ULONG bfSourceJournal=QEntry->m_bfSourceJournal;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfSourceJournal","ULONG",CCommonOutPut::ToStr(bfSourceJournal).c_str());

	//m_bfDone - member
    ULONG m_bfDone=QEntry->m_bfDone;
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,"m_bfDone","ULONG",CCommonOutPut::ToStr(m_bfDone).c_str());

	





}

/*============================= F U N C T I O N =============================*
 *  Function CQEntryDumpable::CQEntryDumpable
 *
 *  PURPOSE    : constract CQEntryDumpable class
 *
 *  PARAMETERS : IN - Name - the name of the class
 *               IN  - CQEntry* QEntry - pointer CQEntry object  
 *               IN  - unsigned long Realaddress - object real address 
 */
CQEntryDumpable::CQEntryDumpable(const char* Name,char* QEntry,unsigned long Realaddress):
			   Idumpable(Realaddress,sizeof(CQEntry)),
			   m_Name(Name),
			   m_QEntry(QEntry)
{

}

//destructor
CQEntryDumpable::~CQEntryDumpable()
{
  delete[] m_QEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqpropid.cpp ===
//implements CQPROPIDDumpable class

//project spesific headers
#include "dqpropid.h"
#include "common.h"



//os spesific headers
#include <windows.h>
#include <mq.h>

#pragma warning(disable :4786)
#include <map>
using namespace std;


//constants
   const char* const PROPID_Q_INSTANCE_STR="PROPID_Q_INSTANCE";
   const char* const PROPID_Q_TYPE_STR="PROPID_Q_TYPE";
   const char* const PROPID_Q_PATHNAME_STR="PROPID_Q_PATHNAME";
   const char* const PROPID_Q_JOURNAL_STR="PROPID_Q_JOURNAL";
   const char* const PROPID_Q_QUOTA_STR="PROPID_Q_QUOTA";
   const char* const PROPID_Q_BASEPRIORITY_STR="PROPID_Q_BASEPRIORITY";
   const char* const PROPID_Q_JOURNAL_QUOTA_STR="PROPID_Q_JOURNAL_QUOTA";
   const char* const PROPID_Q_LABEL_STR="PROPID_Q_LABEL";
   const char* const PROPID_Q_CREATE_TIME_STR="PROPID_Q_CREATE_TIME";
   const char* const PROPID_Q_MODIFY_TIME_STR="PROPID_Q_MODIFY_TIME";
   const char* const PROPID_Q_AUTHENTICATE_STR="PROPID_Q_AUTHENTICATE";
   const char* const PROPID_Q_PRIV_LEVEL_STR="PROPID_Q_PRIV_LEVEL";
   const char* const PROPID_Q_TRANSACTION_STR="PROPID_Q_TRANSACTION";
   const char* const PROPID_Q_PATHNAME_DNS_STR="PROPID_Q_PATHNAME_DNS";


/*============================= F U N C T I O N =============================*
 *  Function CQPROPIDDumpable::CQPROPIDDumpable
 *
 *  PURPOSE    : constract CQPROPIDDumpable class
 *
 *  PARAMETERS :  IN  - const char* Name - class name
 *                IN  - char* queueid - pointer msmq QUEUEPROPID object    
 *                IN  - unsigned long Realaddress - the numeric value of the original pointer
 */
CQPROPIDDumpable::CQPROPIDDumpable(const char* Name,char* queueid,unsigned long Realaddress):
								Idumpable(Realaddress,sizeof(QUEUEPROPID)),
								m_Name(Name),
								m_queueid(queueid)
{

}

/*============================= F U N C T I O N =============================*
 *  Function CQPROPIDDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq QUEUEPROPID object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the QPROPID object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CQPROPIDDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
	
   
	map<int,const char* > QueuePropsMap;
    QueuePropsMap[PROPID_Q_INSTANCE]=PROPID_Q_INSTANCE_STR;
	QueuePropsMap[PROPID_Q_TYPE]=PROPID_Q_TYPE_STR;
	QueuePropsMap[PROPID_Q_PATHNAME]=PROPID_Q_PATHNAME_STR;
	QueuePropsMap[PROPID_Q_JOURNAL]= PROPID_Q_JOURNAL_STR;
	QueuePropsMap[PROPID_Q_QUOTA]=PROPID_Q_QUOTA_STR;
	QueuePropsMap[PROPID_Q_BASEPRIORITY]=PROPID_Q_BASEPRIORITY_STR;
	QueuePropsMap[PROPID_Q_JOURNAL_QUOTA]=PROPID_Q_JOURNAL_QUOTA_STR;
	QueuePropsMap[PROPID_Q_LABEL]=PROPID_Q_LABEL_STR;
	QueuePropsMap[PROPID_Q_CREATE_TIME]=PROPID_Q_CREATE_TIME_STR;
	QueuePropsMap[PROPID_Q_MODIFY_TIME]=PROPID_Q_MODIFY_TIME_STR;
	QueuePropsMap[PROPID_Q_AUTHENTICATE]=PROPID_Q_AUTHENTICATE_STR;
	QueuePropsMap[PROPID_Q_PRIV_LEVEL]=PROPID_Q_PRIV_LEVEL_STR;
	QueuePropsMap[PROPID_Q_TRANSACTION]=PROPID_Q_TRANSACTION_STR;
	QueuePropsMap[PROPID_Q_PATHNAME_DNS]=PROPID_Q_PATHNAME_DNS_STR;

	QUEUEPROPID* qpropid=reinterpret_cast<QUEUEPROPID*>(m_queueid);
	

	const char* propstr=QueuePropsMap[*qpropid];
    if(propstr == 0)
    {
      propstr="unknown";
    }

	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                   "QUEUEPROPID",
										    CCommonOutPut::ToStr(*qpropid).c_str(),
											propstr
											);
	                              
		                                     
		                                     


	

											
}

//destructor
CQPROPIDDumpable::~CQPROPIDDumpable()
{
  delete[] m_queueid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqueue.h ===
//this is the header file for class CqueuetDumpable that implements
// Idumpable for CQueue  object

#ifndef DUMPABLEQUEUE_H
#define DUMPABLEQUEUE_H

//project spesific header
#include "dumpable.h"


//forward declarations
class CQueue;



class CqueuetDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CqueuetDumpable(const char* Name, char* Queue,unsigned long Realaddress);
	~CqueuetDumpable();
private:
	 char* m_Queue;
	 const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqprops.cpp ===
//implements class CMQQUEUEPROPSDumpable declared in dqprops.h

//project spesific headers
#include "dqprops.h"
#include "common.h"



//os spesific headers
#include <windows.h>
#include <mq.h>
  


/*============================= F U N C T I O N =============================*
 *  Function CMQQUEUEPROPSDumpable::CMQQUEUEPROPSDumpable
 *
 *  PURPOSE    : constract CMQQUEUEPROPSDumpable class
 *
 *  PARAMETERS :  IN  - const char* Name - class name
 *                IN  - char* MQQUEUEPROPSDumpable - pointer msmq MQQUEUEPROPS object    
 *                IN  - unsigned long Realaddress - the numeric value of the original pointer
 */
CMQQUEUEPROPSDumpable::CMQQUEUEPROPSDumpable(const char* Name,char* MQQUEUEPROPSDumpable,unsigned long Realaddress):
								Idumpable(Realaddress,sizeof(MQQUEUEPROPS)),
								m_Name(Name),
								m_MQQUEUEPROPSDumpable(MQQUEUEPROPSDumpable)
{

}

/*============================= F U N C T I O N =============================*
 *  Function CMQQUEUEPROPSDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of msmq MQQUEUEPROPS object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the MQQUEUEPROPS object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CMQQUEUEPROPSDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    MQQUEUEPROPS* qprops = reinterpret_cast<MQQUEUEPROPS*>(m_MQQUEUEPROPSDumpable);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

 
	//content
	const pS const arr[]=
	{
		new SS<DWORD>("ULONG","cProp",qprops->cProp),
		new SS<QUEUEPROPID*>("QUEUEPROPID*","aPropID",qprops->aPropID),
		new SS<MQPROPVARIANT*>("MQPROPVARIANT*","aPropVar",qprops->aPropVar),
	 	new SS<HRESULT*>("HRESULT*","aStatus",qprops->aStatus)
	};
	
	CCommonOutPut::DisplayArray(lpOutputRoutine, arr, sizeof(arr) / sizeof(pS));

	CCommonOutPut::Cleanup(arr, sizeof(arr) / sizeof(pS));
}

//destructor
CMQQUEUEPROPSDumpable::~CMQQUEUEPROPSDumpable()
{
  delete[] m_MQQUEUEPROPSDumpable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dqprops.h ===
//this is the header file for class CMQQUEUEPROPSDumpable that implements
// Idumpable for MSMQ QMQQUEUEPROPS object

#ifndef DQPROPS_H
#define DQPROPS_H

//project spesific header
#include "dumpable.h"

class CMQQUEUEPROPSDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CMQQUEUEPROPSDumpable(const char* Name,char* MQQUEUEPROPSDumpable,unsigned long Realaddress);
    ~CMQQUEUEPROPSDumpable();

private:
	  char* m_MQQUEUEPROPSDumpable;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dshare.h ===
// This is the header file for class SHARE_ACCESS that implements 
// Idumpable for DShare object

#ifndef DSHAREACCESS_H
#define DSHAREACCESS_H

//project spesific header
#include "dumpable.h"

//standart
#include <string>

class DShareDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	DShareDumpable(const char* Name, char* Queue,unsigned long Realaddress);
	~DShareDumpable();
private:
	 char* m_Share;
	 const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dshare.cpp ===
//implements class DShareDumpable

//mproject spesific headers
#include "dshare.h"
#include "common.h"
#include "accomp.h"

//contructor
DShareDumpable::DShareDumpable(const char* Name, char* Share,unsigned long Realaddress)
:Idumpable(Realaddress,sizeof(SHARE_ACCESS)),
m_Name(Name),
m_Share(Share)
{
}
//destructor
DShareDumpable::~DShareDumpable()
{
  delete[] m_Share;
}
/*============================= F U N C T I O N =============================*
 *  Function DShareDumpable::DumpContent
 *
 *  PURPOSE    : dump the content of SHARE_ACCESS object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the SHARE_ACCESS object content using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void DShareDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{
    SHARE_ACCESS* Share = reinterpret_cast<SHARE_ACCESS*>(m_Share);

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

	const pS const arr[]=
	{
		new SS<ULONG>("ULONG","OpenCount",Share->OpenCount),
		new SS<ULONG>("ULONG","Readers",Share->Readers),
		new SS<ULONG>("ULONG","Writers",Share->Writers),
	 	new SS<ULONG>("ULONG","Deleters",Share->Deleters),
		new SS<ULONG>("ULONG","SharedRead",Share->SharedRead),
		new SS<ULONG>("ULONG","SharedWrite",Share->SharedWrite),
		new SS<ULONG>("ULONG","SharedDelete",Share->SharedDelete)
	};
	
	CCommonOutPut::DisplayArray(lpOutputRoutine, arr, sizeof(arr) / sizeof(pS));

	CCommonOutPut::Cleanup(arr, sizeof(arr) / sizeof(pS));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\duqueue.cpp ===
// implementation of CUserQueueDumpable class

//project spesific headers
#include "duqueue.h"
#include "common.h"
#include "accomp.h"

//msmq headers
#define private public 
#include <quser.h>

/*============================= F U N C T I O N =============================*
 *  Function CUserQueueDumpable::CUserQueueDumpable
 *
 *  PURPOSE    : dump the content of msmq CUserQueue object
 *
 *  PARAMETERS : IN  - lpOutputRoutine - call back function to print the object content.
 *  REMARK : The function prints the CUserQueue object contetnt using debugger supplied function
 *           given in lpExtensionApis parameter.
 */
void CUserQueueDumpable::DumpContent(DUMPABLE_CALLBACK_ROUTINE lpOutputRoutine)const
{

	//title
	CCommonOutPut::DisplayClassTitle(lpOutputRoutine,m_Name,GetSize());

    //QueueBase - base
	//for displaying base class address we get help from the compiler derive-base casting.
    //for example if class A : Public B and we have A* a and we want to know the address
    // of B in a - we do : B* b=a. The value in b is not nessesary the valur in a. The compiler
    // is reposible for placing the correct value in b according to the position of B object in A object
	CQueueBase* QueueBase=reinterpret_cast<CUserQueue*>(GetRealAddress());
	CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "base - ",
		                                    "CQueueBase",
											 CCommonOutPut::ToStr(QueueBase).c_str(),
											 sizeof(QueueBase));

	//m_cursors - member
	 List<CCursor>* Plist=reinterpret_cast<List<CCursor>*>(GetRealAddress()+offsetof(CUserQueue,m_cursors)); 
	 CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_cursors",
		                                    "List<CCursor>",
											 CCommonOutPut::ToStr(Plist).c_str(),
											 sizeof(List<CCursor>));

	 //m_QueueID - member
	 QUEUE_FORMAT* pFormat=reinterpret_cast<QUEUE_FORMAT*>(GetRealAddress()+offsetof(CUserQueue,m_QueueID)); 
	 CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_QueueID",
		                                    "QUEUE_FORMAT",
											 CCommonOutPut::ToStr(pFormat).c_str(),
											 sizeof(QUEUE_FORMAT));

	 //m_ShareInfo - member
	 SHARE_ACCESS* pShareAccess=reinterpret_cast<SHARE_ACCESS*>(GetRealAddress()+offsetof(CUserQueue,m_ShareInfo));  
	 CCommonOutPut::DisplayMemberPointerLine(lpOutputRoutine,
		                                    "m_ShareInfo",
		                                    "SHARE_ACCESS",
											 CCommonOutPut::ToStr(pShareAccess).c_str(),
											 sizeof(SHARE_ACCESS));



}

//destructor
CUserQueueDumpable::~CUserQueueDumpable()
{
  delete[] m_CUserQueue;
}

/*============================= F U N C T I O N =============================*
 *  Function CUserQueueDumpable::CUserQueueDumpable
 *
 *  PURPOSE    : constract CQEntryDumpable class
 *
 *  PARAMETERS : IN - Name - the name of the class
 *               IN  - char* CUserQ - pointer to CUserQueue object  
 *               IN  - unsigned long Realaddress - object real address 
 */
CUserQueueDumpable::CUserQueueDumpable(const char* Name,char* CUserQ,unsigned long Realaddress):
					Idumpable(Realaddress,sizeof(CUserQueue)),
					m_Name(Name),
					m_CUserQueue(CUserQ)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\dumpable.h ===
//this is a abstract class that represents the dumpable  interface
// every class that that support dumping it contet to string should implements
// this interface

#ifndef DUMPABLE_H
#define DUMPABLE_H


#include "callback.h"

class Idumpable
{
public:
  Idumpable(unsigned long RealAddress,unsigned long Size):m_RealAddress(RealAddress),m_Size(Size){};
  virtual void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const=0;
  unsigned long GetRealAddress()const {return m_RealAddress;}
  unsigned long GetSize()const {return m_Size;}
  virtual ~Idumpable(){};
private:
	unsigned long m_RealAddress;
	unsigned long m_Size;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\htest.cpp ===
#include "apdump.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\duqueue.h ===
//this is the header file for class CUserQueueDumpable that implements
// Idumpable for MSMQ CUserQueue object

#ifndef DUQUEUE_H
#define DUQUEUE__H

//project spesific header
#include "dumpable.h"




class CUserQueue;

class CUserQueueDumpable : public Idumpable
{
public:
	void DumpContent(DUMPABLE_CALLBACK_ROUTINE)const;
	CUserQueueDumpable::CUserQueueDumpable(const char*,char*,unsigned long);
    ~CUserQueueDumpable();

private:
	  char* m_CUserQueue;
	  const char* const m_Name;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\kdobj.cpp ===
//implmentation of CKdobj


//os spesific headers
#include <windows.h>
#include <windbgkd.h>
#include <ntsdexts.h>
#include <wdbgexts.h>


//project spesific headers
#include "kdobj.h"

//standart headers
#include <assert.h>



/*============================= F U N C T I O N =============================*
 *  Function CKdobj::CKdobj
 *
 *  PURPOSE    : constract CKdobj object
 *
 *  PARAMETERS : IN - unsigned long objptr - object pointer value  
 *               IN - struct _WINDBG_OLDKD_EXTENSION_APIS* lpExtensionApis - pointer to kd suplied callback functions
 *                
 */
CKdobj::CKdobj(unsigned long objptr,struct _WINDBG_OLDKD_EXTENSION_APIS* lpExtensionApis):IDbgobj(objptr),m_lpExtensionApis(lpExtensionApis)
{
 assert(lpExtensionApis);
 assert(m_lpExtensionApis->lpReadVirtualMemRoutine);
}

/*============================= F U N C T I O N =============================*
 *  Function CKdobj::Read
 *
 *  PURPOSE    : read data from the kd object
 *
 *  PARAMETERS : OUT - char* buffer - will receive the data read
 *               IN  - unsigned long len - number of bytes to read into the buffer
 *  RETURN - win32 error code              
 */
unsigned long CKdobj::Read(char* buffer,unsigned long len)const
{
    DWORD read=0;
    BOOL b=m_lpExtensionApis->lpReadVirtualMemRoutine(GetRealAddress(),buffer,len,&read);
	if(b == FALSE || read != len)
    {
	  return GetLastError();	
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\mqntsdtest.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string>
#include "commonoutput.h"
void main()
{
  
  __int64 j=0x1111111122222222;
  std::string s=CCommonOutPut::ToStr(j);
  printf("%s\n",s.c_str());


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\kdobj.h ===
//header file for class CKdobj that implements the interface
// IDbgobj for kd objects. It enable the user to read memory
// from a given pointer osing the kd supplied function in seemless way.
#ifndef KDOBJ_H
#define KDOBJ_H

//project spesific headers
#include "dbgobj.h"

struct _WINDBG_OLDKD_EXTENSION_APIS;
class CKdobj : public IDbgobj
{
public:
	CKdobj(unsigned long objptr,struct _WINDBG_OLDKD_EXTENSION_APIS* lpExtensionApis);
	unsigned long Read(char* buffer,unsigned long len)const;
private:
	struct _WINDBG_OLDKD_EXTENSION_APIS* m_lpExtensionApis;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\mqrtsize.cpp ===
//implementation of class CMQRTsize declared in mqrtsize.h

//osspesific
#include <windows.h>
#include <mq.h>

//project spesific
#include "mqrtsize.h"


//return the size of MQQUEUEPROP
unsigned long CMQRTsize::GetMQQUEUEPROPSsize()
{
 return sizeof(MQQUEUEPROPS);
}

//return the size of QUEUEPROPID
unsigned long CMQRTsize::GetQUEUEPROPIDsize()
{
   return sizeof(QUEUEPROPID);
}

//return the size of MSGPROPID
unsigned long CMQRTsize::GetMSGPROPIDsize()
{
   return sizeof(MSGPROPID);
}
//return the size of MQPROPVARIANT
unsigned long CMQRTsize::GetMQPROPVARIANTsize()
{
   return sizeof(MQPROPVARIANT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\mqntsd.cpp ===
//this is a ntsd extension  dll for MSMQ internal classes. it prints the content of
// msmq class given in the command line.


//system headers
#include <windows.h>
#include <windbgkd.h>
#include <ntsdexts.h>
#include <wdbgexts.h>

//standart headers
#include <sstream>

//project spesific
#include "dfactory.h"
#include "dumpable.h"
#include "kdobj.h"
#include "ntsdobj.h"
#include "apdump.h"

using namespace std;
DUMPABLE_CALLBACK_ROUTINE g_lpOutputRoutine;


////////////////////// static functions //////////////////
static bool GetAruments(LPCSTR ArgumentString,string& ClassName,unsigned long& ObjPtr,unsigned long& count);
template <class T,class E>  static void common(E Readhandle,
					const char*  ClassName,
					unsigned long ObjPtr,
					unsigned long count);

/*============================= F U N C T I O N =============================*
 *  Function GetAruments 
 *
 *  PURPOSE    : extract argumnts from arguments string
 *
 *  PARAMETERS : IN  - LPCSTR ArgumentString - argument string passed by ntsd/windbg to this dll
 *               OUT - std::string& ClassName - class name from argument string returned here
 *               OUT - unsigned long& ObjPtr - the object pointer form arguments string returned here
 *               OUT - 	unsigned long& count - number of objects (valid if you have array of objects only)
 *         
 *
 *  RETURNS    : fail of success
 */  
static bool GetAruments(LPCSTR ArgumentString,
						string& ClassName,
						unsigned long& ObjPtr,
						unsigned long& count)
{
	count=0;
	istringstream InputSream(ArgumentString);
    InputSream>>ClassName; 
    if(!InputSream)
    {
      return false;
    }

    InputSream>>hex;
    InputSream>>ObjPtr;
	if(!InputSream)
    {
      return false;
    }
	InputSream>>count;
	if(count ==0)
    {
	  count=1;	
    }
    return true;
}




/*============================= F U N C T I O N =============================*
 *  Function mqobj  
 *
 *  PURPOSE    : Display content of msmq object (called from windbg/ntsd)
 *
 *  PARAMETERS : 
 *             IN - HANDLE hCurrentProcess- current process handle
 *             IN - HANDLE hCurrentThread - current thread handle
 *             IN - DWORD dwCurrentPc - current pc
 *             IN - struct _NTSD_EXTENSION_APIS* lpExtensionApis - ntsd extions api block
 *             IN - LPSTR lpArgumentString arguments strings 
 *
 *  RETURNS    : Nothing. 
 *
 *  REMARKS    :  this function is export by this dll and called by ntsd/windbg
 *                - currently not implemented
 */  
VOID mqobj (
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    struct _NTSD_EXTENSION_APIS* lpExtensionApis,
    LPSTR lpArgumentString
    )

{
  try
  {
	    g_lpOutputRoutine=lpExtensionApis->lpOutputRoutine;
		std::string ClassName;
		unsigned long count;
		unsigned long ObjPtr=0;
		if(!GetAruments(lpArgumentString,ClassName,ObjPtr,count))
		{
		  g_lpOutputRoutine("mqntsd -- usage: mqobj [class name] [object pointer] [number of objects( array only)] \n");
		  g_lpOutputRoutine("supported classes are :\n");
		  CdumpableFactory::ListSupportedClasses((DUMPABLE_CALLBACK_ROUTINE)lpExtensionApis->lpOutputRoutine);
		  return;
		}
        common<CNTSDobj,HANDLE>    (hCurrentProcess,
			                         ClassName.c_str(),
			                         ObjPtr,
                                     count);


  }
  catch(std::exception& e)
  {   
    g_lpOutputRoutine("mqntsd -- got run time error %s\n",e.what());
  }

}
/*============================= F U N C T I O N =============================*
 *  Function mqobjk  
 *
 *  PURPOSE    : Display content of msmq object (called from kd)
 *
 *  PARAMETERS : 
 *             
 *             IN - DWORD dwCurrentPc - current pc
 *             IN - struct _WINDBG_OLDKD_EXTENSION_APIS* lpExtensionApis - ntsd extions api block
 *             IN - LPSTR lpArgumentString arguments strings 
 *
 *  RETURNS    : Nothing. 
 *
 *  REMARKS    :  this function is export by this dll and called by kd.
 *                does exacly what mqobj does but called from kd instead of windbg/ntsd 
 */  
void mqobjk(ULONG                        dwCurrentPc,
            struct _WINDBG_OLDKD_EXTENSION_APIS* lpExtensionApis,
            PCSTR                        lpArgumentString)
{
  try
  {
	     g_lpOutputRoutine=(DUMPABLE_CALLBACK_ROUTINE)lpExtensionApis->lpOutputRoutine;
		std::string ClassName;
		unsigned long ObjPtr=0;
		unsigned long count;
		if(!GetAruments(lpArgumentString,ClassName,ObjPtr,count))
		{
		  g_lpOutputRoutine("mqntsd -- usage: mqobjk [class name] [object pointer] [number of objects( array only)]  \n");
		  g_lpOutputRoutine("supported classes are :\n");
		  CdumpableFactory::ListSupportedClasses((DUMPABLE_CALLBACK_ROUTINE)lpExtensionApis->lpOutputRoutine);
		  return;
		}

		common<CKdobj,struct _WINDBG_OLDKD_EXTENSION_APIS*>(lpExtensionApis,
			     ClassName.c_str(),
			     ObjPtr,
				 count);


					 
  }
  catch(std::exception& e)
  {   
    g_lpOutputRoutine("mqntsd -- got run time error %s\n",e.what());
  }  
}

/*============================= F U N C T I O N =============================*
 *  Function common  
 *
 *  PURPOSE    : do common action for Display content of msmq object (called from kd or ntsd)
 *
 *  PARAMETERS : 
 *             
 *             IN - E Readhandle - template parameter to kd or ntsd used to read memory of the displayed object
 *             IN - const char*  ClassName - the class name of the object
 *             IN - unsigned long ObjPtr - object address 
 *             IN - unsigned long count - the number of objects (in case of array starts at ObjPtr)
 *
 *  RETURNS    : Nothing. 
 */

template <class T,class E>  static void common(E Readhandle,
					const char*  ClassName,
					unsigned long ObjPtr,
				    unsigned long count)

{
  

    //create the first object
	T firstobj(ObjPtr,Readhandle);
	unsigned long err;
	
   	CAPDumpable dumpableFirst=CdumpableFactory::Create(ClassName,&firstobj,&err);
	
	if(err != ERROR_SUCCESS)
    {
       g_lpOutputRoutine("mqntsd -- run time error %d from CdumpableFactory::Create \n",err);
	   return;
    }

	//dump it content
	dumpableFirst->DumpContent((DUMPABLE_CALLBACK_ROUTINE)g_lpOutputRoutine);

   

	//dump other objects if it is array
    for(unsigned long i=1;i<count;i++)
    {
      g_lpOutputRoutine("%d-------------------------------------\n",i);
      T obj(ObjPtr+dumpableFirst->GetSize()*i,Readhandle);
	  CAPDumpable  dumpable=CdumpableFactory::Create(ClassName,&obj,&err);
	  if(err != 0)
	  {
		g_lpOutputRoutine("mqntsd -- creating object number %d got run time error %d from CdumpableFactory::Create \n",i,err);
	    return;
	  }
	  dumpable->DumpContent((DUMPABLE_CALLBACK_ROUTINE)g_lpOutputRoutine);
	}	 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\ntsdobj.h ===
//header file for class CNTSDobj that implements the interface
// IDbgobj for ntsd objects. It enable the user to read memory
// from a given pointer osing the ntsd supplied function in seemless way.
#ifndef NTSDOBJ_H
#define NTSDOBJ_H

//project spesific headers
#include "dbgobj.h"

typedef void* HANDLE;
class CNTSDobj : public IDbgobj
{
public:
	CNTSDobj(unsigned long objptr, HANDLE hCurrentProcess);
	unsigned long Read(char* buffer,unsigned long len)const;
private:
	HANDLE m_hCurrentProcess;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\createcs.h ===
//header file for CriticaltSecCreate that created & delete creatical section object
#ifndef CREATECS_H
#define CREATECS_H



//forward declarations
#include <winfwd.h>
#pragma warning(disable:4290)
class Win32exp;
class CriticaltSecCreateImp;
namespace std
{
  class bad_alloc;
}

class CriticaltSecCreate
{
public:
   CriticaltSecCreate()throw(Win32exp,std::bad_alloc);
  ~CriticaltSecCreate();
   PCRITICAL_SECTION get() const;
private:
   CriticaltSecCreateImp* m_imp;
   CriticaltSecCreate(const CriticaltSecCreate&); //not imppemented
   CriticaltSecCreate& operator=(const CriticaltSecCreate&); //not implemented
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\ntsdobj.cpp ===
//implmentation of cntsdobj


//os spesific headers
#include <windows.h>
#include <windbgkd.h>
#include <ntsdexts.h>
#include <wdbgexts.h>


//project spesific headers
#include "ntsdobj.h"

//standart headers
#include <assert.h>



/*============================= F U N C T I O N =============================*
 *  Function CNTSDobj::CNTSDobj
 *
 *  PURPOSE    : constract CNTSDobj object
 *
 *  PARAMETERS : IN - unsigned long objptr - object pointer value  
 *               IN - HANDLE hCurrentProcess - current process handle
 *                
 */
CNTSDobj::CNTSDobj(unsigned long objptr,HANDLE hCurrentProcess):IDbgobj(objptr),m_hCurrentProcess(hCurrentProcess)
{
 
}

/*============================= F U N C T I O N =============================*
 *  Function CNTSDobj::Read
 *
 *  PURPOSE    : read data from the ntsd object
 *
 *  PARAMETERS : OUT - char* buffer - will receive the data read
 *               IN  - unsigned long len - number of bytes to read into the buffer
 *  RETURN - win32 error code              
 */
unsigned long CNTSDobj::Read(char* buffer,unsigned long len)const
{
    DWORD read=0;
    BOOL b=ReadProcessMemory(m_hCurrentProcess,
		                     reinterpret_cast<const void*>(GetRealAddress()),
		                     buffer,
							 len,
							 &read);
	if(b == FALSE || read != len)
    {
	  return GetLastError();	
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\entercs.h ===
//header file for class CEntercs that hold critical section in constructor and free it in destructor

#ifndef ENTERCS_H
#define ENTERCS_H

//internal library headrs
#include <winfwd.h>

class CEntercs
{
public:
   explicit CEntercs(PCRITICAL_SECTION cs);
   ~CEntercs();

private:
  CEntercs(const CEntercs&);
  CEntercs& operator=(const CEntercs&);
  PCRITICAL_SECTION m_cs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqntsd.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\asptr.h ===
//header file for class AASPTR that implements
//smart pointer class for array heap allocated objectS pointer

#ifndef ASPTR_H
#define ASPTR_H
#pragma warning(disable: 4284) 

//utilities headers
#include <mtcounter.h>

template <class T,class C=CMTCounter> class ASPTR
{
public:

	//contructor
	explicit ASPTR<T,C>(T* p=0):m_p(p),m_counter(new C(1))
	{
	}

	//template copy contructor
    template <class T2> ASPTR(const ASPTR<T2,C>& p):
	                    m_p(p.get()),
						m_counter(p.getcounter())
	{
		++*m_counter;
	}


    //simple copy contructor
     ASPTR(const ASPTR<T,C>& p):
	                    m_p(p.m_p),
						m_counter(p.m_counter)
	{
		++*m_counter;
	}



    //template operator =
	template <class T2>  ASPTR& operator=(const ASPTR<T2,C>& p) //lint !e114
    {
      if (reinterpret_cast<const void*>(&p) != this)
      {
        reset(p);
      }
	  return *this;
    } 

	
	//simple operator=
	ASPTR& operator=(const ASPTR<T,C>& p)
    {
      if (&p != this)
      {
         reset(p);
      }
	  return *this;
    }

    //destructor
	~ASPTR()
	{
		release();
	}

    //template operator =
	template<class T2> bool operator==(const ASPTR<T2,C>p)
    {
      return  m_p == p.get();
    }

    //template operator<
    template<class T2> bool operator<(const ASPTR<T2,C>& p)
    {
      return m_p < p.get();
    }

    //template operator >
    template<class T2> bool operator>(const ASPTR<T2,C>& p)
    {
      return m_p > p.get();
    }

	//operator [] - for read/write
    T& operator[](int index)
    {
       return m_p[index];
    }
 
    //operator [] - for read only
    const T& operator[](int index)const
    {
       return m_p[index];
    }


	//get the managed pointer
    T* get() const 
	{
		return m_p;
	}

	//opreator-> return the managed pointer
	T* operator->()const 
	{
		return m_p;
	}

	//dereferencing the managed pointer
	T& operator*() const 
	{
		return *m_p;
	}

	// ! operator
    bool operator!()const
    {
		return (m_p==0);
    }

    //get the counter - it is public only because vc does not support
	// template friends
	C* getcounter()const 
	{
		return m_counter;
	};

private:
 //decreament ref count and  delete if needed
 void release()
 {
#ifdef DEBUG
   if(**m_counter<0)
   {
	   throw std::runtime_error("ASPTR catastrofic error");
   } 
#endif

   if(--*m_counter == 0)
   {
	 delete[] m_counter;
	 delete m_p;
   }
 }

 //reset to another smart pointer
 template <class T2> void reset(const ASPTR<T2,C>& p)
 {
     release();
     m_counter=p.getcounter();
	 m_p=p.get();
	 ++*m_counter;	 
 }
 T* m_p;
 C* m_counter;
};



#pragma warning(disable: 4284) 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\dbgext\mqntsd\mqrtsize.h ===
//header file for class the expose function to get the compile time
// object size of mqrt objects. This is in a seperate class  because
// including <mq.h> will not compile in modules that uses MSMQ internal headers

#ifndef MQRTSIZE_H
#define MQRTSIZE_H

class CMQRTsize
{
public:
	static unsigned long GetMQQUEUEPROPSsize();
	static unsigned long GetQUEUEPROPIDsize();
	static unsigned long GetMSGPROPIDsize();
	static unsigned long GetMQPROPVARIANTsize();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\genconst.h ===
//headr file for general contants

#ifndef GENCONST_H
#define GENCONST_H
const char* NULL_CHARP=0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\expbase.h ===
//header file that for class Cexpbase that is the base class for our exceptions
// classes. the class derived from std::exception. The class holds line number ,module and
//details and error code for derived classes. each derive class should implements
// the pure virtual function what() - that return full description of the exception

#ifndef EXPBASE_H
#define EXPBASE_H

#include <exception>

//consts
const char* const  COULD_NOT_GET_ERROR_DESC="could not get error description.";
class Cexpbase: public std::exception
{
public:
	const char*   getmodule()const throw();
	const char*   getdetail()const throw();
	unsigned long getline()const throw();  
	unsigned long geterr() const throw();
	Cexpbase(unsigned long err,unsigned long line,const char* module,const char* detail=0)throw();
	virtual const char* what()const throw()=0;
    virtual ~Cexpbase (){};
	enum{MAX_DETAIL_LEN=512,MAX_MODULE_LEN=256};

private:
const unsigned long m_err;
const unsigned long m_line;
char  m_module[MAX_MODULE_LEN];
char  m_detail[MAX_DETAIL_LEN];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\jbapitml.h ===
//headr file for few template function in order to make jet api function throw exception
// Cjbexp instead of returning error codes


#ifndef JBAPITML_H
#define JBAPITML_H

//ms internal headers
#include <jet.h>

//internal library headrs
#include <jbexp.h>





#define CallJetbApi( fn )			{ 						\
	                           JET_ERR err;           \
					if ( ( err = fn ) != JET_errSuccess )				\
						{					\
							\
						 	THROW_TEST_RUN_TIME_JB(err,"");	\
									\
						}					\
					}







#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\jbexp.h ===
//headr file for Cjbexp - exception class for jet blue api

#ifndef JBEXP_H
#define JBEXP_H

//tool lib headers
#include <expbase.h>


class Cjbexp:public Cexpbase
{
public:
	enum{ADDITIONAL_SPACE=128};
	Cjbexp(long err,unsigned long line,const char* module,const char* detail=0)throw();
	const char* what()const throw();
	private:
    mutable char m_what[Cexpbase::MAX_MODULE_LEN + Cexpbase::MAX_MODULE_LEN + ADDITIONAL_SPACE];
};

#define THROW_TEST_RUN_TIME_JB(errorcode,details) throw Cjbexp(errorcode,__LINE__,__FILE__,details)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\jinstance.h ===
//header file for class CJetInstance - class that init jet in contructor and terminate it indestrcutor

#ifndef JETINSTANCE_H
#define JETINSTANCE_H

#pragma warning( disable : 4290 ) 
class Cjbexp;
typedef unsigned long JET_INSTANCE;

class CJetInstance
{
public:
   CJetInstance()throw(Cjbexp);
   CJetInstance(JET_INSTANCE instance);
   ~CJetInstance();
   JET_INSTANCE get()const; 
private:
	JET_INSTANCE m_instance;
    CJetInstance& operator=(const CJetInstance&);
    CJetInstance(const CJetInstance&);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\jetblue.h ===
//header file for few structures spesific for for jetblue data base
#ifndef JETBLUE_H
#define JETBLUE_H

//ms internal headers
#include <jet.h>

//msmq property data in the eye of jet blue data base
struct JbmsmqProps
{
  const char* m_propname;
  long  m_type;
  long m_grbit;
  long m_maxsize;
  JET_COLUMNID   m_colid;
};

//access information to jet blue table
struct JetbTableAcessInfo
{
  JET_INSTANCE			m_instance;
  JET_SESID				m_sesid;
  JET_DBID				m_dbid;
  JET_TABLEID 			m_tableid;
};


static JbmsmqProps g_jbmsmqcolums[]={{"PROPID_M_CLASS",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_MSGID",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_CORRELATIONID",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_PRIORITY",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_DELIVERY",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_ACKNOWLEDGE",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_JOURNAL",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_APPSPECIFIC",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_BODY",JET_coltypLongBinary,0,500000000},
							{ "PROPID_M_LABEL",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_TIME_TO_REACH_QUEUE",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_TIME_TO_BE_RECEIVED",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_RESP_QUEUE",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_ADMIN_QUEUE",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_VERSION",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_SENDERID",JET_coltypLongBinary,0,0},
							{ "PROPID_M_PRIV_LEVEL",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_AUTH_LEVEL",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_AUTHENTICATED",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_HASH_ALG",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_ENCRYPTION_ALG",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_SENDER_CERT",JET_coltypLongBinary,0,0},
							{ "PROPID_M_SRC_MACHINE_ID",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_SENTTIME",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_ARRIVEDTIME",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_DEST_QUEUE",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_EXTENSION",JET_coltypLongBinary,0,0},
							{ "PROPID_M_SECURITY_CONTEXT",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_CONNECTOR_TYPE",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_XACT_STATUS_QUEUE",JET_coltypBinary,JET_bitColumnFixed,0},
							{ "PROPID_M_TRACE",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_BODY_TYPE",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_DEST_SYMM_KEY",JET_coltypLongBinary,0,0},
							{ "PROPID_M_SIGNATURE",JET_coltypLongBinary,0,0},
							{ "PROPID_M_PROV_TYPE",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_PROV_NAME",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_FIRST_IN_XACT",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_LAST_IN_XACT",JET_coltypLong,JET_bitColumnFixed,0},
							{ "PROPID_M_XACTID",JET_coltypBinary,JET_bitColumnFixed,0},
						};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\llibfree.h ===
//header file for class Cllibfree that load and free dll by loadlibrary/freelibrary system
//calls
#ifndef LLIBFREE_H
#define LLIBFREE_H



#pragma warning( disable : 4290 ) 

namespace std
{
  class bad_alloc;
}

class Cwin32exp;
class Cllibfreeimp;
class Cllibfree
{
public:
	explicit Cllibfree(const char* dllname)throw(Cwin32exp,std::bad_alloc);
  ~Cllibfree();
private:
  Cllibfree(const Cllibfree&); //not implemented
  operator=(const Cllibfree&); //not implemented
  Cllibfreeimp* m_imp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\nhandler.h ===
//header file for CNewHandle that set new_handler function  to function  that throw
// std::bad_alloc exception. In the current vc implementation new return 0 if fail.
// on destruction - the old new handler is set back
#ifndef NEW_HANDLER_H
#define NEW_HANDLER_H

typedef unsigned int     size_t;
typedef int (__cdecl * _PNH)( size_t );

class CNewHandleImp;
class CNewHandle
{
public:
  CNewHandle();
  ~CNewHandle();

private:
 CNewHandle(const CNewHandle&) ;//no implemented
 CNewHandle& operator=(const CNewHandle&); //not implemented
_PNH  m_oldhandler;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\mtcounter.h ===
//headr file for multihtreaded CMTCounter class. The class enable you
// to decreamnet, incerament and test long value in multithreaded safe way

#ifndef MTCOUNTER_H
#define MTCOUNTER_H

class CMTCounter
{
public:
  CMTCounter(long value = 0);
  CMTCounter(const CMTCounter&);
  CMTCounter& operator=(const CMTCounter&);
  long operator++(); 
  long operator++(int);
  long operator--();
  long operator--(int); 
  long operator*()const;
  private:
   long m_value;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\refcount.h ===
//header file for Irefcount interface. The interface is for managing reference count for objects
#ifndef REFCOUNT_H
#define REFCOUNT_H

class IRefcount
{
public:
  unsigned long virtual AddRef() throw() =0; //increament refcount and return value after increament
  unsigned long virtual Release() throw() =0; //decreament refcount (delet the object if needed) and return refcount after decreament
  virtual ~IRefcount()throw(){};
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\runnable.h ===
//headr file for for IRannable interface for thread supports. User that wants to uses
// CUserThread class should implements this interface

#ifndef RANNABLE_H
#define RANNABLE_H

class IRunnable
{
public:
	virtual ~IRunnable(){};
	virtual unsigned long ThreadMain()=0;
	virtual void StopRequest()=0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\params.h ===
//header file for class CInput that helps in command line processing

#ifndef PARAMS_H
#define PARAMS_H
#pragma warning(disable:4786)
#pragma warning( disable : 4290 ) 


//string forward declaration
#include <strfwd.h>

//bad_alloc declaration
namespace std
{
  class  bad_alloc;
}



class CInputImp;
class CInput     
{    
public:
	
    CInput(int argc, char *argv[])throw(std::bad_alloc);
	CInput(const CInput& in)throw(std::bad_alloc);
    CInput(const std::string& str)throw(std::bad_alloc);
	CInput& operator=( const CInput& in)throw(std::bad_alloc);
    ~CInput();
    bool IsExists(const std::string& token)const throw(std::bad_alloc);
	std::string operator[](const std::string& token)const throw(std::bad_alloc);
	long GetNumber(const std::string& token)const throw(std::bad_alloc);
private:
    CInputImp* m_imp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\mqexp.h ===
//header file for class CMQexp that wrapps is the exception class for MSMQ error

#ifndef MQEXP_H
#define MQEXP_H

//tool lib headers
#include <expbase.h>
#include <strfwd.h>
#include <winfwd.h>

namespace std
{
  class bad_alloc;
}

class CMQexp :public Cexpbase
{
public:
	virtual CMQexp::~CMQexp();
	CMQexp(DWORD err,unsigned long line,const char* module,const char* detail=0)throw();
	const char* what()const throw();
private:
	static std::string SystemErrorDescription (DWORD err)throw(std::bad_alloc);
	static DWORD SystemErrorDescriptionStaticBuff(DWORD err,char* buffer,int bufflen)throw();
	void FormatDescriptionBuffer(const char* description)const throw();
	enum{ADDITIONAL_SPACE=512,MSMQ_ERR_STRING_MAX_LEN=512};
	mutable char m_what[Cexpbase::MAX_MODULE_LEN + Cexpbase::MAX_MODULE_LEN + ADDITIONAL_SPACE];
};


#define THROW_TEST_RUN_TIME_MSMQ(errorcode,details) throw CMQexp(errorcode,__LINE__,__FILE__,details)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\sptr.h ===
//header file for class SPTR that implements
//smart pointer class for single(not array) heap allocated object pointer

#ifndef SPTR_H
#define SPTR_H
#pragma warning(disable: 4284) 

//utilities headers
#include <mtcounter.h>

template <class T,class C=CMTCounter> class SPTR
{
public:

	//contructor
	explicit SPTR<T,C>(T* p=0):m_p(p),m_counter(new C(1))
	{
	}

	//template copy contructor
    template <class T2> SPTR(const SPTR<T2,C>& p):
	                    m_p(p.get()),
						m_counter(p.getcounter())
	{
		++*m_counter;
	}


    //simple copy contructor
     SPTR(const SPTR<T,C>& p):
	                    m_p(p.m_p),
						m_counter(p.m_counter)
	{
		++*m_counter;
	}



    //template operator =
	template <class T2>  SPTR& operator=(const SPTR<T2,C>& p) //lint !e114
    {
      if (reinterpret_cast <const void*>(&p) != this)
      {
        reset(p);
      }
	  return *this;
    } 

	
	//simple operator=
	SPTR& operator=(const SPTR<T,C>& p)
    {
      if (&p != this)
      {
         reset(p);
      }
	  return *this;
    }

    //destructor
	~SPTR()
	{
		release();
	}

    //template operator =
	template<class T2> bool operator==(const SPTR<T2,C>p)
    {
      return  m_p == p.get();
    }

    //template operator<
    template<class T2> bool operator<(const SPTR<T2,C>& p)
    {
      return m_p < p.get();
    }

    //template operator >
    template<class T2> bool operator>(const SPTR<T2,C>& p)
    {
      return m_p > p.get();
    }

	//get the managed pointer
    T* get() const 
	{
		return m_p;
	}

	//opreator-> return the managed pointer
	T* operator->()const 
	{
		return m_p;
	}

	//dereferencing the managed pointer
	T& operator*() const 
	{
		return *m_p;
	}

	// ! operator
    bool operator!()const
    {
		return (m_p==0);
    }

    //get the counter - it is public only because vc does not support
	// template friends
	C* getcounter()const 
	{
		return m_counter;
	};

private:
 //decreament ref count and  delete if needed
 void release()
 {
#ifdef DEBUG
   if(**m_counter<0)
   {
	   throw std::runtime_error("SPTR catastrofic error");
   } 
#endif

   if(--*m_counter == 0)
   {
     delete m_counter;
	 delete m_p;
   }
 }

 //reset to another smart pointer
 template <class T2> void reset(const SPTR<T2,C>& p)
 {
     release();
     m_counter=p.getcounter();
	 m_p=p.get();
	 ++*m_counter;	 
 }
 T* m_p;
 C* m_counter;
};



#pragma warning(disable: 4284) 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\sqlexp.h ===
//header file for class CSQLexp that is the class for SQL exceptions
#ifndef SQLEXP_H
#define SQLEXP_H


//internal library  headers
#include <expbase.h>


class CSQLexp:public Cexpbase
{
public:
	enum{ADDITIONAL_SPACE=128};
	CSQLexp(long err,unsigned long line,const char* module,const char* detail=0)throw();
	const char* what()const throw();
	private:
    mutable char m_what[Cexpbase::MAX_MODULE_LEN + Cexpbase::MAX_MODULE_LEN + ADDITIONAL_SPACE];
};

#define THROW_TEST_RUN_TIME_SQL(errorcode,details) throw CSQLexp(errorcode,__LINE__,__FILE__,details)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\strcnv.h ===
//header file for class CStrcnv that convert stl strings or c strings to other types
#ifndef STRCNV_H
#define STRCNV_H

#pragma warning( disable : 4290 ) 


//stl strings forward declaration
#include <strfwd.h>


//bad_alloc forward declaration
namespace std
{
  class  bad_alloc;
}
class Cwin32exp;

class CStrcnv
{
public:
	static std::wstring StrToWstr(const std::string&)throw(std::bad_alloc,Cwin32exp);
    static std::string  WStrToStr(const std::wstring&)throw(std::bad_alloc,Cwin32exp);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\sysdir.h ===
//header file for class CSysdir for getting all kind of system directories
#ifndef SYSDIR_H
#define SYSDIR_H

//internal library headrs
#include <strfwd.h>
class Cwin32exp;
namespace std
{
  class bad_alloc;
}
#pragma warning(disable:4290)
class CSysdir
{
public:
	static std::string GetSystemDir() throw(std::bad_alloc,Cwin32exp);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\sqlcon.h ===
//header file for class CSQLcon that is an abstraction for ODBC conection to sql server

#ifndef SQLCON_H
#define SQLCON_H


//some forward declarations
typedef unsigned short  SQLUSMALLINT;
typedef unsigned long   SQLUINTEGER;
typedef SQLUINTEGER     SQLULEN;    
typedef void *          SQLPOINTER;
typedef short           SQLSMALLINT;
typedef SQLSMALLINT     SQLRETURN;
typedef long            SQLINTEGER;
typedef void*           SQLHSTMT;
typedef void*			SQLHDBC;
#define SQLLEN          SQLINTEGER
class CSQLconImp;
class CSQLexp;
namespace std
{
  class bad_alloc;
}
#pragma warning( disable : 4290 ) 

class CSQLcon
{
  public:
  CSQLcon(const char* odbcconstr)throw(CSQLexp,std::bad_alloc);
  void    T_SQLExecDirect(const char* szSqlStr)throw(CSQLexp);
  SQLRETURN  T_SQLFetch()throw(CSQLexp);
  void    T_SQLSetConnectOption(SQLUSMALLINT fOption,SQLUINTEGER vParam)throw(CSQLexp);
  void    T_SQLBindCol(SQLUSMALLINT      icol,
                     SQLSMALLINT       fCType,
                     SQLPOINTER        rgbValue,
                     SQLINTEGER        cbValueMax,
                     SQLINTEGER     *pcbValue)throw(CSQLexp);
  void    T_SQLGetData(SQLUSMALLINT       icol,
                       SQLSMALLINT        fCType,
                       SQLPOINTER         rgbValue,
                       SQLINTEGER         cbValueMax,
                       SQLINTEGER     *pcbValue)throw(CSQLexp);

  void T_SQLPutData(SQLPOINTER DataPtr,
					 SQLINTEGER StrLen_or_Ind)throw(CSQLexp);

  void T_SQLBindParameter(SQLUSMALLINT       ipar,
                          SQLSMALLINT        fParamType,
                          SQLSMALLINT        fCType,
                          SQLSMALLINT        fSqlType,
                          SQLULEN            cbColDef,
                          SQLSMALLINT        ibScale,
                          SQLPOINTER         rgbValue,
                          SQLLEN             cbValueMax,
                          SQLLEN     		   *pcbValue)throw(CSQLexp);


	    

  const char* GetSQLError();
  SQLHSTMT GetHstmt()const;
  SQLHDBC  GetHdb()const;
  const char* GetSQLError()const;
 
  ~CSQLcon();

  private:
  CSQLconImp* m_imp;
  CSQLcon(const CSQLcon&);
  CSQLcon& operator=(CSQLcon&);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\threadmn.h ===
//header file for IThreadmn interface. This interface expose thread management methods
#ifndef THREADMN_H
#define THREADMN_H

#include <winfwd.h>

class IRunnable;
class IThreadmn
{
public:
  virtual void Start()=0;
  virtual HANDLE GetHandle()const=0;
  virtual DWORD  GetId()const=0;
  virtual IRunnable* GetRunnable()const=0;
  virtual ~IThreadmn(){}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\strfwd.h ===
//forward declaration for  string stl file
#ifndef STRFDW_H
#define STRFDW_H

typedef unsigned short wchar_t; //lint !e55  !e13 
namespace std
{
  template<class _Ty> class allocator;
  template<class T> struct  char_traits;
  template<> struct  char_traits<char>;
  template<> struct  char_traits<wchar_t>;
  template<class _E,class _Tr = char_traits<_E>,class _A = allocator<_E> >class basic_string;
  typedef basic_string<char, char_traits<char>, allocator<char> >string;
  typedef basic_string<wchar_t, char_traits<wchar_t>,allocator<wchar_t> > wstring;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\thpriv.h ===
//headr file for IThreadPriv that is interface for internal thtread class thread class that uses  IRunnable interface
// this class is not for the use of the end user

#pragma warning( disable : 4290 ) 
class IRunnable;


//intenal library headers
#include <refcount.h>
#include <threadmn.h>


namespace std
{
  class bad_alloc;
}

class IThreadPriv:public IRefcount,public IThreadmn
{
public:
  static  IThreadPriv* new_instance(IRunnable* runnable)throw(std::bad_alloc);
  virtual ~IThreadPriv(){};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\createcs.cpp ===
//implementation of class CriticaltSecCreate declared in createcs.h


//internal library headrs
#include <createcs.h>
#include <win32exp.h>

//os spesific headers
#include <windows.h>


//internal implementation class
class CriticaltSecCreateImp
{
public:
	CRITICAL_SECTION m_critsec;
};

//constrcutor that initialize critical section
CriticaltSecCreate::CriticaltSecCreate()throw(Win32exp,std::bad_alloc):m_imp(0)
{
	m_imp = new CriticaltSecCreateImp;
    __try
    {
        InitializeCriticalSection(&m_imp->m_critsec); //lint !e613
	}
    __except (GetExceptionCode() == STATUS_NO_MEMORY)
    {
        delete m_imp;
        THROW_TEST_RUN_TIME_WIN32(E_OUTOFMEMORY,"");//lint !e570 !e55
    }
}

//cleanup
CriticaltSecCreate::~CriticaltSecCreate()
{
   DeleteCriticalSection(&m_imp->m_critsec);//lint !e613
   delete m_imp;
}

//return the managed critical section
PCRITICAL_SECTION CriticaltSecCreate::get() const
{
   return &m_imp->m_critsec;//lint !e613
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\winfwd.h ===
//header for forward declaration to windows type. if you need few type windows.h
// but you don't want to include windows.h (mybe beacuse mfc wont compile...) - this
//header is for you


#ifndef WINFWD_H
#define WINFWD_H

typedef unsigned long   DWORD;
typedef void* HANDLE;
struct  _RTL_CRITICAL_SECTION;
typedef _RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef _RTL_CRITICAL_SECTION* PRTL_CRITICAL_SECTION;
typedef CRITICAL_SECTION* PCRITICAL_SECTION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\win32exp.h ===
//header file for class Cwin32exp that is a class for win32 exceptions

#ifndef WIN32EXP_H
#define WIN32EXP_H

//tool lib headers
#include <expbase.h>
#include <strfwd.h>
#include <winfwd.h>


class Cwin32exp:public Cexpbase
{
public:
	virtual Cwin32exp::~Cwin32exp();
	Cwin32exp(DWORD err,unsigned long line,const char* module,const char* detail=0)throw();
	const char* what()const throw();
	private:
    void FormatDescriptionBuffer(const char* description)const throw();
	static std::string SystemErrorDescription (DWORD err)throw(std::exception);
	static DWORD SystemErrorDescriptionStaticBuff(DWORD err,char* buffer,int bufflen)throw();
	enum{ADDITIONAL_SPACE=512,WIN32_ERR_STRING_MAX_LEN=512};
	mutable char m_what[Cexpbase::MAX_MODULE_LEN + Cexpbase::MAX_MODULE_LEN + ADDITIONAL_SPACE];
};


#define THROW_TEST_RUN_TIME_WIN32(errorcode,details) throw Cwin32exp(errorcode,__LINE__,__FILE__,details)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\entercs.cpp ===
//implementation of class CEntercs declared in entercs.h

//internal library headrs
#include <entercs.h>

//os spesific headers
#include <windows.h>

//contrcutor - hold critical section
CEntercs::CEntercs(PCRITICAL_SECTION cs):m_cs(cs)
{
   EnterCriticalSection(m_cs);
}

//destructor - leav critical section
CEntercs::~CEntercs()
{
   LeaveCriticalSection(m_cs);
}//lint !e1740
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\htest.cpp ===
#include <win32exp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\usrthrd.h ===
// this is header file for CUserThread template class that gives the end user thread abstraction.
// the template parameter is class that implements IRunnable interface and has a default contructor
// example :
// class MyThread : public IRunnable
// {
//   virtual unsigned long ThreadMain();
//	 virtual void StopRequest();
//   MyThread();
//   MyFunc();
// }
//
//  CUserThread<MyThread> thread (new MyThread) ;
//  thread.Start();
//  HANDLE h=thread.GetHandle(); 
//  thread->MyFunc();
//


//intenal library headers
#include <thpriv.h>
#include <threadmn.h>
#include <win32exp.h>

//standart headers
#include <new>
#include <assert.h>


template <class T> class CUserThread : public IThreadmn
{
public: //IThreadmn interface
  virtual void Start() throw(Cwin32exp);
  virtual HANDLE GetHandle()const throw();
  virtual DWORD  GetId()const throw();
  virtual IRunnable* GetRunnable()const throw();
  virtual T* Get()const throw();

public: //contructors && destructor
   explicit CUserThread(T* userthread)throw(std::bad_alloc);
   CUserThread(const CUserThread&);
   virtual ~CUserThread();

public:
	CUserThread& operator=(const CUserThread&)throw();
    T* operator->() const throw();

private:
   IThreadPriv* m_thread;
};

//constructor
template <class T>  inline CUserThread<T>::CUserThread(T* userthread) throw(std::bad_alloc):m_thread(0)
{
 assert(userthread);
 try
 {
   m_thread=IThreadPriv::new_instance(userthread);
 }
 catch(std::bad_alloc&)
 {
    delete   m_thread;
	delete   userthread; 
	throw;
 }
}

//copy constructor
template <class T>  inline  CUserThread<T>::CUserThread(const CUserThread<T>& UserThread):
                            m_thread(UserThread.m_thread)
{
  m_thread->AddRef();
}

//destructor
template <class T>  inline  CUserThread<T>::~CUserThread()
{
  m_thread->Release();
}

//operator=
template <class T>  inline  CUserThread<T>& CUserThread<T>::operator=(const CUserThread<T>& UserThread)throw()
{
  if(this != & UserThread)
  {  
    m_thread->Release();
    m_thread=UserThread.m_thread;
    m_thread->AddRef();
  }
  return *this;
}

//operator->
template <class T> inline T*  CUserThread<T>::operator->() const throw()
{
  return static_cast<T*>(m_thread->GetRunnable());
}

//start the new thread
template <class T>  inline void CUserThread<T>::Start()throw(Cwin32exp)
{
	m_thread->Start();
}

//get the thread handle
template <class T> inline HANDLE CUserThread<T>::GetHandle()const throw()
{
  return m_thread->GetHandle();
}

//get the thread id
template <class T> inline DWORD CUserThread<T>::GetId()const throw()
{
  return m_thread->GetId();
}

//return the user Runnable object
template <class T> inline IRunnable*  CUserThread<T>::GetRunnable()const throw()
{
  return m_thread->GetRunnable();
}

//return the user user object
template <class T> inline T* CUserThread<T>::Get()const throw()
{
  return  static_cast<T*>(m_thread->GetRunnable());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\inc\tostr.h ===
//header file for few functions that convert few common types to strings
#ifndef TOSTR_H
#define TOSTR_H


//standart headers
#include <string>
#include <sstream>

//os spesific headers
#include <guiddef.h>


//to std::string
template <class T> static std::string ToStr(const T& val)
{
	    std::stringstream str;
		str<<val;
  	    return str.str();
}

//to std::string - hex format
template <class T> static std::string ToHexStr(const T& val)
{
      	std::ostringstream str;
		str<<std::hex<<val;
  	    return str.str();
}

//to std::wstring
template <class T> static std::	wstring ToWStr(const T& val)
{
	    std::wstringstream str;
		str<<val;
  	    return str.str();
}

//to wstd::string - hex format
template <class T> static std::wstring ToHexWStr(const T& val)
{
      	std::wstringstream str;
		str<<std::hex<<val;
  	    return str.str();
}

//guid to string
template <> static std::string ToStr(const GUID& val)
{
	  std::ostringstream str; 
	  str.fill('0');
	  str<<std::hex;
	  str.width(8);
	  str<<val.Data1<<"-";
	  str.width(4);
      str<<val.Data2<<"-";
	  str.width(4);
      str<<val.Data3<<"-";
      str.width(2);
	  str<<unsigned long(val.Data4[0]);
	  str.width(2);
      str<<unsigned long(val.Data4[1])<<"-";
	  for (int i=2;i<8;i++)
      {
        str.width(2);
        str<<unsigned long(val.Data4[i]);
      }
	  return str.str();
} 


//guid to wstring
template <> static std::wstring ToWStr(const GUID& val)
{
	  std::wostringstream str; 
	  str.fill('0');
	  str<<std::hex;
	  str.width(8);
	  str<<val.Data1<<"-";
	  str.width(4);
      str<<val.Data2<<"-";
	  str.width(4);
      str<<val.Data3<<"-";
      str.width(2);
	  str<<unsigned long(val.Data4[0]);
	  str.width(2);
      str<<unsigned long(val.Data4[1])<<"-";
	  for (int i=2;i<8;i++)
      {
        str.width(2);
        str<<unsigned long(val.Data4[i]);
      }
	  return str.str();
} 

template <> static std::string ToStr(const __int64 & val)
{
      std::ostringstream str; 
	  str.fill('0');
	  str.width(8);
	  const int* buf=reinterpret_cast<const int*>(&val);
      str<<buf[1];
	  str.width(8);
	  str<<buf[0];
	  return str.str();
} 

template <> static std::wstring ToWStr(const __int64 & val)
{
      std::wostringstream str; 
	  str.fill('0');
	  str.width(8);
	  const int* buf=reinterpret_cast<const int*>(&val);
      str<<buf[1];
	  str.width(8);
	  str<<buf[0];
	  return str.str();
}

template <> static std::string ToHexStr(const __int64 & val)
{
      std::ostringstream str; 
	  str.fill('0');
	  str.width(8);
	  const int* buf=reinterpret_cast<const int*>(&val);
      str<<std::hex<<buf[1];
	  str.width(8);
	  str<<std::hex<<buf[0];
	  return str.str();
}  

template <> static std::wstring ToHexWStr(const __int64 & val)
{
      std::wostringstream str; 
	  str.fill('0');
	  str.width(8);
	  const int* buf=reinterpret_cast<const int*>(&val);
      str<<std::hex<<buf[1];
	  str.width(8);
	  str<<std::hex<<buf[0];
	  return str.str();
}  




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\jbexp.cpp ===
//implementation of class Cjbexp - declared in jbexp.h

//internal library headers
#include <jbexp.h>

//standart headers
#include <stdio.h>
#include <assert.h>

//constructor
Cjbexp::Cjbexp(long err,
			   unsigned long line,
			   const char* module,
			   const char* detail)throw():
               Cexpbase(err,line,module,detail)//lint !e732
{
   m_what[0]='\0';
}

//contruct exception description 
const char* Cjbexp::what()const throw()
{
   int count=_snprintf( m_what,
	                    sizeof(m_what),
					    "got jet blue api error  %d at line %d module %s.  details : %s.\n",
                        geterr(),
                        getline(),
					    getmodule(),
                        getdetail()
					   );

   assert(count > 0);
   return m_what;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\expbase.cpp ===
//implementation of class Cexpbase


#include <expbase.h>

//standart headers
#include <string.h>

//return the module that has the exception
const char*   Cexpbase::getmodule()const throw()
{
 return m_module;
}

//return details about the exception
const char*   Cexpbase::getdetail()const throw()
{
  return m_detail;
}

//return the exception line number
unsigned long Cexpbase::getline()const throw()
{
  return m_line;
}

//return the exception error code
unsigned long Cexpbase::geterr() const throw()
{
  return m_err;
}

//constructor - that takes exception information and set it into the constructed object
Cexpbase::Cexpbase(unsigned long err,
		   	       unsigned long line,
				   const char* module,
				   const char* detail)throw():
                   m_err(err),
                   m_line(line)
{
     m_module[0]='\0';
	 m_detail[0]='\0'; 
					   
	 if(module != 0)
     {//lint !e525
		strncpy(m_module,module,MAX_MODULE_LEN);
     }//lint !e525 
	 if(detail != 0)//lint !e539
     {//lint !e525
		strncpy(m_detail,detail,MAX_DETAIL_LEN);
     }//lint !e525

	 m_module[MAX_MODULE_LEN-1]='\0';
	 m_detail[MAX_DETAIL_LEN-1]='\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\llibfree.cpp ===
//implementation of class Cllibfree declared in llibfree.h


//internal library headers


//os spesific headers
#include <windows.h>


//internal library headers
#include <llibfree.h>
#include <win32exp.h>


//standart headers
#include <assert.h>


class Cllibfreeimp
{
public:
  HINSTANCE m_instance;
};


//contructor that loads library and store handle to it
Cllibfree::Cllibfree(const char* dllname)throw(Cwin32exp,std::bad_alloc)
{
  m_imp=new Cllibfreeimp;
  m_imp->m_instance=LoadLibrary(dllname);//lint !e613
  if(m_imp->m_instance == 0)//lint !e613
  {
    delete m_imp; 
    THROW_TEST_RUN_TIME_WIN32(GetLastError(),"");//lint !e55
  }
}

//desctructor
Cllibfree::~Cllibfree()
{
  BOOL b=FreeLibrary(m_imp->m_instance);//lint !e613
  assert(b); 
  delete m_imp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\mtcounter.cpp ===
//implementation of class CMTCounter declared in mtcounter.h

//project spesific header
#include "mtcounter.h"

//os spesific header
#include <windows.h>

//contruct multithreaded counter with given value
CMTCounter::CMTCounter(long value):m_value(value)
{
}

//copy contructor
CMTCounter::CMTCounter(const CMTCounter& counter):m_value(counter.m_value)
{
}

//operator =
CMTCounter& CMTCounter::operator=(const CMTCounter& counter)
{
  if(this != &counter)
  {
	 m_value=counter.m_value;
  }
  return *this;
}

//pre increament
long CMTCounter::operator++()
{ 
	return InterlockedIncrement(&m_value);
}
//post increament
long CMTCounter::operator++(int) 
{
   return InterlockedIncrement(&m_value)-1;
}

//pre decreament
long CMTCounter::operator--()
{ 
	return InterlockedDecrement(&m_value);
}

//post decreament
long CMTCounter::operator--(int)
{
	return InterlockedDecrement(&m_value)+1;
} 

//return current value
long CMTCounter::operator*()const
{
	return m_value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\mqexp.cpp ===
//implementation of class CMQexp declared in mqexp.h


//internal library headers
#include <mqexp.h>

//os spesific
#include <windows.h>


//standart headers
#include <string>
#include <sstream>
#include <assert.h>



//constructor save all exception info in the base class
CMQexp::CMQexp(DWORD err,
		  unsigned long line,
		  const char* module,
		  const char* detail)throw():
          Cexpbase(err,line,module,detail)
        
{
  m_what[0]='\0';
}

//destructor
CMQexp::~CMQexp()
{
  
}

//contruct exception description 
const char* CMQexp::what()const throw()
{
   try
   {

	 //first try to get the error code with static buffer
	  char staticstr[MSMQ_ERR_STRING_MAX_LEN ];
	  DWORD res=SystemErrorDescriptionStaticBuff(geterr(),staticstr,sizeof(staticstr));//lint !e732
	  if (res == ERROR_SUCCESS)
	  {
		FormatDescriptionBuffer(staticstr); 	  
	  }
	  //try to get it with system dynamic allocated buffer (on the heap !!)
	  else
	  {
		  std::string allocatedstr=SystemErrorDescription(geterr());//lint !e732 !e55
		  if(allocatedstr == "")
		  {
			FormatDescriptionBuffer(COULD_NOT_GET_ERROR_DESC);
		  }
		  else
		  {
			 FormatDescriptionBuffer(allocatedstr.c_str());
		  }
	  }
   }
   catch(std::exception&)
   {
      FormatDescriptionBuffer(COULD_NOT_GET_ERROR_DESC);
   }
   return m_what;
}

//translate error code to string - letting FormatMessage to allocate the buffer
// if the function fails it return empry string - you can call (GetLastError() to see what happened)
std::string CMQexp::SystemErrorDescription (DWORD err)throw(std::bad_alloc)
{
       LCID locale =  GetUserDefaultLCID();
       char* pszErrorDescription=0;	
       std::string  strReturnString;
       bool fSuccess  = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
						   GetModuleHandle("MQUTIL.DLL"),
						   err,
						   locale,
						   (LPTSTR)&pszErrorDescription,
						   0,
						   NULL )!=0;


      if(fSuccess  && pszErrorDescription != 0)
	  {
        strReturnString=pszErrorDescription;
		LocalFree(pszErrorDescription);
	  } 
      return strReturnString; //lint !e55
}

//  function: SystemErrorDescriptionStaticBuff
//  Translate error code to string into user suplied buffer
// IN - DWORD err - MSMQ error code
// OUT - char buffer -  pointer to user allocated buffer
// IN - int bufflen - the buffer length.
//return WIN32 error code
DWORD CMQexp::SystemErrorDescriptionStaticBuff(DWORD err,char* buffer,int bufflen)throw()
{
    LCID locale =  GetUserDefaultLCID();
    DWORD count=FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
					          GetModuleHandle("MQUTIL.DLL"),
						      err,
						      locale,
						      buffer,
						      bufflen, //lint !e732
						      NULL);
   if(count == 0)
   {
	  return GetLastError();
   }
   else
   {
      return ERROR_SUCCESS;
   }

}

//format full description message based on the error description
void CMQexp::FormatDescriptionBuffer(const char* errdescription)const throw()
{
              int count=_snprintf( m_what,
	                               sizeof(m_what),
					               "got msmq error code %d at line %d module %s. description : %s details : %s.\n",
                                   geterr(),
                                   getline(),
					               getmodule(),
                                   errdescription,
                                   getdetail()
					 );

    assert(count > 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\nhandler.cpp ===
//implementation of class CNewHandle declared in nhandler.h

//project spesific
#include "nhandler.h"

//standart headers
#include <new> //lint !e537

//os spesific
#include <new.h>

 

//called when memory allocation fails - throw std::bad_alloc exception
// - this is not according to the standart !!
static int NewHandler( size_t size )throw(std::bad_alloc)
{
  size=size; 
  throw std::bad_alloc(); //lint !e55

 
  return 0;  //lint !e527
}//lint -e715


//contructor that saved old new handler and set new one
// that throw std::bad_alloc
CNewHandle::CNewHandle()
{
	m_oldhandler = _set_new_handler( NewHandler );

}
//revert to original new handler
CNewHandle::~CNewHandle()
{
	(void)_set_new_handler(m_oldhandler);
}//lint !e1740
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\params.cpp ===
//implementation of CInput class declared in params.h


//project spesific
#include <params.h>

//standart headers
#include <map>
#include <string>



//class that implements all CInput public members
class CInputImp
{
public:
  CInputImp(int argc, char *argv[])throw(std::bad_alloc);
  CInputImp(const CInputImp&)throw(std::bad_alloc);
  CInputImp& operator=(const CInputImp&)throw(std::bad_alloc);
  CInputImp(const std::string& str)throw(std::bad_alloc);
  bool IsExists(const std::string& str)const throw(std::bad_alloc);
  std::string operator[](const std::string& str)const throw(std::bad_alloc);
  long GetNumber(const std::string& str)const throw(std::bad_alloc);
  void ParseToken(const std::string& str,
	         std::string::size_type tokenstart,
			 std::string::size_type tokenfinish) throw(std::bad_alloc);

   mutable std::map<std::string,std::string> m;
   //lint -e1712
};




// CInput - class contructor
// IN - int argc number of arguments
// IN - char *argv[] - pointer to arrary of pointer with size of srgc
// Remark - the contructor take input parameters and build from it a map
// of toke->value pairs
CInput::CInput(int argc, char *argv[])throw(std::exception&):m_imp(new CInputImp(argc,argv))
{
}
	
// CInput - class contructor
// IN - const std::string& str - pointer to string in the format
// of token delimiter value. 
// Remark - the contructor take input parameters and build from it a map
// of toke->value pairs
CInput::CInput(const std::string& str)throw(std::bad_alloc) :m_imp(new CInputImp(str))
{
}

//copy contructor
CInput::CInput(const CInput& ci)throw(std::bad_alloc) :m_imp(new CInputImp(*ci.m_imp))
{
  
}

//destructor
CInput::~CInput()
{
  delete m_imp;
}

//operator=
CInput& CInput::operator=( const CInput& in)throw(std::bad_alloc)
{
  if(this != &in)
  {
    delete m_imp;
	m_imp= new CInputImp(*in.m_imp);
  }
  return *this;
}

//check if token exists - forward it to impelmentation class
bool CInput::IsExists(const std::string& token)const throw(std::bad_alloc) 
{
   /*lint -e613 */ 
  return m_imp->IsExists(token);
}

//return value for given token - forward it to impelmentation class
std::string CInput::operator[](const std::string& token)const throw(std::bad_alloc) 
{
  /*lint -e55 */ return m_imp->operator[](token);
}

//return numeric value for given token
long CInput::GetNumber(const std::string& token)const throw(std::bad_alloc) 
{
	return m_imp->GetNumber(token);
}

// CInputImp - class contructor
// IN - int argc number of arguments
// IN - char *argv[] - pointer to arrary of pointer with size of srgc
// Remark - the contructor take input parameters and build from it a map
// of toke->value pairs
CInputImp::CInputImp(int argc, char *argv[])throw(std::bad_alloc)
{
    int i;
    for (i=1;i<argc;i++)
    {
        ParseToken(argv[i],0,std::string::npos);
    }
}

// CInputImp - class contructor
// IN - const std::string& str - pointer to string in the format
// of token delimiter value. 
// Remark - the contructor take input parameters and build from it a map
// of toke->value pairs
CInputImp::CInputImp(const std::string& str)throw(std::bad_alloc)
{
    std::string::size_type tokenstart=0;
    std::string::size_type tokenfinish=0;
    while ((tokenstart!=std::string::npos) && (tokenfinish!=std::string::npos))
    {
        tokenstart=str.find_first_not_of(' ',tokenfinish);
        if (tokenstart!=std::string::npos)
        {
            tokenfinish=str.find_first_of(' ',tokenstart);     
            if (tokenfinish==std::string::npos)
            {
                ParseToken(str,tokenstart,tokenfinish);
            }
            else
            {
                ParseToken(str,tokenstart,tokenfinish-1);
            }
        }
    }
}

//copy contructor
CInputImp::CInputImp(const CInputImp& ci)throw(std::bad_alloc):m(ci.m)
{
}

//operator =
CInputImp& CInputImp::operator=(const CInputImp& ci)throw(std::bad_alloc)
{
  if(this != & ci)
  {
    m=ci.m;
  }
  return *this;
}


/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    str (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/
void CInputImp::ParseToken(const std::string& str,
                           std::string::size_type tokenstart,
                           std::string::size_type tokenfinish)throw(std::bad_alloc)
{
    std::string command;
    std::string value;
    std::string::size_type commandstart;
    std::string::size_type valuestart;
    commandstart=str.find("/",tokenstart)+1;
    valuestart=str.find(":",tokenstart)+1;
    if ((commandstart!=std::string::npos) &&
        (valuestart!=std::string::npos) &&
        (commandstart<valuestart) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish) &&
        (valuestart>=tokenstart) &&
        (valuestart<=tokenfinish))
    {
        command=str.substr(commandstart,valuestart-1-commandstart);
        if (tokenfinish!=std::string::npos)
        {
            value=str.substr(valuestart,tokenfinish+1-valuestart);
        }
        else
        { 
            value=str.substr(valuestart);
        }
        m[command]=value;
		return;
    }

    if ((commandstart!=std::string::npos) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish))
    {
        if (tokenfinish!=std::string::npos)
        {
            command=str.substr(commandstart,tokenfinish+1-commandstart);
        }
        else 
        {
            command=str.substr(commandstart);
        }
        m[command]="";
    }
}


/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    str (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/
bool CInputImp::IsExists(const std::string& str)const throw(std::bad_alloc)
{
/*lint -e55 */ std::map<std::string,std::string>::const_iterator p=m.find(str);
    if (p==m.end())
    { 
        return false;
    }
    else
    {
        return true;
    }
}


/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    str (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/
std::string CInputImp::operator[](const std::string& str)const throw(std::bad_alloc)
{
    if (IsExists(str))
    {
        return m[str];
    }
    else
    {    
       return "";
    }
}
 

/*++
Routine Description:
  return numeric value for given
  key

Arguments:
    str (IN) - the key.
--*/
long CInputImp::GetNumber(const std::string& str)const throw(std::bad_alloc)
{
	std::string s=operator[](str);
	return atol(s.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\test.cpp ===
#include <sptr.h>
#include <params.h>
class B;
class A
{
  B f();
};

int main(int argc,char** argv)
{
  SPTR<char> g(0);
  CInput p(argc,argv);
  CInput p1(p);
  p1=p;
  p=p1;
 
  std::string f=p1["c"];
  long y=p.GetNumber("c");
  long s=p.GetNumber("m");




  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\sqlexp.cpp ===
//implementation of class CSQLexp from declared in sqlexp.h

//internal library headers
#include <sqlexp.h>

//include standart headers
#include <stdio.h>
#include <assert.h>

//constructor save all exception info in the base class
CSQLexp::CSQLexp(long err,
		  unsigned long line,
		  const char* module,
		  const char* detail)throw():
          Cexpbase(err,line,module,detail)//lint !e732
        
{
  m_what[0]='\0';
}

//contruct exception description 
const char* CSQLexp::what()const throw()
{
   int count=_snprintf( m_what,
	                    sizeof(m_what),
					    "got sql server  error  %d at line %d module %s.  details : %s.\n",
                        geterr(),
                        getline(),
					    getmodule(),
                        getdetail()
					   );

   assert(count > 0);
   return m_what;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\strcnv.cpp ===
//standart headers
#include <string>

//os spesific headers
#include <windows.h>

//internal library headers
#include <win32exp.h>
#include <strcnv.h>

//convert string to wstring
std::wstring CStrcnv::StrToWstr(const std::string& s)throw(std::bad_alloc,Cwin32exp)
{
  wchar_t* wstr=new  wchar_t[s.length() + 1];

   int converted = MultiByteToWideChar(CP_ACP,
                                      0,
                                      s.c_str(),
                                      -1,
                                      wstr,
                                      s.length()+1); //lint !e713 


  if(converted != s.length() + 1) //lint !e737
  {
     THROW_TEST_RUN_TIME_WIN32(GetLastError(),""); //lint !e55  
  }
  
  
  std::wstring ret(wstr);
  delete[] wstr;

  return ret; //lint !e55  
} 



//convert wstring to string
std::string CStrcnv::WStrToStr(const std::wstring& wstr)throw(std::bad_alloc,Cwin32exp)
{
  char* str=new  char[wstr.length() + 1];
 

 
  int converted = WideCharToMultiByte(CP_ACP,
                                      0,
                                      wstr.c_str(),
                                      -1,
                                      str,
                                      wstr.length()+1, //lint !e713
									  0,
									  0);


  if(converted != wstr.length() + 1)  //lint !e737
  {
     THROW_TEST_RUN_TIME_WIN32(GetLastError(),""); //lint !e55  
  }
  
  
  std::string ret(str);
  delete[] str;

  return ret; //lint !e55  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\sysdir.cpp ===
//implementation of class CSysdir declared in sysdir.h


//internal library headers
#include <sysdir.h>
#include <win32exp.h>

//standart headers
#include <string>

//os spesific headers
#include <windows.h>

//return the system directory
std::string CSysdir::GetSystemDir() throw(std::bad_alloc,Cwin32exp)
{
  char sysdir[MAX_PATH];
  UINT ret=GetSystemDirectory(sysdir,MAX_PATH);
  if(ret == 0)
  {
    THROW_TEST_RUN_TIME_WIN32(GetLastError(),"could not get system directory name");//lint !e55
  }
  return sysdir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\proxycfg\inetreg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS          TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

#define REGSTR_VAL_USEIBAR              TEXT("UseBar")

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR       "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE      TEXT("Use AutoComplete")

// iBar
#define SZ_IE_IBAR                      "Bar"
#define TSZIBARPATH                     TSZIEPATH TEXT( "\\") TEXT(SZ_IE_IBAR)
#define REGSTR_PATH_IBAR                TSZIBARPATH
#define REGSTR_KEY_IBAR                 TEXT(SZ_IE_IBAR)

#define SZ_IE_IBAR_BANDS                "Bands"
#define REGSTR_PATH_IBAR_BANDS          TSZIBARPATH TEXT("\\") TEXT(SZ_IE_IBAR_BANDS)
#define REGSTR_KEY_IBAR_BANDS           TEXT(SZ_IE_IBAR_BANDS)


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")
#define REGSTR_VAL_INETCPL_PRIVACYTAB     TEXT("PrivacyTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\proxycfg\proxreg.h ===
#include <inetreg.h>

#define BLOB_BUFF_GRANULARITY   1024

class CRegBlob
{
    private:
        HKEY    _hkey;
        BOOL    _fWrite;
        BOOL    _fCommit;
        DWORD   _dwOffset;
        DWORD   _dwBufferLimit;
        BYTE *  _pBuffer;
        LPCSTR  _pszValue;

    public:
        CRegBlob(BOOL fWrite);
        ~CRegBlob();
        DWORD Init(HKEY hBaseKey, LPCSTR pszSubKey, LPCSTR pszValue);
        DWORD Abandon();
        DWORD Commit();
        DWORD WriteString(LPCSTR pszString);
        DWORD ReadString(LPCSTR * ppszString);
        DWORD WriteBytes(LPCVOID pBytes, DWORD dwByteCount);
        DWORD ReadBytes(LPVOID pBytes, DWORD dwByteCount);

    private:
        DWORD Encrpyt();
        DWORD Decrypt();
};


typedef struct {

    //
    // dwStructSize - Structure size to handle growing list of new entries or priv/pub structures
    //

    DWORD dwStructSize;

    //
    // dwFlags - Proxy type flags
    //

    DWORD dwFlags;

    //
    // dwCurrentSettingsVersion - a counter incremented every time we change our settings
    //

    DWORD dwCurrentSettingsVersion;

    //
    // lpszConnectionName - name of the Connectoid for this connection
    //
    
    LPCSTR lpszConnectionName;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;

    //
    // lpszAutoconfigUrl - autoconfig URL
    //

    LPCSTR lpszAutoconfigUrl;
    LPCSTR lpszAutoconfigSecondaryUrl;

    //
    // dwAutoDiscoveryFlags - auto detect flags.
    //

    DWORD dwAutoDiscoveryFlags;

    // 
    // lpszLastKnownGoodAutoConfigUrl - Last Successful Url 
    //

    LPCSTR lpszLastKnownGoodAutoConfigUrl;

    //
    // dwAutoconfigReloadDelayMins - number of mins until automatic 
    //    refresh of auto-config Url, 0 == disabled.
    //

    DWORD dwAutoconfigReloadDelayMins;

    //
    // ftLastKnownDetectTime - When the last known good Url was found with detection.
    //

    FILETIME ftLastKnownDetectTime;

    //
    // dwDetectedInterfaceIpCount - Number of IPs detected in last detection
    //

    DWORD dwDetectedInterfaceIpCount;

    //
    // dwDetectedInterfaceIp - Array of DWORD of IPs detected in last detection
    //

    DWORD *pdwDetectedInterfaceIp;

} INTERNET_PROXY_INFO_EX, * LPINTERNET_PROXY_INFO_EX;

// name of blob for saved legacy settings
#define LEGACY_SAVE_NAME            "SavedLegacySettings"

DWORD
LoadProxySettings();

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

DWORD
SetPerConnOptions(
    HINTERNET hInternet,    
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2
    );

HKEY
FindBaseProxyKey(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\thpriv.cpp ===
//implementation class CThreadPriv for interface IThreadPriv declared in thpriv.h

//intenal library headers
#include <thpriv.h>
#include <mtcounter.h>
#include <runnable.h>
#include <win32exp.h>

//os spesific headers
#include <windows.h>
#include <assert.h>





class CThreadPriv: public IThreadPriv
{
  CThreadPriv(IRunnable* runnable)throw(); //lint !e1704
  virtual ~CThreadPriv();

//IRefcount interface
  unsigned long virtual AddRef() throw();
  unsigned long virtual Release() throw();

//IThreadmn interface
  virtual void Start() throw(Cwin32exp);
  virtual HANDLE GetHandle()const throw();
  virtual DWORD  GetId()const throw();
  virtual IRunnable* GetRunnable() const throw();
 
//implementation details  
  static unsigned long __stdcall ThreadFunc(void* params);
  IRunnable* m_runnable; 
  HANDLE m_threadhandle;
  DWORD  m_threadid;
  CMTCounter m_counter;
  bool m_started;
  CThreadPriv(const CThreadPriv&);//lint !e1704
  CThreadPriv& operator=(const CThreadPriv&);//lint !e1704
  friend IThreadPriv;
};//lint !e1712


//virtual contructor - create CThreadPriv , increament reference count (set to 1) and return
// IThreadPriv pointer to caller
IThreadPriv* IThreadPriv::new_instance(IRunnable* runnable)throw(std::bad_alloc)
{
  IThreadPriv* ThreadPriv = new CThreadPriv(runnable);
  (void)ThreadPriv->AddRef(); //lint !e613
  return ThreadPriv;
}

//constructor that saves rannable pointer
CThreadPriv::CThreadPriv(IRunnable* runnable)throw():
             m_runnable(runnable),
             m_threadhandle(0),
             m_threadid(0),
			 m_counter(0),
			 m_started(false)
{
 
}

//return the embedded runnable object
IRunnable* CThreadPriv::GetRunnable() const throw()
{
  return   m_runnable;
}


//return the thread handle
HANDLE CThreadPriv::GetHandle ()const throw()
{
  return m_threadhandle;
}
 
//return the thread id
DWORD CThreadPriv::GetId()const throw()
{
  return m_threadid;
}

//decreamnet counter and delete itself if needed
unsigned long  CThreadPriv::Release()throw()
{
  long counterval=--m_counter;
  if(counterval <= 0)
  {
	delete(this);
  }
  return  counterval; //lint !e732
}


// increament reference count
unsigned long  CThreadPriv::AddRef()throw()
{
  return ++m_counter;  //lint !e732
}


//thread function - calls ThreadMain function on  the Runnable interface we keep
unsigned long __stdcall CThreadPriv::ThreadFunc(void* params)
{
  CThreadPriv* thread = static_cast<CThreadPriv*>(params);
  unsigned long ret=thread->m_runnable->ThreadMain();
  (void)thread->Release();
  return ret;
}


//start win32 thread
//if error in thread creation - throw Cwin32exp exception
void CThreadPriv::Start() throw(Cwin32exp)
{
  //if it already statted - do nothing
  if(m_started)
  {
    assert(0);
	return;
  }

  const    int NULL_STACK_SIZE=0;
  const    int CREATE_THREAD_STARTED=0;
  static   LPSECURITY_ATTRIBUTES  NULL_SECURITY_DESC=0;

  (void)AddRef();
  m_threadhandle=CreateThread(NULL_SECURITY_DESC, //lint !e746
							NULL_STACK_SIZE,
							CThreadPriv::ThreadFunc,
							this,
							CREATE_THREAD_STARTED,
							&m_threadid);

  if(m_threadhandle == 0)
  {
     (void)Release(); 
	 THROW_TEST_RUN_TIME_WIN32(GetLastError(),""); //lint !e55
  }
  m_started=true;
}

//destructor
CThreadPriv::~CThreadPriv()
{
  if(m_threadhandle != 0)
  {
    BOOL b=CloseHandle(m_threadhandle);
	assert(b);
  }
  delete m_runnable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\resolvename\resolvename.cpp ===
#include <libpch.h>
#include <svcguid.h>
#include <Winsock2.h>


//
// Class that ends winsock look up in it's dtor
//
class CAutoEndWSALookupService
{
public:
	CAutoEndWSALookupService(
		HANDLE h = NULL
		):
		m_h(h)
		{
		}

	~CAutoEndWSALookupService()
	{
		if(m_h != NULL)
		{
			WSALookupServiceEnd(m_h);
		}
	}

	HANDLE& get()
	{
		return m_h;		
	}

private:
	HANDLE m_h;	
};



bool
NoGetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN >* pAddr,
	bool fUseCache
    )
/*++

Routine Description:
    Return list of addreses for given unicode machine name

Parameters:
    host - A pointer to the null-terminated name of the host to resolve. 
	pAddr - pointer to vector of addresses the function should fill.
	fUseCache - indicate if to use cache for machine name translation (default use cache).
 
Returned Value:
    true on Success false on failure. 
	Call WSAGetLastError() to get the winsock error code in case of faliure.

--*/

{
	ASSERT(pAddr != NULL);
	DWORD Bufsize = 1024 + sizeof(WSAQUERYSET);
   	char* ResultBuffer = new char[Bufsize];

    //
    // create the query
    //
	GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
    AFPROTOCOLS afp[] = { {AF_INET, IPPROTO_UDP}, {AF_INET, IPPROTO_TCP } };

	PWSAQUERYSET pwsaq = (PWSAQUERYSET)ResultBuffer;
    memset(pwsaq, 0, sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = const_cast<LPWSTR>(host);
    pwsaq->lpServiceClassId = &HostnameGuid;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = sizeof(afp)/sizeof(AFPROTOCOLS);
    pwsaq->lpafpProtocols = &afp[0];

	//
	// get query handle
	//
	DWORD flags =  LUP_RETURN_ADDR;
	if(!fUseCache)
	{
		flags |= LUP_FLUSHCACHE;		
	}

	CAutoEndWSALookupService hLookup;
    int retcode = WSALookupServiceBegin(
								pwsaq,
                                flags,
                                &hLookup.get()
								);

  	

	if(retcode !=  0)
	{
		printf("WSALookupServiceNext got error %d \n", WSAGetLastError());
		return false;
	}	


	//
	// Loop and get addresses for the given machine name
	//
 	for(;;)
	{
			retcode = WSALookupServiceNext(
								hLookup.get(),
								0,
								&Bufsize,
								pwsaq
								);

		if(retcode != 0)
		{
			int ErrorCode = WSAGetLastError();
			if(ErrorCode == WSA_E_NO_MORE)
				break;

			if(ErrorCode  == WSAEFAULT)
			{
				delete[] ResultBuffer;
				ResultBuffer = new char[Bufsize];
				continue;
			}

			printf("WSALookupServiceNext got error %d \n", ErrorCode);
			return false;
		}

		DWORD NumOfAddresses = pwsaq->dwNumberOfCsAddrs;
		ASSERT(NumOfAddresses != 0);
		SOCKADDR_IN*  pAddress = (SOCKADDR_IN*)pwsaq->lpcsaBuffer->RemoteAddr.lpSockaddr;
		ASSERT(pAddress != NULL);
		std::copy(pAddress, pAddress + NumOfAddresses, std::back_inserter(*pAddr));
		delete[] ResultBuffer;
 	}
	return true; 
}

#define LOG_INADDR_FMT  "%d.%d.%d.%d"
#define LOG_INADDR(a)   (a).sin_addr.s_net, (a).sin_addr.s_host, (a).sin_addr.s_lh, (a).sin_addr.s_impno

extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
{
	if(argc != 2)
	{
		printf("resolvename [hotsname]\n");
		return -1;
	}

	const WORD x_WinsockVersion = MAKEWORD(2, 0);
	WSADATA WSAData;
    if (WSAStartup(x_WinsockVersion, &WSAData))
    {
		printf("Start winsock 2.0 Failed. Error %d \n", WSAGetLastError());
        return -1;
    }

	const LPCTSTR host =  argv[1];
	std::vector<SOCKADDR_IN> AddressList;
	bool fRet = NoGetHostByName(host, &AddressList, true);
	if(!fRet)
	{
		printf("NoGetHostByName failed\n");
		return -1;
	}
	
	
	printf("Resolved address for '%ls' succeeded. Address=" LOG_INADDR_FMT,  host, LOG_INADDR(AddressList[0]));

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\proxycfg\proxycfg.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================

//#include <libpch.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>
#include <proxreg.h>

//
// private macros
//

#define ALLOCATE_FIXED_MEMORY(Size) LocalAlloc(LMEM_FIXED, Size)

#define FREE_FIXED_MEMORY(hLocal)   LocalFree((HLOCAL)(hLocal))

#define REGOPENKEY(a, b, c)         RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a)              RegCloseKey(a)

#define CASE_OF(constant)   case constant: return # constant


//
// private prototypes
//

LPSTR InternetMapError(DWORD Error);


/*
    usage:

    proxyconfig -?  : to view help information

    proxyconfig     : to view current proxy settings under HKLM.

    proxyconfig [-d] [-p <server-name> [<bypass-list>]]

        -d : enable PROXY_TYPE_DIRECT
        -p : enable PROXY_TYPE_PROXY, with given proxy name and optional bypass list

 */


enum ARGTYPE
{
    ARGS_HELP,
    ARGS_SET_PROXY_SETTINGS,
    ARGS_VIEW_PROXY_SETTINGS,
    ARGS_INITIALIZE_PROXY_SETTINGS, // updates from HKCU only if never init
    ARGS_MIGRATE_PROXY_SETTINGS     // forces update from HKCU
};


struct ARGS
{
    ARGTYPE Command;

    DWORD   Flags;
    char *  ProxyServer;
    char *  BypassList;
};

#define INTERNET_SETTINGS_KEY         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

static const CHAR szRegPathConnections[] = INTERNET_SETTINGS_KEY "\\Connections";


void ParseArguments(int argc, char ** argv, ARGS * Args)
{
    Args->Command = ARGS_VIEW_PROXY_SETTINGS;
    Args->Flags = 0;
    Args->ProxyServer = NULL;
    Args->BypassList = NULL;

    if (argc == 0)
        return;

    for (;;)
    {
        if ((argv[0][0] != '-') || (lstrlen(argv[0]) != 2))
        {
            Args->Command = ARGS_HELP;
            goto Exit;
        }

        switch (tolower(argv[0][1]))
        {
        default:
            Args->Command = ARGS_HELP;
            goto Exit;

        case 'd':
            Args->Command = ARGS_SET_PROXY_SETTINGS;
            Args->Flags   = PROXY_TYPE_DIRECT;

            argc--;
            argv++; 

            if (argc == 0)
                goto Exit;

            continue;

        case 'i':
            Args->Command = ARGS_INITIALIZE_PROXY_SETTINGS;
            goto Exit;
            
        case 'p':
            argc--;
            argv++;

            if (argc == 0)
            {
                // error: no proxy specified
                Args->Command = ARGS_HELP;
            }
            else
            {
                Args->Command = ARGS_SET_PROXY_SETTINGS;
                Args->Flags  |= PROXY_TYPE_PROXY;

                Args->ProxyServer = argv[0];

                argc--;
                argv++;

                if (argc >= 1)
                {
                    Args->BypassList = argv[0];
                }
            }
            goto Exit;

        case 'u':
            Args->Command = ARGS_MIGRATE_PROXY_SETTINGS;
            goto Exit;
            
        }
       
    }

Exit:
    return;
}


DWORD WriteProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(TRUE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

    if (r.WriteBytes(&pInfo->dwStructSize, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD)) == 0
        || r.WriteString(pInfo->lpszProxy) == 0
        || r.WriteString(pInfo->lpszProxyBypass) == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        r.Abandon();
        goto quit;
    }

    lRes = r.Commit();
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

quit:
    return error;
}


void SetProxySettings(DWORD Flags, char * ProxyServer, char * BypassList)
{
    INTERNET_PROXY_INFO_EX  Info;
    DWORD                   error;

    // initialize structure
    memset(&Info, 0, sizeof(Info));
    Info.dwStructSize = sizeof(Info);
    Info.lpszConnectionName = "WinHttpSettings";
    Info.dwFlags = Flags;
    Info.dwCurrentSettingsVersion = 0;
    Info.lpszProxy = ProxyServer;
    Info.lpszProxyBypass = BypassList;

    error = WriteProxySettings(&Info);

    if (error)
    {
        fprintf(stderr, "Error (%s) writing proxy settings.\n", InternetMapError(error));
    }
    else
    {
        fprintf(stderr, "Updating proxy settings\n");
    }
}


DWORD MigrateProxySettings (void)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);
    DWORD dwErr = ERROR_SUCCESS;
    
    // fill out list struct
    list.dwSize = sizeof(list);
    list.pszConnection = NULL;      // NULL == LAN, otherwise connectoid name
    list.dwOptionCount = 3;         // get three options
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
        return ERROR_NOT_ENOUGH_MEMORY;
        
    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;

    // ask wininet
    BOOL fRet = InternetQueryOption (NULL,
        INTERNET_OPTION_PER_CONNECTION_OPTION,
        &list,
        &dwBufSize);

// TODO: what if there is no manual proxy setting?

    if (!fRet)
    {
        dwErr = GetLastError();
        goto cleanup;
    }
    else
    {
        SetProxySettings(
             list.pOptions[0].Value.dwValue,
             list.pOptions[1].Value.pszValue,
             list.pOptions[2].Value.pszValue
             );
    }
    
cleanup:

    GlobalFree (list.pOptions[1].Value.pszValue);
    GlobalFree (list.pOptions[2].Value.pszValue);
    delete [] list.pOptions;

    if (dwErr == ERROR_INTERNET_INVALID_OPTION)
    {
        fprintf (stderr, "proxycfg: requires IE 5.01\n");
    }
    return dwErr;
}

DWORD ReadProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(FALSE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = "WinHttpSettings";
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);

quit:
    return error;
}


void ViewProxySettings()
{
    INTERNET_PROXY_INFO_EX  Info;
    DWORD                   error;
    char *                  szFlags;

    Info.dwStructSize = sizeof(Info);

    error = ReadProxySettings(&Info);

    if (error)
    {
        fprintf(stderr, "\nError (%s) reading proxy settings.\n", InternetMapError(error));
        return;
    }

    fprintf(stdout, "\nCurrent WinHTTP proxy settings under\n\n  HKEY_LOCAL_MACHINE\\\n    %s\\\n      WinHttpSettings :\n\n", szRegPathConnections);

    switch (Info.dwFlags)
    {
    case PROXY_TYPE_DIRECT:                     szFlags = "PROXY_TYPE_DIRECT";  break;
    case PROXY_TYPE_PROXY:                      szFlags = "PROXY_TYPE_PROXY";   break;
    case PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY:  szFlags = "PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY"; break;
    default:    szFlags = "-error-";
    }

    fprintf(stdout, "    Flags        = %s\n", szFlags);

    fprintf(stdout, "    Proxy Server = %s\n", Info.lpszProxy ? Info.lpszProxy : "-not set-");

    fprintf(stdout, "    Bypass List  = %s\n\n", Info.lpszProxyBypass ? Info.lpszProxyBypass : "-not set-");
}


int __cdecl main (int argc, char **argv)
{
    ARGS    Args;
    DWORD dwErr;
    
    // Discard program arg.
    argv++;
    argc--;

    ParseArguments(argc, argv, &Args);

    switch (Args.Command)
    {
    
    case ARGS_HELP:
    default:
        fprintf (stderr,
            "\nWinHTTP Proxy Configuration Tool\n\n"
            "usage:\n\n"
            "    proxycfg -?  : to view help information\n\n"
            "    proxycfg     : to view current winhttp proxy settings (in HKLM)\n\n"
            "    proxycfg [-d] [-p <server-name> [<bypass-list>]]\n\n"
            "        -d : set PROXY_TYPE_DIRECT\n"
            "        -p : set PROXY_TYPE_PROXY, proxy server, and optional bypass list\n\n"
            "    proxycfg -u  : to set winhttp proxy settings\n"
            "                   from current user's manual setting (in HKCU)\n"
            "\n");
        break;

    case ARGS_SET_PROXY_SETTINGS:

        SetProxySettings(Args.Flags, Args.ProxyServer, Args.BypassList);
        ViewProxySettings();
        break;

    case ARGS_INITIALIZE_PROXY_SETTINGS:

        // First make sure the proxy settings have never been set before.
        INTERNET_PROXY_INFO_EX Info;
        Info.dwStructSize = sizeof(Info);
        dwErr = ReadProxySettings (&Info);
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            fprintf (stderr, "proxycfg: WinHTTP proxy settings already set.\n");
            fprintf (stderr, "proxycfg: Use -u to force update from current user.\n");
            break;
        }
        // else intentional fall through
    
    case ARGS_MIGRATE_PROXY_SETTINGS:
    
        dwErr = MigrateProxySettings();
        if (dwErr != ERROR_SUCCESS)
        {
            fprintf (stderr, "proxycfg: failed with err %d\n", dwErr);
            exit (dwErr);
        }
        ViewProxySettings();
        break;

    case ARGS_VIEW_PROXY_SETTINGS:
    
        ViewProxySettings();
        break;
    }

    return 0;
}        




///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation - copied from dll\proxreg.cxx
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // Use RegOpenKeyEx instead if not writing.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            if (_fWrite)
            {
                // nothing there - make zero size buffer
                _dwBufferLimit = 0;
            }
            else
            {
                return lRes;
            }
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


LPSTR InternetMapError(DWORD Error)

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error)
    {
    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WININET errors
    //

    CASE_OF(ERROR_INTERNET_OUT_OF_HANDLES);
    CASE_OF(ERROR_INTERNET_TIMEOUT);
    CASE_OF(ERROR_INTERNET_EXTENDED_ERROR);
    CASE_OF(ERROR_INTERNET_INTERNAL_ERROR);
    CASE_OF(ERROR_INTERNET_INVALID_URL);
    CASE_OF(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_INTERNET_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_INVALID_OPTION);
    CASE_OF(ERROR_INTERNET_BAD_OPTION_LENGTH);
    CASE_OF(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_INTERNET_SHUTDOWN);
    CASE_OF(ERROR_INTERNET_INCORRECT_USER_NAME);
    CASE_OF(ERROR_INTERNET_INCORRECT_PASSWORD);
    CASE_OF(ERROR_INTERNET_LOGIN_FAILURE);
    CASE_OF(ERROR_INTERNET_INVALID_OPERATION);
    CASE_OF(ERROR_INTERNET_OPERATION_CANCELLED);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_INTERNET_NOT_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    CASE_OF(ERROR_INTERNET_NO_DIRECT_ACCESS);
    CASE_OF(ERROR_INTERNET_NO_CONTEXT);
    CASE_OF(ERROR_INTERNET_NO_CALLBACK);
    CASE_OF(ERROR_INTERNET_REQUEST_PENDING);
    CASE_OF(ERROR_INTERNET_INCORRECT_FORMAT);
    CASE_OF(ERROR_INTERNET_ITEM_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_CANNOT_CONNECT);
    CASE_OF(ERROR_INTERNET_CONNECTION_ABORTED);
    CASE_OF(ERROR_INTERNET_CONNECTION_RESET);
    CASE_OF(ERROR_INTERNET_FORCE_RETRY);
    CASE_OF(ERROR_INTERNET_INVALID_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_NEED_UI);
    CASE_OF(ERROR_INTERNET_HANDLE_EXISTS);
    CASE_OF(ERROR_INTERNET_SEC_CERT_DATE_INVALID);
    CASE_OF(ERROR_INTERNET_SEC_CERT_CN_INVALID);
    CASE_OF(ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR);
    CASE_OF(ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR);
    CASE_OF(ERROR_INTERNET_MIXED_SECURITY);
    CASE_OF(ERROR_INTERNET_CHG_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_INTERNET_INVALID_CA);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP);
    CASE_OF(ERROR_INTERNET_ASYNC_THREAD_FAILED);
    CASE_OF(ERROR_INTERNET_REDIRECT_SCHEME_CHANGE);
    CASE_OF(ERROR_INTERNET_DIALOG_PENDING);
    CASE_OF(ERROR_INTERNET_RETRY_DIALOG);
    CASE_OF(ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR);
    CASE_OF(ERROR_INTERNET_INSERT_CDROM);
    CASE_OF(ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED);
    CASE_OF(ERROR_INTERNET_SEC_CERT_ERRORS);
    CASE_OF(ERROR_INTERNET_SECURITY_CHANNEL_ERROR);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_CACHE_FILE);
    CASE_OF(ERROR_INTERNET_TCPIP_NOT_INSTALLED);
    CASE_OF(ERROR_INTERNET_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_PROXY_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT);
    CASE_OF(ERROR_INTERNET_SEC_INVALID_CERT);
    CASE_OF(ERROR_INTERNET_SEC_CERT_REVOKED);
    CASE_OF(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
    CASE_OF(ERROR_INTERNET_NOT_INITIALIZED);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_DOWNLEVEL_SERVER);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_HEADER);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);
    CASE_OF(ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION);
    CASE_OF(ERROR_HTTP_COOKIE_DECLINED);
    CASE_OF(ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default:
        return "?";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      cluscfg.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Header File:
//      cluscfg.h
//
//  Maintained By:
//      Nela Karpel (nelak) 17-OCT-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "trigres.h"
#include "cluscfg.h"
#include <clusapi.h>
#include <initguid.h>
#include <comdef.h>
#include <mqtg.h>

extern HMODULE	g_hResourceMod;


// {031B4FB7-2C82-461a-95BB-EA7EFE2D03E7}
DEFINE_GUID( TASKID_Minor_Configure_My_Resoure_Type, 
0x031B4FB7, 0x2C82, 0x461a, 0x95, 0xBB, 0xEA, 0x7E, 0xFE, 0x2D, 0x03, 0xE7);


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::FinalConstruct()
//
//  Description:
//      ATL Constructor of the CClusCfgMQTrigResType class. This initializes
//      the member variables
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed. In this case, the object is destoryed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::FinalConstruct( void )
{
    m_lcid = LOCALE_SYSTEM_DEFAULT;

    return S_OK;

} // CClusCfgMQTrigResType::FinalConstruct()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgInitialize]
//  CClusCfgMQTrigResType::Initialize()
//
//  Description:
//      Initialize this component. This function is called by the cluster
//      configuration server to provide this object with a pointer to the 
//      callback interface (IClusCfgCallback) and with its locale id.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgMQTrigResType::Initialize(
      IUnknown *   punkCallbackIn,
	  LCID         lcidIn
    )
{
    m_lcid = lcidIn;

	if ( punkCallbackIn == NULL )
	{
		return S_OK;
	}

	//
    // Query for the IClusCfgCallback interface.
	//
    HRESULT hr;
    IClusCfgCallback * pcccCallback = NULL;

    hr = punkCallbackIn->QueryInterface( __uuidof( pcccCallback ), reinterpret_cast< void ** >( &pcccCallback ) );
    if ( SUCCEEDED( hr ) )
    {
		//
        // Store the pointer to the IClusCfgCallback interface in the member variable.
        // Do not call pcccCallback->Release()
		//
        m_cpcccCallback.Attach( pcccCallback );
    }

    return hr;

} // CClusCfgMQTrigResType::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::CommitChanges()
//
//  Description:
//      This method is called to inform a component that this node has either
//      formed, joined or left a cluster. During this call, a component typically
//      performs operations that are required to configure this resource type.
//
//      If the node has just become part of a cluster, the cluster
//      service is guaranteed to be running when this method is called.
//      Querying the punkClusterInfoIn allows the resource type to get more
//      information about the event that caused this method to be called.
//
//  Arguments:
//      punkClusterInfoIn
//          The resource should QI this interface for services provided
//          by the caller of this function. Typically, the component that
//          this punk refers to also implements the IClusCfgClusterInfo
//          interface.
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example, 
//          during a join or a form, this punk can be queried for the 
//          IClusCfgResourceTypeCreate interface, which provides methods 
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::CommitChanges(
      IUnknown * punkClusterInfoIn,
	  IUnknown * punkResTypeServicesIn
    )
{
    HRESULT     hr = S_OK;
    CComBSTR    bstrStatusReportText( L"An error occurred trying to load the status report text" );

	//
    // Dummy do-while loop to avoid gotos - we 'break' out of this loop if an error occurs
	//
    do
    {
		//
        // Set the thread locale.
		//
        SetThreadLocale( m_lcid );

        //
        // Validate parameters
        //
        if ( ( punkClusterInfoIn == NULL ) || ( punkResTypeServicesIn == NULL ) )
        {
            hr = E_POINTER;
            break;
        }

		//
        // Load the status report text first
		//
        if ( !bstrStatusReportText.LoadString( g_hResourceMod, IDS_CONFIGURING_RESOURCE_TYPE ) )
        {
            hr = E_UNEXPECTED;
            break;
        }

		//
        // Send a status report up to the UI.
		//
        if ( m_cpcccCallback != NULL )
        {
            hr = m_cpcccCallback->SendStatusReport(
									NULL,
									TASKID_Major_Configure_Resource_Types,
									TASKID_Minor_Configure_My_Resoure_Type,
									0,
									1,
									0,
									hr,
									bstrStatusReportText,
									NULL,
									L""
									);
			if ( FAILED( hr ) )
			{
				break;
			}
        }


        //
        // Find out what event caused this call.
        //
        CComQIPtr<IClusCfgClusterInfo> cpClusterInfo(punkClusterInfoIn);

		ECommitMode commitMode;
        hr = cpClusterInfo->GetCommitMode(&commitMode);

        if ( FAILED(hr) )
        {
            break;
        }


		CComQIPtr< IClusCfgResourceTypeCreate >     cpResTypeCreate( punkResTypeServicesIn );
		
		switch (commitMode)
		{
			case cmCREATE_CLUSTER:
			case cmADD_NODE_TO_CLUSTER:
				
				//
				// If we are forming or joining, create our resource type.
				//

				hr = S_HrCreateResType( cpResTypeCreate );
				
				break;

			case cmCLEANUP_NODE_AFTER_EVICT:

				//
				// By default, no resource type specific processing need be done during eviction.
				//
				break;

			default:

                hr = E_UNEXPECTED;
                break;
        }
    }
    while( false );

	//
    // Complete the status report
	//
    if ( m_cpcccCallback != NULL )
    {
        HRESULT hrTemp = m_cpcccCallback->SendStatusReport(
											NULL,
											TASKID_Major_Configure_Resource_Types,
											TASKID_Minor_Configure_My_Resoure_Type,
											0,
											1,
											1,
											hr,
											bstrStatusReportText,
											NULL,
											L""
											);

        if ( FAILED(hrTemp) && hr == S_OK )
        {
			hr = hrTemp;
        }
    }

    return hr;

} // CClusCfgMQTrigResType::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::GetTypeName()
//
//  Description:
//      Get the resource type name of this resource type.
//
//  Arguments:
//      pbstrTypeNameOut
//          Pointer to the BSTR that holds the name of the resource type.
//          This BSTR has to be freed by the caller using the function
//          SysFreeString().
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::GetTypeName( BSTR * pbstrTypeNameOut )
{
    if ( pbstrTypeNameOut == NULL )
    {
        return E_POINTER;
    } 

    *pbstrTypeNameOut = SysAllocString( xTriggersResourceType );
    if ( *pbstrTypeNameOut == NULL )
    {
        return E_OUTOFMEMORY;
    } 

    return S_OK;

} // CClusCfgMQTrigResType::GetTypeName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::GetTypeGUID()
//
//  Description:
//       Get the globally unique identifier of this resource type.
//
//  Arguments:
//       pguidGUIDOut
//           Pointer to the GUID object which will receive the GUID of this
//           resource type.
//
//  Return Values:
//      S_OK
//          The call succeeded and the *pguidGUIDOut contains the type GUID.
//
//      S_FALSE
//          The call succeeded but this resource type does not have a GUID.
//          The value of *pguidGUIDOut is undefined after this call.
//
//      other HRESULTs
//          The call failed.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::GetTypeGUID( GUID * /*pguidGUIDOut*/ )
{
	//
	// No GUID associated with Triggers cluster resource type
	//
    return S_FALSE;

} // CClusCfgMQTrigResType::GetTypeGUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgStartupListener]
//  CClusCfgMQTrigResType::Notify()
//
//  Description:
//      This method is called by the cluster service to inform a component
//      that the cluster service has started on this computer. If this DLL
//      was installed when this computer was part of a cluster, but when
//      the cluster service was not running, the resource type can be created
//      during this method call.
//
//      This method also deregisters from further cluster startup notifications,
//      since the tasks done by this method need be done only once.
//
//  Arguments:
//      IUnknown * punkIn
//          The component that implements this punk may also provide services
//          that are useful to the implementor of this method. For example,
//          this component usually implements the IClusCfgResourceTypeCreate
//          interface.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::Notify( IUnknown * punkIn )
{
    //
    // Validate parameters
    //
    if ( punkIn == NULL ) 
    {
        return E_POINTER;
    } 

	//
    // Set the thread locale.
	//
    SetThreadLocale( m_lcid );

	//
    // Create our resource type.
	//
    CComQIPtr<IClusCfgResourceTypeCreate> cpResTypeCreate( punkIn );

    HRESULT hr = S_HrCreateResType( cpResTypeCreate );
    if ( FAILED(hr) )
    {
        return hr;
    }

	//
    // Unregister from cluster startup notifications, now that our resource type has
    // been created.
	//
    hr = S_HrRegUnregStartupNotifications( false ); // false means unregister from startup notifications

    return hr;

} // CClusCfgMQTrigResType::Notify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::S_HrCreateResType()
//
//  Description:
//      This method creates this resource type and registers its admin extension.
//
//  Arguments:
//      IClusCfgResourceTypeCreate * pccrtResTypeCreateIn
//          Pointer to the IClusCfgResourceTypeCreate interface, which helps create
//          a resource type.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::S_HrCreateResType( IClusCfgResourceTypeCreate * pccrtResTypeCreateIn )
{
    //
    // Validate parameters
    //
    if ( pccrtResTypeCreateIn == NULL )
    {
        return E_POINTER;
    }

	//
    // Load the display name for this resource type.
	//
	CComBSTR bstrMyResoureTypeDisplayName;
    if ( !bstrMyResoureTypeDisplayName.LoadString(g_hResourceMod, IDS_DISPLAY_NAME) )
    {
        return E_UNEXPECTED;
    }

	//
    // Create the resource type
	//
    HRESULT hr = pccrtResTypeCreateIn->Create(
											xTriggersResourceType,
											bstrMyResoureTypeDisplayName,
											RESOURCE_TYPE_DLL_NAME,
											RESOURCE_TYPE_LOOKS_ALIVE_INTERVAL,
											RESOURCE_TYPE_IS_ALIVE_INTERVAL
											);

	return hr;

} // CClusCfgMQTrigResType::S_HrCreateResType()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications()
//
//  Description:
//      This method either registers or unregisters this component for cluster
//      startup notifications.
//
//  Arguments:
//      bool fRegisterIn
//          If true this component is registered as belonging to the
//          CATID_ClusCfgStartupListeners category. Otherwise, it unregisters this
//          component from that category.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications( bool fRegisterIn )
{
	//
    // Create the COM component categories manager.
	//
    HRESULT hr;
    CComQIPtr<ICatRegister> cpcrCatReg;

    hr = cpcrCatReg.CoCreateInstance(
						CLSID_StdComponentCategoriesMgr,
						NULL,
						CLSCTX_INPROC_SERVER
						);
    
    if ( FAILED(hr) )
    {
        return hr;
    }

	//
	// Register/Unregister implemented categories
	//
    CATID rgCatId[1];
    rgCatId[0] = CATID_ClusCfgStartupListeners;
    if ( fRegisterIn )
    {
        hr = cpcrCatReg->RegisterClassImplCategories(
							CLSID_ClusCfgMQTrigResType,
							sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] ),
							rgCatId
							);
    }
    else
    {
        hr = cpcrCatReg->UnRegisterClassImplCategories(
							CLSID_ClusCfgMQTrigResType,
							sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] ),
							rgCatId
							);
    }
    
    return hr;

} // CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::UpdateRegistry()
//
//  Description:
//      This method is called by the ATL framework to register or unregister
//      this component. Note, the name of this method should not be changed
//      as it is called by the framework.
//
//  Arguments:
//      BOOL bRegister
//          If TRUE, this component needs to be registered. It needs to be
//          unregistered otherwise.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::UpdateRegistry( BOOL bRegister )
{
	HRESULT hr;

    if ( bRegister )
    {
        hr = _Module.UpdateRegistryFromResourceD( IDR_ClusCfgMQTrigResType, bRegister );
        if ( FAILED( hr ) )
        {
           return hr;
        }

		//
        // Check if this node is already part of a cluster.
		//
        DWORD dwError;
        DWORD dwClusterState;

        dwError = GetNodeClusterState( NULL, &dwClusterState );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            return hr;
        }

        if ( dwClusterState == ClusterStateNotRunning )
        {
			//
            // If this node is already part of a cluster, but the cluster service is not running,
            // register for cluster startup notifications, so that we can create our resource type
            // the next time the cluster service starts.
			//
            hr = S_HrRegUnregStartupNotifications( true ); // true means register for startup notifications
			if ( FAILED(hr) )
			{
				return hr;
			}

        }
        else if ( dwClusterState == ClusterStateRunning )
        {
			//
            // The cluster service is running on this node. Create our resource type and register
            // our admin extension now!
			//
            CComQIPtr<IClusCfgResourceTypeCreate> cpResTypeCreate;

			//
            // Create the ClusCfgResTypeServices component. This component supports the IClusCfgResourceTypeCreate
            // interface that helps create and register resource types and their admin extensions.
			//
            hr = cpResTypeCreate.CoCreateInstance( CLSID_ClusCfgResTypeServices, NULL, CLSCTX_INPROC_SERVER );
			if ( FAILED(hr) )
            {
                return hr;
            }

            hr = S_HrCreateResType( cpResTypeCreate );
            if ( FAILED(hr) )
            {
                return hr;
            }
        }
        
        // If the node is not part of a cluster, this component will be notified when it becomes part
        // of one, so there is nothing more that need be done here.
        
    }

    else
    {
        hr = S_HrRegUnregStartupNotifications( false ); // false means unregister from startup notifications
        if ( FAILED( hr ) )
        {
            return hr;
        }

        hr = _Module.UpdateRegistryFromResourceD( IDR_ClusCfgMQTrigResType, bRegister );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;

} // CClusCfgMQTrigResType::UpdateRegistry()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      cluscfg.h
//
//  Description:
//      This file contains the declaration of the class CClusCfgMQTrigResType.
//
//  Maintained By:
//      Nela Karpel (nelak) 17-OCT-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <atlbase.h>        // for CComPtr
#include <ClusCfgGuids.h>   // for the CATID guids
#include "tclusres.h"       // main symbols


const WCHAR RESOURCE_TYPE_DLL_NAME[] = L"mqtgclus.dll";		// name of the resource type dll
const DWORD RESOURCE_TYPE_LOOKS_ALIVE_INTERVAL = 5000;		// looks-alive interval in milliseconds
const DWORD RESOURCE_TYPE_IS_ALIVE_INTERVAL = 60000;		// is-alive interval in milliseconds


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgMQTrigResType
//
//  Description:
//      This class encapsulates the functionality that a resource type needs
//      to participate in the management (creation, deletion, etc.) of the resource 
//      type when the local node forms, joins or leaves a cluster.
//
//      When the COM components in this DLL are registered (during the call to
//      DllRegisterServer()), this class specifies that it implements the
//      CATID_ClusCfgResourceTypes component category. As a result, whenever
//      a cluster is formed on this node, this node joins a cluster or this node
//      is evicted from a cluster, an object of this class is created by the
//      cluster configuration server, and its IClusCfgResourceTypeInfo::CommitChanges()
//      method is called. This method can then perform the actions required to
//      configure this cluster resource type.
//
//      If this DLL is registered when this node is already part of a cluster, but
//      when the cluster service is not running (this is the case if GetNodeClusterState()
//      returns ClusterStateNotRunning), then this class also registers for the 
//      CATID_ClusCfgStartupListeners category. As a result, when the cluster
//      service starts on this node, an object of this class is created and 
//      the IClusCfgStartupListener::Notify() method is called. This method
//      creates this resource type and deregisters from further cluster
//      startup notifications.
//
//      If this DLL is registered when the cluster service is running on this
//      node, the cluster resource type is created in the UpdateRegistry() method
//      of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgMQTrigResType :
	public IClusCfgInitialize,
	public IClusCfgResourceTypeInfo,
	public IClusCfgStartupListener,
	public CComObjectRoot,
	public CComCoClass< CClusCfgMQTrigResType, &CLSID_ClusCfgMQTrigResType >
{
public:

    // C++ constructor
    CClusCfgMQTrigResType() {}

    // ATL constructor
    HRESULT
        FinalConstruct( void );

    // ATL interface map
    BEGIN_COM_MAP(CClusCfgMQTrigResType)
	    COM_INTERFACE_ENTRY(IClusCfgInitialize)
	    COM_INTERFACE_ENTRY(IClusCfgResourceTypeInfo)
	    COM_INTERFACE_ENTRY(IClusCfgStartupListener)
    END_COM_MAP()

    // This class cannot be aggregated
    DECLARE_NOT_AGGREGATABLE(CClusCfgMQTrigResType) 

    // Registers this class as implementing the following categories
    BEGIN_CATEGORY_MAP( CClusCfgMQTrigResType )
        IMPLEMENTED_CATEGORY( CATID_ClusCfgResourceTypes )
    END_CATEGORY_MAP()

public:
    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
		IUnknown *   punkCallbackIn,
		LCID         lcidIn
		);


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeInfo methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that the resource type configuration needs to be performed.
    STDMETHOD( CommitChanges )(
		IUnknown * punkClusterInfoIn,
		IUnknown * punkResTypeServicesIn
        );

    // Get the resource type name of this resource type.
    STDMETHOD( GetTypeName )(
        BSTR *  pbstrTypeNameOut
        );

    // Get the globally unique identifier of this resource type.
    STDMETHOD( GetTypeGUID )(
        GUID * pguidGUIDOut
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupListener methods
    //////////////////////////////////////////////////////////////////////////

    // Do the tasks that need to be done when the cluster service starts on this
    // computer.
    STDMETHOD( Notify )(
          IUnknown * punkIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create this resource type and register its admin extension.
    static HRESULT
        S_HrCreateResType( IClusCfgResourceTypeCreate * pccrtResTypeCreateIn );

    // Register or unregister from cluster startup notifications.
    static HRESULT
        S_HrRegUnregStartupNotifications( bool fRegisterIn );


    // Function called by ATL framework to register this component.
    static HRESULT WINAPI
        UpdateRegistry( BOOL bRegister );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member variables
    //////////////////////////////////////////////////////////////////////////

    // Locale id
    LCID m_lcid;

    // Pointer to the callback interface
    CComPtr<IClusCfgCallback> m_cpcccCallback;

}; // class CClusCfgMQTrigResType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\stdafx.cpp ===
//  stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\tools\lib\win32exp.cpp ===
//implementation of class Cwin32exp


//internal library headers
#include <win32exp.h>


//os spesific
#include <windows.h>


//standart headers
#include <string>
#include <sstream>
#include <assert.h>



//constructor save all exception info in the base class
Cwin32exp::Cwin32exp(DWORD err,
		  unsigned long line,
		  const char* module,
		  const char* detail)throw():
          Cexpbase(err,line,module,detail)
        
{
  m_what[0]='\0';
}

//destructor
Cwin32exp::~Cwin32exp()
{
  
}

//contruct exception description 
const char* Cwin32exp::what()const throw()
{
   try
   {

	 //first try to get the error code with static buffer
	  char staticstr[WIN32_ERR_STRING_MAX_LEN ];
	  DWORD res=SystemErrorDescriptionStaticBuff(geterr(),staticstr,sizeof(staticstr));//lint !e732
	  if (res == ERROR_SUCCESS)
	  {
		FormatDescriptionBuffer(staticstr); 	  
	  }
	  //try to get it with system dynamic allocated buffer (on the heap !!)
	  else
	  {
		  std::string allocatedstr=SystemErrorDescription(geterr());//lint !e732 !e55
		  if(allocatedstr == "")
		  {
			FormatDescriptionBuffer(COULD_NOT_GET_ERROR_DESC);
		  }
		  else
		  {
			 FormatDescriptionBuffer(allocatedstr.c_str());
		  }
	  }
   }
   catch(std::exception&)
   {
      FormatDescriptionBuffer(COULD_NOT_GET_ERROR_DESC);
   }
   return m_what;
}

//translate error code to string - letting FormatMessage to allocate the buffer
// if the function fails it return empry string - you can call (GetLastError() to see what happened)
std::string Cwin32exp::SystemErrorDescription (DWORD err)throw(std::exception)
{
  
       LCID locale =  GetUserDefaultLCID();
       char* pszErrorDescription=0;	
       std::string  strReturnString;
       bool fSuccess  = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
						   NULL,
						   err,
						   locale,
						   (LPTSTR)&pszErrorDescription,
						   0,
						   NULL )!=0;


      if(fSuccess  && pszErrorDescription != 0)
	  {
        strReturnString=pszErrorDescription;
		LocalFree(pszErrorDescription);
	  } 
      return strReturnString; //lint !e55
}

//  function: SystemErrorDescriptionStaticBuff
//  Translate error code to string into user suplied buffer
// IN - DWORD err - win32 error code
// OUT - char buffer -  pointer to user allocated buffer
// IN - int bufflen - the buffer length.
//return WIN32 error code
DWORD Cwin32exp::SystemErrorDescriptionStaticBuff(DWORD err,char* buffer,int bufflen)throw()
{
    LCID locale =  GetUserDefaultLCID();
    DWORD count=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
					        0,
						    err,
						    locale,
						    buffer,
						    bufflen, //lint !e732
						    NULL);
   if(count == 0)
   {
	  return GetLastError();
   }
   else
   {
      return ERROR_SUCCESS;
   }

}

//format full description message based on the error description
void Cwin32exp::FormatDescriptionBuffer(const char* errdescription)const throw()
{
              int count=_snprintf( m_what,
	                               sizeof(m_what),
					               "got win32 error code %d at line %d module %s. description : %s details : %s.\n",
                                   geterr(),
                                   getline(),
					               getmodule(),
                                   errdescription,
                                   getdetail()
					 );

    assert(count > 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\stdafx.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Main header file

Author:

    Nela Karpel (nelak) Jul 31, 2000

Revision History:

--*/

#ifndef _TRIGCLUS_STDH_H_
#define _TRIGCLUS_STDH_H_

#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <libpch.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ClusCfgGuids.h>
#include <clusapi.h>
#include <resapi.h>

#endif // _TRIGCLUS_STDH_H_

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\trigclusp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      trigclusp.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Maintained By:
//      Nela Karpel (nelak) 31-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "tclusres.h"
#include <cm.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include <xolehlp.h>
#include <mqwin64a.h>
#include <comdef.h>
#include <mqsymbls.h>
#include <mqtg.h>
#include "trigclusp.h"


//
// Handle to Win32 event logging source
//
CEventSource     s_hEventSource;


VOID
TrigCluspReportEvent(
    WORD      wType,
    DWORD     dwEventId,
    WORD      wNumStrings,
    ...
    )

/*++

Routine Description:

    Wrapper for ReportEvent Win32 API.

Arguments:

    wType - Event type to log.

    dwEventId - Event identifier.

    wNumStrings - Number of strings to merge with message.

    ... - Array of strings to merge with message.

Return Value:

    None.

--*/

{
    if (s_hEventSource == NULL)
    {
        return;
    }

    const DWORD x_MAX_STRINGS = 20;
    ASSERT(wNumStrings < x_MAX_STRINGS);
    va_list Args;
    LPWSTR ppStrings[x_MAX_STRINGS] = {NULL};
    LPWSTR pStrVal = NULL;

    va_start(Args, wNumStrings);
    pStrVal = va_arg(Args, LPWSTR);

    for (UINT i=0; i < wNumStrings; ++i)
    {
        ppStrings[i]=pStrVal;
        pStrVal = va_arg(Args, LPWSTR);
    }

    ::ReportEvent(s_hEventSource, wType, 0, dwEventId, NULL, wNumStrings, 0, (LPCWSTR*)&ppStrings[0], NULL);

} //TrigCluspReportEvent


void
TrigCluspCreateRegistryForEventLog(
	LPCWSTR szEventSource,
	LPCWSTR szEventMessageFile
	)
/*++

Routine Description:

	Create registry keys for EventLog inforamtion

Arguments:

    szEventSource - Source Application Name

	szEventMessageFile - Message File with Event Inforamtion

Return Value:

    None.
--*/
{
	//
	// Create registery key
	//
	WCHAR appPath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(appPath, MAX_REGKEY_NAME_SIZE, L"%s%s", xEventLogRegPath, szEventSource);
    // XP SP1 bug 594248 (although cluster is not relevant on XP) .
	appPath[ MAX_REGKEY_NAME_SIZE-1 ] = L'\0' ;
	if (n < 0)
	{
		ASSERT(("Buffer to small to contain the registry path", n < 0));
		throw bad_alloc();
	}

	RegEntry appReg(appPath,  NULL, 0, RegEntry::MustExist, NULL);
	CRegHandle hAppKey = CmCreateKey(appReg, KEY_ALL_ACCESS);

	RegEntry eventFileReg(NULL, L"EventMessageFile", 0, RegEntry::MustExist, hAppKey);
	CmSetValue(eventFileReg, szEventMessageFile);


	DWORD types = EVENTLOG_ERROR_TYPE   |
				  EVENTLOG_WARNING_TYPE |
				  EVENTLOG_INFORMATION_TYPE;

	RegEntry eventTypesReg(NULL, L"TypesSupported", 0, RegEntry::MustExist, hAppKey);
	CmSetValue(eventTypesReg, types);

} // TrigCluspCreateRegistryForEventLog


CTrigResource::CTrigResource(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hReportHandle
    ):
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
    m_ResId(this),
#pragma warning(default: 4355) // 'this' : used in base member initializer list
	m_pwzResourceName(NULL),
    m_hReport(hReportHandle),
    m_hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)),
    m_hCluster(OpenCluster(NULL)),
    m_hResource(OpenClusterResource(m_hCluster, pwzResourceName))

/*++

Routine Description:

    Constructor.
    Called by Open entry point function.

    All operations must be idempotent !!

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hReportHandle - A handle that is passed back to the resource monitor
        when the SetResourceStatus or LogClusterEvent method is called. See the
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    None.
    Throws bad_alloc.

--*/

{
	//
	// TODO: Check if MSMQ Triggers is installed on this computer
	//

	ResUtilInitializeResourceStatus(&m_ResourceStatus);
    SetState(ClusterResourceOffline);

    //
    // Dont assume any limit to the resource name.
    // It is defined by client and could be very long.
    // The good thing with resource names is that Cluster
    // guarantees their uniqueness.
    //
    m_pwzResourceName = new WCHAR[wcslen(pwzResourceName) + 1];
    wcscpy(m_pwzResourceName, pwzResourceName);

    //
    // Service name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQTriggers$";
    wcscpy(m_wzServiceName, x_SERVICE_PREFIX);
    wcsncat(m_wzServiceName, m_pwzResourceName, STRLEN(m_wzServiceName) - wcslen(x_SERVICE_PREFIX));

	//
    // Initialize registry section - idempotent
    //
    // The registry section name of this Triggers resource MUST
    // be identical to the service name. The registry routines
    // in trigobjs.dll are based on that.
    //

    C_ASSERT(TABLE_SIZE(m_wzTrigRegSection)> TABLE_SIZE(REGKEY_TRIGGER_PARAMETERS) +
											   TABLE_SIZE(REG_SUBKEY_CLUSTERED) +
                                               TABLE_SIZE(m_wzServiceName));

    wcscpy(m_wzTrigRegSection, REGKEY_TRIGGER_PARAMETERS);
	wcscat(m_wzTrigRegSection, REG_SUBKEY_CLUSTERED);
    wcscat(m_wzTrigRegSection, m_wzServiceName);

	
	try
	{
		//
		// Create root key for this resource in registry
		//
		RegEntry triggerReg(m_wzTrigRegSection,  NULL, 0, RegEntry::MustExist, NULL);
		CRegHandle hTrigKey = CmCreateKey(triggerReg, KEY_ALL_ACCESS);
	}
    catch (const bad_alloc&)
	{
		(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to create registry section.\n");
		
		throw;
	}


	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Resource constructed OK.\n");

} //CTrigResource::CTrigResource()


DWORD
CTrigResource::ReportLastError(
    DWORD ErrId,
    LPCWSTR pwzDebugLogMsg,
    LPCWSTR pwzArg
    ) const

/*++

Routine Description:

    Report error messages based on last error.
    Most error messages are reported using this routine.
    The report goes to debug output and to cluster
    log file.

Arguments:

    ErrId - ID of the error string in mqsymbls.mc

    pwzDebugLogMsg - Non localized string for debug output.

    pwzArg - Additional string argument.

Return Value:

    Last error.

--*/

{
    DWORD err = GetLastError();
    ASSERT(err != ERROR_SUCCESS);

    WCHAR wzErr[10];
    _ultow(err, wzErr, 16);

    WCHAR DebugMsg[255];

    if (pwzArg == NULL)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 1, wzErr);

		_snwprintf(DebugMsg, TABLE_SIZE(DebugMsg), L"%s Error 0x%1!x!.\n", pwzDebugLogMsg);
        // XP SP1 bug 594249 (although cluster is not relevant on XP) .
		DebugMsg[ TABLE_SIZE(DebugMsg) -1 ] = L'\0' ;
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, err);
    }
    else
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 2, pwzArg, wzErr);

		_snwprintf(DebugMsg, TABLE_SIZE(DebugMsg), L"%s Error 0x%2!x!.\n", pwzDebugLogMsg);
        // Xp SP1 bug 594250 (although cluster is not relevant on XP).
		DebugMsg[ TABLE_SIZE(DebugMsg) - 1 ] = L'\0' ;
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, pwzArg, err);
    }

    return err;

} //CTrigResource::ReportLastError


void
CTrigResource::CreateRegistryForEventLog(
	VOID
    )

/*++

Routine Description:

	Update Registry with Event Log info
	for the new service

Arguments:

	hReportHandle - Handle for reports to cluster log

Return Value:


--*/

{
	try
	{
		WCHAR szEventMessagesFile[MAX_PATH];
		GetSystemDirectory(szEventMessagesFile, TABLE_SIZE(szEventMessagesFile)-15);

		wcscat(szEventMessagesFile, L"\\");
		wcscat(szEventMessagesFile, xTriggersEventSourceFile);

		TrigCluspCreateRegistryForEventLog(m_wzServiceName, szEventMessagesFile);

		return;
	}
	catch(const exception&)
	{
		TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REGISTRY_UPDATE_ERR, 1, m_wzServiceName);
		(g_pfLogClusterEvent)(GetReportHandle(), LOG_ERROR, L"Failed to update EventLog info in registry.\n");
	}


} // CreateRegistryForEventLog


void
CTrigResource::DeleteRegistryForEventLog(
	VOID
    )

/*++

Routine Description:

	Update Registry with Event Log info
	for the new service

Arguments:


Return Value:


--*/

{
	WCHAR szEventLogRegPath[256];

	wcscpy(szEventLogRegPath, xEventLogRegPath);
	wcscat(szEventLogRegPath, m_wzServiceName);

	RegDeleteKey(HKEY_LOCAL_MACHINE, szEventLogRegPath);
}


inline
VOID
CTrigResource::ReportState(
    VOID
    ) const

/*++

Routine Description:

    Report status of the resource to resource monitor.
    This routine is called to report progress when the
    resource is online pending, and to report final status
    when the resource is online or offline.

Arguments:

    None

Return Value:

    None

--*/

{
    ++m_ResourceStatus.CheckPoint;
    g_pfSetResourceStatus(m_hReport, &m_ResourceStatus);

} //CTrigResource::ReportState


bool
CTrigResource::IsResourceOfType(
    LPCWSTR pwzResourceName,
	LPCWSTR pwzType
    )

/*++

Routine Description:

    Check if a resource is of type pwzType.

Arguments:

    pwzResourceName - Name of resource to check upon.

	pwzType - Type

Return Value:

    true - Resource is of type pwzType

    false - Resource is not of type pwzType

--*/

{
    AP<BYTE> pType = 0;

	//
	// Get the type of resource with name pwzResourceName
	//
    DWORD status = ClusterResourceControl(
                       pwzResourceName,
                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                       &pType,
                       NULL
                       );

    if (status != ERROR_SUCCESS )
    {
        return false;
    }

	//
	// Compare type of the resource with the specified type name
	//
	if ( _wcsicmp(reinterpret_cast<LPWSTR>(pType.get()), pwzType) != 0 )
	{
		return false;
	}

    return true;

} //CTrigResource::IsResourceOfType


DWORD
CTrigResource::QueryResourceDependencies(
    VOID
    )

/*++

Routine Description:

	Check dependenct on MSMQ.
	Keep this routine idempotent.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    DWORD dwResourceType = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hResEnum(ClusterResourceOpenEnum(
                               m_hResource,
                               dwResourceType
                               ));
    if (hResEnum == NULL)
    {
        DWORD gle = GetLastError();
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_TRIGGER_DEPENDENCIES_ERR, 0);

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,L"Failed to enum dependencies. Error 0x%1!x!.\n", gle);

        return gle;
    }

    DWORD dwIndex = 0;
    WCHAR wzResourceName[260] = {0};
    DWORD status = ERROR_SUCCESS;
	bool fMsmq = false;
	bool fNetName = false;

    for (;;)
    {
		
		if ( fMsmq && fNetName )
		{
			return ERROR_SUCCESS;
		}

        DWORD cchResourceName = STRLEN(wzResourceName);
        status = ClusterResourceEnum(
                     hResEnum,
                     dwIndex++,
                     &dwResourceType,
                     wzResourceName,
                     &cchResourceName
                     );

        if (ERROR_SUCCESS != status)
        {
			TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_TRIGGER_DEPENDENCIES_ERR, 0);
			return status;
        }


        ReportState();

        if (IsResourceOfType(wzResourceName, xMSMQ))
        {
            fMsmq = true;
			continue;
        }

        if (IsResourceOfType(wzResourceName, xNetworkName))
        {
            fNetName = true;
			continue;
        }

    }

    return status;

} //CTrigResource::QueryResourceDependencies




DWORD
CTrigResource::ClusterResourceControl(
    LPCWSTR pwzResourceName,
    DWORD dwControlCode,
    LPBYTE * ppBuffer,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Wrapper for ClusterResourceControl.
    We want to control resources such as network name and disk.

    Note that most of the control code functions should not be called
    by resource DLLs, unless from within the online/offline threads.

Arguments:

    pwzResourceName - Name of resource to control.

    dwControlCode - Operation to perform on the resource.

    ppBuffer - Pointer to pointer to output buffer to be allocated.

    pcbSize - Pointer to allocated size of buffer, in bytes.

Return Value:

    Win32 error code.

--*/

{
    ASSERT(("must have a valid handle to cluster", m_hCluster != NULL));

    CClusterResource hResource(OpenClusterResource(
                                   m_hCluster,
                                   pwzResourceName
                                   ));
    if (hResource == NULL)
    {
        return ReportLastError(OPEN_RESOURCE_ERR, L"OpenClusterResource for '%1' failed.", pwzResourceName);
    }

    DWORD dwReturnSize = 0;
    DWORD dwStatus = ::ClusterResourceControl(
                           hResource,
                           0,
                           dwControlCode,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
    if (dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }
    ASSERT(("failed to get buffer size for a resource", 0 != dwReturnSize));

	// BUGBUG: ... temp pointer
    *ppBuffer = new BYTE[dwReturnSize];

    dwStatus = ::ClusterResourceControl(
                     hResource,
                     0,
                     dwControlCode,
                     0,
                     0,
                     *ppBuffer,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (pcbSize != NULL)
    {
        *pcbSize = dwReturnSize;
    }

    return dwStatus;

} //CTrigResource::ClusterResourceControl


DWORD
CTrigResource::AddRemoveRegistryCheckpoint(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove registry checkpoint for this resource.
    Convenient wrapper for ClusterResourceControl,
    which does the real work.

Arguments:

    dwControlCode - specifies ADD or REMOVE

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("Must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(m_wzTrigRegSection),
                         (wcslen(m_wzTrigRegSection) + 1)* sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );

    ReportState();


    if (ERROR_SUCCESS == status)
    {
        return ERROR_SUCCESS;
    }
    if (CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return ERROR_SUCCESS;
    }

    if (CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return ERROR_SUCCESS;
    }

    ReportLastError(REGISTRY_CP_ERR, L"Failed to add/remove registry CP", NULL);
    return status;

} //CTrigResource::AddRemoveRegistryCheckpoint


DWORD
CTrigResource::RegisterService(
    VOID
    ) const

/*++

Routine Description:

    Create the msmq service for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Register service (idempotent)
    //

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256] = L"";
    wcscpy(wzDisplayName, buffer);
    wcscat(wzDisplayName, L" (");
    wcsncat(wzDisplayName, m_pwzResourceName, STRLEN(wzDisplayName) - wcslen(buffer) - 5);
    wcscat(wzDisplayName, L")");

    WCHAR wzPath[MAX_PATH] = {0};
    GetSystemDirectory(wzPath, TABLE_SIZE(wzPath));
    wcscat(wzPath, L"\\mqtgsvc.exe");

    DWORD dwType = SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS;

    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(CreateService(
                                m_hScm,
                                m_wzServiceName,
                                wzDisplayName,
                                SERVICE_ALL_ACCESS,
                                dwType,
                                SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL,
                                wzPath,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                ));
    if (hService == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register service '%1'.", m_wzServiceName);
    }


    ReportState();


    LoadString(g_hResourceMod, IDS_TRIGGER_CLUSTER_SERVICE_DESCRIPTION, buffer, TABLE_SIZE(buffer));
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = buffer;
    ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);

    return ERROR_SUCCESS;

} //CTrigResource::RegisterService


DWORD
CTrigResource::SetServiceEnvironment(
    VOID
    ) const

/*++

Routine Description:

    Configure the environment for the msmq service of this QM,
    such that code inside the QM that calls GetComputerName will
    get the name of the cluster virtual server (the network name).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	//
	// ISSUE-14/08/2000 - nelak
	// Use Cm lib. Add functionality to Cm - MULTI_SZ
	//
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Setting service environment.\n");

    CEnvironment Environment(ResUtilGetEnvironmentWithNetName(m_hResource));
    if (Environment.operator PBYTE() == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to set environment for service '%1'.",
                               m_wzServiceName);
    }


    //
    // Write the environment block in the service registry
    //

    LPCWSTR x_SERVICES_KEY = L"System\\CurrentControlSet\\Services\\";

    CAutoCloseRegHandle hMyServiceKey;
	WCHAR wzFullKey[255] = {0};

	wcscpy( wzFullKey, x_SERVICES_KEY );
	wcscat( wzFullKey, m_wzServiceName );

    DWORD status = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       wzFullKey,
                       0,
                       KEY_READ | KEY_WRITE,
                       &hMyServiceKey
                       );

    if (ERROR_SUCCESS != status)
    {
        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to open registry key '%1'.", m_wzServiceName);
    }

    //
    // Compute the size of the environment. We are looking for
    // the double NULL terminator that ends the environment block.
    //
    PWCHAR p = Environment;
    while (*p)
    {
        while (*p++)
		{
			NULL;
		}
    }

    DWORD size = DWORD_PTR_TO_DWORD(reinterpret_cast<PUCHAR>(p) - Environment.operator PUCHAR()) +
                 sizeof(WCHAR);

    LPCWSTR x_ENVIRONMENT = L"Environment";
    status = RegSetValueEx(
                 hMyServiceKey,
                 x_ENVIRONMENT,
                 0,
                 REG_MULTI_SZ,
                 Environment.operator PBYTE(),
                 size
                 );

    if (ERROR_SUCCESS != status)
    {
        wcscat(wzFullKey, L"\\");
        wcscat(wzFullKey, x_ENVIRONMENT);

        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to set registry value '%1'.", m_wzServiceName);
    }

    return ERROR_SUCCESS;

} //CTrigResource::SetServiceEnvironment


DWORD
CTrigResource::StartService(
    VOID
    ) const

/*++

Routine Description:

    Configure environment for the MSMQTriggers service of this resource,
    start the service and block until it's up and running.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to open service '%1'.", m_wzServiceName);
    }

    DWORD status = SetServiceEnvironment();
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Starting the '%1' service.\n", m_wzServiceName);

    BOOL rc = ::StartService(hService, 0, NULL);

	ReportState();

    //
    // Could take a long time for service to start.
    // This routine can be called more than once.
    //
    if (!rc &&
        ERROR_SERVICE_ALREADY_RUNNING != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError())
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to start service '%1'.", m_wzServiceName);
    }

    //
    // Wait until service is up
    //
    TrigCluspReportEvent(EVENTLOG_INFORMATION_TYPE, START_SERVICE_OK, 1, m_wzServiceName);
    SERVICE_STATUS ServiceStatus;
    for (;;)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(START_SERVICE_ERR, L"Failed to query service '%1'.", m_wzServiceName);
        }


        ReportState();


        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            Sleep(100);
            continue;
        }

        break;
    }

    if (SERVICE_RUNNING != ServiceStatus.dwCurrentState)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Service '%1' failed to start.\n", m_wzServiceName);

        return ERROR_SERVICE_SPECIFIC_ERROR;
    }

    return ERROR_SUCCESS;

} //CTrigResource::StartService


DWORD
CTrigResource::BringOnline(
    VOID
    )

/*++

Routine Description:

    Handle operations to perform online of this MSMQTriggers
	resource:

    * query dependencies
    * add registry checkpoint
	* start the service

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online.\n");

	DWORD status = QueryResourceDependencies();

	if (ERROR_SUCCESS != status)
    {
        return status;
    }

    status = AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

	if (ERROR_SUCCESS != (status = RegisterService()) ||
		ERROR_SUCCESS != (status = StartService()) )
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to bring online. Error 0x%1!x!.\n",
                              status);

        return status;
    }

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"All first-online operations completed.\n");

    return ERROR_SUCCESS;

} //CTrigResource::BringOnline


DWORD
CTrigResource::StopService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop a service and block until it's stopped (or timeout).

Arguments:

    pwzServiceName - The service to stop.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(STOP_SERVICE_ERR, L"Failed to open service '%1'.", pwzServiceName);
    }

    SERVICE_STATUS ServiceStatus;
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus) &&
        ERROR_SERVICE_NOT_ACTIVE != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError() &&
        ERROR_BROKEN_PIPE != GetLastError())
    {
        return ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
    }

    //
    // Wait until service is down (or timeout 5 seconds)
    //
    const DWORD x_TIMEOUT = 1000 * 5;

    DWORD dwWaitTime = 0;
    while (dwWaitTime < x_TIMEOUT)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(STOP_SERVICE_ERR, L"Failed to query service '%1'.", pwzServiceName);
        }

        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            //
            // Service is still start pending from a previous call
            // to start it. So it cannot be stopped. We can do
            // nothing about it. Trying to terminate the process
            // of the service will fail with access denied.
            //
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Service '%1' can not be stopped because it is start pending.\n", pwzServiceName);

            return SERVICE_START_PENDING;
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
        {
            break;
        }

        const DWORD x_INTERVAL = 50;
        Sleep(x_INTERVAL);
        dwWaitTime += x_INTERVAL;
    }

    if (SERVICE_STOPPED != ServiceStatus.dwCurrentState)
    {
        //
        // Service failed to stop.
        //
        ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
        return ServiceStatus.dwCurrentState;
    }

    return ERROR_SUCCESS;

} //CTrigResource::StopService


DWORD
CTrigResource::RemoveService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop and delete a service.

Arguments:

    pwzServiceName - The service to stop and delete.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    //
    // First check if service exists
    //
    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to open service '%1'", pwzServiceName);
    }

    //
    // Service exists. Make sure it is not running.
    //
    DWORD status = StopService(pwzServiceName);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting service '%1'.\n", pwzServiceName);

    if (!DeleteService(hService) &&
        ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
    {
        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to delete service '%1'", pwzServiceName);
    }

    return ERROR_SUCCESS;

} //CTrigResource::RemoveService


BOOL
CTrigResource::CheckIsAlive(
    VOID
    ) const

/*++

Routine Description:

    Checks is the service is up and running.

Arguments:

    None.

Return Value:

    TRUE - The service is up and running.

    FALSE - The service is not up and running.

--*/

{

    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));

    SERVICE_STATUS ServiceStatus;
    BOOL fIsAlive = QueryServiceStatus(hService, &ServiceStatus) &&
                    SERVICE_RUNNING == ServiceStatus.dwCurrentState;

    return fIsAlive;

} //CTrigResource::CheckIsAlive


VOID
CTrigResource::RegDeleteTree(
    HKEY hRootKey,
    LPCWSTR pwzKey
    ) const

/*++

Routine Description:

    Recursively delete registry key and all its subkeys - idempotent.

Arguments:

    hRootKey - Handle to the root key of the key to be deleted

    pwzKey   - Key to be deleted

Return Value:

    None

--*/

{
	//
	// TODO: Use CM, write EnumKeys function in CM
	//
    HKEY hKey = 0;
    if (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, pwzKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, &hKey))
    {
        return;
    }

    for (;;)
    {
        WCHAR wzSubkey[255] = {0};
        DWORD cbSubkey = 0;

        cbSubkey = TABLE_SIZE(wzSubkey);
        if (ERROR_SUCCESS != RegEnumKeyEx(hKey, 0, wzSubkey, &cbSubkey, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteTree(hKey, wzSubkey);
    }

    RegCloseKey(hKey);

    RegDeleteKey(hRootKey, pwzKey);

} //CTrigResource::RegDeleteTree


VOID
CTrigResource::DeleteTrigRegSection(
    VOID
    )
{
    //
    // Idempotent deletion
    //

    if (wcslen(m_wzTrigRegSection) < 1)
    {
        return;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting registry section '%1'.\n", m_wzTrigRegSection);

    RegDeleteTree(REGKEY_TRIGGER_POS, m_wzTrigRegSection);

    wcscpy(m_wzTrigRegSection, L"");

} //CTrigResource::DeleteTrigRegSection


static
bool
TrigCluspIsMainSvcConfigured(
    VOID
    )

/*++

Routine Description:

    Query if main msmq service running on the node is configured
    for clustering, i.e. is demand start.

Arguments:

    None

Return Value:

    true - Main msmq triggers service is configured for clustering.

    false - Main msmq triggers service is not configured, or a failure accured.

--*/

{
    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hScm == NULL)
    {
        return false;
    }

    CServiceHandle hService(OpenService(hScm, xDefaultTriggersServiceName, SERVICE_ALL_ACCESS));
    if (hService == NULL)
    {
        return false;
    }

    P<QUERY_SERVICE_CONFIG> pqsc = new QUERY_SERVICE_CONFIG;
    DWORD cbSize = sizeof(QUERY_SERVICE_CONFIG);
    DWORD dwBytesNeeded = 0;
    memset(pqsc, 0, cbSize);

    BOOL success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);

    if (!success && ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
        delete pqsc.detach();

        cbSize = dwBytesNeeded + 1;
        pqsc = reinterpret_cast<LPQUERY_SERVICE_CONFIG>(new BYTE[cbSize]);
        memset(pqsc, 0, cbSize);

        success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);
    }

    if (!success)
    {
        return false;
    }

    if (pqsc->dwStartType != SERVICE_DEMAND_START)
    {
        return false;
    }

    return true;

} //TrigCluspIsMainSvcConfigured


static
VOID
TrigCluspConfigureMainSvc(
    VOID
    )

/*++

Routine Description:

    If cluster software was installed on this machine after installation
    of msmq, then the main msmq triggers service needs to be reconfigured
	to manual start

    Since this routine deals only with the main msmq triggers service on the
    node, failure is not critical.

Arguments:

    None

Return Value:

    None.
--*/

{
    if (TrigCluspIsMainSvcConfigured())
    {
        //
        // Dont configure more than once.
        //
        return;
    }

    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));

    ASSERT(("Must have a valid handle to SCM", hScm != NULL));

    CServiceHandle hService(OpenService(hScm, xDefaultTriggersServiceName, SERVICE_ALL_ACCESS));

    if (hService == NULL)
    {
        return;
    }

    ChangeServiceConfig(
        hService,
        SERVICE_NO_CHANGE,
        SERVICE_DEMAND_START,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

} //TrigCluspConfigureMainSvc


VOID
TrigCluspRegisterEventSource(
    VOID
    )

/*++

Routine Description:

    Register event source so that this DLL can log events
    in the Windows Event Log.

    We do not use the routines in trigobjs.dll to do that,
    since this DLL is installed as part of the cluster
    product and should not assume that MSMQ Triggers are installed.

Arguments:

    None

Return Value:

    None.

--*/

{
    if (s_hEventSource != NULL)
    {
        //
        // Already registered
        //
        return;
    }

    WCHAR wzFilename[MAX_PATH] = L"";
    if (0 == GetModuleFileName(g_hResourceMod, wzFilename, TABLE_SIZE(wzFilename)))
    {
        return;
    }

    LPCWSTR x_EVENT_SOURCE = L"MSMQTriggers Cluster Resource DLL";

	TrigCluspCreateRegistryForEventLog(x_EVENT_SOURCE, wzFilename);

    s_hEventSource = RegisterEventSource(NULL, x_EVENT_SOURCE);

} //TrigCluspRegisterEventSource


DWORD
TrigCluspStartup(
    VOID
    )

/*++

Routine Description:

    This routine is called when DLL is registered or loaded.
    Could be called by many threads.
    Do not assume that MSMQ / Triggers is installed on the node here.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successful

    Win32 error code - The operation failed.

--*/

{
    try
    {
        TrigCluspConfigureMainSvc();

        TrigCluspRegisterEventSource();
    }

    catch (const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //TrigCluspStartup


RESID
TrigCluspOpen(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Create an object to represent a new MSMQTriggers resource
	and return a handle to that object.

Arguments:

    pwzResourceName - Name of this MSMQTriggers resource.

    hResourceHandle - report handle for this MSMQTriggers resource.

Return Value:

    NULL - The operation failed.

    Some valid address - the memory offset of this MSMQTriggers object.

--*/

{
    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"Opening resource.\n");

    CTrigResource * pTrigRes = NULL;
    try
    {
        pTrigRes = new CTrigResource(pwzResourceName, hResourceHandle);

		(g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"Resource was opened successfully.\n");

		return static_cast<RESID>(pTrigRes);
   }

	catch(const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(hResourceHandle, LOG_ERROR, L"No memory (CQmResource construction).\n");
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }


} //TrigCluspOpen


VOID
TrigCluspClose(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Delete the TrigRes object. Undo TrigCluspOpen.

Arguments:

    pTrigRes - pointer to the CTrigResource object

Return Value:

    None.

--*/

{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Closing resource.\n");

    delete pTrigRes;

} //TrigCluspClose



DWORD
TrigCluspOnlineThread(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    This is the thread where stuff happens: bringing
    the resource online.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Starting online thread.\n");

    try
    {
        pTrigRes->SetState(ClusterResourceOnlinePending);
        pTrigRes->ReportState();

		pTrigRes->CreateRegistryForEventLog();

        DWORD status = ERROR_SUCCESS;
		status = pTrigRes->BringOnline();

        if (ERROR_SUCCESS != status)
        {
            //
            // We report the resource as failed, so make sure
            // the service and driver are indeed down.
            //
            pTrigRes->StopService(pTrigRes->GetServiceName());

            pTrigRes->SetState(ClusterResourceFailed);
            pTrigRes->ReportState();

            (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION,
                                  L"Failed to bring online. Error 0x%1!x!.\n", status);

            return status;
        }


        pTrigRes->SetState(ClusterResourceOnline);
        pTrigRes->ReportState();
    }

    catch (const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, L"No memory (online thread).\n");

        return ERROR_OUTOFMEMORY;
    }

    return(ERROR_SUCCESS);

} //TrigCluspOnlineThread


DWORD
TrigCluspOffline(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Brings down this QM resource:
    * stop and remove device driver and msmq service
    * delete the binary for the device driver

    We not only stop the QM, but also undo most of the
    operations done in BringOnline. This way we clean
    the local node before failover to remote node, and
    Delete on the remote node will not leave "garbage"
    on this node.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	pTrigRes->RemoveService(pTrigRes->GetServiceName());

	pTrigRes->DeleteRegistryForEventLog();

    return ERROR_SUCCESS;

} //TrigCluspOffline


BOOL
TrigCluspCheckIsAlive(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Verify that the msmq service of this QM is up and running.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    TRUE - The msmq service for this QM is up and running.

    FALSE - The msmq service for this QM is not up and running.

--*/

{

	return pTrigRes->CheckIsAlive();

} //TrigCluspCheckIsAlive


DWORD
TrigCluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    //
    // MSMQTriggers resource depends on MSMQ service.
    // The code is taken from cluster tree.
    //

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_SZ_DECLARE( msmq, TABLE_SIZE(xMSMQ) );
    CLUSPROP_SZ_DECLARE( networkEntry, TABLE_SIZE(xNetworkName) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;

typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;


static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, msmq), CLUSPROP_SYNTAX_NAME, sizeof(xMSMQ), const_cast<LPWSTR>(xMSMQ) },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(xNetworkName), const_cast<LPWSTR>(xNetworkName) },
    { 0, 0 }
};

    try
    {
        PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
        PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
        CLUSPROP_BUFFER_HELPER value;

        *BytesReturned = sizeof(COMMON_DEPEND_DATA);
        if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) )
        {
            if ( OutBuffer == NULL )
            {
                return ERROR_SUCCESS;
            }

            return ERROR_MORE_DATA;
        }
        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 )
        {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat )
            {
            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD) DWORD_PTR_TO_DWORD(pdepsetup->Value); //safe cast, the value is known to be a DWORD constant
                break;

            case CLUSPROP_FORMAT_SZ:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
    }
    catch (const bad_alloc&)
    {
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //TrigCluspClusctlResourceGetRequiredDependencies


DWORD
TrigCluspClusctlResourceSetName(
    VOID
    )
{
    //
    // Refuse to rename the resource
    //
    return ERROR_CALL_NOT_IMPLEMENTED;

} //TrigCluspClusctlResourceSetName


DWORD
TrigCluspClusctlResourceDelete(
    CTrigResource * pTrigRes
    )
{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Deleting resource.\n");

    pTrigRes->RemoveService(pTrigRes->GetServiceName());

    pTrigRes->AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);

	//
	// TODO: when Cm will be used, catch exceptions
	//
    pTrigRes->DeleteTrigRegSection();

    return ERROR_SUCCESS;

} //TrigCluspClusctlResourceDelete


DWORD
TrigCluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    return TrigCluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, BytesReturned);

} // TrigCluspClusctlResourceTypeGetRequiredDependencies
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\trigres_i_.c ===
#include <trigres_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\trigclus.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      trigclus.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Maintained By:
//      Nela Karpel (nelak) 31-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "tclusres.h"
#include "trigclusp.h"
#include <comdef.h>
#include <mqtg.h>
#include "_mqres.h"


//
// Load the mqutil resource only DLL first
//
HMODULE	g_hResourceMod = MQGetResourceHandle();


// Event Logging routine.

PLOG_EVENT_ROUTINE g_pfLogClusterEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_TrigClusFunctionTable;

//
// TrigClus resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
TrigClusResourcePrivateProperties[] = {
    { 0 }
};



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) 
	{
        return(ERROR_REVISION_MISMATCH);
    }

    if ( 0 != _wcsicmp( ResourceType, xTriggersResourceType )  ) 
	{
        return(ERROR_MOD_NOT_FOUND);
    }

    if ( g_pfLogClusterEvent == NULL ) 
	{
        g_pfLogClusterEvent = LogEvent;
        g_pfSetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_TrigClusFunctionTable;

    return TrigCluspStartup();

} // Startup


RESID
WINAPI
TrigClusOpen(
    IN LPCWSTR pwzResourceName,
    IN HKEY /* ResourceKey */,
    IN RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Open routine for TrigClus resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        TrigClusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    return TrigCluspOpen(pwzResourceName, hResourceHandle);

} // TrigClusOpen


VOID
WINAPI
TrigClusClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for TrigClus resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return;
    }

    if ( ResourceId != pTrigRes->GetResId() )
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Close sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Deallocate resource entry
    //
    TrigCluspClose(pTrigRes);

} // TrigClusClose



DWORD
WINAPI
TrigClusOnlineThread(
    PCLUS_WORKER /*WorkerPtr*/,
    IN CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    pqm - A pointer to the TRIGCLUS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    return TrigCluspOnlineThread(pTrigRes);

} // TrigClusOnlineThread



DWORD
WINAPI
TrigClusOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE /* EventHandle */
    )

/*++

Routine Description:

    Online routine for TrigClus resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId()) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Online sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    pTrigRes->SetState(ClusterResourceFailed);
    
	ClusWorkerTerminate( &pTrigRes->m_OnlineThread );
    
	DWORD status = ClusWorkerCreate( 
                       &pTrigRes->m_OnlineThread,
                       reinterpret_cast<PWORKER_START_ROUTINE>(TrigClusOnlineThread),
                       pTrigRes
                       );
    if ( status != ERROR_SUCCESS ) 
    {
        pTrigRes->SetState(ClusterResourceFailed);
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Failed to create the online thread. Error 0x%1!x!.\n", status);
    } 
    else 
    {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // TrigClusOnline



DWORD
WINAPI
TrigClusOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for TrigClus resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Offline sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    return TrigCluspOffline(pTrigRes);

} //TrigClusOffline


VOID
WINAPI
TrigClusTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for TrigClus resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return;
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Terminate sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Terminate the resource.
    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pTrigRes->m_OnlineThread );

    //
    // SCM does not provide any way to kill a service immediately.
    // Even trying to query the service for its process ID and then 
    // terminating the process will fail with access denied.
    // So we will stop the service gracefully by calling Offline.
    //
    TrigCluspOffline(pTrigRes);
    pTrigRes->SetState(ClusterResourceOffline);

} // TrigClusTerminate


BOOL
TrigClusCheckIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Check to see if the resource is alive for TrigClus resources.

Arguments:

    pTrigRes - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"IsAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    //
    // Check to see if the resource is alive.
    //
    return TrigCluspCheckIsAlive(pTrigRes);

} // TrigClusCheckIsAlive


BOOL
WINAPI
TrigClusLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for TrigClus resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    return TrigClusCheckIsAlive(ResourceId);

} // TrigClusLooksAlive


BOOL
WINAPI
TrigClusIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for TrigClus resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{

    return TrigClusCheckIsAlive(ResourceId);

} // TrigClusIsAlive


DWORD
WINAPI
TrigClusResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID /* InBuffer */,
    IN DWORD /* InBufferSize */,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for TrigClus resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"ResourceControl sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_UNKNOWN:
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = TrigCluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            status = TrigCluspClusctlResourceSetName();
            break;

        case CLUSCTL_RESOURCE_DELETE:
            status = TrigCluspClusctlResourceDelete(pTrigRes);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // TrigClusResourceControl


DWORD
WINAPI
TrigClusResourceTypeControl(
    IN LPCWSTR  pResourceTypeName,
    IN DWORD    ControlCode,
    IN PVOID    /*InBuffer*/,
    IN DWORD    /*InBufferSize*/,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MSMQTriggers resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    pResourceTypeName - Supplies the type name of the specific resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_TYPE_NOT_FOUND - pResourceTypeName is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    if (0 != _wcsicmp(pResourceTypeName, xTriggersResourceType)) 
    {
        return ERROR_RESOURCE_TYPE_NOT_FOUND;
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = TrigCluspClusctlResourceTypeGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
	}

    return(status);

} // TrigClusResourceTypeControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_TrigClusFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         TrigClus,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         TrigClusResourceControl,     // ResControl
                         TrigClusResourceTypeControl); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\trigclusp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    TrigClusp.h

Abstract:

    Header for internal routines

Author:

    Nela Karpel ( nelak ) 27 Jul 2000

Revision History:

--*/

#ifndef _TRIGCLUSP_H_
#define _TRIGCLUSP_H_

#include <autorel2.h>
#include <autorel3.h>
#include "mqnames.h"



extern HMODULE	g_hResourceMod;
extern PLOG_EVENT_ROUTINE           g_pfLogClusterEvent;
extern PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus;
extern CLRES_FUNCTION_TABLE         g_MqclusFunctionTable;

const WCHAR xMSMQ[] = L"MSMQ";
const WCHAR xNetworkName[] = L"Network Name";

const WCHAR xEventLogRegPath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
const WCHAR xTriggersEventSourceFile[] = MQUTIL_DLL_NAME;

//
// CTrigResource - Holds information of a single resource 
//
class CTrigResource
{

public:
	CTrigResource(LPCWSTR, RESOURCE_HANDLE);
	~CTrigResource(){};

	void CreateRegistryForEventLog();
	void DeleteRegistryForEventLog();

	RESID GetResId(VOID) const { return m_ResId; };
    LPCWSTR GetResourceName(VOID) const { return m_pwzResourceName; };
	LPCWSTR GetServiceName(VOID) const { return m_wzServiceName; }; 
    RESOURCE_HANDLE GetReportHandle(VOID) const { return m_hReport; };

    BOOL CheckIsAlive(VOID) const;
    
	DWORD AddRemoveRegistryCheckpoint(DWORD) const;

    DWORD BringOnline(VOID);
	DWORD StopService(LPCWSTR) const;
    DWORD RemoveService(LPCWSTR) const;

    VOID DeleteTrigRegSection(VOID);
    
	VOID SetState(CLUSTER_RESOURCE_STATE s) { m_ResourceStatus.ResourceState = s; };
    inline VOID ReportState(VOID) const;

	CLUS_WORKER m_OnlineThread;

private:
	DWORD ReportLastError(DWORD, LPCWSTR, LPCWSTR) const;
	
	bool IsResourceOfType(LPCWSTR, LPCWSTR);
	
	DWORD SetServiceEnvironment(VOID) const;
	DWORD QueryResourceDependencies(VOID);
	DWORD RegisterService(VOID) const;
	DWORD StartService(VOID) const;

	DWORD ClusterResourceControl(LPCWSTR, DWORD, LPBYTE*, DWORD*) const;

	VOID  RegDeleteTree(HKEY, LPCWSTR) const;


private:
	RESID                     m_ResId;
    AP<WCHAR>                 m_pwzResourceName; 
	WCHAR                     m_wzServiceName[200];
    WCHAR                     m_wzTrigRegSection[200 + 100];
    mutable RESOURCE_STATUS   m_ResourceStatus;

    RESOURCE_HANDLE           m_hReport;
	CServiceHandle            m_hScm;
	CAutoCluster              m_hCluster;
    CClusterResource          m_hResource;


}; //class CTrigResource


DWORD
TrigCluspStartup(
    VOID
    );


RESID
TrigCluspOpen(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hResourceHandle
    );


VOID
TrigCluspClose(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspOnlineThread(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspOffline(
    CTrigResource * pTrigRes
    );


BOOL
TrigCluspCheckIsAlive(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );


DWORD
TrigCluspClusctlResourceSetName(
    VOID
    );


DWORD
TrigCluspClusctlResourceDelete(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

#endif //_TRIGCLUSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\genmqsec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	GenMQSec.h

Abstract:
    generates a security descriptor matching the desired access to MQ.

Author:
   Dan Bar-Lev
   Yifat Peled	(yifatp)	24-Sep-98

--*/

#ifndef GEN_MQ_SEC_H_
#define GEN_MQ_SEC_H_


DWORD 
GenSecurityDescriptor(	SECURITY_INFORMATION*	pSecInfo,
						const WCHAR*			pwcsSecurityStr,
						PSECURITY_DESCRIPTOR*	ppSD);


#endif // GEN_MQ_SEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\cinputparams.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	CInputParams.h

Abstract:
    CInputParams definition
	This class takes the arguments from the command line
    and puts them into a container. You can get each
    argument by calling CInputParams[] operator. 
	You can find if argument exists by calling IsOptionGiven.
	(each argument may be given only once)
	The format of an argument may be:
	/command:value  (no spaces)
	/command

Author:
   Ofer Gigi		
   Yifat Peled 31-Aug-98

--*/

        
#ifndef _CINPUT_PARAMS_H
#define _CINPUT_PARAMS_H



using namespace std;


class CInputParams     
{    
public:  
    CInputParams(int argc, WCHAR *argv[]);
    CInputParams(const wstring& wcs);
    virtual ~CInputParams(){};
    bool IsOptionGiven(const wstring& wcsOption)const;
    wstring operator[](const wstring& wcsOption);
	    
private:
    void ParseToken(const wstring& wcsToken,
					wstring::size_type tokenstart,
					wstring::size_type tokenfinish);

	wstring Covert2Upper(const wstring& wcs)const;

	map<wstring, wstring> m_InputParams;
};    

  
#endif //_CINPUT_PARAMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\cluster\trigres.cpp ===
// trigres.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ResourceType.idl by adding the following 
//      files to the Outputs.
//          ResourceType_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ResourceTypeps.mk in the project directory.

#include "stdafx.h"
#include "tclusres.h"
#include "trigres.h"
#include "cluscfg.h"
#include <cm.h>


CComModule _Module;
extern HMODULE	g_hResourceMod;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ClusCfgMQTrigResType, CClusCfgMQTrigResType)
END_OBJECT_MAP()


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /* lpReserved */)
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RESOURCETYPELib);

        DisableThreadLibraryCalls(hInstance);
		
		CmInitialize(HKEY_LOCAL_MACHINE, L"");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\logcodes.hpp ===
//*******************************************************************
//
// File Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef __LOGCODES_INCLUDED
#define __LOGCODES_INCLUDED

#define LOGCAT_ERROR    3
#define LOGCAT_WARNING  2
#define LOGCAT_INFO     1

// Informational
#define LOGEVNT_TRACE                   0
#define LOGEVNT_STARTUP                 1
#define LOGEVNT_TRIGGER_INITIALISED     2
#define LOGEVNT_STATUS_UPDATE	        3
#define LOGEVNT_QUEUE_CREATED           4

// Warnings
#define LOGEVNT_QUEUE_INVALID           100
#define LOGEVNT_MSGBODY_BUFFER_OVERFLOW 101
#define LOGEVNT_UNKNOWN_ENABLEMENT_ID   102

// ERRORS 
#define LOGEVNT_FAILED                     -1

#define LOGEVNT_INIT_FAILED                -1
#define LOGEVNT_QOPEN_FAILED               -2
#define LOGEVNT_THREAD_STOP_FAILED         -3
#define LOGEVNT_WAIT_FAILED                -4
#define LOGEVNT_EXECUTE_ACTION_FAILED      -5 
#define LOGEVNT_COINITIALIZE_FAILED        -6
#define LOGEVNT_COMPONENT_CREATE_FAILED    -7
#define LOGEVNT_METHOD_INVOCATION_FAILED   -8
#define LOGEVNT_RECV_MSG_FAILED            -9
#define LOGEVNT_CREATE_CURSOR_FAILED       -10
#define LOGEVNT_CREATEIOPORT_FAILED        -11
#define LOGEVNT_BINDIOPORT_FAILED          -12
#define LOGEVNT_STOP_REQUEST_FAILED        -13
#define LOGEVNT_HANDLER_CREATE_FAILED      -14
#define LOGEVNT_RECEIVEMSG_FAILED          -15
#define LOGEVNT_PROPBAG_CREATE_FAILED      -16
#define LOGEVNT_THREADPOOL_INIT_FAILED     -17
#define LOGEVNT_THREADPOOL_SHUTDOWN_FAILED -18
#define LOGENVT_ATTACHTRIGGER_FAILED       -19
#define LOGEVNT_OPEN_LOGQUEUE_FAILED       -20
#define LOGEVNT_CREATE_MONITOR_FAILED      -21
#define LOGEVNT_INVALID_CONFIG_PARM        -22
#define LOGEVNT_MEM_ALLOC_FAILED           -23
#define LOGEVNT_CREATE_KEY_FAILED          -24
#define LOGEVNT_INVALID_OBJECT             -25
#define LOGEVNT_GET_CONFIG_PARM_FAILED     -26
#define LOGEVNT_GETQUEUEREF_FAILED         -27
#define LOGEVNT_UNKNOWN_RESULT             -28
#define LOGEVNT_UNKNOWN_ADMIN_MSG_TYPE     -30
#define LOGEVNT_GET_COMPUTER_NAME_FAILED   -31
#define LOGEVNT_QSEND_FAILED			   -32
#define LOGEVNT_PROCESS_RULE_STATUS_STOP   -33
#define LOGEVNT_IDENTIFIED_COM_EXCEPTION   -900
#define LOGEVNT_UNIDENTIFIED_EXCEPTION     -901

#define LOGEVNT_TRIGGER_HAS_NO_RULES      -1
#define LOGEVNT_RULE_INDEX_INVALID        -2
#define LOGEVNT_INVALID_ARG               -3
#define LOGEVNT_ADDTRIGGER_FAILED         -4
#define LOGEVNT_ADDRULE_FAILED            -5
#define LOGEVNT_DELETETRIGGER_FAILED      -5
#define LOGEVNT_GETTRIGGER_FAILED         -6
#define LOGEVNT_CREATE_RS_FAILED          -8
#define LOGEVNT_QGETPATHNAME_FAILED       -9
#define LOGEVNT_REFRESH_FAILED            -10
#define LOGEVNT_USETRIGGERMAP_FAILED      -11
#define LOGEVNT_PARSE_ACTION_FAILED       -12
#define LOGEVNT_PARSE_CONDITION_FAILED    -13
#define LOGEVNT_ACTION_FAILED             -14
#define LOGEVNT_INVOKECOM_FAILED          -15
#define LOGEVNT_CONDITION_EVAL_FAILED     -16

#define LOGEVNT_REFRESH_RULESET_FAILED    -18
#define LOGEVNT_DETACH_RULES              -19
#define LOGEVNT_UPDATETRIGGER_FAILED      -20
#define LOGEVNT_DELETERULE_FAILED         -21
#define LOGEVNT_GET_RULEDETAILS_FAILED    -22 
#define LOGEVNT_GET_COUNT_FAILED          -23
#define LOGEVNT_RULE_REFRESH_FAILED       -24
#define LOGEVNT_MEMALLOC_FAILED           -23

#define LOGEVNT_INVOKEEXE_FAILED          -26
#define LOGEVNT_CONNECT_REGISTRY_FAILED   -27
#define LOGEVNT_LOAD_RULE_FAILED          -28
#define LOGEVNT_DELETE_RULE_FAILED        -29
#define LOGEVNT_LOAD_TRIGGER_FAILED       -30
#define LOGEVNT_LOAD_TRIGGERRULE_FAILED   -31
#define LOGEVNT_DELETE_TRIGGER_FAILED     -32
#define LOGEVNT_DETACH_RULE_FAILED        -33



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\strparse.hpp ===
// CStringTokens.hpp: interface for the CStringTokens class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __STPARSE_H__
#define __STPARSE_H__

#pragma once


typedef std::list< std::wstring > TOKEN_LIST;


class CStringTokens  
{
public:
	CStringTokens();
	virtual ~CStringTokens();

	void Parse(const _bstr_t& bstrString, WCHAR delimiter);
	void GetToken(DWORD tokenIndex, _bstr_t& strToken);
	DWORD GetNumTokens();

private:
	TOKEN_LIST m_lstTokens;
};

#endif // __STPARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\queueutil.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Yifat Peled
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 4/07/99	| yifatp	| Initial Release
//
//*****************************************************************************
#pragma once

#ifndef _QUEUE_UTIL_H
#define _QUEUE_UTIL_H

//
// Opens the given queue .
// When indicated, if the queue does not exist and should be local - creates the queue
//
HRESULT 
OpenQueue(
	_bstr_t bstrQueuePath,
	DWORD dwAction,
	bool fCreateIfNotExist,
	QUEUEHANDLE* pQHandle,
	_bstr_t* pbstrFormatName
    );	


_bstr_t 
GetDirectQueueFormatName(
    _bstr_t bstrQueuePath
    );


bool 
IsQueueLocal(
    _bstr_t bstrQueuePath
    );


bool 
IsPrivateQPath(
    std::wstring wcsQPath
    );


SystemQueueIdentifier 
IsSystemQueue(
    _bstr_t QueueName
    );


HRESULT 
GenSystemQueueFormatName(
    SystemQueueIdentifier SystemQueue, 
    _bstr_t* pbstrFormatName
    );



#endif //_QUEUE_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\msmqtrigbld.h ===
//
// file: MSMQTrigbld.h
//
// Copyright (c) 1997-2000 Microsoft Corporation, All Rights Reserved
//

//
// This file is empty on all machines and should be out to the build machine only
// for specific build macro decleration
//

//#define MSMQTRIG_OFFICIAL_BUILD	// defined only on the official build machine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\triginfo.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CRuntimeTriggerInfo_INCLUDED 
#define CRuntimeTriggerInfo_INCLUDED

// Define the maximum lengths of the rule properties
#define MAX_TRIGGER_NAME_LEN        128
#define MAX_TRIGGER_QUEUE_NAME_LEN  255

// Define the names of the registry values that store the rule properties.
#define REGISTRY_TRIGGER_VALUE_NAME          _T("Name")
#define REGISTRY_TRIGGER_VALUE_QUEUE_NAME    _T("Queue")
#define REGISTRY_TRIGGER_VALUE_ENABLED       _T("Enabled")
#define REGISTRY_TRIGGER_VALUE_SERIALIZED    _T("Serialized")
#define REGKEY_TRIGGER_RULES                 _T("Rules")

// Define the key name (relative to REGKEY_TRIGGER_DATA above) where attached rule info is located.
#define REGKEY_TRIGGER_ATTACHED_RULES      _T("AttachedRules")

// Definition of a trigger rule structure
#include "RuleInfo.hpp"
#include "stddefs.hpp"

// Define a new type - a list of Runtime Rule Info
typedef std::list<CRuntimeRuleInfo*> RUNTIME_RULEINFO_LIST;

class CRuntimeTriggerInfo  
{

	friend class CMSMQTriggerSet;

	private:

		bool m_bAdminTrigger;
		MsgProcessingType m_msgProcType;

		TCHAR m_wzTriggerRegPath[MAX_REGKEY_NAME_SIZE];
		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

	protected:

		bool m_bEnabled;
		bool m_bSerialized;

	public:
		CRuntimeTriggerInfo(LPCTSTR pwzRegPath);
				
		CRuntimeTriggerInfo(
			const _bstr_t& bsTriggerID,
			BSTR bsTriggerName, 
			BSTR bsQueueName, 
			LPCTSTR pwzRegPath, 
			SystemQueueIdentifier SystemQueue, 
			bool bEnabled, 
			bool bSerialized,
			MsgProcessingType msgProcType
			);

		~CRuntimeTriggerInfo();

		// TODO : move to private
		_bstr_t m_bstrTriggerID;
		_bstr_t m_bstrTriggerName;
		_bstr_t m_bstrQueueName;
		_bstr_t m_bstrQueueFormatName;

		SystemQueueIdentifier m_SystemQueue;

		// A handle to the queue that the trigger is attached to.
		//HANDLE m_hQueueHandle;

		// A list of CRuntimeRuleInfo class instances.
		RUNTIME_RULEINFO_LIST m_lstRules;

		bool IsEnabled()         {return(m_bEnabled);}
		bool IsSerialized()      {return(m_bSerialized);} 
		bool IsAdminTrigger()    {return(m_bAdminTrigger);}
		long GetNumberOfRules()  {return numeric_cast<long>(m_lstRules.size());}
		
		MsgProcessingType GetMsgProcessingType() 
		{
			return m_msgProcType;
		}
		
		void SetMsgProcessingType(MsgProcessingType msgProcType)
		{
			m_msgProcType = msgProcType;
		}

		void SetAdminTrigger()
		{
			m_bAdminTrigger = true;
		}

		// Returns a reference to the CRuntimeRuleInfo instance at the specified index.
		CRuntimeRuleInfo * GetRule(long lIndex);
			
		// Used to determine if a rule is attached to a trigger.
		bool IsRuleAttached(BSTR sRuleID);

		// Used to determine if this represents a valid trigger
		bool IsValid();

		// Methods for managing the persistence trigger definitions.	
		bool Update(HKEY hRegistry);
		bool Create(HKEY hRegistry);
		bool Delete(HKEY hRegistry);
		HRESULT Retrieve(HKEY hRegistry,_bstr_t bstrRuleID);
		bool Attach(HKEY hRegistry, _bstr_t bstrRuleID,ULONG ulPriority);
		bool Detach(HKEY hRegistry, _bstr_t bstrRuleID);
		bool DetachAllRules(HKEY hRegistry);


		// Static validation methods.
		static bool IsValidTriggerID(_bstr_t bstrRuleID);
		static bool IsValidTriggerName(_bstr_t bstrRuleName);
		static bool IsValidTriggerQueueName(_bstr_t bstrRuleCondition);

    private:
		// Methods for building and clear the rules list.
		void BuildRulesList(HKEY hRegistry,_bstr_t &bstrTriggerID);
		void ClearRulesList();

		//used by attach/detach and detach all rules
		void FlushAttachedRulesToRegistry(const HKEY& hRegistry);
		
        // Used by create and update methods to flush values to registry.
		void FlushValuesToRegistry(const HKEY& hRegistry);

		HKEY GetTriggerKeyHandle( HKEY hRegistry, LPCTSTR triggerId );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\ruleinfo.hpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeRuleInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class encapsulates the information about a 
//               trigger rule. It is used to cache rule information
//               at runtime about triggers.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CRuntimeRuleInfo_INCLUDED 
#define CRuntimeRuleInfo_INCLUDED

#include "mqtg.h"

// Define the maximum lengths of the rule properties in characters.
#define MAX_RULE_ID_LEN          128
#define MAX_RULE_NAME_LEN        128
#define MAX_RULE_DESCRIPTION_LEN 255
#define MAX_RULE_PROGID_LEN      255
#define MAX_RULE_CONDITION_LEN   512
#define MAX_RULE_ACTION_LEN      512

// Define the names of the registry values that store the rule properties.
#define REGISTRY_RULE_VALUE_NAME					_T("Name")
#define REGISTRY_RULE_VALUE_IMP_PROGID				_T("ImplementationProgID")
#define REGISTRY_RULE_VALUE_CONDITION				_T("Condition")
#define REGISTRY_RULE_VALUE_ACTION					_T("Action")
#define REGISTRY_RULE_VALUE_DESCRIPTION				_T("Description")
#define REGISTRY_RULE_VALUE_SHOW_WINDOW	        	_T("ShowWindow")

class CRuntimeRuleInfo  
{
	friend class CMSMQRuleSet;

	private:
		HKEY GetRuleKeyHandle( HKEY hRegistry, LPCTSTR ruleId );


	public:
		CRuntimeRuleInfo( LPCTSTR pwzRegPath );
		
		CRuntimeRuleInfo(
				const _bstr_t& bsRuleID, 
				BSTR bsRuleName,
				BSTR bsDescription,
				BSTR bsRuleCondition,
				BSTR bsRuleAction, 
				BSTR bsRuleImplementationProgID,
				LPCTSTR pwzRegPath,
				bool fShowWindow );

		~CRuntimeRuleInfo();

		_bstr_t m_bstrRuleID;
		_bstr_t m_bstrRuleName;
		_bstr_t m_bstrRuleDescription;
		_bstr_t m_bstrImplementationProgID;
		_bstr_t m_bstrAction;
		_bstr_t m_bstrCondition;

		TCHAR m_wzRuleRegPath[MAX_REGKEY_NAME_SIZE];

		bool	m_fShowWindow;

		// This is a reference count of how many triggers currently use this rule. 
		// It is NOT a dynamic reference count against this class instance. 
		//DWORD m_dwTriggerRefCount;

		// Declare an instance of the default (MS) rule handler
		CComPtr<IUnknown> m_MSMQRuleHandler;

		// Used to determine if this represents a valid rule
		bool IsValid();

		// Methods for managing the persistence of rule definitions.	
		bool Update(HKEY hRegistry);
		bool Create(HKEY hRegistry);
		bool Delete(HKEY hRegistry);
		bool Retrieve(HKEY hRegistry,_bstr_t bstrRuleID);

		// methods used to increment and decrement the reference count on this rule
		//inline DWORD GetRefCount() { return m_dwTriggerRefCount; };
		//inline DWORD IncrementRefCount() { return ++m_dwTriggerRefCount; };
		//inline DWORD DecrementRefCount() { return --m_dwTriggerRefCount; };

		// Used by create and update methods to flush values to registry.
		void FlushValuesToRegistry(const HKEY& hRuleKey);

		// Static validation methods.
		static bool IsValidRuleID(_bstr_t bstrRuleID);
		static bool IsValidRuleName(_bstr_t bstrRuleName);
		static bool IsValidRuleDescription(_bstr_t bstrRuleDescription);
		static bool IsValidRuleCondition(_bstr_t bstrRuleCondition);
		static bool IsValidRuleAction(_bstr_t bstrRuleAction);
		static bool IsValidRuleProgID(_bstr_t bstrRuleProgID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\stddefs.hpp ===
//*****************************************************************************
//
// File  Name  : stddefs.hpp
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This file contains definitions of constants that are shared 
//               throughout the MSMQ triggers projects and components.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/05/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef STDDEFS_INCLUDED 
#define STDDEFS_INCLUDED

// Define maximum Triggers service name length
#define MAX_TRIGGERS_SERVICE_NAME  200

//
// Define the message labels that will be used in administrative messages.
//
#define MSGLABEL_TRIGGERADDED           _T("MSMQTriggerNotification:TriggerAdded")
#define MSGLABEL_TRIGGERUPDATED         _T("MSMQTriggerNotification:TriggerUpdated")
#define MSGLABEL_TRIGGERDELETED         _T("MSMQTriggerNotification:TriggerDeleted")
#define MSGLABEL_RULEADDED              _T("MSMQTriggerNotification:RuleAdded")
#define MSGLABEL_RULEUPDATED            _T("MSMQTriggerNotification:RuleUpdated")
#define MSGLABEL_RULEDELETED            _T("MSMQTriggerNotification:RuleDeleted")
//
// Define the property names that are passed into the MSMQRuleHandler interface 
// via the MSMQPropertyBag COM component. These definitions are used by both the
// trigger service and the COM dll that implements the default IMSMQRuleHandler 
// interface. Note that these are defined as _bstr_t objects to facilitate string
// comparisons. 
//
const static _bstr_t gc_bstrPropertyName_Label = _T("Label");
const static _bstr_t gc_bstrPropertyName_MsgID = _T("MessageID");
const static _bstr_t gc_bstrPropertyName_MsgBody = _T("MessageBody");
const static _bstr_t gc_bstrPropertyName_MsgBodyType = _T("MessageBodyType");
const static _bstr_t gc_bstrPropertyName_CorID = _T("CorrelationID");
const static _bstr_t gc_bstrPropertyName_MsgPriority = _T("MessagePriority");
const static _bstr_t gc_bstrPropertyName_QueuePathname = _T("QueueNamePathname"); 
const static _bstr_t gc_bstrPropertyName_QueueFormatname = _T("QueueNameFormatname"); 
const static _bstr_t gc_bstrPropertyName_TriggerName = _T("TriggerName"); 
const static _bstr_t gc_bstrPropertyName_TriggerID = _T("TriggerID"); 
const static _bstr_t gc_bstrPropertyName_ResponseQueueName = _T("ResponseQueueName"); 
const static _bstr_t gc_bstrPropertyName_ResponseQueueNameLen = _T("ResponseQueueNameLen"); 
const static _bstr_t gc_bstrPropertyName_AdminQueueName = _T("AdminQueueName"); 
const static _bstr_t gc_bstrPropertyName_AdminQueueNameLen = _T("AdminQueueNameLen"); 
const static _bstr_t gc_bstrPropertyName_AppSpecific = _T("AppSpecific"); 
const static _bstr_t gc_bstrPropertyName_DeliveryStyle = _T("DeliveryStyle"); 
const static _bstr_t gc_bstrPropertyName_SentTime = _T("SentTime"); 
const static _bstr_t gc_bstrPropertyName_ArrivedTime = _T("ArrivedTime");
const static _bstr_t gc_bstrPropertyName_MessageClass = _T("MessageClass"); 
const static _bstr_t gc_bstrPropertyName_MaxTimeToReachQueue = _T("MaxTimeToReachQueue"); 
const static _bstr_t gc_bstrPropertyName_MaxTimeToReceive = _T("MaxTimeToReceive"); 
const static _bstr_t gc_bstrPropertyName_JournalStyle = _T("JournalStyle"); 
const static _bstr_t gc_bstrPropertyName_SenderID = _T("SenderID"); 
const static _bstr_t gc_bstrPropertyName_SrcMachineId = _T("SrcMachineId"); 
const static _bstr_t gc_bstrPropertyName_LookupId = _T("LookupId");

//
// Define the bstr's used to denote a conditional test
//
const static _bstr_t gc_bstrConditionTag_MsgLabelContains =   _T("$MSG_LABEL_CONTAINS");
const static _bstr_t gc_bstrConditionTag_MsgLabelDoesNotContain =   _T("$MSG_LABEL_DOES_NOT_CONTAIN");

const static _bstr_t gc_bstrConditionTag_MsgBodyContains =   _T("$MSG_BODY_CONTAINS");
const static _bstr_t gc_bstrConditionTag_MsgBodyDoesNotContain =   _T("$MSG_BODY_DOES_NOT_CONTAIN");

const static _bstr_t gc_bstrConditionTag_MsgPriorityEquals = _T("$MSG_PRIORITY_EQUALS");
const static _bstr_t gc_bstrConditionTag_MsgPriorityNotEqual = _T("$MSG_PRIORITY_NOT_EQUAL");
const static _bstr_t gc_bstrConditionTag_MsgPriorityGreaterThan = _T("$MSG_PRIORITY_GREATER_THAN");
const static _bstr_t gc_bstrConditionTag_MsgPriorityLessThan = _T("$MSG_PRIORITY_LESS_THAN");

const static _bstr_t gc_bstrConditionTag_MsgAppSpecificEquals = _T("$MSG_APPSPECIFIC_EQUALS");
const static _bstr_t gc_bstrConditionTag_MsgAppSpecificNotEqual = _T("$MSG_APPSPECIFIC_NOT_EQUAL");
const static _bstr_t gc_bstrConditionTag_MsgAppSpecificGreaterThan = _T("$MSG_APPSPECIFIC_GREATER_THAN");
const static _bstr_t gc_bstrConditionTag_MsgAppSpecificLessThan = _T("$MSG_APPSPECIFIC_LESS_THAN");

const static _bstr_t gc_bstrConditionTag_MsgSrcMachineIdEquals = _T("$MSG_SRCMACHINEID_EQUALS");
const static _bstr_t gc_bstrConditionTag_MsgSrcMachineIdNotEqual = _T("$MSG_SRCMACHINEID_NOT_EQUAL");


#define ACTION_EXECUTABLETYPE_ORDINAL  0
#define ACTION_COMPROGID_ORDINAL       1
#define ACTION_COMMETHODNAME_ORDINAL   2
#define ACTION_EXE_NAME                1


//
// Define the bstrs that represents message and / or trigger attributes
//
const static _bstr_t gc_bstrPARM_MSG_ID							= _T("$MSG_ID");
const static _bstr_t gc_bstrPARM_MSG_LABEL						= _T("$MSG_LABEL");
const static _bstr_t gc_bstrPARM_MSG_BODY						= _T("$MSG_BODY");
const static _bstr_t gc_bstrPARM_MSG_BODY_AS_STRING				= _T("$MSG_BODY_AS_STRING");
const static _bstr_t gc_bstrPARM_MSG_PRIORITY					= _T("$MSG_PRIORITY");
const static _bstr_t gc_bstrPARM_MSG_ARRIVEDTIME				= _T("$MSG_ARRIVEDTIME");
const static _bstr_t gc_bstrPARM_MSG_SENTTIME					= _T("$MSG_SENTTIME");
const static _bstr_t gc_bstrPARM_MSG_CORRELATION_ID				= _T("$MSG_CORRELATION_ID");
const static _bstr_t gc_bstrPARM_MSG_APPSPECIFIC				= _T("$MSG_APPSPECIFIC");
const static _bstr_t gc_bstrPARM_MSG_QUEUE_PATHNAME				= _T("$MSG_QUEUE_PATHNAME");
const static _bstr_t gc_bstrPARM_MSG_QUEUE_FORMATNAME			= _T("$MSG_QUEUE_FORMATNAME");
const static _bstr_t gc_bstrPARM_MSG_RESPQUEUE_FORMATNAME		= _T("$MSG_RESPONSE_QUEUE_FORMATNAME");
const static _bstr_t gc_bstrPARM_MSG_DESTQUEUE_FORMATNAME		= _T("$MSG_DEST_QUEUE_FORMATNAME");
const static _bstr_t gc_bstrPARM_MSG_ADMINQUEUE_FORMATNAME		= _T("$MSG_ADMIN_QUEUE_FORMATNAME");
const static _bstr_t gc_bstrPARM_MSG_SRCMACHINEID				= _T("$MSG_SRCMACHINEID");
const static _bstr_t gc_bstrPARM_MSG_LOOKUPID    				= _T("$MSG_LOOKUP_ID");

const static _bstr_t gc_bstrPARM_TRIGGER_NAME              = _T("$TRIGGER_NAME");
const static _bstr_t gc_bstrPARM_TRIGGER_ID                = _T("$TRIGGER_ID");


const static _bstr_t gc_bstrNotificationsQueueName	= _T("\\PRIVATE$\\MSMQTriggersNotifications");
const static _bstr_t gc_bstrNotificationsQueueLabel = _T("MSMQ Trigger Notifications");

const static _bstr_t gc_PauseResmueEvent = _T("MSMQTriggerService Paused Resume Event");

const static _bstr_t gc_bstrTrigObjsDll = _T("mqtrig.dll");
const static _bstr_t gc_bstrRegistryKeyPath_EventLog = _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\include\stdfuncs.hpp ===
//*****************************************************************************
//
// File Name   : stdfuncs.h
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This file contains standard macros and utility functions
//               that are shared accross the MSMQ triggers projects.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __stdfuncs__
#define __stdfuncs__

#include <time.h>

// Debug only exception handling.
#ifdef _DEBUG
	#define DEBUG_TRY          try {
	#define DEBUG_CATCH_ALL    }catch(...){
	#define DEBUG_CATCH_END    }
#else
	#define DEBUG_TRY       
	#define DEBUG_CATCH_ALL     
	#define DEBUG_CATCH_END     
#endif

// registry key values into. 
#define REGKEY_STRING_BUFFER_SIZE 128 * sizeof(TCHAR)

// Define the maximum size of a registry key (255 Unicode chars + null)
#define MAX_REGKEY_NAME_SIZE       512


// Customized trace definitions - allow super long trace messages to the debug window.

#define TRACE_MSG_BUFFER_SIZE 256

#define STRING_MSG_BUFFER_SIZE 256

// Function prototypes for globally available function
void _cdecl FormatBSTR(_bstr_t * pbstrString, LPCTSTR lpszMsgFormat, ...);
void GetTimeAsBSTR(_bstr_t& bstrTime);
void ObjectIDToString(const OBJECTID *pID, WCHAR *wcsResult, DWORD dwSize);

_bstr_t CreateGuidAsString(void);
HRESULT ConvertFromByteArrayToString(VARIANT * pvData);
HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime);
bool GetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD * pdwValue,DWORD dwDefaultValue);
long SetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD dwValue);
bool UpdateMachineNameInQueuePath(_bstr_t bstrOldQPath, _bstr_t MachineName, _bstr_t* pbstrNewQPath);
DWORD GetLocalMachineName(_bstr_t* pbstrMachine);


#endif // __stdfuncs_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\mqgenobj.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    mqgenobj.cpp

Abstract:
    Transactional Object for Rules processing

Author:
    Nela Karpel (nelak) 28-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "Mqgentr.h"
#include "mqgenobj.h"
#include <autorel.h>
#include <mqexception.h>
#include "mqtg.h"

#import "mqoa.tlb" no_namespace


static
IMSMQQueue3Ptr 
OpenQueue(
    LPCWSTR queueFormatName,
    long access,
    long deny
    )
{
    IMSMQQueueInfo3Ptr qinfo(L"MSMQ.MSMQQueueInfo");

    _bstr_t qpn(const_cast<LPWSTR>(queueFormatName));
    qinfo->put_FormatName(qpn);

    return qinfo->Open(access, deny);
}


static
void
ReceiveMsgInTransaction(
	IMSMQPropertyBagPtr	pPropBag
	)
{
	HRESULT hr = S_OK;

	_variant_t queueFormatName;
	hr = pPropBag->Read(gc_bstrPropertyName_QueueFormatname, &queueFormatName);
	ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

    IMSMQQueue3Ptr q = OpenQueue(queueFormatName.bstrVal, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);

	_variant_t lookupId;
	hr = pPropBag->Read(gc_bstrPropertyName_LookupId, &lookupId);
	ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

	//
	// To use current MTS transaction context is the 
	// default for Receive()
	//
    q->ReceiveByLookupId(lookupId);

}


static
CRuntimeTriggerInfo*
GetTriggerInfo(
	BSTR bstrTrigID,
	BSTR bstrRegPath
	)
{
	//
	// Connect to registry in order to retrieve trigger details
	//
	CAutoCloseRegHandle hHostRegistry;
	LONG lRes = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHostRegistry);

	if ( lRes != ERROR_SUCCESS )
	{
		ATLTRACE("Failed to connect to registry.\n");
		throw bad_win32_error(lRes);
	}

	//
	// Build the Trigger Info object
	//
	P<CRuntimeTriggerInfo> pTriggerInfo = new CRuntimeTriggerInfo(bstrRegPath);

	HRESULT hr = pTriggerInfo->Retrieve(hHostRegistry, bstrTrigID);
	if (FAILED(hr))
	{
		ATLTRACE("Failed to retreive trigger info from registry.\n");
		throw _com_error(E_FAIL);
	}

	return pTriggerInfo.detach();
}


//
// CMqGenObj Implementation
//
CMqGenObj::CMqGenObj()
{
	HRESULT hr = CoGetObjectContext(IID_IObjectContext, reinterpret_cast<LPVOID*>(&m_pObjContext));

	if ( FAILED(hr) )
	{
		ATLTRACE("Failed to get Object Context.\n");
		throw _com_error(hr);
	}

	if (!m_pObjContext->IsInTransaction())
	{
		ATLTRACE("Transactional object not in transaction.\n");
		throw _com_error(E_FAIL);
	}	
}


VOID
CMqGenObj::AbortTransaction()
{
	m_pObjContext->SetAbort();
}


STDMETHODIMP 
CMqGenObj::InvokeTransactionalRuleHandlers(
	BSTR bstrTrigID, 
	BSTR bstrRegPath, 
	IUnknown *pPropBagUnknown,
    DWORD dwRuleResult
	)
{	
	IMSMQRuleHandlerPtr pMSQMRuleHandler;
	IMSMQPropertyBagPtr pIPropertyBag(pPropBagUnknown);

	try
	{
		HRESULT hr;
		
		//
		// Retrieve Trigger info
		//
		P<CRuntimeTriggerInfo> pTriggerInfo = GetTriggerInfo(bstrTrigID, bstrRegPath);

		//
		// Create instance of Rule Handler
		//
		hr = pMSQMRuleHandler.CreateInstance(_T("MSMQTriggerObjects.MSMQRuleHandler")); 

		if ( FAILED(hr) )
		{
			ATLTRACE("Failed to create MSMQRuleHandler instance.\n");
			throw bad_hresult(hr);
		}

		//
		// Start rule processing
		//
        DWORD dwRuleIndex=1;
		for (LONG lRuleCtr=0; lRuleCtr < pTriggerInfo->GetNumberOfRules(); lRuleCtr++)
		{
            //
            //for first 32 rules: if corresponding bit in the dwRuleResult is off
            //rule condition is not satisfied
            // we can start checking next rule
            //
            if((lRuleCtr < 32) && ((dwRuleResult & dwRuleIndex) == 0))
            {
                dwRuleIndex<<=1;
                continue;
            }
            dwRuleIndex<<=1;
			CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
			ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

			// Test if we have an instance of the MSMQRuleHandler - and if not, create one
			if (!pRule->m_MSMQRuleHandler) 
			{
				// Create the interface
				// Copy the local pointer to the rule store.
				pRule->m_MSMQRuleHandler = pMSQMRuleHandler;
				
				// Initialise the MSMQRuleHandling object.
				pMSQMRuleHandler->Init(
									pRule->m_bstrRuleID,
									pRule->m_bstrCondition,
									pRule->m_bstrAction,
									(BOOL)(pRule->m_fShowWindow) 
									);
			}
			else
			{
				// Get a reference to the existing copy.
				pMSQMRuleHandler = pRule->m_MSMQRuleHandler;
			}

			// Initialize the rule result code. 
			long lRuleResult = 0;

			// trace message to determine what rule are firing and in what order.
			ATLTRACE(L"InvokeMSMQRuleHandlers() is about to call ExecuteRule() on the IMSMQRuleHandler interface for rule (%d) named (%s)\n",(long)lRuleCtr,(wchar_t*)pRule->m_bstrRuleName);

			DWORD dwRuleExecStartTime = GetTickCount();

		
			//
			// !!! This is the point at which the IMSMQRuleHandler component is invoked.
			// Note: fQueueSerialized ( 3rd parameter ) is always true - 
			// wait for completion of every action
			//
            long bConditionSatisfied = true;
            
            //
            //for rule numbers > 32 we have no bitmask
            //have to check if condidtion satisfied before call to ExecuteRule
            //
            if(lRuleCtr > 32)           
            {
                pMSQMRuleHandler->CheckRuleCondition(
								pIPropertyBag.GetInterfacePtr(), 
								&bConditionSatisfied);		
            }

            if(bConditionSatisfied) // always true for lRuleCtr < 32
            {
                pMSQMRuleHandler->ExecuteRule(
								pIPropertyBag.GetInterfacePtr(), 
                                TRUE,
								&lRuleResult);		
            }
        
			DWORD dwRuleExecTotalTime = GetTickCount() - dwRuleExecStartTime;

			//
			// Trace message to show the result of the rule firing
			//
			ATLTRACE(L"InvokeMSMQRuleHandlers() has completed the call to ExecuteRule() on the IMSMQRuleHandler interface for rule (%d) named (%s). The rule result code returned was (%d).The time taken in milliseconds was (%d).\n",(long)lRuleCtr,(wchar_t*)pRule->m_bstrRuleName,(long)lRuleResult,(long)dwRuleExecTotalTime);
			

			// if processing the rule result fails, we do not want to process
			// any more rules attached to this trigger. Hence we will break out of 
			// this rule processing loop. 
			//
			if ( lRuleResult & xRuleResultActionExecutedFailed  )
			{
				AbortTransaction();
				return E_FAIL;
			}
			
	
			if(lRuleResult & xRuleResultStopProcessing)
			{
				ATLTRACE(L"Last processed rule (%s) indicated to stop rules processing on Trigger (%s). No further rules will be processed for this message.\n",(LPCTSTR)pRule->m_bstrRuleName,(LPCTSTR)pTriggerInfo->m_bstrTriggerName);						

				//
				// If no one aborted the transaction, it will be commited
				//
				break;
			}
		} // end of rule processing loop

		//
		// Perform Transactional Receive
		//
		ReceiveMsgInTransaction(pIPropertyBag);
		return S_OK;
	}
	catch(const _com_error& e)
	{
		ATLTRACE("InvokeMSMQRuleHandlers() has caught COM exception. Error: %d\n", e.Error());
		AbortTransaction();
		return e.Error();
	}
	catch(const bad_alloc&)
	{
		ATLTRACE("Not enough memory to allocate resources\n");
		AbortTransaction();
		return ERROR_NO_SYSTEM_RESOURCES;	
	}
	catch(const bad_hresult& b)
	{
		ATLTRACE("Bad HRESULT %d\n", b.error());
		AbortTransaction();
		return b.error();
	}
	catch(const bad_win32_error& b)
	{
		ATLTRACE("Windows error %d\n", b.error());
		AbortTransaction();
		return b.error();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\mqgentr_i_.c ===
#include <mqgentr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\mqgenobj.h ===
// mqgenobj.h : Declaration of the CMqGenObj

#ifndef __MQGENOBJ_H_
#define __MQGENOBJ_H_

#include "resource.h"       // main symbols
#include "triginfo.hpp"
#include <comsvcs.h>

/////////////////////////////////////////////////////////////////////////////
// CMqGenObj
class ATL_NO_VTABLE CMqGenObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMqGenObj, &CLSID_MqGenObj>,
	public IDispatchImpl<IMqGenObj, &IID_IMqGenObj, &LIBID_MQGENTRLib>
{
public:

	CMqGenObj();
	
private:
	VOID GetMyContext();

	VOID AbortTransaction();

// IMqGenObj
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MQGENOBJ)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMqGenObj)
	COM_INTERFACE_ENTRY(IMqGenObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	STDMETHOD(InvokeTransactionalRuleHandlers)(BSTR bstrTrigID, BSTR bstrRegPath, IUnknown *pPropBagUnknown, DWORD dwRuleResult);

private:
	R<IObjectContext> m_pObjContext;
};

#endif //__MQGENOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqgentr.rc
//
#define IDR_MQGENOBJ                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\mqgentr.cpp ===
// mqgentr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mqgentrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "mqgentr.h"
#include "mqgenobj.h"
#include "cm.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MqGenObj, CMqGenObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MQGENTRLib);
        DisableThreadLibraryCalls(hInstance);

		CmInitialize(HKEY_LOCAL_MACHINE, L"");
		TrInitialize();

		TrRegisterComponent(xTriggerObjectsComponent, TABLE_SIZE(xTriggerObjectsComponent));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\mqgentr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#ifndef _MQGENTR_H_
#define _MQGENTR_H_


#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

const TraceIdEntry Tgu = L"Trigger Utilities";
const TraceIdEntry Tgo = L"Trigger Objects";
const TraceIdEntry Tgt = L"Trigger Test";

const TraceIdEntry xTriggerObjectsComponent[] = {Tgu, Tgo, Tgt};


#include "mqtrig.tlh"



#endif // _MQGENTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\actionstest\actionstest.cpp ===
// ActionsTest.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ActionsTestps.mk in the project directory.

#include "stdafx.h"

#include "resource.h"
#include <initguid.h>
#include "ActionsTest.h"
#include "ActionTest.h"

#include "ActionsTest_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ActionTest, CActionTest)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ACTIONSTESTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\actionstest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ActionsTest.rc
//
#define IDR_ACTIONTEST                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\actionstest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED_)
#define AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED_

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\actionstest\actiontest.cpp ===
// ActionTest.cpp : Implementation of CActionTest
#include "stdafx.h"
#include "ActionsTest.h"
#include "ActionTest.h"
#include "stdfuncs.hpp"

/////////////////////////////////////////////////////////////////////////////
// CActionTest

STDMETHODIMP CActionTest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IActionTest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CActionTest::CActionTest()
{
}

CActionTest::~CActionTest()
{
	MQCloseQueue(m_hQ);
}




STDMETHODIMP CActionTest::MessageParams(VARIANT MsgID, BSTR MsgLabel, VARIANT MsgBodyAsVar, BSTR MsgBodyAsString, long Priority, VARIANT MsgCorlID, BSTR QueuePath, BSTR QueueFormat, BSTR ResponseQ, BSTR AdminQ, long AppSpecific, DATE SentTime,DATE ArrivedTime, BSTR SrcMachine, BSTR TriggerName, BSTR TriggerID, BSTR LiteralString, long Number)
{
	try
	{
		HRESULT hr = S_OK;

		_bstr_t FileName = LiteralString;
		
		WCHAR wcsBuf[512];
		wsprintf(wcsBuf, L"%d", Number);

		FileName += wcsBuf;
		FileName += L".txt";

		m_wofsFile.open((char*)FileName, ios_base::out | ios_base::app);


		if(!ComparePathName2FormatName(QueuePath, QueueFormat))
		{
			m_wofsFile << L"FAILED: PathName and FormatName parameters don't match"	<<endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"Queue PathName and FormatName passed successfully. (they match)" <<endl;
	
		hr = ReadMessageFromQueue(QueueFormat);	
		if(hr != S_OK)
			return hr;
			
		//check message Id 
		wstring wcsMsgIdFromTrigger;
		wstring wcsMsgIdFromMessage;

		hr = OBJECTIDVar2String(MsgID, wcsMsgIdFromTrigger);
		if(FAILED(hr))
			return hr;

		hr = OBJECTID2String((OBJECTID*)(m_MsgProps.aPropVar[MSG_ID].caub.pElems), wcsMsgIdFromMessage);
		if(FAILED(hr))
			return hr;

        //
        // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
        //
		if(! (wcsMsgIdFromTrigger == wcsMsgIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg Id param is diffrent, either different message in queue or passed corrupted" << endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"MsgId parameter was passed successfully"<<endl;
		

		//check messag label
		if( (MsgLabel == NULL && m_MsgProps.aPropVar[MSG_LABEL].pwszVal != NULL) ||
			(MsgLabel != NULL && m_MsgProps.aPropVar[MSG_LABEL].pwszVal == NULL) ||
			(_bstr_t(MsgLabel) != _bstr_t(m_MsgProps.aPropVar[MSG_LABEL].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg Label param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"MsgLabel parameter was passed successfully"<<endl;

		//check priority
		if(Priority != m_MsgProps.aPropVar[MSG_PRIORITY].bVal)
		{
			m_wofsFile << L"FAILED: Msg Priority param is different." << endl;
			return S_FALSE;	
		}

		m_wofsFile << L"MsgPriority parameter was passed successfully"<<endl;

		//check AppSpecific
		if(numeric_cast<DWORD>(AppSpecific) != m_MsgProps.aPropVar[MSG_APP_SPECIFIC].ulVal)
		{
			m_wofsFile << L"FAILED: Msg AppSpecific param is different." << endl;
			return S_FALSE;	
		}

		m_wofsFile << L"MsgAppSpecific parameter was passed successfully"<<endl;


		//check response queue
		if( (ResponseQ == NULL && m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal != NULL) ||
			(ResponseQ != NULL && m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal == NULL) ||
			(_bstr_t(ResponseQ) != _bstr_t(m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg ResponseQ param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg ResponseQ parameter was passed successfully"<<endl;


		//check admin queue
		if( (AdminQ == NULL && m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal != NULL) ||
			(AdminQ != NULL && m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal == NULL) ||
			(_bstr_t(AdminQ) != _bstr_t(m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg AdminQ param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg AdminQ parameter was passed successfully"<<endl;


		//check correlation Id 
		wstring wcsCorrIdFromTrigger;
		wstring wcsCorrIdFromMessage;

		hr = OBJECTIDVar2String(MsgCorlID, wcsCorrIdFromTrigger);
		if(FAILED(hr))
			return hr;

		hr = OBJECTID2String((OBJECTID*)(m_MsgProps.aPropVar[MSG_CORRID].caub.pElems), wcsCorrIdFromMessage);
		if(FAILED(hr))
			return hr;

        //
        // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
        //
		if(!(wcsCorrIdFromTrigger == wcsCorrIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg Corr param is diffrent" << endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"Msg correlation parameter was passed successfully"<<endl;
		

		//check sent time
		{
			VARIANT vtDate;
			VariantInit(&vtDate);
			vtDate.vt = VT_DATE;
			vtDate.date = SentTime;

			_bstr_t bstrSentTimeFromTriggers = (_bstr_t)(_variant_t(vtDate));

			VARIANT vSentTime;
			VariantInit(&vSentTime);

			GetVariantTimeOfTime(m_aVariant[MSG_SENT_TIME].ulVal, &vSentTime);

			_bstr_t bstrSentTimeFromMessage = (_bstr_t)(_variant_t(vSentTime));

			if(bstrSentTimeFromTriggers != bstrSentTimeFromMessage)
			{
				m_wofsFile << L"FAILED: Msg SentTime param is diffrent" << endl;
				return S_FALSE;
			}
			
			m_wofsFile << L"Msg SentTime parameter was passed successfully"<<endl;
		}

		{

			//check arrived time
			VARIANT vtDate;
			VariantInit(&vtDate);
			vtDate.vt = VT_DATE;
			vtDate.date = ArrivedTime;

			_bstr_t bstrArrivedTimeFromTriggers = (_bstr_t)(_variant_t(vtDate));

			VARIANT vArrivedTime;
			VariantInit(&vArrivedTime);

			GetVariantTimeOfTime(m_aVariant[MSG_ARRIVED_TIME].ulVal, &vArrivedTime);

			_bstr_t bstrArrivedTimeFromMessage = (_bstr_t)(_variant_t(vArrivedTime));

			if(bstrArrivedTimeFromTriggers != bstrArrivedTimeFromMessage)
			{
				m_wofsFile << L"FAILED: Msg ArrivedTime param is diffrent" << endl;
				return S_FALSE;
			}
			
			m_wofsFile << L"Msg ArrivedTime parameter was passed successfully"<<endl;
		}

		
		//check src machine id param
		wstring wcsSrcMachineIdFromMessage;

		hr = GUID2String(m_aVariant[MSG_SRC_MACHINE_ID].puuid, wcsSrcMachineIdFromMessage);
		if(FAILED(hr))
			return hr;
		
		wstring wcsSrcMachineFromTriggers = (SrcMachine == NULL) ? L"" : (WCHAR*)_bstr_t(SrcMachine);
		if(SrcMachine == NULL ||
            //
            // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
            //
			!(wcsSrcMachineFromTriggers == wcsSrcMachineIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg src machine id different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg src machine id parameter was passed successfully"<<endl;

		//check body as variant
		if( (MsgBodyAsVar.vt == VT_EMPTY && m_MsgProps.aPropVar[MSG_BODY].caub.pElems!= NULL) ||
			(MsgBodyAsVar.vt != VT_EMPTY && m_MsgProps.aPropVar[MSG_BODY].caub.pElems == NULL) )
		{
			m_wofsFile << L"FAILED: Msg body as variant different." << endl;
			return S_FALSE;	
		}

		bool fEq = CompareVar2ByteArray(MsgBodyAsVar, m_MsgProps.aPropVar[MSG_BODY].caub.pElems, m_MsgProps.aPropVar[MSG_BODY].caub.cElems);  
		if(!fEq)
		{
			m_wofsFile << L"FAILED: Msg body as variant different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg body as variant parameter was passed successfully"<<endl;

		if( (MsgBodyAsString == NULL && m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal == VT_BSTR) ||
			(MsgBodyAsString != NULL && m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal != VT_BSTR) )
		{
			m_wofsFile << L"FAILED: Msg body as string different." << endl;
			return S_FALSE;	
		}

		//check body as string
		if(m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal == VT_BSTR)
		{
			_bstr_t bstrBodyFromTriggers(MsgBodyAsString);
			_bstr_t bstrBodyFromMessage;

			WCHAR* pwcs = new WCHAR[(m_MsgProps.aPropVar[MSG_BODY].caub.cElems)/sizeof(WCHAR) + 1];
			memcpy((void*)pwcs, m_MsgProps.aPropVar[MSG_BODY].caub.pElems, m_MsgProps.aPropVar[MSG_BODY].caub.cElems);
			pwcs[(m_MsgProps.aPropVar[MSG_BODY].caub.cElems)/sizeof(WCHAR)] = L'\0';
						
			bstrBodyFromMessage = pwcs;
			delete pwcs;
				
			if(bstrBodyFromTriggers != bstrBodyFromMessage)
			{
				m_wofsFile << L"FAILED: Msg body as string different." << endl;
				return S_FALSE;	
			}
			
			m_wofsFile << L"Msg body as string parameter was passed successfully"<<endl;

			
			//check TriggerName and Id
			wstring Body = (WCHAR*)bstrBodyFromMessage;
			wstring::size_type pos = Body.find_first_of(L",");
			if(pos != wstring::npos)
			{
				wstring Name = Body.substr(0, pos);
				wstring Id = Body.substr(pos + 1, wstring::npos);

				wstring NameFromTriggers = (WCHAR*)_bstr_t(TriggerName);
				wstring IDFromTriggers = (WCHAR*)_bstr_t(TriggerID);

                //
                // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
                //
				if(!(Name == NameFromTriggers))
				{
					m_wofsFile << L"FAILED: Trigger Name wasn't passed correctly" << endl;
					return S_FALSE;	
				}

				m_wofsFile << L"Trigger Name was passed successfully"<<endl;

                //
                // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
                //
				if(!(Id == IDFromTriggers))
				{
					m_wofsFile << L"FAILED: Trigger ID wasn't passed correctly" << endl;
					return S_FALSE;	
				}
				
				m_wofsFile << L"Trigger ID was passed successfully"<<endl;
			}

		}
		
		m_wofsFile << endl << L"All message params were passed successfully. TEST PASSED"<<endl;
			
		return S_OK;
	}
	catch(const _com_error&)
	{
		return E_FAIL;
	}
}


bool CActionTest::ComparePathName2FormatName(_bstr_t PathName, _bstr_t FormatName)
{
	_bstr_t FormatNameAccordingToPathName;

	//check direct first
	FormatNameAccordingToPathName = L"DIRECT=OS:";
	FormatNameAccordingToPathName += PathName;

	if(!_wcsicmp((WCHAR*)FormatName, (WCHAR*)FormatNameAccordingToPathName))
	{
		return true;
	}
	
	//check by converting PathName to FormatName
	DWORD dwLen = wcslen((WCHAR*)FormatName) + 1;
	WCHAR* pFormatNameBuffer = new WCHAR[dwLen];
	
	
	HRESULT hr = MQPathNameToFormatName(
						(WCHAR*)PathName, 
						pFormatNameBuffer,
						&dwLen);
	
	if(FAILED(hr))
		return false;
		
	return (!_wcsicmp(FormatName, pFormatNameBuffer));	
}


HRESULT CActionTest::ReadMessageFromQueue(_bstr_t QueueFormat)
{
	
	HRESULT hr = MQOpenQueue(
						(WCHAR*)QueueFormat,
						MQ_RECEIVE_ACCESS,
						MQ_DENY_NONE,
						&m_hQ );

	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to open queue with format name "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	m_MsgProps.cProp = 0;
	m_MsgProps.aPropID = m_aPropId;
	m_MsgProps.aPropVar = m_aVariant;
	m_MsgProps.aStatus = NULL;

	m_aPropId[MSG_BODY_SIZE] = PROPID_M_BODY_SIZE;       
	m_aVariant[MSG_BODY_SIZE].vt = VT_UI4;                  
	m_aVariant[MSG_BODY_SIZE].ulVal = 0;

	m_MsgProps.cProp++;

	m_aPropId[MSG_LABEL_LEN] = PROPID_M_LABEL_LEN;
	m_aVariant[MSG_LABEL_LEN].vt = VT_UI4;       
	m_aVariant[MSG_LABEL_LEN].ulVal = 0; 

	m_MsgProps.cProp++;
	
	m_aPropId[MSG_RESPQ_NAME_LEN] = PROPID_M_RESP_QUEUE_LEN;  
	m_aVariant[MSG_RESPQ_NAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_RESPQ_NAME_LEN].ulVal = 0;    

	m_MsgProps.cProp++;

	m_aPropId[MSG_ADMINQ_NAME_LEN] = PROPID_M_ADMIN_QUEUE_LEN;  
	m_aVariant[MSG_ADMINQ_NAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_ADMINQ_NAME_LEN].ulVal = 0; 

	m_MsgProps.cProp++;

	
	//peek message len
	hr = MQReceiveMessage(
			m_hQ,
			0,
			MQ_ACTION_PEEK_CURRENT,
			&m_MsgProps,
			NULL,
			NULL,
			NULL, 
			NULL );

	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to peek at message from queue "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	DWORD dwBodySize = m_aVariant[MSG_BODY_SIZE].ulVal;
	DWORD dwLabelLen = m_aVariant[MSG_LABEL_LEN].ulVal;
	DWORD dwResponseQLen = m_aVariant[MSG_RESPQ_NAME_LEN].ulVal;
	DWORD dwAdminQLen = m_aVariant[MSG_ADMINQ_NAME_LEN].ulVal;

	m_MsgProps.cProp = MAX_ACTION_PROPS;

	m_aPropId[MSG_ID] = PROPID_M_MSGID;                   
	m_aVariant[MSG_ID].vt = VT_VECTOR | VT_UI1;           
	m_aVariant[MSG_ID].caub.cElems = MSG_ID_BUFFER_SIZE; 
	m_aVariant[MSG_ID].caub.pElems = new unsigned char[MSG_ID_BUFFER_SIZE]; 

	m_aPropId[MSG_LABEL] = PROPID_M_LABEL; 
	m_aVariant[MSG_LABEL].vt = VT_LPWSTR;
	m_aVariant[MSG_LABEL].pwszVal = (WCHAR*)new WCHAR[dwLabelLen];

	m_aPropId[MSG_BODY_TYPE] = PROPID_M_BODY_TYPE;       
	m_aVariant[MSG_BODY_TYPE].vt = VT_UI4;                  
	m_aVariant[MSG_BODY_TYPE].ulVal = 0; 
	
	m_aPropId[MSG_BODY] = PROPID_M_BODY;               
	m_aVariant[MSG_BODY].vt = VT_VECTOR|VT_UI1; 
	m_aVariant[MSG_BODY].caub.cElems = dwBodySize;  
	m_aVariant[MSG_BODY].caub.pElems = new unsigned char[dwBodySize]; 

	m_aPropId[MSG_PRIORITY] = PROPID_M_PRIORITY; 
	m_aVariant[MSG_PRIORITY].vt = VT_UI1;        
		
	m_aPropId[MSG_CORRID] = PROPID_M_CORRELATIONID;      
	m_aVariant[MSG_CORRID].vt = VT_VECTOR|VT_UI1;       
	m_aVariant[MSG_CORRID].caub.cElems = MSG_ID_BUFFER_SIZE; 
	m_aVariant[MSG_CORRID].caub.pElems = new unsigned char[MSG_ID_BUFFER_SIZE]; 

	m_aPropId[MSG_RESPONSEQ] = PROPID_M_RESP_QUEUE;    
	m_aVariant[MSG_RESPONSEQ].vt = VT_LPWSTR;          
	m_aVariant[MSG_RESPONSEQ].pwszVal = new WCHAR[dwResponseQLen];

	m_aPropId[MSG_ADMINQ] = PROPID_M_ADMIN_QUEUE;         
	m_aVariant[MSG_ADMINQ].vt = VT_LPWSTR;               
	m_aVariant[MSG_ADMINQ].pwszVal = new WCHAR[dwAdminQLen]; 

	m_aPropId[MSG_APP_SPECIFIC] = PROPID_M_APPSPECIFIC;       
	m_aVariant[MSG_APP_SPECIFIC].vt = VT_UI4;                  
	m_aVariant[MSG_APP_SPECIFIC].ulVal = 0;    

	m_aPropId[MSG_SENT_TIME] = PROPID_M_SENTTIME;       
	m_aVariant[MSG_SENT_TIME].vt = VT_UI4;                  
	m_aVariant[MSG_SENT_TIME].ulVal = 0; 

	m_aPropId[MSG_ARRIVED_TIME] = PROPID_M_ARRIVEDTIME;       
	m_aVariant[MSG_ARRIVED_TIME].vt = VT_UI4;                  
	m_aVariant[MSG_ARRIVED_TIME].ulVal = 0; 

	m_aPropId[MSG_SRC_MACHINE_ID] = PROPID_M_SRC_MACHINE_ID ;
	m_aVariant[MSG_SRC_MACHINE_ID].vt = VT_CLSID;
	m_aVariant[MSG_SRC_MACHINE_ID].puuid = new GUID;

	hr = MQReceiveMessage(m_hQ, 0, MQ_ACTION_RECEIVE, &m_MsgProps, NULL, NULL, NULL, NULL);
	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to receive message from queue "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	return S_OK;
}

HRESULT CActionTest::OBJECTIDVar2String(VARIANT& Val, wstring& wcsVal)
{
	BYTE obj[20];
	WCHAR* pwcs = NULL;
	memset(&obj, 0, sizeof(OBJECTID));

	long type = VT_ARRAY | VT_UI1;

	if(Val.vt == type)
	{
		long i, UBound;

		SafeArrayLock(Val.parray);
		SafeArrayGetUBound(Val.parray, 1, &UBound);
		for(i=0; i<UBound && i < 20;i++)
		{
			SafeArrayGetElement(Val.parray, &i, (void*)&(obj[i]));
		}
		SafeArrayUnlock(Val.parray);
		UuidToString(&(((OBJECTID*)obj)->Lineage), &pwcs);
		wcsVal = pwcs;
		RpcStringFree( &pwcs );

		WCHAR szI4[12];
		_ltow(((OBJECTID*)obj)->Uniquifier, szI4, 10);
	
		wcsVal += L"\\";
		wcsVal += szI4;

		return S_OK;
	}
		
	return E_FAIL;
}


HRESULT CActionTest::OBJECTID2String(OBJECTID* pObj, wstring& wcsVal)
{
	WCHAR* pwcs = NULL;

	RPC_STATUS status = UuidToString(&(pObj->Lineage), &pwcs);
	if(status != RPC_S_OK)
		return E_FAIL;
	wcsVal = pwcs;
	RpcStringFree( &pwcs );

	WCHAR szI4[12];
	_ltow(pObj->Uniquifier, szI4, 10);
	
	wcsVal += L"\\";
	wcsVal += szI4;

	return S_OK;
}


HRESULT CActionTest::GUID2String(GUID* pGuid, wstring& wcsVal)
{
	WCHAR* pwcs = NULL;

	RPC_STATUS status = UuidToString(pGuid, &pwcs);
	if(status != RPC_S_OK)
		return E_FAIL;
	wcsVal = pwcs;
	RpcStringFree( &pwcs );

	return S_OK;
}


bool CActionTest::CompareVar2ByteArray(VARIANT& Var, BYTE* pBuffer, DWORD Size)
{
	if(Var.vt != (VT_ARRAY | VT_UI1))
		return false;

	long UBound = 0;
	BYTE* pVarBuffer;
	SafeArrayLock(Var.parray);

	SafeArrayGetUBound(Var.parray, 1, &UBound);

	if(numeric_cast<DWORD>(UBound + 1) != Size) //starts from 0
		return false;

	SafeArrayAccessData(Var.parray, (void**)&pVarBuffer);

	int fCmp = memcmp((void*)pBuffer, (void*)pVarBuffer , Size);

	SafeArrayUnaccessData(Var.parray);

	SafeArrayUnlock(Var.parray);

	return (fCmp == 0) ? true : false;
}

/*
HRESULT CActionTest::GUIDVarIs(bstr_t bstrPropName,VARIANT& Val)
{
	BYTE obj[20];
	WCHAR* pwcs = NULL;
	memset(&obj, 0, sizeof(OBJECTID));

	long type = VT_ARRAY | VT_UI1;

	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";

	if(Val.vt == type)
	{
		long i, UBound;

		SafeArrayLock(Val.parray);
		SafeArrayGetUBound(Val.parray, 1, &UBound);
		for(i=0; i<UBound && i < 20;i++)
		{
			SafeArrayGetElement(Val.parray, &i, (void*)&(obj[i]));
		}
		SafeArrayUnlock(Val.parray);
		UuidToString(&(((OBJECTID*)obj)->Lineage), &pwcs);
		wcs += pwcs;
		RpcStringFree( &pwcs );

		WCHAR szI4[12];
		_ltow(((OBJECTID*)obj)->Uniquifier, szI4, 10);
	
		wcs += L"\\";
		wcs += szI4;

		m_wofsFile << wcs.c_str() << endl;

		return S_OK;
	}
		
	return E_FAIL;
}


HRESULT CActionTest::StringIs(_bstr_t bstrPropName, BSTR& Val)
{
	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";
	wcs += (WCHAR*)_bstr_t(Val);

	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}

HRESULT CActionTest::VarIs(_bstr_t bstrPropName, VARIANT& Val)
{
	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";
	_bstr_t bstr = (_bstr_t)(_variant_t(Val));
	wcs += (WCHAR*)bstr;
	
	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}
	

HRESULT CActionTest::LongIs(_bstr_t bstrPropName, long Val)
{
	std::wstring wcs = bstrPropName;
	wcs += L" Is: ";
	
	WCHAR wcsBuf[512];
	wsprintf(wcsBuf, L"%d", Val);

	wcs += wcsBuf;

	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}


HRESULT CActionTest::DateIs(_bstr_t bstrPropName, DATE& Val)
{
	VARIANT vtDate;
	VariantInit(&vtDate);
	vtDate.vt = VT_DATE;
	vtDate.date = Val;

	_bstr_t bstr = (_bstr_t)(_variant_t(vtDate));

	std::wstring wcs = bstrPropName;
	wcs += L" Is: ";
	
	wcs += (WCHAR*)bstr;

	m_wofsFile << wcs.c_str() << endl;
	
	return S_OK;
}
*/

/*
HRESULT  CActionTest::ConverFromByteArray2Variant(BYTE* pByteArray, DWORD size,  _variant_t& vtArray)
{
	HRESULT hr = S_OK;
	
	VARIANT Var;
	VariantInit(&Var);

	BYTE* pBuffer;

	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	
	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = size;

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);
	if (psaBytes == NULL)
	{ 
		return S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pBuffer);
	if SUCCEEDED(hr)
	{
		// Copy the body from the message object to the safearray data buffer.
		memcpy(pBuffer, pByteArray, size);

		// Return the safe array if created successfully.
		Var.vt = VT_ARRAY | VT_UI1;
		Var.parray = psaBytes;

		hr = SafeArrayUnaccessData(Var.parray);
		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			Var.vt = VT_ERROR;
		}
	}
	else
	{
		Var.vt = VT_ERROR;
	}

	vtArray = Var;	
	
	return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\actionstest\actiontest.h ===
// ActionTest.h : Declaration of the CActionTest

#ifndef __ACTIONTEST_H_
#define __ACTIONTEST_H_

#include "resource.h"       // main symbols
#include <mq.h>

using namespace std;

enum ActionMsgProps
{
	MSG_BODY_SIZE = 0,
	MSG_LABEL_LEN, 
	MSG_RESPQ_NAME_LEN,
	MSG_ADMINQ_NAME_LEN, 
	MSG_ID,
	MSG_LABEL,
	MSG_BODY_TYPE,
	MSG_BODY,
	MSG_PRIORITY,
	MSG_CORRID,
	MSG_RESPONSEQ,
	MSG_ADMINQ,
	MSG_APP_SPECIFIC,
	MSG_SENT_TIME,
	MSG_ARRIVED_TIME,
	MSG_SRC_MACHINE_ID,
	MAX_ACTION_PROPS
};

#define MSG_ID_BUFFER_SIZE 20

/////////////////////////////////////////////////////////////////////////////
// CActionTest
class ATL_NO_VTABLE CActionTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CActionTest, &CLSID_ActionTest>,
	public ISupportErrorInfo,
	public IDispatchImpl<IActionTest, &IID_IActionTest, &LIBID_ACTIONSTESTLib>
{
public:
	CActionTest();
	~CActionTest();

DECLARE_REGISTRY_RESOURCEID(IDR_ACTIONTEST)
DECLARE_NOT_AGGREGATABLE(CActionTest)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CActionTest)
	COM_INTERFACE_ENTRY(IActionTest)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IActionTest
public:
	STDMETHOD(MessageParams)(/*[in]*/ VARIANT MsgID, /*[in]*/BSTR MsgLabel, /*[in]*/VARIANT MsgBodyAsVar,/*[in]*/BSTR MsgBodyAsString,/*[in]*/long Priority, /*[in]*/VARIANT MsgCorlID, /*[in]*/BSTR QueuePath, /*[in]*/BSTR QueueFormat, /*[in]*/BSTR ResponseQ,/*[in]*/ BSTR AdminQ, /*[in]*/long AppSpecific, /*[in]*/DATE SentTime, /*[in]*/DATE ArrivedTime, /*[in]*/BSTR SrcMachine, /*[in]*/BSTR TriggerName, /*[in]*/BSTR TriggerID, /*[in]*/BSTR LiteralString, /*[in]*/long Number);
private:

	HRESULT ReadMessageFromQueue(_bstr_t QueueFormat);

	HRESULT OBJECTIDVar2String(VARIANT& Val, wstring& wcsVal);
	HRESULT GUID2String(GUID* pGuid, wstring& wcsVal);
	HRESULT OBJECTID2String(OBJECTID* pObj, wstring& wcsVal);
	bool CompareVar2ByteArray(VARIANT& Var, BYTE* pBuffer, DWORD Size);

	bool ComparePathName2FormatName(_bstr_t PathName, _bstr_t FormatName);

private:
    std::wofstream m_wofsFile;

	QUEUEHANDLE m_hQ;

	MQMSGPROPS  m_MsgProps;
	MQPROPVARIANT  m_aVariant[MAX_ACTION_PROPS];
	MSGPROPID m_aPropId[MAX_ACTION_PROPS];
};

#endif //__ACTIONTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\createtriggerq\createtriggerq.cpp ===
// CreateTriggerQ.cpp : Defines the entry point for the console application.
//
#include "libpch.h"
#include <mq.h>

#include "CInputParams.h"
#include "GenMQSec.h"

using namespace std;

int __cdecl wmain(int argc, wchar_t* argv[])
{
	CInputParams Input(argc, argv);

	wstring wcsQPath = Input[L"QPath"];
	bool fTransacted = Input.IsOptionGiven(L"Trans");

	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
	SECURITY_INFORMATION* pSecInfo = NULL;
	wstring wscSecurity = L"+:* A";
		
	DWORD dwError = GenSecurityDescriptor(
							pSecInfo,
							wscSecurity.c_str(),
							&pSecurityDescriptor );

	if(dwError != 0)
	{
		wprintf(L"Failed to create security descriptor");					
		return -1;
	}

	WCHAR wcsFormatName[255];
	ZeroMemory(wcsFormatName,sizeof(wcsFormatName));
	DWORD dwFormatNameLen = 255;

	MQQUEUEPROPS QueueProps;
	PROPVARIANT aVariant[2];
	QUEUEPROPID aPropId[2];
	DWORD PropIdCount = 0;

	WCHAR* pwcs = new WCHAR[wcsQPath.length() + 1];
	wcscpy(pwcs, wcsQPath.c_str());

	//Set the PROPID_Q_PATHNAME property.
	aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
	aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
	aVariant[PropIdCount].pwszVal = pwcs;
    	
	PropIdCount++;
    
	aPropId[PropIdCount] = PROPID_Q_TRANSACTION; 
	aVariant[PropIdCount].vt = VT_UI1;
	aVariant[PropIdCount].bVal = (fTransacted ? MQ_TRANSACTIONAL : MQ_TRANSACTIONAL_NONE);
	
	PropIdCount++;

	//Set the MQQUEUEPROPS structure.
	QueueProps.cProp = PropIdCount;           //No of properties
	QueueProps.aPropID = aPropId;             //Ids of properties
	QueueProps.aPropVar = aVariant;           //Values of properties
	QueueProps.aStatus = NULL;                //No error reports

	// Attempt to create the notifications queue.
	HRESULT hr = MQCreateQueue(
					pSecurityDescriptor,
					&QueueProps,
					wcsFormatName,
					&dwFormatNameLen );

	delete pwcs;

	// Check if the queue already existed or if we got an error etc...
	switch(hr)
	{
		case MQ_OK: 
			break;

		case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL: 
			break;

		case MQ_ERROR_QUEUE_EXISTS: 
			break;
		
		default: // Error
		{
			wprintf(L"Failed to create the queue\n");
			return -1;
		}
	}


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\createtriggerq\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_)
#define AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\checktest.h ===
// checkTest.h : Declaration of the CcheckTest

#ifndef __CHECKTEST_H_
#define __CHECKTEST_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CcheckTest
class ATL_NO_VTABLE CcheckTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CcheckTest, &CLSID_checkTest>,
	public IDispatchImpl<IcheckTest, &IID_IcheckTest, &LIBID_TESTLOOKUPIDINVOKATIONLib>
{
public:
	CcheckTest()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHECKTEST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CcheckTest)
	COM_INTERFACE_ENTRY(IcheckTest)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IcheckTest
public:
	STDMETHOD(checkLookupIdInvocation)(BSTR queueFormatName, BSTR label, VARIANT lookupId);
};

#endif //__CHECKTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\msgrecvtest\rcvtest.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rcvtest.cpp

Abstract:
    Transactional Object for Rules processing

Author:
    Nela Karpel (nelak) 28-Sep-2000

--*/

/* Test description:
	The test consists of 6 stages, on each stage different configuration 
	of the new "Message Receive" feature is tested.
	At each stage a trigger is created, and messages are sent to a queue. 
	After that a check of the results is done. The check is based on the
	expected number of messages in queue after trigger was processed.
	One rule is created and used in every stage: 
		Rule condition is "Message Label Contains STAGE".
	Stage1: Send x messages with label that contains STAGE to regular queue. 
			Create PEEK_MESSAGE trigger. Expect x messages.
	Stage2: Send x messages with label that contains STAGE to regular queue. 
			Create RECEIVE_MESSAGE trigger. Expect 0 messages.
	Stage3: Send x messages with label that contains STAGE to transactional queue. 
			Create PEEK_MESSAGE trigger. Expect x messages.
	Stage4: Send x messages with label that contains STAGE to transactional queue. 
			Create RECEIVE_MESSAGE trigger. Expect 0 messages.
	Stage5: Send x messages with label that contains STAGE to transactional queue. 
			Create RECEIVE_MESSAGE_XACT trigger. Expect 0 messages.
	Stage6: Send x messages with label that does not contain STAGE to regular queue. 
			Create RECEIVE_MESSAGE trigger. Expect x messages.
*/

#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

#define NO_OF_STAGES 6

const DWORD xNoOfMessages = 10;
const WCHAR xQueuePath[] = L".\\private$\\RecvTestQueue";
const WCHAR xXactQueuePath[] = L".\\private$\\RecvTestQueueXact";

struct StageInfo
{
	MsgProcessingType trigType;
	int numOfExpectedMsgs;
	WCHAR* label;
	bool xact;
};

/* 
stageInfo sructure holds information specific to every stage. 
For each stage a tuple of 4 values is kept.
1. trigType - value of "Message Processing Type" property for
	a trigger in that stage
2. numOfExpectedMsgs - number of messages expected at the end 
	of trigger processing
3. label - label for the messages in that stage. The label is
	important for rule condition evaluation
4. xact - true for stages in which messages are sent to transactional
	queues. 
*/
const StageInfo stageInfo[NO_OF_STAGES] = { 
	{PEEK_MESSAGE,			10, L"Stage1_", false},
	{RECEIVE_MESSAGE,		0,	L"Stage2_", false},
	{PEEK_MESSAGE,			10, L"Stage3_", true},
	{RECEIVE_MESSAGE,		0,	L"Stage4_", true},
	{RECEIVE_MESSAGE_XACT,	0,	L"Stage5_", true},
	{RECEIVE_MESSAGE,		10,	L"Nela1_",	false}
};


void CleanupOldTriggers(LPCWSTR queuePathName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);
    GetComputerName(computerName, &size);

	WCHAR myQueuePath[256];
	wcscpy(myQueuePath, computerName);
	wcscat(myQueuePath, queuePathName + 1);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(L"");
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(myQueuePath, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


void
CreateQueue(
	LPCWSTR queuePathName,
	bool xact
	)
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);
	
	try
	{
		qinfo->Delete();
	}
	catch(const _com_error& e)
	{
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete old queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
	}

	CleanupOldTriggers(queuePathName);

    try
    {
        _variant_t vWorld = true;
		_variant_t vXact = xact;

        qinfo->Create(&vXact, &vWorld);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"Create queue failed. Error %d\n", e.Error());
            throw;
        }
    }
}


void
CreateTestQueues()
{
	CreateQueue(xQueuePath, false);
	CreateQueue(xXactQueuePath, true);
}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    return qinfo->Open(access, deny);
}


void SendMessagesToQueue(DWORD noOfMessages, LPCWSTR destQueue, int stageNo)
{
    IMSMQQueuePtr sq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            wsprintf(label, L"%s%d", stageInfo[stageNo].label, i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 
			
			if ( stageInfo[stageNo].xact )
			{
				_variant_t vTrans(static_cast<long>(MQ_SINGLE_MESSAGE));

				msg->Send(sq, &vTrans);
			}
			else
			{
				msg->Send(sq);
			}
			Sleep(100);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


BSTR CreateTrigger(
	LPCWSTR trigName, 
	LPCWSTR queuePath, 
	UINT msgProcType, 
	BSTR bstrRuleID
	)
{
	try
	{
		IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		trigSet->Init(L"");
		trigSet->Refresh();
		
		BSTR bstrTrigID = NULL;
		trigSet->AddTrigger(
					trigName,
					queuePath,
					SYSTEM_QUEUE_NONE,
					true,
					false,
					static_cast<MsgProcessingType>(msgProcType),
					&bstrTrigID
					);
	
		trigSet->AttachRule (bstrTrigID, bstrRuleID, 0);
		return bstrTrigID;
	}
	catch (const _com_error& e)
	{
		printf("Failed to create trigger, error: %d\n", e.Error());
		throw;
	}
}


void DeleteTrigger(BSTR bstrTrigID)
{
	if ( bstrTrigID == NULL )
	{
		return;
	}

	try
	{
		IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		trigSet->Init(L"");
		trigSet->Refresh();
		
		trigSet->DeleteTrigger(
					bstrTrigID
					);
	
		//SysFreeString(bstrTrigID);
	}
	catch (const _com_error& e)
	{
		printf("Failed to delete trigger, error: %d\n", e.Error());
		throw;
	}
}


BSTR CreateRule(LPCWSTR ProgID, LPCWSTR Method)
{
	try
	{
		IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		ruleSet->Init(L"");
		ruleSet->Refresh();

		wostringstream ruleAction;
		ruleAction << L"COM\t" << ProgID << L"\t" << Method << L"";
		
		BSTR ruleID = NULL;
		ruleSet->Add(
                L"RecvTestRule", 
                L"Rule For MsgRcv Test", 
                L"$MSG_LABEL_CONTAINS=Stage\t", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );
		
		return ruleID;

	}
	catch (const _com_error& e)
	{
		printf("Failed to create rule. Error: %d\n", e.Error());
		throw;
	}
}


void DeleteRule( BSTR bstrRuleId )
{
	if ( bstrRuleId == NULL )
	{
		return;
	}

	try
	{
		IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		ruleSet->Init(L"");
		ruleSet->Refresh();

		ruleSet->Delete(bstrRuleId);
		
		//SysFreeString(bstrRuleId);
	}
	catch (const _com_error& e)
	{
		printf("Failed to delete rule. Error: %d\n", e.Error());
		throw;
	}
}


IMSMQMessagePtr ReceiveMessage(IMSMQQueuePtr pQueue)
{
	_variant_t vtReceiveTimeout = (long)1000;

	return pQueue->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
}


bool CheckResults(LPCWSTR queueName, int stageNo)
{
    IMSMQQueuePtr pQueue;

    try
    {
        pQueue = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
		if (stageInfo[stageNo].numOfExpectedMsgs == 0)
		{
			IMSMQMessagePtr msg = ReceiveMessage(pQueue);
			if ( msg == NULL )
			{
				return true;
			}
			return false;
		}

        for (long i = 0; i < stageInfo[stageNo].numOfExpectedMsgs; ++i)
        {
  
           IMSMQMessagePtr msg = ReceiveMessage(pQueue);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
		   _bstr_t expectedLabel = L"";

		   wsprintf(expectedLabel, L"%s%d", stageInfo[stageNo].label, i);
           msg->get_Label(&label);

           if (wcscmp(label, expectedLabel) == 0)
           {
			   SysFreeString(label);
               continue;
           }

		   SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to receive a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


void
CleanUp(
	BSTR ruleID,
	BSTR triggerID
	)
{
	DeleteRule(ruleID);
	DeleteTrigger(triggerID);
}


int __cdecl wmain(int , WCHAR**)
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

	wprintf(L"Beginning Message Receive Test. TotaL of %d stages.\n", NO_OF_STAGES);

    BSTR ruleId = NULL;
    BSTR triggerId = NULL;
    try
    {
		CreateTestQueues();

        ruleId = CreateRule(L"XactProj.XactObj", L"XactFunc");

		WCHAR queuePath[256];

		for	( int i = 0; i < NO_OF_STAGES; i++ )
		{
			wprintf(L"Message Receive Test. Stage %d: ", i+1);

			if ( !(stageInfo[i].xact) )
			{
				wcscpy(queuePath, xQueuePath);
			}
			else
			{
				wcscpy(queuePath, xXactQueuePath);
			}

			SendMessagesToQueue(xNoOfMessages, queuePath, i);

			WCHAR trigName[30];
			wsprintf(trigName, L"RecvTrigger%d", i);
			triggerId = CreateTrigger(trigName, queuePath, stageInfo[i].trigType, ruleId);
			Sleep(10000);

			if (CheckResults( queuePath, i ) == false)
			{

				wprintf(L"Failed\n");
				CleanUp(ruleId, triggerId);
				CoUninitialize();
				return -1;
			}
			
			wprintf(L"Passed\n");
			DeleteTrigger(triggerId);
		}
    }
    catch(const _com_error& e)
    {
		CleanUp(ruleId, triggerId);
        CoUninitialize();
    
        wprintf(L"Test Failed. Error: %d\n", e.Error());
        return -1;
    }
    
    DeleteRule(ruleId);
    CoUninitialize();
    wprintf(L"Test pass successfully\n");
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\checktest.cpp ===
// checkTest.cpp : Implementation of CcheckTest
#include "stdafx.h"
#include "TestLookupidInvokation.h"
#include "checkTest.h"


#import  "mqoa.tlb" no_namespace


/////////////////////////////////////////////////////////////////////////////
// CcheckTest

IMSMQQueue3Ptr 
OpenQueue(
    LPCWSTR queueFormatName,
    long access,
    long deny
    )
{
    try
    {
        IMSMQQueueInfo3Ptr qinfo(L"MSMQ.MSMQQueueInfo");

        BSTR qpn(const_cast<LPWSTR>(queueFormatName));
        qinfo->put_FormatName(qpn);

        //
        // try to create a queue. if exist ignore the error
        //
        return qinfo->Open(access, deny);

    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"faile to open queue %s. Error %d\n", queueFormatName, e.Error());
            throw;
        }
    }
    return NULL;
}


STDMETHODIMP 
CcheckTest::checkLookupIdInvocation(
    BSTR queueFormatName, 
    BSTR expectedLabel, 
    VARIANT lookupId
    )
{
    try
    {
        IMSMQQueue3Ptr q = OpenQueue(queueFormatName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
        IMSMQMessagePtr msg = q->ReceiveByLookupId(lookupId);

        if (msg == NULL)
        {
            MessageBox(NULL, L"Failed to recevive by lookup ID", NULL, MB_OK);
            return S_OK;
        }

        //
        // Open response queue
        //
        IMSMQQueueInfo* pResponseQueue;
        msg->get_ResponseQueueInfo(&pResponseQueue);
        IMSMQQueuePtr rq = (*pResponseQueue).Open(MQ_SEND_ACCESS, MQ_DENY_NONE);

        BSTR label;
        msg->get_Label(&label);
        if (wcscmp(label, expectedLabel) == 0)
        {
            label= L"OK";
        }
        else
        {        
            WCHAR msg[1000];
            swprintf(msg, L"Test Failed. Expected %s. Received %s", expectedLabel, label);
            MessageBox(NULL, msg, NULL, MB_OK);

            label = L"FAILE ";
        }

        //
        // Response message
        //
        IMSMQMessagePtr respMsg(L"MSMQ.MSMQMessage");
        respMsg->put_Label(label);

        respMsg->Send(rq);
    }
    catch (const _com_error& e)
    {
        WCHAR msg[256];
        swprintf(msg, L"Test failed. Error %x", e.Error());

        MessageBox(NULL, msg, NULL, MB_OK);
    }
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\lookupid\main.cpp ===
#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

const DWORD xQueuePathName = 256;
const DWORD xNoOfMessages = 100;

void GetQueuePaths(LPWSTR testQueue, LPWSTR responseQueue)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

    int n = _snwprintf(testQueue, xQueuePathName, L"%s\\private$\\TestTriggerLookupID", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(responseQueue, xQueuePathName, L"%s\\private$\\TestTriggerLookupIDResponseQueue", machineName);
    if (n < 0)
        throw exception();


}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny,
    bool fDelete
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        if (fDelete)
            qinfo->Delete();
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
    }


    //
    // try to create a queue. if exist ignore the error
    //
    try
    {
        VARIANT v;
        v.vt = VT_BOOL;
        v.boolVal = VARIANT_TRUE;

        qinfo->Create(&vtMissing, &v);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"create queue failed. Error %d\n", e.Error());
            throw;
        }
    }

    return qinfo->Open(access, deny);
}


void SendMessageToQueue(DWORD noOfMessages, LPCWSTR destQueue, LPCWSTR responseQueue)
{
    IMSMQQueuePtr sq;
    IMSMQQueuePtr rq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE, true);
        rq = OpenQueue(responseQueue, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, true);
        rq->Close();
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    //
    // Get response queue object
    //
    IMSMQQueueInfoPtr qResponseInfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(responseQueue));
    qResponseInfo->put_PathName(qpn);


    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    msg->ResponseQueueInfo = qResponseInfo;

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            swprintf(label, L"Trigger lookup ID test - message %d", i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 
            msg->Send(sq);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


void CleanupOldTrigger(LPCWSTR queueFormatName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(queueFormatName, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


_bstr_t CreateRule(LPCWSTR progId, LPCWSTR methodId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    //
    // Create Rule
    //
    IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
    ruleSet->Init(computerName);
    ruleSet->Refresh();

    wostringstream ruleAction;
    ruleAction << L"COM\t" << progId << L"\t" << methodId << L"\t$MSG_QUEUE_FORMATNAME\t$MSG_LABEL\t$MSG_LOOKUP_ID";
    BSTR ruleID = NULL;

    ruleSet->Add(
                L"LookupidTest", 
                L"Lookup ID rule", 
                L"", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );

    _bstr_t retRuleId = ruleID;
    SysFreeString(ruleID);
    
    return retRuleId;
}


bool CheckResult(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //          
            // Set value of ReceiveTimout parameter.
            //
            _variant_t vtReceiveTimeout = (long)100000;
  
           IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
           msg->get_Label(&label);
           if (wcscmp(label, L"OK") == 0)
           {
               SysFreeString(label);
               continue;
           }

           SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


_bstr_t SetTrigger(LPCWSTR queueName, const _bstr_t& ruleId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    BSTR triggerId = NULL;
    trigSet->AddTrigger(
        L"Lookupid",
        queueName,
        SYSTEM_QUEUE_NONE,
        true,
        false,
		PEEK_MESSAGE,
        &triggerId
        );

    trigSet->AttachRule (triggerId, ruleId, 0);

    _bstr_t retTriggerId = triggerId;
    SysFreeString(triggerId);

    return retTriggerId;
}


void CleanupRuleAndTrigger(_bstr_t& ruleId, _bstr_t& triggerId)
{
    try
    {
        WCHAR computerName[256];
        DWORD size = sizeof(computerName)/sizeof(WCHAR);

        GetComputerName(computerName, &size);

        IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
        trigSet->Init(computerName);
        trigSet->Refresh();

        trigSet->DeleteTrigger(triggerId);

        //
        // Delete Rule
        //
        IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
        ruleSet->Init(computerName);
        ruleSet->Refresh();

        ruleSet->Delete(ruleId);
    }
    catch(const _com_error&)
    {
    }
}

int __cdecl wmain(int , WCHAR** )
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

    WCHAR testQueue[xQueuePathName];
    WCHAR responseQueue[xQueuePathName];
    GetQueuePaths(testQueue, responseQueue);

    CleanupOldTrigger(testQueue);
    SendMessageToQueue(xNoOfMessages, testQueue, responseQueue);

    //
    // craete trigger and rule
    //
    _bstr_t ruleId;
    _bstr_t triggerId;
    try
    {
        ruleId = CreateRule(L"testLookupidInvokation.checkTest", L"checkLookupIdInvocation");
        triggerId = SetTrigger(testQueue, ruleId);
    }
    catch(const _com_error&)
    {
        CoUninitialize();
    
        wprintf(L"Failed to create rule and triggr\n");
        return -1;
    }

    if (CheckResult(xNoOfMessages, responseQueue) == false)
    {
        CleanupRuleAndTrigger(ruleId, triggerId);
        CoUninitialize();

        wprintf(L"Test Failed\n");
        return -1;
    }
    
    CleanupRuleAndTrigger(ruleId, triggerId);
    CoUninitialize();
    wprintf(L"Test pass successfully\n");
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testLookupidInvokation.rc
//
#define IDR_CHECKTEST                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\systemqueue\main.cpp ===
#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

const DWORD xQueuePathName = 256;
const DWORD xNoOfMessages = 100;

void 
GetQueuePaths(
	LPWSTR testJournalQueue, 
	LPWSTR testDeadletterQueue, 
	LPWSTR testXactdedQueue, 
	LPWSTR responseQueue
	)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

    int n = _snwprintf(testJournalQueue, xQueuePathName, L"%s\\private$\\TestJournalSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(testDeadletterQueue, xQueuePathName, L"%s\\private$\\TestDeadletterSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(testXactdedQueue, xQueuePathName, L"%s\\private$\\TestXactdeadSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(responseQueue, xQueuePathName, L"%s\\private$\\TestSystemQueueResponseQueue", machineName);
    if (n < 0)
        throw exception();
}


//
// DIRECT=OS:<computerName>\SYSTEM$;<suffix>
//
WCHAR x_SystemQueueFormat[] = L"DIRECT=OS:%s\\SYSTEM$%s";
WCHAR x_JOURNAL_SUFFIX[] = L";JOURNAL";
WCHAR x_DEADLETTER_SUFFIX[] = L";DEADLETTER";
WCHAR x_DEADXACT_SUFFIX[] = L";DEADXACT";


void
GetSysytemQueuePaths(
	LPWSTR journalQueue, 
	LPWSTR DeadletterQueue, 
	LPWSTR XactDeadletterQueue
	)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

	int n = _snwprintf(journalQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_JOURNAL_SUFFIX);
    if (n < 0)
        throw exception();

    n = _snwprintf(DeadletterQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_DEADLETTER_SUFFIX);
    if (n < 0)
        throw exception();

    n = _snwprintf(XactDeadletterQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_DEADXACT_SUFFIX);
    if (n < 0)
        throw exception();
}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny,
    bool fDelete,
	bool fTransacted
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        if (fDelete)
            qinfo->Delete();
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
    }


    //
    // try to create a queue. if exist ignore the error
    //
    try
    {
        VARIANT v[2];
        v[0].vt = VT_BOOL;
        v[0].boolVal = fTransacted;
        v[1].vt = VT_BOOL;
        v[1].boolVal = VARIANT_TRUE;

        qinfo->Create(&v[0], &v[1]);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"create queue failed. Error %d\n", e.Error());
            throw;
        }
    }

    return qinfo->Open(access, deny);
}


void 
SendMessageToQueue(
	DWORD noOfMessages, 
	LPCWSTR destQueue, 
	LPCWSTR responseQueue,
	long fJournal,
	long MaxTimeToReceive,
	bool fTransacted

	)
{
    IMSMQQueuePtr sq;
    IMSMQQueuePtr rq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE, true, fTransacted);
        rq = OpenQueue(responseQueue, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
        rq->Close();
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    //
    // Get response queue object
    //
    IMSMQQueueInfoPtr qResponseInfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(responseQueue));
    qResponseInfo->put_PathName(qpn);
	qResponseInfo->Refresh();

    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    msg->ResponseQueueInfo = qResponseInfo;
	msg->Journal = fJournal;
	msg->MaxTimeToReceive = MaxTimeToReceive;

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            swprintf(label, L"Trigger lookup ID test - message %d", i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 

			_variant_t bTransaction((LONG_PTR)(fTransacted ? MQ_SINGLE_MESSAGE : MQ_NO_TRANSACTION));     
            msg->Send(sq, &bTransaction);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


bool ReceiveMessageFromQueue(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    for (DWORD i = 0; i < noOfMessages; ++i)
    {
        //          
        // Set value of ReceiveTimout parameter.
        //
        _variant_t vtReceiveTimeout = (long)1000;

       IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
       if (msg == NULL)
       {
           wprintf(L"Failed to receive message from response queue: %s", queueName);
           return false;
       }
	}

	return true;
}


void CleanupOldTrigger(LPCWSTR queueFormatName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(queueFormatName, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


_bstr_t CreateRule(LPCWSTR progId, LPCWSTR methodId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    //
    // Create Rule
    //
    IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
    ruleSet->Init(computerName);
    ruleSet->Refresh();

    wostringstream ruleAction;
    ruleAction << L"COM\t" << progId << L"\t" << methodId << L"\t$MSG_QUEUE_FORMATNAME\t$MSG_LABEL\t$MSG_LOOKUP_ID";
    BSTR ruleID = NULL;

    ruleSet->Add(
                L"LookupidTest", 
                L"Lookup ID rule", 
                L"", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );

    _bstr_t retRuleId = ruleID;
    SysFreeString(ruleID);
    
    return retRuleId;
}


bool CheckResult(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //          
            // Set value of ReceiveTimout parameter.
            //
            _variant_t vtReceiveTimeout = (long)100000;
  
           IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
           msg->get_Label(&label);
           if (wcscmp(label, L"OK") == 0)
           {
               SysFreeString(label);
               continue;
           }

           SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


_bstr_t SetTrigger(SystemQueueIdentifier SystemQueue, LPCWSTR triggerName, const _bstr_t& ruleId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    BSTR triggerId = NULL;
    trigSet->AddTrigger(
        triggerName,
        L"",
        SystemQueue,
        true,
        false,
		RECEIVE_MESSAGE,
        &triggerId
        );

    trigSet->AttachRule (triggerId, ruleId, 0);

    _bstr_t retTriggerId = triggerId;
    SysFreeString(triggerId);

    return retTriggerId;
}


void CleanupRuleAndTrigger(_bstr_t& ruleId, _bstr_t* triggerId)
{
    try
    {
        WCHAR computerName[256];
        DWORD size = sizeof(computerName)/sizeof(WCHAR);

        GetComputerName(computerName, &size);

        IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
        trigSet->Init(computerName);
        trigSet->Refresh();

        trigSet->DeleteTrigger(triggerId[0]);
        trigSet->DeleteTrigger(triggerId[1]);
        trigSet->DeleteTrigger(triggerId[2]);

        //
        // Delete Rule
        //
        IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
        ruleSet->Init(computerName);
        ruleSet->Refresh();

        ruleSet->Delete(ruleId);
    }
    catch(const _com_error&)
    {
    }
}


void 
DeleteQueue(
    LPCWSTR queuePathName
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        qinfo->Delete();
    }
    catch(const _com_error& )
    {
    }
}


int __cdecl wmain(int , WCHAR** )
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

    WCHAR testJournalQueue[xQueuePathName];
    WCHAR testDeadletterQueue[xQueuePathName];
	WCHAR testXactdedQueue[xQueuePathName];
    WCHAR responseQueue[xQueuePathName];
    GetQueuePaths(testJournalQueue, testDeadletterQueue, testXactdedQueue, responseQueue);

	DeleteQueue(testJournalQueue);
	DeleteQueue(testDeadletterQueue);
	DeleteQueue(testXactdedQueue);
	DeleteQueue(responseQueue);
	

    WCHAR journalQueue[xQueuePathName];
	WCHAR DeadletterQueue[xQueuePathName];
	WCHAR XactDeadletterQueue[xQueuePathName];
    GetSysytemQueuePaths(journalQueue, DeadletterQueue, XactDeadletterQueue);

    CleanupOldTrigger(journalQueue);
    CleanupOldTrigger(DeadletterQueue);
    CleanupOldTrigger(XactDeadletterQueue);

    SendMessageToQueue(1, testJournalQueue, responseQueue, MQMSG_JOURNAL, 5, false);
    SendMessageToQueue(1, testDeadletterQueue, responseQueue, MQMSG_DEADLETTER, 1, false);
    SendMessageToQueue(1, testXactdedQueue, responseQueue, MQMSG_DEADLETTER, 1, true);
	ReceiveMessageFromQueue(1, 	testJournalQueue);

    //
    // craete trigger and rule
    //
    _bstr_t ruleId;
    _bstr_t triggerId[3];
    try
    {
        ruleId = CreateRule(L"testLookupidInvokation.checkTest", L"checkLookupIdInvocation");
        triggerId[0] = SetTrigger(SYSTEM_QUEUE_JOURNAL, L"JournalSystemQueueTrigger", ruleId);
        triggerId[1] = SetTrigger(SYSTEM_QUEUE_DEADLETTER, L"DeadletterSystemQueueTrigger", ruleId);
        triggerId[2] = SetTrigger(SYSTEM_QUEUE_DEADXACT, L"XactdeadSystemQueueTrigger", ruleId);
    }
    catch(const _com_error&)
    {
        CoUninitialize();
    
        wprintf(L"Failed to create rule and triggr\n");
        return -1;
    }

	bool fFailed = false;

    if (CheckResult(3, responseQueue) == false)
    {
		fFailed = true;
    }
    
    CleanupRuleAndTrigger(ruleId, triggerId);
	DeleteQueue(testJournalQueue);
	DeleteQueue(testDeadletterQueue);
	DeleteQueue(testXactdedQueue);
	DeleteQueue(responseQueue);

    CoUninitialize();

	if (fFailed)
	{
        wprintf(L"Test Failed\n");
        return -1;
    }
	
	wprintf(L"Test pass successfully\n");
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED_)
#define AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\trigadm\trigadm.cpp ===
#include "libpch.h"
#include <comdef.h>
#include "cinputparams.h"

#include "trigadm.h"
#include "StrParse.hpp"
#import "mqtrig.tlb" 


using namespace std;

const wstring LegalRequests[NUM_OF_REQUESTS] = {
														L"UpdateConfig",
														L"GetConfig",
														L"AddTrigger",
														L"UpdateTrigger",
														L"DeleteTrigger",
														L"AttachRule",
														L"DetachRule",
														L"AddRule",
														L"UpdateRule",
														L"DeleteRule",
														L"GetTriggersList",
														L"GetRulesList",
														L"GetTrigger",
														L"GetRule" 
												};


MSMQTriggersRequest IsLegalRequest(wstring wcsRequest)
{
	if(wcsRequest.empty())
	{
		return REQUEST_NONE;
	}

	for(int i=0; i < NUM_OF_REQUESTS ;i++)
	{
		//
		// Compare without case sensetive
		//
		wstring wcs = LegalRequests[i];
		if( !_wcsicmp( wcs.c_str(), wcsRequest.c_str() ) )
		{
			return (MSMQTriggersRequest)i;
		}
	}
	return REQUEST_ILLEGAL;
}




int __cdecl wmain(int argc, WCHAR* argv[])
{
	try
	{
		HRESULT hr = OleInitialize(NULL);
		if(FAILED(hr))
		{
			wprintf(L"Failed to initialize com %#x\n", hr);
			return -1;
		}

		CInputParams Input(argc, argv);
		
		if(argc == 1)
		{
			PrintUsage(REQUEST_NONE);
			return 0;
		}
		
		wstring wcsRequest = Input[L"Request"];
		MSMQTriggersRequest Request = IsLegalRequest(wcsRequest);
		wstring MachineName = Input[L"Machine"];

		bool fHelp = Input.IsOptionGiven(L"?");
		if(fHelp)
		{
			PrintUsage(Request);
			return 0;
		}
		
		switch(Request)
		{
		case REQUEST_UPDATE_CONFIG:
			hr = UpdateConfig(Input);
			break;

		case REQUEST_GET_CONFIG:
			hr = GetConfig();
			break;

		case REQUEST_ADD_TRIGGER:
			hr = AddTrigger(MachineName, Input);
			break;

		case REQUEST_UPDATE_TRIGGER:
			hr = UpdateTrigger(MachineName, Input);
			break;

		case REQUEST_DELETE_TRIGGER:
			hr = DeleteTrigger(MachineName, Input);
			break;

		case REQUEST_ATTACH_RULE:
			hr = AttachDetachRule(MachineName, Input, true);
			break;

		case REQUEST_DETACH_RULE:
			hr = AttachDetachRule(MachineName, Input, false);
			break;

		case REQUEST_ADD_RULE:
			hr = AddRule(MachineName, Input);
			break;

		case REQUEST_UPDATE_RULE:
			hr = UpdateRule(MachineName, Input);
			break;

		case REQUEST_DELETE_RULE:
			hr = DeleteRule(MachineName, Input);
			break;

		case REQUEST_GET_TRIGGERS_LIST:
			hr = GetTriggersList(MachineName, Input);
			break;

		case REQUEST_GET_RULES_LIST:
			hr = GetRulesList(MachineName, Input);
			break;

		case REQUEST_GET_TRIGGER:
			hr = GetTrigger(MachineName, Input);
			break;
	
		case REQUEST_GET_RULE:
			hr = GetRule(MachineName, Input);
			break;

		case REQUEST_NONE:
			PrintUsage(REQUEST_NONE);
			break;

		case REQUEST_ILLEGAL:
			wprintf(L"Failed : %s is an illegal request\n", wcsRequest.c_str());
			PrintUsage(REQUEST_ILLEGAL);
			hr = -1;
			break;

		default:
			ASSERT(0);
		}

		return hr;
	}
	catch (_com_error& Err)
	{
		_bstr_t ErrStr;
		try
		{
			ErrStr = Err.Description();
		}
		catch(_com_error& )
		{
			return -1;
		}
		if(!(!ErrStr))
		{
			try
			{
				printf("Failed : %ls\n", (wchar_t*)ErrStr);
			}
			catch(_com_error& )
			{
				return -1;
			}
		}
		else
			printf("Failed : 0x%x\n", Err.Error());
			
		return (int)Err.Error();
	}
}



HRESULT UpdateConfig(CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggersConfigPtr TriggersConfig(L"MSMQTriggerObjects.MSMQTriggersConfig.1");

	wcs = Input[L"InitThreads"];
	if(!wcs.empty())
	{
		long InitThreads = 0;
		if(swscanf(wcs.c_str(), L"%d", &InitThreads) != 1)
		{
			wprintf(L"Failed : InitThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(InitThreads <= 0 || InitThreads >= 100)
		{
			wprintf(L"Failed : InitThreads value must be a number between 1 and 99\n");
			return -1;
		}
		
		TriggersConfig->InitialThreads = InitThreads;
	}

	wcs = Input[L"MaxThreads"];
	if(!wcs.empty())
	{
		long MaxThreads = 0;
		if(swscanf(wcs.c_str(), L"%d", &MaxThreads) != 1)
		{
			wprintf(L"Failed : MaxThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(MaxThreads <= 0 || MaxThreads >= 100)
		{
			wprintf(L"Failed : MaxThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(MaxThreads < TriggersConfig->InitialThreads)
		{
			wprintf(L"Failed : Max threads number should be higher than Init threads number\n");
			return -1;
		}
		
		TriggersConfig->MaxThreads = MaxThreads;
	}

	wcs = Input[L"BodySize"];
	if(!wcs.empty())
	{
		long DefaultMsgBodySize = 0;
		if(swscanf(wcs.c_str(), L"%d", &DefaultMsgBodySize) != 1)
		{
			wprintf(L"Failed : DefaultMsgBodySize value must be a number between 0 and 4MB\n");
			return -1;
		}

		if(DefaultMsgBodySize <= 0 || DefaultMsgBodySize >= 4194304)
		{
			wprintf(L"Failed : DefaultMsgBodySize value must be a number between 0 and 4MB\n");
			return -1;
		}

		TriggersConfig->DefaultMsgBodySize = DefaultMsgBodySize;
	}

	wprintf(L"UpdateConfig completed successfuly\n");
	return 0;
}


HRESULT GetConfig()
{
	MSMQTriggerObjects::IMSMQTriggersConfigPtr TriggersConfig(L"MSMQTriggerObjects.MSMQTriggersConfig.1");

	wprintf(L"MSMQ Triggers configuration:\n");
	wprintf(L"Initial number of threads: %d\n", TriggersConfig->InitialThreads);
	wprintf(L"Max number of threads: %d\n", TriggersConfig->MaxThreads);
	wprintf(L"Default message body size is: %d\n", TriggersConfig->DefaultMsgBodySize);

	return 0;
}

HRESULT AddTrigger(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerName = Input[L"Name"];
	if(TriggerName.empty())
	{
		wprintf(L"Failed : Trigger name must be given\n");
		return -1;
	}

	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_NONE;

    wstring QueuePath = Input[L"Queue"];
	if(QueuePath.empty())
	{
		wprintf(L"Failed : Queue path must be given\n");
		return -1;
	}
	
	if(_wcsicmp(QueuePath.c_str(), L"JOURNAL") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL;
		QueuePath = L"";
	}
	else if(_wcsicmp(QueuePath.c_str(), L"DEADLETTER") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER;
		QueuePath = L"";
	}
	else if(_wcsicmp(QueuePath.c_str(), L"DEADXACT") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT;
		QueuePath = L"";
	}


	long lEnabled = 1, lSerialized = 0;

	wcs = Input[L"Enabled"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lEnabled = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lEnabled = 0;
		}
		else
		{
			wprintf(L"Failed : Enabled should be either true or false");
			return -1;
		}
	}
	
	wcs = Input[L"Serialized"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lSerialized = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lSerialized = 0;
		}
		else
		{
			wprintf(L"Failed : Serialized should be either true or false");
			return -1;
		}
	}

    
	BSTR bstrTriggerID = NULL;

	TriggerSet->AddTrigger(
					TriggerName.c_str(),
					QueuePath.c_str(),
					SystemQueue,
					lEnabled,
					lSerialized,
					MSMQTriggerObjects::PEEK_MESSAGE,
					&bstrTriggerID); 
				
	wprintf(L"%s\n", (WCHAR*)_bstr_t(bstrTriggerID));
	SysFreeString(bstrTriggerID);
	return 0;
}

HRESULT UpdateTrigger(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Failed : Trigger Id must be given\n");
		return -1;
	}

	BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
	long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

	TriggerSet->GetTriggerDetailsByID(
					TriggerId.c_str(),
					&bstrTriggerName,
					&bstrQueuePath,
					&SystemQueue,
					&lNumberOfRules,
					&lEnabled,
					&lSerialized,
					NULL);

	wstring TriggerName = Input[L"Name"];
	if(TriggerName.empty())
	{
		TriggerName = (WCHAR*)_bstr_t(bstrTriggerName);	
	}
	
	wstring QueuePath = Input[L"Queue"];
	if(QueuePath.empty())
	{
		//SystemQueue is already updated
		QueuePath = (WCHAR*)_bstr_t(bstrQueuePath);
	}
	else //queue path parameter is given and should be updated
	{
		if(_wcsicmp(QueuePath.c_str(), L"JOURNAL") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL;
			QueuePath = L"";
		}
		else if(_wcsicmp(QueuePath.c_str(), L"DEADLETTER") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER;
			QueuePath = L"";
		}
		else if(_wcsicmp(QueuePath.c_str(), L"DEADXACT") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT;
			QueuePath = L"";
		}
		else //regular path given
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_NONE;
		}
	}


	SysFreeString(bstrTriggerName);
	SysFreeString(bstrQueuePath);
	
	wcs = Input[L"Enabled"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lEnabled = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lEnabled = 0;
		}
		else
		{
			wprintf(L"Failed : Enabled should be either true or false");
			return -1;
		}
	}
	
	wcs = Input[L"Serialized"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lSerialized = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lSerialized = 0;
		}
		else
		{
			wprintf(L"Failed : Serialized should be either true or false");
			return -1;
		}
	}

    TriggerSet->UpdateTrigger(
					TriggerId.c_str(),			
					TriggerName.c_str(),
					QueuePath.c_str(),
					SystemQueue,
					lEnabled,
					lSerialized,
					MSMQTriggerObjects::PEEK_MESSAGE
					);
				
	wprintf(L"Trigger was updated successfuly\n");
	return 0;
}


HRESULT DeleteTrigger(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Trigger Id must be given\n");
		return -1;
	}

	TriggerSet->DeleteTrigger(TriggerId.c_str());

	wprintf(L"Trigger was deleted successfuly\n");
	return 0;
}


HRESULT AttachDetachRule(wstring MachineName, CInputParams& Input, bool fAttach)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"TriggerID"];
	if(TriggerId.empty())
	{
		wprintf(L"Trigger Id must be given\n");
		return -1;
	}

	wstring RuleId = Input[L"RuleID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	if(fAttach)
	{
		long lPriority;
		wstring wcs = Input[L"Priority"];
		if(!wcs.empty())
		{
			if(swscanf(wcs.c_str(), L"%d", &lPriority) != 1)
			{
				wprintf(L"Failed : Priority given must be a number in the range of 0 - number of rules attached\n");
				return -1;
			}
		
			if(lPriority < 0)
			{
				wprintf(L"Failed : Priority given must be a number in the range of 0 - number of rules attached\n");
				return -1;
			}
		}
		else //priority not given, add last
		{
			BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
			long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
			MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

			TriggerSet->GetTriggerDetailsByID(
							TriggerId.c_str(),
							&bstrTriggerName,
							&bstrQueuePath,
							&SystemQueue,
							&lNumberOfRules,
							&lEnabled,
							&lSerialized,
							NULL);

			lPriority = lNumberOfRules;
			SysFreeString(bstrTriggerName);
			SysFreeString(bstrQueuePath);
		}
		
		TriggerSet->AttachRule(TriggerId.c_str(), RuleId.c_str(), lPriority);
		wprintf(L"Attach operation completed successfuly\n");
	}
	else //detach
	{
		TriggerSet->DetachRule(TriggerId.c_str(), RuleId.c_str());
		wprintf(L"Detach operation completed successfuly\n");
	}

	return 0;
}


HRESULT AddRule(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleName = Input[L"Name"];
	if(RuleName.empty())
	{
		wprintf(L"Failed : Rule name must be given\n");
		return -1;
	}

	wstring Description = Input[L"Desc"];
	
	wstring Condition = Input[L"Cond"];
	if(!Condition.empty())
	{
		ConvertSeperatorsToTabs(Condition);
	}
		
	wstring Action = Input[L"Action"];
	if(!Action.empty())
	{
		ConvertSeperatorsToTabs(Action);
	}
	else
	{
		Action = L"EXE";
	}

	wstring Implementation;

	long lShowWindow = 1;
	wcs = Input[L"ShowWindow"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lShowWindow = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lShowWindow = 0;
		}
		else
		{
			wprintf(L"Failed : ShowWindow should be either true or false");
			return -1;
		}
	}

		
	BSTR  bstrRuleID = NULL;

	RuleSet->Add(
				RuleName.c_str(),
				Description.c_str(),
				Condition.c_str(),
				Action.c_str(),
				Implementation.c_str(),
				lShowWindow,
				&bstrRuleID );

	wprintf(L"%s\n", (WCHAR*)_bstr_t(bstrRuleID));
	SysFreeString(bstrRuleID);
	return 0;
}

HRESULT UpdateRule(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	BSTR bstrRuleName = NULL;
    BSTR bstrDescription = NULL;
    BSTR bstrCondition = NULL;
    BSTR bstrAction = NULL;
    BSTR bstrImplementationProgID = NULL;
    long lShowWindow;

	RuleSet->GetRuleDetailsByID(
				RuleId.c_str(),
				&bstrRuleName,
				&bstrDescription,
				&bstrCondition,
				&bstrAction,
				&bstrImplementationProgID,
				&lShowWindow);

	wstring RuleName = Input[L"Name"];
	if(RuleName.empty())
	{
		RuleName = (WCHAR*)_bstr_t(bstrRuleName);
	}
	SysFreeString(bstrRuleName);
	
	wstring Description = Input[L"Desc"];
	if(Description.empty())
	{
		Description = (WCHAR*)_bstr_t(bstrDescription);
	}
	SysFreeString(bstrDescription);

	wstring Condition = Input[L"Cond"];
	if(Condition.empty())
	{
		Condition = (WCHAR*)_bstr_t(bstrCondition);
	}
	else
	{
		ConvertSeperatorsToTabs(Condition);
	}
	SysFreeString(bstrCondition);

	wstring Action = Input[L"Action"];
	if(Action.empty())
	{
		Action = (WCHAR*)_bstr_t(bstrAction);
	}
	else
	{
		ConvertSeperatorsToTabs(Action);
	}
	SysFreeString(bstrAction);
	
	wstring Implementation = (WCHAR*)_bstr_t(bstrImplementationProgID);
	SysFreeString(bstrImplementationProgID);

	wcs = Input[L"ShowWindow"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lShowWindow = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lShowWindow = 0;
		}
		else
		{
			wprintf(L"Failed : ShowWindow should be either true or false");
			return -1;
		}
	}

	RuleSet->Update(
				RuleId.c_str(),
				RuleName.c_str(),
				Description.c_str(),
				Condition.c_str(),
				Action.c_str(),
				Implementation.c_str(),
				lShowWindow);

	wprintf(L"Rule was updated successfuly\n");			
	return 0;
}

HRESULT DeleteRule(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Rule Id must be given\n");
		return -1;
	}

	RuleSet->Delete(RuleId.c_str());

	wprintf(L"Rule was deleted successfuly\n");
	return 0;

}

HRESULT GetTriggersList(wstring MachineName, CInputParams& )
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();
	

	wstring Triggers;
	long NumberOfTriggers = TriggerSet->GetCount();
	for(long l = 0; l < NumberOfTriggers; l++)
	{
		BSTR bstrTriggerID = NULL;
		BSTR bstrTriggerName = NULL;
		BSTR bstrQueueName = NULL;
        long lNumberOfRules;
        long lEnabled;
        long lSerialized;
		MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

		TriggerSet->GetTriggerDetailsByIndex(
							l,
							&bstrTriggerID,
							&bstrTriggerName,
							&bstrQueueName,
							&SystemQueue,
							&lNumberOfRules,
							&lEnabled,
							&lSerialized,
							NULL);

		Triggers += (WCHAR*)_bstr_t(bstrTriggerID);
		Triggers += L"\t";
		Triggers += (WCHAR*)_bstr_t(bstrTriggerName);
		Triggers += L"\t\t";

		if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_NONE)
		{
			Triggers += (WCHAR*)_bstr_t(bstrQueueName);
		}
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL)
		{
			Triggers += L"Journal";	
		}
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER)
		{
			Triggers += L"DeadLetter";	
		}	
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT)
		{
			Triggers += L"DeadXact";	
		}
		Triggers += L"\n";

		SysFreeString(bstrTriggerID);
		SysFreeString(bstrTriggerName);
		SysFreeString(bstrQueueName);
	}

	wprintf(L"Total number of Triggers is:%d\n", NumberOfTriggers);
	if(NumberOfTriggers > 0)
	{
		wprintf(L"The list of Triggers' IDs is:\n");
		wprintf(L"TriggerID\t\t\t\tTriggerName\tTriggerQueuePath\n");
		wprintf(L"---------\t\t\t\t-----------\t----------------\n");
		wprintf(L"%s", Triggers.c_str());
	}
	return 0;
}

HRESULT GetRulesList(wstring MachineName, CInputParams& )
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();
	

	wstring Rules;
	long NumberOfRules = RuleSet->GetCount();
	for(long l = 0; l < NumberOfRules; l++)
	{
		BSTR bstrRuleID = NULL;
		BSTR bstrRuleName = NULL;
		BSTR bstrDescription = NULL;
		BSTR bstrCondition = NULL;
		BSTR bstrAction = NULL;
		BSTR bstrImplementationProgID = NULL;
		long lShowWindow = 0;

		RuleSet->GetRuleDetailsByIndex(
							l,
							&bstrRuleID,
							&bstrRuleName,
							&bstrDescription,
							&bstrCondition,
							&bstrAction,
							&bstrImplementationProgID,
							&lShowWindow );

		Rules += (WCHAR*)_bstr_t(bstrRuleID);
		Rules += L"\t";
		Rules += (WCHAR*)_bstr_t(bstrRuleName);
		Rules += L"\t\t";
		Rules += (WCHAR*)_bstr_t(bstrDescription);
		Rules += L"\n";

		SysFreeString(bstrRuleID);
		SysFreeString(bstrRuleName);
		SysFreeString(bstrDescription);
		SysFreeString(bstrCondition);
		SysFreeString(bstrAction);
		SysFreeString(bstrImplementationProgID);		
	}

	wprintf(L"Total number of rules is:%d\n", NumberOfRules);
	if(NumberOfRules > 0)
	{
		wprintf(L"The list of rules' IDs is:\n");
		wprintf(L"RuleId\t\t\t\t\tRuleName\tDescription\n");
		wprintf(L"------\t\t\t\t\t--------\t-----------\n");
		wprintf(L"%s", Rules.c_str());
	}
	return 0;
}

HRESULT GetTrigger(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Failed : Trigger Id must be given\n");
		return -1;
	}

	BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
	long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

	TriggerSet->GetTriggerDetailsByID(
					TriggerId.c_str(),
					&bstrTriggerName,
					&bstrQueuePath,
					&SystemQueue,
					&lNumberOfRules,
					&lEnabled,
					&lSerialized,
					NULL);

	wstring AttachedRules;
	for(long l = 0; l < lNumberOfRules; l++)
	{
		BSTR bstrRuleID = NULL;
		BSTR bstrRuleName = NULL;
		BSTR bstrDescription = NULL;
		BSTR bstrCondition = NULL;
		BSTR bstrAction = NULL;
		BSTR bstrImplementationProgID = NULL;
		long lShowWindow = 0;

		TriggerSet->GetRuleDetailsByTriggerID (
							TriggerId.c_str(),
							l,
							&bstrRuleID,
							&bstrRuleName,
							&bstrDescription,
							&bstrCondition,
							&bstrAction,
							&bstrImplementationProgID,
							&lShowWindow );

		AttachedRules += L"\t";
		AttachedRules += (WCHAR*)_bstr_t(bstrRuleID);
		AttachedRules += L"\n";

		SysFreeString(bstrRuleID);
		SysFreeString(bstrRuleName);
		SysFreeString(bstrDescription);
		SysFreeString(bstrCondition);
		SysFreeString(bstrAction);
		SysFreeString(bstrImplementationProgID);
	}

	wprintf(L"Details for trigger with Id %s are:\n", TriggerId.c_str());
	wprintf(L"Trigger Name: %s\n", (WCHAR*)_bstr_t(bstrTriggerName));

	wstring QueueName;
	if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_NONE)
	{
		QueueName += (WCHAR*)_bstr_t(bstrQueuePath);
	}
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL)
	{
		QueueName += L"Journal";	
	}
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER)
	{
		QueueName += L"DeadLetter";	
	}	
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT)
	{
		QueueName += L"DeadXact";	
	}
	wprintf(L"Queue Path: %s\n", QueueName.c_str());

	if(lEnabled == 0)
	{
		wprintf(L"Trigger is not Enabled\n");
	}
	else
	{
		wprintf(L"Trigger is Enabled\n");
	}

	if(lSerialized == 0)
	{
		wprintf(L"Trigger is not Serialized\n");
	}
	else
	{
		wprintf(L"Trigger is Serialized\n");
	}

	wprintf(L"Number of attached rules is: %d\n", lNumberOfRules);
	if(lNumberOfRules > 0)
	{
		wprintf(L"Attached rules are:\n");
		wprintf(L"%s", AttachedRules.c_str());
	}
	
	SysFreeString(bstrTriggerName);
	SysFreeString(bstrQueuePath);
	return 0;
}

HRESULT GetRule(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	BSTR bstrRuleName = NULL;
    BSTR bstrDescription = NULL;
    BSTR bstrCondition = NULL;
    BSTR bstrAction = NULL;
    BSTR bstrImplementationProgID = NULL;
    long lShowWindow = 0;

	RuleSet->GetRuleDetailsByID(
				RuleId.c_str(),
				&bstrRuleName,
				&bstrDescription,
				&bstrCondition,
				&bstrAction,
				&bstrImplementationProgID,
				&lShowWindow);

	wprintf(L"Details for rule with Id %s are:\n", RuleId.c_str());
	wprintf(L"Rule Name: %s\n", (WCHAR*)_bstr_t(bstrRuleName));
	wprintf(L"Description: %s\n", (WCHAR*)_bstr_t(bstrDescription));

	CStringTokens Cond;
	Cond.Parse(bstrCondition, L'\t');

	long lNumOfConds = Cond.GetNumTokens();
	wstring wcsCond;
	for(long l=0 ; l < lNumOfConds; l++)
	{
		_bstr_t bstrCurrCond;
		Cond.GetToken(l, bstrCurrCond);
		if(wcsCond.empty())
		{
			wcsCond = (WCHAR*)bstrCurrCond;
		}
		else
		{
			wcsCond += L" AND ";
			wcsCond += (WCHAR*)bstrCurrCond;
		}
	}

	wprintf(L"Condition is: %s\n", wcsCond.c_str());

	//print action
	CStringTokens Action;
	Action.Parse(bstrAction, L'\t');

	long lNumOfActionParams = Action.GetNumTokens();
	wstring wcsAction;
	for(l=0 ; l < lNumOfActionParams; l++)
	{
		_bstr_t bstrCurrActionParam;
		Action.GetToken(l, bstrCurrActionParam);
		if(wcsAction.empty())
		{
			wcsAction = (WCHAR*)bstrCurrActionParam;
		}
		else
		{
			wcsAction += L" ";
			wcsAction += (WCHAR*)bstrCurrActionParam;
		}
	}

	wprintf(L"Action is: %s\n", wcsAction.c_str());

	wprintf(L"Implementation prog id is: %s\n", (WCHAR*)_bstr_t(bstrImplementationProgID));
	
	if( lShowWindow == 0)
	{
		wprintf(L"ShowWindow is set to false\n");
	}
	else
	{
		wprintf(L"ShowWindow is set to true\n");
	}

	SysFreeString(bstrRuleName);
	SysFreeString(bstrDescription);
	SysFreeString(bstrCondition);
	SysFreeString(bstrAction);
	SysFreeString(bstrImplementationProgID);

	return 0;
}


void ConvertSeperatorsToTabs(wstring& wcs)
{
	CStringTokens Tokens;
	Tokens.Parse(wcs.c_str(), L';');

	wcs = L"";

	long lNumOfTokens = Tokens.GetNumTokens();
	for(long l=0 ; l < lNumOfTokens; l++)
	{
		_bstr_t bstrCurr;
		Tokens.GetToken(l, bstrCurr);
		if(wcs.empty())
		{
			wcs = (WCHAR*)bstrCurr;
		}
		else
		{
			wcs += L"\t";
			wcs += (WCHAR*)bstrCurr;
		}
	}

}

void PrintUsage(MSMQTriggersRequest Request)
{
	switch(Request)
	{
	case REQUEST_UPDATE_CONFIG:
		wprintf(L"UpdateConfig	- updates the triggers' service configuration parameters\n");
		wprintf(L"Usage: trigadm /Request:UpdateConfig [/InitThreads:[] /MaxThreads:[] /BodySize:[] \n");		
		wprintf(L"InitThreads	-	Initial number of threads the service should use.optional.\n");
		wprintf(L"MaxThreads	-	Max number of threads the service should use.optional.\n");
		wprintf(L"BodySize	-	default message body size.\n");
		break;

	case REQUEST_GET_CONFIG:
		wprintf(L"GetConfig	-	prints the triggers' service configuration parameters\n");
		wprintf(L"Usage: trigadm /Request:GetConfig\n");		
		break;

	case REQUEST_ADD_TRIGGER:
		wprintf(L"AddTrigger	-	adds a new trigger\n");
		wprintf(L"Usage: trigadm /Request:AddTrigger [/Machine:[]] /Name:[] /Queue:[] [/Enabled:[true|false] /Serailized:[true|false]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"Name	-	trigger name. Must be given.\n");
		wprintf(L"Queue	-	trigger queue. Must be given.\n");
		wprintf(L"Enabled	-	Whether or not the trigger definition is enabled.optional.\n");
		wprintf(L"Serialized -	Whether or not the trigger queue is serialized.optional.\n");
		break;

	case REQUEST_UPDATE_TRIGGER:
		wprintf(L"UpdateTrigger	-	updates a trigger\n");
		wprintf(L"Usage: trigadm /Request:UpdateTrigger [/Machine:[]] /ID:[] [/Name:[] /Queue:[] /Enabled:[true|false] /Serailized:[true|false]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	trigger id. Must be given.\n");
		wprintf(L"Name	-	trigger name. optional.\n");
		wprintf(L"Queue	-	trigger queue. optional.\n");
		wprintf(L"Enabled	-	Whether or not the trigger definition is enabled.optional.\n");
		wprintf(L"Serialized -	Whether or not the trigger queue is serialized.optional.\n");

		break;

	case REQUEST_DELETE_TRIGGER:
		wprintf(L"DeleteTrigger	-	deletes a trigger\n");
		wprintf(L"Usage: trigadm /Request:DeleteTrigger [/Machine:[]] /ID:[]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	trigger id. Must be given.\n");
		break;

	case REQUEST_ATTACH_RULE:
		wprintf(L"AttachRule	-	attaches a rule to a trigger\n");
		wprintf(L"Usage: trigadm /Request:AttachRule [/Machine:[]] /TriggerID:[] /RuleId:[] [/Priority:[]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"TriggerID	-	trigger id. Must be given.\n");
		wprintf(L"RuleID	-	rule id. Must be given.\n");
		wprintf(L"Priority	-	priority of the rule within the attached rules. Default is last.\n");
		break;

	case REQUEST_DETACH_RULE:
		wprintf(L"DetachRule	-	detaches a rule from a trigger\n");
		wprintf(L"Usage: trigadm /Request:DetachRule [/Machine:[]] /TriggerID:[] /RuleId:[]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"TriggerID	-	trigger id. Must be given.\n");
		wprintf(L"RuleID	-	rule id. Must be given.\n");
		break;

	case REQUEST_ADD_RULE:
		wprintf(L"AddRule	-	adds a new rule\n");
		wprintf(L"Usage: trigadm /Request:AddRule [/Machine:[]] /Name:[] [/Desc:[] /Cond:[] /Action:[] /ShowWindow:[true|false]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"Name	-	rule name. Must be given.\n");
		wprintf(L"Desc	- rule description. optional.\n");
		wprintf(L"Cond	- A string representing rule conditions. optional\n");
		wprintf(L"	condition1;condition2;... , treated as AND between conditions.\n");
		wprintf(L"	Each condition can be one of the following:\n");
		wprintf(L"	$MSG_LABEL_CONTAINS=xyz\n");
		wprintf(L"	$MSG_LABEL_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"	$MSG_BODY_CONTAINS=xyz\n");	
		wprintf(L"	$MSG_BODY_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"	$MSG_PRIORITY_EQUALS=2\n");
		wprintf(L"	$MSG_PRIORITY_DOES_NOT_EQUAL=2\n");
		wprintf(L"	$MSG_PRIORITY_GREATER_THAN=2\n");
		wprintf(L"	$MSG_PRIORITY_LESS_THAN=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_EQUALS=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_DOES_NOT_EQUAL=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_GREATER_THAN=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_LESS_THAN=2\n");
		wprintf(L"	$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"	$MSG_SRCMACHINEID_DOES_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"Action - a string representing the rule action.optional\n");
		wprintf(L"	EXE;exe path;command line params\n");
		wprintf(L"	COM;prog-id;method name;method arguments\n");
		wprintf(L"	Params and Arguments can be one of the following:\n");
		wprintf(L"	$MSG_ID\n");
		wprintf(L"	$MSG_LABEL\n");
		wprintf(L"	$MSG_BODY\n");
		wprintf(L"	$MSG_BODY_AS_STRING\n");
		wprintf(L"	$MSG_PRIORITY\n");
		wprintf(L"	$MSG_ARRIVEDTIME\n");
		wprintf(L"	$MSG_SENTTIME\n");
		wprintf(L"	$MSG_CORRELATION_ID\n");
		wprintf(L"	$MSG_APPSPECIFIC\n");
		wprintf(L"	$MSG_QUEUE_PATHNAME\n");
		wprintf(L"	$MSG_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_RESPONSE_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_ADMIN_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_SRCMACHINEID\n");
		wprintf(L"	$TRIGGER_NAME\n");
		wprintf(L"	$TRIGGER_ID\n");
		wprintf(L"	\"literal string\"\n");
		wprintf(L"	literal number\n");
		wprintf(L"ShowWindow	-	show application window. appiles only when action type is exe. optional.\n");
		break;

	case REQUEST_UPDATE_RULE:
		wprintf(L"UpdateRule	-	updates a rule\n");
		wprintf(L"Usage: trigadm /Request:UpdateRule [/Machine:[]] /ID:[] [/Name:[] /Desc:[] /Cond:[] /Action:[] /ShowWindow:[true|false]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	rule id. Must be given.\n");
		wprintf(L"Name	-	rule name. optional.\n");
		wprintf(L"Desc	- rule description. optional.\n");
		wprintf(L"Cond	- A string representing rule conditions. optional\n");
		wprintf(L"	condition1;condition2;... , treated as AND between conditions.\n");
		wprintf(L"	Each condition can be one of the following:\n");
		wprintf(L"	$MSG_LABEL_CONTAINS=xyz\n");
		wprintf(L"	$MSG_LABEL_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"	$MSG_BODY_CONTAINS=xyz\n");	
		wprintf(L"	$MSG_BODY_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"	$MSG_PRIORITY_EQUALS=2\n");
		wprintf(L"	$MSG_PRIORITY_DOES_NOT_EQUAL=2\n");
		wprintf(L"	$MSG_PRIORITY_GREATER_THAN=2\n");
		wprintf(L"	$MSG_PRIORITY_LESS_THAN=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_EQUALS=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_DOES_NOT_EQUAL=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_GREATER_THAN=2\n");
		wprintf(L"	$MSG_APPSPECIFIC_LESS_THAN=2\n");
		wprintf(L"	$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"	$MSG_SRCMACHINEID_DOES_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"Action - a string representing the rule action.optional\n");
		wprintf(L"	EXE;exe path;command line params\n");
		wprintf(L"	COM;prog-id;method name;method arguments\n");
		wprintf(L"	Params and Arguments can be one of the following:\n");
		wprintf(L"	$MSG_ID\n");
		wprintf(L"	$MSG_LABEL\n");
		wprintf(L"	$MSG_BODY\n");
		wprintf(L"	$MSG_BODY_AS_STRING\n");
		wprintf(L"	$MSG_PRIORITY\n");
		wprintf(L"	$MSG_ARRIVEDTIME\n");
		wprintf(L"	$MSG_SENTTIME\n");
		wprintf(L"	$MSG_CORRELATION_ID\n");
		wprintf(L"	$MSG_APPSPECIFIC\n");
		wprintf(L"	$MSG_QUEUE_PATHNAME\n");
		wprintf(L"	$MSG_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_RESPONSE_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_ADMIN_QUEUE_FORMATNAME\n");
		wprintf(L"	$MSG_SRCMACHINEID\n");
		wprintf(L"	$TRIGGER_NAME\n");
		wprintf(L"	$TRIGGER_ID\n");
		wprintf(L"	\"literal string\"\n");
		wprintf(L"	literal number\n");
		wprintf(L"ShowWindow	-	appiles only when action type is exe. optional.\n");
		break;

	case REQUEST_DELETE_RULE:
		wprintf(L"DeleteRule	-	deletes a rule\n");
		wprintf(L"Usage: trigadm /Request:DeleteRule [/Machine:[]] /ID:[]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	rule id. Must be given.\n");
		break;

	case REQUEST_GET_TRIGGERS_LIST:
		wprintf(L"GetTriggersList	-	prints the list of triggers\n");
		wprintf(L"Usage: trigadm /Request:GetTriggersList [/Machine:[]]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		break;

	case REQUEST_GET_RULES_LIST:
		wprintf(L"GetRulesList	-	prints the list of rules\n");
		wprintf(L"Usage: trigadm /Request:GetRulesList [/Machine:[]]\n");		
		wprintf(L"Machine	-	rules store machine name. Default is local machine.\n");
		break;

	case REQUEST_GET_TRIGGER:
		wprintf(L"GetTrigger	-	prints trigger's detailes\n");
		wprintf(L"Usage: trigadm /Request:GetTrigger [/Machine:[]] /ID:[]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	trigger id. Must be given.\n");
		break;

	case REQUEST_GET_RULE:
		wprintf(L"GetRule	-	prints rule's details\n");
		wprintf(L"Usage: trigadm /Request:GetRule [/Machine:[]] /ID:[]\n");		
		wprintf(L"Machine	-	triggers store machine name. Default is local machine.\n");
		wprintf(L"ID	-	rule id. Must be given.\n");
		break;

	case REQUEST_ILLEGAL:
	case REQUEST_NONE:
		{
			wprintf(L"trigadm is an admin tool for management of the trigger store\n");
			wprintf(L"Usage: trigadm /request:[]\n");	
			wprintf(L"request can be one of the following:\n");
			wprintf(L"GetConfig		- prints the triggers' service configuration parameters\n");
			wprintf(L"UpdateConfig		- updates the triggers' service configuration parameters\n");
			wprintf(L"AddTrigger		- adds a new trigger\n");
			wprintf(L"UpdateTrigger		- updates a trigger\n");
			wprintf(L"DeleteTrigger		- deletes a trigger\n");
			wprintf(L"GetTrigger		- prints trigger details\n");
			wprintf(L"AddRule			- adds a new rule\n");
			wprintf(L"UpdateRule		- updates a rule\n");
			wprintf(L"DeleteRule		- deletes a rule\n");
			wprintf(L"GetRule			- prints rule details\n");
			wprintf(L"AttachRule		- attaches a rule to a trigger\n");
			wprintf(L"DetachRule		- detaches a rule from a trigger\n");
			wprintf(L"GetTriggersList		- prints the list of triggers\n");
			wprintf(L"GetRulesList		- prints the list of rules\n");
			return;
		}
		break;

	default:
		ASSERT(0);
	}
		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\testlookupidinvokation.cpp ===
// testLookupidInvokation.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f testLookupidInvokationps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "testLookupidInvokation.h"

#include "testLookupidInvokation_i.c"
#include "checkTest.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_checkTest, CcheckTest)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TESTLOOKUPIDINVOKATIONLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xactproj.rc
//
#define IDR_XACTOBJ                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\testrule\main.cpp ===
#include <libpch.h>
//#include <comdef.h>

#import "mqtrig.tlb" no_namespace 

using namespace std;

const LPCWSTR xLableCondition[] = {
    L"\t",
    L"$MSG_LABEL_CONTAINS=HelloWorld\t",
    L"$MSG_LABEL_DOES_NOT_CONTAIN=HelloWorld\t",
};

const LPCWSTR xBodyCondition[] = {
    L"\t",
    L"$MSG_BODY_CONTAINS=HelloWorld\t",
    L"$MSG_BODY_DOES_NOT_CONTAIN=HelloWorld\t",
};

const LPCWSTR xPriorityCondition[] = {
    L"\t",
    L"$MSG_PRIORITY_EQUALS=2\t",
	L"$MSG_PRIORITY_NOT_EQUAL=2\t",
    L"$MSG_PRIORITY_GREATER_THAN=2\t",
    L"$MSG_PRIORITY_LESS_THAN=2\t"
};

const LPCWSTR xAppspecificCondition[] = {
    L"\t",
    L"$MSG_APPSPECIFIC_EQUALS=2\t",
	L"$MSG_APPSPECIFIC_NOT_EQUAL=2\t",
    L"$MSG_APPSPECIFIC_GREATER_THAN=2\t",
    L"$MSG_APPSPECIFIC_LESS_THAN=2\t"
};

const LPCWSTR xSrcmachineCondition[] = {
    L"\t"
    L"$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A",
    L"$MSG_SRCMACHINEID_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A",
};

void BuildRuleCondition(
    wostringstream& ruleCond
    )
{
    ruleCond << xLableCondition[rand() % TABLE_SIZE(xLableCondition)];
    ruleCond << xBodyCondition[rand() % TABLE_SIZE(xBodyCondition)];
    ruleCond << xPriorityCondition[rand() % TABLE_SIZE(xPriorityCondition)];
    ruleCond << xAppspecificCondition[rand() % TABLE_SIZE(xAppspecificCondition)];
    ruleCond << xSrcmachineCondition[rand() % TABLE_SIZE(xSrcmachineCondition)];
}


void BuildRuleAction(
    wostringstream& ruleAction
    )
{
    ruleAction << L"EXE;c:\temp\try.exe;";
	ruleAction << (rand() %2 == 0) ? L"$MSG_ID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_LABEL;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_BODY;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_BODY_AS_STRING;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_PRIORITY;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_ARRIVEDTIME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_SENTTIME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_CORRELATION_ID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_APPSPECIFIC;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_QUEUE_PATHNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_RESPONSE_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_ADMIN_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_SRCMACHINEID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$TRIGGER_NAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$TRIGGER_ID;" : L"";
}


void CreateRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // Create rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        wostringstream ruleName;
        wostringstream ruleCond;
        wostringstream ruleAction;

        ruleName << L"Rule" << i;
        BuildRuleCondition(ruleCond);
        BuildRuleAction(ruleAction);

        RuleSet->Add(
                    ruleName.str().c_str(),
                    L"Test - Create Rule",
                    ruleCond.str().c_str(),
                    ruleAction.str().c_str(),
                    L"",
                    rand() %2,
                    &ruleIds[i]
                    );
        //wprintf(L"Success to add rule %ls, rule id = %s\n", ruleName.str().data(), static_cast<LPCWSTR>(ruleIds[i]));

    }
}


void UpdateRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // Update rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        wostringstream ruleName;
        wostringstream ruleCond;
        wostringstream ruleAction;

        ruleName << L"Update Rule" << i;
        BuildRuleCondition(ruleCond);
        BuildRuleAction(ruleAction);

        RuleSet->Update(
                    ruleIds[i],
                    ruleName.str().c_str(),
                    L"Test - Update Rule",
                    ruleCond.str().c_str(),
                    ruleAction.str().c_str(),
                    L"",
                    rand() %2
                    );

        //wprintf(L"Success to update rule %s, rule id = %s\n", ruleName.str().data(), static_cast<LPCWSTR>(ruleIds[i]));

    }

}


void RetrieveRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // retrieve rules
    //
    for (DWORD i = NoOfRules; i > 0; i--)
    {
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCond = NULL;
        BSTR ruleAction = NULL;
        BSTR ruleProg = NULL;
        long ruleShowWindow = NULL;

        RuleSet->GetRuleDetailsByID(
                    ruleIds[i-1],
                    &ruleName,
                    &ruleDescription,
                    &ruleCond,
                    &ruleAction,
                    &ruleProg,
                    &ruleShowWindow
                    );


        /*
        wprintf(L"Success to retrieve values of rule = %s\n", static_cast<LPCWSTR>(ruleIds[i-1]));
        wprintf(L"\trule name = %s\n", static_cast<LPCWSTR>(ruleName));
        wprintf(L"\trule Description = %s\n", static_cast<LPCWSTR>(ruleDescription));
        wprintf(L"\trule Condition = %s\n", static_cast<LPCWSTR>(ruleCond));
        wprintf(L"\trule Action = %s\n", static_cast<LPCWSTR>(ruleAction));
        wprintf(L"\trule Program = %s\n", static_cast<LPCWSTR>(ruleProg));
        */

        SysFreeString(ruleName);
        SysFreeString(ruleDescription);
        SysFreeString(ruleCond);
        SysFreeString(ruleAction);
        SysFreeString(ruleProg);
    }
}


void DeleteRules(BSTR* ruleIds, DWORD NoOfRules)
{
    IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");

    RuleSet->Init(L"");
    RuleSet->Refresh();
    //
    // Delete rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        RuleSet->Delete(ruleIds[i]);
        // wprintf(L"Success to delete rule: %s\n", static_cast<LPCWSTR>(ruleIds[i]));
    }

    try
    {
        RuleSet->Delete(ruleIds[1]);
    }
    catch(const _com_error&)
    {
        return;
    }

    //
    // delete of unexisiting rule shoule fail
    //
    throw exception();
}


void TestRuleOperation(BSTR* ruleIds, DWORD NoOfRules)
{
    IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");

    try
    {
        RuleSet->Init(L"");
        RuleSet->Refresh();
    
        CreateRules(RuleSet, ruleIds, NoOfRules);
        UpdateRules(RuleSet, ruleIds, NoOfRules);
        RetrieveRules(RuleSet, ruleIds, NoOfRules);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to execute rule operation. ErrorMsg: %s. Error: 0x%x", e.ErrorMessage(), e.Error()); 
        throw;
    }
}


void DeleteTriggers(BSTR* triggersIds, DWORD NoOfTriggers)
{
    IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");

    TriggerSet->Init(L"");
    TriggerSet->Refresh();

    //
    // Delete rules
    //
    for (DWORD i = 0; i < NoOfTriggers; ++i)
    {
        TriggerSet->DeleteTrigger(triggersIds[i]);
        //wprintf(L"Success to delete trigger: %s\n", static_cast<LPCWSTR>(triggersIds[i]));
    }

    try
    {
        TriggerSet->DeleteTrigger(triggersIds[1]);
    }
    catch(const _com_error&)
    {
        return;
    }

    //
    // delete of unexisiting rule shoule fail
    //
    throw exception();
}

void     
CreateTriggers(
    IMSMQTriggerSetPtr& TriggerSet,
    const BSTR* ruleIds, 
    DWORD noOfRules,
    BSTR* triggerIds, 
    DWORD noOfTriggers
    )
{
    for (DWORD i = 0; i < noOfTriggers; ++i)
    {
        wostringstream triggerName;


        triggerName << L"Trigger" << i;

        TriggerSet->AddTrigger(
                        triggerName.str().c_str(),
                        L".\\q1",
                        SYSTEM_QUEUE_NONE,
                        rand() %2,
                        rand() %2,
						PEEK_MESSAGE,
                        &triggerIds[i]
                        );

        //
        // Attached rule to trigger
        //
        DWORD NoOfAttachedRule = ( rand() % noOfRules ) + 1;
        DWORD ruleIndex = rand() % noOfRules;
        for (DWORD j = 0; j < NoOfAttachedRule; ++j)
        {
            DWORD rulePriority = rand() % (j + 1);

            TriggerSet->AttachRule(triggerIds[i], ruleIds[(ruleIndex+j) % noOfRules], rulePriority);
        }
            
        try
        {
            //
            // try to add same rule twice
            //
            TriggerSet->AttachRule(triggerIds[i], ruleIds[ruleIndex], 0);
            wprintf(L"Test Failed. Successed to attach the same rule twice");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }

        //
        // detach rule
        //
        TriggerSet->DetachRule(triggerIds[i], ruleIds[ruleIndex]);

        //
        // attach and detach of invalid rule
        //
        try
        {
            TriggerSet->AttachRule(triggerIds[i], L"52601E36-6ED9-4e41-A7D6-B6B7AEA38348", 0);
            wprintf(L"Test Failed. Success to attach un-exisiting rule");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }
        try
        {
            TriggerSet->DetachRule(triggerIds[i], L"52601E36-6ED9-4e41-A7D6-B6B7AEA38348");
            wprintf(L"Test Failed. Success to detach un-exisiting rule");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }
    }
}


void     
TestTriggerOperation(
    const BSTR* ruleIds, 
    DWORD noOfRules,
    BSTR* triggerIds, 
    DWORD noOfTriggers
    )
{
    IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");

    try
    {
        TriggerSet->Init(L"");
        TriggerSet->Refresh();
    
        long NoOfExistingTrigger = TriggerSet->GetCount();

        CreateTriggers(TriggerSet, ruleIds, noOfRules, triggerIds, noOfTriggers);
        
        if (numeric_cast<DWORD>(TriggerSet->GetCount()) != NoOfExistingTrigger + noOfTriggers)
        {
            wprintf(L"Failed to create all the requested triggers\n");
            throw exception();
        }

        TriggerSet->DetachAllRules(triggerIds[0]);


    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to execute rule operation. ErrorMsg: %s. Error: 0x%x", e.ErrorMessage(), e.Error()); 
        throw;
    }
}




int __cdecl wmain(int , WCHAR**)
{
    try
    {
	    HRESULT hr = CoInitialize(NULL);
	    if(FAILED(hr))
	    {
		    wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		    return -1;
	    }

        BSTR ruleIds[12] = { 0 };
        BSTR triggerIds[1] = { 0 };

        TestRuleOperation(ruleIds, TABLE_SIZE(ruleIds));
        TestTriggerOperation(ruleIds, TABLE_SIZE(ruleIds), triggerIds, TABLE_SIZE(triggerIds));

        DeleteTriggers(triggerIds, TABLE_SIZE(triggerIds));
        DeleteRules(ruleIds, TABLE_SIZE(ruleIds));

        //
        // free BSTR
        //
        for (DWORD i = 0; i < TABLE_SIZE(ruleIds); ++i)
        {
            SysFreeString(ruleIds[i]);
        }

        for (DWORD i = 0; i < TABLE_SIZE(triggerIds); ++i)
        {
            SysFreeString(triggerIds[i]);
        }

        CoUninitialize();
        
        wprintf(L"Test pass successfully\n");
        return 0;
    }
    catch(const exception&)
    {
    }
    catch(const _com_error&)
    {
    }

    wprintf(L"Test Failed\n");
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\trigadm\trigadm.h ===
class CInputParams;

enum MSMQTriggersRequest
{
	REQUEST_NONE = -2,
	REQUEST_ILLEGAL = -1,
	REQUEST_UPDATE_CONFIG = 0,
	REQUEST_GET_CONFIG,
	REQUEST_ADD_TRIGGER,
	REQUEST_UPDATE_TRIGGER,
	REQUEST_DELETE_TRIGGER,
	REQUEST_ATTACH_RULE,
	REQUEST_DETACH_RULE,
	REQUEST_ADD_RULE,
	REQUEST_UPDATE_RULE,
	REQUEST_DELETE_RULE,
	REQUEST_GET_TRIGGERS_LIST,
	REQUEST_GET_RULES_LIST,
	REQUEST_GET_TRIGGER,
	REQUEST_GET_RULE,
	NUM_OF_REQUESTS,
};


MSMQTriggersRequest IsLegalRequest(std::wstring wcsRequest);

void PrintUsage(MSMQTriggersRequest Request);

HRESULT UpdateConfig(CInputParams& Input);
HRESULT GetConfig();
HRESULT AddTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT UpdateTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT DeleteTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT AttachDetachRule(std::wstring MachineName, CInputParams& Input, bool fAttach);
HRESULT AddRule(std::wstring MachineName, CInputParams& Input);
HRESULT UpdateRule(std::wstring MachineName, CInputParams& Input);
HRESULT DeleteRule(std::wstring MachineName, CInputParams& Input);
HRESULT GetTriggersList(std::wstring MachineName, CInputParams& Input);
HRESULT GetRulesList(std::wstring MachineName, CInputParams& Input);
HRESULT GetTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT GetRule(std::wstring MachineName, CInputParams& Input);

void ConvertSeperatorsToTabs(std::wstring& wcs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED_)
#define AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactobj.cpp ===
// XactObj.cpp : Implementation of CXactObj
#include "stdafx.h"
#include "Xactproj.h"
#include "XactObj.h"

/////////////////////////////////////////////////////////////////////////////
// CXactObj


STDMETHODIMP CXactObj::XactFunc()
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactobj.h ===
// XactObj.h : Declaration of the CXactObj

#ifndef __XACTOBJ_H_
#define __XACTOBJ_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CXactObj
class ATL_NO_VTABLE CXactObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXactObj, &CLSID_XactObj>,
	public IDispatchImpl<IXactObj, &IID_IXactObj, &LIBID_XACTPROJLib>
{
public:
	CXactObj()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_XACTOBJ)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXactObj)
	COM_INTERFACE_ENTRY(IXactObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IXactObj
public:
	STDMETHOD(XactFunc)();
};

#endif //__XACTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\clusfunc.h ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Nela Karpel
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 08/08/00 | nelak     | 
//
//*****************************************************************************
#ifndef ClusFunc_INCLUDED 
#define ClusFunc_INCLUDED


bool
FindTriggersServiceName(
	void
	);


LPCWSTR
GetTrigParamRegPath(
	void
	);


bool 
ClusteredService(
	LPCWSTR wzServiceName
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\cpropbag.cpp ===
//*****************************************************************************
//
// Class Name  : CMSMQPropertyBag
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implementation of the MSMQPropertyBag COM component. This 
//               component behaves very much like the standard VB property bag
//               object. It is used to transport message properties into the 
//               IMSMQRuleHandler interface.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "mqsymbls.h"

//
// Include the definions for standard functions and definitions.
//
#include "stdfuncs.hpp"

#include "mqtrig.h"
#include "cpropbag.hpp"

#include "cpropbag.tmh"

//*****************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard interface for error info support.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQPropertyBag
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//*****************************************************************************
//
// Method      : Constructor 
//
// Description : Creates an empty property bag.
//
//*****************************************************************************
CMSMQPropertyBag::CMSMQPropertyBag()
{
	m_pUnkMarshaler = NULL;
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Destroys the property bag - and it's contents.
//
//*****************************************************************************
CMSMQPropertyBag::~CMSMQPropertyBag()
{
	PROPERTY_MAP::iterator i = m_mapPropertyMap.begin();
	VARIANT * pvStoredPropertyValue = NULL;

	while ((!m_mapPropertyMap.empty()) && (i != m_mapPropertyMap.end()) )
	{
		pvStoredPropertyValue  = (VARIANT*)(*i).second;

		VariantClear(pvStoredPropertyValue);

		// This should never be NULL
		ASSERT(pvStoredPropertyValue != NULL);

		delete pvStoredPropertyValue;
		
		i = m_mapPropertyMap.erase(i);
	}
}

//*****************************************************************************
//
// Method      : Write
//
// Description : Stores a named property value in the property bag. If a 
//               property by the same name already exists in the bag, the write
//               will fail, and this method will return E_FAIL
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::Write(BSTR sPropertyName, VARIANT vPropertyValue)
{
	try
	{
		_bstr_t bstrPropertyName = sPropertyName;
		wstring sPropName = (wchar_t*)bstrPropertyName; // _bstr_t to STL string class

		ASSERT(SysStringLen(sPropertyName) > 0);

		// Allocate a new variant
		//
		VARIANT * pvNewPropertyValue = new VARIANT;
	
		//
		// Initialise and copy the new variant if allocated OK
		//
		VariantInit(pvNewPropertyValue);

		HRESULT hr = VariantCopy(pvNewPropertyValue,&vPropertyValue);

		if SUCCEEDED(hr)
		{
			m_mapPropertyMap.insert(PROPERTY_MAP::value_type(sPropName,pvNewPropertyValue));
			return S_OK;
		}

		TrERROR(Tgo, "Failed to copy the a variant value into the property bag. Error 0x%x",hr);
		return E_FAIL;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to copy the a variant value into the property bag due to low resource.");
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//*****************************************************************************
//
// Method      : Read
//
// Description : Returns a property value from the property bad, using the 
//               supplied property name as the key.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::Read(BSTR sPropertyName, VARIANT *pvPropertyValue)
{
	HRESULT hr = S_OK;
	PROPERTY_MAP::iterator i;
	_bstr_t bstrPropertyName = sPropertyName;
	wstring sPropName = (wchar_t*)bstrPropertyName; // _bstr_t to STL string class

	// Assert parameters
	ASSERT(pvPropertyValue != NULL);
	ASSERT(SysStringLen(sPropertyName) > 0);

	// Initialise the return value and temp variant
	VariantInit(pvPropertyValue);

	// Attempt to find the named queuue
	i = m_mapPropertyMap.find(sPropName);

	if ((i == m_mapPropertyMap.end()) || (m_mapPropertyMap.empty()))
	{
		// No value found - set variant to VT_ERROR and set a failed HRESULT
		pvPropertyValue->vt = VT_ERROR;

		hr = E_FAIL;
	}
	else
	{
		// Assign the found value 
		ASSERT((*i).second != NULL);

		hr = VariantCopy(pvPropertyValue,(VARIANT*)(*i).second);
	}

	return hr;
}


//*****************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of items currently in the property bag.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::get_Count(long *pVal)
{
	ASSERT(pVal != NULL);

	(*pVal) = numeric_cast<long>(m_mapPropertyMap.size());

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactproj.cpp ===
// xactproj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xactprojps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xactproj.h"

#include "xactproj_i.c"
#include "XactObj.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_XactObj, CXactObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XACTPROJLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_)
#define AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\cpropbag.hpp ===
//*****************************************************************************
//
// Class Name  : CMSMQPropertyBag
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Header file for the CMSMQPropertyBag class. This 
//               class is used to transport name-value pairs between
//               components.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQPROPERTYBAG_H_
#define __MSMQPROPERTYBAG_H_

#include "resource.h"       // main symbols

#pragma warning(disable:4786)

// Define the name of this object as it will appear in the log
#define THIS_OBJECT_NAME   _T("IMSMQPropertyBag")


using namespace std;

// Define a new type - a 2D array of named variants.
typedef map<wstring,VARIANT*, less<wstring> > PROPERTY_MAP;

class ATL_NO_VTABLE CMSMQPropertyBag : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSMQPropertyBag, &CLSID_MSMQPropertyBag>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQPropertyBag, &IID_IMSMQPropertyBag, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQPropertyBag();
		~CMSMQPropertyBag();

		DECLARE_REGISTRY_RESOURCEID(IDR_IMSMQPROPERTYBAG)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQPropertyBag)
			COM_INTERFACE_ENTRY(IMSMQPropertyBag)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		// ISupportsErrorInfo
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

		// this is the map structure that holds property values (as variants)
		PROPERTY_MAP m_mapPropertyMap;

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(Read)(/*[in]*/ BSTR sPropertyName , /*[out]*/ VARIANT * pvPropertyValue);
		STDMETHOD(Write)(/*[in]*/ BSTR sPropertyName,  /*[in]*/ VARIANT vPropertyValue);
};

#endif //__MSMQPROPERTYBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\mqtrig_i_.c ===
#include <mqtrig_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\idspprxy.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CDispatchInterfaceProxy_INCLUDED 
#define CDispatchInterfaceProxy_INCLUDED

#include <windows.h> 
#include <windowsx.h> 
#include <stdarg.h>   
 
class CDispatchInterfaceProxy  
{

	private :

		IDispatch * m_pDisp;

	public:
		CDispatchInterfaceProxy();
		~CDispatchInterfaceProxy();

		HRESULT CreateObjectFromProgID(BSTR bstrProgID);
		HRESULT InvokeMethod(BSTR bstrMethodName,DISPPARAMS * pArguments, VARIANT* pvResult);

	private :

		HRESULT CreateObject(LPOLESTR pszProgID, IDispatch FAR* FAR* ppdisp) ;
		HRESULT __cdecl Invoke(LPDISPATCH pdisp,WORD wFlags,LPVARIANT pvRet,EXCEPINFO FAR* pexcepinfo,UINT FAR* pnArgErr,LPOLESTR pszName,LPCTSTR pszFmt,...);
		HRESULT CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn); 
		LPCTSTR GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt); 

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\clusfunc.cpp ===
//************************************************************************************
//
// File Name:  clusfunc.cpp
//
// Author: Nela Karpel	
// 
// Description : Implementation of functions that deal with clustered nodes
// 
//************************************************************************************#include <stdafx.h>

 
#include <stdafx.h>
#include <clusapi.h>
#include <resapi.h>
#include <mqtg.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include "stdfuncs.hpp"
#include "clusfunc.h"
#include "stddefs.hpp"
#include "mqtg.h"

#include "clusfunc.tmh"

//
// Type definitions of Cluster API functions that will be loaded
// if the machine we are working on is clustered. The functions will
// be used for resource enumeration on the cluster.
//
typedef HCLUSTER (WINAPI *OpenClus_fn) (LPCWSTR);
typedef HNODE (WINAPI *OpenClusNode_fn) (HCLUSTER, LPCWSTR);
typedef HCLUSENUM (WINAPI *ClusOpenEnum_fn) (HCLUSTER, DWORD);
typedef DWORD (WINAPI *ClusEnum_fn) (HCLUSENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef HRESOURCE (WINAPI *OpenClusRes_fn) (HCLUSTER, LPCWSTR);
typedef BOOL (WINAPI *GetNetName_fn) (HRESOURCE, LPWSTR, LPDWORD);
typedef DWORD (WINAPI *ClusResCtrl_fn) (HRESOURCE, HNODE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD);

//
// Type definitions of Cluster API function that will be 
// overloaded. Overload is needed for use of autohandles.
// Autohandles use Cluster API functions directly, but this
// module is not linked staticly with clusapi.lib.
//
typedef BOOL (WINAPI *CloseClus_fn) (HCLUSTER);
typedef DWORD (WINAPI *ClusCloseEnum_fn) (HCLUSENUM);
typedef BOOL (WINAPI *CloseClusRes_fn) (HRESOURCE);
typedef BOOL (WINAPI *CloseClusNode_fn) (HNODE);


static WCHAR s_wzServiceName[MAX_TRIGGERS_SERVICE_NAME];
static WCHAR s_wzTrigParamPathName[MAX_REGKEY_NAME_SIZE];

//
// Handle to clusapi.dll
//
CAutoFreeLibrary g_hLib;


BOOL 
WINAPI
CloseCluster(
  HCLUSTER hCluster
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClus_fn pfCloseClus = (CloseClus_fn)GetProcAddress(g_hLib, "CloseCluster");
	ASSERT(("Can not load CloseCluster() function", pfCloseClus != NULL));

	return pfCloseClus( hCluster );
}


DWORD 
WINAPI 
ClusterCloseEnum(
  HCLUSENUM hEnum  
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    ClusCloseEnum_fn pfClusCloseEnum = (ClusCloseEnum_fn)GetProcAddress(g_hLib, "ClusterCloseEnum");
	ASSERT(("Can not load ClusterCloseEnum() function", pfClusCloseEnum != NULL));

	return pfClusCloseEnum(hEnum);
}


BOOL 
WINAPI 
CloseClusterResource(
  HRESOURCE hResource  
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClusRes_fn pfCloseClusRes = (CloseClusRes_fn)GetProcAddress(g_hLib, "CloseClusterResource");
	ASSERT(("Can not load CloseClusterResource() function", pfCloseClusRes != NULL));

	return pfCloseClusRes(hResource);
}


BOOL 
WINAPI 
CloseClusterNode(
  HNODE hNode  
  )

{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClusNode_fn pfCloseClusNode = (CloseClusNode_fn)GetProcAddress(g_hLib, "CloseClusterNode");
	ASSERT(("Can not load CloseClusterNode() function", pfCloseClusNode != NULL));

	return pfCloseClusNode(hNode);
}


bool
IsLocalSystemCluster()
/*++
From mqutil

Routine Description:

    Check if local machine is a cluster node.

    The only way to know that is try calling cluster APIs.
    That means that on cluster systems, this code should run
    when cluster service is up and running. (ShaiK, 26-Apr-1999)

Arguments:

    None

Return Value:

    true - The local machine is a cluster node.

    false - The local machine is not a cluster node.

--*/
{

    g_hLib = LoadLibrary(L"clusapi.dll");

    if (g_hLib == NULL)
    {
        TrTRACE(Tgo, "Local machine is NOT a Cluster node");
        return false;
    }

    typedef DWORD (WINAPI *GetState_fn) (LPCWSTR, DWORD*);
    GetState_fn pfGetState = (GetState_fn)GetProcAddress(g_hLib, "GetNodeClusterState");

    if (pfGetState == NULL)
    {
        TrTRACE(Tgo, "Local machine is NOT a Cluster node");
        return false;
    }

    DWORD dwState = 0;
    if (ERROR_SUCCESS != pfGetState(NULL, &dwState))
    {
        TrTRACE(Tgo, "Local machine is NOT a Cluster node");
        return false;
    }

    if (dwState != ClusterStateRunning)
    {
        TrTRACE(Tgo, "Cluster Service is not running on this node");
        return false;
    }


    TrTRACE(Tgo, "Local machine is a Cluster node !!");
    return true;

} //IsLocalSystemCluster


bool
IsResourceMSMQTriggers (
	HRESOURCE hResource,
	ClusResCtrl_fn pfClusResCtrl
	)
/*++

Routine Description:

	Find if the resource with the given name is of type MSMQ Triggers

Arguments:

    hResource - handle to the resource

	pfClusResCtrl - pointer to ClusterResourceControl function

Return Value:

    true - if resource is of type MSMQ Triggers
	flase - otherwise

--*/
{
	DWORD dwReturnSize = 0;
    DWORD dwStatus = pfClusResCtrl(
                           hResource,
                           0,
                           CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
   
	if (dwStatus != ERROR_SUCCESS)
    {
        return false;
    }

    AP<BYTE> pType = new BYTE[dwReturnSize];

    dwStatus = pfClusResCtrl(
                     hResource,
                     0,
                     CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                     0,
                     0,
                     pType,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (dwStatus != ERROR_SUCCESS || 
		0 != _wcsicmp(reinterpret_cast<LPWSTR>(pType.get()), xDefaultTriggersServiceName))
	
	{
		return false;
	}
		
	return true;
}


bool 
GetClusteredServiceName (
	VOID
	)
/*++

Routine Description:

	Find the name of MSMQ Triggers service that is running on
	clustered machine. This computer may be a virtual server on a
	cluster, or phisycal node that is part of a cluster.

Arguments:


Return Value:

    true - if succeded to find MSMQ Triggers service on this machine
	flase - otherwise

--*/
{
	TCHAR wzComputerName[200];
	DWORD size = 200;
	GetComputerName( wzComputerName, &size );

    g_hLib = LoadLibrary(L"clusapi.dll");

    if (g_hLib == NULL)
    {
        TrTRACE(Tgo, "Local machine is NOT a Cluster node");
        return false;
    }

	//
	// Load neccesary functions
	//
    OpenClus_fn pfOpenClus = (OpenClus_fn)GetProcAddress(g_hLib, "OpenCluster");

    OpenClusNode_fn pfOpenClusNode = (OpenClusNode_fn)GetProcAddress(g_hLib, "OpenClusterNode");

    ClusOpenEnum_fn pfClusOpenEnum = (ClusOpenEnum_fn)GetProcAddress(g_hLib, "ClusterOpenEnum");

    ClusEnum_fn pfClusEnum = (ClusEnum_fn)GetProcAddress(g_hLib, "ClusterEnum");

    OpenClusRes_fn pfOpenClusRes = (OpenClusRes_fn)GetProcAddress(g_hLib, "OpenClusterResource");

    GetNetName_fn pfGetNetName = (GetNetName_fn)GetProcAddress(g_hLib, "GetClusterResourceNetworkName");

    ClusResCtrl_fn pfClusResCtrl = (ClusResCtrl_fn)GetProcAddress(g_hLib, "ClusterResourceControl");

 
	if (pfOpenClus == NULL     ||
		pfOpenClusNode == NULL ||
		pfClusOpenEnum == NULL ||
		pfClusEnum == NULL     ||
		pfOpenClusRes == NULL  ||
		pfGetNetName == NULL   ||
		pfClusResCtrl == NULL)
    {
        TrTRACE(Tgo, "Failed to load cluster API functions");
        return false;
    }

	CAutoCluster hCluster( pfOpenClus(NULL) );

	if ( hCluster == NULL )
	{
		TrTRACE(Tgo, "Failed to get handle to Cluster");
		return false;
	}

	CClusterNode hNode( pfOpenClusNode(hCluster, wzComputerName) );

	if ( hNode != NULL )
	{
		//
		// Such node exists. Local service.
		// Return default service name
		//
		wcscpy( s_wzServiceName, xDefaultTriggersServiceName);
		return true;
	}

	ASSERT(("Node Open Failure", GetLastError() == ERROR_CLUSTER_NODE_NOT_FOUND));

	//
	// Enumerate resources on this cluster
	//
	DWORD dwEnumType = CLUSTER_ENUM_RESOURCE;
	CClusterEnum hEnum( pfClusOpenEnum(hCluster, dwEnumType) );

	if ( hEnum == NULL )
	{
		TrTRACE(Tgo, "Failed to get handle to Cluster resource enumeration");
		return false;
	}

    DWORD dwIndex = 0;
    WCHAR wzResourceName[260] = {0};
	DWORD status = ERROR_SUCCESS;

	for( ; ; )
	{
        DWORD cchResourceName = 259;
  
		status = pfClusEnum(
                     hEnum,
                     dwIndex++,
                     &dwEnumType,
                     wzResourceName,
                     &cchResourceName
                     );

		if ( status != ERROR_SUCCESS )
		{
			return false;
		}

		CClusterResource hResource( pfOpenClusRes(hCluster, wzResourceName) );

		if ( hResource == NULL )
		{
			TrTRACE(Tgo, "Failed to get handle to resource.");
			return false;
		}

		if ( !IsResourceMSMQTriggers( hResource, pfClusResCtrl ) )
		{
			continue;
		}

		WCHAR wzNetName[200];
		DWORD ccNetName = 200;
		BOOL res = pfGetNetName(hResource,
								wzNetName,
								&ccNetName );
		
		if ( res && ( _wcsicmp(wzComputerName, wzNetName) == 0 ) )
		{
			wcscpy( s_wzServiceName, xDefaultTriggersServiceName );
			wcscat( s_wzServiceName, L"$" );
			wcscat( s_wzServiceName, wzResourceName );
			return true;
		}		
	} 

	return false;
}


bool
FindTriggersServiceName(
	VOID
	)
/*++

Routine Description:

	Find the name of MSMQ Triggers service that is running on
	this computer. If the machine is not clustered, service name
	is default name - "MSMQTriggers". If machine is clustered and
	the service is running on virtual server, the name of the service
	is "MSMQTriggers" + "$" + MSMQ Triggers resource name on that 
	node.

Arguments:


Return Value:

    true - if succeded to find MSMQ Triggers service on this machine
	flase - otherwise

--*/

{
	if ( !IsLocalSystemCluster() )
	{
		wcscpy( s_wzServiceName, xDefaultTriggersServiceName );
		wcscpy( s_wzTrigParamPathName, REGKEY_TRIGGER_PARAMETERS );
		return true;
	}
	else
	{
		//
		// Get service name on machine that is clustered.
		// 
		bool fRes = GetClusteredServiceName();
		if ( !fRes )
		{
			return false;
		}

		wcscpy( s_wzTrigParamPathName, REGKEY_TRIGGER_PARAMETERS );

		//
		// Service is running on vitual node
		//
		if ( ClusteredService(s_wzServiceName) )
		{
			wcscat( s_wzTrigParamPathName, REG_SUBKEY_CLUSTERED );
			wcscat( s_wzTrigParamPathName, s_wzServiceName );
		}

		TrTRACE(Tgo, "The service name is %ls", s_wzServiceName);
		return true;
	}
}


LPCWSTR
GetTriggersServiceName (
	void
	)
{
	return s_wzServiceName;
}


LPCWSTR
GetTrigParamRegPath (
	void
	)
{
	return s_wzTrigParamPathName;
}



bool
ClusteredService( 
	LPCWSTR wzServiceName 
	)
/* 
	true - if service name is not the default - "MSMQTriggers"
*/
{
	bool res = ( _wcsicmp(wzServiceName, xDefaultTriggersServiceName) != 0 );

	return res;
}


bool IsResourceOnline(
	void
	)
{
	CServiceHandle hCm( OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) );

	if ( hCm == NULL )
	{
		ASSERT(("Cannot get handle to Service Manager.", hCm != NULL));
		return false;
	}

	//
	// Get handle to a service with the given name.
	// The service may not exist, since in cluster Offline() deletes
	// the service from the system.
	//
	CServiceHandle hService(OpenService(
                                hCm,
                                s_wzServiceName,
                                SERVICE_QUERY_STATUS
                                ));
	
	if ( hService == NULL )
	{
		ASSERT(("Access Denied", (GetLastError() == ERROR_INVALID_NAME || GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) ));
		return false;
	}

	SERVICE_STATUS ServiceStatus;
	BOOL fRes = QueryServiceStatus(hService, &ServiceStatus);
	if ( !fRes )
	{
		TrTRACE(Tgo, "Can not get service status.");
		return false;
	}

	if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING ||
		 ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING ||
		 ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING ||
		 ServiceStatus.dwCurrentState == SERVICE_PAUSED )
	{
		//
		// The proccess of the service exists
		//
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\idspprxy.cpp ===
//*****************************************************************************
//
// Class Name  : CDispatchInterfaceProxy
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a helper class that simplifies the creation of a COM 
//               component and the subsequent nvocation of a named method via the
//               IDispatch interface.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "idspprxy.hpp"

#include "idspprxy.tmh"

//*****************************************************************************
//
// Method      : Constructor
//
// Description : initialize an instance of the CDispatchInterfaceProxy class.
//
//*****************************************************************************
CDispatchInterfaceProxy::CDispatchInterfaceProxy()
{
	m_pDisp = NULL;
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : destroys an instance of the CDispatchInterfaceProxy class.
//
//*****************************************************************************
CDispatchInterfaceProxy::~CDispatchInterfaceProxy()
{
	// Release the IDispatch interface if we have one.
    if (m_pDisp != NULL)
	{
		m_pDisp->Release(); 
	}
}

//*****************************************************************************
//
// Method      : CreateObjectFromProgID
//
// Description : creates an instance of COM component identified by the supplied
//               prog id.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CreateObjectFromProgID(BSTR bstrProgID)
{
	HRESULT hr = S_OK;

	hr = CreateObject((LPTSTR)bstrProgID,&m_pDisp); 

	// TODO - check if this method can be rationalised by calling CreateObject.

	return(hr);
}

//*****************************************************************************
//
// Method      : InvokeMethod
//
// Description : invokes a method on the current instance of the IDispatch 
//               interface. 
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::InvokeMethod(BSTR bstrMethodName,DISPPARAMS * pArguments, VARIANT* pvResult)
{
	HRESULT hr = S_OK;
    DISPID dispid; 
	UINT uiArgErr = 0;
	EXCEPINFO ExceptionInfo;

	// ensure that we have been supplied valid parameters
	ASSERT(SysStringLen(bstrMethodName) != 0);
	ASSERT(pArguments != NULL);

    // Get DISPID of property/method 
    hr = m_pDisp->GetIDsOfNames(IID_NULL,&bstrMethodName, 1, LOCALE_USER_DEFAULT, &dispid); 

	// Inistialise exeception info structure
	ZeroMemory(&ExceptionInfo,sizeof(ExceptionInfo));
	
	// Make the call to the method.
    hr = m_pDisp->Invoke(dispid,
		                 IID_NULL,
						 LOCALE_USER_DEFAULT,
						 DISPATCH_METHOD,
						 pArguments,
						 pvResult,
						 &ExceptionInfo,
						 &uiArgErr); 


	return(hr);
}

//*****************************************************************************
//
// Method      : CreateObject
//
// Description : Creates an instances of the COM component identified by the 
//               supplied prog id, and then calls QueryInterface for an instance
//               of the IDispatch interface. Returns the IDispatch interface 
//               pointer if successfull.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CreateObject(LPOLESTR pszProgID, IDispatch FAR* FAR* ppdisp) 
{ 
    CLSID clsid;                   // CLSID of automation object 
    HRESULT hr; 
    LPUNKNOWN punk = NULL;         // IUnknown of automation object 
    LPDISPATCH pdisp = NULL;       // IDispatch of automation object 
     
    *ppdisp = NULL; 
     
    // Retrieve CLSID from the progID that the user specified 
    hr = CLSIDFromProgID(pszProgID, &clsid); 
    if (FAILED(hr)) 
        goto error; 
     
    // Create an instance of the automation object and ask for the IDispatch interface 
    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER,  
                          IID_IUnknown, (void FAR* FAR*)&punk); 
    if (FAILED(hr)) 
        goto error; 
                    
    hr = punk->QueryInterface(IID_IDispatch, (void FAR* FAR*)&pdisp); 
    if (FAILED(hr)) 
        goto error; 
 
    *ppdisp = pdisp; 
    punk->Release(); 
    return NOERROR; 
      
error: 
    if (punk) punk->Release(); 
    if (pdisp) pdisp->Release(); 
    return hr; 
}    

//*****************************************************************************
//
// Method      : Invoke 
// 
// Description : Invokes a property accessor function or method of an automation
//               object. Uses Unicode with OLE. 
// 
// Parameters   : 
//
//  pdisp         IDispatch* of automation object. 
//  wFlags        Specfies if property is to be accessed or method to be invoked. 
//                Can hold DISPATCH_PROPERTYGET, DISPATCH_PROPERTYPUT, DISPATCH_METHOD, 
//                DISPATCH_PROPERTYPUTREF or DISPATCH_PROPERTYGET|DISPATCH_METHOD.    
//  pvRet         NULL if caller excepts no result. Otherwise returns result. 
//  pexcepinfo    Returns exception info if DISP_E_EXCEPTION is returned. Can be NULL if 
//                caller is not interested in exception information.  
//  pnArgErr      If return is DISP_E_TYPEMISMATCH, this returns the index (in reverse 
//                order) of argument with incorrect type. Can be NULL if caller is not interested 
//                in this information.  
//  pszName       Name of property or method. 
//  pszFmt        Format string that describes the variable list of parameters that  
//                follows. The format string can contain the follwoing characters. 
//                & = mark the following format character as VT_BYREF  
//                b = VT_BOOL 
//                i = VT_I2 
//                I = VT_I4 
//                r = VT_R2 
//                R = VT_R4 
//                c = VT_CY  
//                s = VT_BSTR (far string pointer can be passed, BSTR will be allocated by this function). 
//                e = VT_ERROR 
//                d = VT_DATE 
//                v = VT_VARIANT. Use this to pass data types that are not described in  
//                                the format string. (For example SafeArrays). 
//                D = VT_DISPATCH 
//                U = VT_UNKNOWN 
//     
//  ...           Arguments of the property or method. Arguments are described by pszFmt.   
//               
// Return Value:
// 
//  HRESULT indicating success or failure         
// 
// Usage examples: 
// 
//  HRESULT hr;   
//  LPDISPATCH pdisp;    
//  BSTR bstr; 
//  short i; 
//  BOOL b;    
//  VARIANT v, v2; 
// 
//1. bstr = SysAllocString(OLESTR("")); 
//   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method1"),  
//        TEXT("bis&b&i&s"), TRUE, 2, (LPOLESTR)OLESTR("param"), (BOOL FAR*)&b, (short FAR*)&i, (BSTR FAR*)&bstr);    
// 
//2. VariantInit(&v); 
//   V_VT(&v) = VT_R8; 
//   V_R8(&v) = 12345.6789;  
//   VariantInit(&v2); 
//   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method2"),  
//         TEXT("v&v"), v, (VARIANT FAR*)&v2); 
//
//*****************************************************************************
HRESULT  
__cdecl
CDispatchInterfaceProxy::Invoke(
    LPDISPATCH pdisp,  
    WORD wFlags, 
    LPVARIANT pvRet, 
    EXCEPINFO FAR* pexcepinfo, 
    UINT FAR* pnArgErr,  
    LPOLESTR pszName, 
    LPCTSTR pszFmt,  
    ...
    ) 
{ 
    va_list argList; 
    va_start(argList, pszFmt);   
    DISPID dispid; 
    HRESULT hr; 
    VARIANTARG* pvarg = NULL; 
    DISPPARAMS dispparams; 
   
    if (pdisp == NULL) 
	{
        return E_INVALIDARG; 
    }

    // Get DISPID of property/method 
    hr = pdisp->GetIDsOfNames(IID_NULL, &pszName, 1, LOCALE_USER_DEFAULT, &dispid); 

    if(FAILED(hr)) 
	{
        return hr; 
    }
	
	// initialize dispparms structure
    _fmemset(&dispparams, 0, sizeof dispparams); 
 
    // determine number of arguments 
    if (pszFmt != NULL) 
	{
        CountArgsInFormat(pszFmt, &dispparams.cArgs); 
    }

    // Property puts have a named argument that represents the value that the property is 
    // being assigned. 
    DISPID dispidNamed = DISPID_PROPERTYPUT; 

    if (wFlags & DISPATCH_PROPERTYPUT) 
    { 
        if (dispparams.cArgs == 0) 
            return E_INVALIDARG; 
        dispparams.cNamedArgs = 1; 
        dispparams.rgdispidNamedArgs = &dispidNamed; 
    } 
 
    if (dispparams.cArgs != 0) 
    { 
        // allocate memory for all VARIANTARG parameters 
        pvarg = new VARIANTARG[dispparams.cArgs]; 

        if(pvarg == NULL) 
		{
            return E_OUTOFMEMORY;    
		}

        dispparams.rgvarg = pvarg; 

        _fmemset(pvarg, 0, sizeof(VARIANTARG) * dispparams.cArgs); 
 
        // get ready to walk vararg list 
        LPCTSTR psz = pszFmt; 
        pvarg += dispparams.cArgs - 1;   // params go in opposite order 
         
        psz = GetNextVarType(psz, &pvarg->vt);
        while (psz) 
        { 
            if (pvarg < dispparams.rgvarg) 
            { 
                hr = E_INVALIDARG; 
                goto cleanup;   
            } 
            switch (pvarg->vt) 
            { 
            case VT_I2: 
                V_I2(pvarg) = va_arg(argList, short); 
                break; 
            case VT_I4: 
                V_I4(pvarg) = va_arg(argList, long); 
                break; 
            case VT_R4: 
                V_R4(pvarg) = va_arg(argList, float); 
                break;  
            case VT_DATE: 
            case VT_R8: 
                V_R8(pvarg) = va_arg(argList, double); 
                break; 
            case VT_CY: 
                V_CY(pvarg) = va_arg(argList, CY); 
                break; 
            case VT_BSTR: 
                V_BSTR(pvarg) = SysAllocString(va_arg(argList, OLECHAR FAR*)); 
                if (pvarg->bstrVal == NULL)  
                { 
                    hr = E_OUTOFMEMORY;   
                    pvarg->vt = VT_EMPTY; 
                    goto cleanup;   
                } 
                break; 
            case VT_DISPATCH: 
                V_DISPATCH(pvarg) = va_arg(argList, LPDISPATCH); 
                break; 
            case VT_ERROR: 
                V_ERROR(pvarg) = va_arg(argList, SCODE); 
                break; 
            case VT_BOOL: 
                V_BOOL(pvarg) = (VARIANT_BOOL)(va_arg(argList, BOOL) ? -1 : 0); 
                break; 
            case VT_VARIANT: 
                *pvarg = va_arg(argList, VARIANTARG);  
                break; 
            case VT_UNKNOWN: 
                V_UNKNOWN(pvarg) = va_arg(argList, LPUNKNOWN); 
                break; 
 
            case VT_I2|VT_BYREF: 
                V_I2REF(pvarg) = va_arg(argList, short FAR*); 
                break; 
            case VT_I4|VT_BYREF: 
                V_I4REF(pvarg) = va_arg(argList, long FAR*); 
                break; 
            case VT_R4|VT_BYREF: 
                V_R4REF(pvarg) = va_arg(argList, float FAR*); 
                break; 
            case VT_R8|VT_BYREF: 
                V_R8REF(pvarg) = va_arg(argList, double FAR*); 
                break; 
            case VT_DATE|VT_BYREF: 
                V_DATEREF(pvarg) = va_arg(argList, DATE FAR*); 
                break; 
            case VT_CY|VT_BYREF: 
                V_CYREF(pvarg) = va_arg(argList, CY FAR*); 
                break; 
            case VT_BSTR|VT_BYREF: 
                V_BSTRREF(pvarg) = va_arg(argList, BSTR FAR*); 
                break; 
            case VT_DISPATCH|VT_BYREF: 
                V_DISPATCHREF(pvarg) = va_arg(argList, LPDISPATCH FAR*); 
                break; 
            case VT_ERROR|VT_BYREF: 
                V_ERRORREF(pvarg) = va_arg(argList, SCODE FAR*); 
                break; 
            case VT_BOOL|VT_BYREF:  
                { 
                    BOOL FAR* pbool = va_arg(argList, BOOL FAR*); 
                    *pbool = 0; 
                    V_BOOLREF(pvarg) = (VARIANT_BOOL FAR*)pbool; 
                }  
                break;               
            case VT_VARIANT|VT_BYREF:  
                V_VARIANTREF(pvarg) = va_arg(argList, VARIANTARG FAR*); 
                break; 
            case VT_UNKNOWN|VT_BYREF: 
                V_UNKNOWNREF(pvarg) = va_arg(argList, LPUNKNOWN FAR*); 
                break; 
 
            default: 
                { 
                    hr = E_INVALIDARG; 
                    goto cleanup;   
                } 
                break; 
            } 
 
            --pvarg; // get ready to fill next argument 
            psz = GetNextVarType(psz, &pvarg->vt);
        } //while 
    } //if 
     
    // Initialize return variant, in case caller forgot. Caller can pass NULL if return 
    // value is not expected. 
    if (pvRet) 
	{
        VariantInit(pvRet);  
	}

    // make the call  
    hr = pdisp->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, wFlags,&dispparams, pvRet, pexcepinfo, pnArgErr); 
 
cleanup: 

    // cleanup any arguments that need cleanup 
    if (dispparams.cArgs != 0) 
    { 
        VARIANTARG FAR* pvarg = dispparams.rgvarg; 
        UINT cArgs = dispparams.cArgs;    
         
        while (cArgs--) 
        { 
            switch (pvarg->vt) 
            { 
            case VT_BSTR: 
                VariantClear(pvarg); 
                break; 
            } 
            ++pvarg; 
        } 
    } 

    delete dispparams.rgvarg; 

    va_end(argList); 

    return hr;    
}    

//*****************************************************************************
//
// Method      : CountArgsInFormat
//
// Description : returns the number of arguments found in the supplied format 
//               string. See the definition of the Invoke() method for the 
//               definition of this format string.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn) 
{ 
    *pn = 0; 
 
    if(pszFmt == NULL) 
      return NOERROR; 
     
    while (*pszFmt)   
    { 
       if (*pszFmt == '&') 
           pszFmt++; 
 
       switch(*pszFmt) 
       { 
           case 'b': 
           case 'i':  
           case 'I': 
           case 'r':  
           case 'R': 
           case 'c': 
           case 's': 
           case 'e': 
           case 'd': 
           case 'v': 
           case 'D': 
           case 'U': 
               ++*pn;  
               pszFmt++; 
               break; 
           case '\0':   
           default: 
               return E_INVALIDARG;    
        } 
    } 
    return NOERROR; 
} 

 
//*****************************************************************************
//
// Method      : GetNextVarType
//
// Description : returns a pointer to the next variable-type declaration in 
//               the supplied format string. 
//
//*****************************************************************************
LPCTSTR CDispatchInterfaceProxy::GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt) 
{    

    *pvt = 0; 
    if (*pszFmt == '&')  
    { 
         *pvt = VT_BYREF;  
         pszFmt++;     
         if (!*pszFmt) 
             return NULL;     
    }  
    switch(*pszFmt) 
    { 
        case 'b': 
            *pvt |= VT_BOOL; 
            break; 
        case 'i':  
            *pvt |= VT_I2; 
            break; 
        case 'I':  
            *pvt |= VT_I4; 
            break; 
        case 'r':  
            *pvt |= VT_R4; 
            break; 
        case 'R':  
            *pvt |= VT_R8; 
            break; 
        case 'c': 
            *pvt |= VT_CY; 
            break; 
        case 's':  
            *pvt |= VT_BSTR; 
            break; 
        case 'e':  
            *pvt |= VT_ERROR; 
            break; 
        case 'd':  
            *pvt |= VT_DATE;  
            break; 
        case 'v':  
            *pvt |= VT_VARIANT; 
            break; 
        case 'U':  
            *pvt |= VT_UNKNOWN;  
            break; 
        case 'D':  
            *pvt |= VT_DISPATCH; 
            break;   
        case '\0': 
             return NULL;     // End of Format string 
        default: 
            return NULL; 
    }  
    return ++pszFmt;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trigobjs.rc
//
#define IDR_MSMQTRIGGERSET              101
#define IDR_MSMQRULEHANDLER             102
#define IDR_IMSMQPROPERTYBAG            103
#define IDR_MSMQRULESET                 104
#define IDR_MSMQTRIGGER                 105
#define IDR_MSMQTRIGGERSCONFIG          106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\rulehdlr.hpp ===
// CMSMQRuleHandler.hpp : Declaration of the CMSMQRuleHandler

#ifndef __MSMQRULEHANDLER_H_
#define __MSMQRULEHANDLER_H_

#include "resource.h"       // main symbols

#include "strparse.hpp"
#include "IDspPrxy.hpp"


// Declare smart pointer type for the MSMQ property bag COM object.
_COM_SMARTPTR_TYPEDEF(IMSMQPropertyBag, __uuidof(IMSMQPropertyBag));

class ATL_NO_VTABLE CMSMQRuleHandler : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQRuleHandler, &CLSID_MSMQRuleHandler>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSMQRuleHandler>,
	public IDispatchImpl<IMSMQRuleHandler, &IID_IMSMQRuleHandler, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQRuleHandler();
		~CMSMQRuleHandler();


		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQRULEHANDLER)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQRuleHandler)
			COM_INTERFACE_ENTRY(IMSMQRuleHandler)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY(IConnectionPointContainer)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()
		BEGIN_CONNECTION_POINT_MAP(CMSMQRuleHandler)
		END_CONNECTION_POINT_MAP()


	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


	CComPtr<IUnknown> m_pUnkMarshaler;

	CStringTokens m_tokCondition;
	CStringTokens m_tokAction;

	_bstr_t m_bstrRuleID;
	_bstr_t m_bstrCondition;
	_bstr_t m_bstrAction;
    RulesProcessingStatus m_RulesProcessingStatus;

	bool	m_fIsSerializedQueue;
	bool	m_fShowWindow;


	// Used to determine if the action portion of this rule should be executed
	HRESULT RuleConditionSatisfied(IMSMQPropertyBag * pIMSMQPropertyBag,BOOL * pbConditionSatisifed);

	// Evaluates a single condition token.
	HRESULT EvaluateConditionToken(IMSMQPropertyBag * pIMSMQPropertyBag,_bstr_t bstrConditionToken,BOOL * pbConditionSatisfied);

	// Used to execute the action portion of a rule
	HRESULT ExecuteRuleAction(IMSMQPropertyBag * pIMSMQPropertyBag);

	// Creates and releases and array of parameters for a method calls.
	HRESULT PrepareMethodParameters(IMSMQPropertyBag * pIMSMQPropertyBag,DISPPARAMS * pdispparms,bstr_t * pbstrTestMessageBody);
	HRESULT ReleaseMethodParameters(DISPPARAMS * pdispparms);

	// Formats a command line of parameters for standalone EXE invocation
	HRESULT PrepareEXECommandLine(IMSMQPropertyBag * pIMSMQPropertyBag,_bstr_t * pbstrCommandLine,bstr_t * pbstrTestMessageBody);

	// Methods used to invoke customer functionality
	HRESULT InvokeCOMComponent(IMSMQPropertyBag * pIMSMQPropertyBag);
	HRESULT InvokeEXE(IMSMQPropertyBag * pIMSMQPropertyBag);

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	// Retreive a name arguement value from the property bag, return as a variant
	HRESULT GetArgumentValue(IMSMQPropertyBag * pIMSMQPropertyBag,bstr_t bstrArgName, VARIANTARG * pvArgValue);

	// Helper functions used in testing and manipulating strings
	bool IsEnclosedInQuotes(_bstr_t bstrString);
	bool ConvertToUnquotedVariant(_bstr_t bstrString, VARIANT * pv);


// IMSMQRuleHandler
public:
    STDMETHOD(CheckRuleCondition)(/*[in]*/ IMSMQPropertyBag * pIPropertyBag ,  /*[out]*/ BOOL * pbConditionSatisfied );
	STDMETHOD(ExecuteRule)(/*[in]*/ IMSMQPropertyBag * pIPropertyBag , /*[in]*/ BOOL fIsSerializedQueue, /* [out]*/ LONG * plRuleResult );
	STDMETHOD(Init)(/*[in]*/ BSTR bstrRuleID, /*[in]*/ BSTR sRuleCondition , /*[in]*/ BSTR sRuleAction, /*[in]*/ BOOL fShowWindow);

private:
	void SetComClassError(HRESULT hr);

};

#endif //__MSMQRULEHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\rulehdlr.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQRuleHandler
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents the generic rule handling 
//               component. This component interprets the condition
//               and action strings for a particular rule - and peforms
//               the appropriate actions. 
//
//               This class is exposed as a COM component with the 
//               progid "MSMQTriggerObjects.MSMQRuleHandler". This 
//               is the default rule handling component instantiated 
//               by the MSMQ Trigger Service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"

//
// Include the definions for standard functions and definitions.
//
#include "stdfuncs.hpp"

//
// Definitions of the return codes used by these object
//

#include "mqtrig.h"
#include "rulehdlr.hpp"
#include "mqsymbls.h"


// Include the standard definitions used throughout the triggers projects and components.
#include "stddefs.hpp"
#include "mqtg.h"

// Include the test functions
#include "TriggerTest.hpp"

#include "rulehdlr.tmh"

//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard rich error info interface method - built by wizard.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleHandler::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQRuleHandler
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Invoked when a rule handler object is created. 
//
//************************************************************************************
CMSMQRuleHandler::CMSMQRuleHandler()
{
	m_pUnkMarshaler = NULL;

	// Initialise member variables.
	m_bstrCondition = _T("");
	m_bstrAction  = _T("");
	m_fIsSerializedQueue = false;
	m_fShowWindow = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Invoked when a rule handler object is destroyed.
//
//************************************************************************************
CMSMQRuleHandler::~CMSMQRuleHandler()
{
	TrTRACE(Tgo, "Destroy rule handle for rule: %ls", static_cast<LPCWSTR>(m_bstrRuleID));
}

//************************************************************************************
//
// Method      : Init
//
// Description : This method is called by the MSMQ Trigger Service once after the 
//               rule handler component has been created. This calling of this method 
//               gives the rule handle the opportunity to perform once-off initializations
//               and resource allocations. The main steps performed during this call are :
//
//               (1) Create an instance of the logging class.
//               (2) Initialize member vars with supplied initialization parms.
//               (3) Parse the rule condition string.
//               (4) Parse the rule action string
//
//************************************************************************************
STDMETHODIMP CMSMQRuleHandler::Init(
								BSTR bstrRuleID,
								BSTR sRuleCondition,
								BSTR sRuleAction,
								BOOL fShowWindow )
{
	TrTRACE(Tgo, "Init CMSMQRuleHandler for Rule: %ls. Condition string: %ls,  Action string %ls", static_cast<LPCWSTR>(bstrRuleID), static_cast<LPCWSTR>(sRuleCondition), static_cast<LPCWSTR>(sRuleAction));

	//
	// Store the condition and action strings and the queue handle.
	//
	m_bstrRuleID = bstrRuleID;
	m_bstrCondition = sRuleCondition;
	m_bstrAction = sRuleAction;
	m_fShowWindow = (fShowWindow != FALSE);
    m_RulesProcessingStatus = RULES_PROCESSING_CONTINUE;
	 
	//
	// Parse the condition strings
	//
	try
	{
		m_tokCondition.Parse(sRuleCondition, xConditionDelimiter);
	}
	catch(const exception&)
	{
		TrERROR(Tgo, "Failed to parse rule condition: %ls for rule: %ls", (LPCWSTR)m_bstrCondition, (LPCWSTR)m_bstrRuleID);
		
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}

	//
	// Parse the action string
	//
	try
	{
		m_tokAction.Parse(sRuleAction, xActionDelimiter);
	}
	catch(const exception&)
	{
		TrERROR(Tgo, "Failed to parse rule action: %ls for rule: %ls", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
		
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}

    //
	// ISSUE-2000/10/29-urih - perform extra validation on the token set here.
	//

	return S_OK;
}

//************************************************************************************
//
// Method      : CheckRuleCondition
//
// Description : This method is called by the MSMQ Trigger Service every time a msg 
//               arrives on queue that has a trigger attached to it. This method is 
//               evalutate the rule condition
//               
// 
// Parameters   :
//               [in] pIMSMQPropertyBag 
//
//               This is an interface pointer to an instance of the MSMQ property bag 
//			     COM object. This component holds the message properties of the message
//               that has just arrived on a monitorred queue. Using this interface pointer
//               the rule-handler can access the message property values without actually
//               having to visit the queue.
//
//               [out] pbConditionSatisfied 
//
//               This value is used to pass information back to the MSMQ Trigger Service. 
//               Currently it is used to communicate if the rule-condition was satisfied
//               and if the rule-action executed successfully.
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleHandler::CheckRuleCondition(
	IMSMQPropertyBag * pIMSMQPropertyBag, 
	BOOL *pbConditionSatisfied
	)
{
	TrTRACE(Tgo, "Rule %ls is tested.", static_cast<LPCWSTR>(m_bstrRuleID));
    *pbConditionSatisfied = false;
	
	//
	// Check if we have a valid property bag object
	//
	if (pIMSMQPropertyBag == NULL)
	{
		TrERROR(Tgo, "Rule %ls has been invoked with empty property bag. Rule handling cannot be processed.", (LPCWSTR)m_bstrRuleID);

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}



	//
	// Test if the rule condition is satisfied. Note that the HRESULT from this call does not indicate if 
	// condition has been satisfied - instead it indicates if we could perform the evaluation correctly.
	//
    IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	
	HRESULT hr = RuleConditionSatisfied(pIPropertyBag.GetInterfacePtr(),pbConditionSatisfied);
	if (FAILED(hr))
	{
		TrERROR(Tgo, "Invalid rule condition %ls for rule %ls. Failed to evaluate the condition.", (LPCWSTR)m_bstrRuleID, (LPCWSTR)m_bstrCondition);
	
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}

	if (!(*pbConditionSatisfied))
	{
		TrTRACE(Tgo, "Rule condition for rule: %ls wasn't satisfied. Continue ...", static_cast<LPCWSTR>(m_bstrRuleID));
	}

	return S_OK;
}


//************************************************************************************
//
// Method      : ExecuteRule
//
// Description : This method is called by the MSMQ Trigger Service every time a msg 
//               arrives on queue that has a trigger attached to it and
//               the condition was true.
// 
// Parameters   :
//               [in] pIMSMQPropertyBag 
//
//               This is an interface pointer to an instance of the MSMQ property bag 
//			     COM object. This component holds the message properties of the message
//               that has just arrived on a monitorred queue. Using this interface pointer
//               the rule-handler can access the message property values without actually
//               having to visit the queue.
//
//               [in] fIsSerializedQueue
//               Indicates if the queue is serialized
//
//               [out] pRuleProcessingStatus 
//
//               This value is used to pass information back to the MSMQ Trigger Service. 
//               Indicates if next rule should be executed
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleHandler::ExecuteRule(
	IMSMQPropertyBag * pIMSMQPropertyBag, 
	BOOL fIsSerializedQueue, 
	LONG* plRuleResult
	)
{
	TrTRACE(Tgo, "Rule %ls action is executed.", static_cast<LPCWSTR>(m_bstrRuleID));

	m_fIsSerializedQueue = (fIsSerializedQueue != FALSE);
	
	if (pIMSMQPropertyBag == NULL)
	{
		TrERROR(Tgo, "Rule %ls has been invoked with empty property bag. Rule handling cannot be processed.", (LPCWSTR)m_bstrRuleID);

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

    *plRuleResult = 0;

	HRESULT hr = ExecuteRuleAction(pIMSMQPropertyBag); 

    if (FAILED(hr))
	{
		*plRuleResult |= xRuleResultActionExecutedFailed;
	    SetComClassError(hr);
        return hr;
	}
 

    if (m_RulesProcessingStatus == RULES_PROCESSING_STOP)
    {
        *plRuleResult |= xRuleResultStopProcessing;
    }
	return S_OK;
}



//************************************************************************************
//
// Method      : RuleConditionSatisfied
//
// Description : Returns true or false (in the form of an out parameter) depending on
//               whether the rule condition is satisfied given the message properties
//               supplied in the MSMQPropertyBag COM object instance (pIMSMQPropertyBag)
//
//************************************************************************************
HRESULT CMSMQRuleHandler::RuleConditionSatisfied(IMSMQPropertyBag * pIMSMQPropertyBag,BOOL * pbConditionSatisfied)
{
	HRESULT hr = S_OK;
	ULONG ulNumTokens = 0 ;
	ULONG ulTokenCtr = 0;
	_bstr_t bstrToken = _T("");
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Assume that the group of conditions is satsified - quit loop if proved otherwise.
	(*pbConditionSatisfied) = true;

	// get the number of condition tokens
	ulNumTokens = m_tokCondition.GetNumTokens();

	// If the number of tokens in the condition string is 0, then rule should be fired.
	if (ulNumTokens < 1)
	{
		return(hr);
	}

	// Test each condition token
	while ((ulTokenCtr <= (ulNumTokens - 1))  && (SUCCEEDED(hr)) )
	{
		_bstr_t bstrToken;

		// Get the next token 
		m_tokCondition.GetToken(ulTokenCtr, bstrToken);
		
		hr = EvaluateConditionToken(
				pIPropertyBag.GetInterfacePtr(),
				bstrToken,
				pbConditionSatisfied
				);
		
		if ((*pbConditionSatisfied) == false)
		{ 
			break;
		}

		// Process the next condition token
		ulTokenCtr++;
	}

	return(hr);
} 

//************************************************************************************
//
// Method      : EvaluateConditionToken
//
// Description : A rule condition can be made up of multiple condition tokens. This
//               method is used to determine if a single condition token is true or 
//               false. 
//
//               This method currently supports the following conditional tests:
//
//               (1) Message label contains a specific (literal) string
//               (2) Message Prioriry is at least a specific (literal) value.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::EvaluateConditionToken(IMSMQPropertyBag * pIMSMQPropertyBag, _bstr_t bstrConditionToken,BOOL * pbConditionSatisfied)
{
	VARIANT vPropertyValue;
	_bstr_t bstrToken = _T("");
	_bstr_t bstrTokenValue = _T("");
	CStringTokens spConditionTokenParser;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialise property value variant
	VariantInit(&vPropertyValue);

	// Assume that this individual condition is false - and try to prove otherwise.
	(*pbConditionSatisfied) = false;

	try
	{
		// Parse the conditional expression
		spConditionTokenParser.Parse(bstrConditionToken, xConditionValueDelimiter);
		spConditionTokenParser.GetToken(0,bstrToken);

		// Depending on which token it is - apply a different test.
		if (bstrToken == gc_bstrConditionTag_MsgLabelContains ||
			bstrToken == gc_bstrConditionTag_MsgLabelDoesNotContain ) 
		{		
			spConditionTokenParser.GetToken(1,bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(gc_bstrPropertyName_Label,&vPropertyValue);

			_bstr_t bstrLabel = vPropertyValue;
		
			TCHAR* ptcs = _tcsstr((wchar_t*)bstrLabel,(wchar_t*)bstrTokenValue);

			if(bstrToken == gc_bstrConditionTag_MsgLabelContains)
			{
				(*pbConditionSatisfied) = (ptcs != NULL);
			}
			else //gc_bstrConditionTag_MsgLabelDoesNotContain
			{
				(*pbConditionSatisfied) = (ptcs == NULL);
			}

			// Clear property value variant
			VariantClear(&vPropertyValue);
			return S_OK;
		}
		
		
		if (bstrToken == gc_bstrConditionTag_MsgBodyContains ||
			bstrToken == gc_bstrConditionTag_MsgBodyDoesNotContain ) 
		{		
			spConditionTokenParser.GetToken(1,bstrTokenValue);

			pIPropertyBag->Read(gc_bstrPropertyName_MsgBodyType,&vPropertyValue);

			DWORD dwBodyType = vPropertyValue.ulVal;

			if(dwBodyType == VT_BSTR) //we check the body only if it is of type string
			{
				// Get the message Body from the property bag.
				pIPropertyBag->Read(gc_bstrPropertyName_MsgBody,&vPropertyValue);

				_bstr_t bstrBody = vPropertyValue;

				TCHAR* ptcs = NULL;

				// We don't want to use _tcsstr if bstrBody.m_Data is NULL. If it NULL
				// then the TokenValue does not exist in it so ptcs = NULL;
				if (bstrBody.length()!=0)
				{
					ptcs = _tcsstr((wchar_t*)bstrBody,(wchar_t*)bstrTokenValue);
				}

				if(bstrToken == gc_bstrConditionTag_MsgBodyContains)
				{
					(*pbConditionSatisfied) = (ptcs != NULL);
				}
				else //gc_bstrConditionTag_MsgBodyDoesNotContain
				{
					(*pbConditionSatisfied) = (ptcs == NULL);
				}
			}

			// Clear property value variant
			VariantClear(&vPropertyValue);
			return S_OK;
		}


		if (bstrToken == gc_bstrConditionTag_MsgPriorityGreaterThan ||
			bstrToken == gc_bstrConditionTag_MsgPriorityLessThan ||
			bstrToken == gc_bstrConditionTag_MsgPriorityEquals ||
			bstrToken == gc_bstrConditionTag_MsgPriorityNotEqual ) 
		{
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(gc_bstrPropertyName_MsgPriority,&vPropertyValue);

			long lActualMsgPriority = vPropertyValue.lVal;
			long lRequirdMsgPriority = _wtol((wchar_t*)bstrTokenValue);

			if(bstrToken == gc_bstrConditionTag_MsgPriorityEquals)
			{
					(*pbConditionSatisfied) = (lRequirdMsgPriority == lActualMsgPriority);
			}
			else if(bstrToken == gc_bstrConditionTag_MsgPriorityNotEqual)
			{
					(*pbConditionSatisfied) = (lRequirdMsgPriority != lActualMsgPriority);
			}
			else if(bstrToken == gc_bstrConditionTag_MsgPriorityGreaterThan)
			{
				(*pbConditionSatisfied) = (lRequirdMsgPriority < lActualMsgPriority);
			}
			else //gc_bstrConditionTag_MsgPriorityLessThan
			{
				(*pbConditionSatisfied) = (lRequirdMsgPriority > lActualMsgPriority);
			}
			
			// Clear property value variant
			VariantClear(&vPropertyValue);
			return S_OK;
		}

		if (bstrToken == gc_bstrConditionTag_MsgAppSpecificGreaterThan ||
			bstrToken == gc_bstrConditionTag_MsgAppSpecificLessThan ||
			bstrToken == gc_bstrConditionTag_MsgAppSpecificEquals ||
			bstrToken == gc_bstrConditionTag_MsgAppSpecificNotEqual ) 
		{
			TCHAR* pEnd = NULL;
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(gc_bstrPropertyName_AppSpecific,&vPropertyValue);

			ULONG ulAppSpecific = vPropertyValue.ulVal;
			ULONG ulRequiredAppSpecific = _tcstoul((wchar_t*)bstrTokenValue, &pEnd, 10);


			if(bstrToken == gc_bstrConditionTag_MsgAppSpecificEquals)
			{
					(*pbConditionSatisfied) = (ulRequiredAppSpecific == ulAppSpecific);
			}
			else if(bstrToken == gc_bstrConditionTag_MsgAppSpecificNotEqual)
			{
					(*pbConditionSatisfied) = (ulRequiredAppSpecific != ulAppSpecific);
			}
			else if(bstrToken == gc_bstrConditionTag_MsgAppSpecificGreaterThan)
			{
				(*pbConditionSatisfied) = (ulRequiredAppSpecific < ulAppSpecific);
			}
			else //gc_bstrConditionTag_MsgAppSpecificLessThan
			{
				(*pbConditionSatisfied) = (ulRequiredAppSpecific > ulAppSpecific);
			}
			
			// Clear property value variant
			VariantClear(&vPropertyValue);
			return S_OK;
		}

		if (bstrToken == gc_bstrConditionTag_MsgSrcMachineIdEquals ||
			bstrToken == gc_bstrConditionTag_MsgSrcMachineIdNotEqual )
		{
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(gc_bstrPropertyName_SrcMachineId, &vPropertyValue);

			_bstr_t bstrSrcMachineId = vPropertyValue;
		
			int ret = _tcsicmp((wchar_t*)bstrSrcMachineId,(wchar_t*)bstrTokenValue);

			if(bstrToken == gc_bstrConditionTag_MsgSrcMachineIdEquals)
			{
				(*pbConditionSatisfied) = (ret == 0);
			}
			else //gc_bstrConditionTag_MsgSrcMachineIdNotEqual
			{
				(*pbConditionSatisfied) = (ret != 0);
			}
			
			// Clear property value variant
			VariantClear(&vPropertyValue);
			return S_OK;
		}

		// Clear property value variant
		VariantClear(&vPropertyValue);
		
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}
	catch( const exception&)
	{
		// Clear property value variant
		VariantClear(&vPropertyValue);

		TrERROR(Tgo, "Failed to parse rule condition: %ls for rule: %ls", (LPCWSTR)m_bstrCondition, (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}
}

//************************************************************************************
//
// Method      : ExecuteRuleAction
//
// Description : This method executes the action component of a rule. It is called only
//               if the rule-condition was evaluated as true. 
//
//               Currently this method supports two broad action types:
//
//               (1) The invocation of a COM component.
//               (2) The invocation of a stand-alone executable.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::ExecuteRuleAction(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	_bstr_t bstrToken = _T("");
	
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Get the executable type token
	m_tokAction.GetToken(ACTION_EXECUTABLETYPE_ORDINAL, bstrToken);


	// If we are invoking a COM component - then attempt to crea
	if (bstrToken == _bstr_t(xCOMAction))
	{
		return InvokeCOMComponent(pIPropertyBag.GetInterfacePtr());
	}

	if (bstrToken == _bstr_t(xEXEAction))
	{
		return InvokeEXE(pIPropertyBag.GetInterfacePtr());
	}

	TrERROR(Tgo, "Failed to parse rule action: %ls for rule: %ls", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
	return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
}

//************************************************************************************
//
// Method      : InvokeCOMComponent
//
// Description : This method will invoked the COM component specific in the rule's 
//               action string. There are 4 steps required to do this:
//
//                (1) Create the COM component identified in the action string,
//
//                (2) Prepare the array of parameters that will be passed to this 
//                    component instance, based on the rule-action definition,
//
//                (3) Execute the method identified in the rule-action string, passing
//                    the prepared parameter array,
//
//                (4) Clean up the dynamically allocated parameter array.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::InvokeCOMComponent(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	HRESULT hr = S_OK;
	DISPPARAMS disparms;
	_bstr_t bstrProgID = _T("");
	_bstr_t bstrMethodName = _T("");
	
	// in test mode will hold all relevant information about the action and it's parameters
	// when finished adding data it it, it will be sent to the "TriggersTestQueue" queue

	_bstr_t bstrTestMessageBody= _T("");

	CDispatchInterfaceProxy oObject;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	
	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	try
	{
		// Get the ProgID of the custom component we are to create. 
		m_tokAction.GetToken(ACTION_COMPROGID_ORDINAL, bstrProgID);
		m_tokAction.GetToken(ACTION_COMMETHODNAME_ORDINAL, bstrMethodName);			
	
		hr = oObject.CreateObjectFromProgID(bstrProgID);
		if FAILED(hr)
		{
			TrERROR(Tgo, "Failed to create the COM component with the ProgID %ls for rule %ls. Error 0x%x.", (LPCWSTR)bstrProgID, (LPCWSTR)m_bstrRuleID, hr);
			return MQTRIG_ERROR_CREATE_COM_OBJECT;
		}

		//
		// add the trigger ID, RuleID, MessageID, "COM", prog ID and the method name to test message body
		//
		TriggerTestInitMessageBody(&bstrTestMessageBody,pIMSMQPropertyBag,m_bstrRuleID,L"COM",L"",bstrProgID,bstrMethodName);

		//
		// For testing puposes, the bstrTestMessageBody parameter is added to this method
		//
		hr = PrepareMethodParameters(pIPropertyBag.GetInterfacePtr(),&disparms,&bstrTestMessageBody);
		if FAILED(hr)
		{
			ReleaseMethodParameters(&disparms);

			TrERROR(Tgo, "Failed to prepare the parameter structure for calling to a COM component for rule %ls. rule action: %ls. Error 0x%x", (LPCWSTR)m_bstrRuleID, (LPCWSTR)m_bstrAction, hr);
			return MQTRIG_ERROR_INVOKE_COM_OBJECT;
		}

        VARIANT vResult;
        VariantInit(&vResult);

		hr = oObject.InvokeMethod(bstrMethodName,&disparms, &vResult);
		if FAILED(hr)
		{
			ReleaseMethodParameters(&disparms);

			TrERROR(Tgo, "Failed to invoke the method %ls of COM component with ProgID %ls for rule %ls. rule action: %ls. Error 0x%x", (LPCWSTR)bstrMethodName,(LPCWSTR)bstrProgID, (LPCWSTR)m_bstrRuleID, (LPCWSTR)m_bstrAction, hr);
			return MQTRIG_ERROR_INVOKE_COM_OBJECT;
		}

		//
		// send the action & parameters to the test queue
		//
		TriggerTestSendTestingMessage(bstrTestMessageBody);                


		if(vResult.vt == VT_I4)
        {
			m_RulesProcessingStatus = (vResult.lVal == 0) ? RULES_PROCESSING_CONTINUE : RULES_PROCESSING_STOP;
        }

		//
		// Clean up the allocated method parameter
		ReleaseMethodParameters(&disparms);
		return S_OK;
	}
	catch(const _com_error& e)
	{
		TrERROR(Tgo, "The custome COM component for rule %ls throw an exception. Error 0x%x, Description: %s", m_bstrRuleID, e.Error(), e.Description());
		return MQTRIG_ERROR_INVOKE_COM_OBJECT;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to invoke COM component for rule: %ls, due to insufficient resource", (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		TrERROR(Tgo, "Failed to parse rule action: %ls for rule: %ls. Can't retrieve method name", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}
}

//************************************************************************************
//
// Method      : InvokeEXE
//
// Description : Controls the invocation of a standalone executable. This method will 
//               control the formatted of the parameters command line to be passed to 
//               the EXE, and it will create the new process.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::InvokeEXE(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	HRESULT hr = S_OK;
	_bstr_t bstrCommandLine;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	
	// in test mode will hold all relevant information about the action and it's parameters
	// when finished adding data it it, it will be sent to the "TriggersTestQueue" queue

	_bstr_t bstrTestMessageBody= _T("");
	
	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialize the startup info an process information structures
	ZeroMemory(&si,sizeof(si));
	ZeroMemory(&pi,sizeof(pi));

	si.cb = sizeof(si);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = (VARIANT_BOOL)(m_fShowWindow ? SW_SHOW : SW_HIDE);

	// Initialize the desktop parameter to use the default desktop of the interactive user.
	si.lpDesktop = _T("winsta0\\default");

	// Build the command line we will pass to the EXE
	// For testing puposes, the bstrTestMessageBody parameter is added to this method
	hr = PrepareEXECommandLine(pIPropertyBag,&bstrCommandLine,&bstrTestMessageBody); 

	if (FAILED(hr))
	{
		TrERROR(Tgo, "Failed to prepare the parameter structure for calling the standalone executable, for rule %ls. Error 0x%x", (LPCWSTR)m_bstrRuleID, hr);
		return MQTRIG_ERROR_INVOKE_EXE;
	}

	TrTRACE(Tgo, "Invoke EXE for rule %ls with command line %ls", static_cast<LPCWSTR>(m_bstrRuleID), static_cast<LPCWSTR>(bstrCommandLine));

	// Create the new process
	if(CreateProcess(NULL,                 // Name of the EXE 
					 bstrCommandLine,             // Parameters being passed to EXE
					 NULL,                        // Process security (default)
					 NULL,                        // Thread security (default)
					 FALSE,                       // Do not inherit handles 
					 NULL, //DETACHED_PROCESS     // Creation flags
					 NULL,                        // Use current environment
					 NULL,                        // Use current directory
					 &si,                         // Startup info structure
					 &pi) == FALSE)               // Returned process info
	{
		//
		// The create process failed, log an error
		//
		TrERROR(Tgo, "Failed to invoke a standalone executable, for rule %ls. Error 0x%x", (LPCWSTR)m_bstrRuleID, GetLastError());
		return MQTRIG_ERROR_INVOKE_EXE;
	}

	CloseHandle(pi.hThread);

	//
	// send the action & parameters to the test queue
	//
	TriggerTestSendTestingMessage(bstrTestMessageBody);

	if(m_fIsSerializedQueue)
	{
		DWORD dwStatus = WaitForSingleObject(pi.hProcess, INFINITE);
		ASSERT(dwStatus == WAIT_OBJECT_0); //WAIT_TIMEOUT is not possible here since timeout is infinite
		DBG_USED(dwStatus);
	}

	CloseHandle(pi.hProcess);

	return S_OK;
}

//************************************************************************************
//
// Method      : PrepareMethodParameters
//
// Description : This method prepares a parameters array for a call to a COM component
//               via the IDispatch interface. The rule action string drives which 
//               parameters are included in the parameters array - and the instance of 
//               the MSMQPropertyBag component is used to retrieve the parameter values 
//
//************************************************************************************
HRESULT CMSMQRuleHandler::PrepareMethodParameters(IMSMQPropertyBag * pIMSMQPropertyBag,DISPPARAMS * pdispparms,_bstr_t * pbstrTestMessageBody)
{
	HRESULT hr = S_OK;
	long lArgCounter = 0;
	long lArgCount = 0;
	_bstr_t bstrArg = _T("");
	VARIANTARG vArg;
	VARIANTARG * pvarg = NULL;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialise the disparms structure
	_fmemset(pdispparms, 0, sizeof DISPPARAMS); 

	// Determine how many args there are to process (remember first three tokens are not args).
	lArgCount = m_tokAction.GetNumTokens() - 3;

	// Check if there are no arguements - in this case - define an empty dispparms block.
	if (lArgCount == 0)
	{
		pdispparms->rgvarg = NULL;
		pdispparms->cArgs = 0;
		pdispparms->cNamedArgs = 0;
		pdispparms->rgdispidNamedArgs = 0;
	}
	else
	{
		// We definately have arguements to pass, allocate and initialise disparms structure.
        pvarg = new VARIANTARG[lArgCount]; 

        ZeroMemory(pvarg,sizeof(VARIANTARG) * lArgCount); 

		// Initialise our general purpose variant.
		VariantInit(&vArg);

		// NOTE that this index is used with a 1 base.
		lArgCounter = 1;

		// For each token - check if it matches a predefined type. If not - assign a literal value.
		while ((lArgCounter <= lArgCount) && (SUCCEEDED(hr)))
		{
			// Release any memory used by this variant before using again.
			VariantClear(&vArg);

			try
			{
				// Get the next argument (remember first three tokens are not args and the token list is 0 based.)
				m_tokAction.GetToken(lArgCounter + 2, bstrArg);
			}
			catch(const exception&)
			{
				TrERROR(Tgo, "Failed to retrieve an arguement value from the MSMQPropertyBag. Rule id: %ls. Parameter: %ls, Erroe 0x%x.", (LPCWSTR)m_bstrRuleID, (LPCWSTR)bstrArg, hr);
				return MQTRIG_ERROR_INVOKE_EXE;
			}

			hr = GetArgumentValue(pIMSMQPropertyBag,bstrArg,&vArg);				

			if SUCCEEDED(hr)
			{
				// Initialise the current variant arg in the structure of arguments
				VariantInit(&pvarg[lArgCount - lArgCounter]);

				// Copy the prepared parameter into the structure.
				VariantCopy(&pvarg[lArgCount - lArgCounter],&vArg);

				// add parameter and it's type to test message body
				TriggerTestAddParameterToMessageBody(pbstrTestMessageBody,bstrArg,vArg);
			}			


			// Process the next arguement
			lArgCounter++;
		}

		//Final clear
		VariantClear(&vArg);

		// Attach the array of prepared arguments to the dispparms structure
		pdispparms->rgvarg = pvarg;
		pdispparms->cArgs = lArgCount;
		pdispparms->cNamedArgs = 0;
		pdispparms->rgdispidNamedArgs = 0;
	}

	return (hr);
}

//************************************************************************************
//
// Method      : PrepareEXECommandLine
//
// Description : This method prepares a command line for a call to a standalone EXE.
//               The rule action string determines which parameters are included in the
//               commandline, and the instance of the MSMQPropertyBag component is used
//               to retrieve the parameter values 
//
//************************************************************************************
HRESULT 
CMSMQRuleHandler::PrepareEXECommandLine(
	IMSMQPropertyBag * pIMSMQPropertyBag,
	_bstr_t * pbstrCommandLine,
	_bstr_t * pbstrTestMessageBody
	)
{
	HRESULT hr = S_OK;
	long lArgCount = 0;
	long lArgCounter = 0;
	_bstr_t bstrTempCmdLine = _T("");
	_bstr_t bstrArg = _T("");
	VARIANTARG vArg;
	VariantInit(&vArg);
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Get the EXE name of the process as the start of the command line.
	if (m_tokAction.GetNumTokens() < ACTION_EXE_NAME)
	{
		TrERROR(Tgo, "Invalid rule action parameter, %ls", static_cast<LPCWSTR>(m_bstrAction));
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}

	m_tokAction.GetToken(ACTION_EXE_NAME, bstrTempCmdLine);

	// If the exe name is not in quotes, and there is an embedded space (as often happens w
	// with long filenames), then we will want to enclose the exe name in double quotes now.
	if ((IsEnclosedInQuotes(bstrTempCmdLine) == false) && (wcsstr((wchar_t*)bstrTempCmdLine,_T(" ")) != NULL))
	{
		(*pbstrCommandLine) = _T("\"");
		(*pbstrCommandLine) = (*pbstrCommandLine) + bstrTempCmdLine;
		(*pbstrCommandLine) = (*pbstrCommandLine) + _T("\" ");	
	}
	else
	{
		(*pbstrCommandLine) = (*pbstrCommandLine) + bstrTempCmdLine;
		(*pbstrCommandLine) = (*pbstrCommandLine) + _T(" ");
	}
	
	// add the trigger ID, RuleID, MessageID, "EXE" and EXE name to test message body	
	TriggerTestInitMessageBody(pbstrTestMessageBody,pIMSMQPropertyBag,m_bstrRuleID,L"EXE",*pbstrCommandLine,L"",L"");
	
	// Determine how many args there are to process (remember first two tokens are not args).
	lArgCount = m_tokAction.GetNumTokens() - 2;

	// For each token - check if it matches a predefined type. If not - assign a literal value.
	while ((lArgCounter < lArgCount) && (SUCCEEDED(hr)))
	{
		VariantClear(&vArg);


		// Get the next argument (remember first two tokens are not args and the token list is 0 based.)
		m_tokAction.GetToken(lArgCounter + 2, bstrArg);

		hr = GetArgumentValue(pIPropertyBag,bstrArg,&vArg);
		

		if SUCCEEDED(hr)
		{
			_variant_t vConvertedArg;
			
			// Change the variant into a BSTR type
			hr = VariantChangeType(&vConvertedArg,&vArg,NULL,VT_BSTR);
			
			// If we succeeded, append BSTR parameter to the command line. Note that
			// we want to wrap each parameter in double quotes so that console applications
			// dont get confused about how many parameters we have passed them.
			if SUCCEEDED(hr)
			{
				// If we are processing more than one argument, append a delimiting space character
				if (lArgCounter > 0)
				{
					(*pbstrCommandLine) += _T(" ");
				}

				(*pbstrCommandLine) += _T("\"");

				if (bstrArg == gc_bstrPARM_MSG_ID ||
					bstrArg == gc_bstrPARM_MSG_CORRELATION_ID)
				{
					OBJECTID* pObj = (OBJECTID*)(vConvertedArg.pbVal);

					WCHAR strId[256];
					ObjectIDToString(pObj, strId, 256);

					(*pbstrCommandLine) += (_bstr_t)strId;
				}
				else
				{
					(*pbstrCommandLine) += (_bstr_t)vConvertedArg;
				}

				(*pbstrCommandLine) += _T("\"");
				
				// add parameter and it's type to test message body
				TriggerTestAddParameterToMessageBody(pbstrTestMessageBody,bstrArg,vArg);
			}
			else
			{
				TrERROR(Tgo, "Failed to Convert a variant from one type to another for rule %ls.	Error 0x%x", (LPCWSTR)m_bstrRuleID, hr);
				hr = MQTRIG_ERROR_INVOKE_EXE;
				break;
			}
		}
		else
		{
			TrERROR(Tgo, "Failed to retrieve an arguement value from the MSMQPropertyBag. Rule id: %ls. Parameter: %ls, Erroe 0x%x.", (LPCWSTR)m_bstrRuleID, (LPCWSTR)bstrArg, hr);
			hr = MQTRIG_ERROR_INVOKE_EXE;
			break;
		}

		// Process the next arguement
		lArgCounter++;
	}

	// Release resources used by vArg.
	VariantClear(&vArg);

	return(hr);
}

//************************************************************************************
//
// Method      : ReleaseMethodParameters
//
// Description : This method is used to de-allocate the resources consumed by the 
//               parameters array used when making a call to a COM component.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::ReleaseMethodParameters(DISPPARAMS * pdispparms)
{
	HRESULT hr = S_OK;

	if (pdispparms->rgvarg != NULL)
	{
		for(DWORD lArgCounter=0; lArgCounter < pdispparms->cArgs; lArgCounter++)
		{
			hr = VariantClear(&pdispparms->rgvarg[lArgCounter]);		
		}

		delete pdispparms->rgvarg;
	}	

	return(hr);
}

//************************************************************************************
//
// Method      : GetArgumentValue
//
// Description : This method is used to retrieve a property value from the instance of
//               MSMQPropertyBag component. This retrieval logic is separated out in 
//               a separate method (as opposed to using the pIMSMQPropertyBag instance 
//               from the caller g
//               
//
//************************************************************************************
HRESULT 
CMSMQRuleHandler::GetArgumentValue(
    IMSMQPropertyBag * pIMSMQPropertyBag,
    bstr_t bstrArg,
    VARIANTARG * pvArgValue
    )
{
	HRESULT hr = S_OK;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);
	
	if(bstrArg == gc_bstrPARM_MSG_ID)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_MsgID,pvArgValue);
	}			
	else if (bstrArg == gc_bstrPARM_MSG_LABEL)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_Label,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_MSG_BODY)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_MsgBody,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_MSG_BODY_AS_STRING)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_MsgBody,pvArgValue);

		if SUCCEEDED(hr)
		{
			hr = ConvertFromByteArrayToString(pvArgValue);
		}
	}
	else if (bstrArg == gc_bstrPARM_MSG_PRIORITY) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_MsgPriority,pvArgValue);
	}		
	else if (bstrArg == gc_bstrPARM_MSG_CORRELATION_ID) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_CorID,pvArgValue);			
	}
	else if (bstrArg == gc_bstrPARM_MSG_QUEUE_PATHNAME) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_QueuePathname,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_MSG_QUEUE_FORMATNAME) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_QueueFormatname,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_MSG_APPSPECIFIC) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_AppSpecific,pvArgValue);			
	}
	else if (bstrArg == gc_bstrPARM_MSG_RESPQUEUE_FORMATNAME) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_ResponseQueueName,pvArgValue);			
	}
	else if (bstrArg == gc_bstrPARM_MSG_ADMINQUEUE_FORMATNAME) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_AdminQueueName,pvArgValue);			
	}
	else if (bstrArg == gc_bstrPARM_MSG_ARRIVEDTIME)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_ArrivedTime,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_MSG_SENTTIME)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_SentTime,pvArgValue);
	}
	else if ( bstrArg == gc_bstrPARM_MSG_SRCMACHINEID)
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_SrcMachineId,pvArgValue);
	}
    else if (bstrArg == gc_bstrPARM_MSG_LOOKUPID)
    {
        hr = pIPropertyBag->Read(gc_bstrPropertyName_LookupId,pvArgValue);
    }
	else if (bstrArg == gc_bstrPARM_TRIGGER_NAME) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_TriggerName,pvArgValue);
	}
	else if (bstrArg == gc_bstrPARM_TRIGGER_ID) 
	{
		hr = pIPropertyBag->Read(gc_bstrPropertyName_TriggerID,pvArgValue);
	}
	else // Interpret as a literal value, either string or numeric.
	{
		if (IsEnclosedInQuotes(bstrArg))
		{
			hr = ConvertToUnquotedVariant(bstrArg,pvArgValue);
		}
		else // Assume it's numeric - attempt to convert it to a string 
		{		
		
			VARIANT vStringArg;
			VariantInit(&vStringArg);

			vStringArg.vt = VT_BSTR;
			vStringArg.bstrVal = bstrArg;

			hr = VariantChangeType(pvArgValue,&vStringArg,NULL,VT_I4);
			
			if FAILED(hr)
			{
				TrERROR(Tgo, "Failed to Convert a variant from one type to another. rule %ls.	Error 0x%x", m_bstrRuleID, hr);
			}
		}
	}

	return(hr);
}

//************************************************************************************
//
// Method      : IsEnclosedInQuotes
//
// Description : returns true if the supplied string is wrapped in either single or 
//               double quotes. Returns false otherwise.
//
// Note        : this method test that both the begginning and the end of the string
//               are quote characters , of the same type (i.e. both single quotes or
//               both double quotes)
//
//************************************************************************************
bool CMSMQRuleHandler::IsEnclosedInQuotes(_bstr_t bstrString)
{
	TCHAR * pchFirstChar = (wchar_t*)bstrString;
	TCHAR * pchLastChar = pchFirstChar + (bstrString.length() - 1);

	if (((memcmp(pchFirstChar,_T("\""),sizeof(TCHAR)) == 0) ||  
	  	 (memcmp(pchFirstChar,_T("'"),sizeof(TCHAR)) == 0)) &&
		((memcmp(pchLastChar,_T("\""),sizeof(TCHAR)) == 0) ||
		 (memcmp(pchLastChar,_T("'"),sizeof(TCHAR)) == 0)))
	{
		return true;
	}	
	else
	{
		return false;
	}
}

//************************************************************************************
//
// Method      : ConvertToUnquotedVariant
//
// Description : Converts the supplied quoted string into an unquoted string, and 
//               returns the result in a VARINAT datatype.
//
//************************************************************************************
bool CMSMQRuleHandler::ConvertToUnquotedVariant(_bstr_t bstrString, VARIANT * pv)
{
	HRESULT hr = S_OK;
	TCHAR * pchFirstChar = (wchar_t*)bstrString;
	TCHAR * pchFirstDataChar = pchFirstChar + 1;
	TCHAR * pszBuffer = NULL;
	DWORD dwNewStringSize = bstrString.length() - 2;  // Remove quotes
	DWORD dwNewStringBufferSize = dwNewStringSize * sizeof(TCHAR) + sizeof(TCHAR);

	// ensure that the supplied string is actually quoted. 
	ASSERT(IsEnclosedInQuotes(bstrString));

	// intialize the supplied variant value.
	hr = VariantClear(pv);

	if (dwNewStringSize == 0) // Check for empty string.
	{
		pv->vt = VT_BSTR;
		pv->bstrVal = SysAllocString(_T(""));			
	}
	else
	{
		pszBuffer = new TCHAR[dwNewStringBufferSize];

		if (pszBuffer != NULL)
		{
			ZeroMemory(pszBuffer,dwNewStringBufferSize);
			memcpy(pszBuffer,pchFirstDataChar,(dwNewStringSize * sizeof(TCHAR)));
		
			pv->vt = VT_BSTR;
			pv->bstrVal = SysAllocString(pszBuffer);

			delete(pszBuffer);
		}
		else
		{
			// memory allocation failed.
			hr = E_FAIL;		
		}
	}

	return ((bool)(hr == S_OK));
}


void CMSMQRuleHandler::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#ifndef __TRIGOBJ_STDAFX_H__
#define __TRIGOBJ_STDAFX_H__

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>


const TraceIdEntry Tgu = L"Trigger Utilities";
const TraceIdEntry Tgo = L"Trigger Objects";
const TraceIdEntry Tgt = L"Trigger Test";

const TraceIdEntry xTriggerObjectsComponent[] = {Tgu, Tgo, Tgt};


void TrigReAllocString(BSTR* pbstr,	LPCWSTR psz);
void GetErrorDescription(HRESULT hr, LPWSTR errmsg, DWORD size);


#endif __TRIGOBJ_STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\ruleset.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQRuleSet
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the COM implementation of the IMSMQRuleSet interface. This 
//               component is used for accessing and manipulating trigger rule 
//               definitions.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqsymbls.h"
#include "mqtrig.h"
#include "mqtg.h"
#include "ruleset.hpp"
#include "clusfunc.h"

#include "ruleset.tmh"

using namespace std;


//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard rich error info interface.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQRuleSet
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Initializes the CMSMQRuleSet instance.
//
//************************************************************************************
CMSMQRuleSet::CMSMQRuleSet()
{
	m_pUnkMarshaler = NULL;
	m_hHostRegistry= NULL;

	// Set the name of this class for future reference in tracing & logging etc..
	m_bstrThisClassName  = _T("MSMQRuleSet");
	m_fHasInitialized = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Releases resources owned by this class instance.
//
//************************************************************************************
CMSMQRuleSet::~CMSMQRuleSet()
{
	// Release resources currently held by the rule cache
	ClearRuleMap();

	// Close the registry handle 
	if (m_hHostRegistry != NULL)
	{
		RegCloseKey(m_hHostRegistry);
	}
}

STDMETHODIMP CMSMQRuleSet::Init(BSTR bstrMachineName)
{
	TrTRACE(Tgo, "RuleSet initilization. Computer name: %ls", static_cast<LPCWSTR>(bstrMachineName));

	bool fRes = CMSMQTriggerNotification::Init(bstrMachineName);
	if ( !fRes )
	{
		TrERROR(Tgo, "Failed to initialize rule set for computer %ls", (LPCWSTR)bstrMachineName);

		SetComClassError(MQTRIG_ERROR_INIT_FAILED);
		return MQTRIG_ERROR_INIT_FAILED;
	}
	
	return S_OK;
}


//************************************************************************************
//
// Method      : ClearRuleMap
//
// Description : This method destroys the contents of the current rule map.
//
//************************************************************************************
void CMSMQRuleSet::ClearRuleMap()
{
	TrTRACE(Tgo, "Call CMSMQRuleSet::ClearRuleMap().");

	RULE_MAP::iterator i = m_mapRules.begin();
	CRuntimeRuleInfo * pRule = NULL;

	while ((i != m_mapRules.end()) && (!m_mapRules.empty()))
	{
		// Cast to a rule pointer
		pRule = (*i).second;

		// We should never have null pointers in this map.
		ASSERT(pRule != NULL);

		// delete this rule object.
		delete pRule;

		// Reinitialize the rule pointer
		pRule = NULL;

		// Look at the next item in the map.
		i = m_mapRules.erase(i);
	}
}

//************************************************************************************
//
// Method      : DumpRuleMap
//
// Description : This method dumps the contents of the rule map to the debugger. This
//               should only be invoked from a _DEBUG build.
//
//************************************************************************************
_bstr_t CMSMQRuleSet::DumpRuleMap()
{
	_bstr_t bstrTemp;
	_bstr_t bstrRuleMap;
	long lRuleCounter = 0;
	RULE_MAP::iterator i = m_mapRules.begin();
	CRuntimeRuleInfo * pRule = NULL;

	bstrRuleMap = _T("\n");

	while ((i != m_mapRules.end()) && (!m_mapRules.empty()))
	{
		// Cast to a rule pointer
		pRule = (*i).second;

		// We should never have null pointers in this map.
		ASSERT(pRule != NULL);

		FormatBSTR(&bstrTemp,_T("\nRule(%d)\t ID(%s)\tName(%s)"),lRuleCounter,(wchar_t*)pRule->m_bstrRuleID,(wchar_t*)pRule->m_bstrRuleName);

		bstrRuleMap += bstrTemp;

		// Increment the rule count
		lRuleCounter++;

		// Reinitialize the rule pointer
		pRule = NULL;

		// Look at the next item in the map.
		i++;
	}

	bstrRuleMap += _T("\n");

	return(bstrRuleMap);
}

//************************************************************************************
//
// Method      : Refresh
//
// Description : This method rebuilds the map of rule data cached by this component. 
//               This method must be called at least once by a client component that 
//               intends to manage rule data.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::Refresh()
{
	TrTRACE(Tgo, "CMSMQRuleSet::Refresh()");

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try 
	{	
		// Release resources currently held by the rule cache
		ClearRuleMap();

		if (PopulateRuleMap(m_mapRules) == false)
		{
			TrERROR(Tgo, "Failed to refresh ruleset");

			SetComClassError(MQTRIG_ERROR_COULD_NOT_RETREIVE_RULE_DATA);			
			return MQTRIG_ERROR_COULD_NOT_RETREIVE_RULE_DATA;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of rules currently cached in the map.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::get_Count(long *pVal)
{
	TrTRACE(Tgo, "CMSMQRuleSet::get_Count. pValue = 0x%p", pVal);
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	if (pVal == NULL)
	{
		TrERROR(Tgo, "CMSMQRuleSet::get_Count, invalid parameter");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	//
	// Get the size from the map structure.
	//
	*pVal = numeric_cast<long>(m_mapRules.size());

	return S_OK;
}

//************************************************************************************
//
// Method      : GetRuleDetailsByID
//
// Description : Returns the rule details for the rule with the supplied RuleID.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::GetRuleDetailsByID(/* [in] */  BSTR sRuleID,
											  /* [out] */ BSTR *psRuleName,
											  /* [out] */ BSTR *psDescription,
											  /* [out] */ BSTR *psCondition,
											  /* [out] */ BSTR *psAction,
											  /* [out] */ BSTR *psImplementationProgID,
											  /* [out] */ BOOL *pfShowWindow)
{
	TrTRACE(Tgo, "CMSMQRuleSet::GetRuleDetailsByID. sRuleID = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(Tgo, "Invalid rule ID passed to GetRuleDetailsByID. sRuleID = %ls", (LPCWSTR)sRuleID);

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}

		// Convert the BSTR rule ID to an STL basic string.
		wstring bsRuleID;
		bsRuleID = (wchar_t*)sRuleID;

		// Attempt to find this rule id in the map of rules.
		RULE_MAP::iterator i = m_mapRules.find(bsRuleID);

		// Check if we have found the rule
		if (i != m_mapRules.end())
		{
			// Cast to a rule object reference 
			CRuntimeRuleInfo * pRule = (*i).second;

			// We should never have nulls in the map
			ASSERT(pRule != NULL);

			// We should only store valid rules.
			ASSERT(pRule->IsValid());

			// Populate out parameters if they have been supplied. 
			if (psRuleName != NULL)
			{
				TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
			}
			if (psDescription != NULL)
			{
				TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
			}
			if (psCondition != NULL)
			{
				TrigReAllocString(psCondition,pRule->m_bstrCondition);
			}
			if (psAction != NULL)
			{
				TrigReAllocString(psAction,pRule->m_bstrAction);
			}
			if (psImplementationProgID != NULL)
			{
				TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
			}
			if(pfShowWindow != NULL)
			{
				*pfShowWindow = pRule->m_fShowWindow;
			}
        }
		else
		{
			TrERROR(Tgo, "The supplied rule id was not found in the rule store. rule: %ls", bsRuleID.c_str());
			
			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : GetRuleDetailsByIndex
//
// Description : Returns the rule details for the rule with the supplied index. Note
//               that this is a 0 base index.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::GetRuleDetailsByIndex(/* [in] */  long lRuleIndex, 
												 /* [out] */ BSTR *psRuleID,
												 /* [out] */ BSTR *psRuleName,
												 /* [out] */ BSTR *psDescription,
												 /* [out] */ BSTR *psCondition,
												 /* [out] */ BSTR *psAction,
												 /* [out] */ BSTR *psImplementationProgID,
												 /* [out] */ BOOL *pfShowWindow)
{
	TrTRACE(Tgo, "CMSMQRuleSet::GetRuleDetailsByIndex. index = %d", lRuleIndex);

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	// We need to validate that the supplied rule index is within range
 	if ((lRuleIndex < 0) || (numeric_cast<DWORD>(lRuleIndex) > m_mapRules.size()))
	{
		TrERROR(Tgo, "The supplied rule index was invalid. ruleIndex=%d", lRuleIndex);
		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}
	
	try
	{
		// Get a reference to the beginging of the map
		RULE_MAP::iterator i = m_mapRules.begin();

		// Iterate through to the correct index. 
		for (long lCounter = 0; lCounter < lRuleIndex ; ++i,lCounter++)
		{
			NULL;
		}

		// Cast to a rule object reference 
		CRuntimeRuleInfo* pRule = (*i).second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psRuleID != NULL)
		{
			TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
		}
		if (psRuleName != NULL)
		{
			TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
		}
		if (psDescription != NULL)
		{
			TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
		}
		if (psCondition != NULL)
		{
			TrigReAllocString(psCondition,pRule->m_bstrCondition);
		}
		if (psAction != NULL)
		{
			TrigReAllocString(psAction,pRule->m_bstrAction);
		}
		if (psImplementationProgID != NULL)
		{
			TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
		}
		if(pfShowWindow != NULL)
		{
			*pfShowWindow = pRule->m_fShowWindow;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Delete
//
// Description : This method delete the rule with the specified rule id from the 
//               trigger store.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::Delete(BSTR sRuleID)
{
	TrTRACE(Tgo, "CMSMQRuleSet::Delete. rule = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}


	try
	{
		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(Tgo, "Invalid parameter to CMSMQRuleSet::Delete.");

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}

		// Convert the BSTR rule ID to an STL basic string.
		wstring bsRuleID = (wchar_t*)sRuleID;

		// Attempt to find this rule id in the map of rules.
		RULE_MAP::iterator it = m_mapRules.find(bsRuleID);

		// Check if we have found the rule
		if (it == m_mapRules.end())
        {
            //
            // rule wasn't found
            //
			TrERROR(Tgo, "The supplied rule id was not found. rule: %ls", bsRuleID.c_str());

			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
        }

		// Cast to a rule object reference 
    	CRuntimeRuleInfo* pRule = it->second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Attempt to delete the rule
		bool fSucc = pRule->Delete(m_hHostRegistry);
		if(!fSucc)
		{
			//
			// Failed to delete the rule. Dont remove the rule from the map
			//
			SetComClassError(MQTRIG_ERROR_COULD_NOT_DELETE_RULE);
			return MQTRIG_ERROR_COULD_NOT_DELETE_RULE;
		};

        //
        // Delete success. Remove the rule from rule map and delete the rule instance
        //
		NotifyRuleDeleted(sRuleID);
		m_mapRules.erase(it);
        delete pRule;

        return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Add
//
// Description : This method add a new rule to the trigger store. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleSet::Add(
    BSTR sName, 
    BSTR sDescription, 
    BSTR sCondition, 
    BSTR sAction, 
    BSTR sImplementation, 
    BOOL fShowWindow, 
    BSTR *psRuleID
    )
{
	TrTRACE(Tgo, "CMSMQRuleSet::Add. rule name = %ls", static_cast<LPCWSTR>(sName));

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try
	{
		//
		// Validate the supplied method parameters.
		//
		if (!CRuntimeRuleInfo::IsValidRuleName(sName))
		{
			TrERROR(Tgo, "The supplied rule name for CMSMQRuleSet::Add is invalid. rule name: %ls", (LPCWSTR)sName);

			SetComClassError(MQTRIG_INVALID_RULE_NAME);			
			return MQTRIG_INVALID_RULE_NAME;
		}
	
		if (!CRuntimeRuleInfo::IsValidRuleCondition(sCondition))
		{
			TrERROR(Tgo, "The supplied rule condition for CMSMQRuleSet::Add is invalid. rule condition: %ls", (LPCWSTR)sCondition);

			SetComClassError(MQTRIG_INVALID_RULE_CONDITION);			
			return MQTRIG_INVALID_RULE_CONDITION;
		}

		if (!CRuntimeRuleInfo::IsValidRuleAction(sAction))
		{
			TrERROR(Tgo, "The supplied rule action for CMSMQRuleSet::Add is invalid. rule action: %ls", (LPCWSTR)sAction);
			
			SetComClassError(MQTRIG_INVALID_RULE_ACTION);			
			return MQTRIG_INVALID_RULE_ACTION;
		}

		if (!CRuntimeRuleInfo::IsValidRuleDescription(sDescription))
		{
			TrERROR(Tgo, "The supplied rule description for CMSMQRuleSet::Add is invalid. rule description: %ls", (LPCWSTR)sDescription);
			
			SetComClassError(MQTRIG_INVALID_RULE_DESCRIPTION);			
			return MQTRIG_INVALID_RULE_DESCRIPTION;
		}

		//
		// Currently only support use of default MS implementation.
		//
		sImplementation = _T("MSMQTriggerObjects.MSMQRuleHandler");

		//
		// Allocate a new rule object
		//
		P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo(
											CreateGuidAsString(),
											sName,
											sDescription,
											sCondition,
											sAction,
											sImplementation,
											m_wzRegPath,
											(fShowWindow != 0) );

		
		bool fSucc = pRule->Create(m_hHostRegistry);
		if (fSucc)
		{
			//
			// Keep rule ID  for later use
			//
			BSTR bstrRuleID = pRule->m_bstrRuleID;

			//
			// Add this rule to our map of rules.
			//
			m_mapRules.insert(RULE_MAP::value_type(bstrRuleID, pRule));
			pRule.detach();


			//
			// If we have been supplied a out parameter pointer for the new rule ID use it.
			//
			if (psRuleID != NULL)
			{
				TrigReAllocString(psRuleID, bstrRuleID);
			}

			NotifyRuleAdded(bstrRuleID, sName);

			return S_OK;
		}

		TrERROR(Tgo, "Failed to store rule data in registry");
		return MQTRIG_ERROR_STORE_DATA_FAILED;

	}
	catch(const bad_alloc&)
	{
		SysFreeString(*psRuleID);

		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Update
//
// Description : This method updates the nominated rule with new parameters.
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleSet::Update(
	BSTR sRuleID, 
	BSTR sName, 
	BSTR sDescription, 
	BSTR sCondition, 
	BSTR sAction, 
	BSTR sImplementation, 
	BOOL fShowWindow
	)
{
	TrTRACE(Tgo, "CMSMQRuleSet::Update. rule = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	//
	// Validate the supplied method parameters.
	//
	if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
	{
		TrERROR(Tgo, "Invalid parameter to CMSMQRuleSet::Delete.");

		SetComClassError(MQTRIG_INVALID_RULEID);
		return MQTRIG_INVALID_RULEID;
	}

 	if (!CRuntimeRuleInfo::IsValidRuleName(sName))
	{
		TrERROR(Tgo, "The supplied rule name for CMSMQRuleSet::Add is invalid. rule name: %ls", (LPCWSTR)sName);

		SetComClassError(MQTRIG_INVALID_RULE_NAME);
		return MQTRIG_INVALID_RULE_NAME;
	}
	
	if (!CRuntimeRuleInfo::IsValidRuleCondition(sCondition))
	{
		TrERROR(Tgo, "The supplied rule condition for CMSMQRuleSet::Add is invalid. rule condition: %ls", (LPCWSTR)sCondition);

		SetComClassError(MQTRIG_INVALID_RULE_CONDITION);
		return MQTRIG_INVALID_RULE_CONDITION;
	}

	if (!CRuntimeRuleInfo::IsValidRuleAction(sAction))
	{
		TrERROR(Tgo, "The supplied rule action for CMSMQRuleSet::Add is invalid. rule action: %ls", (LPCWSTR)sAction);

		SetComClassError(MQTRIG_INVALID_RULE_ACTION);
		return MQTRIG_INVALID_RULE_ACTION;
	}

	if (!CRuntimeRuleInfo::IsValidRuleDescription(sDescription))
	{
		TrERROR(Tgo, "The supplied rule description for CMSMQRuleSet::Add is invalid. rule description: %ls", (LPCWSTR)sDescription);

		SetComClassError(MQTRIG_INVALID_RULE_DESCRIPTION);
		return MQTRIG_INVALID_RULE_DESCRIPTION;
	}

	sImplementation = _T("MSMQTriggerObjects.MSMQRuleHandler");	

	try
	{
		//
		// Convert the BSTR rule ID to an STL basic string.
		//
		wstring bsRuleID = (wchar_t*)sRuleID;

		//
		// Attempt to find this rule id in the map of rules.
		//
		RULE_MAP::iterator it = m_mapRules.find(bsRuleID);

		// Check if we found the nominated rule.
		if (it == m_mapRules.end())
		{
			TrERROR(Tgo, "The rule could not be found. rule: %ls", (LPCWSTR)sRuleID);

			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
		}

		// Cast to a rule object reference 
		CRuntimeRuleInfo* pRule = it->second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Update the rule object with new parameters if they have been supplied. 
		if (sName != NULL)
		{
			pRule->m_bstrRuleName = (wchar_t*)sName;
		}
		if (sCondition != NULL)
		{
			pRule->m_bstrCondition = (wchar_t*)sCondition;
		}
		if (sAction != NULL)
		{
			pRule->m_bstrAction = (wchar_t*)sAction;
		}
		if (sImplementation != NULL)
		{
			pRule->m_bstrImplementationProgID = (wchar_t*)sImplementation;
		}
		if (sDescription != NULL)
		{
			pRule->m_bstrRuleDescription = (wchar_t*)sDescription;
		}

		pRule->m_fShowWindow = (fShowWindow != 0);

		// Confirm that the rule is still valid before updating
		bool fSucc = pRule->Update(m_hHostRegistry);
		if (!fSucc)
		{
			TrERROR(Tgo, "Failed to store the updated data for rule: %ls in registry", (LPCWSTR)sRuleID);
			return MQTRIG_ERROR_STORE_DATA_FAILED;
		}

		NotifyRuleUpdated(sRuleID, sName);
		
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//************************************************************************************
//
// Method      : PopulateRuleMap
//
// Description : Populates the rule map with instances of the CRuntimeRuleInfo class
//               based on the data found in the registry.
//
//************************************************************************************
bool CMSMQRuleSet::PopulateRuleMap(RULE_MAP &mapRules)
{
	bool bOK = true;
	CRegKey oRegKey;
	long lKeyOpened = 0;
	DWORD dwIndex =0;
	TCHAR szSubKeyBuffer[MAX_REGKEY_NAME_SIZE];
	DWORD dwSubKeyBufferSize = MAX_REGKEY_NAME_SIZE;
	FILETIME ftLastWriteTime;
	CRuntimeRuleInfo * pRule = NULL;
	wstring sRuleID;

	// Make sure we have a connection to the registry 
	bOK = ConnectToRegistry();

	TCHAR wzRulePath[MAX_REGKEY_NAME_SIZE];
	if (bOK == true)
	{

		_tcscpy( wzRulePath, m_wzRegPath );
		_tcscat( wzRulePath, REG_SUBKEY_RULES );

		// Open the key where the rule data can be found.
		lKeyOpened = oRegKey.Create(
            m_hHostRegistry,
            wzRulePath,
            REG_NONE,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            NULL
            );

		if (lKeyOpened != ERROR_SUCCESS)
		{
			//
			// Failed to allocate CRuntimeRuleInfo structure - log an error and set return code.
			//
			TrERROR(Tgo, "Failed to open the registry key: %ls",  wzRulePath);
		}
	}

	// Enumerate through the keys under the Rules key. Each subkey here should be a RuleID. As we 
	// enumerate through these keys, we will populate the rule map with instance of the CRuntimeRuleInfo
	// class. We stop if any rule fails to load.
	while ((lKeyOpened == ERROR_SUCCESS) && (bOK == true))
	{
		// Initialise the subkey buffer.
		ZeroMemory(szSubKeyBuffer,sizeof(szSubKeyBuffer));

		// Reinitialize the size of buffer that holds the key name
		dwSubKeyBufferSize = MAX_REGKEY_NAME_SIZE;

		// Attempt to open the next sub key (pointed to by dwIndex)
		lKeyOpened =  RegEnumKeyEx(oRegKey.m_hKey,                 // handle to key to enumerate
								   dwIndex,                        // index of subkey to enumerate
								   (LPTSTR)(&szSubKeyBuffer),      // address of buffer for subkey name
								   &dwSubKeyBufferSize,            // address for size of subkey buffer
								   NULL,                           // reserved
								   NULL,                           // address of buffer for class string
								   NULL,                           // address for size of class buffer
								   (PFILETIME)(&ftLastWriteTime) );

		// If the key was opened - then we will try to load this rule.
		if (lKeyOpened == ERROR_SUCCESS)
		{
			// Allocate a new rule structure.
			pRule = new CRuntimeRuleInfo(m_wzRegPath);

			// Retreive the rule. Note the subkey buffer is actually the RuleID
			bOK = pRule->Retrieve(m_hHostRegistry,(LPCTSTR)szSubKeyBuffer);

			if (bOK == false)
			{
				//
				// Failed to load the rule. Log an error and delete the rule object.
				//
				TrERROR(Tgo, "Failed to load rule: %ls from registry key: %ls.", szSubKeyBuffer, wzRulePath);
				delete pRule;
			}

			// At this point we have successfully loaded the rule, now insert it into the rule map.
			if (bOK == true)
			{
				// Convert rule id to an STL basic string
				sRuleID = pRule->m_bstrRuleID;

				// Check if this rule is already in the map.
				RULE_MAP::iterator i = mapRules.find(sRuleID);

				if(i == mapRules.end())
				{
					mapRules.insert(RULE_MAP::value_type(sRuleID,pRule));
				}
				else
				{
					TrTRACE(Tgo, "Duplicate rule id was found. rule: %ls.", static_cast<LPCWSTR>(pRule->m_bstrRuleID));
					delete pRule;
				}
			}

			// Increment the index so that we look for the next rule sub-key
			dwIndex++;
		}
	}

	// At this point, the only valid value of the lKeyOpened retcode is  ERROR_NO_MORE_ITEMS. 
	// Any other value indicates that something went wrong.
	if (bOK == true) 
	{
		if (lKeyOpened != ERROR_NO_MORE_ITEMS)
		{
			TrERROR(Tgo, "CMSMQRuleSet::PopulateRuleMap() has failed with enumerating the registry keys below %ls. The sub key being processed was at index %d. The error code from the registry call was %d", wzRulePath, dwIndex, lKeyOpened);
			// Indicatge that something went wrong.
			bOK = false;
		}
		else
		{
			TrTRACE(Tgo, "A total of %d trigger rules have been loaded.", (long)mapRules.size());
		}
	}

	return(bOK);
}


STDMETHODIMP CMSMQRuleSet::get_TriggerStoreMachineName(BSTR *pVal)
{
	TrTRACE(Tgo, "CMSMQRuleSet::get_TriggerStoreMachineName(). pVal = 0x%p", pVal);

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	
	if(pVal == NULL)
	{
		TrERROR(Tgo, "Inavlid parameter to get_TriggerStoreMachineName");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	try
	{
		TrigReAllocString(pVal, (TCHAR*)m_bstrMachineName);
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


void CMSMQRuleSet::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\ruleset.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 02/01/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQRULESET_H_
#define __MSMQRULESET_H_

#include "resource.h"        

// Base class that handle receiving and sending notification msgs
#include "trignotf.hpp"

// Used to allow STL to compile without thousands of warnings.
#pragma warning(disable:4786)

// Include the definition of the CRuntimeRuleInfo class (used to hold rule info)
#include "ruleinfo.hpp"

// Define a new type - a 2D map of Rule-ID's and pointers to instance of CRuntimeRuleInfo
typedef std::map<std::wstring,CRuntimeRuleInfo*, std::less<std::wstring> > RULE_MAP;

class ATL_NO_VTABLE CMSMQRuleSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQRuleSet, &CLSID_MSMQRuleSet>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQRuleSet, &IID_IMSMQRuleSet, &LIBID_MSMQTriggerObjects>,
	public CMSMQTriggerNotification
{
	public:

		CMSMQRuleSet();
		~CMSMQRuleSet();

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQRULESET)
		DECLARE_NOT_AGGREGATABLE(CMSMQRuleSet)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQRuleSet)
			COM_INTERFACE_ENTRY(IMSMQRuleSet)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		// ISupportsErrorInfo
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	private:
		// A map of CRuntimeRuleInfo objects keyed by Rule ID
		RULE_MAP m_mapRules;

		// Used to destroy the contents of the rule map.
		void ClearRuleMap();

		// Builds the map of rules based on registry data.
		bool PopulateRuleMap(RULE_MAP &mapRules);

		// debug only
		_bstr_t DumpRuleMap();

	private:
		void SetComClassError(HRESULT hr);

	public:
		STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(Init)(/*[in]*/ BSTR bstrMachineName);

		STDMETHOD(Refresh)();

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

		STDMETHOD(Add)(
					/*[in]*/ BSTR sName,
					/*[in]*/ BSTR sDescription,
					/*[in]*/ BSTR sCondition,
					/*[in]*/ BSTR sAction,
					/*[in]*/ BSTR sImplementation,
					/*[in]*/ BOOL fShowWindow,
					/*[out]*/BSTR * psRuleID );
		STDMETHOD(Update)(
					/*[in]*/ BSTR sRuleID,
					/*[in]*/ BSTR sName,
					/*[in]*/ BSTR sDescription,
					/*[in]*/ BSTR sCondition,
					/*[in]*/ BSTR sAction,
					/*[in]*/ BSTR sImplementation,
					/*[in]*/ BOOL fShowWindow );
					
		STDMETHOD(Delete)(/*[in]*/ BSTR sRuleID);
		STDMETHOD(GetRuleDetailsByID)(
					/*[in]*/  BSTR sRuleID,
					/*[out]*/ BSTR * psRuleName,
					/*[out]*/ BSTR * psDescription,
					/*[out]*/ BSTR * psCondition,
					/*[out]*/ BSTR * psAction,
					/*[out]*/ BSTR * psImplementationProgID,
					/*[out]*/ BOOL * pfShowWindow);//,
					///*[out]*/ long * plRefCount );

		STDMETHOD(GetRuleDetailsByIndex)(
					/*[in]*/  long lRuleIndex,
					/*[out]*/ BSTR * psRuleID,
					/*[out]*/ BSTR * psRuleName,
					/*[out]*/ BSTR * psDescription,
					/*[out]*/ BSTR * psCondition,
					/*[out]*/ BSTR * psAction,
					/*[out]*/ BSTR * psImplementationProgID,
					/*[out]*/ BOOL * pfShowWindow);//,
					///*[out]*/ long * plRefCount );
					

};

#endif //__MSMQRULESET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\triggertest.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    triggertest.cpp

Abstract:
    Trigger service testing functions

Author:
    Tali Kariv (t-talik) 28-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "mq.h"
#include "mqtrig.h"
#include "stddefs.hpp"
#include "Cm.h"

#include "triggertest.tmh"

const LPWSTR xTriggersTestQueue = L".\\private$\\TriggerTestQueue";
const DWORD FORMAT_NAME_LENGTH = 255;
const DWORD NUM_OF_PROPS = 2;
const LPWSTR MESSAGE_LABEL = L"TriggerMessage";

static QUEUEHANDLE QHandle = NULL;


// TestFlag==0 means the flag hasn't been initialized yet
// TestFlag==1 means the flag has been initialized and it is not test mode
// TestFlag==2 means the flag has been initialized and it is test mode

static DWORD TestFlag=0;

// private function declarations

VOID 
InitTriggerTestFlag(
	VOID);

VOID 
AddTextToTestMessageBody(
	_bstr_t * bstrTestMessageBody,
	_bstr_t TextToAdd,
	DWORD Type);

HRESULT
TriggerTestOpenTestQueue(
	VOID);





VOID 
TriggerTestInitMessageBody(
	bstr_t * pbstrTestMessageBody,
	IMSMQPropertyBag * pIMSMQPropertyBag,
	_bstr_t bstrRuleID,_bstr_t ActionType,
	_bstr_t bstrEXEName,_bstr_t bstrProgID,
	_bstr_t bstrMethodName
	)

/*++
	Description 	:	This method will initialize the testing message body with trigger ID, 
				ruleID, message ID,action type and EXE name or COM prog ID and method.
	Input		:	Action information - trigger ID (in property bag),
				rule ID , message ID, action type , and COM prog ID
				& method or EXE name
	Return value	:	none.
--*/


{
	//
	// Check if flag TestFlag was initialized
	//
	if (TestFlag == 0)
		InitTriggerTestFlag(); 

	//
	// if is not test mode
	//
	if (TestFlag == 1)
	{
		return;	
	}

	//
	// it is test mode
	//


	//
	// add trigger ID
	//
	
	_variant_t vTriggerID;	
	HRESULT hr = pIMSMQPropertyBag->Read(gc_bstrPropertyName_TriggerID,&vTriggerID);
	if (FAILED(hr))
	{
		TrTRACE(Tgt, "Testing - TriggerTestInitMessageBody - the result of pIMSMQPropertyBag->Read was- 0x%x",hr);
		TestFlag=1;
		return ;
	}

	//
	// convert from variant to bstr
	//
	_variant_t vConvertedTriggerID;
	hr = VariantChangeType(&vConvertedTriggerID,&vTriggerID,NULL,VT_BSTR);
	if (FAILED(hr))
	{
		TrTRACE(Tgt, "Testing - TriggerTestInitMessageBody - the result of VariantChangeType was- 0x%x",hr);
		TestFlag=1;
		return;
	}

	AddTextToTestMessageBody(pbstrTestMessageBody,
		static_cast<_bstr_t>(vConvertedTriggerID),1);
	
	//
	// add rule ID
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,bstrRuleID,1);

	//
	// add Message ID
	//
	VARIANT vMessageID;	
	hr = pIMSMQPropertyBag->Read(gc_bstrPropertyName_MsgID , &vMessageID);
	if (FAILED(hr))
	{	
		TrTRACE(Tgt, "Testing - TriggerTestInitMessageBody - the result of pIMSMQPropertyBag->Read was- 0x%x",hr);
		TestFlag=1;
		return ;
	}	
	
	WCHAR* parray = NULL;
	SafeArrayAccessData( vMessageID.parray , (void **)&parray );

	unsigned short* MessageGUID = NULL;
	OBJECTID** pObj = (OBJECTID**)&(parray);
	UuidToString(&(*pObj)->Lineage , &MessageGUID);
	
	
	_bstr_t bstrTempMessageID (L"{");
	bstrTempMessageID += (MessageGUID);
	bstrTempMessageID += (L"}");

	DWORD MessageUniquifierNumber = 0;
	MessageUniquifierNumber = (*pObj)->Uniquifier;
	
	WCHAR* MessageUniquifier = new WCHAR[10];

	_itow(MessageUniquifierNumber , MessageUniquifier , 10 );

	bstrTempMessageID += (L"\\");
	bstrTempMessageID += (MessageUniquifier);

	delete []MessageUniquifier;

	AddTextToTestMessageBody(pbstrTestMessageBody , bstrTempMessageID , 1);


	// add action type
	
	AddTextToTestMessageBody(pbstrTestMessageBody,ActionType,1);

	// check action type

	if (wcscmp(ActionType,L"COM") == 0)
	{
		// add Prog ID
		AddTextToTestMessageBody(pbstrTestMessageBody,bstrProgID,1);

		// add Method 
		AddTextToTestMessageBody(pbstrTestMessageBody,bstrMethodName,1);
		return ;
	}

	//
	// else - add EXE name
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,bstrEXEName,1);
}


VOID
InitTriggerTestFlag(
	VOID
	)
/*++
   Description 		:	This method will check if a specific entry is registed in registry.
				if yes - will change TestFlag to 2 otherwise will change it to 1
		 
   Input		:	none.

   Return value		:	none.
--*/
{
	try
	{
		AP<TCHAR> TriggerTestQueueName = NULL;

		RegEntry TriggerTestQueueNameEntry(L"SOFTWARE\\Microsoft\\MSMQ\\Triggers" ,	L"TriggerTest" , 0 , RegEntry::MustExist , HKEY_LOCAL_MACHINE);
 	}
	catch(const exception&)
	{
		TestFlag=1;
		return ;
	}

	//
	// check if queue exist
	//
	if (QHandle==NULL)
	{
		HRESULT hr=TriggerTestOpenTestQueue();
		if (FAILED(hr))
		{
			TrTRACE(Tgt, "Testing - InitTriggerTestFlag - the result of TriggerTestOpenTestQueue was- 0x%x",hr);
			TestFlag=1; // change to user mode
			return ;	
		}		
	}
	
	//
	// the registry key was found and the queue was opened - change to test mode
	//
	TrTRACE(Tgt, "Test option is on");
	TestFlag=2;
}


VOID 
AddTextToTestMessageBody
	(_bstr_t * bstrTestMessageBody,
	_bstr_t TextToAdd,
	DWORD Type
	)
/*++
   Description 		:	This method will add text to the test message body.
		 
   Input		:	The test message body, the text to add and style (with or without "'")

   Return value		:	none.
--*/


{
	if (Type)
	{
		(*bstrTestMessageBody) += ("'")	;			
		(*bstrTestMessageBody) += (TextToAdd);
		(*bstrTestMessageBody) += ("' ");				
	}
	else
	{
		(*bstrTestMessageBody) += (TextToAdd);
		(*bstrTestMessageBody) += (" ");
	}


}

VOID 
TriggerTestSendTestingMessage(
	_bstr_t bstrTestMessageBody
	)
/*++
   Description  	:	This method will send a message to a queue which pathname is 
				defined in registry entry with label ="Triggers test" and 
				body=EXE name + parameters or COM name + COM method + parameters

   Input		:	The test message body.

   Return value		:	none.
--*/


{
	
	
	if (TestFlag==1)
		return ; // not test mode
	
	//
	// test mode
	//
	bstrTestMessageBody+="    "; // just to mark the end of message
	
	MQPROPVARIANT	propVar[NUM_OF_PROPS];
	MSGPROPID	propId[NUM_OF_PROPS];
	MQMSGPROPS	mProps;
	DWORD MessageBodyLength = wcslen(bstrTestMessageBody)+1;
	WCHAR* MessageBody=new WCHAR[MessageBodyLength];
	wcscpy(MessageBody,(LPWSTR)bstrTestMessageBody);
	
	
	DWORD nProps=0;
	propId[nProps]=PROPID_M_BODY;
	propVar[nProps]	.vt=VT_UI1 | VT_VECTOR;
	propVar[nProps].caub.cElems = MessageBodyLength * sizeof(WCHAR);
	propVar[nProps].caub.pElems=reinterpret_cast<UCHAR*>(MessageBody);
	nProps++;

	propId[nProps]=PROPID_M_LABEL;
	propVar[nProps]	.vt=VT_LPWSTR;
	propVar[nProps].pwszVal=MESSAGE_LABEL;
	nProps++;
	
	mProps.cProp=nProps;
	mProps.aPropID=propId;
	mProps.aPropVar=propVar;
	mProps.aStatus=NULL;
	
	HRESULT hr;

	hr = MQSendMessage(QHandle,&mProps,NULL);
	if (FAILED(hr))
	{
		TrTRACE(Tgt, "Testing - TriggerTestSendTestingMessage - the result of MQSendMessage was- 0x%x",hr);
		TestFlag=1; // change to user mode
	}
}

HRESULT 
TriggerTestOpenTestQueue(
	VOID
	)
/*++
   Description	:	This method will open the queue to which the messages will be sent.

   Input	:	none.
 
   Return value	:	code for success or failure in opening queue.
--*/

{
	//
	// test mode
	//	
	WCHAR		FormatName[FORMAT_NAME_LENGTH]=L"";
	DWORD		FormatNameLength=FORMAT_NAME_LENGTH;
	
	HRESULT hr;		

	hr=MQPathNameToFormatName(xTriggersTestQueue,FormatName,&FormatNameLength);
	if (FAILED(hr))
	{
		TrTRACE(Tgt, "Testing - TriggerTestOpenTestQueue - the result of MQPathNameToFormatName was - 0x%x",hr);
		TestFlag=1;
		return (hr);
	}
	
	//
	// open the "TriggersTestQueue" 
	//
	hr=MQOpenQueue(FormatName,MQ_SEND_ACCESS,MQ_DENY_NONE,&QHandle);
	if (FAILED(hr))
	{
		TrTRACE(Tgt, "Testing - TriggerTestOpenTestQueue - the result of MQOpenQueue was- 0x%x",hr);
		TestFlag=1;
		return (hr);
	}
	return (S_OK);
}

VOID 
TriggerTestAddParameterToMessageBody(
	_bstr_t * pbstrTestMessageBody,
	_bstr_t TypeToAdd,
	variant_t vArg
	)
/*++
   Description	:	This method will add to the test message body a parameter and it's type.
 
   Input	:	The test message body argument type and value (as variant)

   Return value :	none.
--*/

{

	if (TestFlag == 1)
	{	
		return;	
	}
	
	//
	// test mode
	//	
	// add parameter type
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,TypeToAdd,1);
		
	//
	// add parameter value
	//
	HRESULT hr;
	_variant_t vConvertedArg;
	
	hr = VariantChangeType(&vConvertedArg,&vArg,NULL,VT_BSTR);
	if (FAILED(hr))
	{	
		TrTRACE(Tgt, "Testing - TriggerTestAddParameterToMessageBody - the result of VariantChangeType was- 0x%x",hr);
		TestFlag=1;
		return ;
	}
						
	AddTextToTestMessageBody(pbstrTestMessageBody,static_cast<_bstr_t>(vConvertedArg),1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trigcnfg.cpp ===
//*****************************************************************************
//
// Class Name  : CMSMQTriggersConfig
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the implemenation for the MSMQ Triggers configuration
//               COM component. This component is used to retrieve and set 
//               configuration info for the MSMQ triggers service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqtg.h"
#include "mqsymbls.h"
#include "mqtrig.h"
#include "trigcnfg.hpp"
#include "stddefs.hpp"
#include "trignotf.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"

#include "trigcnfg.tmh"

//*****************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard support for rich error info.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTriggersConfig
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//*****************************************************************************
//
// Method      : get_TriggerStoreMachineName
//
// Description : Returns the machine name on which the triggers data store 
//               can be found.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_TriggerStoreMachineName(BSTR *pVal)
{
	_bstr_t bstrLocalComputerName;
	
	DWORD dwError = GetLocalMachineName(&bstrLocalComputerName);

	if(dwError != 0)
	{
		TrERROR(Tgo, "Failed to retreive local computer name. Error 0x%x", GetLastError());

		SetComClassError(MQTRIG_ERROR);
		return MQTRIG_ERROR;
	}

	
	try
	{
		if (pVal != NULL)
		{
			SysReAllocString(pVal,(wchar_t*)bstrLocalComputerName);
		}
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//*****************************************************************************
//
// Method      : get_InitialThreads
//
// Description : Returns the initial number of threads that triggers service 
//               should start with.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_InitialThreads(long *plInitialThreads)
{
	// Check that we have been passed a valid parameter
	if (plInitialThreads == NULL)
	{
		// Assign the exception return code
		TrERROR(Tgo, "Invalid parameter passed to get_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Attempt to retrieve the trigger store machine name parm.
	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_INITIAL_THREADS,
						(DWORD*)plInitialThreads,
						CONFIG_PARM_DFLT_INITIAL_THREADS
						);

	return S_OK;
}

//*****************************************************************************
//
// Method      : put_InitialThreads
//
// Description : Stores the number of threads the triggers service should 
//               start with.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_InitialThreads(long lInitialThreads)
{
	// Validate that we have been supplied a valid parameter.
	if ((lInitialThreads > xMaxThreadNumber) || (lInitialThreads < 1))
	{
		TrERROR(Tgo, "Invalid parameter passed to put_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	long lRetCode = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_INITIAL_THREADS,(DWORD)lInitialThreads);
	if (lRetCode != ERROR_SUCCESS)
	{
		TrERROR(Tgo, "Failed to store initial thread number in registery. Error 0x%x", lRetCode);

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}

//*****************************************************************************
//
// Method      : get_MaxThreads
//
// Description : Returns the maximum number of threads the triggers service 
//               is allowed to create to service queue messages.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_MaxThreads(long *plMaxThreads)
{
	// Check that we have been passed a valid parameter
	if (plMaxThreads == NULL)
	{
		TrERROR(Tgo, "Invalid parameter passed to get_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_MAX_THREADS,
						(DWORD*)plMaxThreads,
						CONFIG_PARM_DFLT_MAX_THREADS
						);

	return S_OK;
}


//*****************************************************************************
//
// Method      : put_MaxThreads
//
// Description : Stores the maximum number of threads the triggers servie is 
//               allowed to create in order to process queue messages.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_MaxThreads(long lMaxThreads)
{
	long lRetCode = ERROR_SUCCESS;

	// Validate that we have been supplied a valid parameter.
	if ((lMaxThreads > xMaxThreadNumber) || (lMaxThreads < 1))
	{
		TrERROR(Tgo, "Invalid parameter passed to put_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();
	lRetCode = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_MAX_THREADS,(DWORD)lMaxThreads);
	
	if (lRetCode != ERROR_SUCCESS)
	{
		TrERROR(Tgo, "Failed to store max thread number in registery. Error 0x%x", lRetCode);

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}



//*****************************************************************************
//
// Method      : get_DefaultMsgBodySize
//
// Description : returns the default size that the MSMQ Triggers service
//               should use to pre-allocate message body buffers. 
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_DefaultMsgBodySize(long *plDefaultMsgBodySize)
{
	// Check that we have been passed a valid parameter
	if (plDefaultMsgBodySize == NULL)
	{
		TrERROR(Tgo, "Invalid parameter passed to get_DefaultMsgBodySize routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE,
						(DWORD*)plDefaultMsgBodySize,
						CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE
						);
	
	return S_OK;
}

//*****************************************************************************
//
// Method      : put_DefaultMsgBodySize
//
// Description : sets the default size that the MSMQ Triggers service
//               should use to pre-allocate message body buffers. 
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_DefaultMsgBodySize(long lDefaultMsgBodySize)
{
	// Validate that we have been supplied a valid parameter.
	if ((lDefaultMsgBodySize > xDefaultMsbBodySizeMaxValue) || (lDefaultMsgBodySize < 1))
	{
		TrERROR(Tgo, "Invalid parameter passed to put_DefaultMsgBodySize routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	long lRetCode = SetNumericConfigParm(
								pRegPath,
								CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE,
								(DWORD)lDefaultMsgBodySize
								);

	if (lRetCode != ERROR_SUCCESS)
	{
		TrERROR(Tgo, "Failed to store default body size in registery. Error 0x%x", lRetCode);

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}


STDMETHODIMP CMSMQTriggersConfig::get_NotificationsQueueName(BSTR * pbstrNotificationsQueueName)
{
	// Check that we have been passed a valid parameter
	if (pbstrNotificationsQueueName == NULL)
	{
		TrERROR(Tgo, "Invalid parameter passed to get_NotificationsQueueName routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	try
	{
		BSTR bstrTemp = NULL;
		_bstr_t bstrNotificationsQPath;

		get_TriggerStoreMachineName(&bstrTemp); 
						
		bstrNotificationsQPath = bstrTemp;
		bstrNotificationsQPath += gc_bstrNotificationsQueueName;

		SysReAllocString(pbstrNotificationsQueueName, (wchar_t*)bstrNotificationsQPath);

		SysFreeString(bstrTemp);

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


STDMETHODIMP CMSMQTriggersConfig::get_InitTimeout(long *pVal)
{
	// Check that we have been passed a valid parameter
	if (pVal == NULL)
	{
		TrERROR(Tgo, "Inavlid parameter to get_InitTimeout");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Attempt to retrieve the trigger store machine name parm.
	GetNumericConfigParm(
		pRegPath,
		CONFIG_PARM_NAME_INIT_TIMEOUT,
		(DWORD*)pVal,
		CONFIG_PARM_DFLT_INIT_TIMEOUT
		);

	return S_OK;
}

STDMETHODIMP CMSMQTriggersConfig::put_InitTimeout(long newVal)
{
	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Validate that we have been supplied a valid parameter.
	long lRetCode = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_INIT_TIMEOUT,(DWORD)newVal);

	if (lRetCode != ERROR_SUCCESS)
	{
		TrERROR(Tgo, "Failed to store init timeout in registery. Error 0x%x", lRetCode);

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}


void CMSMQTriggersConfig::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trigcnfg.hpp ===
//*****************************************************************************
//
// Class Name  : CMSMQTriggersConfig
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Header file for the CMSMQTriggersConfig class.This 
//               component is used to retrieve and set configuration
//               info for the MSMQ triggers service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQTRIGGERSCONFIG_H_
#define __MSMQTRIGGERSCONFIG_H_

#include "resource.h"       // main symbols


class ATL_NO_VTABLE CMSMQTriggersConfig : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTriggersConfig, &CLSID_MSMQTriggersConfig>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTriggersConfig, &IID_IMSMQTriggersConfig, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQTriggersConfig()
		{
			m_pUnkMarshaler = NULL;
		}

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRIGGERSCONFIG)
		DECLARE_NOT_AGGREGATABLE(CMSMQTriggersConfig)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQTriggersConfig)
			COM_INTERFACE_ENTRY(IMSMQTriggersConfig)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(
				GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		private:
			void SetComClassError(HRESULT hr);
			
		public:
			STDMETHOD(get_InitTimeout)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_InitTimeout)(/*[in]*/ long newVal);

			STDMETHOD(get_NotificationsQueueName)(/*[out, retval]*/ BSTR *pVal);

			STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

			STDMETHOD(get_MaxThreads)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_MaxThreads)(/*[in]*/ long newVal);

			STDMETHOD(get_InitialThreads)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_InitialThreads)(/*[in]*/ long newVal);

			STDMETHOD(get_DefaultMsgBodySize)(/*[out, retval]*/ long *plDefaultMsgBodySize);
			STDMETHOD(put_DefaultMsgBodySize)(/*[in]*/ long lDefaultMsgBodySize);

			STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__MSMQTRIGGERSCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\triggertest.hpp ===
// Declarations of function for testing purposes

VOID TriggerTestSendTestingMessage(_bstr_t TestingMessageBody);
VOID TriggerTestInitMessageBody(bstr_t * pbstrTestMessageBody,IMSMQPropertyBag * pIMSMQPropertyBag,_bstr_t bstrRuleID,_bstr_t ActionType,_bstr_t EXEName,_bstr_t bstrProgID,_bstr_t bstrMethodName);
VOID TriggerTestAddParameterToMessageBody(_bstr_t * bstrTestMessageBody,_bstr_t TypeToAdd,variant_t vArg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trigset.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQTriggerSet
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the implementation of the MSMQTriggerSet object. This is the 
//               main object by which trigger definitons are maintained.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqtrig.h"
#include "mqsymbls.h"
#include "mqtg.h"
#include "trigset.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"

#include "trigset.tmh"

using namespace std;

//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard interface for rich error info.
//
//************************************************************************************
STDMETHODIMP CMSMQTriggerSet::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTriggerSet
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Initializes an instance of the MSMQTriggerSet object.
//
//************************************************************************************
CMSMQTriggerSet::CMSMQTriggerSet()
{
	m_pUnkMarshaler = NULL;
	m_hHostRegistry = NULL;

	// Set the name of this class for future reference in tracing & logging etc..
	m_bstrThisClassName  = _T("MSMQTriggerSet");

	m_fHasInitialized = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Destroys an instance of the MSMQTriggerSet object.
//
//************************************************************************************
CMSMQTriggerSet::~CMSMQTriggerSet()
{
	// Release resources currently held by the trigger cache
	ClearTriggerMap();

	// Close the registry handle 
	if (m_hHostRegistry != NULL)
	{
		RegCloseKey(m_hHostRegistry);
	}
}


//************************************************************************************
//
// Method      : Init
//
// Description : Initialization of the object
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::Init(
	BSTR bstrMachineName
	)
{
	bool fRes = CMSMQTriggerNotification::Init(bstrMachineName);

	if ( !fRes )
	{
		TrERROR(Tgo, "Failed to initialize CMSMQTriggerSet object");

		SetComClassError(MQTRIG_ERROR_INIT_FAILED);
		return MQTRIG_ERROR_INIT_FAILED;
	}
	
	return S_OK;
}


//************************************************************************************
//
// Method      : ClearTriggerMap
//
// Description : This method destroys the contents of the current trigger map.
//
//************************************************************************************
void 
CMSMQTriggerSet::ClearTriggerMap(
	VOID
	)
{
	TRIGGER_MAP::iterator i = m_mapTriggers.begin();
	CRuntimeTriggerInfo * pTrigger = NULL;

	while (i != m_mapTriggers.end())
	{
		// Cast to a rule pointer
		pTrigger = (*i).second;

		// We should never have null pointers in this map.
		ASSERT(pTrigger != NULL);

		// delete this rule object.
		delete pTrigger;

		// Reinitialize the rule pointer
		pTrigger = NULL;

		// Look at the next item in the map.
		i = m_mapTriggers.erase(i);
	}
}

//************************************************************************************
//
// Method      : Refresh
//
// Description : This method retrieves a fresh snapshot of the trigger data from the 
//               database. It will rebuild it's list of triggers, rules, and the 
//               associations between triggers and rules. This method needs to be 
//               called before the client of this object can browse trigger info.
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::Refresh(
	VOID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try 
	{			
		// Release resources currently held by the trigger cache
		ClearTriggerMap();

		if (PopulateTriggerMap() == false)
		{
			TrERROR(Tgo, "Failed to refresh trigger set");

			SetComClassError(MQTRIG_ERROR_COULD_NOT_RETREIVE_TRIGGER_DATA);
			return MQTRIG_ERROR_COULD_NOT_RETREIVE_TRIGGER_DATA;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : FindTriggerInMap
//
// Description : 
//
//************************************************************************************
HRESULT 
CMSMQTriggerSet::FindTriggerInMap(
	BSTR sTriggerID, 
	CRuntimeTriggerInfo ** ppTrigger,
	TRIGGER_MAP::iterator &i
	)
{
	HRESULT hRetCode = S_OK;
	wstring bsTriggerID;

	(*ppTrigger) = NULL;

	// Validate the supplied method parameters.
	if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
	{
		TrERROR(Tgo, "CMSMQTriggerSet::FindTriggerInMap, invalid parameter");
		return MQTRIG_INVALID_TRIGGER_ID;
	}

	if (hRetCode == S_OK)
	{
		// Convert the BSTR rule ID to an STL basic string.
		bsTriggerID = (wchar_t*)sTriggerID;

		// Attempt to find this rule id in the map of rules.
		i = m_mapTriggers.find(bsTriggerID);

		// Check if we have found the rule
		if (i != m_mapTriggers.end())
		{
			// Cast to a rule object reference 
			(*ppTrigger) = (*i).second;

			// We should never have nulls in the map
			ASSERT((*ppTrigger) != NULL);

			// We should only have valid triggers in the map.
			ASSERT((*ppTrigger)->IsValid());
		}
		else
		{
			TrERROR(Tgo, "Trigger id wasn't found");
			hRetCode = MQTRIG_TRIGGER_NOT_FOUND;
		}
	}

	return(hRetCode);
}

//************************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of trigger definitions currently cached by this 
//               object instance. This is not the same as going to the database to 
//               determine how many triggers are defined. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::get_Count(
	long *pVal
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	if (pVal == NULL)
	{
		TrERROR(Tgo, "CMSMQTriggerSet::get_Count, invalid parameter");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	// Get the size from the map structure.
	(*pVal) = numeric_cast<long>(m_mapTriggers.size());

	return S_OK;
}

///************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetTriggerDetailsByID(
	/*[in]*/ BSTR sTriggerID,
	/*[out]*/ BSTR * psTriggerName,
	/*[out]*/ BSTR * psQueueName,
	/*[out]*/ SystemQueueIdentifier* pSystemQueue,
	/*[out]*/ long * plNumberOfRules,
	/*[out]*/ long * plEnabledStatus,
	/*[out]*/ long * plSerialized,
	/*[out]*/ MsgProcessingType* pMsgProcType
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		TRIGGER_MAP::iterator it;
		CRuntimeTriggerInfo * pTrigger = NULL;

		//
		// attempt to find this trigger in the map.
		//
		HRESULT hr = FindTriggerInMap(sTriggerID,&pTrigger,it);

		if (FAILED(hr))
		{
			TrERROR(Tgo, "The supplied trigger id was not found in the trigger store. trigger: %ls", (LPCWSTR)sTriggerID);
			
			SetComClassError(hr);
			return hr;
		}

		// Populate out parameters if they have been supplied. 
		if (psTriggerName != NULL)
		{
			TrigReAllocString(psTriggerName,pTrigger->m_bstrTriggerName);
		}
		if(pSystemQueue != NULL)
		{
			(*pSystemQueue) = pTrigger->m_SystemQueue;
		}
		if (psQueueName != NULL)
		{
			TrigReAllocString(psQueueName,pTrigger->m_bstrQueueName);
		}
		if (plEnabledStatus != NULL)
		{
			(*plEnabledStatus) = (long)pTrigger->IsEnabled();
		}
		if (plSerialized != NULL)
		{
			(*plSerialized) = (long)pTrigger->IsSerialized();
		}
		if (plNumberOfRules != NULL)
		{			
			(*plNumberOfRules) = pTrigger->GetNumberOfRules();	
		}
		if (pMsgProcType != NULL)
		{
			(*pMsgProcType) = pTrigger->GetMsgProcessingType();
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresh trigger set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetTriggerDetailsByIndex(
	/*[in]*/ long lTriggerIndex ,
	/*[out]*/ BSTR * psTriggerID ,
	/*[out]*/ BSTR * psTriggerName ,
	/*[out]*/ BSTR * psQueueName,
	/*[out]*/SystemQueueIdentifier* pSystemQueue,
	/*[out]*/ long * plNumberOfRules,
	/*[out]*/ long * plEnabledStatus,
	/*[out]*/ long * plSerialized,
	/*[out]*/ MsgProcessingType* pMsgProcType
	)
{
	long lCounter = 0;
	wstring bsTriggerID;
	CRuntimeTriggerInfo * pTrigger = NULL;

	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Check that the supplied index is within range.
		if ((lTriggerIndex < 0) || (numeric_cast<DWORD>(lTriggerIndex) > m_mapTriggers.size()))
		{
			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		TRIGGER_MAP::iterator i = m_mapTriggers.begin();

		// Move to the lTriggerIndex-th location in the triggers map
		for (lCounter=0; lCounter < lTriggerIndex;lCounter++,++i)
		{
			NULL;
		}

		// Cast to a Trigger object reference 
		pTrigger = (*i).second;

		// We should never have nulls in the map
		ASSERT(pTrigger != NULL);
			
		// We should only store valid triggers
		ASSERT(pTrigger->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psTriggerID != NULL)
		{
			TrigReAllocString(psTriggerID,pTrigger->m_bstrTriggerID);
		}
		if (psTriggerName != NULL)
		{
			TrigReAllocString(psTriggerName,pTrigger->m_bstrTriggerName);
		}
		if(pSystemQueue != NULL)
		{
			(*pSystemQueue) = pTrigger->m_SystemQueue;
		}
		if (psQueueName != NULL)
		{
			TrigReAllocString(psQueueName,pTrigger->m_bstrQueueName);
		}
		if (plEnabledStatus != NULL)
		{
			(*plEnabledStatus) = (long)pTrigger->IsEnabled();
		}
		if (plSerialized != NULL)
		{
			(*plSerialized) = (long)pTrigger->IsSerialized();
		}
		if (plNumberOfRules != NULL)
		{
			(*plNumberOfRules) = pTrigger->GetNumberOfRules();
        }
		if (pMsgProcType != NULL)
		{
			(*pMsgProcType) = pTrigger->GetMsgProcessingType();
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetRuleDetailsByTriggerIndex(
	long lTriggerIndex,
	long lRuleIndex,
	BSTR *psRuleID,
	BSTR *psRuleName,
	BSTR *psDescription,
	BSTR *psCondition,
	BSTR *psAction ,
	BSTR *psImplementationProgID,
	BOOL *pfShowWindow
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	long lCounter = 0;
	CRuntimeRuleInfo * pRule = NULL;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// We need to validate that the supplied rule index is within range
 		if ((lTriggerIndex < 0) || (numeric_cast<DWORD>(lTriggerIndex) > m_mapTriggers.size()))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetRuleDetailsByTriggerIndex. lTriggerIndex = %d", lTriggerIndex);

			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		if SUCCEEDED(hr)
		{
			// Get a reference to the beginging of the map
			TRIGGER_MAP::iterator i = m_mapTriggers.begin();

			// Iterate through to the correct index. 
			for (lCounter = 0; lCounter < lTriggerIndex ; ++i,lCounter++)
			{
				NULL;
			}

			// Cast to a rule object reference 
			pTrigger = (*i).second;

			// We should never have nulls in the map
			ASSERT(pTrigger != NULL);

			// We should only store valid triggers.
			ASSERT(pTrigger->IsValid());

			// Validate the supplied rule index against the number rule attached to this trigger
			if ((lRuleIndex < 0) || (lRuleIndex > pTrigger->GetNumberOfRules()))
			{
				TrERROR(Tgo, "Invalid rule index passed to GetRuleDetailsByTriggerIndex. lRuleIndex = %d", lRuleIndex);

				SetComClassError(MQTRIG_INVALID_PARAMETER);
				return MQTRIG_INVALID_PARAMETER;
			}

			pRule = pTrigger->GetRule(lRuleIndex);

			// We should never get a null rule after validating the index.
			ASSERT(pRule != NULL);
		
			// We should never get invalid rule definitions
			ASSERT(pRule->IsValid());

			// Populate out parameters if they have been supplied. 
            if (psRuleID != NULL)
            {
                TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
            }
			if (psRuleName != NULL)
			{
				TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
			}
			if(psDescription != NULL)
			{
				TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
			}
			if (psCondition != NULL)
			{
				TrigReAllocString(psCondition,pRule->m_bstrCondition);
			}
			if (psAction != NULL)
			{
				TrigReAllocString(psAction,pRule->m_bstrAction);
			}
			if (psImplementationProgID != NULL)
			{
				TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
			}
			if(pfShowWindow != NULL)
			{
				*pfShowWindow = pRule->m_fShowWindow;
			}
        }
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetRuleDetailsByTriggerID(
	BSTR sTriggerID,
	long lRuleIndex,
	BSTR *psRuleID,
	BSTR *psRuleName,
	BSTR *psDescription,
	BSTR *psCondition,
	BSTR *psAction,
	BSTR *psImplementationProgID,
	BOOL *pfShowWindow
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	TRIGGER_MAP::iterator i;
	CRuntimeRuleInfo * pRule = NULL;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}


		// find this trigger in the trigger map
		hr = FindTriggerInMap(sTriggerID,&pTrigger,i);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Validate that the specified trigger actually has rules.
		if (pTrigger->GetNumberOfRules() < 1)
		{
			TrERROR(Tgo, "The supplied trigger id has no rules attached. trigger: %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_RULE_NOT_ATTACHED);
			return MQTRIG_RULE_NOT_ATTACHED;
		}

		// Validate the supplied rule index against the number rule attached to this trigger
		if ((lRuleIndex < 0) || (lRuleIndex >= pTrigger->GetNumberOfRules()))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		// Get a reference to the rule at the specified index.
		pRule = pTrigger->GetRule(lRuleIndex);

		// We should never get a null rule after validating the index.
		ASSERT(pRule != NULL);

		// We should never get invalid rule definitions
		ASSERT(pRule->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psRuleID != NULL)
		{
			TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
		}
		if (psRuleName != NULL)
		{
			TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
		}
		if(psDescription != NULL)
		{
			TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
		}
		if (psCondition != NULL)
		{
			TrigReAllocString(psCondition,pRule->m_bstrCondition);
		}
		if (psAction != NULL)
		{
			TrigReAllocString(psAction,pRule->m_bstrAction);
		}
		if (psImplementationProgID != NULL)
		{
			TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
		}
		if(pfShowWindow != NULL)
		{
			*pfShowWindow = pRule->m_fShowWindow;
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}

//************************************************************************************
//
// Method      : AddTrigger
//
// Description : This method will add a new trigger to the underlying trigger store. It
//               will create a new trigger (a GUID in string form) and attempt to insert
//               this into the registry. 
//
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::AddTrigger(
	BSTR sTriggerName, 
	BSTR sQueueName, 
	SystemQueueIdentifier SystemQueue, 
	long lEnabled, 
	long lSerialized, 
	MsgProcessingType msgProcType,
	BSTR * psTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	TRIGGER_MAP::iterator i;
	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerName(sTriggerName))
		{
			TrERROR(Tgo, "Invalid trigger name passed to AddTrigger. sTriggerName = %ls", (LPCWSTR)sTriggerName);

			SetComClassError(MQTRIG_INVALID_TRIGGER_NAME);
			return MQTRIG_INVALID_TRIGGER_NAME;
		}

		if SUCCEEDED(hr)
		{
			if(SystemQueue == SYSTEM_QUEUE_NONE)
			{
				if (!CRuntimeTriggerInfo::IsValidTriggerQueueName(sQueueName))
				{
					TrERROR(Tgo, "Invalid queue name passed to AddTrigger. sQueueName = %ls", (LPCWSTR)sQueueName);

					SetComClassError(MQTRIG_INVALID_TRIGGER_QUEUE);
					return MQTRIG_INVALID_TRIGGER_QUEUE;
				}
			}
		}

		if SUCCEEDED(hr)
		{
			_bstr_t bstrUpdatedQueueName;
			_bstr_t bstrMachineName;

			if(SystemQueue != SYSTEM_QUEUE_NONE) //one of the system queues is selected
			{
				//generate format name for the selected system queue
				hr = GenSystemQueueFormatName(SystemQueue, &bstrUpdatedQueueName);
				if(hr != S_OK)
				{
					TrERROR(Tgo, "Failed to generate system queue format name. Error=0x%x", hr);

					SetComClassError(MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER);
					return MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER;
				}
			}
			else //queue path given
			{
				//
				// if queue name contains "." as machine name, replace it with the
				// local machine name
				//
				DWORD dwError = GetLocalMachineName(&bstrMachineName);
				if(dwError != 0)
				{
					TrERROR(Tgo, "Failed to retreive local machine queue. Error=0x%x", dwError);

					SetComClassError(MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER);
					return MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER;
				}
					
				UpdateMachineNameInQueuePath(
						sQueueName,
						bstrMachineName,
						&bstrUpdatedQueueName );
			}

			//
			// Allow only one receive trigger per queue
			//
			if (msgProcType != PEEK_MESSAGE &&
				ExistTriggersForQueue(bstrUpdatedQueueName))
			{
				TrERROR(Tgo, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

				SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
				return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
			}

			if (msgProcType == PEEK_MESSAGE &&
					 ExistsReceiveTrigger(bstrUpdatedQueueName))
			{
				TrERROR(Tgo, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

				SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
				return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
			}

			//
			// Force serialized trigger for transactional receive
			//
			if ( msgProcType == RECEIVE_MESSAGE_XACT )
			{
				lSerialized = 1;
			}

			//
			// Allocate a new trigger object
			//
			P<CRuntimeTriggerInfo> pTrigger = new CRuntimeTriggerInfo(
															CreateGuidAsString(),
															sTriggerName,
															bstrUpdatedQueueName,
															m_wzRegPath,
															SystemQueue, 
															(lEnabled != 0),
															(lSerialized != 0),
															msgProcType
															);
			
			if (pTrigger->Create(m_hHostRegistry) == true)
			{
				//
				// Keep trigger ID and Queue name for later use
				//
				BSTR bstrQueueName = pTrigger->m_bstrQueueName;
				BSTR bstrTriggerID = pTrigger->m_bstrTriggerID;

				//
				// Add this trigger to map.
				//
				m_mapTriggers.insert(TRIGGER_MAP::value_type(bstrTriggerID, pTrigger));
				pTrigger.detach();

				//
				// If we have been supplied a out parameter pointer for the new rule ID use it.
				//
				if (psTriggerID != NULL)
				{
					TrigReAllocString(psTriggerID, bstrTriggerID);
				}

				//
				// send a notification indicating that a trigger has been added to the trigger store.
				//
				NotifyTriggerAdded(bstrTriggerID, sTriggerName, bstrQueueName); 

				return S_OK;
			}
			else
			{
				// We need to delete the trigger instance object as the create failed.
				TrERROR(Tgo, "Failed to store trigger data in registry");
				SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED );
				
				return MQTRIG_ERROR_STORE_DATA_FAILED;
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
 }

//************************************************************************************
//
// Method      : DeleteTrigger
//
// Description : This method removes a trigger definiton from the database. It will not
//               delete any rules that are attached to this trigger, however it will 
//               delete any associations between the supplied trigger id and existing 
//               rules in the database. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DeleteTrigger(
	BSTR sTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		// find this trigger in the map.
    	TRIGGER_MAP::iterator it;
		CRuntimeTriggerInfo * pTrigger = NULL;

        long hr = FindTriggerInMap(sTriggerID,&pTrigger,it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Delete the Trigger from the underlying data store.
        bool f = pTrigger->Delete(m_hHostRegistry);
        if (!f)
        {
			TrERROR(Tgo, "Failed to delete trigger from trigger set. trigget %ls", (LPCWSTR)sTriggerID);
			
			SetComClassError(MQTRIG_ERROR_COULD_NOT_DELETE_TRIGGER);
			return MQTRIG_ERROR_COULD_NOT_DELETE_TRIGGER;
        }

        // Send a notification that a trigger has been deleted from the trigger store.
		NotifyTriggerDeleted(pTrigger->m_bstrTriggerID);

		// Delete this Trigger object instance
		delete pTrigger;

		// Now remove this Trigger from our map.
		m_mapTriggers.erase(it);
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return S_OK;
}

//************************************************************************************
//
// Method      : 
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::UpdateTrigger(
	BSTR sTriggerID, 
	BSTR sTriggerName, 
	BSTR sQueueName, 
	SystemQueueIdentifier SystemQueue, 
	long lEnabled, 
	long lSerialized,
	MsgProcessingType msgProcType
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	wstring bsTriggerID;
	TRIGGER_MAP::iterator i;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if (!CRuntimeTriggerInfo::IsValidTriggerName(sTriggerName))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_NAME);
			return MQTRIG_INVALID_TRIGGER_NAME;
		}

		if(SystemQueue == SYSTEM_QUEUE_NONE)
		{
			if(sQueueName != NULL)
			{
				if (!CRuntimeTriggerInfo::IsValidTriggerQueueName(sQueueName))
				{
					TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

					SetComClassError(MQTRIG_INVALID_TRIGGER_QUEUE);
					return MQTRIG_INVALID_TRIGGER_QUEUE;
				}
			}
		}

		HRESULT hr = FindTriggerInMap(sTriggerID,&pTrigger,i);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		_bstr_t bstrUpdatedQueueName;
		SystemQueueIdentifier queueType = SYSTEM_QUEUE_NONE;

		if(SystemQueue != SYSTEM_QUEUE_NONE) //one of the system queues is selected
		{
			//generate format name for the selected system queue
			hr = GenSystemQueueFormatName(SystemQueue, &bstrUpdatedQueueName);
			if(hr != S_OK)
			{
				TrERROR(Tgo, "Failed to generate system queue format name. Error=0x%x", hr);

				SetComClassError(MQTRIG_ERROR);
				return MQTRIG_ERROR;
			}

			queueType = SystemQueue;
		}
		else if (sQueueName != NULL) //queue path given
		{
			_bstr_t bstrMachineName;
	
			//
			// if queue name contains "." as machine name, replace it with the
			// local machine name
			//
			
			DWORD dwError = GetLocalMachineName(&bstrMachineName);
			if(dwError != 0)
			{
				TrERROR(Tgo, "Failed to retreive local machine queue. Error=0x%x", dwError);

				SetComClassError(MQTRIG_ERROR);
				return MQTRIG_ERROR;
			}
				
			UpdateMachineNameInQueuePath(
					sQueueName,
					bstrMachineName,
					&bstrUpdatedQueueName );						
			
			queueType = SYSTEM_QUEUE_NONE;
		}

		//
		// Allow only one receive trigger per queue
		//
		if ((msgProcType != PEEK_MESSAGE) && 
			(GetNoOfTriggersForQueue(bstrUpdatedQueueName) > 1))
		{
			TrERROR(Tgo, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

			SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
			return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
		}

		//
		// Force serialized trigger for transactional receive
		//
		if ( msgProcType == RECEIVE_MESSAGE_XACT )
		{
			lSerialized = 1;
		}

		//
		// Update values
		//
		pTrigger->m_bstrTriggerName = (wchar_t*)sTriggerName;
		pTrigger->m_SystemQueue = queueType;
		pTrigger->m_bstrQueueName = (wchar_t*)bstrUpdatedQueueName;
		pTrigger->m_bEnabled = (lEnabled != 0)?true:false;
		pTrigger->m_bSerialized = (lSerialized != 0)?true:false;
		pTrigger->SetMsgProcessingType(msgProcType);

		if (pTrigger->Update(m_hHostRegistry) == true)
		{			
			// send a notification indicating that a trigger in the trigger store has been updated.
			NotifyTriggerUpdated(
				pTrigger->m_bstrTriggerID,
				pTrigger->m_bstrTriggerName,
				pTrigger->m_bstrQueueName
				);

			return S_OK;
		}

		TrERROR(Tgo, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
		
		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : DetachAllRules
//
// Description : 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DetachAllRules(
	BSTR sTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	wstring bsTriggerID;
	TRIGGER_MAP::iterator i;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if SUCCEEDED(hr)
		{
			// find this trigger in the map
			hr = FindTriggerInMap(sTriggerID,&pTrigger,i);
			if (hr != S_OK)
			{
				SetComClassError(hr);
				return hr;
			}

			// Attempt to detach the rule.
			if (!pTrigger->DetachAllRules(m_hHostRegistry))
			{
				TrERROR(Tgo, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
				
				SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
				hr = MQTRIG_ERROR_STORE_DATA_FAILED;
			}
			else //succeeded to detach
			{
				NotifyTriggerUpdated(sTriggerID, pTrigger->m_bstrTriggerName, pTrigger->m_bstrQueueName);
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}

//************************************************************************************
//
// Method      : AttachRule
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::AttachRule(
	BSTR sTriggerID, 
	BSTR sRuleID, 
	long lPriority
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	wstring bsTriggerID;
	TRIGGER_MAP::iterator i;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if SUCCEEDED(hr)
		{
			if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
			{
				TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

				SetComClassError(MQTRIG_INVALID_RULEID);
				return MQTRIG_INVALID_RULEID;
			}		
		}

		if SUCCEEDED(hr)
		{
			// find this trigger in the map
			hr = FindTriggerInMap(sTriggerID,&pTrigger,i);
			if (hr != S_OK)
			{
				SetComClassError(hr);
				return hr;
			}

			// Ensure that this rule is not allready attached.
			if (pTrigger->IsRuleAttached(sRuleID) == false)
			{		
				// We should only store valid triggers.
				ASSERT(pTrigger->IsValid());

				if(pTrigger->GetNumberOfRules() >= lPriority)
				{
					// Attempt to attach the rule.
					if (pTrigger->Attach(m_hHostRegistry,sRuleID,lPriority) == true)
					{
						// send a notification indicating that a trigger in the trigger store has been updated.
						NotifyTriggerUpdated(pTrigger->m_bstrTriggerID,pTrigger->m_bstrTriggerName,pTrigger->m_bstrQueueName);
					}
					else
					{
						TrERROR(Tgo, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
						
						SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
						return MQTRIG_ERROR_STORE_DATA_FAILED;
					}
				}
				else
				{
					TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

					SetComClassError(MQTRIG_INVALID_PARAMETER);
					return MQTRIG_INVALID_PARAMETER;
				}
			}
			else
			{
				TrERROR(Tgo, "Unable to attach rule because it is already attached.");

				SetComClassError(MQTRIG_RULE_ALLREADY_ATTACHED);
				return MQTRIG_RULE_ALLREADY_ATTACHED;
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}

//************************************************************************************
//
// Method      : 
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DetachRule(
	BSTR sTriggerID, 
	BSTR sRuleID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	wstring bsTriggerID;
	TRIGGER_MAP::iterator i;
	CRuntimeTriggerInfo * pTrigger = NULL;

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if SUCCEEDED(hr)
		{
			if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
			{
				TrERROR(Tgo, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

				SetComClassError(MQTRIG_INVALID_RULEID);
				return MQTRIG_INVALID_RULEID;
			}		
		}

		if SUCCEEDED(hr)
		{
			hr = FindTriggerInMap(sTriggerID,&pTrigger,i);
			if (hr != S_OK)
			{
				SetComClassError(hr);
				return hr;
			}

			// Check that this rule is really attached.
			if (pTrigger->IsRuleAttached(sRuleID) == true)
			{		
				// We should only store valid triggers.
				ASSERT(pTrigger->IsValid());

				// Attempt to detach the rule.
				if (pTrigger->Detach(m_hHostRegistry,sRuleID) == true)
				{
					// send a notification indicating that a trigger in the trigger store has been updated.
					NotifyTriggerUpdated(pTrigger->m_bstrTriggerID,pTrigger->m_bstrTriggerName,pTrigger->m_bstrQueueName);
				}
				else
				{
					TrERROR(Tgo, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
					
					SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
					return MQTRIG_ERROR_STORE_DATA_FAILED;
				}
			}
			else
			{
				TrERROR(Tgo, "Unable to detach rule because it is not currently attached.");
				
				SetComClassError(MQTRIG_RULE_NOT_ATTACHED);
				return MQTRIG_RULE_NOT_ATTACHED;
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}


//*******************************************************************
//
// Method      : PopulateTriggerMap
//
// Description : This method will populate the rule map with instances
//               of the CRuntimeTriggerInfo class based on the data found
//               in the registry. Note that this method will create the 
//               triggers data registry key if it does not already exist.
//
//*******************************************************************
bool 
CMSMQTriggerSet::PopulateTriggerMap(
	VOID
	)
{
	// Make sure we have a connection to the registry 
	
	BOOL fSucc = ConnectToRegistry();
	if (!fSucc)
	{
		TrERROR(Tgo, "PopulateTriggerMap failed to connect to registry. Triggers information can't be retreived.");
		return false;
	}


	WCHAR wzTriggerPath[MAX_REGKEY_NAME_SIZE];
	_tcscpy( wzTriggerPath, m_wzRegPath );
	_tcscat( wzTriggerPath, REG_SUBKEY_TRIGGERS );

	//
	// Open the key where the rule data can be found.
	//
	CRegKey oRegKey;
	long lKeyOpened;
	lKeyOpened = oRegKey.Create(
								m_hHostRegistry,
								wzTriggerPath,
								REG_NONE,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								NULL
								);

	if (lKeyOpened != ERROR_SUCCESS)
	{
		//
		// Failed to allocate CRuntimeRuleInfo structure - log an error and set return code.
		//
		TrERROR(Tgo, "CMSMQTriggerSet::PopulateTriggerMap() failed to open the registry key that contains the rule data. The key was (%ls). The machine was (%ls)." ,wzTriggerPath,(wchar_t*)m_bstrMachineName);
		return false;
	}

	// Enumerate through the keys under the Rules key. Each subkey here should be a RuleID. As we 
	// enumerate through these keys, we will populate the rule map with instance of the CRuntimeRuleInfo
	// class. We stop if any rule fails to load.
	DWORD dwIndex = 0;
	while(true)
	{
		TCHAR szSubKeyBuffer[MAX_REGKEY_NAME_SIZE];
		DWORD dwSubKeyBufferSize = MAX_REGKEY_NAME_SIZE;
		FILETIME ftLastWriteTime;


		// Initialise the subkey buffer.
		ZeroMemory(szSubKeyBuffer, dwSubKeyBufferSize);


		// Attempt to open the next sub key (pointed to by dwIndex)
		lKeyOpened =  RegEnumKeyEx(
							oRegKey.m_hKey,                 // handle to key to enumerate
							dwIndex,						// index of subkey to enumerate
							(LPTSTR)(&szSubKeyBuffer),      // address of buffer for subkey name
							&dwSubKeyBufferSize,            // address for size of subkey buffer
							NULL,                           // reserved
							NULL,                           // address of buffer for class string
							NULL,                           // address for size of class buffer
							(PFILETIME)(&ftLastWriteTime) 
							);

		if (lKeyOpened != ERROR_SUCCESS)
		{
			if (lKeyOpened != ERROR_NO_MORE_ITEMS)
			{
				TrERROR(Tgo, "PopulateTriggerMap failed to enumerate the registry keys below (%ls). The sub key being processed was at index (%d). Error=%d", m_wzRegPath,dwIndex,lKeyOpened);
				return false;

			}

			TrTRACE(Tgo, "PopulateTriggerMap complete successfully. A total of %d triggers have been loaded.",(long)m_mapTriggers.size());
			return true;
		}

		//
		// Allocate a new rule structure.
		//
		P<CRuntimeTriggerInfo> pTrigger = new CRuntimeTriggerInfo(m_wzRegPath);

		//
		// Retreive the rule. Note the subkey buffer is actually the RuleID
		//
		HRESULT hr = pTrigger->Retrieve(m_hHostRegistry, (LPCTSTR)szSubKeyBuffer);

		if (FAILED(hr))
		{
			//
			// If trigger was deleted between enumeration and retrieval, just ignore
			// it. Another notification message will be recieved.
			//
			if (hr == MQTRIG_TRIGGER_NOT_FOUND)
			{
				continue;
			}
			//
			// Failed to load the rule. Log an error and delete the rule object.
			//
			TrERROR(Tgo, "PopulateTriggerMap failed to load trigger %ls from registry.", wzTriggerPath);
			return false;
		}
		
		//
		// At this point we have successfully loaded the rule, now insert it into the rule map.
		//
		wstring sTriggerID = pTrigger->m_bstrTriggerID;

		//
		// Check if this rule is already in the map.
		//
		TRIGGER_MAP::iterator it = m_mapTriggers.find(sTriggerID);
		if(it == m_mapTriggers.end())
		{
			//
			// if queue name contains "." as machine name, replace it with the
			// store machine name
			//
			_bstr_t bstrOldQueueName = pTrigger->m_bstrQueueName;
			
			bool fUpdated = UpdateMachineNameInQueuePath(
								bstrOldQueueName,
								m_bstrMachineName,
								&(pTrigger->m_bstrQueueName) );

			//
			// if queue name was updated, update registry as well
			//
			if(fUpdated)
			{
				if ( !pTrigger->Update(m_hHostRegistry) )
				{
					TrERROR(Tgo, "CMSMQTriggerSet::PopulateTriggerMap() failed becuse a duplicate rule id was found. The rule id was (%ls). The registry key (%ls).", (LPCWSTR)pTrigger->m_bstrTriggerID, wzTriggerPath);
				}
			}

			m_mapTriggers.insert(TRIGGER_MAP::value_type(sTriggerID,pTrigger));
			pTrigger.detach();
		}

		++dwIndex;
	}
}


STDMETHODIMP 
CMSMQTriggerSet::get_TriggerStoreMachineName(
	BSTR *pVal
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(Tgo, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	if(pVal == NULL)
	{
		TrERROR(Tgo, "Inavlid parameter to get_TriggerStoreMachineName");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}
	
	try
	{
		TrigReAllocString(pVal, (TCHAR*)m_bstrMachineName);
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgo, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


DWORD 
CMSMQTriggerSet::GetNoOfTriggersForQueue(
	const BSTR& bstrQueueName
	) const
{
	DWORD noOfTriggers = 0;

	for(TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		CRuntimeTriggerInfo* pTrigger = it->second;

		if ( _wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName ) == 0 )
		{
			++noOfTriggers;
		}
	}

	return noOfTriggers;
}


bool 
CMSMQTriggerSet::ExistTriggersForQueue(
	const BSTR& bstrQueueName
	) const
{
	for (TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		CRuntimeTriggerInfo * pTrigger = it->second;

		if ( _wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName ) == 0 )
		{
			return true;
		}
	}

	return false;
}


bool 
CMSMQTriggerSet::ExistsReceiveTrigger(
	const BSTR& bstrQueueName
	) const
{
	for (TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		CRuntimeTriggerInfo * pTrigger = it->second;

		// We should never have null pointers in this map.
		ASSERT(("NULL trigger in triggers list\n", pTrigger != NULL));

		if ((_wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName) == 0) &&
			(pTrigger->GetMsgProcessingType() != PEEK_MESSAGE))
		{
			return true;
		}
	}

	return false;
}


void CMSMQTriggerSet::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trignotf.cpp ===
//************************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"

// Include the definition for this class.
#include "trignotf.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"

#include "trignotf.tmh"

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
CMSMQTriggerNotification::CMSMQTriggerNotification()
{
	// Initialise the queue and cursor handles
	m_hSendMsgQueue = NULL;
	m_hPeekMsgQueue = NULL;
	m_hQCursor = NULL;

	// Initialise the Overlapped structure and create an NT event object
	ZeroMemory(&m_Overlapped,sizeof(m_Overlapped));
}

//************************************************************************************
//
// Method      :
//
// Description :
//
// Returns     :
//
//************************************************************************************
CMSMQTriggerNotification::~CMSMQTriggerNotification()
{
}


//************************************************************************************
//
// Method      : Init
//	
// Description : Common initialization function.
//
// Returns     : 
//
//************************************************************************************
bool CMSMQTriggerNotification::Init(BSTR bstrMachineName)
{
	if(m_fHasInitialized)
	{
		TrERROR(Tgo, "TriggerSet was already initialized.");			
		return false;
	}

	_bstr_t bstrLocalMachineName;
	DWORD dwError = GetLocalMachineName(&bstrLocalMachineName);
	if(dwError != 0)
	{
		TrERROR(Tgo, "Failed to get Local Computer Name.");			
		return false;
	}

	//
	// Trying to connect to local machine
	//
	if( bstrMachineName == NULL ||
		_bstr_t(bstrMachineName) == _bstr_t(_T("")) ||
		_bstr_t(bstrMachineName) == bstrLocalMachineName)
	{
		m_bstrMachineName = bstrLocalMachineName;
	}
	else
	{
		TrERROR(Tgo, "Connection to remote machine not supported.");			
		return false;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();
	_tcscpy( m_wzRegPath, pRegPath );

	ConnectToRegistry();

	m_fHasInitialized = true;
	return true;
}

//*******************************************************************
//
// Method      : ConnectToRegistry
//
// Description : This method will connect this class instance to the 
//               registry on the machine nominated in the configuration 
//               parameters (retreived on construction).
//
//*******************************************************************
bool CMSMQTriggerNotification::ConnectToRegistry()
{
	bool bOK = true;

	// First we need to establish a connection to the nominated registry.
	if (m_hHostRegistry == NULL)
	{
		if(RegConnectRegistry(NULL,HKEY_LOCAL_MACHINE,(PHKEY)&m_hHostRegistry) != ERROR_SUCCESS)
		{
			bOK = false;
			TrERROR(Tgo, "CMSMQTriggerSet::ConnectToRegistry() has failed to connect to the registry on machine %ls. Error: 0x%x.", (LPCWSTR)m_bstrMachineName, GetLastError());
		}
	}

	return(bOK);
}


//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerAdded(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERADDED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERADDED,(LPCTSTR)sTriggerID,(LPCTSTR)sTriggerName,(LPCTSTR)sQueueName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerDeleted(BSTR sTriggerID)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERDELETED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERDELETED,(LPCTSTR)sTriggerID);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerUpdated(BSTR sTriggerID, BSTR sTriggerName, BSTR sQueueName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERUPDATED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERUPDATED,(LPCTSTR)sTriggerID,(LPCTSTR)sTriggerName,(LPCTSTR)sQueueName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}


//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleAdded(BSTR sRuleID, BSTR sRuleName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEADDED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEADDED,(LPCTSTR)sRuleID,(LPCTSTR)sRuleName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleDeleted(BSTR sRuleID)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEDELETED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEDELETED,(LPCTSTR)sRuleID);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleUpdated(BSTR sRuleID, BSTR sRuleName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEUPDATED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEUPDATED,(LPCTSTR)sRuleID,(LPCTSTR)sRuleName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::SendToQueue(BSTR sLabel,BSTR sMsg)
{
	HRESULT hr = S_OK;
	MSGPROPID aMsgPropId[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	MQPROPVARIANT aMsgPropVar[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	HRESULT aMsgStatus[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	MQMSGPROPS MsgProps;
	DWORD PropIdCount = 0;
	TCHAR szLabel[MQ_MAX_Q_LABEL_LEN+1];
	_bstr_t bstrLabel = sLabel;
	_bstr_t bstrMsg = sMsg;

	// Convert the label into a null terminated string.
	ZeroMemory(szLabel,sizeof(szLabel));
	wcsncpy(szLabel,(BSTR)bstrLabel,bstrLabel.length());

	TrTRACE(Tgo, "Sending notification message. Label:%ls", static_cast<LPCWSTR>(szLabel));	

	//Set PROPID_M_LABEL
	aMsgPropId[PropIdCount] = PROPID_M_LABEL;                    //PropId
	aMsgPropVar[PropIdCount].vt = VT_LPWSTR;                     //Type
	aMsgPropVar[PropIdCount].pwszVal = (WCHAR*)(LPCTSTR)szLabel; //Value
	PropIdCount++;   

	//Set PROPID_M_BODY
	aMsgPropId[PropIdCount] = PROPID_M_BODY;             //PropId
	aMsgPropVar[PropIdCount].vt = VT_VECTOR | VT_UI1;
	aMsgPropVar[PropIdCount].caub.pElems = (LPBYTE)(LPCTSTR)sMsg;
	aMsgPropVar[PropIdCount].caub.cElems = SysStringByteLen(sMsg);
	PropIdCount++;

	//Set PROPID_M_DELIVERY
	aMsgPropId[PropIdCount] = PROPID_M_DELIVERY;          //PropId
	aMsgPropVar[PropIdCount].vt = VT_UI1;                 //Type
	aMsgPropVar[PropIdCount].bVal = MQMSG_DELIVERY_EXPRESS;// Set durable (default)
	PropIdCount++;    

	//Set PROPID_M_TIME_TO_BE_RECEIVED
	aMsgPropId[PropIdCount] = PROPID_M_TIME_TO_BE_RECEIVED;          //PropId
	aMsgPropVar[PropIdCount].vt = VT_UI4;                            //Type
	aMsgPropVar[PropIdCount].ulVal = 86400;                          // Live for 1 day
	PropIdCount++;    

	//Set the MQMSGPROPS structure.
	MsgProps.cProp = PropIdCount;       //Number of properties.
	MsgProps.aPropID = aMsgPropId;      //Id of properties.
	MsgProps.aPropVar = aMsgPropVar;    //Value of propertis.
	MsgProps.aStatus  = aMsgStatus;     //Error report.

	// Check that we have a valid queu handle
	if (m_hSendMsgQueue == NULL)
	{
		_bstr_t bstrNotificationsQueuePath = m_bstrMachineName;
		bstrNotificationsQueuePath += gc_bstrNotificationsQueueName;

		_bstr_t bstrFormatName;

		hr = OpenQueue(
					bstrNotificationsQueuePath,
					MQ_SEND_ACCESS,
					true,
					&m_hSendMsgQueue,
					&bstrFormatName
					);
		
		if(FAILED(hr))
		{
			TrERROR(Tgo, "Failed to open a notification queue. Error 0x%x", hr);
			return hr;
		}
	}
	
	hr = MQSendMessage(m_hSendMsgQueue,&MsgProps, MQ_NO_TRANSACTION);               
	if(FAILED(hr))
	{
		TrERROR(Tgo, "Failed to send a message to a notification queue. Error 0x%x", hr);
	}

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trignotf.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CMSMQTriggerNotification_INCLUDED 
#define CMSMQTriggerNotification_INCLUDED

// Include definitions required for message queues.
#include <mq.h>

// Include the triggers shared definitions
#include "stddefs.hpp"

// Include the definitions for this project
#include "mqtrig.h"

// Include the definitions for the MSMQ Trigger Configuration COM component.
#include "trigcnfg.hpp"
#include "mqtg.h"

// Define the name of the queue when no queue has been specified. 
#define NO_QUEUE_SPECIFIED L"No Queue Name Specified"

// Define the number message property structures that we are going to use.
#define TRIGGER_NOTIFICATIONS_NMSGPROPS              6
  
// Define max msg body size
#define MAX_MSG_BODY_SIZE      1024

// Define the maximum size of the format queue name 
#define MAX_Q_FORMAT_NAME_LEN  512

// Define the name of the notification queue used by MSMQTriggers
//#define MSMQTRIGGER_NOTIFICATION_QUEUENAME  _T(".\\MSMQTriggerNotifications")

#define MSGBODY_FORMAT_TRIGGERADDED    _T("TriggerID=%s;TriggerName=%s;QueueName=%s")
#define MSGBODY_FORMAT_TRIGGERUPDATED  _T("TriggerID=%s;TriggerName=%s;QueueName=%s")
#define MSGBODY_FORMAT_TRIGGERDELETED  _T("TriggerID=%s")
#define MSGBODY_FORMAT_RULEADDED       _T("RuleID=%s;RuleName=%s")
#define MSGBODY_FORMAT_RULEUPDATED     _T("RuleID=%s;RuleName=%s")
#define MSGBODY_FORMAT_RULEDELETED     _T("RuleID=%s")

class CMSMQTriggerNotification  
{
	public:
	
	protected:

		CMSMQTriggerNotification();
		~CMSMQTriggerNotification();
	
		// The name of the machine that is hosting the trigger data.
		_bstr_t m_bstrMachineName;
		bool m_fHasInitialized;
	
		// A handle to the registry that hosts the trigger data.
		HKEY m_hHostRegistry;

		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

		_bstr_t m_bstrThisClassName;

		OVERLAPPED m_Overlapped;

		bool Init(BSTR bstrMachineName);

		// Used to connect to local or remote registry
		bool ConnectToRegistry();

		HRESULT NotifyTriggerAdded(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName);
		HRESULT NotifyTriggerDeleted(BSTR sTriggerID);
		HRESULT NotifyTriggerUpdated(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName);

		HRESULT NotifyRuleAdded(BSTR sRuleID, BSTR sRuleName);
		HRESULT NotifyRuleDeleted(BSTR sRuleID);
		HRESULT NotifyRuleUpdated(BSTR sRuleID, BSTR sRuleName);
		
	private:

		// Handle to the MSMQTriggerNotifications Queue
		HANDLE m_hSendMsgQueue;
		HANDLE m_hPeekMsgQueue;

		HANDLE m_hQCursor;

		// General send method
		HRESULT SendToQueue(BSTR sLabel,BSTR sMsg);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trigobjs.cpp ===
// MSMQTriggerObjects.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for trigobjs.idl by adding the following 
//      files to the Outputs.
//          MSMQTriggerObjects_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f trigobjs.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "dlldatax.h"
#include "TrigSet.hpp"
#include "rulehdlr.hpp"
#include "cpropbag.hpp"
#include "ruleset.hpp"
#include "trigcnfg.hpp"
#include "clusfunc.h"
#include "_mqres.h"
#include "Cm.h"
#include "Tr.h"

#include "trigobjs.tmh"

CComModule _Module;

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSMQTriggerSet, CMSMQTriggerSet)
OBJECT_ENTRY(CLSID_MSMQRuleHandler, CMSMQRuleHandler)
OBJECT_ENTRY(CLSID_MSMQPropertyBag, CMSMQPropertyBag)
OBJECT_ENTRY(CLSID_MSMQRuleSet, CMSMQRuleSet)
//
// NOTE : The MSMQTrigger object has tentatively been removed from this project. 
//
// OBJECT_ENTRY(CLSID_MSMQTrigger, CMSMQTrigger)
//
//
OBJECT_ENTRY(CLSID_MSMQTriggersConfig, CMSMQTriggersConfig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

        CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS);
		TrInitialize();

		TrRegisterComponent(xTriggerObjectsComponent, TABLE_SIZE(xTriggerObjectsComponent));

        _Module.Init(ObjectMap, hInstance, &LIBID_MSMQTriggerObjects);
        DisableThreadLibraryCalls(hInstance);

		//
		// Try to find MSMQ Triggers service on this
		// machine. This machine may be:
		// 1 - a regular computer
		// 2 - phisycal node of a clustered machine
		// 3 - virtual server on clustered machine
		// The found service name defines the registry section
		// that will be accessed by objects in this DLL
		//
		bool fRes = FindTriggersServiceName();

		if ( !fRes )
		{
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        WPP_CLEANUP();
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}


void TrigReAllocString(BSTR* pbstr,	LPCWSTR psz)
{
	BOOL fSucc = SysReAllocString(pbstr, psz);
	if (!fSucc)
		throw bad_alloc();
}


void 
GetErrorDescription(
	HRESULT hr, 
	LPWSTR errMsg, 
	DWORD size
	)
{
	DWORD dwRet = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
						MQGetResourceHandle(),
                        static_cast<DWORD>(hr),
                        0,
                        errMsg,
                        size,
                        NULL 
						);
	ASSERT(dwRet != 0);
	DBG_USED(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\adminmsg.cpp ===
//*******************************************************************
//
// Class Name  : CAdminMessage
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a message sent to the admin 
//               thread. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "adminmsg.hpp"

#include "adminmsg.tmh"

//*******************************************************************
//
// Method      : Constructor
//
// Description : 
//
//*******************************************************************
CAdminMessage::CAdminMessage(eMsgTypes eMsgType,_bstr_t bstrContext)
{
	m_eMsgType = eMsgType;
	m_bstrContext = bstrContext;
}

//*******************************************************************
//
// Method      : Destructor
//
// Description : 
//
//*******************************************************************
CAdminMessage::~CAdminMessage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\adminmsg.hpp ===
//*******************************************************************
//
// Class Name  : CAdminMessage
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a message sent to the admin 
//               thread. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CAdminMessage_INCLUDED 
#define CAdminMessage_INCLUDED

class CAdminMessage 
{
	public :

		enum eMsgTypes
		{
			eNewThreadRequest = 0,
			eTriggerUpdated = 1,
			eTriggerDeleted = 2,
			eTriggerAdded = 3,
			eRuleUpdated = 4,
			eRuleDeleted = 5,
			eRuleAdded = 6
		};

		CAdminMessage(eMsgTypes eMsgType,_bstr_t bstrContext);
		~CAdminMessage();

		eMsgTypes GetMessageType() { return m_eMsgType; };

	private :

		eMsgTypes m_eMsgType;
		_bstr_t   m_bstrContext;


};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigobjs\trigset.hpp ===
//*****************************************************************************
//
// Class Name  : CLog
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a log object that provides the MSMQ trigger objects
//               with a single interface for writing to a log. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 02/01/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQTRIGGERSET_H_
#define __MSMQTRIGGERSET_H_

#include "resource.h"        

// Base class that handle receiving and sending notification msgs
#include "trignotf.hpp"

// Used to allow STL to compile without thousands of warnings.
#pragma warning(disable:4786)

// Include the definition of the CRuntimeTriggerInfo class (used to hold trigger info)
#include "triginfo.hpp"

// Define a new type - a 2D map of Trigger-ID's and pointers to instance of CRuntimeTriggerInfo
typedef std::map<std::wstring,CRuntimeTriggerInfo*, std::less<std::wstring> > TRIGGER_MAP;

class ATL_NO_VTABLE CMSMQTriggerSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTriggerSet, &CLSID_MSMQTriggerSet>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSMQTriggerSet>,
	public IDispatchImpl<IMSMQTriggerSet, &IID_IMSMQTriggerSet, &LIBID_MSMQTriggerObjects>,
	public CMSMQTriggerNotification
{
	public:

		CMSMQTriggerSet();
		~CMSMQTriggerSet();

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRIGGERSET)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQTriggerSet)
			COM_INTERFACE_ENTRY(IMSMQTriggerSet)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY(IConnectionPointContainer)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()


		BEGIN_CONNECTION_POINT_MAP(CMSMQTriggerSet)
		END_CONNECTION_POINT_MAP()


		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

	private:		
		// A map of CRuntimeTriggerInfo objects keyed by Trigger ID.
		TRIGGER_MAP m_mapTriggers;

		// Used to destroy the contents of the rule map.
		void ClearTriggerMap();

		// Builds the map of triggers based on registry data.
		bool PopulateTriggerMap();

		// Used to find a trigger in the map based on the trigger id.
		long FindTriggerInMap(BSTR sTriggerID, CRuntimeTriggerInfo ** ppTrigger,TRIGGER_MAP::iterator &i);

		// Check if exist triggers that are attached to given queue
		bool ExistTriggersForQueue(const BSTR& bstrQueueName) const;

		// Check if Receive triggers exist for the requested queue
		bool ExistsReceiveTrigger(const BSTR& bstrQueueName) const;

		DWORD GetNoOfTriggersForQueue(const BSTR& bstrQueueName) const;

		void SetComClassError(HRESULT hr);

	public:
		STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(Init)(/*[in]*/ BSTR bstrMachineName);
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

		STDMETHOD(UpdateTrigger)(/*[in]*/  BSTR sTriggerID,
			                     /*[in]*/  BSTR sTriggerName , 
								 /*[in]*/  BSTR sQueueName, 
								 /*[in]*/  SystemQueueIdentifier SystemQueue, 
								 /*[in]*/  long lEnabled , 
								 /*[in]*/  long lSerialized,
								 /*[in]*/  MsgProcessingType msgProcType);

		STDMETHOD(Refresh)();

		STDMETHOD(AddTrigger)(/*[in]*/  BSTR sTriggerName,
			                  /*[in]*/  BSTR sQueueName,
							  /*[in]*/	SystemQueueIdentifier SystemQueue, 
						 	  /*[in]*/  long lEnabled, 
							  /*[in]*/  long lSerialized,
							  /*[in]*/  MsgProcessingType msgProcType,
							  /*[out]*/ BSTR * psTriggerID);

		STDMETHOD(DeleteTrigger)(/*[in]*/  BSTR sTriggerID);

		STDMETHOD(GetRuleDetailsByTriggerID)(/*[in]*/  BSTR sTriggerID, 
		                                     /*[in]*/  long lRuleIndex, 
											 /*[out]*/ BSTR * psRuleID, 
											 /*[out]*/ BSTR * psRuleName, 
											 /*[out]*/ BSTR * psDescription,
											 /*[out]*/ BSTR * psCondition , 
											 /*[out]*/ BSTR * psAction , 
											 /*[out]*/ BSTR * psImplementationProgID, 
											 /*[out]*/ BOOL * pfShowWindow);//,
											 ///*[out]*/ long * plRefCount );
											 
		STDMETHOD(GetRuleDetailsByTriggerIndex)(/*[in]*/  long lTriggerIndex, 
		                                        /*[in]*/  long lRuleIndex, 
												/*[out]*/ BSTR *psRuleID, 
												/*[out]*/ BSTR *psRuleName, 
												/*[out]*/ BSTR * psDescription,
												/*[out]*/ BSTR *psCondition, 
												/*[out]*/ BSTR *psAction , 
												/*[out]*/ BSTR * psImplementationProgID, 
												/*[out]*/ BOOL * pfShowWindow);//,
												///*[out]*/ long * plRefCount );
												
		STDMETHOD(GetTriggerDetailsByID)(/*[in]*/  BSTR sTriggerID ,
		                                 /*[out]*/ BSTR * psTriggerName , 
										 /*[out]*/ BSTR * psQueueName, 
										 /*[out]*/ SystemQueueIdentifier* pSystemQueue, 
										 /*[out]*/ long * plNumberOfRules,
										 /*[out]*/ long * plEnabledStatus,
										 /*[out]*/ long * plSerialized,
										 /*[out]*/ MsgProcessingType * pMsgProcType);

		STDMETHOD(GetTriggerDetailsByIndex)(/*[in]*/  long lTriggerIndex , 
		                                    /*[out]*/ BSTR * psTriggerID , 
											/*[out]*/ BSTR * psTriggerName , 
											/*[out]*/ BSTR * psQueueName, 
											/*[out]*/ SystemQueueIdentifier* pSystemQueue, 
											/*[out]*/ long * plNumberOfRules,
											/*[out]*/ long * plEnabledStatus,
											/*[out]*/ long * plSerialized,
											/*[out]*/ MsgProcessingType * pMsgProcType);

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

		STDMETHOD(DetachRule)(/*[in]*/  BSTR sTriggerID,
			                  /*[in]*/  BSTR sRuleID);

		STDMETHOD(AttachRule)(/*[in]*/  BSTR sTriggerID ,
		                      /*[in]*/  BSTR sRuleID , 
							  /*[in] */ long lPriority);

		STDMETHOD(DetachAllRules)(/*[in]*/  BSTR sTriggerID);

};

#endif //__MSMQTRIGGERSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cmsgprop.cpp ===
//*******************************************************************
//
// Class Name  : CMsgProperties
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is a 'helper' class that encapsulates the native
//               MSMQ message structures in an object-oriented API.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "cmsgprop.hpp"

#include "cmsgprop.tmh"

//*******************************************************************
//
// Method      : Constructor
//
// Description : Creates a 'empty' instance of a message. Note that 
//               it is essential that the client of this class uses the 
//               IsValid() method imediately after construction - 
//               before using this class instance. This will guard 
//               against memory allocation failures.
//
//*******************************************************************
CMsgProperties::CMsgProperties(DWORD dwDefaultMsgBodySize)
{
	m_pMsgProps = new MQMSGPROPS;
	m_paVariant = new MQPROPVARIANT[MSG_PROPERTIES_TOTAL_COUNT];
	m_paPropId = new MSGPROPID[MSG_PROPERTIES_TOTAL_COUNT]; 

	// Only initialize structures if all were allocated OK
	if ((m_pMsgProps != NULL) && (m_paVariant != NULL) && (m_paPropId != NULL))
	{
		// Set the property for receving the Message Label Length
		m_paPropId[MSG_PROP_IDX_LABEL_LEN] = PROPID_M_LABEL_LEN;              //PropId 
		m_paVariant[MSG_PROP_IDX_LABEL_LEN].vt = VT_UI4;                      //Type 
		m_paVariant[MSG_PROP_IDX_LABEL_LEN].ulVal = MSG_LABEL_BUFFER_SIZE;               //Value 

		// Set the property for receving the Message Label 
		m_paPropId[MSG_PROP_IDX_LABEL] = PROPID_M_LABEL; // PropId
		m_paVariant[MSG_PROP_IDX_LABEL].vt = VT_LPWSTR;
		m_paVariant[MSG_PROP_IDX_LABEL].pwszVal = (TCHAR*)new TCHAR[MSG_LABEL_BUFFER_SIZE];

		// Set the property for receving the Message Priority
		m_paPropId[MSG_PROP_IDX_PRIORITY] = PROPID_M_PRIORITY;  // PropId
		m_paVariant[MSG_PROP_IDX_PRIORITY].vt = VT_UI1;         // Type

		// Set the property for receving the Message ID
		m_paPropId[MSG_PROP_IDX_MSGID] = PROPID_M_MSGID;                    // PropId
		m_paVariant[MSG_PROP_IDX_MSGID].vt = VT_VECTOR | VT_UI1;           // Type
		m_paVariant[MSG_PROP_IDX_MSGID].caub.cElems = MSG_ID_BUFFER_SIZE ; // Value
		m_paVariant[MSG_PROP_IDX_MSGID].caub.pElems = new unsigned char[MSG_ID_BUFFER_SIZE]; 

		// Set the property for receving the Message Correlation ID
		m_paPropId[MSG_PROP_IDX_MSGCORRID] = PROPID_M_CORRELATIONID;               // PropId
		m_paVariant[MSG_PROP_IDX_MSGCORRID].vt = VT_VECTOR|VT_UI1;                 // Type
		m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.cElems = MSG_CORRID_BUFFER_SIZE ; // Value
		m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems = new unsigned char[MSG_CORRID_BUFFER_SIZE]; 

        // Set the property for receiving the delivery style (express or recoverable)
		m_paPropId[MSG_PROP_IDX_ARRIVEDTIME] = PROPID_M_ARRIVEDTIME;       
		m_paVariant[MSG_PROP_IDX_ARRIVEDTIME].vt = VT_UI4;                  
		m_paVariant[MSG_PROP_IDX_ARRIVEDTIME].ulVal = 0; 

		// Set the property for receiving the delivery style (express or recoverable)
		m_paPropId[MSG_PROP_IDX_SENTTIME] = PROPID_M_SENTTIME;       
		m_paVariant[MSG_PROP_IDX_SENTTIME].vt = VT_UI4;                  
		m_paVariant[MSG_PROP_IDX_SENTTIME].ulVal = 0; 

		// Set the property for sending/receiving the response queue name buffer size
		m_paPropId[MSG_PROP_IDX_RESPQNAME_LEN] = PROPID_M_RESP_QUEUE_LEN;  
		m_paVariant[MSG_PROP_IDX_RESPQNAME_LEN].vt = VT_UI4;               
		m_paVariant[MSG_PROP_IDX_RESPQNAME_LEN].ulVal = MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS;    

		// Set the property for receiving the Response Queue Name
		m_paPropId[MSG_PROP_IDX_RESPQNAME] = PROPID_M_RESP_QUEUE;         //Property identifier.
		m_paVariant[MSG_PROP_IDX_RESPQNAME].vt = VT_LPWSTR;               //property type.
		m_paVariant[MSG_PROP_IDX_RESPQNAME].pwszVal = new TCHAR[MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS]; 

		// Set the property for receiving the msg body length
		m_paPropId[MSG_PROP_IDX_MSGBODY_LEN] = PROPID_M_BODY_SIZE;       
		m_paVariant[MSG_PROP_IDX_MSGBODY_LEN].vt = VT_UI4;                  
		m_paVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal = dwDefaultMsgBodySize; 

		// Set the property for receving the msg body itself
		m_paPropId[MSG_PROP_IDX_MSGBODY] = PROPID_M_BODY;               
		m_paVariant[MSG_PROP_IDX_MSGBODY].vt = VT_VECTOR|VT_UI1; 
		m_paVariant[MSG_PROP_IDX_MSGBODY].caub.cElems = dwDefaultMsgBodySize;  
		m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems = new unsigned char[dwDefaultMsgBodySize]; 

		m_paPropId[MSG_PROP_IDX_MSGBODY_TYPE] = PROPID_M_BODY_TYPE;       
		m_paVariant[MSG_PROP_IDX_MSGBODY_TYPE].vt = VT_UI4;                  
		m_paVariant[MSG_PROP_IDX_MSGBODY_TYPE].ulVal = 0; 
		 
		// Set the property for receiving the application specific unsigned int value.
		m_paPropId[MSG_PROP_IDX_APPSPECIFIC] = PROPID_M_APPSPECIFIC;       
		m_paVariant[MSG_PROP_IDX_APPSPECIFIC].vt = VT_UI4;                  
		m_paVariant[MSG_PROP_IDX_APPSPECIFIC].ulVal = 0;    

		// Set the property for sending/receiving the Admin queue name buffer size
		m_paPropId[MSG_PROP_IDX_ADMINQNAME_LEN] = PROPID_M_ADMIN_QUEUE_LEN;  
		m_paVariant[MSG_PROP_IDX_ADMINQNAME_LEN].vt = VT_UI4;               
		m_paVariant[MSG_PROP_IDX_ADMINQNAME_LEN].ulVal = MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS; 

		// Set the property for receiving the Admin Queue Name
		m_paPropId[MSG_PROP_IDX_ADMINQNAME] = PROPID_M_ADMIN_QUEUE;         
		m_paVariant[MSG_PROP_IDX_ADMINQNAME].vt = VT_LPWSTR;               
		m_paVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal = new TCHAR[MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS]; 

		// Set the property for receiving the src machine id
		m_paPropId[MSG_PROP_IDX_SRCMACHINEID] = PROPID_M_SRC_MACHINE_ID ;
		m_paVariant[MSG_PROP_IDX_SRCMACHINEID].vt = VT_CLSID;
		m_paVariant[MSG_PROP_IDX_SRCMACHINEID].puuid = new GUID;

		// Set the property for receiving the message lookup id
		m_paPropId[MSG_PROP_IDX_LOOKUP_ID] = PROPID_M_LOOKUPID;
		m_paVariant[MSG_PROP_IDX_LOOKUP_ID].vt = VT_UI8;
        m_paVariant[MSG_PROP_IDX_LOOKUP_ID].uhVal.QuadPart = 0;

		// Set the MQMSGPROPS structure with the property arrays defined above.
		m_pMsgProps->cProp = MSG_PROPERTIES_TOTAL_COUNT; // Number of properties.
		m_pMsgProps->aPropID = m_paPropId;               // Ids of properties.
		m_pMsgProps->aPropVar = m_paVariant;             // Values of properties.
		m_pMsgProps->aStatus = NULL;                     // No Error report. 

		// Initialise allocated memory
		ClearValues();
	}
}

//*******************************************************************
//
// Method      : Destructor	
//
// Description : Destroys and deallocates this message object.
//
//*******************************************************************
CMsgProperties::~CMsgProperties()
{
	if (m_paVariant != NULL)
	{
		delete(m_paVariant[MSG_PROP_IDX_MSGID].caub.pElems);
		delete(m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems);
		delete(m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems);
		delete(m_paVariant[MSG_PROP_IDX_LABEL].pwszVal);
		delete(m_paVariant[MSG_PROP_IDX_RESPQNAME].pwszVal);
		delete(m_paVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal);
		delete(m_paVariant[MSG_PROP_IDX_SRCMACHINEID].puuid);
	}

	if (m_pMsgProps != NULL)
	{
		delete m_pMsgProps;
	}

	if (m_paVariant != NULL)
	{
		delete m_paVariant;
	}

	if (m_paPropId != NULL)
	{
		delete m_paPropId;
	}
}

//*******************************************************************
//
// Method      : IsValid	
//
// Description : Returns a boolean value indicating if this object 
//               instance is currently in a valid state.
//
//*******************************************************************
bool CMsgProperties::IsValid() const
{
	return((m_paVariant[MSG_PROP_IDX_MSGID].caub.pElems != NULL) &&
	       (m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems != NULL) &&
		   (m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems != NULL) &&
	       (m_paVariant[MSG_PROP_IDX_LABEL].pwszVal != NULL) &&	
		   (m_paVariant[MSG_PROP_IDX_RESPQNAME].pwszVal != NULL) &&
		   (m_paVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal != NULL) &&
		   (m_paVariant[MSG_PROP_IDX_SRCMACHINEID].puuid != NULL) &&
	       (m_pMsgProps != NULL) &&
	       (m_paVariant != NULL) &&
	       (m_paPropId != NULL)); 
}

//*******************************************************************
//
// Method      : ClearValues
//
// Description : Initializes allocated memory for this message.
//
//*******************************************************************
void CMsgProperties::ClearValues()
{
	// Only initialize structures if this is a valid message object.
	if (this->IsValid())
	{
		ZeroMemory(m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems,MSG_CORRID_BUFFER_SIZE);
		ZeroMemory(m_paVariant[MSG_PROP_IDX_MSGID].caub.pElems,MSG_ID_BUFFER_SIZE);
		ZeroMemory(m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems,this->GetMsgBodyLen());
		ZeroMemory(m_paVariant[MSG_PROP_IDX_LABEL].pwszVal,MSG_LABEL_BUFFER_SIZE);
		ZeroMemory(m_paVariant[MSG_PROP_IDX_RESPQNAME].pwszVal,(MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS * sizeof(TCHAR)));
		ZeroMemory(m_paVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal,(MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS * sizeof(TCHAR)));	          
		ZeroMemory(m_paVariant[MSG_PROP_IDX_SRCMACHINEID].puuid, sizeof(GUID));	          
	}
}

//*******************************************************************
//
// Method      : GetLabel 
//
// Description : Returns the label of the current message as a variant.
//
//*******************************************************************
_variant_t CMsgProperties::GetLabel() const
{
	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	return (wchar_t*)m_paVariant[MSG_PROP_IDX_LABEL].pwszVal;
}

//*******************************************************************
//
// Method      : GetMessageID
//
// Description : Returns the current message ID as a safearray of 20
//               bytes packaged in a VARIANT.
//
//*******************************************************************
_variant_t CMsgProperties::GetMessageID() const
{
	HRESULT hr = S_OK;
	_variant_t vMessageID;
	BYTE * pByteBuffer = NULL;
	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	MQPROPVARIANT * pvArg = &m_paVariant[MSG_PROP_IDX_MSGID];

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = 20;

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	// Check that we created the safe array OK.
	if (psaBytes == NULL)
	{ 
		hr = S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pByteBuffer);

	// set the return value.
	if SUCCEEDED(hr)
	{
		// Copy the correlation ID from the message object to the safearray data buffer.
		memcpy(pByteBuffer,pvArg->caub.pElems,pvArg->caub.cElems);

		// Return the safe array if created successfully.
		vMessageID.vt = VT_ARRAY | VT_UI1;
		vMessageID.parray = psaBytes;

		hr = SafeArrayUnaccessData(vMessageID.parray);

		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			vMessageID.vt = VT_ERROR;
		}
	}
	else
	{
		vMessageID.vt = VT_ERROR;
	} 

	return(vMessageID);
}

//*******************************************************************
//
// Method      : GetCorrelationID
//
// Description : Returns the current correlation ID as a safearray of 
//               20 bytes packaged in a _variant_t.
//
//*******************************************************************
_variant_t CMsgProperties::GetCorrelationID() const
{
	HRESULT hr = S_OK;
	_variant_t vCorrelationID;
	BYTE * pByteBuffer = NULL;
	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	MQPROPVARIANT * pvArg = &m_paVariant[MSG_PROP_IDX_MSGCORRID];

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = 20;

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	// Check that we created the safe array OK.
	if (psaBytes == NULL)
	{ 
		hr = S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pByteBuffer);

	// set the return value.
	if SUCCEEDED(hr)
	{
		// Copy the correlation ID from the message object to the safearray data buffer.
		memcpy(pByteBuffer,pvArg->caub.pElems,pvArg->caub.cElems);

		// Return the safe array if created successfully.
		vCorrelationID.vt = VT_ARRAY | VT_UI1;
		vCorrelationID.parray = psaBytes;

		hr = SafeArrayUnaccessData(vCorrelationID.parray);

		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			vCorrelationID.vt = VT_ERROR;
		}
	}
	else
	{
		vCorrelationID.vt = VT_ERROR;
	}

	return(vCorrelationID);
}

//*******************************************************************
//
// Method      : GetPriority
//
// Description : Returns the current message priority as a long value.
//               Note that smaller values represent higher priority.
//
//*******************************************************************
_variant_t CMsgProperties::GetPriority() const
{
	_variant_t vPriority;

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	vPriority = (long)m_paVariant[MSG_PROP_IDX_PRIORITY].bVal;

	return(vPriority);
}

//*******************************************************************
//
// Method      : GetMsgBody
//
// Description : Returns the message body as a byte array packaged in 
//               a SafeArray.
//*******************************************************************
_variant_t CMsgProperties::GetMsgBody() const
{
	HRESULT hr = S_OK;
	_variant_t vMsgBody;
	BYTE * pByteBuffer = NULL;
	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	MQPROPVARIANT * pvArg = &m_paVariant[MSG_PROP_IDX_MSGBODY];

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = this->GetMsgBodyLen();

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	// Check that we created the safe array OK.
	if (psaBytes == NULL)
	{ 
		hr = S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pByteBuffer);

	// set the return value.
	if SUCCEEDED(hr)
	{
		// Copy the body from the message object to the safearray data buffer.
		memcpy(pByteBuffer,pvArg->caub.pElems,this->GetMsgBodyLen());

		// Return the safe array if created successfully.
		vMsgBody.vt = VT_ARRAY | VT_UI1;
		vMsgBody.parray = psaBytes;

		hr = SafeArrayUnaccessData(vMsgBody.parray);

		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			vMsgBody.vt = VT_ERROR;
		}
	}
	else
	{
		vMsgBody.vt = VT_ERROR;
	}

	return(vMsgBody);
}

//*******************************************************************
//
// Method      : ReAllocMsgBody
//
// Description : Reallocates the buffer used to hold the message body
//               The current msg body length is used to determine the 
//               size of the new buffer.
//
//*******************************************************************
bool CMsgProperties::ReAllocMsgBody()
{
	DWORD dwBufferSize = m_paVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal;

	// delete the existing message body data.
	if (m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems != NULL)
	{
		delete(m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems);
	}

	// allocate new buffer
	m_paVariant[MSG_PROP_IDX_MSGBODY].caub.cElems = dwBufferSize ;  
	m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems = new unsigned char[dwBufferSize]; //(unsigned char*)malloc(dwBufferSize); 

	// initialize new buffer (if we allocated successfully)
	if (m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems != NULL)
	{
		ZeroMemory(m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems,dwBufferSize);
	}

	return(m_paVariant[MSG_PROP_IDX_MSGBODY].caub.pElems != NULL);
}

//*******************************************************************
//
// Method      : GetMsgBodyLen
//
// Description : Returns the length of the message body
//
//*******************************************************************
long CMsgProperties::GetMsgBodyLen() const
{
	return(m_paVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal);
}

long CMsgProperties::GetMsgBodyType() const
{
	return(m_paVariant[MSG_PROP_IDX_MSGBODY_TYPE].ulVal);
}


//*******************************************************************
//
// Method      : GetMessageIDAsString
//
// Description : Returns the current message id as a BSTR, formatted
//               into the MSMQ Explorer like format.
//
//*******************************************************************
_bstr_t CMsgProperties::GetMessageIDAsString() const
{
	_bstr_t bstrMessageID;
	TCHAR * pszBuffer = NULL;
	OBJECTID oMessageID;
	DWORD dwBufferSize = 128; 

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	pszBuffer = (TCHAR*)new TCHAR[dwBufferSize];

	ZeroMemory(pszBuffer,dwBufferSize);

	memcpy(&oMessageID,m_paVariant[MSG_PROP_IDX_MSGID].caub.pElems,m_paVariant[MSG_PROP_IDX_MSGID].caub.cElems);	

	ObjectIDToString(&oMessageID,pszBuffer,dwBufferSize);

	bstrMessageID = pszBuffer;

	delete(pszBuffer);

	return(bstrMessageID);
}

//*******************************************************************
//
// Method      : GetCorrelationIDAsString
//
// Description : Returns the current correlation id as a BSTR, formatted
//               into the MSMQ Explorer like format.
//
//*******************************************************************
_bstr_t CMsgProperties::GetCorrelationIDAsString() const
{
	_bstr_t bstrCorrelationID;
	TCHAR * pszBuffer = NULL;
	OBJECTID oMessageID;
	DWORD dwBufferSize = 128; 

	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	pszBuffer = (TCHAR*)new TCHAR[dwBufferSize];

	ZeroMemory(pszBuffer,dwBufferSize);

	memcpy(&oMessageID,m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems,m_paVariant[MSG_PROP_IDX_MSGCORRID].caub.cElems);	

	ObjectIDToString(&oMessageID,pszBuffer,dwBufferSize);

	bstrCorrelationID = pszBuffer;

	delete(pszBuffer);

	return(bstrCorrelationID);
}

_variant_t CMsgProperties::GetSrcMachineId() const
{
	TCHAR* pBuffer = NULL;
	
	// This method should only be called on a valid message object - assert this.
	ASSERT(this->IsValid());

	RPC_STATUS status = UuidToString( m_paVariant[MSG_PROP_IDX_SRCMACHINEID].puuid, &pBuffer);
	if(status != RPC_S_OK)
	{
		return _variant_t(_T(""));
	}

	_variant_t vSrcMachineId = pBuffer;

	RpcStringFree(&pBuffer);
	
	return vSrcMachineId;
}



//*******************************************************************
//
// Method      : GetResponseQueueNameLen
//
// Description : Returns the length of the response queue name.
//
//*******************************************************************
long CMsgProperties::GetResponseQueueNameLen() const
{
	return(m_paVariant[MSG_PROP_IDX_RESPQNAME_LEN].ulVal);
}

//*******************************************************************
//
// Method      : GetResponseQueueName
//
// Description : Returns the name of the response queue for this msg.
//
//*******************************************************************
_bstr_t CMsgProperties::GetResponseQueueName() const
{
	return(m_paVariant[MSG_PROP_IDX_RESPQNAME].pwszVal);
}

//*******************************************************************
//
// Method      : GetAdminQueueNameLen
//
// Description : Returns the length of the Admin queue name.
//
//*******************************************************************
long CMsgProperties::GetAdminQueueNameLen() const
{
	return(m_paVariant[MSG_PROP_IDX_ADMINQNAME_LEN].ulVal);
}
 
//*******************************************************************
//
// Method      : GetAdminQueueName
//
// Description : Returns the name of the Admin queue for this msg.
//
//*******************************************************************
_bstr_t CMsgProperties::GetAdminQueueName() const
{
	return(m_paVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal);
}

//*******************************************************************
//
// Method      : GetAppSpecific
//
// Description : Returns the application specific integer value 
//               associated with the current message.
//
//*******************************************************************
_variant_t CMsgProperties::GetAppSpecific() const
{
	_variant_t v;

	v.vt = VT_UI4;
	v.ulVal = m_paVariant[MSG_PROP_IDX_APPSPECIFIC].ulVal;

	return(v);
}



//*******************************************************************
//
// Method      : GetArrivedTime
//
// Description : Returns the time in coordinated universal time format
//               that the message arrived.
//
//*******************************************************************
_variant_t CMsgProperties::GetArrivedTime() const
{
	_variant_t vArrivedTime;

	GetVariantTimeOfTime(m_paVariant[MSG_PROP_IDX_ARRIVEDTIME].ulVal,&vArrivedTime);

	return vArrivedTime.Detach();
}

//*******************************************************************
//
// Method      : GetSentTime
//
// Description : Returns the time in coordinated universal time format
//               that the message was sent.
//
//*******************************************************************
_variant_t CMsgProperties::GetSentTime() const
{
	_variant_t vSentTime;

	GetVariantTimeOfTime(m_paVariant[MSG_PROP_IDX_SENTTIME].ulVal, &vSentTime);

	return vSentTime.Detach();
}


//*******************************************************************
//
// Method      : GetMsgLookupID 
//
// Description : Returns the label of the current message as a variant.
//
//*******************************************************************
_variant_t CMsgProperties::GetMsgLookupID(void) const
{
	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

    //
    // Get string representation of 64bit lookup id
    //
    TCHAR lookupId[256];
    _ui64tot(m_paVariant[MSG_PROP_IDX_LOOKUP_ID].uhVal.QuadPart, lookupId, 10);
    ASSERT(("_ui64tot failed", lookupId [0] != '\0'));

    return lookupId;
    /*
    _variant_t varLookupId;

    //
    // Assign lookup-id to variant
    //
    varLookupId.vt = VT_BSTR;
    varLookupId.bstrVal = SysAllocString(lookupId);

	return varLookupId.Detach();
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cmsgprop.hpp ===
//*******************************************************************
//
// Class Name  : CMsgProperties
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is a 'helper' class that encapsulates the native
//               MSMQ message structures in an object-oriented API.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CMsgProperties_INCLUDED 
#define CMsgProperties_INCLUDED

// Include the definitions for MSMQ structures.
#include "mq.h"

// Define indexs for each message property into the array of message properties.
#define MSG_PROP_IDX_LABEL_LEN       0
#define MSG_PROP_IDX_LABEL           1
#define MSG_PROP_IDX_PRIORITY        2
#define MSG_PROP_IDX_MSGID           3
#define MSG_PROP_IDX_MSGCORRID       4
#define MSG_PROP_IDX_MSGBODY_LEN     5
#define MSG_PROP_IDX_MSGBODY         6
#define MSG_PROP_IDX_APPSPECIFIC     7
#define MSG_PROP_IDX_RESPQNAME_LEN   8
#define MSG_PROP_IDX_RESPQNAME       9
#define MSG_PROP_IDX_ADMINQNAME_LEN  10
#define MSG_PROP_IDX_ADMINQNAME      11
#define MSG_PROP_IDX_ARRIVEDTIME     12
#define MSG_PROP_IDX_SENTTIME        13
#define MSG_PROP_IDX_SRCMACHINEID	 14	
#define MSG_PROP_IDX_MSGBODY_TYPE    15
#define MSG_PROP_IDX_LOOKUP_ID       16

// Define the number of message properties encapsulated by this class.
#define MSG_PROPERTIES_TOTAL_COUNT   17

// Buffer sizes defined in BYTES
#define MSG_LABEL_BUFFER_SIZE       ((MQ_MAX_Q_LABEL_LEN * sizeof(TCHAR)) + sizeof(TCHAR))
#define MSG_ID_BUFFER_SIZE          20
#define MSG_CORRID_BUFFER_SIZE      20 

// Buffer sizes defined in TCHARS
#define MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS  (MQ_MAX_Q_NAME_LEN + 1)
#define MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS (MQ_MAX_Q_NAME_LEN + 1)

class CMsgProperties  
{
	public:		

		MQMSGPROPS * m_pMsgProps;
		MQPROPVARIANT * m_paVariant;
		MSGPROPID * m_paPropId;	

		CMsgProperties(DWORD dwDefaultMsgBodySize);
		~CMsgProperties();
		bool IsValid() const;

		void ClearValues();

		_variant_t GetLabel() const;
		_variant_t GetMessageID() const;
		_variant_t GetCorrelationID() const;
		_variant_t GetSrcMachineId() const;
		_variant_t GetPriority() const;

		
		long GetMsgBodyLen() const;
		bool ReAllocMsgBody();
		_variant_t GetMsgBody() const;
		long GetMsgBodyType() const;

		_bstr_t GetMessageIDAsString() const;
		_bstr_t GetCorrelationIDAsString() const;
		
		long GetResponseQueueNameLen() const;
		_bstr_t GetResponseQueueName() const;

		long GetAdminQueueNameLen() const;
		_bstr_t GetAdminQueueName() const;

		_variant_t GetAppSpecific() const;
		
		_variant_t GetArrivedTime() const;
		_variant_t GetSentTime() const;
        _variant_t GetMsgLookupID(void) const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\complini.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    complini.cpp

Abstract:
    Trigger COM+ component registration

Author:
    Nela Karpel (nelak) 15-May-2001

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include <comdef.h>
#include "Ev.h"
#include "cm.h"
#include "Svc.h"
#include "tgp.h"
#include "mqtg.h"
#include "mqsymbls.h"
#include "comadmin.tlh"

#include "complini.tmh"

const WCHAR xMqGenTrDllName[] = L"mqgentr.dll";

static WCHAR s_wszDllFullPath[MAX_PATH];

//+-------------------------------------------------------------------------
//
//  Function:   NeedToRegisterComponent
//
//  Synopsis:   Check if COM+ component registration is needed
//
//--------------------------------------------------------------------------
static
bool
NeedToRegisterComponent(
	VOID
	)
{
	DWORD dwInstalled;
	RegEntry regEntry(
				NULL, 
				CONFIG_PARM_NAME_COMPLUS_INSTALLED, 
				CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED, 
				RegEntry::Optional, 
				NULL
				);

	CmQueryValue(regEntry, &dwInstalled);

	//
	// Need to register if the value does not exist, or it exists and 
	// is equal to 0
	//
	return (dwInstalled == CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED);
}


//+-------------------------------------------------------------------------
//
//  Function:   SetComplusComponentRegistered
//
//  Synopsis:   Update triggers Complus component flag. 1 is installed.
//
//--------------------------------------------------------------------------
static
void
SetComplusComponentRegistered(
	VOID
	)
{
	RegEntry regEntry( NULL, CONFIG_PARM_NAME_COMPLUS_INSTALLED);

	CmSetValue(regEntry, CONFIG_PARM_COMPLUS_INSTALLED);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetComponentsCollection
//
//  Synopsis:   Create Components collection for application
//
//--------------------------------------------------------------------------
static
ICatalogCollectionPtr
GetComponentsCollection(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApplication
	)
{
		//
		// Get the Key of MQTriggersApp application
		//
		_variant_t vKey;
		pApplication->get_Key(&vKey);

		//
		// Get components colletion associated with MQTriggersApp application
		//
		ICatalogCollectionPtr pCompCollection = pAppCollection->GetCollection(L"Components", vKey);

		pCompCollection->Populate();

		return pCompCollection.Detach();
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateApplication
//
//  Synopsis:   Create Application in COM+
//
//--------------------------------------------------------------------------
static
ICatalogObjectPtr
CreateApplication(
	ICatalogCollectionPtr pAppCollection
	)
{
	SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		//
		// Add new application named TrigApp, Activation = Inproc
		//
		ICatalogObjectPtr pApplication = pAppCollection->Add();

		//
		// Update applications name
		//
		_variant_t vName;
        vName = xTriggersComplusApplicationName;
		pApplication->put_Value(L"Name", vName);

		//
		// Set application activation to "Library Application"
		//
		_variant_t vActType = static_cast<long>(COMAdminActivationInproc);
		pApplication->put_Value(L"Activation", vActType);

		//
		// Save Changes
		//
		pAppCollection->SaveChanges();

		TrTRACE(Tgs, "Created MqTriggersApp application in COM+.");
		return pApplication.Detach();
	}
	catch(_com_error& e)
	{
		TrERROR(Tgs, "New Application creation failed while registering Triggers COM+ component. Error=0x%x", e.Error());
		throw;
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   InstallComponent
//
//  Synopsis:   Install Triggers transasctional component in COM+
//
//--------------------------------------------------------------------------
static
void
InstallComponent(
	ICOMAdminCatalogPtr pCatalog,
	ICatalogObjectPtr pApplication,
	BSTR dllName
	)
{
	SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		//
		// Get application ID for the installation
		//
		_variant_t vId;
		pApplication->get_Value(L"ID", &vId);

		//
		// Install component from mqgentr.dll
		//
		pCatalog->InstallComponent(vId.bstrVal, dllName, L"", L"");

		TrTRACE(Tgs, "Installed component from mqgentr.dll in COM+.");
	}
	catch(_com_error& e)
	{
		TrERROR(Tgs, "The components from %ls could not be installed into COM+. Error=0x%x", xMqGenTrDllName, e.Error());
		throw;
	}

}


//+-------------------------------------------------------------------------
//
//  Function:   SetComponentTransactional
//
//  Synopsis:   Adjust transactional components properties
//
//--------------------------------------------------------------------------
static
void
SetComponentTransactional(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApplication
	)
{
	SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		ICatalogCollectionPtr pCompCollection = GetComponentsCollection(pAppCollection, pApplication);

		//
		// Check assumption about number of components
		//
		long count;
		pCompCollection->get_Count(&count);
		ASSERT(("More components installes than expected", count == 1));

		//
		// Update the first and only component - set Transaction = Required
		//
		ICatalogObjectPtr pComponent = pCompCollection->GetItem(0);

		_variant_t vTransaction = static_cast<long>(COMAdminTransactionRequired);
		pComponent->put_Value(L"Transaction", vTransaction);

		//
		// Save changes
		//
		pCompCollection->SaveChanges();

		TrTRACE(Tgs, "Configured component from mqgentr.dll to be transactional.");
	}
	catch(_com_error& e)
	{
		TrERROR(Tgs, "The Triggers transactional component could not be configured in COM+. Error=0x%x", e.Error());
		throw;
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   IsTriggersComponentInstalled
//
//  Synopsis:   Check if triggers component is installed for given 
//				appllication
//
//--------------------------------------------------------------------------
static
bool
IsTriggersComponentInstalled(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApp
	)
{
	SvcReportProgress(xMaxTimeToNextReport);

	ICatalogCollectionPtr pCompCollection = GetComponentsCollection(pAppCollection, pApp);

	long count;
	pCompCollection->get_Count(&count);

	for ( int i = 0; i < count; i++ )
	{
		ICatalogObjectPtr pComp = pCompCollection->GetItem(i);

		_variant_t vDllName;
		pComp->get_Value(L"DLL", &vDllName);

		if ( _wcsicmp(vDllName.bstrVal, s_wszDllFullPath) == 0 )
		{
			return true;
		}
	}

	return false;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsTriggersComplusComponentInstalled
//
//  Synopsis:   Check if triggers component is installed in COM+
//
//--------------------------------------------------------------------------
static
bool
IsTriggersComplusComponentInstalled(
	ICatalogCollectionPtr pAppCollection
	)
{
	long count;
	pAppCollection->Populate();
	pAppCollection->get_Count(&count);

	//
	// Go through the applications, find MQTriggersApp and delete it
	//
	for ( int i = 0; i < count; i++ )
	{
		ICatalogObjectPtr pApp = pAppCollection->GetItem(i);

		_variant_t vName;
		pApp->get_Name(&vName);

		if ( _wcsicmp(vName.bstrVal, xTriggersComplusApplicationName) == 0 )
		{
			//
			// Note: progress is reported for each application
			//
			if ( IsTriggersComponentInstalled(pAppCollection, pApp) )
			{
				TrTRACE(Tgs, "Triggers COM+ component is already registered.");
				return true;
			}
		}
	}

	TrTRACE(Tgs, "Triggers COM+ component is not yet registered.");
	return false;
}


//+-------------------------------------------------------------------------
//
//  Function:   RegisterComponentInComPlus
//
//  Synopsis:   Transactional object registration
//
//--------------------------------------------------------------------------
void 
RegisterComponentInComPlusIfNeeded(
	VOID
	)
{
	HRESULT hr;

	try
	{
		//
		// Registration is done only once
		//
		
		if ( !NeedToRegisterComponent() )
		{
			TrTRACE(Tgs, "No need to register Triggers COM+ component.");
			return;
		}
		
		TrTRACE(Tgs, "Need to register Triggers COM+ component.");		

		//
		// Compose full path to mqgentr.dll
		//
		WCHAR wszSystemDir[MAX_PATH];
		GetSystemDirectory( wszSystemDir, sizeof(wszSystemDir)/sizeof(wszSystemDir[0]) );
		wsprintf(s_wszDllFullPath, L"%s\\%s", wszSystemDir, xMqGenTrDllName);
		
		SvcReportProgress(xMaxTimeToNextReport);
		
		//
		// Create AdminCatalog Obect - The top level administration object
		//
		ICOMAdminCatalogPtr pCatalog;

		hr = pCatalog.CreateInstance(__uuidof(COMAdminCatalog));
		if ( FAILED(hr) )
		{
			TrERROR(Tgs, "Creating instance of COMAdminCatalog failed. Error=0x%x", hr);			
			throw bad_hresult(hr);
		}

		//
		// Get Application collection
		//
		
		ICatalogCollectionPtr pAppCollection;
		try
		{
			pAppCollection = pCatalog->GetCollection(L"Applications");
		}
		catch(const _com_error& e)
		{
			TrERROR(Tgs, "Failed to get 'Application' collection from COM+. Error=0x%x", e.Error());			
			throw;
		}

		if ( IsTriggersComplusComponentInstalled(pAppCollection) )
		{
			SetComplusComponentRegistered();
			return;
		}

		//
		// Create MQTriggersApp application in COM+
		//
		ICatalogObjectPtr pApplication;
		pApplication = CreateApplication(pAppCollection);
		
		//
		// Install transactional component from mqgentr.dll
		//
		InstallComponent(pCatalog, pApplication, s_wszDllFullPath);

		//
		// Configure installed component
		//
		SetComponentTransactional(pAppCollection, pApplication);
		
		//
		// Update registry
		//
		SetComplusComponentRegistered();

		return;
	}
	catch (const _com_error& e)
	{
		//
		// For avoiding failure in race conditions: if we failed to 
		// install the component, check if someone else did it. In such case
		// do not terminate the service
		//
		Sleep(1000);
		if ( !NeedToRegisterComponent() )
		{
			return;
		}

		WCHAR errorVal[128];
		swprintf(errorVal, L"0x%x", e.Error());
		EvReport(MSMQ_TRIGGER_COMPLUS_REGISTRATION_FAILED, 1, errorVal);
		throw;
	}
	catch (const bad_alloc&)
	{
		WCHAR errorVal[128];
		swprintf(errorVal, L"0x%x", MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		EvReport(MSMQ_TRIGGER_COMPLUS_REGISTRATION_FAILED, 1, errorVal);
		throw;
	}
	catch (const bad_hresult& b)
	{
		WCHAR errorVal[128];
		swprintf(errorVal, L"0x%x", b.error());
		EvReport(MSMQ_TRIGGER_COMPLUS_REGISTRATION_FAILED, 1, errorVal);
		throw;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cqueue.cpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "mqsymbls.h"
#include "mq.h"
#include "Ev.h"
#include "cqueue.hpp"
#include "QueueUtil.hpp"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "tgp.h"

#include "cqueue.tmh"

using namespace std;
 
//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
CQueue::CQueue(
	const _bstr_t& bstrQueueName, 
	HANDLE * phCompletionPort,
	DWORD dwDefaultMsgBodySize
	) :
	m_fOpenForReceive(false) 
{
	// Assert construction parameters
	ASSERT(phCompletionPort != NULL);

	// Initialise member variables
	m_bstrQueueName = bstrQueueName;
	m_bSerializedQueue = false;
	m_bBoundToCompletionPort = false;
	m_bInitialized = false;
	m_pReceivedMsg = NULL;
	m_phCompletionPort = phCompletionPort;
	m_dwDefaultMsgBodySize = dwDefaultMsgBodySize;

	ZeroMemory(&m_OverLapped,sizeof(m_OverLapped)); 
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
CQueue::~CQueue()
{
	TrTRACE(Tgs, "Queue %ls is being closed.", static_cast<LPCWSTR>(m_bstrQueueName));		
	
	//
	// Delete the contents of the trigger info lists.
	//
	ExpireAllTriggers();
}

//*******************************************************************
//
// Method      : IsValid	
//
// Description : Returns a boolean value indicating if this object 
//               instance is currently in a valid state. In the 
//               context of the CQueue object, 'Valid' means that this
//               queue object can participate is handling trigger events.
//
//*******************************************************************
bool CQueue::IsValid()
{
	return((m_hQueue != NULL) &&
		   (m_bBoundToCompletionPort == true) && 
		   (m_phCompletionPort != NULL) );
}
//*******************************************************************
//
// Method      : IsSerializedQueue
//
// Description :
//
//*******************************************************************
bool CQueue::IsSerializedQueue()
{
	return(m_bSerializedQueue);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
bool CQueue::IsInitialized()
{
	return(m_bInitialized);
}

//*******************************************************************
//
// Method      : GetTriggerCount
//
// Description : Returns a count of how many triggers are associated 
//               with this Queue instance.
//
//
//*******************************************************************
ULONG CQueue::GetTriggerCount()
{
	return((ULONG)m_lstRuntimeTriggerInfo.size());
}

//*******************************************************************
//
// Method      : GetTriggerByIndex
//
// Description : Returns a reference to a instance of the CRuntimeTriggerInfo
//               class.
//
//*******************************************************************
CRuntimeTriggerInfo * CQueue::GetTriggerByIndex(ULONG ulIndex)
{
	// This method should only be called when this object is valid - assert this.
	ASSERT(IsValid());

	ULONG ulTriggerCounter = 0;
	for(RUNTIME_TRIGGERINFO_LIST::iterator it = m_lstRuntimeTriggerInfo.begin(); 
	    it != m_lstRuntimeTriggerInfo.end();
		++it, ++ulTriggerCounter)
	{
		if (ulTriggerCounter == ulIndex)
		{
			// Cast our list item to a pointer type we can use.
			return *it;
		}
	}

	return NULL;
}

//*******************************************************************
//
// Method      : DetachMessage
//
// Description :
//
// Returns     : A reference to a CMsgProperties class instance.
//
// NOTE        : The caller of this method assumes the responsibility
//               for deleting the message object.
//
//*******************************************************************
CMsgProperties * CQueue::DetachMessage()
{
	CMsgProperties * pTemp = m_pReceivedMsg;

	if (m_pReceivedMsg != NULL)
	{
		// Assert the validity of the message received member variable.
		ASSERT(m_pReceivedMsg->IsValid());

		m_pReceivedMsg = NULL;
	}

	return(pTemp);
}

//*******************************************************************
//
// Method      : RePeekMessage
//
// Description : This method is called when a buffer overflow error 
//               has occurred. This method will reallocate the the 
//               buffer used for collection the message body and try 
//               to peek the message again.
//
//*******************************************************************
HRESULT CQueue::RePeekMessage()
{
	HRESULT hr = S_OK;

	// This method should only be called when this object is valid - assert this.
	ASSERT(this->IsValid());

	// get the message instance to reallocate it's message body buffer
	m_pReceivedMsg->ReAllocMsgBody();

	// peek at the current message again
	hr = MQReceiveMessage(
				m_hQueue,
				0,
				MQ_ACTION_PEEK_CURRENT,
				m_pReceivedMsg->m_pMsgProps,
				NULL,
				NULL,
				m_hQueueCursor,
				NULL
				);                   

	return(hr);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT CQueue::RequestNextMessage(bool bCreateCursor)
{
	HRESULT hr = S_OK;
	DWORD dwAction = MQ_ACTION_PEEK_NEXT;

	// This method should only be called when this object is valid - assert this.
	ASSERT(this->IsValid());

	// Validate some assumptions
	ASSERT(m_hQueue != NULL);

	// Special case processing for first time call. 
	if (bCreateCursor == true)
	{
		// Create an MSMQ cursor.
		hr = MQCreateCursor(m_hQueue,&m_hQueueCursor);

		if (SUCCEEDED(hr))
		{
			// On the first call - we want to peek at the current message.
			dwAction = MQ_ACTION_PEEK_CURRENT;
			TrTRACE(Tgs, "Create new cursor for queue: %ls. Cursor 0x%p.", static_cast<LPCWSTR>(m_bstrQueueName), m_hQueueCursor);
		}
		else
		{
			// Write an error message.
			TrERROR(Tgs, "Failed to create a cursor for queue: %ls. Error 0x%x", static_cast<LPCWSTR>(m_bstrQueueName), hr);		
		}
	}

	// Attempt to receive a message only if we created the cursor successfully.
	if (SUCCEEDED(hr))
	{
		// If this queue object still has a message object attached, it means that we are 
		// issuing the MQReceiveMessage() request for the same position in the queue. This 
		// only happens when one thread is picking up after another thread has exited. If 
		// we do not have a message object attached, then we are issuing the request for the 
		// next location in the queue - in which case we will need to allocate another msg object.
		if (m_pReceivedMsg == NULL)
		{
			// Create a new message properties structure - and check that it is valid.
			m_pReceivedMsg = new CMsgProperties(m_dwDefaultMsgBodySize);
		}
		else
		{
			// Assert the validity of the message received member variable.
			ASSERT(m_pReceivedMsg->IsValid());

			dwAction = MQ_ACTION_PEEK_CURRENT;
		}
	}

	if SUCCEEDED(hr)
	{
		//
		// Add reference before start of pending operation
		//
		this->AddRef();

		// Request the next message
		hr = MQReceiveMessage(
					m_hQueue,
					INFINITE,
					dwAction,
					m_pReceivedMsg->m_pMsgProps,
					&m_OverLapped,
					NULL,
					m_hQueueCursor,
					NULL );                   


		//
		// SPECIAL CASE processing. We received a message from the queue immediately, but the 
		// preallocated body buffer length was insufficient. We will reallocate the body buffer 
		// and try again and let the return code processing continue.
		//
		if (hr == MQ_ERROR_BUFFER_OVERFLOW)
		{
			m_pReceivedMsg->ReAllocMsgBody();

		    hr = MQReceiveMessage(m_hQueue,INFINITE,MQ_ACTION_PEEK_CURRENT,m_pReceivedMsg->m_pMsgProps,&m_OverLapped,NULL,m_hQueueCursor,NULL);                   								
		}

		switch(hr)
		{
			case MQ_INFORMATION_OPERATION_PENDING :
			{
				// no message on the queue at the moment - this is ok
				hr = S_OK;
				break;
			}
			case MQ_OK :
			{
				// this is OK - we received a message immediately.
				hr = S_OK;
				break;
			}
			default:
			{
				//
				// No pending operation, so release reference counting
				//
				this->Release();

				// an unexpected error has occurred.
				TrERROR(Tgs, "Failed to receive a message from queue: %ls. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);		
				break;
			}
		}
	}

	return(hr);
}


static set< _bstr_t > s_reportedQueues;

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT
CQueue::Initialise(
	bool fOpenForReceive,
	const _bstr_t& triggerName
	)
{
	HRESULT hr = S_OK;

	ASSERT(("Attempt to initialize already initilaized queue.\n", !m_bInitialized));

	m_fOpenForReceive = fOpenForReceive;
	DWORD dwAction = (fOpenForReceive ? MQ_RECEIVE_ACCESS : MQ_PEEK_ACCESS);
	// Attempt to open the queue
	hr = OpenQueue(
		m_bstrQueueName, 
		dwAction,
		false,
		&m_hQueue,
		&m_bstrFormatName
		);

	if(FAILED(hr))
	{
		if (s_reportedQueues.find(m_bstrQueueName) == s_reportedQueues.end())
		{
			//
			// First time MSMQ triggers try to open the queue and failes. Carete an 
			// event log message
			//
			s_reportedQueues.insert(m_bstrQueueName);

			if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
			{
				EvReport(MSMQ_TRIGGER_QUEUE_NOT_FOUND, 2, static_cast<LPCWSTR>(m_bstrQueueName), static_cast<LPCWSTR>(triggerName));
				return hr;
			}

			WCHAR strError[256];
			swprintf(strError, L"0x%x", hr);

			EvReport(MSMQ_TRIGGER_OPEN_QUEUE_FAILED, 3, static_cast<LPCWSTR>(m_bstrQueueName), strError, static_cast<LPCWSTR>(triggerName));
			return hr;
		}

		return hr;
	}

	//
	// Store if the queue opened for recieve or not. This flag is used when attaching a 
	// new receive trigger to a queue. if the queue already opened for peaking only, the
	// queue object can't be used for receiving trigger and new queue should be created
	//
	m_fOpenForReceive = fOpenForReceive;

	//
	// Queue is opened, bind to the supplied IO Completion port.
	//
 	hr = this->BindQueueToIOPort();
	if (FAILED(hr))
	{
		TrERROR(Tgs, "Failed to bind queue handle to completion port. Queue %ls initilization failed. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return hr;
	}

	//
	// Queue is bound, request first message.
	//
	hr = this->RequestNextMessage(true);
	if (FAILED(hr))
	{
		TrERROR(Tgs, "Failed to receive a message from queue: %ls. Queue initilization failed. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return hr;
	}

	this->m_bInitialized = true;
	TrTRACE(Tgs, "Queue: %ls initilization completed successfully", static_cast<LPCWSTR>(m_bstrQueueName));
	
	return S_OK;
}


//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT CQueue::BindQueueToIOPort()
{
	HRESULT hr = S_OK;
	HANDLE hTemp = NULL;

	ASSERT(m_phCompletionPort != NULL);

	// This implementation of the CQueue object only allows the queue object to be bound
	// to one completion port - once only.
	if (m_bBoundToCompletionPort == false)
	{
		// Attempt to bind - use the reference to the runtime info as our completion key.
		hTemp = CreateIoCompletionPort(m_hQueue,(*m_phCompletionPort),0,0);

		// Attempt to open the queue that this Monitor watches.
		if (hTemp != NULL)
		{
			// Set member var to indicate that this queue is bound
			m_bBoundToCompletionPort = true;
			TrTRACE(Tgs, "Successfully bound queue: %ls to IO port", static_cast<LPCWSTR>(m_bstrQueueName));		
		} 
		else
		{
			// Write a log message to indicate what failed.
			TrERROR(Tgs, "Failed to bind queue: %ls to io port. Error %d", (LPCWSTR)m_bstrQueueName, GetLastError());
			hr = MQTRIG_ERROR;
		}
	}

	return (hr);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
void CQueue::ExpireAllTriggers()
{
	for(RUNTIME_TRIGGERINFO_LIST::iterator it = m_lstRuntimeTriggerInfo.begin();
	    it != m_lstRuntimeTriggerInfo.end();
		)
	{
		// Cast our list item to a pointer type we can use.
		CRuntimeTriggerInfo * pTrigger = *it;

		// Remove this trigger refence and process next one
		it = m_lstRuntimeTriggerInfo.erase(it);

		delete pTrigger;	
	}

	m_bSerializedQueue = false;
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
void CQueue::AttachTrigger(CRuntimeTriggerInfo * pTriggerInfo)
{
	// This method should only be called when this object is valid - assert this.
	ASSERT(this->IsValid());
	ASSERT(pTriggerInfo != NULL);

	// Test if this trigger is serialized - if it is, then this entire queue (i.e. all triggers
	// attached to this queue are serialized).
	//BUGBUG - serialized should become a property of the queue !!!
	if(pTriggerInfo->IsSerialized())
	{
		m_bSerializedQueue = true;
	}

	//
	// Add this to our list of run-time trigger info objects
	//
	m_lstRuntimeTriggerInfo.push_back(pTriggerInfo);
}


HRESULT CQueue::ReceiveMessageByLookupId(_variant_t lookupId)
{
	ASSERT(("Queue is not a Message Receive Queue", m_hQueue != 0));

	ULONGLONG ulLookupID = _ttoi64(lookupId.bstrVal);

	HRESULT hr = MQReceiveMessageByLookupId(
						m_hQueue,
						ulLookupID,
						MQ_LOOKUP_RECEIVE_CURRENT,
						NULL,
						NULL,
						NULL,
						NULL
						);

	//
	// If message does not exist already - it is not an error
	//
	if ( hr == MQ_ERROR_MESSAGE_NOT_FOUND )
	{
		TrERROR(Tgs, "Failed to receive message from queue: %ls with lookupid. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return S_OK;
	}

	return hr;
}


_variant_t CQueue::GetLastMsgLookupID()
{
	return m_vLastMsgLookupID;
}


void CQueue::SetLastMsgLookupID(_variant_t vLastMsgLookupId)
{
	m_vLastMsgLookupID = vLastMsgLookupId;
}


void CQueue::CancelIoOperation(void)
{
	//
	// Cancel Io operation on this queue and close the queue handle, so that IO operations 
	// initiated by other threads for this queue will be cancelled.
	//
	CancelIo(m_hQueue);
	MQCloseQueue(m_hQueue.detach());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cqmanger.hpp ===
//*******************************************************************
//
// Class Name  : CQManager
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is a container for the queue objects that the
//               MSMQ trigger service requires. This class acts as the 
//               container for the queue instances, as well as providing
//               the required locking & synchronisation for accessing 
//               the group of queues.
//
//               (1) Any method that returns a reference to a queue object
//                   must increment it's reference count.
//
//               (2) The recipient of a queue reference must decrement the
//                   reference count when they are finished with. There is  
//                   a smart pointer class to facilitate this.
// 
//               (3) Periodically the CQmanager will be called to release
//                   expired queue objects. Only those with a reference 
//                   count of zero will actually be destroyed.
//                
//               (4) The CQManager maintains a single-writer / multiple-reader
//                   lock on behalf of all queues. Any method that adds or 
//                   removes queues must acquire a writer lock first. Any 
//                   method that returns a reference to a queue must do so 
//                   within the scope of a reader lock. 
//
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CQueueManager_INCLUDED 
#define CQueueManager_INCLUDED

#pragma warning(disable:4786)

// Definitions of the Queue object that this class manages
#include "cqueue.hpp"

#include "rwlock.h"

// Define a new type - a 2D map of queue-names and pointers to queue objects
typedef std::map<std::wstring, R<CQueue>, std::less<std::wstring> > QUEUE_MAP;

class CQueueManager : public CReference 
{
	friend class CTriggerMonitorPool;

	private :
		//
		// Reader writer lock protecting changes to the queue map.
		//
		CReadWriteLock m_rwlMapQueue;
		QUEUE_MAP m_mapQueues;

		HANDLE m_hIOCompletionPort;

		//
		// An interface pointer to the MSMQ Triggers Configuration COM component
		//
		IMSMQTriggersConfigPtr m_pITriggersConfig;


	public:
		CQueueManager(IMSMQTriggersConfigPtr pITriggersConfig);
		~CQueueManager();

		CReadWriteLock m_rwlSyncTriggerInfoChange;

		// Returns the number of queue currently in the map.
		long GetNumberOfQueues();

		// Removes a queue from the queue - deleting the instance of the queue object.
		void RemoveUntriggeredQueues(void);
		void CancelQueuesIoOperation(void);
		void ExpireAllTriggers(void);

		// Adds queue to the queue returing the new reference, or the existing reference if 
		// the queue is allready present in the map. The QueueName is used as the key.
		CQueue* 
		AddQueue(
			const _bstr_t& sQueueName,
			const _bstr_t& triggerName,
			bool fOpenForReceive,
			HANDLE * phCompletionPort
			);

		// Returns a queue reference using the name as a key.
		CQueue * GetQueueByName(_bstr_t bstrQueueName);

		// Returns a queue reference using an offset (index) into the queue map.
		CQueue * GetQueueAtIndex(long lIndex);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cqmanger.cpp ===
//*******************************************************************
//
// Class Name  : CQManger
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is a container for the queue objects that the
//               MSMQ trigger service requires. This class acts as the 
//               container for the queue instances, as well as providing
//               the required locking & synchronisation for accessing 
//               the group of queues.
//
//               There are some very strict rules about the use of 
//               Queue references. They are :
//
//               (1) Any method that returns a reference to a queue object
//                   must increment it's reference count.
//
//               (2) The recipient of a queue reference must decrement the
//                   reference count when they are finished with. There is  
//                   a smart pointer class to facilitate this.
// 
//               (3) Periodically the CQmanager will be called to release
//                   expired queue objects. Only those with a reference 
//                   count of zero will actually be destroyed.
//                
//               (4) The CQManager maintains a single-writer / multiple-reader
//                   lock on behalf of all queues. Any method that adds or 
//                   removes queues must acquire a writer lock first. Any 
//                   method that returns a reference to a queue must do so 
//                   within the scope of a reader lock. 
//
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 18/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "cqmanger.hpp"
#include "ruleinfo.hpp"
#include "triginfo.hpp"
#include "Tgp.h"    

#include "cqmanger.tmh"

using namespace std;


//*******************************************************************
//
// Method      : Constructor
//
// Description : Initializes an instance of the CQManager class.
//
//*******************************************************************
CQueueManager::CQueueManager(
	IMSMQTriggersConfigPtr pITriggersConfig
	) : 
	m_pITriggersConfig(pITriggersConfig)	 
{
}

//*******************************************************************
//
// Method      : Destructor
//
// Description : Deallocates an instance of the CQManager class.
//
//*******************************************************************
CQueueManager::~CQueueManager()
{
	CSW wl(m_rwlMapQueue);

	m_mapQueues.erase(m_mapQueues.begin(), m_mapQueues.end());
}


//*******************************************************************
//
// Method      : GetNumberOfQueues
//
// Description : Returns the number of queues currently in contained
//               by this instance of the CQueueManager
//
//*******************************************************************
long CQueueManager::GetNumberOfQueues()
{
	CSR rl(m_rwlMapQueue);

	return ((long)m_mapQueues.size());
}

//*******************************************************************
//
// Method      : GetQueueByName
//
// Description : Returns a reference to a queue object based on the 
//               queue name. If no queue object is found by the 
//               supplied name, null is returned.
//
//*******************************************************************
CQueue * CQueueManager::GetQueueByName(_bstr_t bstrQueueName)
{
	wstring sQueueName;

	{ //always use upper case for queue path comparison
		AP<WCHAR> wcs = new WCHAR[wcslen((WCHAR*)bstrQueueName) + 1]; 
		wcscpy((WCHAR*)wcs, (WCHAR*)bstrQueueName);
		CharUpper((WCHAR*)wcs);

		sQueueName = wcs;
	}

	CSR rl(m_rwlMapQueue);

	//
	// Attempt to find the named queuue
	//
	QUEUE_MAP::iterator it = m_mapQueues.find(sQueueName);

	if (it == m_mapQueues.end())
	{
		// This should never happen;
		ASSERT(false);
		return NULL;
	}

	// Assert that we are returning a reference to a valid queue object
	ASSERT(it->second->IsValid());

	return (SafeAddRef(it->second.get()));
}

//*******************************************************************
//
// Method      : GetQueueAtIndex
//
// Description : Returns a refenence to the queue object at the 
//               specified queue index. If the supplied queue index 
//               is invalid, returns null. As this method is used to 
//               iterate through all queues constained by this class, 
//               it is important that the calling thread acquires a 
//               writer lock on the queue map before iterating.
//
//*******************************************************************
CQueue * CQueueManager::GetQueueAtIndex(long lIndex)
{
	CSR rl(m_rwlMapQueue);

	if ((lIndex >= (long)0) || (lIndex < (long)m_mapQueues.size()))
	{
		QUEUE_MAP::iterator it = m_mapQueues.begin();

		for(long lCtr=0; lCtr != lIndex; lCtr++)
		{
			++it;
		}

		// Assert that we are returning a reference to a valid queue object
		ASSERT((it->second.get())->IsValid());

		// Add to the reference count for this queue object. 
		return (SafeAddRef(it->second.get()));

	}

	return NULL;
}

//*******************************************************************
//
// Method      : RemoveQueueAtIndex
//
// Description : Removes a queue at the specified index from the 
//               queue map. Note that this will delete the queue 
//               object, consequently closing the associated queue 
//               handle and cursor handle.
//
//*******************************************************************
void CQueueManager::RemoveUntriggeredQueues(void)
{
	CSW wl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); )
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		if (pQueue->GetTriggerCount() != 0)
		{
			++it;
			continue;
		}

		pQueue->CancelIoOperation();

		//
		// remove this queue from the map.
		//
		it = m_mapQueues.erase(it); 
	}
}


//
// This routine is called to cancel all the pending operation for a specific thread.
// It doesn't cancel any IO operation related to other threads
//
void CQueueManager::CancelQueuesIoOperation(void)
{
	CSR rl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); ++it)
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		CancelIo(pQueue->m_hQueue);
	}
}


void CQueueManager::ExpireAllTriggers(void)
{
	CSR rl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); ++it)
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		pQueue->ExpireAllTriggers();
	}
}

//*******************************************************************
//
// Method      : AddQueue
//
// Description : Adds a new queue to the queue map. An attempt is made
//               to initialize the new queue object - if this succeeds
//               then the queue object is added to the map and a reference
//               to the new object is returned. If initialization fails, 
//               the queue is not added to the map and this method will 
//               return null.
//
//*******************************************************************
CQueue* 
CQueueManager::AddQueue(
	const _bstr_t& bstrQueueName,
	const _bstr_t& triggerName,
	bool fOpenForReceive,
	HANDLE * phCompletionPort
	)
{
	HRESULT hr = S_OK;
	DWORD dwDefaultMsgBodySize = 0;

	wstring sQueueName;
	
	{ //always use upper case for queue path comparison
		AP<WCHAR> wcs = new WCHAR[wcslen((WCHAR*)bstrQueueName) + 1]; 
		wcscpy((WCHAR*)wcs, (WCHAR*)bstrQueueName);
		CharUpper((WCHAR*)wcs);

		sQueueName = wcs;
	}

	// get the default msg size we expect of messages that arrive in the queue.
	dwDefaultMsgBodySize = m_pITriggersConfig->GetDefaultMsgBodySize();

	// Attempt to find the named queuue
	CSW wl(m_rwlMapQueue);
	
	QUEUE_MAP::iterator it = m_mapQueues.find(sQueueName);

	if (it != m_mapQueues.end())
	{
		CQueue* pQueue = it->second.get();
		if (!fOpenForReceive || pQueue->IsOpenedForReceive())
			return (SafeAddRef(pQueue));

		//
		// There is an existing queue, but it only opened for peaking and now 
		// we need it for receiving. remove this queue object and create a new one
		//
		ASSERT(("Trigger should not associate to queue", (pQueue->GetTriggerCount() == 0)));
		pQueue->CancelIoOperation();

		//
		// remove this queue from the map.
		//
		m_mapQueues.erase(it); 
	}

	// The queue is not currently in the map. Create a new queue object 
	R<CQueue> pQueue = new CQueue(bstrQueueName, phCompletionPort, dwDefaultMsgBodySize);

	//  Attempt to initialise the new queue object
	hr = pQueue->Initialise(fOpenForReceive, triggerName);

	// If we failed, then release the Queue object and return NULL.
	if(FAILED(hr))
	{
		TrTRACE(Tgs, "Failed to add a new queue: %ls. Initialization failed", static_cast<LPCWSTR>(bstrQueueName));
		return NULL;
	}

	// Add it to the map of queue maintained by the QueueManager class
	m_mapQueues.insert(QUEUE_MAP::value_type(sQueueName, pQueue));

	// Write a trace message
	TrTRACE(Tgs, "QueueManager::AddQueue() has successfully added queue %ls", static_cast<LPCWSTR>(bstrQueueName));

	return SafeAddRef(pQueue.get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cqueue.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#pragma once 

#ifndef CQueue_INCLUDED 
#define CQueue_INCLUDED

class CMsgProperties;
class CRuntimeTriggerInfo;

//
// Define the size of the format name for a queue (in characters)
//
#define MSMQ_FORMAT_NAME_BUFFER_SIZE 256

//
// Define a new type - a list of Runtime Trigger Info
//
typedef std::list<CRuntimeTriggerInfo*> RUNTIME_TRIGGERINFO_LIST;


class CQueue : public CReference 
{
friend 
    class CQueueManager;

public :
	CQueue(
		const _bstr_t& bstrQueueName, 
		HANDLE* phCompletionPort,
		DWORD dwDefaultMsgBodySize
		);
	~CQueue();

	void ExpireAllTriggers();
	void AttachTrigger(CRuntimeTriggerInfo * pTriggerInfo);

	HRESULT BindQueueToIOPort();


	bool IsValid();
	bool IsSerializedQueue();
	bool IsInitialized();

	HRESULT 
	Initialise(
		bool fOpenForReceive,
		const _bstr_t& triggerName
		);

	ULONG GetTriggerCount();
	CRuntimeTriggerInfo * GetTriggerByIndex(ULONG ulIndex);

	_variant_t GetLastMsgLookupID();
	void SetLastMsgLookupID(_variant_t vLastNsgLookupId);

	CMsgProperties * DetachMessage();
	HRESULT RePeekMessage();
	HRESULT RequestNextMessage(bool bCreateCursor);

	HRESULT ReceiveMessageByLookupId(_variant_t lookupId);

	void CancelIoOperation(void);


	bool IsTriggerExist(void)
	{
		return (GetTriggerCount() != 0);
	}

	bool IsOpenedForReceive(void) const
	{
		return m_fOpenForReceive;
	}

public:
	bool m_bInitialized;
	bool m_bSerializedQueue;

	bool m_bBoundToCompletionPort;

	CHandle m_hQueue;
	bool m_fOpenForReceive;

	//
	// Cursor will be closed when the queue handle is closed
	//
	HANDLE m_hQueueCursor;
	HANDLE* m_phCompletionPort;

	OVERLAPPED m_OverLapped;

	// the path name of this queue object
	_bstr_t m_bstrQueueName;

	// the msmq format name of this queue object.
	_bstr_t m_bstrFormatName;

private:
	//
	// Reader writer lock protecting changes to trigger list.
	//
	RUNTIME_TRIGGERINFO_LIST m_lstRuntimeTriggerInfo;

	// this is the size of the message bodies we expect to see on this queue.
	DWORD m_dwDefaultMsgBodySize;
	CMsgProperties * m_pReceivedMsg;
	_variant_t m_vLastMsgLookupID;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cthread.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CThread_INCLUDED 
#define CThread_INCLUDED

#include <process.h>

// Define the default thread stack size.
#define DEFAULT_THREAD_STACK_SIZE  8000

class CThread
{
	public:

		// Constructor / Destructor
		CThread(
            DWORD dwStackSize = DEFAULT_THREAD_STACK_SIZE,
            DWORD m_dwCreationFlags = CREATE_SUSPENDED, 
            LPTSTR lpszThreadName = _T("CThread"),
            IMSMQTriggersConfigPtr pITriggersConfig = NULL
            );

		~CThread();

		// An interface pointer to the MSMQ Triggers Configuration COM component
		IMSMQTriggersConfigPtr m_pITriggersConfig;

		// The thread ID of this thread object
		unsigned int m_iThreadID;

		// The handle object to this thread
		HANDLE m_hThreadHandle;

		// Each thread object instance will have a name.
		_bstr_t m_bstrName;

		// Thread identification methods
		_bstr_t GetName();
		DWORD  GetThreadID();

		// Thread control and synchronisation 
		bool Pause();
		bool Resume();
		bool Stop();
		bool IsRunning();
		bool WaitForInitToComplete(DWORD dwTimeout);

		// The follow methods are to be over-riden by derivations of this class. 
		virtual bool Init() = 0;
		virtual bool Run() = 0;
		virtual bool Exit() = 0;

	private :

		CThread * m_pThis;
		LPVOID m_lpThreadParms;
		DWORD m_dwCreationFlags;

		// The stack size that this thread was initialized.
		DWORD m_dwStackSize;

		// Flag indicating if this thread should keep running or not.
		bool m_bKeepRunning;

		// An event that is signall when initialization is complete - either successfully or otherwise.
		HANDLE m_hInitCompleteEvent;
		
		// The static starting address for this thread.
		static unsigned __stdcall ThreadProc(void * pThis);	

		// The main thread routine which calls the Init / Run / Exit over-rides.
		void Execute();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\cthread.cpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "cthread.hpp"
#include "tgp.h"

#include "cthread.tmh"

//*******************************************************************
//
// Method      : Constructor 
//
// Description : Constructs a thread object. Key tasks performed by 
//               the constructor are :
//
//               1 - Attach a reference to the Triggers Config COM obj
//               2 - Initialize thread parameters (stack size etc...)
//               3 - Create a new thread
//               4 - Create the new thread name
//               5 - Create an instance of the log for this thread.
//               6 - Create an NT event used to signal when this thread
//                   has completed it's intialization code.
//
//*******************************************************************
CThread::CThread(
	DWORD dwStackSize,
	DWORD m_dwCreationFlags, 
	LPTSTR lpszThreadName,
	IMSMQTriggersConfigPtr pITriggersConfig
	) :
	m_pITriggersConfig(pITriggersConfig)
{
	TCHAR szThreadID[10];

	ASSERT(lpszThreadName != NULL);
	ASSERT(pITriggersConfig != NULL);

	// Initialise the psuedo this pointer
	m_pThis = (CThread*)this;

	// Initialise default thread properties.
	m_dwStackSize = dwStackSize;
	m_dwCreationFlags = m_dwCreationFlags;  
	m_iThreadID = NULL;
	m_bstrName = lpszThreadName;
	m_hInitCompleteEvent = NULL;

	// Create a new thread
	m_hThreadHandle = (HANDLE)_beginthreadex(
											NULL,
											0,
											&ThreadProc,
											(void*)this,
											m_dwCreationFlags,
											&m_iThreadID
											);

	// Initialise the flag that indicates if this thread should keep running
	m_bKeepRunning = true;

	// If this thread was created successfully, we will append the
	// new thread ID to the Name of this thread to help identify it 
	// in the log.
	if (m_hThreadHandle != NULL)
	{
		// Initialise string buffer for holding the ThreadID as a string
		ZeroMemory(szThreadID,sizeof(szThreadID));

		// Get string representation of thread-id
		swprintf(szThreadID,_T("%d"),(DWORD)GetThreadID());

		// Append this to the name of this thread. 
		m_bstrName += ((LPCTSTR)szThreadID);
	}

	// Create an NT event object that will be used to signal when the thread has 
	// completed it's intiailisation / startup code. 
	m_hInitCompleteEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	if (m_hInitCompleteEvent == NULL) 
	{
		TrERROR(Tgs, "Failed to create an event. CThread construction failed. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

	TrTRACE(Tgs, "CThread constructor has been called. Thread no: %d", m_iThreadID);
}

//*******************************************************************
//
// Method      : Destructor.
//
// Description : Destroys an instance of the thread object.
//
//*******************************************************************
CThread::~CThread()
{
	// Write a trace message
	TrTRACE(Tgs, "CThread destructor has been called. Thread no: %d", m_iThreadID);

	if (m_hInitCompleteEvent != NULL)
	{
		CloseHandle(m_hInitCompleteEvent);
	}
	
	// _endthreadex() does not close the handle of the thread
	CloseHandle( m_hThreadHandle );
}

//*******************************************************************
//
// Method      : GetName
//
// Description : Returns the name of this thread instance.
//
//*******************************************************************
_bstr_t CThread::GetName()
{
	return(m_bstrName);
}

//*******************************************************************
//
// Method      : GetThreadID
//
// Description : Returns the thread id of this thread.
//
//*******************************************************************
DWORD CThread::GetThreadID()
{
	return((DWORD)m_iThreadID);
}

//*******************************************************************
//
// Method      : Pause
//
// Description : Suspends the thread execution.
//
//*******************************************************************
bool CThread::Pause()
{
	// Write a trace message
	TrTRACE(Tgs, "CThread was paused. Thread no: %d", m_iThreadID);

	return(SuspendThread(this->m_hThreadHandle) != 0xFFFFFFFF);
}

//*******************************************************************
//
// Method      : Resume
//
// Description : Unsuspend a threads processing.
//
//*******************************************************************
bool CThread::Resume()
{
	// Write a trace message
	TrTRACE(Tgs, "CThread was resume. Thread no: %d", m_iThreadID);

	return(ResumeThread(this->m_hThreadHandle) != 0xFFFFFFFF);
}

//*******************************************************************
//
// Method      : Execute
//
// Description : This is the main control method for this thread. 
//               Derivations of this class do not over-ride this method,
//               instead, they over-ride the Init() & Run() & Exit() 
//               methods.
//
//*******************************************************************
void CThread::Execute()
{
	// Write a trace message
	TrTRACE(Tgs, "Execute method in CThread was called. Thread no: %d", m_iThreadID);

	// Initialise this thread for COM - note that we support Apartment threading.
	HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TrTRACE(Tgs, "Failed to initializes the COM library. CThread execution failed. Error 0x%x", GetLastError());
		return;
	}

	try
	{
		//
		// Invoke the Init() override in the derived class
		//
		bool bOK = Init();

		// Set the NT event object to indicate that the thread has completed initialisation.
		if (SetEvent(m_hInitCompleteEvent) == FALSE)
		{
			bOK = false;
			TrERROR(Tgs, "Failed set the initialization event object. Unable to continue. Error=0x%x", GetLastError());
		}

		//
		// Invoke the Run() override in the derived class
		//
		if (bOK == true)
		{
			Run();
		}

		//
		// Invoke the Exit() override in the derived class
		//
		Exit();

	}
	catch(const _com_error& e)
	{
		// Write an error message to the log.
		TrERROR(Tgs, "An unhandled COM thread exception has been caught. Thread no: %d. Error=0x%x", m_iThreadID, e.Error());
		SetEvent(m_hInitCompleteEvent);
	}
	catch(const exception&)
	{
		// Write an error message to the log.
		TrERROR(Tgs, "An unhandled thread exception has been caught. Thread no: %d", m_iThreadID);
		SetEvent(m_hInitCompleteEvent);
	}

	// unitialize the COM libraries
	 CoUninitialize();

	// Write a trace message
	TrTRACE(Tgs, "Thread no: %d completed", m_iThreadID);

	// Time to exit this thread.
	_endthreadex(0);		 
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
bool CThread::Stop()
{
	TrTRACE(Tgs, "CThread has been stoped. Thread no: %d", m_iThreadID);

	bool bOriginalValue = m_bKeepRunning;
	m_bKeepRunning = false;

	return(bOriginalValue);
}

//*******************************************************************
//
// Method      : WaitForInitToComplete
//
// Description : This method is called by the owner of this thread 
//               instance. It blocks until this thread pool object 
//               has completed it's initialization or a timeout occurs.
//
//*******************************************************************
bool CThread::WaitForInitToComplete(DWORD dwTimeout)
{
	DWORD dwWait = WAIT_OBJECT_0;

	// The TriggerMonitor thread should not be calling this method - check this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());

	if(dwTimeout == -1)
	{
		dwTimeout = INFINITE;
	}

	// Block until initialization event is set - or timeout.
	dwWait = WaitForSingleObject(m_hInitCompleteEvent, dwTimeout);

	switch(dwWait)
	{
		case WAIT_OBJECT_0 :
		{	
			return true;
		}
		case WAIT_TIMEOUT:
		default:
		{
			break;
		}
	}
	
	TrERROR(Tgs, "An unexpected error has occurred whilst waiting for the CTriggerMonitorPool thread to initilise. The wait return code was (%d)", dwWait);
	return false;
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
bool CThread::IsRunning()
{
	return(m_bKeepRunning);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
unsigned __stdcall CThread::ThreadProc(void * pThis)
{
	CThread * pThisThread = (CThread*)pThis;

	pThisThread->Execute();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\monitor.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CTriggerMonitor_INCLUDED 
#define CTriggerMonitor_INCLUDED

class CTriggerMonitorPool;

// Include the triggers shared definitions
#include "stddefs.hpp"

// Include the definitions for the CThread object
#include "cthread.hpp"

// Definitions for the TriggerMonitor pool
#include "monitorp.hpp"

// Definitions for the global queue-lock manager. 
#include "cqmanger.hpp"

// Definition of the admin message structure
#include "adminmsg.hpp"

// Define the error HRESULT that is returned in the overlapped structure when an 
// asynchronous recieve is terminated because the thread that issued the receive 
// call has terminated. 
#define IO_OPERATION_CANCELLED 0xC0000120


// Define the completion port key that we will give to the MSMQTriggerSEt object
#define TRIGGERSET_NOTIFCATION_KEY 0xFEFEFEFE

// Define the completion port key used to wake up monitor threads
#define TRIGGER_MONITOR_WAKE_UP_KEY  0xAAAAAAAA

// Define the timeout period we will wait for when waiting for the 
// TriggerMonitor thread to terminate after Stop() has been called.
#define TRIGGER_MONITOR_STOP_TIMEOUT  10000    // 10 seconds.


class CTriggerMonitor : public CReference, public CThread
{
	friend class CTriggerMonitorPool;

	private:

		HANDLE * m_phIOCompletionPort;

		// The tick when this thread last completed serving a request 
		DWORD m_dwLastRequestTickCount;

		// Reference to the CTriggerMonitorPool instance
		R<CTriggerMonitorPool> m_pMonitorPool;

		// Reference to Queue lock manager - handles thread synchronisatio to queue when required.
		R<CQueueManager> m_pQueueManager;

		// These methods are used to perform before & after wait state processing.
		void MonitorEnteringWaitState(bool bRoutineWakeup);
		void MonitorExitingWaitState(bool bRoutineWakeup);

		// used to map an overlapped pointer to a queue object. 
		CQueue* GetQueueReference(OVERLAPPED * pOverLapped);
		
		// Used to process a message on any of the bound queues.
		void ProcessReceivedMsgEvent(CQueue * pQueue);

		// Invokes the IMSMQTriggerHandler interface for each rule in the trigger.
		HRESULT InvokeMSMQRuleHandlers(
					CMsgProperties * pMessage,
					CRuntimeTriggerInfo * pTriggerInfo,
					CQueue* pQueue
					);

		// Processes messages received from the administration (notifications) queue.
		HRESULT ProcessMessageFromAdminQueue(const CMsgProperties* pMessage);
		
		void
		ProcessTrigger(
			CQueue* pQueue,
			CRuntimeTriggerInfo* pTriggerInfo,
			const CMsgProperties* pMessage
			);

		void
		ProcessAdminMessage(
			CQueue* pQueue,
			const CMsgProperties* pMessage
			);


	public:

		CTriggerMonitor(
			CTriggerMonitorPool * pMonitorPool, 
			IMSMQTriggersConfig * pITriggersConfig,
			HANDLE * phIOCompletionPort,
			CQueueManager * pQueueManger
			);

		
	private:
        HRESULT InvokeRegularRuleHandlers(
                    IMSMQPropertyBagPtr& pIPropertyBag,
					CRuntimeTriggerInfo * pTriggerInfo,
					CQueue* pQueue
					);
        HRESULT InvokeTransactionalRuleHandlers(
                    IMSMQPropertyBagPtr& pIPropertyBag,
					CRuntimeTriggerInfo * pTriggerInfo
					);


		~CTriggerMonitor();

		// Thread control over-rides of the base class CThread
		bool Init();
		bool Run();
		bool Exit();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\monitorp.cpp ===
//*******************************************************************
//
// Class Name  : CTriggerMonitorPool
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is the container for the set of worker 
//               threads that perform the trigger monitoring and 
//               processing. The key features of this class are 
//
//               (1) It provides aggregate startup and shutdown 
//                   functions for the worker thread group as a whole,
//
//               (2) It provides thread pool maintenance and recovery,
//
//               (3) It intitializes and maintains the cache of 
//                   trigger information,
//
//               (4) It performs the synchronization of the trigger 
//                   data cache as required.
//
//                There will be only one instance of this class in the 
//                entire MSMQ trigger service. 
//
//                This class is derived from the base class CThread, and
//                has it's own thread. This thread is used as an 
//                adminstrative thread only,it does perform trigger rule
//                processing.
//
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "Ev.h"
#include "stdfuncs.hpp"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "ruleinfo.hpp"
#include "monitorp.hpp"
#include "mqsymbls.h"
#include <mqtg.h>
#include "Tgp.h"

#include "monitorp.tmh"

using namespace std;

//*******************************************************************
//
// Method      : Constructor 
//
// Description : Initializes a new instance of CTriggerMonitorPool class.
//
//*******************************************************************
CTriggerMonitorPool::CTriggerMonitorPool(
	IMSMQTriggersConfigPtr  pITriggersConfig,
	LPCTSTR pwzServiceName
	) : 
    CThread(8000,CREATE_SUSPENDED,_T("CTriggerMonitorPool"),pITriggersConfig),
	m_hAdminEvent(CreateEvent(NULL,FALSE,FALSE,NULL))
{
	if (m_hAdminEvent == NULL) 
	{
		TrERROR(Tgs, "Failed to create an event. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

	// Initialise member vars
	m_bInitialisedOK = false;
	m_lNumberOfWaitingMonitors = 0;

	GetTimeAsBSTR(m_bstrStartTime);
	GetTimeAsBSTR(m_bstrLastSyncTime);	

	_tcscpy( m_wzRegPath, REGKEY_TRIGGER_PARAMETERS );
	//
	// Service is running on cluster virtual server
	//
	if ( _wcsicmp(pwzServiceName, xDefaultTriggersServiceName) != 0 )
	{
		_tcscat( m_wzRegPath, REG_SUBKEY_CLUSTERED );
		_tcscat( m_wzRegPath, pwzServiceName );
	}

	//
	// Create an instance of the MSMQTriggerSet component
	//
	HRESULT hr = m_pMSMQTriggerSet.CreateInstance(__uuidof(MSMQTriggerSet));
	if FAILED(hr)
	{	
		TrERROR(Tgs, "Failed to create MSMQTriggerSet component. Error =0x%x", hr);	
		throw bad_hresult(hr);
	}

	BSTR bstrTriggerStoreMahcine = NULL;
	m_pITriggersConfig->get_TriggerStoreMachineName(&bstrTriggerStoreMahcine);

	m_pMSMQTriggerSet->Init(bstrTriggerStoreMahcine);
	SysFreeString(bstrTriggerStoreMahcine);
}


//*******************************************************************
//
// Method      : CTriggerMonitorPool
//
// Description : Destroys an instance of the CTriggerMonitorPool. This 
//               involves deleting any messages remaining in the admin
//               message list, as well as closing some event handles.
//
//*******************************************************************
CTriggerMonitorPool::~CTriggerMonitorPool()
{
	//
	// Clear out any unprocessed messages from the Admin message list.
	// Acquire a writer lock to the list of Admin messsages
	//
	CS cs(m_AdminMsgListLock);

	for(ADMIN_MESSAGES_LIST::iterator it = m_lstAdminMessages.begin(); it != m_lstAdminMessages.end(); )
	{
		P<CAdminMessage> pAdminMessage = *it;
		it = m_lstAdminMessages.erase(it);
	}
}

//*******************************************************************
//
// Method      : Init
//
// Description : This is an over-ride from the CThread base class. This
//               method is called before the thread enters it's main 
//               processing loop (the Run() method). Key initialization 
//               steps are :
//
//               (1) Create an instance of the queue manager,
//
//               (2) Retrieve the trigger data from the database using 
//                   the COM component MSMQTriggerSet,
//
//               (3) Attach this trigger information to the appropriate 
//                   queues.
//
//*******************************************************************
bool CTriggerMonitorPool::Init( )
{
	HRESULT hr = S_OK;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());
	ASSERT(m_bInitialisedOK == false);

	// Write a trace message
	TrTRACE(Tgs, "Trigger monitor pool initialization has been called.");

	// we want the admin thread to have slightly higher priority than worker threads.
	SetThreadPriority(this->m_hThreadHandle,THREAD_PRIORITY_ABOVE_NORMAL);

	// Initialise this thread for COM - note that we support Apartment threading.
	hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	
	if (FAILED(hr))
	{
		TrTRACE(Tgs, "Failed to initializes the COM library. Error 0x%x", GetLastError());
		throw bad_hresult(hr);
	}

	//
	// Create an instance of the queue manager to be shared by all threads in the pool
	//
	m_pQueueManager = new CQueueManager(m_pITriggersConfig);

	//
	// Create the IO completion port that will be used to receive async queue events.
	//
	CreateIOCompletionPort(); 

	//
	// Build the runtime triggger and rule info
	//
	RUNTIME_TRIGGERINFO_LIST lstTriggerInfo;		
	GetTriggerData(lstTriggerInfo);

	AttachTriggersToQueues(lstTriggerInfo);

	// Reset the NT event that prevents the monitor threads from processing messages	
	if (ResetEvent(g_hServicePaused) == FALSE)
	{
		TrERROR(Tgs, "Failed to reset an event. Unable to continue. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

    DWORD initThreadNum = numeric_cast<DWORD>(m_pITriggersConfig->GetInitialThreads()); 
    if (m_pITriggersConfig->GetInitialThreads() > m_pITriggersConfig->GetMaxThreads())
    {
        initThreadNum = numeric_cast<DWORD>(m_pITriggersConfig->GetMaxThreads());            
    }

	// Create the initial pool of trigger monitors			
	for (DWORD ulCounter = 0; ulCounter < initThreadNum; ulCounter++)			
	{
		hr = CreateTriggerMonitor();
		if(FAILED(hr))
		{		
			TrERROR(Tgs, "Failed to create trigger monitor thread. Unable to continue. Error 0x%x", hr);
			break;
		}
	}

	if (m_lstTriggerMonitors.size() < 1)
	{
		TrERROR(Tgs, "The Trigger Monitor thread pool has completed initialisation and there are no trigger monitor threads to service queue events. Unable to continue.");
		throw bad_alloc();
	}

	//
	// Set the NT event that allows the monitor threads to start processing.
	//
	if (SetEvent(g_hServicePaused) == FALSE)
	{
		TrERROR(Tgs, "Failed to set an event. Unable to continue. Error %d", GetLastError());
		throw bad_alloc();
	}

	m_bInitialisedOK = true;
	return true;
}

//*******************************************************************
//
// Method      : CreateTriggerMonitor
//
// Description : Create a new CTriggerMonitor object (trigger worker
//               thread, and add this to the list of trigger monitors.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::CreateTriggerMonitor()
{
	//
	// First we need to determine how many running trigger monitors there are
	//
	DWORD dwRunningMonitors = GetNumberOfRunningTriggerMonitors();

	//
	// First we must check if we are allowed to create an additional thread.
	//
	if (dwRunningMonitors >= (DWORD)m_pITriggersConfig->GetMaxThreads())
	{
		return E_FAIL;
	}

	//
	// Create a new monitor (monitors are created 'suspended')
	//
	R<CTriggerMonitor> pNewMonitor = new CTriggerMonitor(
													this,
													m_pITriggersConfig.GetInterfacePtr(),
													&m_hIOCompletionPort,
													m_pQueueManager.get() 
													);
	
	//
	// Add it to the list of monitor pointers.
	//
	m_lstTriggerMonitors.push_back(pNewMonitor);

	//
	// Let this monitor (thread) go.
	//
	pNewMonitor->Resume();


	TrTRACE(Tgs, "New trigger monitor was created and added to the pool.");
	return S_OK;
}

//*******************************************************************
//
// Method      : ShutdownThreadPool
//
// Description : Called by the owner of this thread pool instance, this
//               method initiates and orderly shutdown of all worker 
//               threads in the pool. This is done by setting a 'function
//               code' and signalling an event that will wake up the 
//               threadpool's administrative thread. This method does 
//               returns when either the thread pool has been shut-down,
//               or the timeout period has expired.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::ShutdownThreadPool()
{
	DWORD dwWait = WAIT_OBJECT_0;

	// The TriggerMonitor thread should not be calling this method - check this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());
	
	{

		CS cs(m_csAdminTask);

		// Set a token indicating what we want the trigger monitor admin thread to do.
		m_lAdminTask = ADMIN_THREAD_STOP;

		// Wake up the trigger monitor admin thread
		BOOL fRet = SetEvent(m_hAdminEvent);
		if(fRet == FALSE)
		{
			TrERROR(Tgs, "Set admin event failed, Error = %d", GetLastError());
			return E_FAIL;
		}
	}
	//Note: ~cs() must be called before the wait operation

	// Wait for the shutdown to complete, timeout here is infinite since
	// the administrator thread wait for all threads with timeout
	// and should end in a timely manner
	dwWait = WaitForSingleObject(m_hThreadHandle, INFINITE);
	if(dwWait == WAIT_FAILED)
	{
		TrERROR(Tgs, "WaitForSingleObject failed for the CTriggerMonitorPool to shutdown. Error= %d", dwWait);
		return E_FAIL;
	}
		
	return S_OK;
}

//*******************************************************************
//
// Method      : Run()
//
// Description : This is an over-ride from the CThread base class. This
//               is the main processing loop for this thread. The thread
//               owned by this class is used to :
//
//               (1) handle synchronization between the in-memory data 
//                   cache of trigger information and the trigger DB,
//
//               (2) Perform periodic processing, such as composing and 
//                   issuing status info.
//
//               The CTriggerMonitorPool thread blocks on an NT event 
//               created during the initialization until either :
//              
//               (1) the admin event is signalled - in which case the 
//                   admin function code can be tested to determine 
//                   what sort of admin processing we need to do, or 
//
//               (2) the timeout expires - in which case the thread 
//                   performs whatever periodic processing we have 
//                   defined for it.     
//
//*******************************************************************
bool CTriggerMonitorPool::Run()
{
	bool bOK = true;
	HRESULT hr = S_OK;
	DWORD dwWait = WAIT_OBJECT_0;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	while (IsRunning())
	{
		// Block on the admin event object
		dwWait = WaitForSingleObject(m_hAdminEvent,ADMIN_THREAD_WAKEUP_PERIOD);

		switch(dwWait)
		{
			case WAIT_OBJECT_0:
			{
				long lAdminTask = GetAdminTask();//resets admin task as well

				if(lAdminTask == ADMIN_THREAD_PROCESS_NOTIFICATIONS)
				{
					// The thread was woken up to process notifications.
					hr = ProcessAdminMessages();
				}
				else if(lAdminTask == ADMIN_THREAD_STOP)
				{
					// The thread was woken up because it has been asked to stop.
					this->Stop();
				}
				break;
			}
			case WAIT_TIMEOUT:
			{
				// The Admin thread exited the wait because the wake-up time period 
				// has expired. Use this opportunity to perform periodic processing.
				hr = PerformPeriodicProcessing();

				break;
			}
			default:
			{
				ASSERT(false); // This should never happen.
				break;
			}
		}	
	}

	return(bOK);
}

long CTriggerMonitorPool::GetAdminTask()
{
	CS cs(m_csAdminTask);

	long lOldTask = m_lAdminTask;
	// Reset the admin task indicator back to idle
	m_lAdminTask = ADMIN_THREAD_IDLE;

	return lOldTask;
}


//*******************************************************************
//
// Method      : Exit()
//
// Description : This is an over-ride from the CThread base class. This
//               method is called when the thread has exited it's main 
//               processing loop (Run). This key cleanup performed by
//               this method is the purging of the TriggerMonitor thread
//               instances.
//
//*******************************************************************
bool CTriggerMonitorPool::Exit()
{
	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// First we need to make sure that the monitor threads are not block on the service
	// pause / resume event object. Here we will reset the event allowing monitors threads
	// to clean up.
	SetEvent(g_hServicePaused);

	// Reset our list iterator to the beggining.
	for(TRIGGER_MONITOR_LIST::iterator it = m_lstTriggerMonitors.begin(); it != m_lstTriggerMonitors.end(); ++it)
	{
		(*it)->Stop();
	}

	// This will wake up all monitors and give them a chance to notice that a stop request
	// has been made. Each monitor will then start shutdown tasks.
	PostMessageToAllMonitors(TRIGGER_MONITOR_WAKE_UP_KEY);

	// Reset our list iterator to the beggining.
	for(TRIGGER_MONITOR_LIST::iterator it = m_lstTriggerMonitors.begin(); it != m_lstTriggerMonitors.end(); ++it)
	{
		// Wait on the thread-handle of this TriggerMonitor.
		DWORD dwWait = WaitForSingleObject((*it)->m_hThreadHandle, TRIGGER_MONITOR_STOP_TIMEOUT);

		// This Trigger monitor won't go quietly - we've got to kill it.
		if (dwWait != WAIT_OBJECT_0)
		{
			// Write an error message to the log.
			TrERROR(Tgs, "Failed to stop a trigger monitor within the timeout period %d.", TRIGGER_MONITOR_STOP_TIMEOUT);
		
			//
			// Increment the reference count on unstoped thread. So it doesn't free later on when we don't expect
			// 
			SafeAddRef(it->get());
		}

	}

	return(true);
}

//*******************************************************************
//
// Method      : CreateIOCompletionPort
//
// Description : This method creates the NT IO completion port that 
//               will be used to recieve messsages asynchronously.
//
//*******************************************************************
void CTriggerMonitorPool::CreateIOCompletionPort()
{
	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	m_hIOCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);

	// Attempt to open the queue that this Monitor watches.
	if (m_hIOCompletionPort == NULL)
	{
		DWORD rc = GetLastError();

		TrERROR(Tgs, "Create complition port failed. Error =%d", rc);
		throw bad_win32_error(rc);
	}

	TrTRACE(Tgs, "Successfully created IO Completion port: %p.", m_hIOCompletionPort);		
}

//get a copy of the current admin message list and reset it
void CTriggerMonitorPool::GetAdminMessageListCopy(ADMIN_MESSAGES_LIST* pAdminList)
{
	ASSERT(pAdminList != NULL);

	ADMIN_MESSAGES_LIST::iterator iAdminMsgRef;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// Acquire a writer lock to the list of Admin messsages (Note that this will block
	// any TriggerMonitor threads attempting to hand-over an admin message).
	CS csAdminMsgList(m_AdminMsgListLock);

	iAdminMsgRef = m_lstAdminMessages.begin();

	while ((iAdminMsgRef != m_lstAdminMessages.end()) && (!m_lstAdminMessages.empty()))
	{
		// Cast the admin message reference to message properties object
		CAdminMessage* pAdminMessage = (CAdminMessage*)(*iAdminMsgRef);

		// we should never have nulls in this list. 
		ASSERT(pAdminMessage != NULL);
		
		pAdminList->push_back(pAdminMessage);
				
		// remove this item from the list and process the next one.
		iAdminMsgRef = m_lstAdminMessages.erase(iAdminMsgRef);
	}
}


//*******************************************************************
//
// Method      : ProcessAdminMessages
//
// Description : Process the messages currently stored in the member 
//               var list of CAdminMessage instances. This list 
//               represents a group of admin requests that need to be 
//               processed by the CTriggerMonitorPool thread.
//            
//               In this implementation of Triggers, we rebuild all the 
//               trigger data whenever a notification message arrives. 
//               Future implementation may anlayze the individual notification
//               messages and change only the trigger info structure that
//               have changed in the underlying data store. For now, we will 
//               clear the contents of the Admin message list - and 
//               rebuild the trigger info once.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::ProcessAdminMessages()
{
	HRESULT hr = S_OK;
	CAdminMessage * pAdminMessage = NULL;
	ADMIN_MESSAGES_LIST AdminList;
	ADMIN_MESSAGES_LIST::iterator iAdminMsgRef;
	RUNTIME_TRIGGERINFO_LIST lstTriggerInfo;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	GetAdminMessageListCopy(&AdminList);

	// Record the synchronization time (used in status reporting)
	GetTimeAsBSTR(m_bstrLastSyncTime);

	iAdminMsgRef = AdminList.begin();

	try
	{
		while ((iAdminMsgRef != AdminList.end()) && (!AdminList.empty()))
		{
			// Cast the admin message reference to message properties object
			pAdminMessage = (CAdminMessage*)(*iAdminMsgRef);

			// we should never have nulls in this list. 
			ASSERT(pAdminMessage != NULL);

			switch (pAdminMessage->GetMessageType())
			{
				case CAdminMessage::eMsgTypes::eNewThreadRequest:
				{
					// attempt to create a new trigger monitor (thread)
					hr = this->CreateTriggerMonitor();
					break;  
				} 
				//
				// note we treat any sort of change in the underlying trigger data in the
				// same way - we reload the completed trigger data cache.
				//
				case CAdminMessage::eMsgTypes::eTriggerAdded:
				case CAdminMessage::eMsgTypes::eTriggerDeleted:
				case CAdminMessage::eMsgTypes::eTriggerUpdated:
				case CAdminMessage::eMsgTypes::eRuleAdded:
				case CAdminMessage::eMsgTypes::eRuleUpdated:
				case CAdminMessage::eMsgTypes::eRuleDeleted:
				{
					// Get the new trigger info
					GetTriggerData(lstTriggerInfo);

					// If successfull, attach the fresh trigger information to the queue objects. 
					AttachTriggersToQueues(lstTriggerInfo);
					break;
				}

				//
				// unrecognized message type - this should never happen.
				//
				default:
					ASSERT(("unrecognized message type", 0));
					break;
			}

			delete pAdminMessage;
			
			// remove this item from the list and process the next one.
			iAdminMsgRef = AdminList.erase(iAdminMsgRef);
		}

		return S_OK;
	}
	catch(const _com_error& e)
	{
		hr = e.Error();
	}
	catch(const bad_alloc&)
	{
		hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	TrERROR(Tgs, "Failed to process admin message. Error=0x%x", hr);
	return(hr);
}



void 
CTriggerMonitorPool::GetAttachedRuleData(
	const BSTR& bsTriggerID,
	long ruleNo,
	RUNTIME_RULEINFO_LIST& ruleList
	)
{
	ASSERT(ruleNo > 0);

	for(long i = 0; i < ruleNo; i++)
	{
		BSTR bsRuleID = NULL;
		BSTR bsRuleName = NULL;
		BSTR bsRuleDescription = NULL;
		BSTR bsRuleCondition = NULL;
		BSTR bsRuleAction = NULL;
		BSTR bsRuleImplementationProgID = NULL;
		long lShowWindow = 0;

		m_pMSMQTriggerSet->GetRuleDetailsByTriggerID(
											bsTriggerID,
											i,
											&bsRuleID,
											&bsRuleName,
											&bsRuleDescription,													
											&bsRuleCondition,
											&bsRuleAction,
											&bsRuleImplementationProgID,
											&lShowWindow
											); 

		//
		// Allocate a new trigger structure 
		//
		P<CRuntimeRuleInfo> pRuleInfo = new CRuntimeRuleInfo(
														bsRuleID,
														bsRuleName,
														bsRuleDescription,
														bsRuleCondition,
														bsRuleAction,
														bsRuleImplementationProgID,
														m_wzRegPath,
														(lShowWindow != 0) );

		// Attach this rule to the current trigger info structure (at the end);
		ruleList.push_back(pRuleInfo);
		pRuleInfo.detach();
	
		SysFreeString(bsRuleID);
		SysFreeString(bsRuleName);
		SysFreeString(bsRuleCondition);
		SysFreeString(bsRuleAction);
		SysFreeString(bsRuleImplementationProgID);
		SysFreeString(bsRuleDescription);			
	}
}


static bool s_fReportTriggerFailure = false;
static set< _bstr_t > s_reported;

CRuntimeTriggerInfo*
CTriggerMonitorPool::GetTriggerRuntimeInfo(
	long triggerIndex
	)
{
	ASSERT(("Invalid trigger index",  triggerIndex >= 0));

	long lNumRules = 0;
	long lEnabled = 0;
	long lSerialized = 0;
	MsgProcessingType msgProctype = PEEK_MESSAGE;
	BSTR bsTriggerID = NULL;
	BSTR bsTriggerName = NULL;
	BSTR bsQueueName = NULL;
	SystemQueueIdentifier SystemQueue = SYSTEM_QUEUE_NONE;

	//
	// Get this trigger's details 
	//
	m_pMSMQTriggerSet->GetTriggerDetailsByIndex(
								triggerIndex,
								&bsTriggerID,
								&bsTriggerName,
								&bsQueueName, 
								&SystemQueue, 
								&lNumRules,
								&lEnabled, 
								&lSerialized,
								&msgProctype);
	
	try
	{
		P<CRuntimeTriggerInfo> pTriggerInfo = NULL;
		//
		// We only bother with enabled triggers that have rules.
		//
		if ((lNumRules > 0) && (lEnabled != 0))
		{
			//
			// Allocate a new trigger info structure 
			//
			pTriggerInfo = new CRuntimeTriggerInfo(
											bsTriggerID,
											bsTriggerName,
											bsQueueName,
											m_wzRegPath,
											SystemQueue,
											(lEnabled != 0),
											(lSerialized != 0),
											msgProctype
											);


			GetAttachedRuleData(bsTriggerID, lNumRules, pTriggerInfo->m_lstRules);
		}

		//
		// Free the BSTR's !
		//
		SysFreeString(bsTriggerID);
		SysFreeString(bsTriggerName);
		SysFreeString(bsQueueName);

		return pTriggerInfo.detach();
	}
	catch(const _com_error&)
	{
	}
	catch(const exception&)
	{
	}

	TrERROR(Tgs, "Failed to retreive attched rule information for trigger %ls.", (LPCWSTR)bsTriggerID);
	
	//
	// Look if we already report about this problem. If no produce event log message
	//
	if (s_reported.insert(bsTriggerID).second)
	{
		EvReport(
			MSMQ_TRIGGER_FAIL_RETREIVE_ATTACHED_RULE_INFORMATION,
			2, 
			static_cast<LPCWSTR>(bsTriggerID),
			static_cast<LPCWSTR>(bsTriggerName)
			);
	}

	SysFreeString(bsTriggerID);
	SysFreeString(bsTriggerName);
	SysFreeString(bsQueueName);
	return NULL;
}


CRuntimeTriggerInfo*
CTriggerMonitorPool::CreateNotificationTrigger(
	void
	)
{
	_bstr_t bstrNotificationsTriggerName = _T("MSMQ Trigger Notifications");

	// Use the MSMQ Triggers Configuration component to retrieve the name of the notifications queue.
	BSTR bstrNotificationsQueueName = NULL;
	m_pITriggersConfig->get_NotificationsQueueName(&bstrNotificationsQueueName);		

	// Allocate a new trigger info structure - NOTE that we treat this as a serialized trigger.
	// This trigger is marked as "Admin Trigger" - special message handling
	P<CRuntimeTriggerInfo> pTriggerInfo = new CRuntimeTriggerInfo(
																_T(""),
																bstrNotificationsTriggerName,
																bstrNotificationsQueueName,
																m_wzRegPath,
																SYSTEM_QUEUE_NONE,
																true,
																true,
																PEEK_MESSAGE);
	
	pTriggerInfo->SetAdminTrigger();

	// Free the BSTR above
	SysFreeString(bstrNotificationsQueueName);

	return pTriggerInfo.detach();
}

//*******************************************************************
//
// Method      : GetTriggerData
//
// Description : This method uses the COM object MSMQTriggerSet to 
//               collect the trigger information from the database 
//               and build an in memory cache of trigger-info structures.
//               Note that this method places the instances of the 
//               trigger info structures into a temporary list - each 
//               trigger info structure will eventually be removed from 
//               this temporary list and attached to the appropriate 
//               queue object.
//
//*******************************************************************
void 
CTriggerMonitorPool::GetTriggerData(
	RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
	)
{
	//
	// Only the TriggerMonitor thread should be executing this method - assert this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// The trigger list should be empty at this point - if it is not, something is seriously wrong.
	//
	ASSERT(lstTriggerInfo.size() == 0);

	try
	{
		//
		// Build the trigger map and determine how many triggers there are.
		//
		m_pMSMQTriggerSet->Refresh();
		
		long lNumTriggers;
		m_pMSMQTriggerSet->get_Count(&lNumTriggers);
		ASSERT(lNumTriggers >= 0);

		//
		// We need to perform 'per trigger' initailization - as each thread can service any defined trigger
		//
		for(long lTriggerCtr = 0; lTriggerCtr < lNumTriggers; lTriggerCtr++)
		{
			//
			// Retreive trigger inforamtion and the attached rules
			//
			P<CRuntimeTriggerInfo> pTriggerInfo = GetTriggerRuntimeInfo(lTriggerCtr);
			
			if (pTriggerInfo.get() != NULL)
			{
				//
				// Add this to our list of run-time trigger info objects
				//
				lstTriggerInfo.push_back(pTriggerInfo);
				pTriggerInfo.detach();
			}
		}

		//
		// Now we want to add one final trigger for the MSMQ Trigger Notifications queue. This 
		// trigger is a different from normal triggers in that it does not have a rule defined. 
		// By using a private constructor - the TriggerInfo object is marked as a special 'Admin'
		// trigger - and we can test for this on message arrival.
		//
		P<CRuntimeTriggerInfo> pTriggerInfo = CreateNotificationTrigger();

		//
		// Add this to our list of run-time trigger info objects
		//
		lstTriggerInfo.push_back(pTriggerInfo);
		pTriggerInfo.detach();
		TrTRACE(Tgs, "Successfully loaded all the trigger(s) into the Active Trigger Map.");
	}
	catch(const _com_error& e)
	{
		TrERROR(Tgs, "Failed to retrieve trigger information. Error=0x%x", e.Error());

		if (!s_fReportTriggerFailure)
		{
			EvReport(MSMQ_TRIGGER_FAIL_RETREIVE_TRIGGER_INFORMATION);
			s_fReportTriggerFailure	= true;
		}

		throw;
	}

}

//*******************************************************************
//
// Method      : AttachTriggersToQueues
//
// Description : Works through the list of triggers and attaches each
//               one to the apprropriate Queue object. References to 
//               the Queue objects is obtained via the AddQueue() call
//               to the Queue Manager which will either add a new queue
//               or return a reference to an existing queue instance.
//               Once all triggers have been attached, we iterate through
//               the queue list again, removing queues that no longer 
//               have any triggers attached.
//
//*******************************************************************
void CTriggerMonitorPool::AttachTriggersToQueues(RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo)
{
	long lNumTriggersAttached = 0;
	
	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// Acquire exclusive lock on queue manager to insure that no one try to access the 
	// trigger info while refreshing it. We use a global read-write lock on queue manager
	// since the trigger object doesn't contains reference counting.
	//
	CSW rw(m_pQueueManager->m_rwlSyncTriggerInfoChange);

	//
	// Firstly we want to iterate through all the current queues instances, and expire 
	// whatever trigger info instances they have attached to them.
	//
	m_pQueueManager->ExpireAllTriggers();

	// Now we iterate through the temporary list of trigger info, attaching each trigger
	// info object to the appropriate queue object. 
	for(RUNTIME_TRIGGERINFO_LIST::iterator it = lstTriggerInfo.begin();
	    it != lstTriggerInfo.end();
		)
	{
		//
		// Get a reference to our first trigger info structure				
		//
		CRuntimeTriggerInfo * pTriggerInfo = *it;
		bool fOpenForReceive = 	(pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE) || 
			                    (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE_XACT) ||
								pTriggerInfo->IsAdminTrigger();

		// Attempt to add this queue - note that if one already exists we will get a reference to the existing queue.
		R<CQueue> pQueue = m_pQueueManager->AddQueue(
												pTriggerInfo->m_bstrQueueName,
												pTriggerInfo->m_bstrTriggerName,
												fOpenForReceive,
												&m_hIOCompletionPort
												);
					
		//if (pQueue.IsValid())
		if(pQueue.get() != NULL)
		{
			// Attach this trigger to the queue.
			pQueue->AttachTrigger(pTriggerInfo);

			// save the queue format name with this trigger
			pTriggerInfo->m_bstrQueueFormatName = pQueue->m_bstrFormatName;

			// Increment the count of how many triggers we have attached. 
			lNumTriggersAttached++;
		}
		else
		{
			// Write an error message to the log (note we cannot use the pQueue object in this message as it may be invalid)
			TrERROR(Tgs, "Failed to attach trigger %ls to queue %ls.", (LPCWSTR)pTriggerInfo->m_bstrTriggerID, (LPCWSTR)pTriggerInfo->m_bstrQueueName);
		}

		// Remove this trigger from the trigger monitor list as it is now attached to a queue,
		// the returned iterator will point to the next item in the list.
		it = lstTriggerInfo.erase(it);
		
	}
	ASSERT(lstTriggerInfo.size() == 0);

	//
	// Now we can walk through the queue list and remove the queues no longer have 
	// any trigger attached.
	//
	m_pQueueManager->RemoveUntriggeredQueues();

	TrTRACE(Tgs, "Successfully attached all trigger(s) to queue(s).");
}

//*******************************************************************
//
// Method      : PerformPeriodicProcessing
//
// Description : This method is called periodically to peform routine
//               administration & monitoring tasks. This includes :
//
//               (1) determining if the thread pool need to be scaled
//                   down - and removing CTriggerMonitor thread instances
//                   if this is the case,
//
//               (2) removing any dead monitor threads from the thread 
//                   pool,
//
//*******************************************************************
HRESULT CTriggerMonitorPool::PerformPeriodicProcessing()
{
	TrTRACE(Tgs, "Trigger monitor pool perform periodic processing");

	HRESULT hr = S_OK;
	DWORD dwWait = WAIT_OBJECT_0;
	long lRunningMonitors = 0;
	long lRequiredMonitors = 0; 
	long lExpiredMonitors = 0;
	TRIGGER_MONITOR_LIST::iterator iMonitorRef;
	

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// Calculate how many monitor threads we have in excess of the initial (normal) state.
	lRequiredMonitors = m_pITriggersConfig->GetInitialThreads();

	// If we have excess monitors, then we will walk through the list looking for any monitors
	// that have been idle for a period of time. Keep a count of idle, excess monitors.
	iMonitorRef = m_lstTriggerMonitors.begin();

	while ((iMonitorRef != m_lstTriggerMonitors.end()) && (!m_lstTriggerMonitors.empty()) )
	{
		// Cast the reference to a monitor type
		
		R<CTriggerMonitor> pTriggerMonitor = (*iMonitorRef);

		if (pTriggerMonitor->IsRunning()) 
		{
			// Increment the count of running monitors
			lRunningMonitors++;			

			// If at this point we have more running monitors than we require, examine the each monitor
			// to determine if it has been idle for a period of time that allows us to expire it.
			if ((lRunningMonitors > lRequiredMonitors) && (pTriggerMonitor->m_dwLastRequestTickCount < (GetTickCount() - MONITOR_MAX_IDLE_TIME)))
			{
				// trace message to indicate that we are asking a thread monitor to stop.
				TrTRACE(Tgs, "Requesting STOP on trigger monitor. Trhead no: %d.", pTriggerMonitor->GetThreadID());

				// Ask this trigger monitor to stop. The next time the monitor wakes up, it  will
				// detect that it has been asked to stop - and it will terminate itself.
				pTriggerMonitor->Stop();

				// Key a count of how many monitors we have tried to stop
				lExpiredMonitors++;
			}
		}

		// look at the next monitor in the list.
		++iMonitorRef;
	}

	// If we have less running threads than the stated config minimum, create some more.
	if (lRunningMonitors < lRequiredMonitors)
	{
		// Write a trace message here indicating that we are scaling up the thread pool. 
		TrTRACE(Tgs, "Need to add %d threads to the thread pool.", lRequiredMonitors - lRunningMonitors);
	}

	while (lRunningMonitors < lRequiredMonitors)
	{
		hr = CreateTriggerMonitor();

		if SUCCEEDED(hr)
		{
			lRunningMonitors++;
		}
		else
		{		
			TrERROR(Tgs, "Failed to create a new trigger monitor thread. Error=0x%x", hr);
		}
	}

	// Walk through the monitor list and remove dead monitors. Some may be dead due to the stop
	// requests issued above, but some may also be dead due to errors and exceptions.
	iMonitorRef = m_lstTriggerMonitors.begin();

	// Initialise trigger monitor reference.
	while ( (iMonitorRef != m_lstTriggerMonitors.end()) && (!m_lstTriggerMonitors.empty()) )
	{
		// Cast the reference to a monitor type
		R<CTriggerMonitor> pTriggerMonitor = (*iMonitorRef);

		// Wait on the thread-handle of this TriggerMonitor.
		dwWait = WaitForSingleObject(pTriggerMonitor->m_hThreadHandle,0);

		// If the wait completes successfully, then the thread has stopped executing, and 
		// we can delete it. If the wait times-out, then the monitor is still executing and
		// we will leave it alone. If the monitor is just taking a while to shutdown, then
		// we will pick it up next time we perform this periodic clean up of the monitor list.
		if (dwWait == WAIT_OBJECT_0) 
		{
			TrTRACE(Tgs, "Remove trigger monitor from the pool. Thread no: %d", pTriggerMonitor->GetThreadID());

			// remove this reference from the list of monitors
			iMonitorRef = m_lstTriggerMonitors.erase(iMonitorRef);

		}
		else
		{
			// look at the next monitor in the list.
			++iMonitorRef;
		}
	}

	// At this point we want to make sure that there is at least one active monitor in the pool.
	// If not, create a new monitor thread.
	if (m_lstTriggerMonitors.size() < 1)
	{
		hr = CreateTriggerMonitor();

		if FAILED(hr)
		{		
			TrERROR(Tgs, "Failed to create a new trigger monitor. Error=0x%x", hr);
			return hr;
		}
	}

	ASSERT(hr == S_OK);
	
	TrTRACE(Tgs, "Completed Sucessfully periodic processing. number of active trigger monitors is: %d.", (long)m_lstTriggerMonitors.size());
	return S_OK;
}

//*******************************************************************
//
// Method      : HandleAdminMessage
//
// Description : This method is called by threads in the thread pool
//               when they have recieved a message on the administration
//               queue. Monitor threads call this method to 'hand over' 
//               the administration message. This is done by adding the 
//               message to the list, setting a function code for the 
//               admin thread - and then waking it up to process these
//               messages.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::AcceptAdminMessage(CAdminMessage * pAdminMessage)
{
	HRESULT hr = S_OK;

	// The TriggerMonitor thread should not be executing this method - assert this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());

	// Ensure that we have been given a valid message structure
	ASSERT(pAdminMessage != NULL);

	CS cs(m_csAdminTask);
	
	if(m_lAdminTask == ADMIN_THREAD_STOP)
	{
		delete pAdminMessage;
		return MSMQ_TRIGGER_STOPPED;
	}

	{
		// Acquire a writer lock to the list of Admin messsages
		CS cs(m_AdminMsgListLock);

		// Add this copy to the list of messages to be processed.
		m_lstAdminMessages.insert(m_lstAdminMessages.end(),pAdminMessage);
	}
	
	// Set a token indicating what we want the admin thread to do.
	m_lAdminTask = ADMIN_THREAD_PROCESS_NOTIFICATIONS;

	// Wake up the admin thread
	SetEvent(m_hAdminEvent);

	return (hr);
}

//*******************************************************************
//
// Method      : PostMessageToAllMonitors
//
// Description : This method posts messages to the IO completion port 
//               that the worker threads are blocking on. It will post
//               one message for every thread in the pool. This message
//               type is determined by the supplied completion key.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::PostMessageToAllMonitors(DWORD dwCompletionKey)
{
	long lThreadCtr = 0;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// log a trace message
	TrTRACE(Tgs, "CTriggerMonitorPool is about to post the completion port key (%X) (%d) times to IO port (%p)",(DWORD)dwCompletionKey,(long)m_lstTriggerMonitors.size(),m_hIOCompletionPort);

	for(lThreadCtr=0; lThreadCtr < (long)m_lstTriggerMonitors.size(); lThreadCtr++)
	{
		if (PostQueuedCompletionStatus(m_hIOCompletionPort,0,dwCompletionKey,NULL) == FALSE)
		{
			TrTRACE(Tgs, "Failed when posting a messages to the IOCompletionPort. Error=%d.", GetLastError());
		}
	}

	// Surrender time slice of this thread to allow monitors to clean up and shut down. 
	Sleep(200);

	return(S_OK);
}

//*******************************************************************
//
// Method      : CountRunningTriggerMonitors
//
// Description : returns the number of currently live trigger monitors. Note that 
//               this is possibly different from the number of monitors in the list
//
//*******************************************************************
DWORD CTriggerMonitorPool::GetNumberOfRunningTriggerMonitors()
{
	DWORD dwRunningMonitors = 0;
	
	for(TRIGGER_MONITOR_LIST::iterator it = m_lstTriggerMonitors.begin(); it != m_lstTriggerMonitors.end(); ++it)
	{
		if ((*it)->IsRunning()) 
		{
			// Increment the count of running monitors
			dwRunningMonitors++;			
		}
	}

	return(dwRunningMonitors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\tginit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TgInit.cpp

Abstract:
    Trigger service initialization

Author:
    Uri Habusha (urih) 3-Aug-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "mq.h"
#include "Ev.h"
#include "mqsymbls.h"
#include "Svc.h"
#include "monitorp.hpp"
#include "queueutil.hpp"
#include "Tgp.h"

#include "tginit.tmh"


//*******************************************************************
//
// Method      : ValidateTriggerStore
//
// Description : 
//
//*******************************************************************
static
void 
ValidateTriggerStore(
	IMSMQTriggersConfigPtr pITriggersConfig
	)
{
	pITriggersConfig->GetInitialThreads();
	pITriggersConfig->GetMaxThreads();
	_bstr_t bstrTemp = pITriggersConfig->GetTriggerStoreMachineName();
}


void ValidateTriggerNotificationQueue(void)
/*++

Routine Description:
    The routine validates existing of notification queue. If the queue doesn't
	exist, the routine creates it.

Arguments:
    None

Returned Value:
    None

Note:
	If the queue can't opened for receive or it cannot be created, the 
	routine throw an exception

--*/
{
	_bstr_t bstrFormatName;
	_bstr_t bstrNotificationsQueue = L"." + gc_bstrNotificationsQueueName;
	QUEUEHANDLE hQ = NULL;

	HRESULT hr = OpenQueue(
					bstrNotificationsQueue, 
					MQ_RECEIVE_ACCESS,
					true,
					&hQ,
					&bstrFormatName
					);
	
	if(FAILED(hr))
	{
		TrERROR(Tgs, "Failed to open/create trigger notification queue. Error 0x%x", hr);
		
		WCHAR strError[256];
		swprintf(strError, L"0x%x", hr);

		EvReport(MSMQ_TRIGGER_OPEN_NOTIFICATION_QUEUE_FAILED, 2, static_cast<LPCWSTR>(bstrNotificationsQueue), strError);
		throw bad_hresult(hr);
	}

	MQCloseQueue(hQ);
}


CTriggerMonitorPool* 
TriggerInitialize(
    LPCTSTR pwzServiceName
    )
/*++

Routine Description:
    Initializes Trigger service

Arguments:
    None

Returned Value:
    pointer to trigger monitor pool.

--*/
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
    {
		TrERROR(Tgs, "Trigger start-up failed. CoInitialized Failed, error 0x%x", hr);
        throw bad_hresult(hr);
    }

    //
    //  Report a 'Pending' progress to SCM. 
    //
	SvcReportProgress(xMaxTimeToNextReport);

    //
	// Create the instance of the MSMQ Trigger COM component.
    //
	IMSMQTriggersConfigPtr pITriggersConfig;
	hr = pITriggersConfig.CreateInstance(__uuidof(MSMQTriggersConfig));
 	if FAILED(hr)
	{
		TrERROR(Tgs, "Trigger start-up failed. Can't create an instance of the MSMQ Trigger Configuration component, Error 0x%x", hr);					
        throw bad_hresult(hr);
	}

    //
	// If we have create the configuration COM component OK - we will now verify that 
	// the required registry definitions and queues are in place. Note that these calls
	// will result in the appropraite reg-keys & queues being created if they are absent,
    // the validation routine can throw _com_error. It will be catch in the caller
    //
	ValidateTriggerStore(pITriggersConfig);
	SvcReportProgress(xMaxTimeToNextReport);

	ValidateTriggerNotificationQueue();
	SvcReportProgress(xMaxTimeToNextReport);

	//
	// Triggers COM+ component registration.
	// This is done only once
	//
	RegisterComponentInComPlusIfNeeded();
	SvcReportProgress(xMaxTimeToNextReport);

    //
	// Attempt to allocate a new trigger monitor pool
    //
	R<CTriggerMonitorPool> pTriggerMonitorPool = new CTriggerMonitorPool(
														pITriggersConfig,
														pwzServiceName);

    //
	// Initialise and start the pool of trigger monitors
    //
	pTriggerMonitorPool->Resume();

    //
	// Block until initialization is complete
    //
    long timeOut =  pITriggersConfig->InitTimeout;
    SvcReportProgress(numeric_cast<DWORD>(timeOut));

	if (! pTriggerMonitorPool->WaitForInitToComplete(timeOut))
    {
        TrERROR(Tgs, "The MSMQTriggerService has failed to initialize the pool of trigger monitors. The service is being shutdown. No trigger processing will occur.");
        throw exception();
    }

	if (pTriggerMonitorPool->IsInitialized())
	{
		EvReport(MSMQ_TRIGGER_INITIALIZED);
	    return pTriggerMonitorPool.detach();
	}

	//
	// Initilization failed. Stop the service
	//
	throw exception();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\stdafx.h ===
#pragma once

#ifndef __MQTRIG_STDH__
#define __MQTRIG_STDH__

#include <libpch.h>
#include <mqexception.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>
#include <comdef.h>

#include "mqtrig.tlh"

#endif //__MQTRIG_STDH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\monitor.cpp ===
//*******************************************************************************
//
// Class Name  : CTriggerMonitor
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a worker thread that performs 
//               trigger monitoring and processing. Each instance of 
//               this class has it's own thread - and it derives from
//               the CThread class. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************************
#include "stdafx.h"
#include "Ev.h"
#include "monitor.hpp"
#include "mqsymbls.h"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "Tgp.h"
#include "mqtg.h"
#include "rwlock.h"

#include "monitor.tmh"

#import  "mqgentr.tlb" no_namespace

using namespace std;

static
void
ReportInvocationError(
	const _bstr_t& name,
	const _bstr_t& id, 
	HRESULT hr,
	DWORD eventId
	)
{
	WCHAR errorVal[128];
	swprintf(errorVal, L"0x%x", hr);

	EvReport(
		eventId, 
		3, 
		static_cast<LPCWSTR>(name), 
		static_cast<LPCWSTR>(id), 
		errorVal
		);
}


//********************************************************************************
//
// Method      : Constructor	
//
// Description : Initializes a new trigger monitor class instance,
//               and calls the constructor of the base class CThread.
//
//********************************************************************************
CTriggerMonitor::CTriggerMonitor(CTriggerMonitorPool * pMonitorPool, 
								 IMSMQTriggersConfig * pITriggersConfig,
								 HANDLE * phICompletionPort,
								 CQueueManager * pQueueManager) : CThread(8000,CREATE_SUSPENDED,_T("CTriggerMonitor"),pITriggersConfig)
{
	// Ensure that we have been given construction parameters
	ASSERT(pQueueManager != NULL);
	ASSERT(phICompletionPort != NULL);
	
	// Initialise member variables.
	m_phIOCompletionPort = phICompletionPort;

	// Store a reference to the Queue lock manager.
	pQueueManager->AddRef();
	m_pQueueManager = pQueueManager;

	// Store reference to the monitor pool object (parent)
	pMonitorPool->AddRef();
	m_pMonitorPool = pMonitorPool;

}

//********************************************************************************
//
// Method      : Destructor
//
// Description : Destorys an instance of this class.
//
//********************************************************************************
CTriggerMonitor::~CTriggerMonitor()
{
}

//********************************************************************************
//
// Method      : Init
//
// Description : This is an over-ride of the Init() method in the 
//               base class CThread. This method is called by the 
//               new thread prior to entering the normal-execution 
//               loop.
//
//********************************************************************************
bool CTriggerMonitor::Init()
{
	//
	// Only this TiggerMonitor thread should be executing the Init() method - check this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	TrTRACE(Tgs, "Initialize trigger monitor ");
	return (true);
}

//********************************************************************************
//
// Method      : Run
// 
// Description : This is an over-ride of the Init() method in the 
//               base class CThread. This method is called by the 
//               thread after calling Init(). This method contains the 
//               main processing loop of the worker thread. When the
//               thread exits this method - it will begin shutdown 
//               processing.
//
// TODO notes about CQueueReference 
//********************************************************************************
bool CTriggerMonitor::Run()
{
	HRESULT hr = S_OK;
	BOOL bGotPacket = FALSE;
	DWORD dwBytesTransferred = 0;
	ULONG_PTR dwCompletionKey = 0;
	bool bRoutineWakeUp = false;
	OVERLAPPED * pOverLapped = NULL;

	// Only this TiggerMonitor thread should be executing the Run() method - check this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// Write a trace message
	TrTRACE(Tgs, "Trigger monitor is runing");

	while (this->IsRunning() && SUCCEEDED(hr))
	{
		bGotPacket = FALSE;
		dwCompletionKey = 0;

		// Notfiy the parent trigger pool that this thread is now entering a wait state.
		MonitorEnteringWaitState(bRoutineWakeUp);

		// Wait on the IO Completion port for a message to process
		bGotPacket = GetQueuedCompletionStatus(
                            *m_phIOCompletionPort,
                            &dwBytesTransferred,
                            &dwCompletionKey,
                            &pOverLapped,
                            MONITOR_MAX_IDLE_TIME
                            );

		// This wait is used to pause and resume the trigger service. 
		DWORD dwState = WaitForSingleObject(g_hServicePaused,INFINITE);
		if(dwState == WAIT_FAILED)
		{
			TrTRACE(Tgs, "WaitForSingleObject failed.Error code was %d.", GetLastError());			
		}

		// Determine if this is a routine wake-up (due to either a time-out or a wake-up key being sent by the
		// trigger monitor. Set a flag accordingly.
		bRoutineWakeUp = ((dwCompletionKey == TRIGGER_MONITOR_WAKE_UP_KEY) || (pOverLapped == NULL));

		// Notfiy the parent trigger pool that this thread is now in use. 
		MonitorExitingWaitState(bRoutineWakeUp);

		//
		// Get the read/write lock for read, so no one will delete the trigger info
		// while we process the message
		//
		CSR rw(m_pQueueManager->m_rwlSyncTriggerInfoChange);

		if (bGotPacket == TRUE)
		{
			switch(dwCompletionKey)
			{
				case TRIGGER_MONITOR_WAKE_UP_KEY:
				{
					// we don't need to do anything here - this is simply a request
					// by the administrator to 'wake-up' and check state. If this thread
					// has been asked to stop, the IsRunning() controlling this loop will
					// return false and we will exit this method. 

					break;
				}
				default:
				{
					//
					// This reference indicates pending operation that ended
					// At start of every pending operation AddRef() for the queue
					// is performed. If the queue is valid, a real reference to
					// the queue is received, in all other cases pQueueRef will 
					// be NULL.
					//
					R<CQueue> pQueueRef = GetQueueReference(pOverLapped);

					if(pQueueRef->IsTriggerExist())
					{
						ProcessReceivedMsgEvent(pQueueRef.get());
					}
					break;
				}
			}			
		}
		else //failed I/O operation
		{
			if (pOverLapped != NULL)
			{
				switch (pOverLapped->Internal)
				{
					case MQ_ERROR_QUEUE_DELETED:
					{
						// The completion packet was for an outstanding request on a queue that has 
						// been deleted. We do not need to do anything here.
						TrTRACE(Tgs, "Failed to receive message on queue because the queue has been deleted. Error 0x%I64x", pOverLapped->Internal);


						// TODO - Remove queue from qmanager.

						break;
					}
					case MQ_ERROR_BUFFER_OVERFLOW:
					{
						// This indicates that the buffer used for receiving the message body was not
						// large enough. At this point we can attempt to re-peek the message after 
						// allocating a larger message body buffer. 
						
						//
						// This reference indicates pending operation that ended
						// At start of every pending operation AddRef() for the queue
						// is performed. If the queue is valid, a real reference to
						// the queue is received, in all other cases pQueueRef will 
						// be NULL.
						//
						R<CQueue> pQueueRef = GetQueueReference(pOverLapped);


						TrTRACE(Tgs, "Failed to receiv message on a queue due to buffer overflow. Allocate a bigger buffer and re-peek the message");

						if(pQueueRef->IsTriggerExist())
						{
							hr = pQueueRef->RePeekMessage();

							if SUCCEEDED(hr)
							{
								ProcessReceivedMsgEvent(pQueueRef.get());
							}
							else
							{
								TrERROR(Tgs, "Failed to peek a message from queue %s. Error 0x%x", pQueueRef->m_bstrQueueName, hr);
							}
						}
						break;
					}
					case IO_OPERATION_CANCELLED:
					{
						//
						// The io operation was cancelled, either the thread which initiated
						// the io operation has exited or the CQueue object was removed from the
						// m_pQueueManager
						//
						
						//
						// This reference indicates pending operation that ended
						// At start of every pending operation AddRef() for the queue
						// is performed. If the queue is valid, a real reference to
						// the queue is received, in all other cases pQueueRef will 
						// be NULL.
						//
						R<CQueue> pQueueRef = GetQueueReference(pOverLapped);

						if(pQueueRef->IsTriggerExist())
						{
							TrTRACE(Tgs, "receive operation on queue: %ls was cnacled", static_cast<LPCWSTR>(pQueueRef->m_bstrQueueName));

							pQueueRef->RequestNextMessage(false);
						}
						break;
					}
					default:
					{
						// We have received an unknown error code. This is bad. Terminate this thread.
						
						this->Stop();

						hr = static_cast<HRESULT>(pOverLapped->Internal);
						TrERROR(Tgs, "Failed to receive a message. Error 0x%I64x", pOverLapped->Internal);
					    
						break;
					}

				} // end switch (pOverLapped->Internal)

			} //  end if (pOverLapped != NULL)

			//
			// Note that we do not specify an else clause for the case where pOverlapped 
			// is NULL. This is interpretted as the regular timeout that occurs with the 
			// call to GetQueuedCompletionStatus(). If this trigger monitor has been asked
			// to stop - it will fall out of the outer-while loop because IsRunning() will 
			// return false. If this monitor has not be asked to stop, this thread will 
			// simply cycle around and reenter a blocked state by calling GetQueuedCompletionStatus()
			//

		} // end if (bGotPacket == TRUE) else clause

	} // end while (this->IsRunning() && SUCCEEDED(hr))

	return(SUCCEEDED(hr) ? true : false);
}

//********************************************************************************
//
// Method      : Exit
// 
// Description : This is an over-ride of the Exit() method in the 
//               base class CThread. This method is called by the 
//               CThread class after the Run() method has exited. It
//               is used to clean up thread specific resources. In this
//               case it cancels any outstanding IO requests made by 
//               this thread.
//
//********************************************************************************
bool CTriggerMonitor::Exit()
{
	// Only this TiggerMonitor thread should be executing the Exit() method - check this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// Cancel any outstanding IO requests from this thread on this queue handle.
	//
	m_pQueueManager->CancelQueuesIoOperation();

	// Write a trace message
	TrTRACE(Tgs, "Exit trigger monitor");

	return true;
}


//********************************************************************************
//
// Method      : MonitorEnteringWaitState
//
// Description : Called by this thread before it enters a blocked 
//               state. It increments the count of waiting (available)
//               monitor threads.
//
//********************************************************************************
void CTriggerMonitor::MonitorEnteringWaitState(bool bRoutineWakeUp)
{
	LONG lWaitingMonitors = InterlockedIncrement(&(m_pMonitorPool->m_lNumberOfWaitingMonitors));

	// record the tick count of when this thread last completed a request.
	if (bRoutineWakeUp == false)
	{
		m_dwLastRequestTickCount = GetTickCount();
	}

	TrTRACE(Tgs, "Entering wait state. There are now %d threads waiting trigger monitors.", lWaitingMonitors);
}

//********************************************************************************
//
// Method      : MonitorExitingWaitState
//
// Description : Called by this thread immediately after it unblocks. It decrements
//               the the count of waiting (available) monitor threads and conditionally
//               requests that another monitor thread be created if the load on the 
//               system is perceived to be high.
//
//********************************************************************************
void CTriggerMonitor::MonitorExitingWaitState(bool bRoutineWakeup)
{
	LONG lWaitingMonitors = InterlockedDecrement(&(m_pMonitorPool->m_lNumberOfWaitingMonitors));

	// If this monitor thread was the last in the pool, then there is a possibility that we will want 
	// to inform the CTriggerMonitorPool instance that more threads are requried to handled the load.
	// We request a new thread if and only if the following conditions have been met 
	// 
	//  (a) the number of waiting monitors is 0, 
	//  (b) the thread was unblocked due to message arrival, not routine time-out or wake-up request
	//  (c) the maximum number of monitors allowed is greater than one.
	//
	if ((lWaitingMonitors < 1) && (bRoutineWakeup == false) &&	(m_pITriggersConfig->GetMaxThreads() > 1)) 
	{
		TrTRACE(Tgs, "Requesting the creation of a new monitor due to load.");

		// Allocate a new CAdminMessage object instance.
		CAdminMessage * pAdminMsg = new CAdminMessage(CAdminMessage::eMsgTypes::eNewThreadRequest,_T(""));

		// Ask the TriggerMonitorPool object to process this message
		m_pMonitorPool->AcceptAdminMessage(pAdminMsg);
	}
}

//********************************************************************************
//
// Method      : GetQueueReference
//
// Description : This method is used to convert a pointer to an overlapped structure
//               to a queue reference. 
//
//********************************************************************************
CQueue* CTriggerMonitor::GetQueueReference(OVERLAPPED * pOverLapped)
{
	ASSERT(("Invalid overlapped pointer", pOverLapped != NULL));

	//
	// Map the pOverLapped structure to the containing queue object
	//
	CQueue* pQueue = CONTAINING_RECORD(pOverLapped,CQueue,m_OverLapped);
	//ASSERT(("Invalid queue object", pQueue->IsValid()));

	//
	// use the queue manager to determine if the pointer to the queue is valid and get
	// a refernce to it.
	// This method can return NULL in case the CQueue object was removed
	//
	return pQueue;
}


//********************************************************************************
// static
// Method      : ReceiveMessage	
//
// Description : Initializes a new trigger monitor class instance,
//               and calls the constructor of the base class CThread.
//
//********************************************************************************
inline
HRESULT
ReceiveMessage(
	VARIANT lookupId,
	CQueue* pQueue
	)
{	
	return pQueue->ReceiveMessageByLookupId(lookupId);
}


static set< _bstr_t > s_reportedDownLevelQueue;

static
bool
IsValidDownLevelQueue(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	if (!pQueue->IsOpenedForReceive())
	{
		//
		// The queue wasn't opened for receive. There is no issue with down-level queue
		//
		return true;
	}

	if (_wtoi64(pMessage->GetMsgLookupID().bstrVal) != 0)
	{
		//
		// It's not down-level queue. Only for down-level queue the returned lookup-id is 0
		//
		return true;
	}

	//
	// Report a message to event log if this is the first time
	//
	if (s_reportedDownLevelQueue.insert(pQueue->m_bstrQueueName).second)
	{
		EvReport(
			MSMQ_TRIGGER_RETRIEVE_DOWNLEVL_QUEUE_FAILED, 
			1,
			static_cast<LPCWSTR>(pQueue->m_bstrQueueName)
			);
	}

	return false;
}


static
bool
IsDuplicateMessage(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	//
	// This check is performed in order to eliminate duplicate last message
	// handling. This may happen when transactional retrieval is aborted
	// and a pending operation has already been initiated
	//
	if ((pQueue->GetLastMsgLookupID() == pMessage->GetMsgLookupID()) &&
		//
		// Down level client (W2K and NT4) doesn't support lookup id. As a result, the returned 
		// lookup id value is always 0.  
		//
		(_wtoi64(pMessage->GetMsgLookupID().bstrVal) != 0)
		)
	{
		return true;
	}

	//
	// Update last message LookupID for this queue, before issuing any
	// new pending operations
	//
	pQueue->SetLastMsgLookupID(pMessage->GetMsgLookupID());
	return false;
}


void
CTriggerMonitor::ProcessAdminMessage(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	HRESULT hr = ProcessMessageFromAdminQueue(pMessage);

	if (FAILED(hr))
		return;
	
	//
	// Remove admin message from queue
	//
	_variant_t vLookupID = pMessage->GetMsgLookupID();
	
	hr = ReceiveMessage(vLookupID, pQueue);
	if (FAILED(hr))
	{
		TrERROR(Tgs, "Failed to remove message from admin queue. Error=0x%x", hr);
	}
}


void
CTriggerMonitor::ProcessTrigger(
	CQueue* pQueue,
	CRuntimeTriggerInfo* pTriggerInfo,
	const CMsgProperties* pMessage
	)
{
	if (!pTriggerInfo->IsEnabled())
		return;

	TrTRACE(Tgs, "Process message from queue %ls of trigger %ls", static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerName), static_cast<LPCWSTR>(pTriggerInfo->m_bstrQueueName));

	//
	// Invoke the rule handlers for this trigger 
	//
	HRESULT hr = InvokeMSMQRuleHandlers(const_cast<CMsgProperties*>(pMessage), pTriggerInfo, pQueue);
	if (FAILED(hr))
	{
		TrERROR(Tgs, "Failed to invoke rules on queue: %ls of trigger %ls", static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerName), static_cast<LPCWSTR>(pTriggerInfo->m_bstrQueueName));
	}
}


//********************************************************************************
//
// Method      : ProcessReceivedMsgEvent
//
// Description : Called by the thread to process a message that has 
//               arrived on a monitored queuue. The key steps to 
//               processing a message are :
//
//               (1) Detach the message from the queue object
//               (2) If the firing trigger is not serialized, then 
//                   request the next message on this queue.
//               (3) If the firing trigger is our administration trigger,
//                   then defer this message to the TriggerMonitorPool class.
//               (4) For each trigger attached to this queue, execute
//                   the CheckRuleCondition() method on its rule-handler 
//               (5) If the firing trigger is a serialized trigger, 
//                   then request the next queue message now.
//               (6) Delete the queue message.                
//
//********************************************************************************
void CTriggerMonitor::ProcessReceivedMsgEvent(CQueue * pQueue)
{
	P<CMsgProperties> pMessage = pQueue->DetachMessage();

	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());
	TrTRACE(Tgs, "Received message for processing from queue: %ls", static_cast<LPCWSTR>(pQueue->m_bstrQueueName));

	//
	// Check if this message already processed. If yes ignore it
	//
	if (IsDuplicateMessage(pQueue, pMessage))
	{
		TrTRACE(Tgs, "Received duplicate message from queue: %ls. Message will be ignored.", (LPCWSTR)pQueue->m_bstrQueueName);
		pQueue->RequestNextMessage(false);
		return;
	}

	//
	// Befor begin to process the message check that the queue isn't down level	queue. For down-level queues
	// MSMQ trigger can't recevie the message since it uses lookup-id mechanism. In such a case write
	// event log messaeg and don't continue	to process messages from this queue.
	//
	if (!IsValidDownLevelQueue(pQueue, pMessage))
	{
		return;
	}

	//
	// If this is not a serialized queue, request the next message now.
	//
	bool fSerialized = pQueue->IsSerializedQueue();
	if(!fSerialized)
	{
		pQueue->RequestNextMessage(false);
	}

	//
	// Icrement the refernce count before invoking the rule handler. This promise that
	// even if the trigger service is stopped the CMonitorThread object still alive
	//
	R<CTriggerMonitor> ar = SafeAddRef(this);

	//
	// Determine how many triggers we need to process
	//
	long lNumTriggers = pQueue->GetTriggerCount();
 
	for(long i=0 ; i < lNumTriggers ; i++)
	{
		// Cast to a trigger info object
		CRuntimeTriggerInfo* pTriggerInfo = pQueue->GetTriggerByIndex(i);

		if (!pTriggerInfo->IsAdminTrigger())
		{
			ProcessTrigger(pQueue, pTriggerInfo, pMessage);
		}
		else
		{
			ProcessAdminMessage(pQueue, pMessage);
		}

	}

	//
	// If this is a serialized queue, we request the next message after we have processed the triggers
	//
	if(fSerialized)
	{
		pQueue->RequestNextMessage(false);
	}
}


bool s_fIssueCreateInstanceError = false;
static set< _bstr_t > s_reportedTransactedTriggers;

static
void
ExecuteRulesInTransaction(
	const _bstr_t& triggerName,
	const _bstr_t& triggerId,
	LPCWSTR registryPath,
	IMSMQPropertyBagPtr& pPropertyBag,
    DWORD dwRuleResult)
{
	IMqGenObjPtr pGenObj;
	HRESULT hr = pGenObj.CreateInstance(__uuidof(MqGenObj));

	if (FAILED(hr))
	{
		if (!s_fIssueCreateInstanceError)
		{
			WCHAR errorVal[128];
			swprintf(errorVal, L"0x%x", hr);

			EvReport(MSMQ_TRIGGER_MQGENTR_CREATE_INSTANCE_FAILED, 1, errorVal);
			s_fIssueCreateInstanceError = true;
		}

		TrTRACE(Tgs, "Failed to create Generic Triggers Handler Object. Error=0x%x", hr);
		throw bad_hresult(hr);
	}

	try
	{
		pGenObj->InvokeTransactionalRuleHandlers(triggerId, registryPath, pPropertyBag, dwRuleResult);
	}
	catch(const _com_error& e)
	{
		if (s_reportedTransactedTriggers.insert(triggerId).second)
		{
			ReportInvocationError(
							triggerName, 
							triggerId, 
							e.Error(), 
							MSMQ_TRIGGER_TRANSACTIONAL_INVOCATION_FAILED
							);
			throw;
		}
	}
}


void
CreatePropertyBag(
	const CMsgProperties* pMessage,
	const CRuntimeTriggerInfo* pTriggerInfo,
	IMSMQPropertyBagPtr& pIPropertyBag
	)
{
	HRESULT hr = pIPropertyBag.CreateInstance(__uuidof(MSMQPropertyBag));
	if (FAILED(hr))
	{
		TrERROR(Tgs, "Failed to create the MSMQPropertybag object. Error=0x%x",hr);
		throw bad_hresult(hr);
	}
	

	// TODO - investigate possible memory leaks here.

	// Populate the property bag with some useful information

	pIPropertyBag->Write(gc_bstrPropertyName_Label,pMessage->GetLabel());
	pIPropertyBag->Write(gc_bstrPropertyName_MsgID,pMessage->GetMessageID());
	pIPropertyBag->Write(gc_bstrPropertyName_MsgBody,pMessage->GetMsgBody());
	pIPropertyBag->Write(gc_bstrPropertyName_MsgBodyType,pMessage->GetMsgBodyType());
	pIPropertyBag->Write(gc_bstrPropertyName_CorID,pMessage->GetCorrelationID());
	pIPropertyBag->Write(gc_bstrPropertyName_MsgPriority,pMessage->GetPriority());
	pIPropertyBag->Write(gc_bstrPropertyName_ResponseQueueName,pMessage->GetResponseQueueName());
	pIPropertyBag->Write(gc_bstrPropertyName_AdminQueueName,pMessage->GetAdminQueueName());
	pIPropertyBag->Write(gc_bstrPropertyName_AppSpecific,pMessage->GetAppSpecific());
	pIPropertyBag->Write(gc_bstrPropertyName_QueueFormatname,pTriggerInfo->m_bstrQueueFormatName);
	pIPropertyBag->Write(gc_bstrPropertyName_QueuePathname,pTriggerInfo->m_bstrQueueName);
	pIPropertyBag->Write(gc_bstrPropertyName_TriggerName,pTriggerInfo->m_bstrTriggerName);
	pIPropertyBag->Write(gc_bstrPropertyName_TriggerID,pTriggerInfo->m_bstrTriggerID);		
	pIPropertyBag->Write(gc_bstrPropertyName_SentTime,pMessage->GetSentTime());
	pIPropertyBag->Write(gc_bstrPropertyName_ArrivedTime,pMessage->GetArrivedTime());
	pIPropertyBag->Write(gc_bstrPropertyName_SrcMachineId,pMessage->GetSrcMachineId());
	pIPropertyBag->Write(gc_bstrPropertyName_LookupId,pMessage->GetMsgLookupID());
}


static bool s_fReportedRuleHandlerCreationFailure = false;
static set< _bstr_t > s_reportedRules;


static 
IMSMQRuleHandlerPtr 
GetRuleHandler(
	CRuntimeRuleInfo* pRule
	)
{
	if (pRule->m_MSMQRuleHandler) 
	{
		//
		// There is an instance of MSMQRuleHandler - use it
		//
		return pRule->m_MSMQRuleHandler;
	}

	//
	// Create the interface
	//
	IMSMQRuleHandlerPtr pMSQMRuleHandler;
	HRESULT hr = pMSQMRuleHandler.CreateInstance(_T("MSMQTriggerObjects.MSMQRuleHandler")); 
	if ( FAILED(hr) )
	{
		TrERROR(Tgs, "Failed to create MSMQRuleHandler instance for Rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, hr);
		if (!s_fReportedRuleHandlerCreationFailure)
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				hr, 
				MSMQ_TRIGGER_RULE_HANDLE_CREATION_FAILED
				);
		}
		throw bad_hresult(hr);
	}

	try
	{
		//
		// Initialise the MSMQRuleHandling object.
		//
		pMSQMRuleHandler->Init(
							pRule->m_bstrRuleID,
							pRule->m_bstrCondition,
							pRule->m_bstrAction,
							(BOOL)(pRule->m_fShowWindow) 
							);

		//
		// Copy the local pointer to the rule store.
		//
		pRule->m_MSMQRuleHandler = pMSQMRuleHandler;
		return pMSQMRuleHandler;
	}
	catch(const _com_error& e)
	{
		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID).second)
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_PARSING_FAILED
				);
		}	
		throw;
	}
}



static 
void
CheckRuleCondition(
	CRuntimeRuleInfo* pRule,
	IMSMQPropertyBagPtr& pIPropertyBag,
	long& bConditionSatisfied
	)
{
	IMSMQRuleHandlerPtr pMSQMRuleHandler = GetRuleHandler(pRule);
	
	//
	// !!! This is the point at which the IMSMQRuleHandler component is invoked.
	// Note: Rules are always serialized - next rule execution starts only after 
	// previous has completed its action
	//
	try
	{
		pMSQMRuleHandler->CheckRuleCondition(
								pIPropertyBag.GetInterfacePtr(), 
								&bConditionSatisfied);		
	}
	catch(const _com_error& e)
	{
		TrERROR(Tgs, "Failed to process received message for rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, e.Error());

		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID).second)
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_INVOCATION_FAILED
				);
		}	
		throw;
	}

	TrTRACE(Tgs, "Successfully checked condition for rule: %ls.",(LPCTSTR)pRule->m_bstrRuleName);
}


static 
void
ExecuteRule(
	CRuntimeRuleInfo* pRule,
	IMSMQPropertyBagPtr& pIPropertyBag,
	long& lRuleResult
	)
{

    IMSMQRuleHandlerPtr pMSQMRuleHandler = GetRuleHandler(pRule);

	//
	// !!! This is the point at which the IMSMQRuleHandler component is invoked.
	// Note: Rules are always serialized - next rule execution starts only after 
	// previous has completed its action
	//
	try
	{
		pMSQMRuleHandler->ExecuteRule(
								pIPropertyBag.GetInterfacePtr(), 
                                TRUE, //serialized
								&lRuleResult);		
        
	}
	catch(const _com_error& e)
	{
		TrERROR(Tgs, "Failed to process received message for rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, e.Error());

		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID).second)
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_INVOCATION_FAILED
				);
		}	
		throw;
	}

	TrTRACE(Tgs, "Successfully pexecuted action for rule: %ls.",(LPCTSTR)pRule->m_bstrRuleName);


}


//********************************************************************************
//
// Method      : InvokeRegularRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeRegularRuleHandlers(
	IMSMQPropertyBagPtr& pIPropertyBag,
	CRuntimeTriggerInfo * pTriggerInfo,
	CQueue * pQueue
	)
{

   
	DWORD noOfRules = pTriggerInfo->GetNumberOfRules();
	bool bExistsConditionSatisfied = false;
   
	//
	// For each rule, invoke it's associated IMSMQTriggerHandling interface.
	//

	for (DWORD lRuleCtr = 0; lRuleCtr < noOfRules; lRuleCtr++)
	{
		CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
		ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

        long bConditionSatisfied=false;
		long lRuleResult=false;
       
		CheckRuleCondition(
						pRule, 
						pIPropertyBag, 
						bConditionSatisfied
						);
        if(bConditionSatisfied)
        {
            bExistsConditionSatisfied=true;
            ExecuteRule(
						pRule, 
						pIPropertyBag, 
						lRuleResult
						);
            if(lRuleResult & xRuleResultStopProcessing)
            {
                TrTRACE(Tgs, "Last processed rule (%ls) indicated to stop rules processing on Trigger (%ls). No further rules will be processed for this message.",(LPCTSTR)pRule->m_bstrRuleName,(LPCTSTR)pTriggerInfo->m_bstrTriggerName);						
                break;
            }
        }
        
	} 
	
	//
	// Receive message if at least one condition was satisdies 
	// and receive was requested
	//
	if (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE && bExistsConditionSatisfied)
	{
		_variant_t lookupId;
		HRESULT hr = pIPropertyBag->Read(gc_bstrPropertyName_LookupId, &lookupId);
		ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

		hr = ReceiveMessage(lookupId, pQueue);
		if ( FAILED(hr) )
		{
			TrERROR(Tgs, "Failed to receive message after processing all rules");
			return hr;
		}
	}

	return S_OK;
}

//********************************************************************************
//
// Method      : InvokeTransactionalRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeTransactionalRuleHandlers(
    IMSMQPropertyBagPtr& pIPropertyBag,
	CRuntimeTriggerInfo * pTriggerInfo
	)
{
    
	DWORD noOfRules = pTriggerInfo->GetNumberOfRules();
	bool bExistsConditionSatisfied = false;

   
	//
	// For each rule, invoke it's associated IMSMQTriggerHandling interface.
	//
    DWORD dwRuleResult=0;

	for (DWORD lRuleCtr = 0, RuleIndex=1; lRuleCtr < noOfRules; lRuleCtr++)
	{
		CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
		ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

        long bConditionSatisfied = false;

		CheckRuleCondition(
						pRule, 
						pIPropertyBag, 
						bConditionSatisfied
						);
        if(bConditionSatisfied)
        {
            bExistsConditionSatisfied = true;
            dwRuleResult |= RuleIndex;
        }

        RuleIndex <<=1;
	} 

	// Execute Rules && Receive message in Transaction if at least one condition was satisdies 
	//  dwRuleResult contains the bitmask for the rules that has been satisfied (first 32 rules)
	//
    if (bExistsConditionSatisfied)
	{
		ExecuteRulesInTransaction( 
							pTriggerInfo->m_bstrTriggerName,
							pTriggerInfo->m_bstrTriggerID,
							m_pMonitorPool->GetRegistryPath(),
							pIPropertyBag,
                            dwRuleResult
							);
	}
	return S_OK;
}

//********************************************************************************
//
// Method      : InvokeMSMQRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeMSMQRuleHandlers(
	CMsgProperties * pMessage,
	CRuntimeTriggerInfo * pTriggerInfo,
	CQueue * pQueue
	)
{
	HRESULT hr;

	try
	{
		TrTRACE(Tgs, "Activate Trigger: %ls  on queue: %ls.",(LPCTSTR)pTriggerInfo->m_bstrTriggerName,(LPCTSTR)pTriggerInfo->m_bstrQueueName);
		
		//
		// Create an instance of the property bag object we will pass to the rule handler, 
		// and populate it with the currently supported property values. Note that we pass
		// the same property bag instance to all rule handlers. 
		//
		IMSMQPropertyBagPtr pIPropertyBag;
		CreatePropertyBag(pMessage, pTriggerInfo, pIPropertyBag);

	
		if (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE_XACT)
		{
		    return InvokeTransactionalRuleHandlers(
                                    pIPropertyBag,
	                                pTriggerInfo
	                                );
		    
		}
        else
        {
            return InvokeRegularRuleHandlers(
                               pIPropertyBag,
	                           pTriggerInfo,
	                           pQueue
	                           );
        }	
	}
	catch(const _com_error& e)
	{
		hr = e.Error();
	}
	catch(const bad_hresult& e)
	{
		hr = e.error();
	}
	catch(const bad_alloc&)
	{
		hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	TrERROR(Tgs, "Failed to invoke rule handler. Error=0x%x.", hr);			
	return(hr);
}

//********************************************************************************
//
// Method      : ProcessMessageFromAdminQueue
//
// Description : processes a message that has been received from an administration
//               queue. In the current implementation this will be for messages 
//               indicating that underlying trigger data has changed. This method
//               will construct a new admin message object and hand it over to the 
//               triggermonitorpool object for subsequent processing.
//
//********************************************************************************
HRESULT CTriggerMonitor::ProcessMessageFromAdminQueue(const CMsgProperties* pMessage)
{
	_bstr_t bstrLabel;
	CAdminMessage * pAdminMsg = NULL;
	CAdminMessage::eMsgTypes eMsgType;

	// Ensure that we have been passsed a valid message pointer 
	ASSERT(pMessage != NULL);

	// get a copy of the message label
	bstrLabel = pMessage->GetLabel();

	// determine what sort of admin message we should be creating based on label.
	if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERUPDATED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerUpdated;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERADDED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerAdded;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERDELETED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerDeleted;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEUPDATED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleUpdated;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEADDED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleAdded;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEDELETED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleDeleted;
	}
	else
	{
		// unrecognized message label on an administrative message - log an error.
		ASSERT(("unrecognized admin message type", 0));

		// set a return code.
		return E_FAIL;
	}

	// Allocate a new CAdminMessage object instance.
	pAdminMsg = new CAdminMessage(eMsgType,(_bstr_t)pMessage->GetMsgBody());

    // Ask the TriggerMonitorPool object to process this message
    return m_pMonitorPool->AcceptAdminMessage(pAdminMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\tgp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tgp.h

Abstract:
    Trigger Service private functions.

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef __Tgp_H__
#define __Tgp_H__

//
// Global const definition
//
const TraceIdEntry Tgu = L"Trigger Utilities";
const TraceIdEntry Tgs = L"Trigger Service";
const TraceIdEntry xTriggerServiceComponent[] = {Tgu,  Tgs};

const DWORD xMaxTimeToNextReport=3000;

//
// Forwarding decleartion
//
extern CHandle g_hServicePaused;

class CTriggerMonitorPool;

//
// Internal interfaces
//
CTriggerMonitorPool*
TriggerInitialize(
    LPCTSTR pwzServiceName
    );

//
// Registration in COM+ function
//
void 
RegisterComponentInComPlusIfNeeded(
	VOID
	);


#endif // __Tgp_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\monitorp.hpp ===
//*******************************************************************
//
// Class Name  : CTriggerMonitorPool
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is the container for the set of worker 
//               threads that perform the trigger monitoring and 
//               processing. The key features of this class are 
//
//               (1) It provides aggregate startup and shutdown 
//                   functions for the worker thread group as a whole,
//
//               (2) It provides thread pool maintenance and recovery,
//
//               (3) It intitializes and maintains the cache of 
//                   trigger information,
//
//               (4) It performs the synchronization of the trigger 
//                   data cache as required.
//
//                There will be only one instance of this class in the 
//                entire MSMQ trigger service. 
//
//                This class is derived from the base class CThread, and
//                has it's own thread. This thread is used as an 
//                adminstrative thread only,it does perform trigger rule
//                processing.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CTriggerMonitorPool_INCLUDED 
#define CTriggerMonitorPool_INCLUDED

class CTriggerMonitor;

// Definition of the CTriggerMonitor object
#include "monitor.hpp"

// Include the definitions for the CThread object
#include "cthread.hpp"

// Definitions for the global queue-lock manager. 
#include "cqmanger.hpp"

// Definition of the admin message structure
#include "adminmsg.hpp"

#include "triginfo.hpp"

#include "mqtg.h"

#include "rwlock.h"

// Define a new type - a list of CTriggerMonitor objects.
typedef std::list< R<CTriggerMonitor> > TRIGGER_MONITOR_LIST;

// Define a new type - a list of Runtime Trigger Info
typedef std::list<CRuntimeTriggerInfo*> RUNTIME_TRIGGERINFO_LIST;

// Define a new type - a list of Messages 
typedef std::list<CAdminMessage*> ADMIN_MESSAGES_LIST;

// Define how long we will wait for shutdown to complete
#define SHUTDOWN_TIMEOUT             120000     // 10 seconds

// Define how often the admin thread will wake to perform periodic processing 
#define ADMIN_THREAD_WAKEUP_PERIOD   60000 //300000    // 5 minutes

// Define how long a monitor thread can be idle for before it becomes a candidate
// for being removed from the thread pool.
#define MONITOR_MAX_IDLE_TIME        120000    // 2 minutes

// Define the list of tasks that the admin thread can do upon request
#define ADMIN_THREAD_IDLE                     0
#define ADMIN_THREAD_PROCESS_NOTIFICATIONS    1
#define ADMIN_THREAD_STOP                     2

class CTriggerMonitorPool  : public CReference, public CThread
{
	friend class CTriggerMonitor;

	public:

		CTriggerMonitorPool(IMSMQTriggersConfigPtr pITriggersConfig, LPCTSTR bstrServiceName) ;

		HRESULT ShutdownThreadPool();
		
		LPWSTR  GetRegistryPath() 
		{ 
			return m_wzRegPath; 
		}

		bool IsInitialized(void) const
		{
			return m_bInitialisedOK;
		}

		DWORD GetProcessingThreadNumber(void) const
		{
			return numeric_cast<DWORD>(m_lstTriggerMonitors.size());
		}

	private:

		~CTriggerMonitorPool();

   	    // A flag indicating if this thread initialized OK
		bool m_bInitialisedOK;

		//get the admin task flag value and rest it
		long GetAdminTask();

		CCriticalSection m_csAdminTask;
		// Used to indicate what sort of admin task we should process
		long m_lAdminTask;

		// A handle to the single IO completion port that all worker thread will 
		// use to receive asynchronous MSMQ messages
		HANDLE m_hIOCompletionPort;

		// the event object that the admin blocks on
		CHandle m_hAdminEvent;

		// This is a count of blocked (available) monitor threads in the thread pool
		LONG m_lNumberOfWaitingMonitors;

		// This is an an instance of the trigger set COM object - used to retrieve 
		// trigger information from the database. 
		IMSMQTriggerSetPtr m_pMSMQTriggerSet;

		// This is the list of TriggerMonitor objects that are managed by this class. 
		TRIGGER_MONITOR_LIST m_lstTriggerMonitors;

		//get a copy of the current admin message list and reset it
		void GetAdminMessageListCopy(ADMIN_MESSAGES_LIST* pAdminList);

		// This is a list of admin messages that are to be processed by the administrator thread.
		ADMIN_MESSAGES_LIST m_lstAdminMessages;

		// This lock is used to control access to the list of admin messages.
		CCriticalSection m_AdminMsgListLock;

		// Queue lock manager - handles thread synchronisatio to queue when required.
		R<CQueueManager>  m_pQueueManager;

		// The time this thread pool started 
		_bstr_t m_bstrStartTime;

		// The time of the last trigger data synchronization
		_bstr_t m_bstrLastSyncTime;

		_bstr_t	m_bstrThreadStatus;

		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

		// Thread controls methods - overrides from the CThread class
		bool Init();
		bool Run();
		bool Exit();

		void 
		CreateIOCompletionPort(
			void
			);
		
		void 
		GetTriggerData(
			RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
			);

		
		void
		GetAttachedRuleData(
			const BSTR& bsTriggerID,
			long ruleNo,
			RUNTIME_RULEINFO_LIST& ruleList
			);


		CRuntimeTriggerInfo*
		CreateNotificationTrigger(
			void
			);

		CRuntimeTriggerInfo*
		GetTriggerRuntimeInfo(
			long triggerIndex
			);


		void 
		AttachTriggersToQueues(
			RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
			);


		HRESULT CreateTriggerMonitor();

		HRESULT PerformPeriodicProcessing();
		HRESULT RefreshServiceStatus();
		HRESULT FlushServiceStatus();

		HRESULT ProcessAdminMessages();

		HRESULT AcceptAdminMessage(CAdminMessage * pAdminMessage);

		HRESULT PostMessageToAllMonitors(DWORD dwCompletionKey);

		// used to determine how many live monitors (threads) are in the pool.
		DWORD GetNumberOfRunningTriggerMonitors();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigserv\trigserv.cpp ===
//*******************************************************************
//
// File Name   : trigserv.cpp
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the main MSMQ Trigger service file.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "Cm.h"
#include "Ev.h"
#include "Svc.h"
#include "monitorp.hpp"
#include "mqsymbls.h"
#include "Tgp.h"

#include "trigserv.tmh"

//
// Create the NT event object that will be used to control service pause and resume
// functionality. We will manually set and reset this event as in response to pause
// and resume requests. This NT event will be named so that other processes on the 
// machine can test if the MSMQ Trigger service is in a pause state or not. 
//
CHandle g_hServicePaused(CreateEvent(NULL,TRUE,TRUE, L""));

CHandle s_hStopEvent(CreateEvent(NULL, FALSE, FALSE, L""));


VOID
AppRun(
	LPCWSTR ServiceName
	)
/*++

Routine Description:
    Triggers service start function.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
    //
    //  Report a service is starting status to SCM. 
    //
    SvcReportState(SERVICE_START_PENDING);
	
	try
	{
		EvInitialize(ServiceName);
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgs,"Failed to initialize event log library. MSMQ Trigger service can't start. Maybe MSMQTriggers registry key is missing.");
	    SvcReportState(SERVICE_STOPPED);
		return;
	}

	TrRegisterComponent(xTriggerServiceComponent, TABLE_SIZE(xTriggerServiceComponent));

    HRESULT hr;
	try
	{
        if ((g_hServicePaused == NULL) || (s_hStopEvent == NULL))
        {
    		TrERROR(Tgs, "Trigger start-up failed. Can't create an event");
            throw bad_alloc();
        }


        //
        // Initialize the trigger service. If success it returns a pointer 
        // to monitor pool. This needs for graceful shutdown
        //
        R<CTriggerMonitorPool> pTriggerMonitorPool = TriggerInitialize(ServiceName);
        
        //
        //  Report a 'Running' status to SCM. 
        //
        SvcReportState(SERVICE_RUNNING);
        SvcEnableControls(
		    SERVICE_ACCEPT_STOP |
		    SERVICE_ACCEPT_SHUTDOWN |
            SERVICE_ACCEPT_PAUSE_CONTINUE 
		    );

        //
        // Wait for service stop or shutdown
        //
        WaitForSingleObject(s_hStopEvent, INFINITE);

        //
        // Stop Pending was already reported to SCM, now tell how long
        // would it take to stop.
        //
        DWORD stopProcessTimeOut = (pTriggerMonitorPool->GetProcessingThreadNumber() + 1) * TRIGGER_MONITOR_STOP_TIMEOUT;
	    SvcReportProgress(stopProcessTimeOut);

        //
	    // Now that we have get shutdown request attempt to 
	    // shutdown the trigger monitor pool gracefully.
        //
	    pTriggerMonitorPool->ShutdownThreadPool();

        //
        //  Report a 'Stopped' status to SCM. 
        //
        SvcReportState(SERVICE_STOPPED);

        //
        // Report Stopped in event log
        //
		EvReport(MSMQ_TRIGGER_STOPPED);

		return;
	}
    catch (const _com_error& e)
    {
		hr = e.Error();
    }
	catch (const bad_hresult& e)
	{
		hr = e.error();
	}
	catch (const bad_alloc&)
	{
		hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch (const exception&)
	{
		hr = MQTRIG_ERROR;
	}

    TrERROR(Tgs, "Trigger service start-up failed. Error=0x%x", hr);

	//
	// Produce Event log message
	//
	WCHAR errorVal[128];
	swprintf(errorVal, L"0x%x", hr);
	EvReport(MSMQ_TRIGGER_INIT_FAILED, 1, errorVal);
    SvcReportState(SERVICE_STOPPED);
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	//
	//  Report a 'service is stopping' progress to SCM. 
	//
    SvcReportState(SERVICE_STOP_PENDING);

	SetEvent(s_hStopEvent);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. It should immidiatly
	report it state back, and take the procedure to pause the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ResetEvent(g_hServicePaused);
    SvcReportState(SERVICE_PAUSED);
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. It should immidiatly
	report it state back, and take the procedure to contineu the service from
	a paused state.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    SetEvent(g_hServicePaused);
	SvcReportState(SERVICE_RUNNING);
}


VOID
AppShutdown(
	VOID
	)
{
	//
	//  Report a 'service is stopping' progress to SCM. 
	//
    SvcReportState(SERVICE_STOP_PENDING);
	SetEvent(s_hStopEvent);
}


//*******************************************************************
//
// Method      :  
//
// Description : 
//
//*******************************************************************
extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
{
	try
	{
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS);
		TrInitialize();

        //
        // If a command line parameter is passed, use it as the dummy service
        // name. This is very usful for debugging cluster startup code.
        //
        LPCWSTR DummyServiceName = (argc == 2) ? argv[1] : L"MSMQTriggers";
        SvcInitialize(DummyServiceName);
	}
	catch(const exception&)
	{
		//
		// Cannot initialize the service, bail-out with an error.
		//
		return -1;
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\ruleinfo.cpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeRuleInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
//
// Description : This class encapsulates information about a trigger rule.
//               It is used to cache rule information at runtime about trigger
//               rules, as well as accessing the underlying trigger storage
//               medium.
//
// Notes       : The current implementation uses the registry as the storage
//               medium.
//
//               This class is used by both the trggers service and the trigger
//               COM components.
//
// When     | Who       | Change Descriptin
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "mqtg.h"
#include "stdfuncs.hpp"
#include "Cm.h"
#include "ruleinfo.hpp"

#include "ruleinfo.tmh"


//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initialize an empty instance of this class.
//
//*****************************************************************************
CRuntimeRuleInfo::CRuntimeRuleInfo(
	LPCTSTR pwzRegPath
	) :
	m_MSMQRuleHandler(NULL)
{
	m_bstrRuleID = _T("");
	m_bstrRuleName = _T("");
	m_bstrAction = _T("");
	m_bstrCondition = _T("");
	m_bstrImplementationProgID = _T("");
	m_fShowWindow = false;

	_tcscpy( m_wzRuleRegPath, pwzRegPath );
	_tcscat( m_wzRuleRegPath, REG_SUBKEY_RULES );
}

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initialize an instance of the CRuntimeRuleInfo structure
//
//*****************************************************************************
CRuntimeRuleInfo::CRuntimeRuleInfo(
	const _bstr_t& ruleId,
	BSTR bsRuleName,
	BSTR bsRuleDescription,
	BSTR bsRuleCondition,
	BSTR bsRuleAction,
	BSTR bsRuleImplementationProgID,
	LPCTSTR pwzRegPath,
	bool fShowWindow
	):
	m_bstrRuleID(ruleId),
	m_MSMQRuleHandler(NULL)
{
	ASSERT(bsRuleName != NULL);
	m_bstrRuleName = bsRuleName;

	if(bsRuleDescription == NULL)
	{
		m_bstrRuleDescription = _T("");
	}
	else
	{
		m_bstrRuleDescription = bsRuleDescription;
	}

	ASSERT(bsRuleAction != NULL); //always contains COM or EXE
	m_bstrAction = bsRuleAction;

	if(bsRuleCondition == NULL)
	{
		m_bstrCondition = _T("");
	}
	else
	{
		m_bstrCondition = bsRuleCondition;
	}

	if(bsRuleImplementationProgID == NULL)
	{
		m_bstrImplementationProgID = _T("");
	}
	else
	{
		m_bstrImplementationProgID = bsRuleImplementationProgID;
	}
	
	m_fShowWindow = fShowWindow;

	_tcscpy( m_wzRuleRegPath, pwzRegPath );
	_tcscat( m_wzRuleRegPath, REG_SUBKEY_RULES );
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Does nothing.
//
//*****************************************************************************
CRuntimeRuleInfo::~CRuntimeRuleInfo()
{
}


//*****************************************************************************
//
// Method      : GetRuleKeyHandle
//
// Description : Returns a handle to specified registry key
//
//*****************************************************************************
HKEY
CRuntimeRuleInfo::GetRuleKeyHandle(
    HKEY hRegistry,
    LPCTSTR ruleId
    )
{
    TCHAR rulePath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(rulePath, MAX_REGKEY_NAME_SIZE, L"%s%s", m_wzRuleRegPath, ruleId);
    // XP SP1 bug 592252.
	rulePath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(Tgu, "Buffer to small to contain the registry path of a rule.");
		return NULL;
	}

    RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::Optional, hRegistry);
    return CmOpenKey(ruleReg, KEY_ALL_ACCESS);
}



//*****************************************************************************
//
// Method      : IsValid
//
// Description : Returns a boolean value indicating if the current
//               instance represents a valid rule definition.
//
//*****************************************************************************
bool CRuntimeRuleInfo::IsValid()
{
	return(IsValidRuleID(m_bstrRuleID) &&
		   IsValidRuleName(m_bstrRuleName) &&
		   IsValidRuleDescription(m_bstrRuleDescription) &&
		   IsValidRuleAction(m_bstrAction) &&
		   IsValidRuleCondition(m_bstrCondition) &&
		   IsValidRuleProgID(m_bstrImplementationProgID));
}


//*****************************************************************************
//
// Method      : Update
//
// Description : This method is used to update the definition of this
//               rule (currently in persisted in the registry).
//
//*****************************************************************************
bool CRuntimeRuleInfo::Update(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(IsValid());

    CRegHandle hRuleKey = GetRuleKeyHandle(hRegistry, m_bstrRuleID );
    if (hRuleKey == NULL)
    {
		TrERROR(Tgu, "Failed to update rule properties for rule: %ls. Rule does't exist in registry", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    try
    {
	    FlushValuesToRegistry(hRuleKey);
        return true;
    }
    catch (const bad_alloc&)
    {
        //
		// ISSUE-2000/10/26-urih: partial success can cause rule inconsistency
        //
		TrERROR(Tgu, "Failed to update rule properties for: %ls rule.", (LPCWSTR)m_bstrRuleID);
	    return false;
    }
}

//*****************************************************************************
//
// Method      : Create
//
// Description : This method creates a new rule definition based on
//               properties values of this class instance.
//
//*****************************************************************************
bool CRuntimeRuleInfo::Create(HKEY hRegistry)
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(hRegistry != NULL);

    //
    // Check that there the registery doesn't contain another rule with same ID
    //
    CRegHandle hRuleKey = GetRuleKeyHandle(hRegistry, m_bstrRuleID );
    if (hRuleKey != NULL)
    {
		TrERROR(Tgu, "Failed to create a key for rule:%ls . Registry already contains rule with same ID.", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    //
    // Assemble rule registery path
    //
    TCHAR rulePath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(rulePath, MAX_REGKEY_NAME_SIZE, L"%s%s", m_wzRuleRegPath, static_cast<LPCWSTR>(m_bstrRuleID));
    // Xp SP1 bug 594253.
    rulePath[ MAX_REGKEY_NAME_SIZE-1 ] = L'\0' ;
	if (n < 0)
	{
		TrERROR(Tgu, "Failed to create a key for rule:%ls. Buffer to small to contain the registry path of a rule.", (LPCWSTR)m_bstrRuleID);
		return false;
	}

    try
    {
        //
        // Create key for the rule in registry
        //
        RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hRuleKey = CmCreateKey(ruleReg, KEY_ALL_ACCESS);

	    FlushValuesToRegistry(hRuleKey);
    	return true;
    }
    catch(const bad_alloc&)
    {
        //
        // Remove the key if already created
        //
        RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::Optional, hRegistry);
        CmDeleteKey(ruleReg);

		TrERROR(Tgu, "Failed to store rule:%ls in registry.",(LPCWSTR)m_bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Delete
//
// Description : This method will delete the current rule definition from the
//               registry. Note that before deleting a rule we must check that
//               it is not currently in use. We do this by retrieving the rule
//               definition again and checking the reference count.
//
//*****************************************************************************
bool CRuntimeRuleInfo::Delete(HKEY hRegistry)
{
    try
    {
        RegEntry rulesReg(m_wzRuleRegPath, NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hRuless = CmOpenKey(rulesReg, KEY_ALL_ACCESS);

        RegEntry ruleReg(m_bstrRuleID, NULL, 0, RegEntry::MustExist, hRuless);
        CmDeleteKey(ruleReg);

        return true;
    }
    catch (const exception&)
    {
		TrERROR(Tgu, "Failed to delete rule:%ls from registry.", (LPCWSTR)m_bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Retrieve
//
// Description : This method retrieve the specified rule ID from the
//               supplied registry key.
//
//*****************************************************************************
bool CRuntimeRuleInfo::Retrieve(HKEY hRegistry, _bstr_t bstrRuleID)
{
    CRegHandle hRuleKey = GetRuleKeyHandle(hRegistry, bstrRuleID );
    if (hRuleKey == NULL)
    {
 		TrERROR(Tgu, "Failed to retrieve rule properties from registery for %ls. Registery key isn't exist.", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    try
    {
        //
        // Retrieve rule name
        //
        AP<TCHAR> ruleName = NULL;
        RegEntry ruleNameReg(NULL, REGISTRY_RULE_VALUE_NAME, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleNameReg, &ruleName);

        //
        // Retrieve rule description
        //
        AP<TCHAR> ruleDescription = NULL;
        RegEntry ruleDescReg(NULL, REGISTRY_RULE_VALUE_DESCRIPTION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleDescReg, &ruleDescription);

        //
        // Retrieve rule prog-id
        //
        AP<TCHAR> ruleProgid = NULL;
        RegEntry ruleProgidReg(NULL, REGISTRY_RULE_VALUE_IMP_PROGID, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleProgidReg, &ruleProgid);

        //
	    // Retrieve rule condition
        //
        AP<TCHAR> ruleCond = NULL;
        RegEntry ruleCondReg(NULL, REGISTRY_RULE_VALUE_CONDITION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleCondReg, &ruleCond);

        //
	    // Retrieve rule action
        //
        AP<TCHAR> ruleAction = NULL;
        RegEntry ruleActReg(NULL, REGISTRY_RULE_VALUE_ACTION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleActReg, &ruleAction);

        //
        // Retrieve rule show console window value
        //
        DWORD ruleShowWindow;
        RegEntry ruleShowWinReg(NULL, REGISTRY_RULE_VALUE_SHOW_WINDOW, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleShowWinReg, &ruleShowWindow);

	    //
        // Initialise the member vars of this rule instance.
        //
		m_bstrRuleID = bstrRuleID;
		m_bstrRuleName = ruleName;
		m_bstrRuleDescription = ruleDescription;
		m_bstrImplementationProgID = ruleProgid;
		m_bstrCondition = ruleCond;
		m_bstrAction = ruleAction;
		m_fShowWindow = ruleShowWindow != 0;

		if (IsValid())
            return true;

		//
        // Invalid rule. write a log message and return false.
		//
		TrERROR(Tgu, "Failed to retrieve rule properties for %ls. Rule property isn't valid", (LPCWSTR)m_bstrRuleID);
		return false;
    }
    catch (const exception&)
	{
		TrERROR(Tgu, "Failed to retrieve rule %ls from registry", (LPCWSTR)bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : FlushValuesToRegistry
//
// Description : This method flushes the member variable values to the
//               supplied registry key.
//
//*****************************************************************************
void
CRuntimeRuleInfo::FlushValuesToRegistry(
    const HKEY& hRuleKey
    )
{
    //
	// Set the NAME value for this rule
    //
    RegEntry ruleNameReg(NULL, REGISTRY_RULE_VALUE_NAME, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleNameReg, m_bstrRuleName);

    //
    // set the DESCRIPTION value for this rule
    //
    RegEntry ruleDescReg(NULL, REGISTRY_RULE_VALUE_DESCRIPTION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleDescReg, m_bstrRuleDescription);

	// Create the Implementation value for this rule. Note that in this release we are
	// not allow the user supplied prog-id to be used - we are forcing the use of the MS
	// supplied rule-handler.
   	m_bstrImplementationProgID = _T("MSQMTriggerObjects.MSMQRuleHandler"); // TO BE REMOVED.
    RegEntry ruleUmpProgReg(NULL, REGISTRY_RULE_VALUE_IMP_PROGID, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleUmpProgReg, m_bstrImplementationProgID);

    //
	// Set the Condition value for this rule
    //
    RegEntry ruleCondReg(NULL, REGISTRY_RULE_VALUE_CONDITION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleCondReg, m_bstrCondition);

    //
    // Set the Action value for this rule
    //
    RegEntry ruleActReg(NULL, REGISTRY_RULE_VALUE_ACTION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleActReg, m_bstrAction);

    //
    // Set the show console window value
    //
    DWORD dwShowWindow = m_fShowWindow ? 1 : 0;
    RegEntry ruleShowWinReg(NULL, REGISTRY_RULE_VALUE_SHOW_WINDOW, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleShowWinReg, dwShowWindow);
}


//*****************************************************************************
//
// Method      : IsValid*
//
// Description : The following static methods are used to validate
//               the validity of parameters and member vars used by
//               the CRuntimeRuleInfo class.
//
//*****************************************************************************
bool CRuntimeRuleInfo::IsValidRuleID(_bstr_t bstrRuleID)
{
	return((bstrRuleID.length() > 0) && (bstrRuleID.length() <= MAX_RULE_ID_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleName(_bstr_t bstrRuleName)
{
	return((bstrRuleName.length() > 0) && (bstrRuleName.length() <= MAX_RULE_NAME_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleDescription(_bstr_t bstrRuleDescription)
{
	return((bstrRuleDescription.length() <= MAX_RULE_DESCRIPTION_LEN)  ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleCondition(_bstr_t bstrRuleCondition)
{
	return((bstrRuleCondition.length() <= MAX_RULE_CONDITION_LEN)? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleAction(_bstr_t bstrRuleAction)
{
	return((bstrRuleAction.length() > 0) && (bstrRuleAction.length() <= MAX_RULE_ACTION_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleProgID(_bstr_t bstrRuleProgID)
{
	return((bstrRuleProgID.length() > 0) && (bstrRuleProgID.length() <= MAX_RULE_PROGID_LEN) ? true:false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\genmqsec.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	GenMQSec.cpp    

Abstract:
    generates a security descriptor matching the desired access to MQ.

Author:
   Dan Bar-Lev
   Yifat Peled	(yifatp)	24-Sep-98

--*/

#define SECURITY_WIN32

#include "stdafx.h"
#include "mqsec.h"
#include "GenMQSec.h"

#include "genmqsec.tmh"


typedef struct tagSecParse
{
	WCHAR *pwcsName;
	DWORD dwVal;
}tagSecParse;

tagSecParse SecParse[] = {
							{ L"Rj",	MQSEC_RECEIVE_JOURNAL_MESSAGE },
							{ L"Rq",	MQSEC_RECEIVE_MESSAGE },
							{ L"Pq",	MQSEC_PEEK_MESSAGE },
							{ L"Sq",	MQSEC_WRITE_MESSAGE },
							{ L"Sp",	MQSEC_SET_QUEUE_PROPERTIES },
							{ L"Gp",	MQSEC_GET_QUEUE_PROPERTIES },
							{ L"D",		MQSEC_DELETE_QUEUE },
							{ L"Pg",	MQSEC_GET_QUEUE_PERMISSIONS },
							{ L"Ps",	MQSEC_CHANGE_QUEUE_PERMISSIONS },
							{ L"O",		MQSEC_TAKE_QUEUE_OWNERSHIP },
							{ L"R",		MQSEC_QUEUE_GENERIC_READ },
							{ L"W",		MQSEC_QUEUE_GENERIC_WRITE },
							{ L"A",		MQSEC_QUEUE_GENERIC_ALL }
						};

int iSecParseLen = ( sizeof(SecParse) / sizeof(tagSecParse) );


/******************************************************************************

	fAddAce

Parse an access right of the form: +"domain\user" 1234;
Output:
  sid of the domain\user
  access mode
  grant - true if allow, false if deny

******************************************************************************/

DWORD
fAddAce(WCHAR*	pOrginalRight,
		SECURITY_INFORMATION*	pSecInfo,
		PSECURITY_DESCRIPTOR	pSecurityDescriptor,
		PSID*	ppSid,
		DWORD*	pdwSidSize,
		PACL*	ppAcl)
		
{
	DWORD	rc;
	DWORD	dwAccess = 0;
	WCHAR	grant_c;
	WCHAR*	pwcs;
	WCHAR*	pInRight;
	AP<WCHAR> pAutoInRight;
	WCHAR*	pwcsTerminate;
	DWORD	dwSize;


	// make a local copy of the right string 
	pAutoInRight = new WCHAR[wcslen(pOrginalRight) + 1];
	pInRight = pAutoInRight;
	wcscpy(pInRight, pOrginalRight);
	pwcsTerminate = pInRight + wcslen(pInRight);

	// remove leading spaces
	while ( iswspace(*pInRight) )
		pInRight++;

	// keep the grant option
	grant_c = *(pInRight++);

	// skip seperator
	ASSERT(*pInRight == L':');	// seperator should be ':'
    ++ pInRight;

	// remove leading spaces
	while ( iswspace(*pInRight) )
		pInRight++;

	// name starts with quote
	if ( *pInRight == L'"')
		pwcs = wcschr( ++pInRight, L'"' );	// search for closing double quote
	else if ( *pInRight == L'\'' )
		pwcs = wcschr( ++pInRight, L'\'' );	// search for closing quote

	else // otherwise we assume white-space delimiter
	{
	 	pwcs = pInRight + wcscspn(pInRight, L" \t\r\f\n");
	}
	*pwcs = L'\0';						// mark the name end
	
	
	//
	// Get SID of the account given
	//

	if ( !(*pInRight) || !wcscmp(pInRight, L".") )// no account or the account is '.' - use current account
	{
		HANDLE hAccessToken;
		UCHAR InfoBuffer[255];
		PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;

		if(!OpenProcessToken(GetCurrentProcess(),
							 TOKEN_READ,
							 //TRUE,
							 &hAccessToken))
		{
			return GetLastError();
		}
		
		if(!GetTokenInformation(hAccessToken,
								TokenUser,
								InfoBuffer,
								sizeof(InfoBuffer),
								&dwSize))
		{
			return GetLastError();
		}

		CloseHandle(hAccessToken);

		if(!IsValidSid(pTokenUser->User.Sid))
		{
			return GetLastError();
		}
		dwSize = GetLengthSid(pTokenUser->User.Sid);
		if ( dwSize > (*pdwSidSize))
		{
			delete [] ((BYTE*)(*ppSid));
			*ppSid = (PSID*)new BYTE[dwSize];
			*pdwSidSize = dwSize;		// keep new size
		}
		memcpy(*ppSid, pTokenUser->User.Sid, dwSize );
	}
	else if ( !wcscmp(pInRight, L"*") )	// account is '*' - use WORLD
	{
		SID SecWorld = { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
		if ( !IsValidSid(&SecWorld) )
		{
			return GetLastError();
		}

		dwSize = GetLengthSid( &SecWorld );
		if ( dwSize > *pdwSidSize )
		{
			delete [] ((BYTE*)(*ppSid));
			*ppSid = (PSID*)new BYTE[dwSize];
			*pdwSidSize = dwSize;		// keep new size
		}
		memcpy( *ppSid, &SecWorld, dwSize );
		
	}
	else // a specific account is given
	{
		SID_NAME_USE	Use;
		WCHAR			refdomain[256];
		DWORD			refdomain_size = sizeof(refdomain) /  sizeof(*refdomain);

		while (1)
		{
			dwSize = *pdwSidSize;

			if ( LookupAccountName( NULL,
								    pInRight, 
							        *ppSid,
									&dwSize, 
									refdomain,
									&refdomain_size, 
									&Use ) )
			{
				break;
			}

			DWORD dwError = GetLastError();
			if ( dwError == ERROR_INSUFFICIENT_BUFFER )
			{
				delete [] ((BYTE*)(*ppSid));
				*ppSid = (PSID*) new BYTE[dwSize];
				*pdwSidSize = dwSize;		// keep new size
			}
			else
			{
				return dwError;
			}
		}

		if ( !IsValidSid( *ppSid ) )
		{
			return GetLastError();
		}
	}

	//
	// Set dwAccess according to given access
	//

	// rights start after the username
	if ( pwcs < pwcsTerminate )
		pInRight = ++pwcs;
	else
		pInRight = pwcs;

	if ( *pInRight )
	{
		// remove leading spaces
		while ( iswspace(*pInRight) )
			pInRight++;

		int i, len;

		for( i=0; *pInRight && i < iSecParseLen; i++ )
		{
			WCHAR*	pwcSecName = SecParse[i].pwcsName;
			len = wcslen( pwcSecName );

			if ( !_wcsnicmp( pInRight, pwcSecName, len) )
			{
				dwAccess = dwAccess | SecParse[i].dwVal;
				i = 0;						// restart search
				pInRight += len;			// goto next security token
			}
		} // for

		while ( iswspace(*pInRight) )	// remove spaces
			pInRight++;					
		ASSERT(*pInRight == 0);				// unknown access rights!
	}

	//
	// Add access to ACL
	//

	switch( towupper( grant_c ) )
	{
	case L'+':
		{
			if(!IsValidSid(*ppSid))
			{
				return GetLastError();
			}

			dwSize = GetLengthSid( *ppSid );
			dwSize += sizeof(ACCESS_ALLOWED_ACE);	
			DWORD dwNewAclSize = (*ppAcl)->AclSize + dwSize - sizeof(DWORD /*ACCESS_ALLOWED_ACE.SidStart*/);
			
			//
			// allocate more space for ACL
			//
			PACL pTempAcl = (PACL) new BYTE[dwNewAclSize];
			memcpy(pTempAcl, *ppAcl, (*ppAcl)->AclSize);
			delete [] ((BYTE*)(*ppAcl));
			*ppAcl = pTempAcl;

			(*ppAcl)->AclSize = (WORD)dwNewAclSize;

			rc = AddAccessAllowedAce( *ppAcl, ACL_REVISION, dwAccess, *ppSid );
			
			if ( rc && pSecInfo )
				*pSecInfo |= DACL_SECURITY_INFORMATION;
			break;
		}
	case L'-':
		{
			if(!IsValidSid(*ppSid))
			{
				return GetLastError();
			}
			dwSize = GetLengthSid( *ppSid );
			dwSize += sizeof(ACCESS_DENIED_ACE);
			DWORD dwNewAclSize = (*ppAcl)->AclSize + dwSize - sizeof(DWORD /*ACCESS_DENIED_ACE.SidStart*/);
		
			//
			// allocate more space for ACL
			//
			PACL pTempAcl = (PACL) new BYTE[dwNewAclSize];
			memcpy(pTempAcl, *ppAcl, (*ppAcl)->AclSize);
			delete [] ((BYTE*)(*ppAcl));
			*ppAcl = pTempAcl;

			(*ppAcl)->AclSize = (WORD)dwNewAclSize;

			rc = AddAccessDeniedAce( *ppAcl, ACL_REVISION, dwAccess, *ppSid );

			if ( rc && pSecInfo )
				*pSecInfo |= DACL_SECURITY_INFORMATION;
			break;
		}
	case L'O':	// specify the owner
		rc = SetSecurityDescriptorOwner( pSecurityDescriptor, *ppSid, FALSE );
		if (rc)
		{
			if(pSecInfo)
				*pSecInfo |= OWNER_SECURITY_INFORMATION;
		}
		else 
			return GetLastError();
		break;
	case 'G':	// specify the group
		rc = SetSecurityDescriptorGroup( pSecurityDescriptor, *ppSid, FALSE );
		if (rc)
		{
			if(pSecInfo)
				*pSecInfo |=  GROUP_SECURITY_INFORMATION;
		}
		else 
			return GetLastError();
		break;
	default: // error
		ASSERT(0);
	}

	return 0;
}

/******************************************************************************

	GenSecurityDescriptor


 * Input: string line of the following format:
 *   right --> [+-]domain\username 0x333 
 *   line --> right1,right2,...
 *
 * Notes: 
 *   domain and username that contain spaces should be enclosed in 
 *     double quotes "
 *   white spaces are allowed.
 *
 * output Security descriptor that must be freed by the calling routine.
 *
 * return codes:
 *   0 if everything went well.
******************************************************************************/

#define SID_USUAL_SIZE	64


DWORD 
GenSecurityDescriptor(	SECURITY_INFORMATION*	pSecInfo,
						const WCHAR*			pwcsSecurityStr,
						PSECURITY_DESCRIPTOR*	ppSD)
{
	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
	PACL	pAcl = NULL;
	PSID	pSid = NULL;
	WCHAR*	pwcsRight;

	ASSERT(pwcsSecurityStr != NULL);
	ASSERT(ppSD != NULL);
	
	//For automatic memory cleanup
	AP<WCHAR> pwcsAutoSecurity = new WCHAR[wcslen(pwcsSecurityStr) + 1];
	WCHAR* pwcsSecurity = pwcsAutoSecurity;

	wcscpy(pwcsSecurity, pwcsSecurityStr);

	*ppSD = NULL;	
	
	// reset the security inforamtion flags
	if (pSecInfo != NULL)
		(*pSecInfo) = 0;


	// remove leading spaces
	while(iswspace(*pwcsSecurity))
		pwcsSecurity++;

	// null input
	if ( !(*pwcsSecurity) || !_wcsicmp(pwcsSecurity, L"null") )
		return 0;

	
	// alocate and initialize a security descriptor
	pSecurityDescriptor = (PSECURITY_DESCRIPTOR)new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
	if ( !InitializeSecurityDescriptor( pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION) )
	{
        DWORD gle = GetLastError();
		delete [] ((BYTE*)pSecurityDescriptor);
		return gle;
	}

	// alocate and initialize an access-control list
	pAcl = (PACL)new BYTE[sizeof(ACL)];
	if (!InitializeAcl( pAcl, sizeof(ACL), ACL_REVISION) )
	{
        DWORD gle = GetLastError();
		delete [] ((BYTE*)pSecurityDescriptor);
		delete [] ((BYTE*)pAcl);
		return gle;
	}

	DWORD dwSidSize = SID_USUAL_SIZE;
	pSid = (PSID)new BYTE[dwSidSize];
		
	
	// go over all rights
	pwcsRight = wcstok( pwcsSecurity, L";");
	while ( pwcsRight )
	{
		DWORD dwError =  fAddAce( pwcsRight,
								  pSecInfo, 
								  pSecurityDescriptor,
								  &pSid,
								  &dwSidSize,
								  &pAcl);
		if(dwError)
		{
			delete [] ((BYTE*)pSid);
			delete [] ((BYTE*)pAcl);
			delete [] ((BYTE*)pSecurityDescriptor);		
			return dwError;
		}

		pwcsRight = wcstok( NULL, L";");
	}

	DWORD dwStatus = 0;
	// add the dacl
	if(SetSecurityDescriptorDacl( pSecurityDescriptor, TRUE, pAcl, FALSE ))
	{
		// make the security descriptor a self realtive one
		DWORD dwSDLen = 0;
		MakeSelfRelativeSD( pSecurityDescriptor, NULL, &dwSDLen );
		dwStatus =  GetLastError();
		if(dwStatus == ERROR_INSUFFICIENT_BUFFER)
		{
			dwStatus = 0;
			*ppSD = (PSECURITY_DESCRIPTOR)new BYTE[dwSDLen];
 			if(!MakeSelfRelativeSD( pSecurityDescriptor, *ppSD, &dwSDLen ))
			{
				dwStatus = GetLastError();
				delete [] ((BYTE*)(*ppSD));
				*ppSD = NULL;
			}
		}
	}
	else
	{
		dwStatus = GetLastError();
	}
			
	delete [] ((BYTE*)pSid);
	delete [] ((BYTE*)pAcl);
	delete [] ((BYTE*)pSecurityDescriptor);

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED_)
#define AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED_

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>


const TraceIdEntry Tgu = L"Trigger Utilities";

//---------------------------------------------------------------------------------
// CUSTOM ADDITION END HERE.
//---------------------------------------------------------------------------------

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\cinputparams.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	CInputParams.cpp    

Abstract:
    CInputParams implementation

Author:
   Ofer Gigi		
   Yifat Peled 31-Aug-98

--*/

#include "stdafx.h"
#include "CInputParams.h"

#include "cinputparams.tmh"


/*++
Routine Description:
    This routine takes the arguments from the command line
    and puts them into a container. Each token 
    ("/command:value") is already apart from the other tokens.

Arguments:
    argc(IN) - number of arguments in the command line.
    argv(IN) - the arguments in the command line.
        
Return Value:
    none.

Note:
    When you are creating this object using THIS constructor
    the first argument is THE NAME OF THE PROGRAM so this 
    argument is not included in the container. 
--*/
CInputParams::CInputParams(int argc, WCHAR*	argv[])
{
    for (int i=1; i < argc; i++)
    {
        ParseToken(argv[i], 0, wstring::npos);
    }
}


/*++
Routine Description:
    This routine takes the string from the command line,
    then takes the tokens ("/command:value") from it and
    puts them into a container. 

Arguments:
    str (IN) - all the arguments contained in one string.

Return Value:
    none.
--*/
CInputParams::CInputParams(const wstring& wcs)
{
    wstring::size_type tokenstart=0;
    wstring::size_type tokenfinish=0;
	
    while ((tokenstart != wstring::npos) && (tokenfinish != wstring::npos))
    {
        tokenstart = wcs.find_first_not_of(L' ',tokenfinish);
        if (tokenstart != wstring::npos)
        {
            tokenfinish = wcs.find_first_of(L' ',tokenstart);     
            if (tokenfinish == wstring::npos)
            {
                ParseToken(wcs, tokenstart, tokenfinish);
            }
            else
            {
                ParseToken(wcs, tokenstart, tokenfinish - 1); 
            }
        }
    }
}

/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    wcs (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/
void CInputParams::ParseToken(const wstring& wcs,
                               wstring::size_type tokenstart,
                               wstring::size_type tokenfinish)
{
    wstring command;
    wstring value;
    wstring::size_type commandstart;
    wstring::size_type valuestart;

	commandstart = wcs.find(L"/", tokenstart);
	if(commandstart != wstring::npos)
		commandstart += 1;
    valuestart = wcs.find(L":", tokenstart);
	if(valuestart != wstring::npos)
		valuestart += 1;
	
	if ((commandstart != wstring::npos) &&
		(commandstart >= tokenstart) &&
		(commandstart <= tokenfinish))
	{
		if (// command option with parameters
			(valuestart != wstring::npos) &&
			(commandstart < valuestart) &&
			(valuestart >= tokenstart) &&
			(valuestart <= tokenfinish))
		{
			command = wcs.substr(commandstart, valuestart - commandstart - 1);
			if (tokenfinish != wstring::npos)
			{
				value = wcs.substr(valuestart, tokenfinish - valuestart + 1);
			}
			else
			{ 
				value = wcs.substr(valuestart);
			}
			
			wstring wcsUpperCommand = Covert2Upper(command);
			m_InputParams[wcsUpperCommand] = value;
		}
	    else if ( // command option with no parameters
				 (valuestart == wstring::npos) || (valuestart > tokenfinish))
		{
			if (tokenfinish != wstring::npos)
			{
				if(wcs[tokenfinish] == L':')
					command = wcs.substr(commandstart, tokenfinish - commandstart);
				else
					command = wcs.substr(commandstart, tokenfinish - commandstart + 1);
			}
			else 
			{
				command = wcs.substr(commandstart);
			}
			wstring wcsUpperCommand = Covert2Upper(command);
			m_InputParams[wcsUpperCommand] = L"";
		}
	}
}

/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    wcs (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/
bool CInputParams::IsOptionGiven(const wstring& wcsOption) const
{
	wstring wcsUpperOption = Covert2Upper(wcsOption);
	map<wstring, wstring>::const_iterator it = m_InputParams.find(wcsUpperOption);	

    return (it != m_InputParams.end());
}

/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    wcs (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/
wstring CInputParams::operator[](const wstring& wcsOption)
{
    if (IsOptionGiven(wcsOption))
    {
		wstring wcsUpperOption = Covert2Upper(wcsOption);
		return m_InputParams[wcsUpperOption];
    }
    else
    {    
       return L"";
    }
}


wstring CInputParams::Covert2Upper(const wstring& wcs) const
{
	WCHAR* pwcsUpper = new WCHAR[wcs.length() + 1];
	wcscpy(pwcsUpper, wcs.c_str());
	CharUpper(pwcsUpper);
	return wstring(pwcsUpper);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\strparse.cpp ===
//*****************************************************************************
//
// Class Name  : CStringTokens
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a limited feature string parser. Allows the user of 
//               this class to parse a string and access the resulting tokens 
//               based on an index value.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/20/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "strparse.hpp"

#include "strparse.tmh"

using namespace std;

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Creates an empty instance.
//
//*****************************************************************************
CStringTokens::CStringTokens()
{
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Destroys the string tokens object - free all the 
//               allocated strings in the token list. 
//
//*****************************************************************************
CStringTokens::~CStringTokens()
{
	m_lstTokens.erase(m_lstTokens.begin(), m_lstTokens.end());
}

//*****************************************************************************
//
// Method      : Parse
//
// Description : Parse the supplied string into tokens. It uses the supplied 
//               delimiter string to determine where tokens start and end within
//               the supplied source string. The tokens are stored in a member
//               variable list of tokens for subsequent access.
//
//*****************************************************************************
void 
CStringTokens::Parse(
	const _bstr_t& bstrString, 
	WCHAR delimiter
	)
{
	//
	// remove previous data
	//
	m_lstTokens.erase(m_lstTokens.begin(), m_lstTokens.end());

	for(LPCWSTR pStart = static_cast<LPCWSTR>(bstrString); pStart != NULL;)
	{
		wstring token;
		LPCWSTR p = pStart;
		LPCWSTR pEnd;

		for(;;)
		{
			pEnd = wcschr(p, delimiter);

			if (pEnd == NULL)
			{
				DWORD len = wcslen(pStart);
				token.append(pStart, len);
				break;
			}

			//
			// Check that this is a valid delimeter
			// 
			if((p != pEnd) && (*(pEnd - 1) == L'\\'))
			{
				DWORD len = numeric_cast<DWORD>(pEnd - pStart - 1);
				token.append(pStart, len);
				token.append(pEnd, 1);

				p = pStart = pEnd + 1;
				continue;
			}
		
			//
			// Test, we are not in exiting a quoted item
			//
			DWORD NoOfQuote = 0;
			LPCWSTR pQuote;
			for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
			{	
				++NoOfQuote;
				++pQuote;
			}

			if ((NoOfQuote % 2) == 1)
			{
				p = wcschr(pEnd + 1, L'\"');
				if (p == NULL)
					throw exception();
				continue;
			}

			//
			// copy the token and insert it to token list 
			// 
			DWORD len = numeric_cast<DWORD>(pEnd - pStart);
			token.append(pStart, len);

			break;
		}

		
		if (token.length() > 0)
		{
			m_lstTokens.push_back(token);
		}

		pStart = (pEnd == NULL)	? NULL : pEnd + 1;
	}
}

//*****************************************************************************
//
// Method      : GetToken 
//
// Description : Returns the token at the specific index.
//
//*****************************************************************************
void 
CStringTokens::GetToken(
	DWORD tokenIndex,
	_bstr_t& strToken
	)
{
	DWORD index = 0;

	if (index > GetNumTokens())
		throw exception();

	for (TOKEN_LIST::iterator it = m_lstTokens.begin();	 it != m_lstTokens.end(); ++it, ++index)
	{
		if (index == tokenIndex)
		{
			strToken = it->c_str();
			return;
		}
	}
}

//*****************************************************************************
//
// Method      : GetNumTokens 
//
// Description : Returns the current number of tokens in the list
//
//*****************************************************************************
DWORD CStringTokens::GetNumTokens()
{
	return numeric_cast<DWORD>(m_lstTokens.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\stdfuncs.cpp ===
//*****************************************************************************
//
// File Name   : stdfuncs.cpp
//
// Author      : James Simpson (Microsoft Consulting Services)
//
// Description : This file contains the implementation of standard utility
//               functions that are shared accross the MSMQ triggers projects.
//
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/06/99 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "stdfuncs.hpp"

#define DLL_IMPORT
#define AFXAPI __stdcall

#include "_guid.h"

#include "stdfuncs.tmh"

//*****************************************************************************
//
// Function    : FormatBSTR
//
// Description :
//
//*****************************************************************************
void _cdecl FormatBSTR(_bstr_t * pbstrString, LPCTSTR lpszMsgFormat, ...)
{
	long lCharsWritten = 0;
	long lStringBufferSize = 0;
	TCHAR * pszStringMsg = NULL;
	bool bStringBufferBigEnough = false;

	ASSERT(pbstrString != NULL);
	ASSERT(lpszMsgFormat != NULL);

	va_list argList;
	va_start(argList, lpszMsgFormat);

	do
	{
		lStringBufferSize = lStringBufferSize + STRING_MSG_BUFFER_SIZE;
		
		if (pszStringMsg != NULL)
		{
			free(pszStringMsg);
		}

		pszStringMsg = (TCHAR*)malloc(lStringBufferSize*(sizeof(TCHAR)));

		ZeroMemory(pszStringMsg,lStringBufferSize);

		lCharsWritten = _vsntprintf(pszStringMsg,lStringBufferSize,lpszMsgFormat, argList);

		if ((lCharsWritten > 0) && (lCharsWritten < lStringBufferSize))
		{
			bStringBufferBigEnough = true;
		}

	}while (bStringBufferBigEnough == false);

	// Assign the string buffer value.
	(*pbstrString) = pszStringMsg;

	// Free the String message buffer
	if (pszStringMsg != NULL)
	{
		free(pszStringMsg);
	}

	va_end(argList);
}

//*****************************************************************************
//
// Function    : GetTimeAsBSTR
//
// Description :
//
//*****************************************************************************
void GetTimeAsBSTR(_bstr_t& bstrTime)
{
	SYSTEMTIME theTime;

	// Get the current time
	GetLocalTime(&theTime);
	FormatBSTR(&bstrTime,_T("%d%02d%02d %d:%d:%d:%d "),theTime.wYear,theTime.wMonth,theTime.wDay,theTime.wHour,theTime.wMinute,theTime.wSecond,theTime.wMilliseconds);
}


_bstr_t CreateGuidAsString(void)
{
	GUID guid;
	CoCreateGuid(&guid);

	GUID_STRING strGuid;
	MQpGuidToString(&guid, strGuid);

	return strGuid;
}


void ObjectIDToString(const OBJECTID *pID, WCHAR *wcsResult, DWORD dwSize)
{

   StringFromGUID2(pID->Lineage, wcsResult, dwSize);

   WCHAR szI4[12];

   _ltow(pID->Uniquifier, szI4, 10);

   wcscat(wcsResult, L"\\") ;
   wcscat(wcsResult, szI4) ;
}

//*****************************************************************************
//
// Function    : ConvertFromByteArrayToString
//
// Description : converts a one dimensional byte array into a BSTR
//               type in-situ. Note that this method will clear the
//               supplied byte array & release it's memory alloc.
//
//*****************************************************************************
HRESULT ConvertFromByteArrayToString(VARIANT * pvData)
{
	HRESULT hr = S_OK;
	BYTE * pByteBuffer = NULL;
	BSTR bstrTemp = NULL;

	// ensure we have been passed valid parameters
	ASSERT(pvData != NULL);
	ASSERT(pvData->vt == (VT_UI1 | VT_ARRAY));
	ASSERT(pvData->parray != NULL);

	// get a pointer to the byte data
	hr = SafeArrayAccessData(pvData->parray,(void**)&pByteBuffer);

	if SUCCEEDED(hr)
	{
		// determine the size of the data to be copied into the BSTR
		long lLowerBound = 0;
		long lUpperBound = 0;
		
		hr = SafeArrayGetLBound(pvData->parray,1,&lLowerBound);

		if SUCCEEDED(hr)
		{
			hr = SafeArrayGetUBound(pvData->parray,1,&lUpperBound);
		}

		if SUCCEEDED(hr)
		{
			DWORD dwDataSize = (lUpperBound - lLowerBound) + 1;

			// allocate a BSTR based on the contents & size of the byte buffer
			bstrTemp = SysAllocStringLen((TCHAR*)pByteBuffer,dwDataSize/sizeof(TCHAR));

			if (bstrTemp == NULL)
			{
				hr = E_FAIL;
			}
		}
	
		// release the safe array (only if we got access to it originally)
		if (pByteBuffer != NULL)
		{
			hr = SafeArrayUnaccessData(pvData->parray);
		}

		// clear the caller supplied variant - note this will deallocate the safe-array
		if SUCCEEDED(hr)
		{
			hr = VariantClear(pvData);
		}

		// attach BSTR representation of the byte array
		if SUCCEEDED(hr)
		{
			pvData->vt = VT_BSTR;
			pvData->bstrVal = bstrTemp;
		}
	}

	return(hr);
}

//*****************************************************************************
//
// Function    : GetDateVal
//
// Description : helper: gets a VARIANT VT_DATE or VT_DATE | VT_BYREF
//               returns 0 if invalid
//
//*****************************************************************************
static double GetDateVal(VARIANT *pvar)
{
	ASSERT(pvar != NULL);

    if (pvar)
	{
		if (pvar->vt == (VT_DATE | VT_BYREF))
		{
			return *V_DATEREF(pvar);
		}
		else if (pvar->vt == VT_DATE)
		{
			return V_DATE(pvar);
		}
    }

    return 0;
}

//*****************************************************************************
//
// Function    : SystemTimeOfTime
//
// Description : Converts time into systemtime. Returns TRUE if able to do the
//               conversion, FALSE otherwise.
//
// Parameters  : iTime [in] time
//               psystime [out] SYSTEMTIME
//
// Notes       : Handles various weird conversions: off-by-one months, 1900 blues.
//
//*****************************************************************************
static BOOL SystemTimeOfTime(time_t iTime, SYSTEMTIME *psystime)
{
    tm *ptmTime;

	ASSERT(psystime != NULL);

    ptmTime = localtime(&iTime);

    if (ptmTime == NULL)
	{
		//
		// can't convert time
		//
		return FALSE;
    }

    psystime->wYear = numeric_cast<USHORT>(ptmTime->tm_year + 1900);
    psystime->wMonth = numeric_cast<USHORT>(ptmTime->tm_mon + 1);
    psystime->wDayOfWeek = numeric_cast<USHORT>(ptmTime->tm_wday);
    psystime->wDay = numeric_cast<USHORT>(ptmTime->tm_mday);
    psystime->wHour = numeric_cast<USHORT>(ptmTime->tm_hour);
    psystime->wMinute = numeric_cast<USHORT>(ptmTime->tm_min);
    psystime->wSecond = numeric_cast<USHORT>(ptmTime->tm_sec);
    psystime->wMilliseconds = 0;

    return TRUE;
}

//*****************************************************************************
//
// Function    : TimeOfSystemTime
//
// Converts systemtime into time
//
// Parameters:
//    [in] SYSTEMTIME
//
// Output:
//    piTime       [out] time
//
// Notes:
//    Various weird conversions: off-by-one months, 1900 blues.
//
//*****************************************************************************
static BOOL TimeOfSystemTime(SYSTEMTIME *psystime, time_t *piTime)
{
    tm tmTime;

    tmTime.tm_year = psystime->wYear - 1900;
    tmTime.tm_mon = psystime->wMonth - 1;
    tmTime.tm_wday = psystime->wDayOfWeek;
    tmTime.tm_mday = psystime->wDay;
    tmTime.tm_hour = psystime->wHour;
    tmTime.tm_min = psystime->wMinute;
    tmTime.tm_sec = psystime->wSecond;

    //
    // set daylight savings time flag from localtime() #3325 RaananH
    //
    time_t tTmp = time(NULL);
    struct tm * ptmTmp = localtime(&tTmp);
    if (ptmTmp)
    {
        tmTime.tm_isdst = ptmTmp->tm_isdst;
    }
    else
    {
        tmTime.tm_isdst = -1;
    }

    *piTime = mktime(&tmTime);
    return (*piTime != -1); //#3325
}


//*****************************************************************************
//
// Function    : TimeToVariantTime
//
//  Converts time_t to Variant time
//
// Parameters:
//    iTime       [in] time
//    pvtime      [out]
//
// Output:
//    TRUE if successful else FALSE.
//
//*****************************************************************************
static BOOL TimeToVariantTime(time_t iTime, double *pvtime)
{
    SYSTEMTIME systemtime;

    if (SystemTimeOfTime(iTime, &systemtime))
	{
		return SystemTimeToVariantTime(&systemtime, pvtime);
    }

    return FALSE;
}

//*****************************************************************************
//
// Function    : VariantTimeToTime
//
//  Converts Variant time to time_t
//
// Parameters:
//    pvarTime   [in]  Variant datetime
//    piTime     [out] time_t
//
// Output:
//    TRUE if successful else FALSE.
//
//*****************************************************************************
static BOOL VariantTimeToTime(VARIANT *pvarTime, time_t *piTime)
{
    // WORD wFatDate, wFatTime;
    SYSTEMTIME systemtime;
    double vtime;

    vtime = GetDateVal(pvarTime);
    if (vtime == 0) {
      return FALSE;
    }
    if (VariantTimeToSystemTime(vtime, &systemtime)) {
      return TimeOfSystemTime(&systemtime, piTime);
    }
    return FALSE;
}

//*****************************************************************************
//
// Function    : GetVariantTimeOfTime
//
// Converts time to variant time
//
// Parameters:
//    iTime      [in]  time to convert to variant
//    pvarTime - [out] variant time
//
//*****************************************************************************
HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime)
{
    double vtime;
    VariantInit(pvarTime);
    if (TimeToVariantTime(iTime, &vtime)) {
      V_VT(pvarTime) = VT_DATE;
      V_DATE(pvarTime) = vtime;
    }
    else {
      V_VT(pvarTime) = VT_ERROR;
      V_ERROR(pvarTime) = 13; // UNDONE: VB type mismatch
    }
    return NOERROR;
}

//*****************************************************************************
//
// Function    : BstrOfTime
//
// Description : Converts time into a displayable string in user's locale
//
// Parameters  :  [in] iTime time_t
//                [out] BSTR representation of time
//
//*****************************************************************************
static BSTR BstrOfTime(time_t iTime)
{
    SYSTEMTIME sysTime;
    CHAR bufDate[128], bufTime[128];
    WCHAR wszTmp[128];
    UINT cchDate, cbDate, cbTime;
    BSTR bstrDate = NULL;

	// Initialize buffers.
	ZeroMemory(&bufDate,sizeof(bufDate));
	ZeroMemory(&bufTime,sizeof(bufTime));
	ZeroMemory(&wszTmp,sizeof(wszTmp));

	// Convert time_t to a SYSTEMTIME structure
    SystemTimeOfTime(iTime, &sysTime);
	
	// format the date portion
    cbDate = GetDateFormatA(
              LOCALE_USER_DEFAULT,
              DATE_SHORTDATE, // flags specifying function options
              &sysTime,       // date to be formatted
              0,              // date format string - zero means default for locale
              bufDate,        // buffer for storing formatted string
              sizeof(bufDate) // size of buffer
              );

    if (cbDate == 0)
	{
      ASSERT(GetLastError() == 0);

 //     IfNullGo(cbDate);
    }

    // add a space
    bufDate[cbDate - 1] = ' ';
    bufDate[cbDate] = 0;  // null terminate

    cbTime = GetTimeFormatA(
              LOCALE_USER_DEFAULT,
              TIME_NOSECONDS, // flags specifying function options
              &sysTime,       // date to be formatted
              0,              // time format string - zero means default for locale
              bufTime,        // buffer for storing formatted string
              sizeof(bufTime)); // size of buffer

    if (cbTime == 0)
	{
      ASSERT(GetLastError() == 0);
//      IfNullGo(cbTime);
    }
    //
    // concat
    //
    strcat(bufDate, bufTime);
    //
    // convert to BSTR
    //
    cchDate = MultiByteToWideChar(CP_ACP,
                                  0,
                                  bufDate,
                                  -1,
                                  wszTmp,
                                  sizeof(wszTmp)/sizeof(WCHAR));
    if (cchDate != 0)
	{
      bstrDate = SysAllocString(wszTmp);
    }
    else
	{
      ASSERT(GetLastError() == 0);
    }

    // fall through...

    return bstrDate;
}


//*****************************************************************************
//
// Method      : GetNumericConfigParm
//
// Description : Retreives a specific registry numeric value. Inserts
//               a default value if the requested key could not found
//
//*****************************************************************************
bool GetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD * pdwValue,DWORD dwDefaultValue)
{
	bool bFoundParm = false;
	long lKeyOpened = 0;
	long lFoundValue = 0;
	long lKeyCreated = 0;
	CRegKey oRegKey;
	DWORD dwDisposition = 0;
	DWORD dwValue = 0;

	// Ensure that we have been passed valid parameters.
	ASSERT(pdwValue != NULL);
	ASSERT(lpszParmName != NULL);

	// Open the parameters registry key.
	lKeyOpened = oRegKey.Open(HKEY_LOCAL_MACHINE,(LPCTSTR)lpszParmKeyName,KEY_ALL_ACCESS);

	// Test to see if we opened the key successfully.
	if (lKeyOpened == ERROR_SUCCESS)
	{
		// Key was opened OK - now get the value.
		lFoundValue = oRegKey.QueryValue(dwValue,lpszParmName);

		// Check if we found the key-value
		if (lFoundValue == ERROR_SUCCESS)
		{
			// Assign the retrieved value
			(*pdwValue) = dwValue;

			// Set the flag to indicate that we did find the value.
			bFoundParm = true;
		}
		else
		{
			// The Key Value was not there. If we have been supplied
			// a default value, we will set the value name using the
			// default and then return the default.
			oRegKey.SetValue(dwDefaultValue,lpszParmName);

			// Assign the default value
			(*pdwValue) = dwDefaultValue;

			// Set the flag to indicate that we did 'find' the value.
			bFoundParm = true;			

		}
	}
	else
	{
		// We could not find the required key. Insert the default value.
		lKeyCreated = oRegKey.Create(HKEY_LOCAL_MACHINE,
									 (LPCTSTR)lpszParmKeyName,
									 REG_NONE,
									 REG_OPTION_NON_VOLATILE,
									 KEY_ALL_ACCESS,
									 NULL,
									 &dwDisposition);

		// Set the value using the default.
		oRegKey.SetValue(dwDefaultValue,lpszParmName);

		// Assign the default value
		(*pdwValue) = dwDefaultValue;
		
	}

	return(bFoundParm);
}

//*****************************************************************************
//
// Method      : SetNumericConfigParm
//
// Description : Sets a numeric registry value. Returns ERROR_SUCCESS
//               on success, otherwise returns the last Win32 error code.
//               Note that this method will create a key if it is not
//               found.
//
//*****************************************************************************
long SetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD dwValue)
{
	long lRetCode = ERROR_SUCCESS;
	CRegKey oRegKey;

	// Ensure that we have been passed valid parameters.
	ASSERT(lpszParmKeyName != NULL);
	ASSERT(lpszParmName != NULL);

	// Attempt to open the registry key.
	lRetCode = oRegKey.Open(HKEY_LOCAL_MACHINE,lpszParmKeyName,KEY_ALL_ACCESS);

	// Check if we found the key-value
	if ((lRetCode == ERROR_SUCCESS) || (lRetCode == ERROR_FILE_NOT_FOUND))
	{
		// set the key value
		oRegKey.SetValue(dwValue,lpszParmName);

		return(ERROR_SUCCESS);
	}
	else
	{
		return ((long)::GetLastError());
	}
}


bool UpdateMachineNameInQueuePath(_bstr_t bstrOldQPath, _bstr_t MachineName, _bstr_t* pbstrNewQPath)
{
	std::wstring wcsOldQPath = (wchar_t*)(bstrOldQPath);
	if(wcsOldQPath[0] == L'.')
	{
		std::wstring wcsNewQPath;
		
		wcsNewQPath = (wchar_t*)MachineName;
		wcsNewQPath += wcsOldQPath.substr(1);

		*pbstrNewQPath = wcsNewQPath.c_str();
		return true;
	}
	else
	{
		*pbstrNewQPath = bstrOldQPath;
		return false;
	}
}


DWORD GetLocalMachineName(_bstr_t* pbstrMachine)
{
    // XP SP1 bug 594143. (prefast).
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
	DWORD dwComputerNameBufferSize = TABLE_SIZE(szComputerName);

	//
    // get the current machine name (we use this as a default value)
	//
	BOOL fRet = GetComputerName((LPTSTR)&szComputerName,&dwComputerNameBufferSize);
	if(fRet == FALSE)
	{
		return GetLastError();
	}

	*pbstrMachine = szComputerName;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\queueutil.cpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Yifat Peled
//
// Description :
//
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 4/07/99	| yifatp	| Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include <mq.h>
#include <mqprops.h>
#include <fntoken.h>

#include "stdfuncs.hpp"

#import "mqtrig.tlb" no_namespace

#include "QueueUtil.hpp"
#include "mqsymbls.h"
#include "GenMQSec.h"

#include "queueutil.tmh"

using namespace std;

//
// Define the maximum size of the format queue name
//
#define MAX_Q_FORMAT_NAME_LEN  512


//********************************************************************************
//
// Name		: OpenQueue		
//
// Desc		: Opens the MSMQ queue that is specified by the queue path parameter.
//			  This method will create the queue if indicated to and if it does not already
//            exist and it should be local.
//
// Returns	: HRESULT (S_OK on success, S_FAIL otherwise)
//
//
//********************************************************************************
HRESULT OpenQueue(
			_bstr_t bstrQueuePath,
			DWORD dwAction,
			bool fCreateIfNotExist,
			QUEUEHANDLE * pQHandle,
			_bstr_t* pbstrFormatName
			)
{	
	HRESULT hr = S_OK;

	(*pbstrFormatName) = _T("");
	bool fQueueCreated = false;

	MQQUEUEPROPS QueueProps;
	PROPVARIANT aVariant[2];
	QUEUEPROPID aPropId[2];
	DWORD PropIdCount = 0;

	// Validate that we have been supplied with a valid queue access parameter
	if ((dwAction != MQ_SEND_ACCESS) && (dwAction != MQ_PEEK_ACCESS) && (dwAction != MQ_RECEIVE_ACCESS))
	{
		// create the rich error info object.
		//
		// ISSUE: Need to return appropriate code
		//
		TrERROR(Tgu, "The supplied queue access parameter is not valid. The supplied value was (%d). Valid values are (%d, %d, %d).",dwAction,(long)MQ_SEND_ACCESS,(long)MQ_PEEK_ACCESS,(long)MQ_RECEIVE_ACCESS);
		return MQTRIG_INVALID_PARAMETER;
	}

	bool fQueueIsLocal = true;
	bool fQueueIsPrivate = true;
	SystemQueueIdentifier SystemQueue = IsSystemQueue(bstrQueuePath);

	if(SystemQueue == SYSTEM_QUEUE_NONE)
	{
		fQueueIsLocal = IsQueueLocal(bstrQueuePath);
		fQueueIsPrivate = IsPrivateQPath((TCHAR*)bstrQueuePath);

		if(fCreateIfNotExist && fQueueIsLocal)
		{
			//we create only private queues for the service
			// Public queue creation will need further handling because of replication
			//
			ASSERT(fQueueIsPrivate);

			DWORD dwFormatNameLen = 0;
			TCHAR szFormatName[MAX_Q_FORMAT_NAME_LEN];

			// Initialize the buffer that will be used to hold the format name
			ZeroMemory(szFormatName,sizeof(szFormatName));
			dwFormatNameLen = sizeof(szFormatName) / sizeof(TCHAR);

			//Set the PROPID_Q_PATHNAME property.
			aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
			aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
			aVariant[PropIdCount].pwszVal = (wchar_t*)bstrQueuePath;

			PropIdCount++;

			//Set the MQQUEUEPROPS structure.
			QueueProps.cProp = PropIdCount;           //No of properties
			QueueProps.aPropID = aPropId;             //Ids of properties
			QueueProps.aPropVar = aVariant;           //Values of properties
			QueueProps.aStatus = NULL;                //No error reports

			PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
			SECURITY_INFORMATION* pSecInfo = NULL;
			wstring wscSecurity = L"+:* A";
			
			DWORD dwError = GenSecurityDescriptor(
								pSecInfo,
								wscSecurity.c_str(),
								&pSecurityDescriptor );

			if(dwError != 0)
			{
				TrERROR(Tgu, "Failed to create security descriptor");					
				return MQTRIG_ERROR;
			}

			// Attempt to create the notifications queue.
			hr = MQCreateQueue(
					pSecurityDescriptor,
					&QueueProps,
					szFormatName,
					&dwFormatNameLen );
			
			//Clean allocated memory
			if ( pSecurityDescriptor != NULL )
				delete pSecurityDescriptor;

			// Check if the queue already existed or if we got an error etc...
			switch(hr)
			{
				case MQ_OK: // this is OK - do nothing
					(*pbstrFormatName) = szFormatName;
					fQueueCreated = true;
					break;

				case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL: //queue was created, we just don't have the format name
					fQueueCreated = true;
					hr = MQ_OK;
					break;

				case MQ_ERROR_QUEUE_EXISTS: // this is OK - remap return code to success.
					hr = MQ_OK;
					break;
				
				default: // Error
				{
					// Build some error context info (note that we do this before we assign general error code to HRESULT)
					TrERROR(Tgu, "Failed to create the queue %ls.The HRESULT from MSMQ was (%X)", (wchar_t*)bstrQueuePath, hr);					
					return MQTRIG_ERROR;
				}
			}
			
		}
	}
	else //system queue, format name is given instead of path name
	{
		(*pbstrFormatName) = bstrQueuePath;
	}

		
	//
	// Since on NT4 direct format name for send is not available for receive,
	// we'll use the regular format name for local queues that we have from MQCreateQueue
	//
	if((*pbstrFormatName) == _bstr_t(_T("")))
	{
		(*pbstrFormatName) = GetDirectQueueFormatName(bstrQueuePath);
	}
	
	// Attempt to open the message queue
	hr = MQOpenQueue(
			(*pbstrFormatName),
			(DWORD)dwAction,
			MQ_DENY_NONE,
			pQHandle );

	if(FAILED(hr))
	{
		//
		// again for NT4 machines we can only try to open public queues using regular
		// format name instead of direct
		//
		if(hr == MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION)
		{
			ASSERT(SystemQueue == SYSTEM_QUEUE_NONE);

			//for local queues or public remote queues (which were not created by this function)
			// we can use MQPathNameToFormatName
			if(fQueueIsLocal || (!fQueueIsPrivate && !fQueueCreated) )
			{
				DWORD dwLength = MAX_Q_FORMAT_NAME_LEN;
				AP<TCHAR> ptcs = new TCHAR[MAX_Q_FORMAT_NAME_LEN + 1];

				hr = MQPathNameToFormatName(
									(TCHAR*)bstrQueuePath,
									(TCHAR*)ptcs,
									&dwLength);
				
				if( hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)	
				{
					//
					// re-alloc a larger buffer for format name
					//
					delete [] ptcs.detach();
					ptcs = new TCHAR[dwLength + 1];
					
					hr = MQPathNameToFormatName(
								(TCHAR*)bstrQueuePath,
								(TCHAR*)ptcs,
								&dwLength );

					ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
				}

				if(FAILED(hr))
				{
					TrERROR(Tgu, "Failed to get format name for the queue %ls. HRESULT = %X",(LPCWSTR)bstrQueuePath, hr);
					return hr;
				}

				(*pbstrFormatName) = ptcs;

				// Attempt to open the message queue
				hr = MQOpenQueue(
							(*pbstrFormatName),
							(DWORD)dwAction,
							MQ_DENY_NONE,
							pQHandle );
			}
		}
	
		if(FAILED(hr))
		{
			TrERROR(Tgu, "Failed to open the queue %ls. HRESULT = %X",(LPCWSTR)bstrQueuePath, hr);
			return hr;
		}
	}	

	return S_OK;
}


_bstr_t GetDirectQueueFormatName(_bstr_t bstrQueuePath)
{
	bstr_t bstrDirectFormatName = L"DIRECT=OS:";
	bstrDirectFormatName += bstrQueuePath;

	return bstrDirectFormatName;
}

bool IsPrivateQPath(wstring wcsQPath)
{
	AP<WCHAR> pwcs = new WCHAR[wcsQPath.length() + 1];
	wcscpy(pwcs, wcsQPath.c_str());
	CharLower(pwcs);

	wstring wcs = pwcs;

	return ( wcs.find(L"private$") != wstring::npos );
}


bool IsQueueLocal(_bstr_t bstrQueuePath)
{
	_bstr_t bstrLocalComputerName;
	DWORD dwError = GetLocalMachineName(&bstrLocalComputerName);
	
    ASSERT(dwError == 0);//BUGBUG - should throw an exception
    DBG_USED(dwError);

	// get the machine name from the queue path
	std::wstring wcsQueuePath = (wchar_t*)bstrQueuePath;
	std::wstring::size_type pos = wcsQueuePath.find_first_of(L"\\");
	bstr_t bstrMachineName = wcsQueuePath.substr(0, pos).c_str();
	
	if(bstrMachineName == _bstr_t(L".") || bstrMachineName == bstrLocalComputerName )
		return true;

	return false;
}

SystemQueueIdentifier IsSystemQueue(_bstr_t QueueName)
{
	LPCWSTR systemQueueType = wcschr(static_cast<LPCWSTR>(QueueName), FN_SUFFIX_DELIMITER_C);

	if (systemQueueType	== NULL)
		return SYSTEM_QUEUE_NONE;

	if( _wcsicmp(systemQueueType, FN_JOURNAL_SUFFIX) == 0)
		return SYSTEM_QUEUE_JOURNAL;

	if(_wcsicmp(systemQueueType, FN_DEADLETTER_SUFFIX) == 0)
		return SYSTEM_QUEUE_DEADLETTER;

	if(_wcsicmp(systemQueueType, FN_DEADXACT_SUFFIX) == 0)
		return SYSTEM_QUEUE_DEADXACT;

	return SYSTEM_QUEUE_NONE;
}


//
// DIRECT=OS:<computerName>\SYSTEM$;<suffix>
//
#define x_SystemQueueFormat FN_DIRECT_TOKEN	FN_EQUAL_SIGN FN_DIRECT_OS_TOKEN L"%s" \
                            FN_PRIVATE_SEPERATOR SYSTEM_QUEUE_PATH_INDICATIOR L"%s"

HRESULT GenSystemQueueFormatName(SystemQueueIdentifier SystemQueue, _bstr_t* pbstrFormatName)
{
	WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
	DWORD size = TABLE_SIZE(computerName);

	if (!GetComputerName(computerName, &size))
		return GetLastError();

	LPCWSTR pSuffixType;

	switch(SystemQueue)
	{
	case SYSTEM_QUEUE_JOURNAL:
		pSuffixType = FN_JOURNAL_SUFFIX;
		break;
	
	case SYSTEM_QUEUE_DEADLETTER:
		pSuffixType = FN_DEADLETTER_SUFFIX;
		break;

	case SYSTEM_QUEUE_DEADXACT:
		pSuffixType = FN_DEADXACT_SUFFIX;
		break;

	default:
		ASSERT(0);
		return S_FALSE;
	}

	WCHAR formatName[512];
	int n = _snwprintf(formatName, TABLE_SIZE(formatName), x_SystemQueueFormat, computerName, pSuffixType);
    // XP SP1 bug 594251.
	formatName[ TABLE_SIZE(formatName) - 1 ] = L'\0' ;

	if (n < 0)
		return S_FALSE;

	(*pbstrFormatName) = formatName;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\trigger\trigutil\triginfo.cpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeTriggerInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
//
// Description : This class encapsulates information about a trigger, as well as
//               being the interface to the underlying trigger data store. This
//               class can be used on its own to store trigger information at
//               runtime, and it can also wrapped in COM class to provide COM
//               access to the underlying trigger data.
//
// Notes       : The current implementation uses the registry as the storage
//               medium.
//
//               This class is used by both the trggers service and the trigger
//               COM components.
//
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 18/12/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include <mq.h>
#include "mqtg.h"
#include "stdfuncs.hpp"

#import "mqtrig.tlb" no_namespace

#include "QueueUtil.hpp"
#include "triginfo.hpp"
#include "Cm.h"
#include "mqsymbls.h"

#include "triginfo.tmh"

using namespace std;

#define ATTACH_RULE_PREFIX L"Rule"

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initializes an empty instance of the CRuntimeTriggerInfo class
//
//*****************************************************************************
CRuntimeTriggerInfo::CRuntimeTriggerInfo( LPCTSTR pwzRegPath )
{
	m_bstrTriggerID = _T("");
	m_bstrTriggerName = _T("");
	m_bstrQueueName = _T("");
	m_bAdminTrigger = false;
	m_bEnabled = true;
	m_bSerialized = false;
	m_msgProcType = PEEK_MESSAGE;
	m_SystemQueue = SYSTEM_QUEUE_NONE;

	_tcscpy( m_wzRegPath, pwzRegPath );
	
	_tcscpy( m_wzTriggerRegPath, pwzRegPath );
	_tcscat( m_wzTriggerRegPath, REG_SUBKEY_TRIGGERS );
}


//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeTriggerInfo::CRuntimeTriggerInfo(
	const _bstr_t& triggerId,
	BSTR bsTriggerName,
	BSTR bsQueueName,
	LPCTSTR pwzRegPath,
	SystemQueueIdentifier SystemQueue,
	bool bEnabled,
	bool bSerialized,
	MsgProcessingType msgProcType
	) :
	m_bstrTriggerID(triggerId)
{
	m_bstrTriggerName = bsTriggerName;

	m_SystemQueue = SystemQueue;
	m_bstrQueueName = bsQueueName;
	
	m_bAdminTrigger = false;
	m_bEnabled = bEnabled;
	m_bSerialized = bSerialized;
	m_msgProcType = msgProcType;

	_tcscpy( m_wzRegPath, pwzRegPath );
	
	_tcscpy( m_wzTriggerRegPath, pwzRegPath );
	_tcscat( m_wzTriggerRegPath, REG_SUBKEY_TRIGGERS );
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeTriggerInfo::~CRuntimeTriggerInfo()
{
	// Release any resources held by the rules list.
	ClearRulesList();
}

//*****************************************************************************
//
// Method      : IsValid
//
// Description : Returns a boolean value indicating if the current
//               instance represents a valid trigger definition.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::IsValid()
{
	return(IsValidTriggerID(this->m_bstrTriggerID) &&
		   IsValidTriggerName(this->m_bstrTriggerName) &&
		   (m_SystemQueue != SYSTEM_QUEUE_NONE  || IsValidTriggerQueueName(this->m_bstrQueueName)));
}


//*****************************************************************************
//
// Method      : GetRuleKeyHandle
//
// Description : Returns a handle to specified registry key
//
//*****************************************************************************
HKEY
CRuntimeTriggerInfo::GetTriggerKeyHandle(
    HKEY hRegistry,
    LPCTSTR triggerId
    )
{
    TCHAR triggerPath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(triggerPath, MAX_REGKEY_NAME_SIZE, L"%s%s", m_wzTriggerRegPath, triggerId);
    // XP SP1 bug 594254
	triggerPath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(Tgu, "Buffer to small to contain the registry path of a trigger.");
		return NULL;
	}

    RegEntry trigReg(triggerPath,  NULL, 0, RegEntry::Optional, hRegistry);
    return CmOpenKey(trigReg, KEY_ALL_ACCESS);
}


//*****************************************************************************
//
// Method      : BuildRulesList
//
// Description : This method populates the member var list of rules
//               that are attached to this trigger. It will clear
//               the current contents of the rules list - and reload
//               rule information from the registry.
//
// Note        : If the current trigger does not have an 'AttachedRules'
//               key in the registry, this method will create one.
//
//*****************************************************************************
void
CRuntimeTriggerInfo::BuildRulesList(
    HKEY hRegistry,
    _bstr_t &bstrTriggerID
    )
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(CRuntimeTriggerInfo::IsValidTriggerID(bstrTriggerID));

	// Release any resources currently held by the rules list.
	ClearRulesList();

    //
    // Open trigger key in registry
    //
    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(Tgu, "Failed to load trigger information. Trigger %ls isn't exist.",(LPCWSTR) bstrTriggerID);
        return;
    }

    //
    // Get registry handle key to attached rule
    //
    RegEntry  AttachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::Optional, hTrigKey);
    CRegHandle hAttachedRule = CmOpenKey(AttachedRuleReg, KEY_ALL_ACCESS);
	
    if (hAttachedRule == NULL)
    {
        //
        // rule hasn't attached yet
        //
        return;
    }

    bool fDeletedRule = false;
    wostringstream listOfDeletedRules;

	typedef map<DWORD, CRuntimeRuleInfo* > ATTACHED_RULES_MAP;
	ATTACHED_RULES_MAP attachedRulesMap;

    //
	// Enumerate through the keys under the AttachedRules key.
	// Each Value here should be a RuleID. As we enumerate through these keys,
	// we will populate the rules list with instance of the CRuntimeRuleInfo class.
	// If any rule fails to load, we remove it from the list.
    //
	for(DWORD index =0;; ++index)
    {
		WCHAR ruleName[256];
		DWORD len = TABLE_SIZE(ruleName);

		LONG hr = RegEnumValue(	
						hAttachedRule,
						index,
						ruleName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			break;
		}

		if ((hr == ERROR_NOTIFY_ENUM_DIR) || (hr == ERROR_KEY_DELETED))
		{
			//
			// The registery was changed while we enumerate it. free all the data and
			// recall to the routine to build the attached rule list
			//
			for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();)
			{
				delete it->second;
				it = attachedRulesMap.erase(it);
			}
			return BuildRulesList(hRegistry, bstrTriggerID);
		}

		if(hr != ERROR_SUCCESS)
		{
			TrERROR(Tgu, "Failed to Enumerate the attached rule from registry. Error 0x%x", hr);
			throw bad_alloc();
		}
	
        //
		// New rule id value, allocate a new rule structure and retrieve rule info.
        //
		AP<TCHAR> ruleId = NULL;

		RegEntry  AttRuleVal(REGKEY_TRIGGER_ATTACHED_RULES, ruleName, 0, RegEntry::MustExist, hTrigKey);
		CmQueryValue(AttRuleVal, &ruleId);

		
		P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo( m_wzRegPath );
		if(pRule->Retrieve(hRegistry, ruleId.get()))
		{
			DWORD rulePriority;
			swscanf(ruleName, ATTACH_RULE_PREFIX L"%d", &rulePriority);

			attachedRulesMap[rulePriority] = pRule.get();
			pRule.detach();

            continue;
		}

        //
		//rule not found
        //
        if (fDeletedRule)
        {
           listOfDeletedRules << L", ";
        }
        else
        {
           fDeletedRule = true;
        }

        listOfDeletedRules << ruleId;
	}

	try
	{
		for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();)
		{
			m_lstRules.push_back(it->second);
			it = attachedRulesMap.erase(it);
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(Tgu, "BuildRulesList failed due to low resources");

		for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();)
		{
			delete it->second;
			it = attachedRulesMap.erase(it);
		}

		throw;
	}


	if(fDeletedRule)
	{
		TrWARNING(Tgu, "The rules: %ls could not be loaded for trigger: %ls.", listOfDeletedRules.str().c_str(), bstrTriggerID);

        //
		//update registry according to changes - some rules were not found
        //
		FlushAttachedRulesToRegistry(hRegistry);
	}
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
void CRuntimeTriggerInfo::ClearRulesList()
{
	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); )
    {
	    CRuntimeRuleInfo* pRule = (*it);

		// We should never have null pointers in this list.
		ASSERT(pRule != NULL);

		// delete this rule object.
		delete pRule;

		// Look at the next item in the map and erase this list item.
		it = m_lstRules.erase(it);
	}
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeRuleInfo*
CRuntimeTriggerInfo::GetRule(
    long lIndex
    )
{
	if((lIndex < 0) || (lIndex >= numeric_cast<long>(m_lstRules.size())))
    {
		TrERROR(Tgu, "Illegal rule index for trigger %ls. The max index is: %I64d", (LPCWSTR)m_bstrTriggerID, m_lstRules.size());
		return NULL;
    }

    long ruleIndex = 0;

	for (RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
    {
		if (lIndex == ruleIndex)
		{
			//
			// ISSUE-2001/3/18-urih the returned object can be deleted if receiving detached rule
			// at the same time. reference count is required.
			//
            return *it;
		}

        ++ruleIndex;
	}

    //
    // Before calling the routine the caller checked that the rule index is valid
    //
    ASSERT(0);
    return NULL;
}


//*****************************************************************************
//
// Method      : IsRuleAttached
//
// Description :
//
//*****************************************************************************
bool
CRuntimeTriggerInfo::IsRuleAttached(
    BSTR sRuleID
    )
{
	for (RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		CRuntimeRuleInfo* pRule = *it;

		// We should never store nulls in the rule list.
		ASSERT(pRule != NULL);

		if (pRule->m_bstrRuleID == (_bstr_t)sRuleID)
			return true;
	}

	return false;
}

//*****************************************************************************
//
// Method      : Update
//
// Description : This method is used to update the definition of this
//               trigger (currently in persisted in the registry).
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Update(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(IsValid());

    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(Tgu, "Failed to upadte trigger %ls. Registery key isn't exist.", (LPCWSTR)m_bstrTriggerID);
        return false;
    }

    try
    {
	    FlushValuesToRegistry(hTrigKey);
        return true;
    }
    catch (const bad_alloc&)
    {
        //
		// ISSUE-2000/10/26-urih: partial success can cause trigger inconsistency
        //
		TrERROR(Tgu, "Failed to update trigger properties for: %ls.", (LPCWSTR)m_bstrTriggerID);
	    return false;
    }
}

//*****************************************************************************
//
// Method      : Create
//
// Description : This method creates a new trigger definition based on
//               properties values of this class instance.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Create(HKEY hRegistry)
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(hRegistry != NULL);

    //
    // Check that there the registery doesn't contain another rule with same ID
    //
    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hTrigKey != NULL)
    {
		TrERROR(Tgu, "Failed to create a key for trigger:%ls . Registry already contains trigger with same ID.", (LPCWSTR)m_bstrTriggerID);
        return false;
    }

    //
    // Assemble rule registery path
    //
    TCHAR triggerPath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(triggerPath, MAX_REGKEY_NAME_SIZE, L"%s%s", m_wzTriggerRegPath, static_cast<LPCWSTR>(m_bstrTriggerID));
    // XP SP1 bug 594257
	triggerPath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(Tgu, "Failed to create a key for trigger:%ls. Buffer to small to contain the registry path of a trigger.", (LPCWSTR)m_bstrTriggerID);
		return false;
	}

    RegEntry triggerReg(triggerPath,  NULL, 0, RegEntry::MustExist, hRegistry);
    try
    {
        //
        // Create key for the rule in registry
        //
        CRegHandle hTrigKey = CmCreateKey(triggerReg, KEY_ALL_ACCESS);
	    FlushValuesToRegistry(hTrigKey);

        return true;
    }
    catch(const bad_alloc&)
    {
        //
        // Remove the key if already created
        //
        CmDeleteKey(triggerReg);

		TrERROR(Tgu, "Failed to store trigger:%ls in registry", (LPCWSTR)m_bstrTriggerID);
        return false;
	}
}


//*****************************************************************************
//
// Method      : Delete
//
// Description : This method will delete the current trigger definition
//               from the registry.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Delete(HKEY hRegistry)
{
    try
    {
        RegEntry triggersReg(m_wzTriggerRegPath, NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hTriggersData = CmOpenKey(triggersReg, KEY_ALL_ACCESS);

        RegEntry trigReg(m_bstrTriggerID, NULL, 0, RegEntry::MustExist, hTriggersData);
        CRegHandle hTrigger = CmOpenKey(trigReg, KEY_ALL_ACCESS);

        RegEntry attachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::MustExist, hTrigger);

        CmDeleteKey(attachedRuleReg);
        CmDeleteKey(trigReg);

		TrTRACE(Tgu, "Delete trigger. Delete attached rule registry for trigger: %ls ", (LPCWSTR)m_bstrTriggerID);

        return true;
    }
    catch (const exception&)
    {
		TrERROR(Tgu, "Failed to delete trigger:%ls from registry.", (LPCWSTR)m_bstrTriggerID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Retrieve
//
// Description : This method retrieve the specified trigger ID from the
//               registry.
//
//*****************************************************************************
HRESULT CRuntimeTriggerInfo::Retrieve(HKEY hRegistry,_bstr_t bstrTriggerID)
{
    //
	// Assert that we have valid parameters and member vars
    //
	ASSERT(hRegistry != NULL);
	ASSERT(bstrTriggerID.length() > 0);

    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(Tgu, "Failed to retrieve trigger %ls. Registery key isn't exist.", (LPCWSTR)m_bstrTriggerID);
        return MQTRIG_TRIGGER_NOT_FOUND;
    }

    try
    {
        //
        // Retrieve trigger name
        //
        AP<TCHAR> triggerName = NULL;
        RegEntry trigNameReg(NULL, REGISTRY_TRIGGER_VALUE_NAME, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigNameReg, &triggerName);

        //
        // Retrieve trigger Queue name
        //
        AP<TCHAR> queueName = NULL;
        RegEntry trigQueueReg(NULL, REGISTRY_TRIGGER_VALUE_QUEUE_NAME, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigQueueReg, &queueName);

		//
        // Retrieve trigger enabled attribute
        //
        DWORD trigEnabled = 0;
        RegEntry trigEnabledReg(NULL, REGISTRY_TRIGGER_VALUE_ENABLED, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigEnabledReg, &trigEnabled);

        //
        // Retrieve trigger serialize attribute
        //
        DWORD trigSerialize = 0;
        RegEntry trigSerializeReg(NULL, REGISTRY_TRIGGER_VALUE_SERIALIZED, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigSerializeReg, &trigSerialize);

        //
        // Retrieve message processing type attribute
        //
        DWORD trigMsgProcType = 0;
        RegEntry trigMsgProcTypeReg(NULL, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigMsgProcTypeReg, &trigMsgProcType);
	
		if ( trigMsgProcType > static_cast<DWORD>(RECEIVE_MESSAGE_XACT) )
		{
			TrTRACE(Tgu, "Illegal MsgProcessingType value in registry for trigger: %ls", static_cast<LPCWSTR>(m_bstrTriggerID));
			return MQTRIG_ERROR;
		}

		//
        // Set trigger attributes
        //
	    m_bstrTriggerID = bstrTriggerID;
	    m_bstrTriggerName = triggerName;
	
	    m_bstrQueueName = queueName;
	    m_SystemQueue = IsSystemQueue(queueName.get());

	    m_bEnabled = (trigEnabled != 0);
	    m_bSerialized = (trigSerialize != 0);

		m_msgProcType = static_cast<MsgProcessingType>(trigMsgProcType);
        //
	    // Attempt to build the rules list.
        //
		BuildRulesList(hRegistry, bstrTriggerID);
    }
    catch(const exception&)
    {
		TrERROR(Tgu, "Failed to retrieve triger: %ls properties", (LPCWSTR)bstrTriggerID);
        return MQTRIG_ERROR;
    }

    if (!IsValid())
	{
		TrERROR(Tgu, "Registry contains invalid property for trigger %ls", (LPCWSTR)bstrTriggerID);
        return MQTRIG_ERROR;
	}

    return S_OK;
}

//*****************************************************************************
//
// Method      : Attach
//
// Description : Attaches a rule definition to this trigger definition.
//
//*****************************************************************************
bool
CRuntimeTriggerInfo::Attach(
    HKEY hRegistry,
    _bstr_t bstrRuleID,
    ULONG ulPriority
    )
{
    //
	// assert that the supplied priority makes sense
    //
	ASSERT(ulPriority <= m_lstRules.size());

    try
    {
        //
	    // Attempt to create instantiate a rule object with this rule id.
	    //
        P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo( m_wzRegPath );

        bool fSucc = pRule->Retrieve(hRegistry, bstrRuleID);
	    if (!fSucc)
	    {
			TrERROR(Tgu, "Failed to attached rule %ls to trigger %ls. Rule doesn't exist.",(LPCWSTR) bstrRuleID, (LPCWSTR)m_bstrTriggerID);
            return false;
	    }

        //
	    // Get a reference to the 'ulPriority' position in the list.
        //
        RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin();

        for (DWORD index =0; index < ulPriority; ++index)
        {
            ASSERT(it != m_lstRules.end());
            ++it;
        }

        //
        // insert the rule into the in-memory list at the correct location.
        //
        m_lstRules.insert(it,pRule);
        pRule.detach();

        //
	    // Delete the existing attached-rules data for this trigger	and write new ones
        //
	    FlushAttachedRulesToRegistry(hRegistry);			

        return true;
    }
    catch(const exception&)
    {
    	TrERROR(Tgu, "Failed to attached rule %ls to trigger %ls.", (LPCWSTR)bstrRuleID, (LPCWSTR)m_bstrTriggerID);
        return false;
    }
}

//*****************************************************************************
//
// Method      : Detach
//
// Description : Detaches a rule from this trigger definiiton.
//
//*****************************************************************************
bool
CRuntimeTriggerInfo::Detach(
    HKEY hRegistry,
    _bstr_t bstrRuleID
    )
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(IsValid());
	ASSERT(hRegistry != NULL);
	ASSERT(CRuntimeRuleInfo::IsValidRuleID(bstrRuleID));

	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		// Get a reference to the current rule object
		CRuntimeRuleInfo* pRule = *it;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		if(pRule->m_bstrRuleID == bstrRuleID)
		{
		    // We should only ever have valid rules in the map
		    ASSERT(pRule->IsValid());
		
			m_lstRules.erase(it);
			delete pRule;

            try
            {
                FlushAttachedRulesToRegistry(hRegistry);
                return true;
            }
            catch(const exception&)
            {
		        TrERROR(Tgu, "Failed to deatch rule: %ls from trigger: %ls", (LPCWSTR)bstrRuleID, (LPCWSTR)m_bstrTriggerID);
                return false;
            }
        }
	}

    //
    // rule ID isn't attached to the trigger
    //
    return false;
}

//*****************************************************************************
//
// Method      : FlushValuesToRegistry
//
// Description : This method flushes the member variable values to the
//               supplied registry key.
//
//*****************************************************************************
void
CRuntimeTriggerInfo::FlushValuesToRegistry(
    const HKEY& hTriggerKey
    )
{
    //
	// Set the NAME value for this trigger
    //
    RegEntry trigNameReg(NULL, REGISTRY_TRIGGER_VALUE_NAME, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigNameReg, m_bstrTriggerName);

    //
	// Set the Queue path name value for this trigger
    //
    RegEntry trigQueueReg(NULL, REGISTRY_TRIGGER_VALUE_QUEUE_NAME, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigQueueReg, m_bstrQueueName);

    //
	// Set the Enabled attribute for this trigger
    //
    RegEntry trigEnabledReg(NULL, REGISTRY_TRIGGER_VALUE_ENABLED, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigEnabledReg, m_bEnabled);

    //
	// Set the Serialize attribute for this trigger
    //
    RegEntry trigSerializeReg(NULL, REGISTRY_TRIGGER_VALUE_SERIALIZED, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigSerializeReg, m_bSerialized);

    //
	// Set the message processing type attribute for this trigger
    //
    RegEntry trigMsgProcTypeReg(NULL, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigMsgProcTypeReg, m_msgProcType);

}


//*****************************************************************************
//
// Method      : IsValid*
//
// Description : The following static methods are used to validate
//               the validity of parameters and member vars used by
//               the CRuntimeTriggerInfo class.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::IsValidTriggerID(_bstr_t bstrTriggerID)
{
	return((bstrTriggerID.length() > 0) ? true:false);
}
bool CRuntimeTriggerInfo::IsValidTriggerName(_bstr_t bstrTriggerName)
{
	return((bstrTriggerName.length() > 0) ? true:false);
}
bool CRuntimeTriggerInfo::IsValidTriggerQueueName(_bstr_t bstrTriggerQueueName)
{
	return((bstrTriggerQueueName.length() > 0) ? true:false);
}


void
CRuntimeTriggerInfo::FlushAttachedRulesToRegistry(
    const HKEY& hRegistry
    )
{
    //
    // Open trigger key in registry
    //
    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(Tgu, "Failed to load trigger information. Trigger %ls isn't exist.", (LPCWSTR)m_bstrTriggerID);
        throw exception();
    }

    //
    // Delete AttachedRules subkey
    //
    RegEntry  AttachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::MustExist, hTrigKey);
    CmDeleteKey(AttachedRuleReg);

    //
	// Write out the new attached rules data for this trigger.
    //
    CRegHandle hAttachedRule = CmCreateKey(AttachedRuleReg, KEY_ALL_ACCESS);

	DWORD ruleIndex = 0;
	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		// Get a reference to the current rule object
	    CRuntimeRuleInfo* pRule = *it;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only ever have valid rules in the map
		ASSERT(pRule->IsValid());

		// Construct the value name
		_bstr_t bstrValueName;
		FormatBSTR(&bstrValueName,_T("%s%d"),ATTACH_RULE_PREFIX, ruleIndex);
		
		// Write this value out to the registry.
        RegEntry  ruleValue(NULL, bstrValueName, 0, RegEntry::MustExist, hAttachedRule);
        CmSetValue(ruleValue, pRule->m_bstrRuleID);

		// Increment the rule counter used to construct the key-value name.
		++ruleIndex;
	}
}


bool CRuntimeTriggerInfo::DetachAllRules(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	
	// Release any resources currently held by the rules list.
	ClearRulesList();

    try
    {
	    FlushAttachedRulesToRegistry(hRegistry);						
        return true;
    }
    catch(const exception&)
    {
		TrERROR(Tgu, "Failed to detachhed all rule for trigger %ls", (LPCWSTR)m_bstrTriggerID);

        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilgcrea.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGREAD.H | Header for interface implementation <c CILogCreateStorage>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _CILGCREA_H
#	define _CILGCREA_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "ilgcrea.h"						// ILogCreateStorage.

// ===============================
// DECLARATIONS:
// ===============================

// ===============================
// CLASS: CILogCreateStorage:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogCreateStorage | Interface implementation of <i ILogRead> for
//                  core class <c CLogStream>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogCreateStorage.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogCreateStorage: public ILogCreateStorage				// @base public | ILogRead.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogCreateStorage (CLogMgr FAR* i_pCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogRead (public):
    virtual STDMETHODIMP  CreateStorage	(LPTSTR ptstrFullFileSpec,ULONG ulLogSize,ULONG ulInitSig, BOOL fOverWrite, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval);
	virtual STDMETHODIMP  CreateStream	(LPTSTR lpszStreamName);


private:	// ------------------------------- @access Backpointers (private):
	CLogMgr FAR*		m_pCLogMgr;				// @cmember Core object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.


};

#endif _CILGCREA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\dblib\include\sqlfront.h ===
#ifndef _INC_SQLFRONT
#define _INC_SQLFRONT

#ifdef DBNTWIN32
	#ifndef _WINDOWS_
		#pragma message (__FILE__ " : db-library error: windows.h must be included before sqlfront.h.")
	#endif
#endif

#ifdef __cplusplus
	extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*     SQLFRONT.H - DB-Library header file for the Microsoft SQL Server.      *
*                                                                            *
*     Copyright (c) 1989 - 1995 by Microsoft Corp.  All rights reserved.     *
*                                                                            *
* All constant and macro definitions for DB-Library applications programming *
* are contained in this file.  This file must be included before SQLDB.H and *
* one of the following #defines must be made, depending on the operating     *
* system: DBMSDOS, DBMSWIN or DBNTWIN32.                                     *
*                                                                            *
*****************************************************************************/


/*****************************************************************************
* Datatype definitions                                                       *
*****************************************************************************/

// Note this has changed because Windows 3.1 defines API as 'pascal far'

#if !defined(M_I86SM) && !defined(DBNTWIN32)
#define SQLAPI cdecl far
#else
#define SQLAPI _cdecl
#endif

#ifndef  API
#define  API  SQLAPI
#endif

#ifndef DOUBLE
typedef double DOUBLE;
#endif


/*****************************************************************************
* DBPROCESS, LOGINREC and DBCURSOR                                           *
*****************************************************************************/

#define DBPROCESS void   // dbprocess structure type
#define LOGINREC  void   // login record type
#define DBCURSOR  void   // cursor record type
#define DBHANDLE  void   // generic handle

// DOS Specific
#ifdef DBMSDOS
typedef DBPROCESS * PDBPROCESS;
typedef LOGINREC  * PLOGINREC;
typedef DBCURSOR  * PDBCURSOR;
typedef DBHANDLE  * PDBHANDLE;
#define PTR *
#endif


// WIN 3.x Specific.  The handle pointers are near for Windows 3.x
#ifdef DBMSWIN
typedef DBPROCESS near * PDBPROCESS;
typedef LOGINREC  near * PLOGINREC;
typedef DBCURSOR  near * PDBCURSOR;
typedef DBHANDLE  near * PDBHANDLE;
#define PTR far *
#endif


// Windows NT Specific
#ifdef DBNTWIN32
typedef DBPROCESS * PDBPROCESS;
typedef LOGINREC  * PLOGINREC;
typedef DBCURSOR  * PDBCURSOR;
typedef DBHANDLE  * PDBHANDLE;
#define PTR *
typedef int (SQLAPI *SQLFARPROC)();
#else
typedef long (far pascal *LGFARPROC)();  // Windows loadable driver fp
#endif


/*****************************************************************************
* Win32 compatibility datatype definitions                                   *
* Note: The following datatypes are provided for Win32 compatibility.        *
* Since some of the datatypes are already defined in unrelated include files *
* there may definition duplication.  Every attempt has been made to check    *
* for such problems.                                                         *
*****************************************************************************/

#ifndef DBNTWIN32

#ifndef SHORT
typedef short SHORT;
#endif

#ifndef INT
typedef int INT;
#endif

#ifndef UINT
typedef unsigned int UINT;
#endif

#ifndef USHORT
typedef unsigned short USHORT;
#endif

#ifndef ULONG
typedef unsigned long ULONG;
#endif

#ifndef CHAR
typedef char CHAR;
#endif

#ifndef LPINT
typedef INT PTR LPINT;
#endif

typedef unsigned char BYTE;

typedef       CHAR PTR LPSTR;
typedef       BYTE PTR LPBYTE;
typedef       void PTR LPVOID;	
typedef const CHAR PTR LPCSTR;

typedef int BOOL;

#endif


/*****************************************************************************
* DB-Library datatype definitions                                            *
*****************************************************************************/

#define DBMAXCHAR 256 // Max length of DBVARBINARY and DBVARCHAR, etc.

#ifndef DBTYPEDEFS    // srv.h (Open Server include) not already included

#define DBTYPEDEFS

#define RETCODE INT
#define STATUS INT

// DB-Library datatypes
typedef char            DBCHAR;
typedef unsigned char   DBBINARY;
typedef unsigned char   DBTINYINT;
typedef short           DBSMALLINT;
typedef unsigned short  DBUSMALLINT;
typedef long            DBINT;
typedef double          DBFLT8;
typedef unsigned char   DBBIT;
typedef unsigned char   DBBOOL;
typedef float           DBFLT4;
typedef long            DBMONEY4;

typedef DBFLT4 DBREAL;
typedef UINT   DBUBOOL;

typedef struct dbdatetime4
{
	USHORT numdays;        // No of days since Jan-1-1900
	USHORT nummins;        // No. of minutes since midnight
} DBDATETIM4;


typedef struct dbvarychar
{
	DBSMALLINT  len;
	DBCHAR      str[DBMAXCHAR];
} DBVARYCHAR;

typedef struct dbvarybin
{
	DBSMALLINT  len;
	BYTE        array[DBMAXCHAR];
} DBVARYBIN;

typedef struct dbmoney
{
	DBINT mnyhigh;
	ULONG mnylow;
} DBMONEY;

typedef struct dbdatetime
{
	DBINT dtdays;
	ULONG dttime;
} DBDATETIME;

// DBDATEREC structure used by dbdatecrack
typedef struct dbdaterec
{
	INT     year;         // 1753 - 9999
	INT     quarter;      // 1 - 4
	INT     month;        // 1 - 12
	INT     dayofyear;    // 1 - 366
	INT     day;          // 1 - 31
	INT     week;         // 1 - 54 (for leap years)
	INT     weekday;      // 1 - 7  (Mon - Sun)
	INT     hour;         // 0 - 23
	INT     minute;       // 0 - 59
	INT     second;       // 0 - 59
	INT     millisecond;  // 0 - 999
} DBDATEREC;

#define MAXNUMERICLEN 16
#define MAXNUMERICDIG 38

#define DEFAULTPRECISION 18
#define DEFAULTSCALE     0

typedef struct dbnumeric
{
	BYTE precision;
	BYTE scale;
	BYTE sign; // 1 = Positive, 0 = Negative
	BYTE val[MAXNUMERICLEN];
} DBNUMERIC;

typedef DBNUMERIC DBDECIMAL;


// Pack the following structures on a word boundary
#ifdef __BORLANDC__
#pragma option -a+
#else
	#ifndef DBLIB_SKIP_PRAGMA_PACK   // Define this if your compiler does not support #pragma pack()
	#pragma pack(2)
    #pragma warning(disable: 4121)   // alignment of a member was sensitive to packing
	#endif
#endif

#define MAXCOLNAMELEN 30
#define MAXTABLENAME  30

typedef struct
{
	DBINT SizeOfStruct;
	CHAR  Name[MAXCOLNAMELEN+1];
	CHAR  ActualName[MAXCOLNAMELEN+1];
	CHAR  TableName[MAXTABLENAME+1];
	SHORT Type;
	DBINT UserType;
	DBINT MaxLength;
	BYTE  Precision;
	BYTE  Scale;
	BOOL  VarLength;     // TRUE, FALSE
	BYTE  Null;          // TRUE, FALSE or DBUNKNOWN
	BYTE  CaseSensitive; // TRUE, FALSE or DBUNKNOWN
	BYTE  Updatable;     // TRUE, FALSE or DBUNKNOWN
	BOOL  Identity;      // TRUE, FALSE
} DBCOL, PTR LPDBCOL;


#define MAXSERVERNAME 30
#define MAXNETLIBNAME 255
#define MAXNETLIBCONNSTR 255

typedef struct
{
	DBINT  SizeOfStruct;
	BYTE   ServerType;
	USHORT ServerMajor;
	USHORT ServerMinor;
	USHORT ServerRevision;
	CHAR   ServerName[MAXSERVERNAME+1];
	CHAR   NetLibName[MAXNETLIBNAME+1];
	CHAR   NetLibConnStr[MAXNETLIBCONNSTR+1];
} DBPROCINFO, PTR LPDBPROCINFO;

typedef struct
{
	DBINT SizeOfStruct;   // Use sizeof(DBCURSORINFO)
	ULONG TotCols;        // Total Columns in cursor
	ULONG TotRows;        // Total Rows in cursor
	ULONG CurRow;         // Current actual row in server
	ULONG TotRowsFetched; // Total rows actually fetched
	ULONG Type;           // See CU_...
	ULONG Status;         // See CU_...
} DBCURSORINFO, PTR LPDBCURSORINFO;

#define INVALID_UROWNUM ((ULONG)(-1))

// Reset default alignment
#ifdef __BORLANDC__
#pragma option -a-
#else
	#ifndef DBLIB_SKIP_PRAGMA_PACK   // Define this if your compiler does not support #pragma pack()
	#pragma pack()
    #pragma warning(default: 4121)   // alignment of a member was sensitive to packing
	#endif
#endif


#endif // End DBTYPEDEFS


/*****************************************************************************
* Pointer Datatypes                                                          *
*****************************************************************************/

typedef const LPINT          LPCINT;
#ifndef _LPCBYTE_DEFINED
typedef const LPBYTE         LPCBYTE ;
#endif
typedef       USHORT PTR     LPUSHORT;
typedef const LPUSHORT       LPCUSHORT;
typedef       DBINT PTR      LPDBINT;
typedef const LPDBINT        LPCDBINT;
typedef       DBBINARY PTR   LPDBBINARY;
typedef const LPDBBINARY     LPCDBBINARY;
typedef       DBDATEREC PTR  LPDBDATEREC;
typedef const LPDBDATEREC    LPCDBDATEREC;
typedef       DBDATETIME PTR LPDBDATETIME;
typedef const LPDBDATETIME   LPCDBDATETIME;


/*****************************************************************************
* General #defines                                                           *
*****************************************************************************/

#define TIMEOUT_IGNORE (ULONG)-1
#define TIMEOUT_INFINITE (ULONG)0
#define TIMEOUT_MAXIMUM (ULONG)1200 // 20 minutes maximum timeout value

// Used for ServerType in dbgetprocinfo
#define SERVTYPE_UNKNOWN   0
#define SERVTYPE_MICROSOFT 1

// Used by dbcolinfo
enum CI_TYPES { CI_REGULAR=1, CI_ALTERNATE=2, CI_CURSOR=3 };

// Bulk Copy Definitions (bcp)
#define DB_IN	1         // Transfer from client to server
#define DB_OUT	2         // Transfer from server to client

#define BCPMAXERRS   1    // bcp_control parameter
#define BCPFIRST     2    // bcp_control parameter
#define BCPLAST      3    // bcp_control parameter
#define BCPBATCH     4    // bcp_control parameter
#define BCPKEEPNULLS 5    // bcp_control parameter
#define BCPABORT     6    // bcp_control parameter

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define TINYBIND         1
#define SMALLBIND        2
#define INTBIND          3
#define CHARBIND         4
#define BINARYBIND       5
#define BITBIND          6
#define DATETIMEBIND     7
#define MONEYBIND        8
#define FLT8BIND         9
#define STRINGBIND      10
#define NTBSTRINGBIND   11
#define VARYCHARBIND    12
#define VARYBINBIND     13
#define FLT4BIND        14
#define SMALLMONEYBIND  15
#define SMALLDATETIBIND 16
#define DECIMALBIND     17
#define NUMERICBIND     18
#define SRCDECIMALBIND  19
#define SRCNUMERICBIND  20
#define MAXBIND         SRCNUMERICBIND

#define DBSAVE          1
#define DBNOSAVE        0

#define DBNOERR         -1
#define DBFINDONE       0x04  // Definately done
#define DBMORE          0x10  // Maybe more commands waiting
#define DBMORE_ROWS     0x20  // This command returned rows

#define MAXNAME         31


#define DBTXTSLEN       8     // Timestamp length

#define DBTXPLEN        16    // Text pointer length

// Error code returns
#define INT_EXIT        0
#define INT_CONTINUE    1
#define INT_CANCEL      2


// dboptions
#define DBBUFFER        0
#define DBOFFSET        1
#define DBROWCOUNT      2
#define DBSTAT          3
#define DBTEXTLIMIT     4
#define DBTEXTSIZE      5
#define DBARITHABORT    6
#define DBARITHIGNORE   7
#define DBNOAUTOFREE    8
#define DBNOCOUNT       9
#define DBNOEXEC        10
#define DBPARSEONLY     11
#define DBSHOWPLAN      12
#define DBSTORPROCID		13

#if defined(DBMSWIN) || defined(DBNTWIN32)
#define DBANSItoOEM		14
#endif

#ifdef DBNTWIN32
#define DBOEMtoANSI		15
#endif

#define DBCLIENTCURSORS 16
#define DBSETTIME 17
#define DBQUOTEDIDENT 18


// Data Type Tokens
#define SQLVOID        0x1f
#define SQLTEXT        0x23
#define SQLVARBINARY   0x25
#define SQLINTN        0x26
#define SQLVARCHAR     0x27
#define SQLBINARY      0x2d
#define SQLIMAGE       0x22
#define SQLCHAR        0x2f
#define SQLINT1        0x30
#define SQLBIT         0x32
#define SQLINT2        0x34
#define SQLINT4        0x38
#define SQLMONEY       0x3c
#define SQLDATETIME    0x3d
#define SQLFLT8        0x3e
#define SQLFLTN        0x6d
#define SQLMONEYN      0x6e
#define SQLDATETIMN    0x6f
#define SQLFLT4        0x3b
#define SQLMONEY4      0x7a
#define SQLDATETIM4    0x3a
#define SQLDECIMAL     0x6a
#define SQLNUMERIC     0x6c

// Data stream tokens
#define SQLCOLFMT      0xa1
#define OLD_SQLCOLFMT  0x2a
#define SQLPROCID      0x7c
#define SQLCOLNAME     0xa0
#define SQLTABNAME     0xa4
#define SQLCOLINFO     0xa5
#define SQLALTNAME     0xa7
#define SQLALTFMT      0xa8
#define SQLERROR       0xaa
#define SQLINFO        0xab
#define SQLRETURNVALUE 0xac
#define SQLRETURNSTATUS 0x79
#define SQLRETURN      0xdb
#define SQLCONTROL     0xae
#define SQLALTCONTROL  0xaf
#define SQLROW         0xd1
#define SQLALTROW      0xd3
#define SQLDONE        0xfd
#define SQLDONEPROC    0xfe
#define SQLDONEINPROC  0xff
#define SQLOFFSET      0x78
#define SQLORDER       0xa9
#define SQLLOGINACK    0xad // NOTICE: change to real value

// Ag op tokens
#define SQLAOPCNT		0x4b
#define SQLAOPSUM    0x4d
#define SQLAOPAVG    0x4f
#define SQLAOPMIN    0x51
#define SQLAOPMAX    0x52
#define SQLAOPANY    0x53
#define SQLAOPNOOP   0x56

// Error numbers (dberrs) DB-Library error codes
#define SQLEMEM         10000
#define SQLENULL        10001
#define SQLENLOG        10002
#define SQLEPWD         10003
#define SQLECONN        10004
#define SQLEDDNE        10005
#define SQLENULLO       10006
#define SQLESMSG        10007
#define SQLEBTOK        10008
#define SQLENSPE        10009
#define SQLEREAD        10010
#define SQLECNOR        10011
#define SQLETSIT        10012
#define SQLEPARM        10013
#define SQLEAUTN        10014
#define SQLECOFL        10015
#define SQLERDCN        10016
#define SQLEICN         10017
#define SQLECLOS        10018
#define SQLENTXT        10019
#define SQLEDNTI        10020
#define SQLETMTD        10021
#define SQLEASEC        10022
#define SQLENTLL        10023
#define SQLETIME        10024
#define SQLEWRIT        10025
#define SQLEMODE        10026
#define SQLEOOB         10027
#define SQLEITIM        10028
#define SQLEDBPS        10029
#define SQLEIOPT        10030
#define SQLEASNL        10031
#define SQLEASUL        10032
#define SQLENPRM        10033
#define SQLEDBOP        10034
#define SQLENSIP        10035
#define SQLECNULL       10036
#define SQLESEOF        10037
#define SQLERPND        10038
#define SQLECSYN        10039
#define SQLENONET       10040
#define SQLEBTYP        10041
#define SQLEABNC        10042
#define SQLEABMT        10043
#define SQLEABNP        10044
#define SQLEBNCR        10045
#define SQLEAAMT        10046
#define SQLENXID        10047
#define SQLEIFNB        10048
#define SQLEKBCO        10049
#define SQLEBBCI        10050
#define SQLEKBCI        10051
#define SQLEBCWE        10052
#define SQLEBCNN        10053
#define SQLEBCOR        10054
#define SQLEBCPI        10055
#define SQLEBCPN        10056
#define SQLEBCPB        10057
#define SQLEVDPT        10058
#define SQLEBIVI        10059
#define SQLEBCBC        10060
#define SQLEBCFO        10061
#define SQLEBCVH        10062
#define SQLEBCUO        10063
#define SQLEBUOE        10064
#define SQLEBWEF        10065
#define SQLEBTMT        10066
#define SQLEBEOF        10067
#define SQLEBCSI        10068
#define SQLEPNUL        10069
#define SQLEBSKERR      10070
#define SQLEBDIO        10071
#define SQLEBCNT        10072
#define SQLEMDBP        10073
#define SQLINIT         10074
#define SQLCRSINV       10075
#define SQLCRSCMD       10076
#define SQLCRSNOIND     10077
#define SQLCRSDIS       10078
#define SQLCRSAGR       10079
#define SQLCRSORD       10080
#define SQLCRSMEM       10081
#define SQLCRSBSKEY     10082
#define SQLCRSNORES     10083
#define SQLCRSVIEW      10084
#define SQLCRSBUFR      10085
#define SQLCRSFROWN     10086
#define SQLCRSBROL      10087
#define SQLCRSFRAND     10088
#define SQLCRSFLAST     10089
#define SQLCRSRO        10090
#define SQLCRSTAB       10091
#define SQLCRSUPDTAB    10092
#define SQLCRSUPDNB     10093
#define SQLCRSVIIND     10094
#define SQLCRSNOUPD     10095
#define SQLCRSOS2       10096
#define SQLEBCSA        10097
#define SQLEBCRO        10098
#define SQLEBCNE        10099
#define SQLEBCSK        10100
#define SQLEUVBF        10101
#define SQLEBIHC        10102
#define SQLEBWFF        10103
#define SQLNUMVAL       10104
#define SQLEOLDVR       10105
#define SQLEBCPS	10106
#define SQLEDTC 	10107
#define SQLENOTIMPL	10108
#define SQLENONFLOAT	10109
#define SQLECONNFB   10110


// The severity levels are defined here
#define EXINFO          1  // Informational, non-error
#define EXUSER          2  // User error
#define EXNONFATAL      3  // Non-fatal error
#define EXCONVERSION    4  // Error in DB-LIBRARY data conversion
#define EXSERVER        5  // The Server has returned an error flag
#define EXTIME          6  // We have exceeded our timeout period while
                           // waiting for a response from the Server - the
                           // DBPROCESS is still alive
#define EXPROGRAM       7  // Coding error in user program
#define EXRESOURCE      8  // Running out of resources - the DBPROCESS may be dead
#define EXCOMM          9  // Failure in communication with Server - the DBPROCESS is dead
#define EXFATAL         10 // Fatal error - the DBPROCESS is dead
#define EXCONSISTENCY   11 // Internal software error  - notify MS Technical Supprt

// Offset identifiers
#define OFF_SELECT      0x16d
#define OFF_FROM        0x14f
#define OFF_ORDER       0x165
#define OFF_COMPUTE     0x139
#define OFF_TABLE       0x173
#define OFF_PROCEDURE   0x16a
#define OFF_STATEMENT   0x1cb
#define OFF_PARAM       0x1c4
#define OFF_EXEC        0x12c

// Print lengths for certain fixed length data types
#define PRINT4     11
#define PRINT2     6
#define PRINT1     3
#define PRFLT8     20
#define PRMONEY    26
#define PRBIT      3
#define PRDATETIME 27
#define PRDECIMAL (MAXNUMERICDIG + 2)
#define PRNUMERIC (MAXNUMERICDIG + 2)

#define SUCCEED  1
#define FAIL     0
#define SUCCEED_ABORT 2

#define DBUNKNOWN 2

#define MORE_ROWS    -1
#define NO_MORE_ROWS -2
#define REG_ROW      MORE_ROWS
#define BUF_FULL     -3

// Status code for dbresults(). Possible return values are
// SUCCEED, FAIL, and NO_MORE_RESULTS.
#define NO_MORE_RESULTS 2
#define NO_MORE_RPC_RESULTS 3

// Macros for dbsetlname()
#define DBSETHOST 1
#define DBSETUSER 2
#define DBSETPWD  3
#define DBSETAPP  4
#define DBSETID   5
#define DBSETLANG 6
#define DBSETSECURE 7
#define DBVER42    8
#define DBVER60    9
#define DBSETLOGINTIME 10
#define DBSETFALLBACK 12

// Standard exit and error values
#define STDEXIT  0
#define ERREXIT  -1

// dbrpcinit flags
#define DBRPCRECOMPILE  0x0001
#define DBRPCRESET      0x0004
#define DBRPCCURSOR     0x0008

// dbrpcparam flags
#define DBRPCRETURN     0x1
#define DBRPCDEFAULT    0x2


// Cursor related constants

// Following flags are used in the concuropt parameter in the dbcursoropen function
#define CUR_READONLY 1 // Read only cursor, no data modifications
#define CUR_LOCKCC   2 // Intent to update, all fetched data locked when
                       // dbcursorfetch is called inside a transaction block
#define CUR_OPTCC    3 // Optimistic concurrency control, data modifications
                       // succeed only if the row hasn't been updated since
                       // the last fetch.
#define CUR_OPTCCVAL 4 // Optimistic concurrency control based on selected column values

// Following flags are used in the scrollopt parameter in dbcursoropen
#define CUR_FORWARD 0       // Forward only scrolling
#define CUR_KEYSET  -1      // Keyset driven scrolling
#define CUR_DYNAMIC 1       // Fully dynamic
#define CUR_INSENSITIVE -2  // Server-side cursors only

// Following flags define the fetchtype in the dbcursorfetch function
#define FETCH_FIRST    1  // Fetch first n rows
#define FETCH_NEXT     2  // Fetch next n rows
#define FETCH_PREV     3  // Fetch previous n rows
#define FETCH_RANDOM   4  // Fetch n rows beginning with given row #
#define FETCH_RELATIVE 5  // Fetch relative to previous fetch row #
#define FETCH_LAST     6  // Fetch the last n rows

// Following flags define the per row status as filled by dbcursorfetch and/or dbcursorfetchex
#define FTC_EMPTY         0x00  // No row available
#define FTC_SUCCEED       0x01  // Fetch succeeded, (failed if not set)
#define FTC_MISSING       0x02  // The row is missing
#define FTC_ENDOFKEYSET   0x04  // End of the keyset reached
#define FTC_ENDOFRESULTS  0x08  // End of results set reached

// Following flags define the operator types for the dbcursor function
#define CRS_UPDATE   1  // Update operation
#define CRS_DELETE   2  // Delete operation
#define CRS_INSERT   3  // Insert operation
#define CRS_REFRESH  4  // Refetch given row
#define CRS_LOCKCC   5  // Lock given row

// Following value can be passed to the dbcursorbind function for NOBIND type
#define NOBIND -2       // Return length and pointer to data

// Following are values used by DBCURSORINFO's Type parameter
#define CU_CLIENT        0x00000001
#define CU_SERVER        0x00000002
#define CU_KEYSET        0x00000004
#define CU_MIXED         0x00000008
#define CU_DYNAMIC       0x00000010
#define CU_FORWARD       0x00000020
#define CU_INSENSITIVE   0x00000040
#define CU_READONLY      0x00000080
#define CU_LOCKCC        0x00000100
#define CU_OPTCC         0x00000200
#define CU_OPTCCVAL      0x00000400

// Following are values used by DBCURSORINFO's Status parameter
#define CU_FILLING       0x00000001
#define CU_FILLED        0x00000002


// Following are values used by dbupdatetext's type parameter
#define UT_TEXTPTR      0x0001
#define UT_TEXT         0x0002
#define UT_MORETEXT     0x0004
#define UT_DELETEONLY   0x0008
#define UT_LOG          0x0010


// The following values are passed to dbserverenum for searching criteria.
#define NET_SEARCH  0x0001
#define LOC_SEARCH  0x0002

// These constants are the possible return values from dbserverenum.
#define ENUM_SUCCESS         0x0000
#define MORE_DATA            0x0001
#define NET_NOT_AVAIL        0x0002
#define OUT_OF_MEMORY        0x0004
#define NOT_SUPPORTED        0x0008
#define ENUM_INVALID_PARAM   0x0010


// Netlib Error problem codes.  ConnectionError() should return one of
// these as the dblib-mapped problem code, so the corresponding string
// is sent to the dblib app's error handler as dberrstr.  Return NE_E_NOMAP
// for a generic DB-Library error string (as in prior versions of dblib).

#define NE_E_NOMAP              0   // No string; uses dblib default.
#define NE_E_NOMEMORY           1   // Insufficient memory.
#define NE_E_NOACCESS           2   // Access denied.
#define NE_E_CONNBUSY           3   // Connection is busy.
#define NE_E_CONNBROKEN         4   // Connection broken.
#define NE_E_TOOMANYCONN        5   // Connection limit exceeded.
#define NE_E_SERVERNOTFOUND     6   // Specified SQL server not found.
#define NE_E_NETNOTSTARTED      7   // The network has not been started.
#define NE_E_NORESOURCE         8   // Insufficient network resources.
#define NE_E_NETBUSY            9   // Network is busy.
#define NE_E_NONETACCESS        10  // Network access denied.
#define NE_E_GENERAL            11  // General network error.  Check your documentation.
#define NE_E_CONNMODE           12  // Incorrect connection mode.
#define NE_E_NAMENOTFOUND       13  // Name not found in directory service.
#define NE_E_INVALIDCONN        14  // Invalid connection.
#define NE_E_NETDATAERR         15  // Error reading or writing network data.
#define NE_E_TOOMANYFILES       16  // Too many open file handles.
#define NE_E_CANTCONNECT		  17  // SQL Server does not exist or access denied.

#define NE_MAX_NETERROR         17

#ifdef __cplusplus
}
#endif

#endif // _INC_SQLFRONT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilginit.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGINIT.H | Header for interface implementation <c CILogInit>.
// @rev 0 | 10/18/94 | rcraig | Created: For WPGEP COM lab.
// @rev 1 | 04/04/95 | rcraig | Updated: For Viper COM DLL templates.
// @rev 2 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _CILGINIT_H
#	define _CILGINIT_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

// TODO: Replace this header with your associated interface header.
#include "ilginit.h"						// ILogInit.

// ===============================
// DECLARATIONS:
// ===============================

class CLogMgr;								// Core class forward declaration.
                           
// ===============================
// CLASS: CILogInit:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogInit | Interface implementation of <i ILogInit> for
//                  core class <c CLogMgr>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogInit.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogInit: public ILogInit				// @base public | ILogInit.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogInit (CLogMgr FAR* i_pCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogInit (public):
    virtual STDMETHODIMP  Init	(ULONG *pulStorageCapacity,ULONG *pulLogSpaceAvailable,LPTSTR ptstrFullFileSpec,ULONG ulInitSig, BOOL fFixedSize, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval,UINT uiLogBuffers);


private:	// ------------------------------- @access Backpointers (private):
	CLogMgr FAR*		m_pCLogMgr;				// @cmember Core object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.

private:	// ------------------------------- @access Private data (private):

};

#endif _CILGINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilgstor.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGSTOR.H | Header for interface implementation <c CILogStorage>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _CILGSTOR_H
#	define _CILGSTOR_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "ilgstor.h"						// ILogStorage.
#include "strmtbl.h"

// ===============================
// DECLARATIONS:
// ===============================

class CLogMgr;								// Core class forward declaration.
                           
// ===============================
// CLASS: CILogStorage:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogStorage | Interface implementation of <i ILogStorage> for
//                  core class <c CLogMgr>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogStorage.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogStorage: public ILogStorage				// @base public | ILogStorage.
{   
friend class CILogWrite;
friend class CILogWriteAsynch;
friend class CILogRead;
friend class CILogCreateStorage;

public:		// ------------------------------- @access Samsara (public):
	CILogStorage (CLogMgr FAR* i_pCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogStorage (public):

	// TODO: Declare your ILogStorage methods here...
	//       (Note: JustAnExample should be used as a template and/or removed.)
 	virtual STDMETHODIMP	  OpenLogStream				(LPTSTR lptstrStreamName, DWORD grfMode, LPVOID FAR* ppvStream);		
	virtual STDMETHODIMP	  OpenLogStreamByClassID	(CLSID clsClassID, DWORD grfMode, LPVOID FAR* ppvStream);				 
	virtual STDMETHODIMP	  LogFlush	(void);				 
	virtual ULONG			  GetLogSpaceNeeded	(ULONG ulRecSize);				 
							                                                                                              
private:	// ------------------------------- @access Backpointers (private):
	CLogMgr FAR*	m_pCLogMgr;				// @cmember Core object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.
	HRESULT     	FindStream		(LPTSTR lptstrStream, STRMTBL** ppstrmtblStream, ULONG *pulStrmID); //@cmember Find the given stream				 
	HRESULT     	FindStream		(CLSID clsidStream, STRMTBL** ppstrmtblStream, ULONG *pulStrmID); //@cmember Find the given stream				 
	HRESULT     	AddStream		(LPTSTR lptstrStream, STRMTBL** ppstrmtblNew, ULONG *pulStrmID); //@cmember Add the stream to the list of known streams
	HRESULT     	AddStream		(CLSID clsidStream, STRMTBL** ppstrmtblNew); //@cmember Add the stream to the list of known streams
	STRMTBL*		GetStream		(ULONG ulStrmID); //@cmember find specific streamtbl entry				 
private:	// ------------------------------- @access Private data (private):


};

#endif _CILGSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilguisc.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGUISC.H | Header for interface implementation <c CILogUISConnect>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _CILGUISC_H
#	define _CILGUISC_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

// TODO: Replace this header with your associated interface header.
#include "ilginit.h"						// ILogUISConnect.

// ===============================
// DECLARATIONS:
// ===============================

class CLogMgr;								// Core class forward declaration.
                           
// ===============================
// CLASS: CILogUISConnect:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogUISConnect | Interface implementation of <i ILogUISConnect> for
//                  core class <c CLogMgr>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogUISConnect.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogUISConnect: public ILogUISConnect				// @base public | ILogUISConnect.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogUISConnect (CLogMgr FAR* i_pCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogUISConnect (public):
    virtual STDMETHODIMP  Init	(IUnknown *punkTracer);
    virtual STDMETHODIMP  Shutdown	(void);

private:	// ------------------------------- @access Backpointers (private):
	CLogMgr FAR*		m_pCLogMgr;				// @cmember Core object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.

private:	// ------------------------------- @access Private data (private):

};

#endif _CILGUISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\dblib\include\sqldb.h ===
#ifndef _INC_SQLDB
#define _INC_SQLDB

#ifdef __cplusplus
	extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*       SQLDB.H - DB-Library header file for the Microsoft SQL Server.       *
*                                                                            *
*     Copyright (c) 1989 - 1995 by Microsoft Corp.  All rights reserved.     *
*                                                                            *
*****************************************************************************/

// Macros for setting the PLOGINREC
#define DBSETLHOST(a,b)    dbsetlname   ((a), (b), DBSETHOST)
#define DBSETLUSER(a,b)    dbsetlname   ((a), (b), DBSETUSER)
#define DBSETLPWD(a,b)     dbsetlname   ((a), (b), DBSETPWD)
#define DBSETLAPP(a,b)     dbsetlname   ((a), (b), DBSETAPP)
#define BCP_SETL(a,b)      bcp_setl     ((a), (b))
#define DBSETLNATLANG(a,b) dbsetlname   ((a), (b), DBSETLANG)
#define DBSETLPACKET(a,b)  dbsetlpacket ((a), (b))
#define DBSETLSECURE(a)    dbsetlname   ((a), 0,   DBSETSECURE)
#define DBSETLVERSION(a,b) dbsetlname   ((a), 0,  (b))
#define DBSETLTIME(a,b)		dbsetlname    ((a), (LPCSTR)(ULONG)(b), DBSETLOGINTIME)
#define DBSETLFALLBACK(a,b) dbsetlname   ((a), (b),   DBSETFALLBACK)

/*****************************************************************************
* Windows 3.x and Non-Windows 3.x differences.                               *
*****************************************************************************/

#ifdef DBMSWIN

extern void SQLAPI dbwinexit(void);

void SQLAPI dblocklib (void);
void SQLAPI dbunlocklib (void);

#define DBLOCKLIB()   dblocklib()
#define DBUNLOCKLIB() dbunlocklib()

#define DBERRHANDLE_PROC FARPROC
#define DBMSGHANDLE_PROC FARPROC

extern DBERRHANDLE_PROC dberrhandle (DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC dbmsghandle (DBMSGHANDLE_PROC);

#else

#define dbwinexit()

#define DBLOCKLIB()
#define DBUNLOCKLIB()

typedef INT (SQLAPI *DBERRHANDLE_PROC)(PDBPROCESS, INT, INT, INT, LPCSTR, LPCSTR);
typedef INT (SQLAPI *DBMSGHANDLE_PROC)(PDBPROCESS, DBINT, INT, INT, LPCSTR, LPCSTR, LPCSTR, DBUSMALLINT);

extern DBERRHANDLE_PROC SQLAPI dberrhandle(DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC SQLAPI dbmsghandle(DBMSGHANDLE_PROC);

extern DBERRHANDLE_PROC SQLAPI dbprocerrhandle(PDBHANDLE, DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC SQLAPI dbprocmsghandle(PDBHANDLE, DBMSGHANDLE_PROC);


#endif


/*****************************************************************************
* Function Prototypes                                                        *
*****************************************************************************/

// Functions macros
#define DBCMDROW(a)      dbcmdrow(a)
#define DBCOUNT(a)       dbcount (a)
#define DBCURCMD(a)      dbcurcmd(a)
#define DBCURROW(a)      dbcurrow(a)
#define DBDEAD(a)        dbdead(a)
#define DBFIRSTROW(a)    dbfirstrow(a)
#define DBGETTIME()      dbgettime()
#define DBISAVAIL(a)     dbisavail(a)
#define DBLASTROW(a)     dblastrow(a)
#define DBMORECMDS(a)    dbmorecmds(a)
#define DBNUMORDERS(a)   dbnumorders(a)
#define dbrbuf(a)        ((DBINT)dbdataready(a))
#define DBRBUF(a)        ((DBINT)dbdataready(a))
#define DBROWS(a)        dbrows (a)
#define DBROWTYPE(a)     dbrowtype (a)

// Two-phase commit functions
extern RETCODE      SQLAPI abort_xact (PDBPROCESS, DBINT);
extern void         SQLAPI build_xact_string (LPCSTR, LPCSTR, DBINT, LPSTR);
extern void         SQLAPI close_commit (PDBPROCESS);
extern RETCODE      SQLAPI commit_xact (PDBPROCESS, DBINT);
extern PDBPROCESS   SQLAPI open_commit (PLOGINREC, LPCSTR);
extern RETCODE      SQLAPI remove_xact (PDBPROCESS, DBINT, INT);
extern RETCODE      SQLAPI scan_xact (PDBPROCESS, DBINT);
extern DBINT        SQLAPI start_xact (PDBPROCESS, LPCSTR, LPCSTR, INT);
extern INT          SQLAPI stat_xact (PDBPROCESS, DBINT);

// BCP functions
extern DBINT        SQLAPI bcp_batch (PDBPROCESS);
extern RETCODE      SQLAPI bcp_bind (PDBPROCESS, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
extern RETCODE      SQLAPI bcp_colfmt (PDBPROCESS, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
extern RETCODE      SQLAPI bcp_collen (PDBPROCESS, DBINT, INT);
extern RETCODE      SQLAPI bcp_colptr (PDBPROCESS, LPCBYTE, INT);
extern RETCODE      SQLAPI bcp_columns (PDBPROCESS, INT);
extern RETCODE      SQLAPI bcp_control (PDBPROCESS, INT, DBINT);
extern DBINT        SQLAPI bcp_done (PDBPROCESS);
extern RETCODE      SQLAPI bcp_exec (PDBPROCESS, LPDBINT);
extern RETCODE      SQLAPI bcp_init (PDBPROCESS, LPCSTR, LPCSTR, LPCSTR, INT);
extern RETCODE      SQLAPI bcp_moretext (PDBPROCESS, DBINT, LPCBYTE);
extern RETCODE      SQLAPI bcp_readfmt (PDBPROCESS, LPCSTR);
extern RETCODE      SQLAPI bcp_sendrow (PDBPROCESS);
extern RETCODE      SQLAPI bcp_setl (PLOGINREC, BOOL);
extern RETCODE      SQLAPI bcp_writefmt (PDBPROCESS, LPCSTR);

// Standard DB-Library functions
extern LPCBYTE      SQLAPI dbadata (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbadlen (PDBPROCESS, INT, INT);
extern RETCODE      SQLAPI dbaltbind (PDBPROCESS, INT, INT, INT, DBINT, LPCBYTE);
extern INT          SQLAPI dbaltcolid (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbaltlen (PDBPROCESS, INT, INT);
extern INT          SQLAPI dbaltop (PDBPROCESS, INT, INT);
extern INT          SQLAPI dbalttype (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbaltutype (PDBPROCESS, INT, INT);
extern RETCODE      SQLAPI dbanullbind (PDBPROCESS, INT, INT, LPCDBINT);
extern RETCODE      SQLAPI dbbind (PDBPROCESS, INT, INT, DBINT, LPBYTE);
extern LPCBYTE      SQLAPI dbbylist (PDBPROCESS, INT, LPINT);
extern RETCODE      SQLAPI dbcancel (PDBPROCESS);
extern RETCODE      SQLAPI dbcanquery (PDBPROCESS);
extern LPCSTR       SQLAPI dbchange (PDBPROCESS);
extern RETCODE      SQLAPI dbclose (PDBPROCESS);
extern void         SQLAPI dbclrbuf (PDBPROCESS, DBINT);
extern RETCODE      SQLAPI dbclropt (PDBPROCESS, INT, LPCSTR);
extern RETCODE      SQLAPI dbcmd (PDBPROCESS, LPCSTR);
extern RETCODE      SQLAPI dbcmdrow (PDBPROCESS);
extern BOOL         SQLAPI dbcolbrowse (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbcolinfo (PDBHANDLE, INT, INT, INT, LPDBCOL);
extern DBINT        SQLAPI dbcollen (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbcolname (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbcolsource (PDBPROCESS, INT);
extern INT          SQLAPI dbcoltype (PDBPROCESS, INT);
extern DBINT        SQLAPI dbcolutype (PDBPROCESS, INT);
extern INT          SQLAPI dbconvert (PDBPROCESS, INT, LPCBYTE, DBINT, INT, LPBYTE, DBINT);
extern DBINT        SQLAPI dbcount (PDBPROCESS);
extern INT          SQLAPI dbcurcmd (PDBPROCESS);
extern DBINT        SQLAPI dbcurrow (PDBPROCESS);
extern RETCODE      SQLAPI dbcursor (PDBCURSOR, INT, INT, LPCSTR, LPCSTR);
extern RETCODE      SQLAPI dbcursorbind (PDBCURSOR, INT, INT, DBINT, LPDBINT, LPBYTE);
extern RETCODE      SQLAPI dbcursorclose (PDBHANDLE);
extern RETCODE      SQLAPI dbcursorcolinfo (PDBCURSOR, INT, LPSTR, LPINT, LPDBINT, LPINT);
extern RETCODE      SQLAPI dbcursorfetch (PDBCURSOR,  INT, INT);
extern RETCODE      SQLAPI dbcursorfetchex (PDBCURSOR, INT, DBINT, DBINT, DBINT);
extern RETCODE      SQLAPI dbcursorinfo (PDBCURSOR, LPINT, LPDBINT);
extern RETCODE      SQLAPI dbcursorinfoex (PDBCURSOR, LPDBCURSORINFO);
extern PDBCURSOR    SQLAPI dbcursoropen (PDBPROCESS, LPCSTR, INT, INT,UINT, LPDBINT);
extern LPCBYTE      SQLAPI dbdata (PDBPROCESS, INT);
extern BOOL         SQLAPI dbdataready (PDBPROCESS);
extern RETCODE      SQLAPI dbdatecrack (PDBPROCESS, LPDBDATEREC, LPCDBDATETIME);
extern DBINT        SQLAPI dbdatlen (PDBPROCESS, INT);
extern BOOL         SQLAPI dbdead (PDBPROCESS);
extern void         SQLAPI dbexit (void);
extern RETCODE 	    SQLAPI dbenlisttrans(PDBPROCESS, LPVOID);
extern RETCODE	    SQLAPI dbenlistxatrans(PDBPROCESS, BOOL);
extern RETCODE	    SQLAPI dbfcmd (PDBPROCESS, LPCSTR, ...);
extern DBINT        SQLAPI dbfirstrow (PDBPROCESS);
extern void         SQLAPI dbfreebuf (PDBPROCESS);
extern void         SQLAPI dbfreelogin (PLOGINREC);
extern void         SQLAPI dbfreequal (LPCSTR);
extern LPSTR        SQLAPI dbgetchar (PDBPROCESS, INT);
extern SHORT        SQLAPI dbgetmaxprocs (void);
extern INT          SQLAPI dbgetoff (PDBPROCESS, DBUSMALLINT, INT);
extern UINT         SQLAPI dbgetpacket (PDBPROCESS);
extern STATUS       SQLAPI dbgetrow (PDBPROCESS, DBINT);
extern INT          SQLAPI dbgettime (void);
extern LPVOID       SQLAPI dbgetuserdata (PDBPROCESS);
extern BOOL         SQLAPI dbhasretstat (PDBPROCESS);
extern LPCSTR       SQLAPI dbinit (void);
extern BOOL         SQLAPI dbisavail (PDBPROCESS);
extern BOOL         SQLAPI dbiscount (PDBPROCESS);
extern BOOL         SQLAPI dbisopt (PDBPROCESS, INT, LPCSTR);
extern DBINT        SQLAPI dblastrow (PDBPROCESS);
extern PLOGINREC    SQLAPI dblogin (void);
extern RETCODE      SQLAPI dbmorecmds (PDBPROCESS);
extern RETCODE      SQLAPI dbmoretext (PDBPROCESS, DBINT, LPCBYTE);
extern LPCSTR       SQLAPI dbname (PDBPROCESS);
extern STATUS       SQLAPI dbnextrow (PDBPROCESS);
extern RETCODE      SQLAPI dbnullbind (PDBPROCESS, INT, LPCDBINT);
extern INT          SQLAPI dbnumalts (PDBPROCESS, INT);
extern INT          SQLAPI dbnumcols (PDBPROCESS);
extern INT          SQLAPI dbnumcompute (PDBPROCESS);
extern INT          SQLAPI dbnumorders (PDBPROCESS);
extern INT          SQLAPI dbnumrets (PDBPROCESS);
extern PDBPROCESS   SQLAPI dbopen (PLOGINREC, LPCSTR);
extern INT          SQLAPI dbordercol (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbprocinfo (PDBPROCESS, LPDBPROCINFO);
extern void         SQLAPI dbprhead (PDBPROCESS);
extern RETCODE      SQLAPI dbprrow (PDBPROCESS);
extern LPCSTR       SQLAPI dbprtype (INT);
extern LPCSTR       SQLAPI dbqual (PDBPROCESS, INT, LPCSTR);
extern DBINT        SQLAPI dbreadpage (PDBPROCESS, LPCSTR, DBINT, LPBYTE);
extern DBINT        SQLAPI dbreadtext (PDBPROCESS, LPVOID, DBINT);
extern RETCODE      SQLAPI dbresults (PDBPROCESS);
extern LPCBYTE      SQLAPI dbretdata (PDBPROCESS, INT);
extern DBINT        SQLAPI dbretlen (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbretname (PDBPROCESS, INT);
extern DBINT        SQLAPI dbretstatus (PDBPROCESS);
extern INT          SQLAPI dbrettype (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbrows (PDBPROCESS);
extern STATUS       SQLAPI dbrowtype (PDBPROCESS);
extern RETCODE      SQLAPI dbrpcinit (PDBPROCESS, LPCSTR, DBSMALLINT);
extern RETCODE      SQLAPI dbrpcparam (PDBPROCESS, LPCSTR, BYTE, INT, DBINT, DBINT, LPCBYTE);
extern RETCODE      SQLAPI dbrpcsend (PDBPROCESS);
extern RETCODE      SQLAPI dbrpcexec (PDBPROCESS);
extern void         SQLAPI dbrpwclr (PLOGINREC);
extern RETCODE      SQLAPI dbrpwset (PLOGINREC, LPCSTR, LPCSTR, INT);
extern INT          SQLAPI dbserverenum (USHORT, LPSTR, USHORT, LPUSHORT);
extern void         SQLAPI dbsetavail (PDBPROCESS);
extern RETCODE      SQLAPI dbsetmaxprocs (SHORT);
extern RETCODE      SQLAPI dbsetlname (PLOGINREC, LPCSTR, INT);
extern RETCODE      SQLAPI dbsetlogintime (INT);
extern RETCODE      SQLAPI dbsetlpacket (PLOGINREC, USHORT);
extern RETCODE      SQLAPI dbsetnull (PDBPROCESS, INT, INT, LPCBYTE);
extern RETCODE      SQLAPI dbsetopt (PDBPROCESS, INT, LPCSTR);
extern RETCODE      SQLAPI dbsettime (INT);
extern void         SQLAPI dbsetuserdata (PDBPROCESS, LPVOID);
extern RETCODE      SQLAPI dbsqlexec (PDBPROCESS);
extern RETCODE      SQLAPI dbsqlok (PDBPROCESS);
extern RETCODE      SQLAPI dbsqlsend (PDBPROCESS);
extern RETCODE      SQLAPI dbstrcpy (PDBPROCESS, INT, INT, LPSTR);
extern INT          SQLAPI dbstrlen (PDBPROCESS);
extern BOOL         SQLAPI dbtabbrowse (PDBPROCESS, INT);
extern INT          SQLAPI dbtabcount (PDBPROCESS);
extern LPCSTR       SQLAPI dbtabname (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbtabsource (PDBPROCESS, INT, LPINT);
extern INT          SQLAPI dbtsnewlen (PDBPROCESS);
extern LPCDBBINARY  SQLAPI dbtsnewval (PDBPROCESS);
extern RETCODE      SQLAPI dbtsput (PDBPROCESS, LPCDBBINARY, INT, INT, LPCSTR);
extern LPCDBBINARY  SQLAPI dbtxptr (PDBPROCESS, INT);
extern LPCDBBINARY  SQLAPI dbtxtimestamp (PDBPROCESS, INT);
extern LPCDBBINARY  SQLAPI dbtxtsnewval (PDBPROCESS);
extern RETCODE      SQLAPI dbtxtsput (PDBPROCESS, LPCDBBINARY, INT);
extern RETCODE      SQLAPI dbuse (PDBPROCESS, LPCSTR);
extern BOOL         SQLAPI dbvarylen (PDBPROCESS, INT);
extern BOOL         SQLAPI dbwillconvert (INT, INT);
extern RETCODE      SQLAPI dbwritepage (PDBPROCESS, LPCSTR, DBINT, DBINT, LPBYTE);
extern RETCODE      SQLAPI dbwritetext (PDBPROCESS, LPCSTR, LPCDBBINARY, DBTINYINT, LPCDBBINARY, BOOL, DBINT, LPCBYTE);
extern RETCODE      SQLAPI dbupdatetext(PDBPROCESS, LPCSTR, LPCDBBINARY, LPCDBBINARY, INT, DBINT, DBINT, LPCSTR, DBINT, LPCDBBINARY);

#ifdef __cplusplus
}
#endif

#endif // _INC_SQLDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilgread.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGREAD.H | Header for interface implementation <c CILogRead>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _CILGREAD_H
#	define _CILGREAD_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "ilgread.h"						// ILogRead.
#include "layout.h"
#include "xmgrdisk.h"
// ===============================
// DECLARATIONS:
// ===============================

class CLogStream;								// Core class forward declaration.
class CReadMap;
                           
// ===============================
// CLASS: CILogRead:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogRead | Interface implementation of <i ILogRead> for
//                  core class <c CLogStream>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogRead.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogRead: public ILogRead				// @base public | ILogRead.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogRead (CLogStream FAR* i_pCLogStream, CLogMgr FAR* p_CLogMgr); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogRead (public):

 	virtual  STDMETHODIMP ReadInit	(void)	 ; // @cmember ;
 	virtual  STDMETHODIMP ReadLRP	(LRP lrpLRPStart, ULONG * pulByteLength, USHORT* pusUserType); // @cmember 
 	virtual  STDMETHODIMP ReadNext	(LRP *plrpLRP, ULONG * pulByteLength, USHORT* pusUserType); // @cmember 
 	virtual  STDMETHODIMP GetCurrentLogRecord	(char *pchBuffer); // @cmember 
	virtual	 STDMETHODIMP SetPosition (LRP lrpLRPPosition); //@cmember
	virtual  STDMETHODIMP Seek		(LRP_SEEK llrpOrigin, LONG cbLogRecs, LRP* plrpNewLRP);  // @cmember .
	virtual  STDMETHODIMP GetCheckpoint   (DWORD cbNumCheckpoint, LRP* plrpLRP);	  // @cmember .

	virtual  STDMETHODIMP	DumpLog(ULONG ulStartPage, ULONG ulEndPage, DUMP_TYPE ulDumpType,  TCHAR *szFileName);

 	virtual  STDMETHODIMP	DumpPage(CHAR * pchOutBuffer, ULONG ulPageNumber, DUMP_TYPE ulDumpType, ULONG *pulLength);

	virtual CHAR *	DumpLRP(LRP lrpTarget,CHAR *szFormat,DUMP_TYPE ulDumpType, ULONG *pulLength);
			

private:	// ------------------------------- @access Backpointers (private):
    CLogStream FAR* m_pCLogStream;			// @cmember Core object pointer
	CLogMgr FAR*	m_pCLogMgr;				// @cmember Core logstorage object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.
    LOGRECHEADER * _FindFirstLRH(VOID * pvDumpPage);
	CHAR *		   _DumpLRH (LOGRECHEADER *plrh, ULONG *pulLength);	
	HRESULT		   _DumpDataPage(CHAR *pchOutBuffer,ULONG ulPageNumber,RECORDPAGE *prcpgDump,DUMP_TYPE ulDumpType, ULONG *pulLength, ULONG ulChecksum); 
	HRESULT		   _DumpRestartPage(CHAR *pchOutBuffer,ULONG ulPageNumber,RESTARTPAGE *prstrpgDump,DUMP_TYPE ulDumpType, ULONG *pulLength,ULONG ulChecksum); 
private:	// ------------------------------- @access Private data (private):

private:	// ------------------------------- @access Reference counting data (private):
};

#endif _CILGREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilgwrit.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGWRIT.H | Header for interface implementation <c CILogWrite>.
// @rev 0 | 10/18/94 | rcraig | Created: For WPGEP COM lab.
// @rev 1 | 04/04/95 | rcraig | Updated: For Viper COM DLL templates.
// @rev 2 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------

// TODO: Search and replace "CLogMgr" with your core class.

// TODO: In the core class source/header, complete the interface implementation class TODO's.

#ifndef _CILGWRIT_H
#	define _CILGWRIT_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

// TODO: Replace this header with your associated interface header.
#include "ilgwrite.h"						// ILogWrite.

// ===============================
// DECLARATIONS:
// ===============================
class CLogMgr;

class CLogStream;								// Core class forward declaration.
                           
// ===============================
// CLASS: CILogWrite:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogWrite | Interface implementation of <i ILogWrite> for
//                  core class <c CLogMgr>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogWrite.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogWrite: public ILogWrite				// @base public | ILogWrite.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogWrite (CLogStream FAR* i_pCLogStream, CLogMgr FAR* pCLogMgr); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogWrite (public):

 	virtual STDMETHODIMP  Append	(LOGREC* rgLogRecords, ULONG cbNumRecs, LRP *rgLRP,ULONG* pcbNumRecs,LRP* pLRPLastPerm, BOOL fFlushNow,ULONG* pulAvailableSpace);

	virtual STDMETHODIMP  SetCheckpoint (LRP lrpLatestCheckpoint);

private:	// ------------------------------- @access Backpointers (private):
	CLogStream FAR*		m_pCLogStream;          // @cmember Core object pointer
	CLogMgr FAR*		m_pCLogMgr;				// @cmember Parent logstorage object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.

private:	// ------------------------------- @access Private data (private):

};

#endif _CILGWRIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilrp.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILRP.H | Header for interface implementation <c CILogRecordPointer>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _CILRP_H
#	define _CILRP_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

// TODO: Replace this header with your associated interface header.
#include "ilrp.h"						// ILogRecordPointer.

// ===============================
// DECLARATIONS:
// ===============================

class CLogMgr;								// Core class forward declaration.
                           
// ===============================
// CLASS: CILogRecordPointer:
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// -----------------------------------------------------------------------
// @class CILogRecordPointer | Interface implementation of <i ILogRecordPointer> for
//                  core class <c CLogMgr>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogRecordPointer.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogRecordPointer: public ILogRecordPointer				// @base public | ILogRecordPointer.
{   
public:		// ------------------------------- @access Samsara (public):
	CILogRecordPointer (CLogMgr FAR* i_pCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogRecordPointer (public):
    virtual DWORD  CompareLRP	(LRP lrpLRP1, LRP lrpLRP2);
 	virtual STDMETHODIMP  LastPermLRP	(LRP* plrpLRP)   ;
 	virtual STDMETHODIMP  GetLRPSize	(LRP lrpLRP, DWORD *pcbSize)    ;


private:	// ------------------------------- @access Backpointers (private):
	CLogMgr FAR*		m_pCLogMgr;				// @cmember Core object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.

private:	// ------------------------------- @access Private data (private):

};

#endif _CILRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ftdisk.h ===
/*
 * @doc
 *
 * @module FTDISK.H | Ondisk physical definitions
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code 
 * @rev 1 | 03-Apr-95 | wilfr    | seqno to gennum changes
 * @rev 2 | 18-Jan-96 | robertba | 8k pages for x86
 */

#ifndef _FTDISK_
#define _FTDISK_


#define ALLOCPOOL

#define X86PAGESIZE 8192
#define ALPHAPAGESIZE 8192
#ifdef _X86_
#define PAGE_SIZE X86PAGESIZE
#else
#define PAGE_SIZE ALPHAPAGESIZE
#endif

#pragma pack(2)


/*
 * @struct  DSKMETAHDR | header that is found in all metadata pages
 *
 * hungarian dmh
 */

typedef struct _DSKMETAHDR              
{
    ULONG sig;	       //@field The signature
	ULONG ulChecksum;  //@field The checksum
	ULONG ulGeneration;//@field The generation number
	ULONG ulPageOffset;//@field The offset of this page
	ULONG ulVersion;   //@field The logmgr version
} DSKMETAHDR;


#pragma pack(4)



#endif  // !_FTDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\cilgwrta.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module CILGWRTA.H | Header for interface implementation <c CILogWriteAsynch>.
// @rev 0 | 06/02/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _CILGWRTA_H
#	define _CILGWRTA_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "ilgwrta.h"						// ILogWriteAsynch.

// ===============================
// DECLARATIONS:
// ===============================

class CLogStream;								// Core class forward declaration.
class CLogMgr;

 class CLogAppendNotice
  {
   public:
   	LRP					lrpLRP;
	CAsynchSupport* pCAsynchSupport;
	BOOL			fInUse;

#ifdef _DEBUG
	DWORD			m_dwNumFlushes;		// for catching delayed notifications
#endif _DEBUG

  };

// ===============================
// CLASS: CILogWriteAsynch:
// ===============================


// -----------------------------------------------------------------------
// @class CILogWriteAsynch | Interface implementation of <i ILogWriteAsynch> for
//                  core class <c CLogStream>.<nl><nl>
// Threading: Thread-safe.<nl>
// Platforms: Win.<nl>
// Includes : None.<nl>
// Ref count: Delegated.<nl>
// Hungarian: CILogWriteAsynch.<nl><nl>
// Description:<nl>
//   This is a template for an interface implementation.<nl><nl>
// Usage:<nl>
//   This is only a template.  You get to say how your instance gets used.
// -----------------------------------------------------------------------
class CILogWriteAsynch: public ILogWriteAsynch				// @base public | ILogWriteAsynch.
{ 
 friend class CLogStream;  
 friend class CLogMgr; 
public:		// ------------------------------- @access Samsara (public):
	CILogWriteAsynch (CLogStream FAR* i_pCLogStream, CLogMgr FAR* pCLogMgr); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP				QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		AddRef (void); // @cmember .
	virtual STDMETHODIMP_ (ULONG)		Release (void); // @cmember .

public:		// ------------------------------- @access ILogWriteAsynch (public):

 	virtual STDMETHODIMP  Init	(ULONG cbMaxOutstandingWrites);
 	virtual STDMETHODIMP  AppendAsynch	(LOGREC* plgrLogRecord, LRP* plrpLRP, CAsynchSupport* pCAsynchSupport,BOOL fFlushHint,ULONG* pulAvailableSpace);
	virtual STDMETHODIMP  SetCheckpoint (LRP lrpLatestCheckpoint,CAsynchSupport* pCAsynchSupport, LRP* plrpCheckpointLogged);

private:	// ------------------------------- @access Backpointers (private):
    CLogStream FAR* m_pCLogStream;			// @cmember core object pointer
	CLogMgr FAR*	m_pCLogMgr;				// @cmember Core logstorage object pointer.
	IUnknown*		m_pIUOuter;				// @cmember	Outer IUnknown pointer.

private:	// ------------------------------- @access Private data (private):

  	CSemExclusive    m_cmxsWriteAsynch;			//@cmember 	The write lock that must be held 
  	                                        //    to manipulate the AppendNotify lists
    ULONG			m_cbMaxOutstanding;		//  @cmember Max limit of outstanding appends
    ULONG			m_cbFlushHints;			//  @cmember current count of flush hints
    CLogAppendNotice  * m_rgCLogAppendNotices;
	ULONG			m_ulListHead;
	ULONG			m_ulListEnd;
	BOOL			m_fListEmpty;
};

#endif _CILGWRTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\crc.h ===
//
// CRC Object
//

#ifndef __CRC32_H__
#define __CRC32_H__
#ifdef _CONSOLE
#define FAR
#else
#define FAR __far
#endif

extern "C"
{
    typedef ULONG (__cdecl *FUNC32)(ULONG, UINT, UCHAR *, ULONG *);
    typedef ULONG ( *FUNC16)(ULONG, UINT, UCHAR *, ULONG *);
};

extern ULONG* pulCRCTable;
extern FUNC32 lpUpdateCRC;
void CreateCRC(void);
void DestroyCRC(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilgcrea.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILogCreateStorage.H | Header for interface <i ILogCreateStorage>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGCREA_H
#	define _ILGCREA_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "logconst.h"

// ===============================
// INTERFACE: ILogCreateStorage
// ===============================

// -----------------------------------------------------------------------
// @interface ILogCreateStorage | See also <c CILogCreateStorage>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogCreateStorage, IUnknown)
{
	// @comm IUnknown methods: See <c CILogCreateStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogCreateStorage methods: See <c CILogCreateStorage>.
	
 	STDMETHOD  (CreateStorage)		(LPSTR ptstrFullFileSpec,ULONG ulLogSize, ULONG ulInitSig, BOOL fOverWrite, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval)				 	PURE;
	STDMETHOD  (CreateStream)		(LPSTR lpszStreamName)				 	PURE;

};

#endif _ILGCREA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilginit.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILogInit.H | Header for interface <i ILogInit>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGINIT_H
#	define _ILGINIT_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32


// ===============================
// INTERFACE: ILogInit
// ===============================

// TODO: In the interface comments, update the description.
// TODO: In the interface comments, update the usage.

// -----------------------------------------------------------------------
// @interface ILogInit | See also <c CILogInit>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogInit, IUnknown)
{
	// @comm IUnknown methods: See <c CILogInit>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogInit methods: See <c CILogInit>.
	
 	STDMETHOD  (Init)		(ULONG *pulStorageCapacity,ULONG *pulLogSpaceAvailable,LPSTR ptstrFullFileSpec,ULONG ulInitSig, BOOL fFixedSize, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval,UINT uiLogBuffers)				 	PURE;
};

#endif _ILGINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilgread.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILogRead.H | Header for interface <i ILogRead>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGREAD_H
#	define _ILGREAD_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogRead
// ===============================

//#define DUMPBUFFERSIZE 0x5230 (((RECORDSPACE /BYTESPERLINE)+1)*CHARSPERLINE) +  (8 * CHARSPERLINE) // data plus header space

#define BYTESPERLINE 16
#define CHARSPERLINE 80
#define DUMPBUFFERSIZE 0xA230 

typedef enum _DUMP_TYPE
	{
	 HEX_DUMP = 0,
	 SUMMARY_DUMP = 1,
	 RECORD_DUMP = 2
	} DUMP_TYPE;
 

typedef enum _LRP_SEEK
	{
	 LRP_START = -1,
	 LRP_END = -2,
	 LRP_CUR = 0
	} LRP_SEEK;

// -----------------------------------------------------------------------
// @interface ILogRead | See also <c CILogRead>.<nl><nl>
// Description:<nl>
//   Provide read functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogRead, IUnknown)
{
	// @comm IUnknown methods: See <c CILogRead>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogRead methods: See <c CILogRead>.
	
 	STDMETHOD  (ReadInit)	(void)				 	PURE;
 	STDMETHOD  (ReadLRP )	(LRP lrpLRPStart, ULONG * ulByteLength, USHORT* usUserType)	PURE;
 	STDMETHOD  (ReadNext )	(LRP *plrpLRP, ULONG * ulByteLength, USHORT* usUserType)				 	PURE;
 	STDMETHOD  (GetCurrentLogRecord )	(char *pchBuffer)	PURE;
	STDMETHOD  (SetPosition)(LRP lrpLRPPosition)PURE;
	STDMETHOD  (Seek) 		(LRP_SEEK llrpOrigin, LONG cbLogRecs, LRP* plrpNewLRP) PURE;
	STDMETHOD  (GetCheckpoint)   (DWORD cbNumCheckpoint, LRP* plrpLRP) PURE;
	STDMETHOD  (DumpLog)  (ULONG ulStartPage, ULONG ulEndPage, DUMP_TYPE ulDumpType, CHAR *szFileName) PURE;
    STDMETHOD  (DumpPage) (CHAR * pchOutBuffer, ULONG ulPageNumber, DUMP_TYPE ulDumpType, ULONG *pulLength) PURE;

	virtual CHAR * DumpLRP (LRP lrpTarget,CHAR *szFormat,DUMP_TYPE ulDumpType, ULONG *pulLength) PURE;
			

};

#endif _ILGREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\debnot.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       DEBNOT.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//
//----------------------------------------------------------------------------

#ifndef __DEBNOT_H__
#define __DEBNOT_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF 
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))


# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation
# define EXCEPT_VERBOSE          0x00000010      // Output message even for "quiet" exceptions


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


//
// Back to the info level stuff.
//

//
// For C++. and in a module which has access to GetProfileInt, automatically
//  initialise the info level from a setting in the [Cairo Infolevels] section
//  of win.ini
//

# if defined(__cplusplus) && defined(_CAIRO_) && !defined(KERNEL) && defined(GetProfileInt)

#  define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = GetProfileIntA (      \
                                                        "Cairo Infolevels", \
                                                        #comp,              \
                                                        DEF_INFOLEVEL );    \
        extern EXTRNC char *comp##InfoLevelString = #comp;

# else

// Simple initialisation
#  define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;        \
        extern EXTRNC char *comp##InfoLevelString = #comp;

# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
//# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0


//
// The following section adds the API's used for the performance snapshots
//


#if PERFSNAP == 1

#ifdef __cplusplus
extern "C" {
#endif

void _stdcall InitPerformanceMetering(char const * const);
void _stdcall Perfon(char const * const);
void _stdcall Perfsnap(char const * const, int const);
void _stdcall Perfcomment(char const * const s);
void _stdcall Perfdelta(char const * const, int const);
void _stdcall Perfoff(char const * const);
void _stdcall EndPerformanceMetering(char const * const);

#ifdef __cplusplus
}
#endif

#define PSNAPINIT(pszFileKey) InitPerformanceMetering(pszFileKey)
#define PSNAPEND() EndPerformanceMetering(NULL)
#define PSNAP(s) Perfsnap(s,0)
#define PSNAPL(s,l) Perfsnap(s,l)
#define PSNAPC(s) Perfcomment(s)
#define PSNAPDELTA(s) Perfdelta(s,0)
#define PSNAPDELTAL(s,l) Perfdelta(s,l)
#define PSNAPON(s) Perfon(s)
#define PSNAPOFF(s) Perfoff(s)

#else   // PERFSNAP == 1

#define InitPerformanceMetering(x)
#define Perfon(x)
#define Perfsnap(x,y)
#define Perfcomment(x)
#define Perfdelta(x,y)
#define Perfoff(x)
#define EndPerformanceMetering(x)

#define PSNAPINIT(pszFileKey)
#define PSNAPEND()
#define PSNAP(s)
#define PSNAPL(s,l)
#define PSNAPC(s)
#define PSNAPDELTA(s)
#define PSNAPDELTAL(s,l)
#define PSNAPON(s)
#define PSNAPOFF(s)

#endif


//
// If the sampling profiler is to be used, then here are its includes
//
//

#ifdef WIN32
#if (DBG == 1) || (RTLPROFILE == 1)

#ifdef __cplusplus
extern "C" {
#endif
void _stdcall InitSamplingProfiler(void);
void _stdcall EndSamplingProfiler(void);
#ifdef __cplusplus
}
#endif


#define INITSAMPLINGPROFILER    InitSamplingProfiler()
#define ENDSAMPLINGPROFILER     EndSamplingProfiler()

#else   // RTLPROFILE == 1

#define INITSAMPLINGPROFILER
#define ENDSAMPLINGPROFILER

#endif  // RTLPROFILE == 1
#endif  // WIN32

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilguisc.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILogUISConnect.H | Header for interface <i ILogUISConnect>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGUISC_H
#	define _ILGUISC_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32


// ===============================
// INTERFACE: ILogUISConnect
// ===============================

// TODO: In the interface comments, update the description.
// TODO: In the interface comments, update the usage.

// -----------------------------------------------------------------------
// @interface ILogUISConnect | See also <c CILogUISConnect>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogUISConnect, IUnknown)
{
	// @comm IUnknown methods: See <c CILogUISConnect>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogUISConnect methods: See <c CILogUISConnect>.
	
 	STDMETHOD  (Init)		(IUnknown *punkTracer)				 	PURE;
 	STDMETHOD  (Shutdown)	(void)				 	PURE;

};

#endif _ILGUISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilgwrta.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILOGWRTA.H | Header for interface <i ILogWriteAsynch>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 06/02/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGWRTA_H
#	define _ILGWRTA_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "logrec.h"  // logmgr general types

class CAsynchSupport; //forward class declaration

// ===============================
// INTERFACE: ILogWriteAsynch
// ===============================

// TODO: In the interface comments, update the description.
// TODO: In the interface comments, update the usage.

// -----------------------------------------------------------------------
// @interface ILogWriteAsynch | See also <c CILogWriteAsynch>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogWriteAsynch, IUnknown)
{
	// @comm IUnknown methods: See <c CILogWriteAsynch>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogWriteAsynch methods: See <c CILogWriteAsynch>.
	
 	STDMETHOD  (Init)	(ULONG cbMaxOutstandingWrites)				 	PURE;
 	STDMETHOD  (AppendAsynch)	(LOGREC* lgrLogRecord, LRP* plrpLRP, CAsynchSupport* pCAsynchSupport,BOOL fFlushHint,ULONG* pulAvailableSpace)				 	PURE;
	STDMETHOD  (SetCheckpoint) (LRP lrpLatestCheckpoint,CAsynchSupport* pCAsynchSupport, LRP* plrpCheckpointLogged)				 	PURE;

};

#endif _ILGWRTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilgstor.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILGSTOR.H | Header for interface <i ILogStorage>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 10/18/94 | rcraig | Created: For WPGEP COM lab.
// @rev 1 | 04/04/95 | rcraig | Updated: For Viper COM DLL templates.
// @rev 2 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGSTOR_H
#	define _ILGSTOR_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

typedef enum _tagSTREAMMODE
{
    STRMMODEREAD        = 0x00000001, //@emem READ mode
    STRMMODEWRITE       = 0x00000002  //@emem WRITE mode
} STRMMODE;




// ===============================
// INTERFACE: ILogStorage
// ===============================


// -----------------------------------------------------------------------
// @interface ILogStorage | See also <c CILogStorage>.<nl><nl>
// Description:<nl>
//   Provide the physical log storage abstraction<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------
DECLARE_INTERFACE_ (ILogStorage, IUnknown)
{
	// @comm IUnknown methods: See <c CILogStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogStorage methods: See <c CILogStorage>.
	
 	STDMETHOD  (OpenLogStream)				(LPSTR lpszStreamName, DWORD grfMode, LPVOID FAR* ppvStream)				 	PURE;
 	STDMETHOD  (OpenLogStreamByClassID)		(CLSID clsClassID, DWORD grfMode, LPVOID FAR* ppvStream)				 	PURE;
 	STDMETHOD  (LogFlush)				(void)				 	PURE;
    virtual ULONG	   (GetLogSpaceNeeded)	(ULONG ulRecSize)		    PURE;
};

#endif _ILGSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilgwrite.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILOGWRITE.H | Header for interface <i ILogWrite>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGWRITE_H
#	define _ILGWRITE_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogWrite
// ===============================


// -----------------------------------------------------------------------
// @interface ILogWrite | See also <c CILogWrite>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogWrite, IUnknown)
{
	// @comm IUnknown methods: See <c CILogWrite>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogWrite methods: See <c CILogWrite>.
	
 	STDMETHOD  (Append)	(LOGREC* rgLogRecords, ULONG cbNumRecs, LRP *rgLRP,ULONG* pcbNumRecs,LRP* pLRPLastPerm, BOOL fFlushNow,ULONG* pulAvailableSpace)				 	PURE;
	STDMETHOD  (SetCheckpoint) (LRP lrpLatestCheckpoint)				 	PURE;
};

#endif _ILGWRITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ilrp.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module ILRP.H | Header for interface <i ILogRecordPointer>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILRP_H
#	define _ILRP_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogRecordPointer
// ===============================


// -----------------------------------------------------------------------
// @interface ILogRecordPointer | See also <c CILogRecordPointer>.<nl><nl>
// Description:<nl>
//   Provide LRP functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogRecordPointer, IUnknown)
{
	// @comm IUnknown methods: See <c CILogRecordPointer>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogRecordPointer methods: See <c CILogRecordPointer>.
	
 	virtual DWORD  (CompareLRP)		(LRP lrpLRP1, LRP lrpLRP2)				 	PURE;
 	STDMETHOD  (LastPermLRP)	(LRP* plrpLRP)    PURE;
 	STDMETHOD  (GetLRPSize)	(LRP  lrpLRP, DWORD *pcbSize)    PURE;

};

#endif _ILRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\layout.h ===
/*
 * @doc
 *
 * @module LAYOUT.H |
 *       Log storage Page Layout and structures stored inside log records.
 *       Miscellaneous data structures used for recovery support.
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code
 * @rev 1 | 29-Mar-95 | wilfr | Removed transaction stuff
 * @rev 2 | 03-Apr-95 | wilfr | seqno to gennum changes and removal of CLR processing  
 *
 */


#ifndef __LAYOUT_H__
#define __LAYOUT_H__


//+----------------------------------------------------------------------------
//
//           Forward class declarations.
//
//-----------------------------------------------------------------------------

class CBuffer;			// cbuf


/*
 * @enum RCT | Describe the number and type of log records in a record page.
 *
 * hungarian rct
 */
typedef enum _tagRECORDTYPE
{
	RCTUpdate         = 0x00000001,      //@emem Normal user record.
    RCTUsrChkPt      = 0x00000002,      //@emem User checkpoint record - one for each
                                         //		call to SetCheckpoint
    RCTBeginChkPt     = 0x00000003,      //@emem Written at the start of the
                                         //  	 chkpt.
    RCTEndChkPt       = 0x00000004,      // @emem Written at the end of the chkpt.
                                         // 	  Log storage is flushed after this
                                         // 	  record is written.
    RCTStrmChkpt = 0x00000005,      // @emem Log record for the stream
                                         // 	  table contents.Must lie between 
										 //       the begin	and end checkpoint
                                         // 	  records.
    RCTRSLChkpt = 0x00000006			 // @emem Log record for the restart info
} RCT;





/*
 * @struct LOGRECHEADER |
 * 		This is the header of a log record.  Together with the sequence
 * 		number of its page, it gives the current position of the log record.
 * 		All offsets in this record are relative to the start of the log
 * 		storage.
 *
 * hungarian lrh
 */

typedef struct _LOGRECHEADER
{
    ULONG ulThisOffset;          //@field Offset of this record in log storage.
    ULONG ulPrevPhyOffset;       //@field Previous log record Offset in storage.
    ULONG ulDataLength;          //@field Length of user supplied data in log record.
	USHORT  usUserType; 	//@field The client specified log record type
    USHORT  usSysRecType; 	//@field The log manager defined log record types
    ULONG ulClientID;            //@field Client ID for this record (##WGR - for future use)
	ULONG ulNextPhyOffset;       //@field Offset of next record - could be in next file								  
} LOGRECHEADER;



/*
 * @struct  RANGEENTRY  |
 *  	This is the descriptor for a buffer necessary to be obtained to
 *  	write to or read from the log storage.  A log record can consist
 *  	up to four ranges; the trailing bytes of the first page where the
 *  	record is written, full pages until the end of the log storage,
 *  	full pages from the beginning of the log storage (necessary when
 *  	the log storage is fixed size), and the leading bytes of the last
 *  	page where the record is written.
 *		
 *  	Each range can consist of one or pages.
 *
 * hungarian re
 */

typedef struct _RANGEENTRY
{
    ULONG    ulRecStart;       //@field Offset in the first buffer page
                               // 		where the user data starts.  This is relative to
                               //		RECORDPAGE.achData
    ULONG    cbRecLength;      //@field Number of user bytes stored in the buffer.
    ULONG    ulFirstPage;      //@field Offset of first file page where
                               // 		user data is to be copied.
    ULONG    cbPhyLength;      //@field Number of bytes that must be pinned.
                               // 		This is a multiple of page size.
    ULONG    ulGenNum;         //@field Generation number to be stored in each page.
    CBuffer  *pcbuf;           //@field The buffer for this range.
    BOOL  fFlush;           //@field True implies that the buffer needs to be
                               // 		flushed when released.  This is because it
                               // 		is full during writes or because no more
                               // 		records can be obtained from it during reads.
} RANGEENTRY;


/*
 *  @enum READMODE  |
 *  	Defines the order in which log records are read.
 *
 *  hungarian remo
 */

typedef enum _tagREADMODE
{
    REMOUNDONEXT        = 0x00000001, //@emem Read next xact record to be undone.
                                      //   	  Used during transaction abort.
    REMOXACTPREVIOUS    = 0x00000002, //@emem Read previous xact record.
    REMONEXT            = 0x00000003, //@emem Read next record.
    REMOPREVIOUS        = 0x00000004  //@emem Read previous record.
} REMO;


//+----------------------------------------------------------------------------
//  Constants to support checkpoint hysterisis.
//
//-----------------------------------------------------------------------------

const ULONG HYSTERISISBASE = 0x00000001;
const ULONG HYSTERISISOVERFLOW = 0x00000050;


//+----------------------------------------------------------------------------
//  Constant representing the log record to be one of our own.
//
//-----------------------------------------------------------------------------

const ULONG LMID = 0xFFFFFFFF;          //##WGR the LM's clientID.

#endif    // __LAYOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logexp.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module LOGMGRDL.CPP | Source for <f DllGetClassObject> <f DllCanUnloadNow>.<nl><nl>
// Description:<nl>
//   COM DLL handler functions for class factories:<nl>
//   <c CFLogMgr>.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------
#ifndef _LOGEXP_H
#define _LOGEXP_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logconst.h ===
//
// Logconst.h
//
// Log manager global constants
//

#ifndef __LOGCONST__H__

#define __LOGCONST__H__

// ===============================
// CONSTANTS:
// ===============================

#define MIN_LOG_TIMER_INTERVAL 		 5 				//milliseconds

#define DEFAULT_LOG_TIMER_INTERVAL	 10 			//milliseconds

#define MAX_LOG_TIMER_INTERVAL		((ULONG) -1)	//milliseconds

#define MIN_LOG_FLUSH_INTERVAL 		 5 				//milliseconds

#define DEFAULT_LOG_FLUSH_INTERVAL	 50 			//milliseconds

#define MAX_LOG_FLUSH_INTERVAL		1000			//milliseconds

#define MIN_LOG_CHKPT_INTERVAL 		 100 			//milliseconds

#define DEFAULT_LOG_CHKPT_INTERVAL	 50000 	//milliseconds

#define MAX_LOG_CHKPT_INTERVAL		((ULONG) -1)	//milliseconds

#define MAX_OUTSTANDING_CHKPT		25

#define MIN_LOG_BUFFERS					50

#define MAX_LOG_BUFFERS					500

#define DEFAULT_LOG_BUFFERS				200

#define INIT_GENERATION_NO		1

#define MIN_GENERATION_NO       2

#define MINFORCEFLUSH 20 //percentage of outstanding asynch writes threshold for forcing flush

#define MINFLUSHCOUNT 3  // minimum number of writes outstanding to force flush

#define LOGMGRSAVEDSPACE 4 //number of pages to "save" for the logmgr 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logmgr.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module LOGMGR.H | Header for core class <c CLogMgr>.<nl><nl>
// @rev 0 | 05/10/95 | rbarmes | Cloned: For logmgr.dll.
// -----------------------------------------------------------------------

#ifndef _LOGMGR_H
#	define _LOGMGR_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32
#include <time.h>
#include "utsem.h"							// Concurrency utilities.

// TODO: KEEP: For each additional interface implementation:
//       - Copy the first two includes below to the bottom of these includes.
//       - Update your copy with your headers and class names.
#include "ILGSTOR.h"						// ILogStorage.
#include "CILGSTOR.h"						// CILogStorage.
#include "ILGREAD.h"						// ILogRead.
#include "CILGREAD.h"						// CILogRead.
#include "ILGWRITE.h"						// ILogWrite.
#include "CILGWRIT.h"						// CILogWrite.
#include "ILRP.h"							// ILogRecordPointer.
#include "CILRP.h" 							// CILogRecordPointer.
#include "ILGINIT.h"						// ILogInit.
#include "CILGINIT.h" 						// CILogInit.
#include "ILGWRTA.h"						// ILogWrite.
#include "CILGWRTA.h"						// CILogWrite.
#include "ILGCREA.h"						// ILogCreateStorage.
#include "CILGCREA.h" 						// CILogCreateStorage.
#include "ILGUISC.h"						// ILogUICConnect.
#include "CILGUISC.h"						// CILogUICConnect.

#include "logrec.h"
// ===============================
// DEFINES:
// ===============================

#undef EXPORT								// Necessary for static member function.
#ifdef  WIN32
#	define EXPORT __declspec(dllexport)
#else
#	define EXPORT __export
#endif WIN32

//
//  Dummy index used to indicate variable length array.
//

//+---------------------------------------------------------------------------
//
//  Forward Class Declarations.
//
//------------------------------------------------------------------------------



class CLogStorage;              // clgstr

class CLogStream;				// clgstrm

class CLogState;                // clgs

class CRestartTable;            // crst

class CWriteMap;                // cwm;

struct _LOGRECHEADER;           // lrh

struct _RESTARTLOG;      		// rsl

class CInitSupport;

class CChkPtNotice
  {
   public:
   	LRP					lrpLRP;
	CAsynchSupport* pCAsynchSupport;
  };



// ===============================
// CLASS: CLogMgr
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// TODO: KEEP: For each additional interface implementation:
//       In the class comments, in Description, add a cross-reference
//       (eg: interface implementation "CILogStorage" has cross-reference "<c CILogStorage>").
	
#define EVENTARRAYSIZE		4
#define FLUSHEVENTENTRY		0
#define CHKPTEVENTENTRY		1
#define CRASHEVENTENTRY		2
#define WAKEUPEVENTENTRY	3

#define MAX_TIMEOUTS	1000


// -----------------------------------------------------------------------
// @class CLogMgr | Core class.<nl><nl>
// Threading: Thread-safe (see concurrency comments on individual methods).<nl>
// Platforms: Win.<nl>
// Includes : COMT_GU.H.<nl>
// Ref count: Per object.<nl>
// Hungarian: CLogMgr.<nl><nl>
// Description:<nl>
//   Class factory of this core class is <c CFLogMgr>.<nl>
//   Interface implementations of this core class are:<nl>
//   <c CILogStorage>.<nl><nl>
// Usage:<nl>
//   This is just wiring.  Where's the beef?
// -----------------------------------------------------------------------
class CLogMgr: public IUnknown				// @base public | IClassFactory.
{   
// TODO: KEEP: For each additional interface implementation:
//       - Copy the friend declaration below to the bottom of these friends.
//		 - Replace "CILogStorage" with the name of your interface implementation.
friend class CILogStorage;
friend class CLogState;
friend class CILogRead;
friend class CILogWrite;
friend class CILogRecordPointer;
friend class CILogInit;
friend class CILogWriteAsynch;
friend class CLogStream;
friend class CILogCreateStorage;
friend class CILogUISConnect;
friend DWORD 	_FlushThread(LPDWORD lpdwParam);

public:		// ------------------------------- @access Samsara (public):
	CLogMgr  (void); // @cmember .
	CLogMgr  (IUnknown* pIUOuter); // @cmember .
	~CLogMgr (void); // @cmember .
	static HRESULT EXPORT			CreateInstance (CLogMgr FAR* FAR* o_ppCLogMgr, IUnknown* i_pIUOuter); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP			QueryInterface (REFIID iid, LPVOID FAR* ppv); // @cmember .
	virtual STDMETHODIMP_(ULONG)	AddRef (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	Release (void); // @cmember .
 	//@cmember	The periodic checkpoint member function will write a
    //   		checkpoint if no checkpoint has occurred since the last periodic
    //   		checkpoint.  Otherwise, it will schedule the next periodic
    //   		checkpoint to occur X seconds after the last (forced)
    //   		checkpoint.  The number of forced checkpoints that occur
    //   		between periodic checkpoints are tracked by a count that is
    //   		reset by each periodic checkpoint.
	VOID  		PeriodicCheckpoint();
	//BUGBUG need to find better way than making this public...
  	//@cmember 	Execute buffer flush
  	VOID 		_Flush(IN ULONG ulGenNum, IN ULONG ulOffset, IN BOOL fIsShutdown);

  	//@cmember 	Set by the first caller to start the flush.
  	BOOL      	_fFlush;

	//@cmember 	TRUE => The recovery object is being shutdown.
  	BOOL       	_fShutdown;

  	//@cmember  Set to true if the client wants to simulate failure.  Used for testing.
  	BOOL       	_fFailure;

     //@cmember 	Gets maximum outstanding appends possible
    ULONG		  GetMaxOutstanding(void);

    //@cmember 	Gets current number of  outstanding appends
    ULONG		  GetCurrentActive(void);
    //@cmember 	Gets the NextFlush interval
	UINT    	GetNextFlush(void);

    //@cmember 	Gets the NextFlush interval
	UINT    	GetNextChkPt(void);

    //@cmember 	Set the low water mark
	HRESULT _SetLowWater(LRP lrpLowWater, BOOL fForceRestart);

    //@cmember 	Tracer Iunknown
	IDtcTrace*	m_pIDtcTrace;

	//@cmember  Force the exit of the logmgr flush thread
    HRESULT		CrashShutDown();

protected:	// ------------------------------- @access Core methods (protected):
	HRESULT		Init (BOOL fCreate, ULONG *pulLogCapacity,ULONG *pulLogSpaceAvailable,LPTSTR ptstrFullFileSpec,ULONG  ulInitSig,BOOL fOverwrite, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval,UINT uiLogBuffers); // @cmember .
  
  
  	//@cmember	This operation allows a client to flush the log storage up to and
    //    		including a particular log record.  This operation impacts both
    //    		the log storage and the log state.  Log storage flushes are
    //   		mutually exclusive.  A caller who attempts to flush a log storage
    //   		while another flush is in progress will block until the other flush
    //    		completes.   A flush will continue until there are no more flush
    //    		requests pending.
  		//@cmember 	This member function is responsible for restoring the recovery
	//   		object to the state at the time of the previous shutdown or crash.
	//   		It performs the Aries protocol to drive the redo and the undo of
	//   		client operations.  It has the following steps:
	//   1.     A read map to do a forward read is constructed.  This read
	//   		map is used to read the last checkpoint records.  For
	//   		checkpoint records that hold the recovery tables the
	//   		recovery table constructor is invoked.
	//   2.     A readmap is constructed for forward reads.  This readmap
	//   		is used to perform the analysis phase of the Aries protocol.
	//   		It also determines the last completely written page of the
	//   		log storage.
	//   3.     A readmap is constructed for forward reads.  This readmap
	//   		is used to perform the redo phase of the Aries protocol.  At
	//   		the end of this phase the system is in the state it was at the
	//   		time of the crash.
	//   4.     A readmap is constructed for backward reads.  This
	//   		readmap is used to perform the undo phase of the Aries
	//   		protocol.
	VOID		DoRecovery(IN CInitSupport *pcis);
  
    HRESULT  	FlushToLRP(IN LRP lrpToFlush);


	// ?
 	VOID  SetFailure();

 	//@cmember	Forced checkpoints occur as part of a log record write if a fixed
    //   		size log storage is more than half full.  Thus a forced checkpoint
    //   		can only occur when the client is writing out many log records.
    //   		The forced checkpoint member function will simply write out a
    //   		checkpoint provided no checkpoint is occurring concurrently.
    //   		To prevent multiple forced checkpoints being written one after
    //   		another, forced checkpoints have a hysterisis count associated
    //   		with them.  This value is initially set to one.  This value is
    //   		decremented each time a forced checkpoint is attempted.  If a
    //   		forced checkpoint attempt decrements the hysterisis count to
    //   		zero, the forced checkpoint is written and the hysterisis count
    //   		set to some value (0x80 in the current implementation).  This
    //   		value is decremented each time a log write finds the log storage
    //   		is more than half full.  When this value goes to zero, another
    //   		forced checkpoint is written.
    //   		Writing a periodic checkpoint with no forced checkpoint in
    //   		between causes the hysterisis count to be reset to one.
    //   		Forced checkpoints are written by the client after a write sets
    //   		the fFullLog flag to TRUE.  This is necessary because the client
    //   		may be holding resources needed by the checkpoint and thus
    //   		cause the checkpoint to deadlock.
	VOID		ForceCheckpoint(IN BOOL fIsLogFull);

  	//@cmember 	Return the LRP of the last written log record
  	LRP   		GetLastWrittenLRP();

	//@cmember  Set the RSL for reading;
	VOID		_SetReadRSL(ULONG *pulOffset,ULONG *pulGenNum);

	//@cmember  Reset the RSL after reading;
	VOID		_ResetRSL(ULONG ulOffset,ULONG ulGenNum);



private:	// ------------------------------- @access Reference counting data (private):
	ULONG			m_ulcRef;				// @cmember Object reference count.
	CSemExclusive	m_semxRef;				// @cmember Exclusive semaphore for object reference count.

private:	// ------------------------------- @access Interface implementation members (private):

	// TODO: KEEP: For each additional interface implementation:
	//       - Copy the member declaration below to the bottom of these members.
	//		 - Replace "CILogStorage" with the name of your interface implementation.
	CILogStorage	m_CILogStorage;					// @cmember See also <c CILogStorage>.
	CILogRecordPointer		m_CILogRecordPointer;	// @cmember See also <c CILogRecordPointer>.
	CILogInit		m_CILogInit;					// @cmember See also <c CILogInit>.
	CILogCreateStorage		m_CILogCreateStorage;   // @cmember See also <c CILogCreateStorage>.
	CILogUISConnect	m_CILogUISConnect;				// @cmember See also <c CILogUISConnect>.

private:	// ------------------------------- @access Core data (private):
	BOOL			m_fFlushThreadStarted; //@cmember TRUE if started;
    ULONG 			m_ulLogPages;   //@cmember number of log pages   
	STRMTBL	*		m_pstrmtblStream; //@cmember tail of list of streams

  	CSemExclusive    m_cmxsChkPt;	//@cmember 	The write lock that must be held 
  	                                      //    to manipulate the AppendNotify lists
    ULONG			m_cbCurrChkPts; //@cmember  The current count of outstanding
	                                //          checkpoint requests
    ULONG			m_cbMaxChkPts;	//  @cmember Max limit of outstanding appends
    CChkPtNotice * m_rgCChkPtNotices;
	ULONG			m_ulListHead;
	ULONG			m_ulListEnd;
	BOOL			m_fListEmpty;
	LONG			m_ulFlushReqs;
	LONG			m_ulChkPtReqs;
//@access Private Members
private:

  	//@cmember 	Perform the actual log write.
  	LRP   		_Write(IN ULONG ulNoElements,IN LOGREC *plgrWriteElements,IN BOOL fFlushLog,IN BOOL fMarkAsOldest,OUT ULONG *pulAvailableSpace, IN ULONG ulClientID);

  	//@cmember 	Actually do a checkpoint.
  	VOID 		_DoCheckpoint(IN BOOL fIsShutdown,IN BOOL fIsLogFull);

  	//@cmember 	Begin timer for flush and checkpoints
  	VOID    	_StartFlushThread(void);

  	//@cmember 	Set the checkpoint timer up for the next checkpoint
  	VOID    	_RescheduleCheckpoint(BOOL fFromNow);

  	//@cmember 	Set the checkpoint timer up for the next checkpoint
  	VOID    	_RescheduleFlush(BOOL fFromNow);

  	//@cmember 	Tries to cancel the checkpoint timer.
  	BOOL 	_NoConcurrentCheckpoint();

  	//@cmember  This operation determines if a thread is waiting for the
  	//          checkpoint to complete before doing the shutdown.  If so the
  	//          thread is signalled.
  	VOID    	_SignalIfShutdown();

  	//@cmember 	Writes the individual checkpoint records.
  	ULONG   	_WriteChkPt(_LOGRECHEADER *plrh,LOGREC *plgr,ULONG ulBytesNeeded);
  	  	//@cmember 	Does the aries pass over the log storage.
  	VOID    	_Recover(CInitSupport *pcis,_RESTARTLOG *prsl,ULONG *pulNextOffset);
   	//@cmember 	Gets the offset for the next record to process
	VOID    	_GetNextOffset(_LOGRECHEADER *plrh,ULONG *pulOffset,ULONG *pulGenNum);

  	//@cmember 	Process recovery for the given log record
  	VOID    	_ProcessRecord(ULONG  cBufUsed,LOGREC *algr,_LOGRECHEADER  *plrh,CInitSupport *pcis,ULONG ulStartGenNum);

	
	//
  	//  data members.
  	//
	//@cmember 	The physical log storage.
  	CLogStorage   	*_pclgstr;

	//@cmember 	The state of the logical log storage.
  	CLogState     	*_pclgs;

	//@cmember 	The write lock that must be held by all write and flush operations.
  	CSemExclusive	_cmxsWrite;

	// @cmember The event that is waited on by all callers who try to flush the storage
	//			when the flag _fFlushInProgress is TRUE.
	CEventSem	     _cesFlush;

	//@cmember  The LRP of the next page in the log storage that must be flushed.
	LRP				 _lrpFlushLRP;

	//@cmember 	Event is signalled if a caller who completes a checkpoint finds a shutdown
	//          waiting behind him.
  	CEventSem     	_cesShutdown;

	//
	//  The following variables are used to set up and ensure that periodic
	//  checkpoints of the log storage are performed.  Since the log storage
	//  can also be force checkpointted if it becomes more than half full,
	//  the hysterisis and checkpoint count variables are used to ensure
	//  that checkpoints will not occur too frequently.
	//
	//@cmember  TRUE => a checkpoint is in progress.
  	BOOL       	_fCheckpoint;

	//@cmember 	Number of forced checkpoints.
  	ULONG         	_ulChkptCount;

	//@cmember 	The default interval used to test for flush/checkpoint
  	UINT  		_liTimerInterval;

	//@cmember 	The default interval between checkpoints
  	UINT  			_liChkPtInterval;

	//@cmember 	The default interval between checkpoints
  	UINT  			_liFlushInterval;

 	//@cmember 	The array of handles to events
  	HANDLE  	_hEventArray[EVENTARRAYSIZE];

 	//@cmember 	The handle to the flush event
  	HANDLE  	_hFlushEvent;

 	//@cmember 	The handle to the checkpoint event
  	HANDLE  	_hChkPtEvent;

 	//@cmember 	The handle to the checkpoint event
  	HANDLE  	_hCrashEvent;

 	//@cmember 	The handle to the wakeup event
  	HANDLE  	_hWakeupEvent;

 	//@cmember 	The number of timeouts received by the flush thread
	DWORD		m_dwTimeoutCount;

	BOOL		_fCrashNow;

	//@cmember 	The handle to the flush and checkpoint thread
  	HANDLE  		_hFlushThread;

	//@cmember 	The thread id of the flush and checkpoint thread
	DWORD			_dwFlushThreadID;

	//@cmember 	The next checkpoint
  	UINT  			_liNextChkPt;

	//@cmember 	The next flush
  	UINT  			_liNextFlush;

	//@cmember 	The last lrp written
  	LRP            _LRPLastWritten;

	//@cmember 	The write map for logging
  	CWriteMap     	*_pcwm;

	//@cmember 	The current page size in use
  	ULONG         	_ulPageSize;
	

	// for debugging only

	DWORD			m_dwLastSetCheckpoint;

	// FIX: COM+ bug # 3652

	BOOL			m_fSleeping;

};

#endif _LOGMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logmgrcf.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module LOGMGRCF.H | Header for class factory <c CFLogMgr>.<nl><nl>
// Description:<nl>
//   Class factory for <c CLogMgr>.
// @rev 0 | 10/18/94 | rcraig | Created: For WPGEP COM lab.
// @rev 1 | 03/16/95 | rcraig | Updated: For Viper COM DLL templates.
// @rev 2 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------



#ifndef _LOGMGRCF_H
#	define _LOGMGRCF_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "utAssert.h"						// Assert macros.

#include "utsem.h"							// Concurrency utilities.

// ===============================
// CLASS: CFLogMgr
// ===============================


// -----------------------------------------------------------------------
// @class CFLogMgr | Class Factory for <c CLogMgr>.<nl><nl>
// Threading: Thread-safe (see concurrency comments on individual methods).<nl>
// Platforms: Win.<nl>
// Includes : LOGMGR.H.<nl>
// Ref count: Per object.<nl>
// Hungarian: n/a.
// -----------------------------------------------------------------------
class CFLogMgr : public IClassFactory			// @base public | IClassFactory.
{
public:		// ------------------------------- @access Samsara (public):
	CFLogMgr(); // @cmember .
	~CFLogMgr(); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP			QueryInterface (REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
	virtual STDMETHODIMP_(ULONG)	AddRef (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	Release (void); // @cmember .

public:		// ------------------------------- @access IClassFactory (public):
	virtual STDMETHODIMP			CreateInstance (IUnknown* i_pIUnkOuter, REFIID i_iid, LPVOID FAR* o_ppv); // @cmember .
    virtual STDMETHODIMP			LockServer (BOOL i_fLock); // @cmember .

private:	// ------------------------------- @access Reference counting data (private):
	ULONG			m_ulcRef;				// @cmember Object reference count.
	CSemExclusive	m_semxRef;				// @cmember Exclusive semaphore for object reference count.
};

#endif _LOGMGRCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logmgrgu.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module COMT_GU.H | Header for all project guids.<nl><nl>
// Description:<nl>
//   All project guids are declared here.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 5/09/95 | rbarnes | Created - note that the following are
//                             reserved
//                             d959f1b9-9e42-11ce-8bca-0080c7a01d7f
// -----------------------------------------------------------------------


#ifndef _LGMGRGU_H
#	define _LGMGRGU_H

// ===============================
// INCLUDES:
// ===============================

// TODO: KEEP: For each set of <n> guids added to this project:
// 		 - Run command-line utility "UUIDGEN -s -n<n> -o<path and file>.tmp".
//       - Copy the tmp file contents; paste them to the end of the guids below.
//		 - Assign each guid a name with a prefix of "CLSID_", "IID_", or "GUID_".
//       - Convert each INTERFACENAME struct to the illustrated DEFINE_GUID format.


// CLSID_CLgMgr: {d959f1b0-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (CLSID_CLogMgr, 0xd959f1b0, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);


// IID_ILogStorage: {d959f1b1-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogStorage, 0xd959f1b1, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogRead: {d959f1b2-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogRead, 0xd959f1b2, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogWrite: {d959f1b3-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogWrite, 0xd959f1b3, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogRecordPointer: {d959f1b4-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogRecordPointer,0xd959f1b4, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogInit: {d959f1b5-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogInit, 0xd959f1b5, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogWriteAsynch: {d959f1b6-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogWriteAsynch, 0xd959f1b6, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogCreateStorage: {d959f1b7-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogCreateStorage, 0xd959f1b7, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogUISConnect: {d959f1b8-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogUISConnect, 0xd959f1b8, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

#endif _LGMGRGU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logstate.h ===
/*
 * @doc
 *
 * @module LOGSTATE.H |
 * 		CLogState is the class that contains the current state of the log.
 *   	It is initialized from the last restart area written to the log.
 *   	It is updated when log records are written.  The methods of this
 *   	class determine the way a log record is laid down in the log.
 *   	It provides the log storage with a write or read map to be used to
 *   	write or read log records.
 *	 	
 *   	CWriteMap defines the mapping of a log record given its length and
 *   	starting position on the log to the log storage pages.  The map
 *   	is then used to get the memory buffers from the log storage and to
 *   	copy the user data into the log buffers.
 *	 	
 *   	CReadMap defines a mapping of a log record given its length and
 *   	starting position on the log to the log storage pages where that
 *   	record is written.
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code
 * @rev 1 | 29-Mar-95 | wilfr | Removed transaction stuff
 * @rev 2 | 03-Apr-95 | wilfr | seqno to gennum changes
 *
 */

#ifndef __LOGSTATE_H__
#define __LOGSTATE_H__

class CLogMgr; //forward class declaration
/*
 * @class  CWriteMap |
 *		Provides a mapping between user supplied write records and the log storage.
 *
 * hungarian crm
 */

class CWriteMap
{
//@access Public Members
public:
	//@cmember  Constructor
    CWriteMap(IN CLogStorage *pclgsto,IN ULONG ulEntryCount,IN LOGREC *algr,IN WRITELISTELEMENT *pwle);

    //@cmember  Default Constructor
    CWriteMap();

    //@cmember  Destructor
    ~CWriteMap();

    //@cmember  Init after default constructor
    VOID 	Init(IN CLogStorage *pclgsto,IN ULONG ulEntryCount,IN LOGREC *algr,IN WRITELISTELEMENT *pwle);

    //@cmember  Returns the computed client data plus header length.
    ULONG   GetRecordLength();

    //@cmember  sets the next range record in the write map.
    VOID    AddRange(IN RANGEENTRY &re);

    //@cmember  copy of the client data into the log storage buffers.
    VOID    CopyRecord(IN LOGRECHEADER &lrh);

    //@cmember	Sets the number of bytes that need to be allocated to align
    //          the next record on a ulALIGN boundary.
    VOID    SetAlign(IN ULONG ulAlign);

    //@cmember  Compute alignment bytes
    ULONG   GetAlign();


//@access Private Members
private:
    //
    //  Initial Parameters
    //
    //@cmember  Number of buffers in array 0 => linked list.
    ULONG                   _ulEntryCount;

    //@cmember 	Array of user buffers.
    LOGREC       *_algr;

    //@cmember  Linked list of buffers.
    WRITELISTELEMENT        *_pwle;

    //@cmember 	Number of date bytes in the message.
    ULONG                   _ulByteLength;

    //@cmember 	Log storage reference.
    CLogStorage             *_pclgstr;

    //@cmember 	Cursor variables into client buffers during copy
    ULONG                   _ulCurrentIndex;

    //@cmember 	The current write element
    WRITELISTELEMENT        *_pwleCurrentElement;

    //@cmember 	The current length
    ULONG                   _ulCurrentLength;

    //@cmember 	The current address
    CHAR                    *_pchCurrentAddress;

    //@cmember 	Alignment bytes needed.
    ULONG                   _ulAlign;

    //@cmember 	Number of bytes allocated for alignment by CLogState::AttemptWrite
    ULONG                   _ulAlignAlloc;

    //
    //  Buffer structures for the client log record.
    //
    //@cmember 	Number of ranges where buffers must be allocated.
    ULONG                   _ulRangeCount;

    //@cmember 	The ranges.
    RANGEENTRY              _arre[4];

	//
    //  Internal Support Routines.
    //
    //@cmember 	Returns the address and length of the next buffer to be copied.
    BOOL 	_GetNextClientBuffer();

    //@cmember 	Copy the client record or part of it into the buffer.
    VOID 		_CopyBuffer(IN ULONG ulRangeIndex);
};



/*
 * @class CReadMap |
 *      Provides a mapping between log storage records and user buffers log storage.
 *
 * hungarian crm
 *
 */

class CReadMap
{
friend class CILogRead;

//@access Public Members
public:
	//@cmember 	Constructor
    CReadMap(IN CLogStorage *pclgs,IN ULONG ulPageSize);

	//@cmember 	Destructor
    ~CReadMap();

	//@cmember 	Initialize the read map
  	VOID    InitReadMap(IN ULONG ulGeneration, IN ULONG ulOffset);

	//@cmember 	Returns start & size of the record to be read
    VOID    GetBounds(OUT ULONG *pulOffset,OUT ULONG *pulLength);
			
	//@cmember 	Get the number of buffers
    ULONG   GetBufCount();

	//@cmember 	Adds a range of buffer to the map.
    VOID    AddRange(IN RANGEENTRY &re);

	//@cmember 	Reads the next record and returns the buffer.
    BOOL ReadRecord(
			IN ULONG ulGeneration,
			IN ULONG ulBufCount,
			OUT ULONG *pulBufUsed,
			OUT LOGRECHEADER **pplrh,
			OUT LOGREC *algr, 
			IN BOOL fFree, 
			IN OUT ULONG *pulGenNum);

	//@cmember 	Release the buffers and get the header for the next record
 	BOOL ReleaseAndSet(
			IN ULONG ulGeneration,
			IN ULONG ulNextOffset);

    
//@access Private Members
private:
	//
    //  Private member functions
    //
	//@cmember 	For each page in the buffer the operation sets the address and
	//  		length of the write array element.
    VOID 	_SetRangeBuffers(LOGREC **pplgrNext,RANGEENTRY *preNext,ULONG *pulBufUsed,BOOL fFree);

	//@cmember 	obtain the log storage page that contains the log header of the
	//  		next record to be read.
    VOID    _SetUpResidue(IN ULONG ulGeneration);

	//@cmember 	Get the next page
    RECORDPAGE* _GetNextPage(RANGEENTRY *pre);

    //
    //  Next record parameters.
    //
	//@cmember 	Offset of next record to be read.
    ULONG			_ulOffset;

	//@cmember 	Length of next record to be read.
    ULONG           _ulLength;

    //
    //  Range structures.
    //
	//@cmember 	The count of ranges
	ULONG            _ulRangeCount;

	//@cmember 	The residue
    RANGEENTRY       _reResidue;

	//@cmember  Is this a residue
    BOOL          _fIsResidue;

	//@cmember 	The ranges
    RANGEENTRY       _arre[4];

	//@cmember 	The current log storage
    CLogStorage      *_pclgs;

	//@cmember 	The current page size
    ULONG            _ulPageSize;
};



/*
 * @class CLogState |
 *  	Maintains the current state of the file.  Is used to determine
 *  	how log records can be written and provides the information to
 *  	construct restart area buffers.
 *
 * hungarian clgs
 *
 */

class CLogState          // clgs
{
friend class CLogMgr;
friend class CILogStorage;
friend class CILogWrite;
friend DWORD _FlushThread(LPDWORD lpdwParam);

//@access Public Members
public:
	//@cmember	Constructor
 	CLogState(IN RESTARTLOG &rslCurrentRestartArea,IN ULONG ulSysPageSize);

 	//@cmember 	Returns a number that signifies the fraction of the log storage that is unused.
 	ULONG  	WhatFractionFree();

 	//@cmember 	Sees if a caller's log record can be fit into the
 	//         	log storage.  If possible, returns the physical
 	//         	layout of the record.
	ULONG   AttemptWrite(IN OUT LOGRECHEADER *plrh,IN CWriteMap &cwm,IN BOOL fFlush,IN BOOL fMarkAsOldest,IN ULONG ulBytesNeeded,IN ULONG ulChkptLen,IN OUT LRP *plrpWritten,OUT ULONG *pulStartGenNum);

	//@cmember 	Sets up a restart area buffer.
	VOID    GetRestartArea(OUT RESTARTLOG *prsl,OUT ULONG *pulAvailableSpace,IN BOOL fIsInit);

	//@cmember 	Determines if a given offset and sequence number are within the current range
	BOOL IsRecordInRange(IN ULONG ulGenNum,IN ULONG ulOffset,IN BOOL fChkBackEdge);

	//@cmember 	Sets up the physical record layout for a record whose bounds are specified.
	VOID    AttemptRead(IN CReadMap &crm, IN BOOL fRecovery);

	//@cmember 	Sets the oldest dirty seq no and offset     in the restart area.
	VOID    SetOldestDirtyRecord(ULONG ulGenNum, ULONG ulOffset,RECORDPAGE *prcpg);


	//@cmember 	Sets the position for the next record to be written and the position
	//         	of the last record completely written.  This is only called during recovery.
 	VOID    SetLeadingEdge(ULONG ulGenNum,ULONG ulOffset,ULONG ulNextOffset,ULONG *pulLastPageOffset,ULONG *pulLastRecOffset,ULONG *pulLastPageSpace);

	//@cmember 	Evaluates whether a checkpoint is necessary
	BOOL IsCheckpointUnnecessary();

	//@cmember 	The log storage was flushed up to the range specified
	BOOL AttemptFlush(IN ULONG ulGenNum,IN ULONG ulOffset,OUT ULONG *pulFlushOffset);

	//@cmember 	Evaluates whether a checkpoint is necessary.
	VOID 	EnsureCheckpointSpace(IN ULONG ulBytesNeeded,IN ULONG ulTabRecLen,IN BOOL fIsLogFull);



//@access Private Members
private:
	//@cmember 	Used to allocate a part of a log storage record page.
	BOOL	_MapOnePage(CReadMap &crm,RANGEENTRY *pre,ULONG *pulLength);

	//@cmember 	Using the state in the range parameter map as many pages
	//  		as possible for the record to be read.
	BOOL _MapPageRange(CReadMap &crm,RANGEENTRY *pre,ULONG *pulLength);

	//@cmember 	Used to allocate a part of a log storage record page.
	BOOL _AllocateFromCurrent(CWriteMap &cwm,ULONG *pulLength,RANGEENTRY *pre,BOOL fFlush);

	//@cmember 	Allocate as many pages as possible from the forward range.
	BOOL _AllocatePages(CWriteMap &cwm,ULONG *pulLength,RANGEENTRY *pre);

	//@cmember 	Handles the wrap around of a fixed size log during a write.
	VOID  	_DoWrapAround();

	//@cmember 	Adjusts the range variables if the allocation or map wrap around
	VOID  	_WrapRange(RANGEENTRY *pre);

	//@cmember 	Determines if the offset being freed is in the current range
	//     		being used by log records.  If it is the forward and backward
	VOID 	_FreeSpace(IN ULONG ulOffset);

	//@cmember 	Computes the state variables of the log.
	VOID  	_ComputeState(IN BOOL fInitCall);

	//@cmember 	Set the restart information for the oldest xaction
	VOID  	_ComputeNextRecord(ULONG *pulGenNum,ULONG *pulOffset);

	//
	//  Computed constants;
	//
	//@cmember 	Offset where first record page starts.
	ULONG   	_ulFirstRecordPage;

	//@cmember 	Number of record pages in the log.
	ULONG   	_ulPageCount;

	//
	//  Current storage State
	//		   	
	//@cmember 	Position where previous write occurred.
	ULONG   	_ulPreviousOffset;

	//@cmember 	There are two free areas; one in front of the buffer for log
	// 			records and the other behind it.
	BOOL 	_fFreeWrapped;

	//@cmember 	Size of the largest record in the log.
	ULONG   	_ulAvailableSpace;

	//@cmember 	Signals that records were not written between checkpoints.
	BOOL 	_fNoRecordWritten;

	//@cmember 	The restart area needed.
	RESTARTLOG 	_rsl;

	//
	//  Current Page State
	//
	//@cmember 	Offset of first byte of the current     page in log storage.
	ULONG   	_ulCurrentPageOffset;

	//@cmember 	Offset in current page for next record. Relative to the start
	//  		of the data area in the page.
	ULONG   	_ulCurrentRecOffset;

	//@cmember 	Space available in the current page.
	ULONG   	_ulCurrentPageSpace;

	//
	//  Forward Range State
	//
	//@cmember 	Offset of first byte of forward range in log storage.
	ULONG   	_ulForwardOffset;

	//@cmember 	Number of pages after current page to end of storage.
	ULONG   	_ulForwardPageCount;

	//
	//  Backward Range State
	//
	//@cmember 	Number of pages before first page of trailing edge.
	ULONG   	_ulBackwardPageCount;
	
	//
	//  State to support log full.
	//
	//@cmember 	Allowance for the fact that records may cause wastage up to
	//  		sizeof(LOGRECHEADER) on a page
	ULONG   	_ulRecOverflow;

	//@cmember 	Set to true when the log storage cannot
	// 			accomodate any more update records. Reset when the checkpoint after this
	// 			condition happens.
	BOOL 	_fLogFull;

	//@cmember 	State to remember last oldest dirty lrp passed in.
 	ULONG   	_ulLastOldestGenNum;

	//@cmember 	State to remember last oldest dirty lrp passed in.
	ULONG   	_ulLastOldestOffset;

	CLogMgr		*m_pCLogMgr;

};

#endif   //  __LOGSTATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logmgr_h.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1992-1992
//
// File:        pch.cxx
//
// Contents:    Precompiled Header source file
//
// History:     12-Jan-93       vincentf            created
//
//---------------------------------------------------------------------------

#include "dtcmem.h"

#define USE_NEW_LARGE_INTEGERS
#define RECOMAPI
USHORT const usMAJORVERSION = 1;
USHORT const usMINORVERSION = 1;

// Global [CRT] includes:
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Global includes...
#include <windows.h>

//#include "resource.h" // tracing
#include "msdtcmsg.h" // tracing
#include "utsem.h"
#include "uimsg.h"
#include "uisinf.h"

#include "ftdisk.h"
#include "logmgr.h"
#include "logstrm.h"
#include "logrec.h"
#include "_logmgr.h"
#include "xmgrdisk.h"
#include "layout.h"
#include "logstor.h"
#include "logstate.h"
extern "C"
{
#ifdef _X86_
    typedef ULONG (__cdecl FAR *FUNC32)(ULONG, UINT, UCHAR *, ULONG *);
#else
    typedef ULONG (__cdecl FAR *FUNC32)( UINT, UCHAR *, ULONG *);
#endif
    typedef ULONG (FAR *FUNC16)(ULONG, UINT, UCHAR *, ULONG *);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logrec.h ===
#ifndef __LOGREC_H__
  #define __LOGREC_H__


#define DUMMYNDX 	1


//+---------------------------------------------------------------------------
//  Structure: LRP           (lrp)
//
//  The following type is used to identify a log record by a Log
//  Record Pointer.
//
//----------------------------------------------------------------------------

typedef ULARGE_INTEGER 	LRP;		// lrp

typedef ULARGE_INTEGER 	LSN;		// lsn

/*
 * @struct LOGREC|
 *      LogRec for ILogWrite::Append.  This interface 
 *      takes a pointer to a LogRec along with a count of how
 *      many other LogRec pointers to expect to describe pieces of the caller's buffer
 *      which are supposed to be copied in sequence to the log file.
 *
 *  hungarian lrec
 */

typedef struct _LOGREC		//lrec
{    
	CHAR	*pchBuffer; 	//@field pointer to the buffer
    ULONG  	ulByteLength; 	//@field the length
	USHORT  usUserType; 	//@field The client specified log record type
    USHORT  usSysRecType; 	//@field The log manager defined log record types
} LOGREC;


/*
 * @struct WRITELISTELEMENT |
 * 		Write Entry for RecOMLogWriteList.  The interface to these
 * 		routines takes a pointer to a Write Entry List Element.  These elements can
 * 		be chained together.  The caller is required to put a value of NULL in the
 * 		last element of the chain.
 *
 * hungarian wle
 */

typedef struct _WRITELISTELEMENT 	  		// wle
{    
    struct 	_WRITELISTELEMENT *pwleNext;	//@field The next pointer
    ULONG 	ulByteLength;                 	//@field The length
    CHAR 	ab[DUMMYNDX];                  	//@field Start of data
} WRITELISTELEMENT;

// Declaration for asynch completion callback

class CAsynchSupport
{
//@access Public Members
public:
	//@cmember 	Destructor
    virtual ~CAsynchSupport() { ; }

  	//@cmember 	This operation is called after an asynch write completes
    virtual VOID  AppendCallback(HRESULT hr, LRP lrpAppendLRP) = 0;

  	//@cmember 	This operation is called after a SetCheckpoint completes
    virtual VOID  ChkPtCallback(HRESULT hr, LRP lrpAppendLRP) = 0;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logstor.h ===
/* @doc
 *
 * @module LOGSTOR.H |
 * 		Class support for physical log access
 * 		Cbuffer and CLogStorage class definitions
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code 
 * @rev 1 | 03-Apr-95 | wilfr | seqno to gennum changes
 *
 */

#ifndef __LOGSTOR_H__
#define __LOGSTOR_H__

/*
 * @class CBuffer |
 *		The CBuffer class provides a buffer that can be copied to or from.  
 *      Buffers are put into a singly linked list 
 * 
 * hungarian cbuf
 */

class CBuffer           // cbuf
{
//@access Public Members 
public:
	//@cmember 	Constructor
	CBuffer();

	//@cmember 	Destuctor
    ~CBuffer();

	//@cmember 	Return the first logical page of a buffer                          
    RECORDPAGE*	GetFirstPage(IN BOOL fReadOnly,IN ULONG ulExpectedGeneration, IN OUT ULONG * pulGeneration, IN OUT ULONG * pulChecksum);

	//@cmember 	Validate and return the current page                          
    RECORDPAGE* GetPage( void );

	//@cmember 	Validate and return a page for read                        
    RECORDPAGE*	GetReadPage(IN ULONG ulGeneration,OUT ULONG *pulOffset);

	//@cmember 	Validate and release a page                          
    VOID  		FreePage(IN RECORDPAGE *prcpgPageAddr,IN BOOL fIsFull, IN ULONG ulGeneration);

	//@cmember 	Determine if a buffer is full                          
    BOOL        IsFull();

	//@cmember 	Initialize a page header                         
	VOID		InitBlockHeader(IN DSKMETAHDR *pdmh,IN ULONG sig, IN ULONG ulGeneration); 

	//@cmember 	Initialize a page header                         
	VOID		Init(IN ULONG ulOffset,IN ULONG ulLength,IN ULONG ulPageSize,IN BOOL fReadOnly,IN CHAR *pchBuffer,IN ULONG ulGeneration, IN  DWORD dwAllocation);

	//@cmember  Verify a page
	BOOL		VerifyPage(RECORDPAGE* prcpg);

    //  A couple of functions in the CLogStorage class are friends of this
    //  class since the log storage class manages a FIFO queue of buffers.
    friend class CLogStorage;
	friend class CReadMap;

//@access Private Members
private:

    //@cmember 	Initialize a buffer 
	VOID _Init();
    //
    //  Initialized parameters.
    //
	//@cmember  Starting log storage offset of the buffer. Must be on a page boundary
    ULONG	_ulOffset;           
                                 
	//@cmember  The size of the buffer.                         
	ULONG   _ulSize;             

	//@cmember  The size of pages in this buffer.                        
    ULONG   _ulPageSize;         

	//@cmember The memory allocation size used
	DWORD	_dwAllocation;
	
	//@cmember 	The view start address.
    CHAR    *_pchBuffer;         

	//@cmember 	The address where the file mapping starts.
    CHAR    *_pchBufBegin;       

	//@cmember 	Offset in file of last byte in buffer.
    CHAR    *_pchBufEnd;         
		
	//@cmember 	The buffers are not to be initialized.
    BOOL _fReadOnly;         

	//@cmember 	Next buffer on queue to be flushed.  This value is manipulated by CLogStorage directly.           
    CBuffer *_pcbufNext;

    //
    //  Current state of the buffer.
    //
	//@cmember 	Current page pointer address.
    CHAR    *_pchPgPtr;   

	//@cmember 	TRUE => Buffer is full.
    BOOL _fFull;
     
	//@cmember 	TRUE => Buffer is being used.
    BOOL _fInUse;
     
	//@cmember 	Offset within the array of buffers.
    ULONG ulArrayOffset;
     
    
};



/*
 * @class CLogStorage | Provides a class that implements the physical log storage.
 * 
 * hungarian clgsto
 */

class CLogStorage           // clgsto
{
 friend class CILogCreateStorage;
 friend class CLogMgr;
 friend class CILogRead;
//@access Public Members
public:
	//@cmember 	Constructor
    CLogStorage(IN ULONG ulPageSize,IN ULONG ulInitSig,IN BOOL fFixedSize,IN ULONG ulLogBuffers );

	//@cmember 	Destructor
    ~CLogStorage();

	//@cmember 	Retrieve log manager restart information
    VOID 		GetRestart(IN OUT RESTARTLOG  *prsl,IN OUT STRMTBL *pstrmtbl);

	//@cmember 	Flush log manager restart information
    VOID  		ForceRestart(IN RESTARTLOG *prsl,IN STRMTBL *pstrmtbl);

	//@cmember 	Initializes or sets up the leading edge of the log storage
    VOID		SetLeadEdge(IN ULONG ulGenNum, IN ULONG ulOffset,IN ULONG ulLastPageOffset,IN ULONG ulLastRecOffset,IN ULONG ulLastPageSpace);

	//@cmember	Allocate a write buffer
    CBuffer*    GetWriteBuffer(IN ULONG ulOffset, IN ULONG ulLength);

	//@cmember	Verify a write buffer
    VOID        PutWriteBuffer(IN CBuffer *pcbufReturned);

	//@cmember 	Allocate a read buffer
    CBuffer*    GetReadBuffer(IN ULONG ulOffset, IN ULONG ulLength);

	//@cmember	Release a read buffer
    VOID        FreeReadBuffer(IN CBuffer *pcbufReturned);

	//@cmember	Set up queue for flush
    VOID        PrepareFlush();
	
	//@cmember	Flush the buffers in the ready queue
	ULONG       PerformFlush(BOOL fFlushCurrent);

	//@cmember	Return true if the flush queue is empty
	BOOL     IsEmptyFlushQ();

	//@cmember	Validate the last pages written
	BOOL     SetLastPage(IN ULONG ulGenNum,IN ULONG ulOffset,IN CBuffer *pcbufRead);

	//@cmember 	Copy the current buffer to the residual page
	VOID        CopyResidue();

	//@cmember 	Determine next offset where a record will go into the residual page
    VOID        NextResidueOffset(ULONG *pulNextOffset);

	//@cmember	The generation number of this file	   
	ULONG	   	_ulGeneration;	    
	   
	//@cmember 	The maximum number of allocated files
	ULONG 	   	_ulMaxFiles;        


//@access Private Members
private:
	//
    // Internal member functions.
	//
	//@cmember 	Initialize the log storage runtime attributes
    VOID 		_CommonInit(IN ULONG ulPageSize,IN BOOL fFixedSize);

	//@cmember 	Check the integrity of log manager restart information
    RESTARTPAGE* _VerifyRestart(IN CBuffer *pcbuf,OUT ULONG *pulGenNum,IN ULONG ulPageSize,OUT BOOL *pfIsChkSumBad,OUT ULONG *pulChecksum);

	//@cmember 	Append a buffer 
    VOID  		_AddToTail(IN CBuffer *pcbufNewTail);

	//@cmember	Map a buffer
    CBuffer* 	_MapBuffer(IN ULONG ulOffset,IN ULONG ulLength,IN BOOL fReadOnly);

	//@cmember 	Release a buffer
    VOID  		_UnmapBuffer(IN CBuffer *pcbuf, BOOL fFlush);

	//@cmember 	Initialize a partial page
	VOID  		_InitResidue(IN BOOL fIsSamePageSize);

	//@cmember 	Find out what size pages were used to init a log generation file
    ULONG  		_GetOldPageSize(OUT CBuffer **ppcbufRestart1,OUT CBuffer **ppcbufRestart2);

	//@cmember 	Determine if a log generation file has been moved
	ULONG 		_GrovelDisk(OUT CBuffer **ppcbufRestart1,OUT CBuffer **ppcbufRestart2);

	//@cmember 	Check to see if a log generation file is valid
	BOOL  	_IsVolumeDirty(IN ULONG ulOldPageSize,IN ULONG ulLastChkPtGenNum,IN ULONG ulLastChkPtOffset);

	//@cmember 	Create a string filename using a generation number
	VOID 		_TchFromGeneration(IN PTSTR ptstrFName,IN ULONG ulGeneration);

	//@cmember 	Format the pages for a new log generation file
	VOID 		_InitLogFilePages(IN ULONG ulNumPages,IN ULONG ulFileSize); 

	//@cmember 	Create a log generation file
	HRESULT 	_NewLogFile(IN LPTSTR ptstrFullFileSpec,IN ULONG	ulFileSize, BOOL fOverwrite, IN OUT ULONG *pulLogPages);

	//@cmember 	Open a log generation file
	HRESULT 	_OpenLogFile(IN LPTSTR ptstrFullFileSpec, IN OUT ULONG * pulLogPages);

	//@cmember 	Get the drive geometry for a device
	HRESULT 	_GetDriveGeometry( CHAR chDrive, LONG *pcbSector, LONG *pcbCylinder );

	//@cmember Look for logrecheader
	LOGRECHEADER * CLogStorage::_FindFirstLRH(RECORDPAGE *prcpDumpPage);

	//@cmember Look for logrecheader
	LOGRECHEADER * CLogStorage::_FindLastLRH(RECORDPAGE *prcpDumpPage,LOGRECHEADER *plrhCheckpoint);

	BOOL		_FindEOF( ULONG *pulLastGoodPage,ULONG *pulLastGenNum, LOGRECHEADER *plrhLast,LOGRECHEADER *plrhLastChkpt);

	BOOL		_FindRSL(RESTARTLOG* prsl,STRMTBL **ppStrmTbl,ULONG * pulCount);

	BOOL		_FillRSL(RESTARTLOG* prsl,STRMTBL **ppStrmTbl,LOGRECHEADER lrhLastChkpt);

	//
	// data members
	//
	//			Current sequence no and offset of the current buffer in log storage are meaningless.                           
                               
	//@cmember 	Current offset of the current buffer in log storage If the     
 	// 			value of pcbufCurrent is NULL this values
    ULONG 		_ulOffset;

	//@cmember 	Size of log storage.
    ULONG 		_ulSize;
	
	//@cmember  Total number of log pages
	ULONG		_ulLogPages;

	//@cmember 	Page size.
    ULONG 		_ulPageSize;
	//@cmember  Memory Allocation granularity
	DWORD		_dwOSAllocationSize;

 	//@cmember 	Sector size.
    LONG 		_lSectorSize;          

 	//@cmember 	Cylinder size.
    LONG 		_lCylinderSize;          

	//@cmember	The page signature for the log pages of an uninitialized storage.
    ULONG 		_ulInitSig;          
                               
	//@cmember	Head of buffer queue ready for flush.
    CBuffer 	*_pcbufReadyHead;  

	//@cmember 	Tail of buffer queue ready for flush.
	CBuffer 	*_pcbufReadyTail;   

	//@cmember 	Head of the queue of buffers to be flushed.
	CBuffer 	*_pcbufFlushQHead; 
     
	//@cmember 	Tail of the queue of buffers to be flushed.
	CBuffer 	*_pcbufFlushQTail; 
     
	//@cmember	Current buffer being filled up
	CBuffer 	*_pcbufCurrent;
        
	//@cmember 	TRUE => Use first restart page.
	BOOL 	_fFirstRestart;    
     
	//@cmember 	Offset of first page that can contain records.
	ULONG   	_ulFirstRecPg;     
     
	//@cmember 	TRUE => The log storage was just created.
	BOOL 	_fNewstorage;     
     		   
 	//@cmember	Set to TRUE when the size of the log storage is fixed.
	BOOL 	_fFixedSize;        
                               
	//@cmember 	True => uses the first residual page.
	BOOL 	_fFirstBuf;  

	//@cmember 	TRUE => The buffer came from the last page
    //      	written to the log storage and not a residual page.
    BOOL 	_fIsCurrentLast;    
                   
	//@cmember 	residue buffer being filled up.
	CBuffer 	*_pcbufFirst;       

	//@cmember 	residue buffer being filled up.
    CBuffer 	*_pcbufSecond;   

	//@cmember 	The next residue
    ULONG    	_ulNextResidue;

	//@cmember 	The handle for the log storage.
	HANDLE  	_hFile; 
				
	//@cmember 	The handle for the mapped section of the log storage.                
    HANDLE  	_hSection;         

	//@cmember 	The log file name
	CHAR 		_tchLogName[_MAX_PATH];

	CSemExclusive    m_cmxsBuffers;	//@cmember 	The write lock that must be held 
  	                                      //    to manipulate the CBuffer lists
    ULONG			m_cbBuffCount;  //@cmember  The current count of outstanding
	                                //          buffers
    ULONG			m_cbMaxBuffers;	//@cmember Max limit of outstanding buffers
    CBuffer * 		m_rgCBuffers;
	ULONG			m_ulListHead;
	ULONG			m_ulListEnd;
	BOOL			m_fListEmpty;

	//@cmember	Tracer
	IDtcTrace		*m_pIDtcTrace;
};



#endif	// _LOGSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\ofssem.h ===
#error ofssem.h is obsolete; use utsem.h instead
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\logstrm.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module LOGSTRM.H | Header for core class <c CLogStream>.<nl><nl>
// @rev 0 | 06/07/95 | rbarmes | Cloned: For logmgr.dll.
// -----------------------------------------------------------------------

// TODO: In the file comments, update the revisions.
// TODO: Search and replace "ILogStorage" with your first interface.

// TODO: Complete a class factory source/header for this core class.

#ifndef _LOGSTRM_H
#	define _LOGSTRM_H

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

#include "utAssert.h"						// Assert macros.
#include "utsem.h"							// Concurrency utilities.

// TODO: Replace the interface and interface implementation headers below with
//		 the corresponding headers for your first interface implementation.

// TODO: KEEP: For each additional interface implementation:
//       - Copy the first two includes below to the bottom of these includes.
//       - Update your copy with your headers and class names.
#include "ILGREAD.h"						// ILogRead.
#include "CILGREAD.h"						// CILogRead.
#include "ILGWRITE.h"						// ILogWrite.
#include "CILGWRIT.h"						// CILogWrite.
#include "ILGWRTA.h"						// ILogWrite.
#include "CILGWRTA.h"						// CILogWrite.

#include "xmgrdisk.h"
#include "logrec.h"
#include "layout.h"
#include "logstate.h"
// ===============================
// DEFINES:
// ===============================

#undef EXPORT								// Necessary for static member function.
#ifdef  WIN32
#	define EXPORT __declspec(dllexport)
#else
#	define EXPORT __export
#endif WIN32

//
//  Dummy index used to indicate variable length array.
//

//+---------------------------------------------------------------------------
//
//  Forward Class Declarations.
//
//------------------------------------------------------------------------------


class CLogRead; 

class CLogWrite;

class CLogWriteAsynch;

class CReadMap;

// ===============================
// CLASS: CLogStream
// ===============================

// TODO: In the class comments, update the threading, platforms, includes, and hungarian.
// TODO: In the class comments, update the description.
// TODO: In the class comments, update the usage.

// TODO: KEEP: For each additional interface implementation:
//       In the class comments, in Description, add a cross-reference
//       (eg: interface implementation "CILogStorage" has cross-reference "<c CILogStorage>").

// -----------------------------------------------------------------------
// @class CLogStream | Core class.<nl><nl>
// Threading: Thread-safe (see concurrency comments on individual methods).<nl>
// Platforms: Win.<nl>
// Includes : COMT_GU.H.<nl>
// Ref count: Per object.<nl>
// Hungarian: CLogStream.<nl><nl>
// Description:<nl>
//   Class factory of this core class is <c CFLogMgr>.<nl>
//   Interface implementations of this core class are:<nl>
//   <c CILogStorage>.<nl><nl>
// Usage:<nl>
//   This is just wiring.  Where's the beef?
// -----------------------------------------------------------------------
class CLogStream: public IUnknown				// @base public | IClassFactory.
{   
// TODO: KEEP: For each additional interface implementation:
//       - Copy the friend declaration below to the bottom of these friends.
//		 - Replace "CILogStorage" with the name of your interface implementation.
friend class CLogMgr;
friend class CILogStorage;
friend class CILogRead;
friend class CILogWrite;
friend class CILogRecordPointer;
friend class CILogInit;
friend class CILogWriteAsynch;

public:		// ------------------------------- @access Samsara (public):
	CLogStream  (CLogMgr* pCLogMgr, ULONG ulStreamID); // @cmember .
	CLogStream  (IUnknown* pIUOuter, CLogMgr* pCLogMgr, ULONG ulStreamID); // @cmember .
	~CLogStream (void); // @cmember .

public:		// ------------------------------- @access IUnknown (public):
	virtual STDMETHODIMP			QueryInterface (REFIID iid, LPVOID FAR* ppv); // @cmember .
	virtual STDMETHODIMP_(ULONG)	AddRef (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	Release (void); // @cmember .


protected:	// ------------------------------- @access Core methods (protected):
	virtual STDMETHODIMP_(ULONG)	ReadAddRef (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	WriteAddRef (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	ReadRelease (void); // @cmember .
	virtual STDMETHODIMP_(ULONG)	WriteRelease (void); // @cmember .

private:	// ------------------------------- @access Reference counting data (private):
	ULONG			m_ulcRef;				// @cmember Object reference count.
	CSemExclusive	m_semxRef;				// @cmember Exclusive semaphore for object reference count.
	ULONG			m_ulcReadRef;			// @cmember Reader reference count.
	ULONG			m_ulcWriteRef;			// @cmember Write reference count.

private:	// ------------------------------- @access Interface implementation members (private):

	// TODO: KEEP: For each additional interface implementation:
	//       - Copy the member declaration below to the bottom of these members.
	//		 - Replace "CILogStorage" with the name of your interface implementation.
	CILogRead		m_CILogRead;					// @cmember See also <c CILogRead>.
	CILogWrite		m_CILogWrite;					// @cmember See also <c CILogWrite>.
	CILogWriteAsynch m_CILogWriteAsynch;			// @cmember See also <c CILogWriteAsynch>.
	CLogMgr 		*m_pCLogMgr;						// @cmember parent CLogStorage
private:	// ------------------------------- @access Core data (private):

//@access Private Members
private:


	//
  	//  data members.
  	//
	ULONG			m_ulStreamID; 					// @cmember internal log stream id
	LPTSTR 			m_ptstrStreamName;				// @cmember Stream name if opened by name
 	CLSID* 			m_pclsClassID;					// @cmember ClassID if opened by Class ID
	CReadMap		m_crmReadMap;					// @cmember read map for reads
	LRP				m_lrpLastRead;					// @cmember Last read position
	LOGRECHEADER	m_lrhLastRecord;				// @cmember Last log record header
	ULONG			m_cbBuffers;					// @cmember The count of buffers needed for record
	LOGREC*			m_rglgrBuffers;					// @cmember Internal pointers to record fragments
	LRP				m_lrpLowWater;					// @cmember Low water mark for stream
	ULONG			m_ulSavedLeadOffset;
	ULONG			m_ulSavedLeadGenNum;
};

#endif _LOGSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\projdefs.h ===
//
// Standard Project Definitions
//

#ifndef __PROJDEFS_H__
#define __PROJDEFS_H__

typedef unsigned long  	ULONG;
typedef unsigned short 	USHORT;
typedef unsigned char  	UCHAR;
typedef unsigned int   	UINT;
typedef int   			INT;
typedef long  			LONG;
typedef short 			SHORT;

#ifndef FALSE
    typedef int	  	BOOL;
#   define  FALSE   0
#   define  TRUE    (!FALSE)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by W:\VIPER95\log\logmgr\src\logmgr.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\published\dload\inetsrvpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\strmtbl.h ===
/*
 * @doc
 *
 * @module STRMTBL.H | 
 *		Contains strmtbl data definition 
 *
 * @rev 0 | 25-Jun-95 | robertba | Created 
 *
 */

#ifndef __STRMTBL_H__
#define __STRMTBL_H__

// Forward Declaration
#include "logrec.h"

class CLogStream;

#define NUMCHKPTS 2  // hardcode number of remembered checkpoints for now

/*
 * @struct STRMTBL |
 * 		This is used to format the restart areas of the log storage
 *
 * hungarian strmtbl
 *
 */


typedef struct _STRMTBL
{
//@cmember The stream name		   LPOLESTR
 char      _szStream[16];
//@cmember  The # of the checkpoints remembered for this stream
 USHORT     _cbChkpoints;
//@cmember  The last checkpoint entry used - checkpoint LRPs are allocated at the 
//          end of this structure, starting with _lrpOldestCheckpoint
 USHORT		_cbNextChkpoint;
//@cmember  The stream 
 CLogStream * _pcLogStream;
//@cmember  The Checkpoints kept for this stream
 LRP		_lrpCheckpoints[NUMCHKPTS];
} STRMTBL;

#endif __STRMTBL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\xmgrdisk.h ===
/*
 * @doc
 *
 * @module XMGRDISK.H | 
 *		Contains Log storage Page Layout and structures stored inside log records
 *      Miscellaneous data structures used for recovery support.
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code
 * @rev 1 | 29-Mar-95 | wilfr | Removed transaction stuff
 * @rev 2 | 03-Apr-95 | wilfr | seqno to gennum changes
 *
 */

#ifndef __XMGRDISK_H__
#define __XMGRDISK_H__

//+----------------------------------------------------------------------------
//
//           Forward class declarations.
//
//-----------------------------------------------------------------------------

class CBuffer;                         // cbuf

//-----------------------------------------------------------------------------
//
//           Log storage Overall Structure
//
//-----------------------------------------------------------------------------
//
//
// @comm
//  	Each Log storage has two restart pages and two residue pages at its beginning.
//  	The rest of the log storage consists of record pages.  The residue pages
//  	are the location where the current record page is flushed to while it is not
//  	completely full.  Both these pages have a header.  The restart pages have a
//  	restart area that is defined in this file.
//		
//  	At the end of a checkpoint a restart page is written.  Restart pages are
//  	written alternately so that the log storage will always have a stable
//  	position from which to begin recovery.
//		
//  	Similarly, the incomplete current log record page is flushed to secondary
//  	storage alternately to one or the other residual page.  The purpose of
//  	flushing the incompletely filled page to a special place in the log is to
//  	avoid problems with accounting for the number of bytes necessary to undo all
//  	active transactions during system recovery or when the log is full.  A side
//  	effect of this strategy is that the log pages are packed with more records
//  	thus keeping the log storage smaller.
//		
//  	All log records stored in a log page MUST BE ALIGNED ON AN 8 BYTE BOUNDARY!
//  	To ensure this make sure that the size of all page headers, restart areas,
//  	and log record headers is divisible by 8.
//		
//  	Every page has a trailer that is 8 bytes long.  The Dword of these is used
//  	to store the sequence number associated with the page.  The first of these
//  	is unused and ensures that the total number of bytes that can be used to
//  	store data in a record page is divisible by 8.  This ensures that the
//  	number of pad bytes needed to ensure that a record's successor is aligned
//  	stays constant across page boundaries.
//		
//  	The purpose of storing the sequence number of a page both in its header and
//  	its trailer is to provide a check that a page was written out completely.
//  	If the values do not match it implies that the system failed while writing
//  	out the page.
//		
//  	Format initializes a log storage to contain 0xFF throughout.  Initialization
//  	changes the page headers to contain a four byte signature as defined below.
//		
//  	Signature strings for page headers.
//
//@todo Update the above to reflect current design

const ULONG SIGNATURELENGTH = 4;

#define SIG_RESTART_PAGE        0x52545352      // "RSTR"
#define SIG_RECORD_PAGE         0x44543252      // "RCRD"

//
//  There are two restart and two residue pages in the log storage.
//
const ULONG NUMRESTARTPAGES = 4;


#pragma pack(2)

/*
 * @struct RESTARTHEADER |
 * 		This is used to format the restart areas of the log storage
 *
 * hungarian rsh
 *
 */
typedef struct _RESTARTHEADER
{
	DSKMETAHDR 	dmh; 			//@field  <t DSKMETAHDR>
    ULONG 		SystemPageSize; //@field System page size.  Can only change
                               	// 		 if log storage is reformatted.
} RESTARTHEADER;





/*
 * @struct LOGPAGEHEADER |
 *		This structure is used to format the log record pages of the log storage
 *
 * hungarian lph
 *
 */
typedef struct _LOGPAGEHEADER   // lph
{
    DSKMETAHDR 	dmh;  			//@field <t DSKMETAHDR>
    ULONG 		ulOffset;       //@field Last starting offset used on page
    ULONG 		ulSpace;        //@field Amount of space left in page for user data.
    ULONG 		ulLastStart;    //@field offset into page of last log record
                               	//		 header. This value is relative to the
                               	// 		 first byte after this header.
} LOGPAGEHEADER;

#pragma pack()


/*
 * @struct 	RESTARTLOG |
 *		This is the structure that is used to drive recovery.  It
 *      represents the last stable state of the log storage.  This structure
 *      is written at the end of a log storage checkpoint after the log record
 *      pages have been flushed.
 *
 * hungarian rsl
 *
 */
typedef struct _RESTARTLOG    	//rsl
{
    ULONG 	ulLeadOffset;       //@field Offset of the last written log record
    ULONG 	ulLeadGenNum;       //@field Generation number of the last written log record
    ULONG 	ulTrailOffset;      //@field Offset of the earliest written log record of interest
    ULONG 	ulTrailGenNum;      //@field Generation number of the earliest written
                              	// 		 log record of interest
	ULONG	ulRecoveryOffset;	//@field Offset after recovery
	ULONG	ulRecoveryGenNum;	//@field Generation number after recovery
    ULONG 	ulDirtyOffset;      //@field Earliest dirty data offset of interest
    ULONG 	ulDirtyGenNum;      //@field Earliest dirty data sequence number of interest.
    ULONG 	ulLogSize;          //@field Current allocated log storage size.
    ULONG 	ulBeginChkptOffset; //@field Offset of the starting checkpoint record.
    ULONG 	ulBeginChkptGenNum; //@field Generation number of the starting checkpoint record.
    ULONG 	ulEndChkptOffset;   //@field Offset of the end checkpoint record.
    ULONG 	ulEndChkptGenNum;   //@field Generation number of the end checkpoint record.
    ULONG 	ulTotalSize;        //@field Number of log bytes available.
    ULONG 	ulPageSize;         //@field Page size of log when created.
    USHORT 	usMajorVersion;     //@field Major version Number of logmgr.
    USHORT 	usMinorVersion;     //@field Minor version number of logmgr.
 	USHORT	cbStrmTblEntries;   //@field Number of streams known.
	USHORT	cbStrmTblSize;		//@field Total size of the stream table
	UINT    uiTimerInterval;	//@field Pulse timer interval in ms
	UINT	uiFlushInterval;	//@field Flush timer interval in ms
	UINT	uiChkPtInterval;	//@field Checkpoint timer interval in ms
    BOOL    fIsCircular;      	//@field TRUE => The log is circular.
} RESTARTLOG;


/*
 * @struct RESTARTINFO |
 * 		This is the structure that contains information about log usage by the client.
 *
 * hungarian rsi
 *
 */


//+----------------------------------------------------------------------------
//  Constants for space left in pages.
//
//-----------------------------------------------------------------------------

const ULONG RECORDSPACE = PAGE_SIZE - sizeof(LOGPAGEHEADER);

const ULONG RESTARTSPACE = PAGE_SIZE - sizeof(RESTARTHEADER);

const ULONG RESTARTOPEN = PAGE_SIZE - sizeof(RESTARTHEADER)
                          - sizeof(RESTARTLOG);

const ULONG STRMTBLENTRIES = RESTARTOPEN / sizeof(STRMTBL);

const ULONG STRMTBLSIZE = STRMTBLENTRIES * sizeof(STRMTBL);

const ULONG RESTARTPAD = RESTARTOPEN - STRMTBLSIZE;

/*
 * @struct RECORDPAGE |
 * 		This is the structure for log record pages of the log storage.  A
 *    	couple of important things to note.  The log records in the
 *   	storage must start on a ulALIGN boundary.  If the header and trailer
 *    	of the record page are multiples of ulALIGN, then the alignment
 *    	padding to be added to a log record will remain constant even if
 *    	a log record goes across pages.  This ensures that the number
 *    	of available log bytes required always is an upper bound.
 *
 * hungarian rcpg
 *
 */

typedef struct _RECORDPAGE
{
    LOGPAGEHEADER	lph;    				//@field header for the page.
    CHAR  			achData[RECORDSPACE]; 	//@field Data area in the page.
} RECORDPAGE;


ULONG const ulALIGN = 8;  		// The alignment boundary for all log records.
ULONG const ulALIGNMASK = 7;  	// The mask used for alignmnent.



/*
 * @struct RESTARTPAGE |
 * 		This is the structure for restart pages of the log storage.
 *
 * hungarian rspg
 *
 */

typedef struct _RESTARTPAGE
{
    RESTARTHEADER lph;                 	//@field header for the page.
    RESTARTLOG    rsl;                  //@field Restart area.
    STRMTBL		  rgstrmtbl[STRMTBLENTRIES];              //@field First Stream Table entry.
    CHAR          achSpace[RESTARTPAD];//@field  Open area in the page.
} RESTARTPAGE;

typedef struct _USRCHKPTRECORD
{
  ULONG ulStrmID;
  LRP   lrpLastCheckpoint;
 }USRCHKPTRECORD;



#endif    __XMGRDISK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\published\query\idlmulti.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       idlmulti.h
//
//  Contents:   preprocessor trickery to make our .idl/.tdl files compile
//              with MIDL or APBU Mktyplib.
//
//  History:    27-May-94   DonCl     Created
//              20-Jul-94   ErikGav   Remove SDKTOOLS support
//
//----------------------------------------------------------------------------

#ifndef __IDLMULTI_H__
#define __IDLMULTI_H__


#ifndef __MKTYPLIB__

#define LOCAL_INTERFACE(guid)       \
[                                   \
    local,                          \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define REMOTED_INTERFACE(guid)     \
[                                   \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]



#else // __MKTYPLIB__

//#define cpp_quote(string)

//#define const

#define LOCAL_INTERFACE(guid)    \
[                           \
    uuid(guid),             \
    odl                     \
]

#define REMOTED_INTERFACE(guid)   \
[                           \
    uuid(guid),             \
    odl                     \
]

#endif  /// MKTYPLIB

#endif  // __IDLMULTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\tables.h ===
/*
 * @doc
 *
 * @module TABLES.H | Recovery Manager Tables
 *
 *
 * @rev 0 | 16-Jan-95 | robertba | Created from Vincentf OFS code
 * @rev 1 | 29-Mar-95 | wilfr | Removed transaction stuff
 *
 */

#ifndef __TABLES_H__
#define __TABLES_H__

#include "dtcmem.h"

/*
 * @class CXact |
 *		Provides a class that implements transaction operations.
 *      The transaction class contains state about an active transaction.
 *      Specifically, it contains the log storage offset of the previous log
 *      record for the transaction and the offset of the next log record
 *      to be undone for the transaction (in case the transaction is
 *      getting aborted).  Most operations that change the transaction
 *      state use the information in the transaction instance and the
 *      contents of a log record header.
 *
 * hungarian cxa
 *
 */

#if 0   //##WGR (removing xaction stuff)
class CXact
{
//@access Public Members
public:
 /*
  *     @cmember
  *      Simply is passed the address of the transaction and returns it.
  *      This operation is invoked by CRestartTable::AllocateXact so
  *      that the fields of a transaction object are initialized.  This class
  *      does not have a destructor since the CRestartTable::FreeXact
  *      function servers that purpose.
  *
  */
 CXact();
 #ifndef _USE_DTC_MEMORY_MANAGER
 	VOID*    operator new(size_t size, CHAR *pch) { return (VOID *) pch; }
 #endif
 //@cmember     Callback indicating abort beginning
 BOOLEAN  BeginAbort(IN ULONG *pulSeqNo, IN ULONG *pulOffset,IN ULONG *pulEnd);
 //@cmember  If the transaction is in the rollback state and the first
 //                      offset equals the parameter, the client did not write a
 //                      CLR for the first log record (or even others).  So make the
 //                      state uninitialized and let the transaction be reclaimed.
 //
 VOID     EnsureAbortComplete(ULONG ulFirstOffset);
 //@cmember     Invoked when the recovery manager is reading records during the
 //  analyse phase of recovery
 VOID     AnalyseRecord(IN LOGRECHEADER *plrhHeader);
 //@cmember     Write log transaction information
 VOID     Write(IN LOGRECHEADER *plrhHeader, IN ULONG ulSeqNo);
 //@cmember Moves  the offset of the next record to be read to the previous
 //             record for this transaction.
 BOOLEAN  IsCLRWriteOk(IN LOGRECHEADER *plrhHeader,IN ULONG *pulSeqNo, IN ULONG *pulOffset);

    friend class CXactTable;
//@access Private Members
private:
//@cmember The current transaction state
 XST        _xsState;
//@cmember      Info about first log record.
 ULONG      _ulFirstSeqNo;
//@cmember      Info about first log record.
 ULONG      _ulFirstOffset;
//@cmember The last offset used
 ULONG      _ulPreviousOffset;
//@cmember A next undo offset of zero indicates that the transaction
//                 been completely undone and must be released after the write
 ULONG      _ulNextUndoOffset;
 //@cmember Log space necessary to roll back this transaction
 ULONG      _ulBytesNeeded;

};
#endif  ##WGR (removing xaction stuff)

/*
 *@class CRestartTable |
 *       Provides a buffer that holds the restart table.  A restart table
 *       contains entries of a fixed size.
 *
 * hungarian crst
 *
 */

class CRestartTable           // crst
{
//@access Public Members
public:
	//@cmember 	Constructor
  	CRestartTable(IN ULONG ulEntrySize,IN ULONG ulNumberOfEntries);

	//@cmember 	Default constructor
  	CRestartTable(IN CHAR *pchBuffer);

	//@cmember 	Destructor
 	~CRestartTable();

	//@cmember  Get the transaction from its offset.
 	CHAR*		Bind(IN ULONG ulOffset);

	//@cmember 	Get a transaction table entry.
 	CHAR*   	Allocate(IN OUT ULONG *pulOffset);

	//@cmember 	Allocates a table entry  with the specified offset
 	CHAR*   	AllocateAt(IN ULONG ulOffset);

	//@cmember 	Release reference to transaction record.
 	VOID    	Free(IN CHAR *pch);

	//@cmember  Returns the address and length of the table.
 	VOID    	GetTableBuffer(IN LOGREC *plgr);
 	
	//@cmember 	Delete the current table and create a new one
 	VOID    	SetTableBuffer(IN ULONG ulLength,IN LOGREC  *algr);

	//@cmember 	Returns TRUE if the offset is on the in use list
 	BOOLEAN 	IsAllocated(IN ULONG ulOffset);

	//@cmember 	Simply clears the table of all its entries.
 	VOID    	Empty();

	//@cmember 	Get the number of bytes that need to be reserved in the log
 	ULONG   	GetLogBytesNeeded(OUT ULONG *pulTabRecLen);
	//##WGR ULONG   GetLogBytesNeeded(IN BOOLEAN fIsNewXact, OUT ULONG *pulTabRecLen);

	//@cmember 	Recalculate the number of bytes needed in the log
 	VOID    	UpdateLogBytesNeeded(IN ULONG ulBytesNeeded,IN BOOLEAN fIncrement);

 	friend class CRestartIter;


//@access Private Members
private:
 	//
 	//  Initialized parameters.
 	//
	//@cmember 	Current size of the table.
 	ULONG 			_ulSize;

	//@cmember 	EntrySize without the header.
 	ULONG 			_ulEntrySize;

	//@cmember 	Initial number of entries in table.
 	ULONG 			_ulInitCount;

	//@cmember  Offset of first entry available to be reused.
 	ULONG 			_ulShortFree;

	//@cmember 	The restart table.
 	RESTARTTABLE	*_prtabTable;

	//
	// Private member functions
	//
	//@cmember 	Expand the restart table
 	VOID  		_Expand(IN ULONG ulEntryCount);

	//@cmember 	Find and relocate an entry in the table
 	VOID  		_FindAndMove(IN RESTARTENTRY *prsteTarget, IN BOOLEAN fFree);

	//@cmember  Allocate a restart table
 	VOID  		_AllocTable (IN ULONG ulEntrySize,IN ULONG ulNumberEntries);

	//@cmember 	Initialize the list of entries
 	VOID  		_ListInit();
};


//
//@class  CRestartIter | Provides a class that permits scans of restart table.
//
// hungarian crit

class CRestartIter           // crit
{
//@access Public Members
public:
 	//@cmember 	Constructor
  	CRestartIter(IN CRestartTable &crstTable);

 	//@cmember 	Destructor
 	~CRestartIter();

 	//@cmember 	Return the next entry from the table
 	CHAR*		Next();

//@access Private Members
private:
 	//
 	//  Initialized parameters.
 	//
	//@cmember 	Current offset into table.
 	ULONG 			_ulCurrent;

	//@cmember 	The restart table.
 	RESTARTTABLE 	*_prtabTable;
};


/*@class CXactTable | Provides a class that provides transaction table modifications.
 *
 * hungarian cxt
 */

#if 0   //##WGR (removing xaction stuff)
class CXactTable         // cxa
{
//@access Public Members
public:
//@cmember Constructor
  CXactTable(IN CRestartTable *pcrst);
//@cmember Destructor
  ~CXactTable();
//@cmember Marks all transactions as failed after the redo phase of recovery
  ULONG       MarkAsFailed();
//@cmember Returns seq no and offset of oldest xact.
  VOID        Oldestlrp(OUT ULONG *pulOldestSeqNo, OUT ULONG *pulOldestOffset);
//@cmember Bind to the CXactTable
  CXact*      BindXact(IN ULONG *pulOffset,IN BOOLEAN fAnalyse);
//@cmember Release a transaction
  BOOLEAN     ReleaseXact(IN CXact *pcxa,IN ULONG ulBytesNeeded,IN BOOLEAN fIncrement);

//@access Private Members
private:
//@cmember The restart table
  CRestartTable *_pcrst;

};
#endif  ##WGR (removing xaction stuff)

#endif  __TABLES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\tools\viper96\log\logmgr\inc\_logmgr.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module DTCLOG.H | Header for helper classes used in CM to LM glue code.<nl><nl>
// Description:<nl>
// Class definitions and inline functions for the Log Manager driver used with CM interface.<nl>
// @rev 0 | 03/23/95 | wilf | Initial Revision.
// -----------------------------------------------------------------------

#ifndef __LOGMGR_H_
#	define __LOGMGR_H_

//+---------------------------------------------------------------------------
//
//  Typedefs
//
//------------------------------------------------------------------------------
#if 0 //disabled
typedef ULONG NTSTATUS;

//
// The success status codes 0 - 63 are reserved for wait completion status.
//
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L)

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to the a service or function.
//
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//
// MessageId: STATUS_END_OF_FILE
//
// MessageText:
//
//  The end-of-file marker has been reached.  There is no valid data in the
//  file beyond this marker.
//
#define STATUS_END_OF_FILE               ((NTSTATUS)0xC0000011L)

//
// MessageId: STATUS_LOG_FILE_FULL
//
// MessageText:
//
//  Log file space is insufficient to support this operation
//
#define STATUS_LOG_FILE_FULL             ((NTSTATUS)0xC0000188L)

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt Disk}
//  The file system structure on the disk is corrupt and unusable.
//  Please run the Chkdsk utility on the volume %s.
//
#define STATUS_DISK_CORRUPT_ERROR        ((NTSTATUS)0xC0000032L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)

//
// MessageId: STATUS_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//
#define STATUS_UNRECOGNIZED_VOLUME       ((NTSTATUS)0xC000014FL)

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

const ULONG MAXULONG = 0xffffffff;

const UINT TIMERGRANULARITY = 100; //one hundred millisconds

#endif __LOGMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\published\dload\query.c ===
#include "inetsrvpch.h"
#pragma hdrstop

#include <unknwn.h>
#include <cmdtree.h>
#include <ntquery.h>

static
HRESULT
WINAPI
LoadIFilter(
    WCHAR const * pwcsPath,
    IUnknown *    pUnkOuter,
    void **       ppIUnk
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
LocateCatalogsW(
    WCHAR const * pwszScope,
    ULONG         iBmk,
    WCHAR *       pwszMachine,
    ULONG *       pccMachine,
    WCHAR *       pwszCat,
    ULONG *       pccCat
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CIState(
    WCHAR const * pwcsCat,
    WCHAR const * pwcsMachine,
    CI_STATE *    pCiState
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CITextToFullTreeEx(
    WCHAR const *     pwszRestriction,
    ULONG             ulDialect,
    WCHAR const *     pwszColumns,
    WCHAR const *     pwszSortColumns, // may be NULL
    WCHAR const *     pwszGroupings,   // may be NULL
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CIMakeICommand(
    ICommand **           ppCommand,
    ULONG                 cScope,
    DWORD const *         aDepths,
    WCHAR const * const * awcsScope,
    WCHAR const * const * awcsCatalogs,
    WCHAR const * const * awcsMachine
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(query)
{
    DLPENTRY(CIMakeICommand)
    DLPENTRY(CIState)
    DLPENTRY(CITextToFullTreeEx)
    DLPENTRY(LoadIFilter)
    DLPENTRY(LocateCatalogsW)
};

DEFINE_PROCNAME_MAP(query)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\ciares.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 2000.
//
// File:        CiaRes.h
//
// Contents:    Constants used in CiAdmin.rc
//
// History:     15-Jun-1998     KyleP   Added header
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//----------------------------------------------------------------------------

#if !defined( __CIARES_H__ )
#define __CIARES_H__

//
// Image strips
//

#define BMP_SMALL_ICONS         400
#define BMP_LARGE_ICONS         401
#define BMP_TOOLBAR_SMALL       402
#define ICON_ABOUT              403
#define BMP_SMALL_OPEN_FOLDER   404
#define BMP_LARGE_CLOSED_FOLDER 405
#define BMP_SMALL_CLOSED_FOLDER 406

//
// These are the virtual offsets into the image strip
//

#define ICON_FOLDER              0
#define ICON_VIRTUAL_FOLDER      1
#define ICON_CATALOG             2
#define ICON_PROPERTY            3
#define ICON_MODIFIED_PROPERTY   4
#define ICON_SHADOW_ALIAS_FOLDER 5
#define ICON_URL                 6
#define ICON_APP                 7

//
// Strings
//

#define MSG_REMOVE_SCOPE_TITLE          501
#define MSG_REMOVE_SCOPE                502
// Gap can be filled with new ids

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
#define MSG_SNAPIN_NAME_STRING_INDIRECT 504
#endif

#define MSG_DIRECTORY_TITLE             505
#define MSG_RESCAN_FULL_SCOPE           506
#define MSG_MERGE_CATALOG               507
#define MSG_NEW_CATALOG                 508
#define MSG_NEW_CATALOG_TITLE           509

#define MSG_CM_ADD_SCOPE                510
#define MSG_CM_ADD_SCOPE_HELP           511
#define MSG_CM_DEL_SCOPE                512
#define MSG_CM_DEL_SCOPE_HELP           513
#define MSG_CM_ADD_CATALOG              514
#define MSG_CM_ADD_CATALOG_HELP         515
#define MSG_CM_DEL_CATALOG              516
#define MSG_CM_DEL_CATALOG_HELP         517
#define MSG_CM_COMMIT_PROP              518
#define MSG_CM_COMMIT_PROP_HELP         519
#define MSG_CM_SCAN_FULL_SCOPE          520
#define MSG_CM_SCAN_FULL_SCOPE_HELP     521
#define MSG_CM_MERGE                    522
#define MSG_CM_MERGE_HELP               523
#define MSG_CM_START_CI                 524
#define MSG_CM_START_CI_HELP            525
#define MSG_CM_STOP_CI                  526
#define MSG_CM_STOP_CI_HELP             527
#define MSG_CM_INVALID_SCOPE            528
#define MSG_CM_UNEXPECTED_ERROR         529
#define MSG_CM_PAUSE_CI                 530
#define MSG_CM_PAUSE_CI_HELP            531
#define MSG_CM_EMPTY_CATALOG            532
#define MSG_CM_EMPTY_CATALOG_HELP       533
#define MSG_CM_SHUTDOWN_SERVICE         534
#define MSG_CM_SHUTDOWN_SERVICE_TITLE   535
#define MSG_CM_TUNE_PERFORMANCE         536
#define MSG_CM_TUNE_PERFORMANCE_HELP    537
#define MSG_CM_CANT_SHUTDOWN_SERVICE    538
#define MSG_CM_CANT_SAVE_SETTINGS       539

#define MSG_ERROR_TITLE                 540
#define MSG_GENERIC_ERROR               541
#define MSG_PENDING_PROP_CHANGE_TITLE   542
#define MSG_PENDING_PROP_CHANGE         543
#define MSG_YES                         544
#define MSG_NO                          545
#define MSG_INDEX_SERVER                546
#define MSG_LOCAL_MACHINE               547
#define MSG_CANT_DELETE_CATALOG         548
#define MSG_DELETE_CATALOG              549

#define MSG_NODE_DIRECTORIES            550
#define MSG_NODE_PROPERTIES             551
#define MSG_CM_PROPERTIES_REFRESH       552
#define MSG_CM_PROPERTIES_REFRESH_HELP  553
#define MSG_ENABLE_CI                   554
#define MSG_ENABLE_CI_TITLE             555
#define MSG_NODE_UNFILTERED             556

#define MSG_INDEX_SERVER_CMPMANAGE      557

#define MSG_STATE_SHADOW_MERGE          560
#define MSG_STATE_MASTER_MERGE          561
#define MSG_STATE_CONTENT_SCAN_REQUIRED 562
#define MSG_STATE_ANNEALING_MERGE       563
#define MSG_STATE_SCANNING              564
#define MSG_STATE_RECOVERING            565
#define MSG_STATE_HIGH_IO               566
#define MSG_STATE_LOW_MEMORY            567
#define MSG_STATE_MASTER_MERGE_PAUSED   568
#define MSG_STATE_READ_ONLY             569
#define MSG_STATE_BATTERY_POWER         570
#define MSG_STATE_USER_ACTIVE           571
#define MSG_STATE_STARTING              572
#define MSG_STATE_READING_USNS          573
#define MSG_STATE_STARTED               574
#define MSG_STATE_STOPPED               575

#define MSG_COL_CATNAME                 600
#define MSG_COL_DRIVE                   601
#define MSG_COL_SIZE                    602
#define MSG_COL_DOCTOTAL                603
#define MSG_COL_DOCFILTER               604
#define MSG_COL_WORDLISTS               605
#define MSG_COL_PERSINDEX               606
#define MSG_COL_STATUS                  607
#define MSG_COL_ROOT                    608
#define MSG_COL_ALIAS                   609
#define MSG_COL_EXCLUDE                 610
#define MSG_COL_PROPSET                 611
#define MSG_COL_PROPERTY                612
#define MSG_COL_DATATYPE                613
#define MSG_COL_DATASIZE                614
#define MSG_COL_FNAME                   615
#define MSG_COL_STORELEVEL              616

#define MSG_STORELEVEL_PRIMARY          625
#define MSG_STORELEVEL_SECONDARY        626

#define MSG_CANT_ADD_CATALOG            630
#define MSG_CANT_ADD_CATALOG_TITLE      631
#define MSG_DELETE_CATALOG_TITLE        632
#define MSG_ERROR_PROP_COMMIT           633

#define MSG_PRODUCT_DESCRIPTION         701
#define MSG_NONE_SELECTED               702
#define MSG_VENDOR_COPYRIGHT            703
#define MSG_VENDOR_NAME                 704
#define MSG_PROVIDER_NAME               705

#define MSG_COL_SECQDOCUMENTS           715
#define MSG_CATALOG_PARTIAL_DELETION    716
#define MSG_DELETE_CATALOG_ASK          717
#define MSG_INVALID_COMPUTER_NAME       718
#define MSG_EMPTY_CATALOG_TITLE         719
#define MSG_EMPTY_CATALOG_PROMPT        720
#define MSG_RESCAN_FULL_SCOPE_EXPLAIN   721
#define MSG_TYPE                        722
#define MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN 723
#define MSG_RESCAN_INCREMENTAL_SCOPE    724
#define MSG_CM_SCAN_INCREMENTAL_SCOPE   725
#define MSG_CM_SCAN_INCREMENTAL_SCOPE_HELP 726 

//
// Property sheets
//

#define IDP_CATALOG_PAGE1               100
#define IDP_CATALOG_PAGE1_TITLE         101
#define IDP_CATALOG_PAGE2               102
#define IDP_CATALOG_PAGE2_TITLE         103
#define IDP_CATALOG_PAGE3               104
#define IDP_CATALOG_PAGE3_TITLE         105

#define IDP_PROPERTY_PAGE1              106
#define IDP_PROPERTY_PAGE1_TITLE        107

#define IDP_IS_PAGE0                    108
#define IDP_IS_PAGE0_TITLE              109
#define IDP_IS_PAGE1                    110
#define IDP_IS_PAGE1_TITLE              111

//
// Dialog constants
//

#define IDD_ADD_SCOPE                   301
#define IDD_BROWSEDIRECTORY             302
#define IDD_ADD_CATALOG                 303
#define IDD_USAGE_ON_SERVER             304
#define IDD_USAGE_ON_WORKSTATION        305
#define IDD_ADVANCED_INFO               306

#define IDDI_PATH                        1000
#define IDDI_BROWSE                      1001
#define IDDI_ALIAS                       1002
#define IDDI_USER_NAME                   1003
#define IDDI_PASSWORD                    1004
#define IDDI_SELECT_PATH                 1008
#define IDDI_SELECT_ALIAS                1009
#define IDDI_SELECT_USER_NAME            1010
#define IDDI_SELECT_PASSWORD             1011
#define IDDI_INCLUDE                     1012
#define IDDI_EXCLUDE                     1013
#define IDDI_CATNAME                     1014
#define IDDI_SIZE                        1015
#define IDDI_PROPSET                     1016
#define IDDI_PROPERTY                    1017
#define IDDI_CACHED                      1018
#define IDDI_DATATYPE                    1019
#define IDDI_VIRTUAL_SERVER              1020
#define IDDI_NNTP_SERVER                 1021
#define IDDI_FILTER_UNKNOWN              1022
#define IDDI_CHARACTERIZATION            1023
#define IDDI_CHARACTERIZATION_SIZE       1024
#define IDDI_SPIN_CHARACTERIZATION       1025
#define IDDI_COMPNAME                    1026
#define IDDI_LOCAL_COMPUTER              1027
#define IDDI_REMOTE_COMPUTER             1028
#define IDDI_SPIN_CACHEDSIZE             1029
#define IDDI_STORAGELEVEL                1030
#define IDDI_CACHEDSIZE                  1031
#define IDDI_DIRPATH                     1032
#define IDDI_CATPATH                     1033
#define IDDI_VSERVER_STATIC              1034
#define IDDI_NNTP_STATIC                 1035
#define IDDI_AUTO_ALIAS                  1036
#define IDDI_PROPCACHE_SIZE              1037
#define IDDI_DEDICATED                   1038
#define IDDI_USEDOFTEN                   1039
#define IDDI_USEDOCCASIONALLY            1040
#define IDDI_NEVERUSED                   1041
#define IDDI_ADVANCED                    1042
#define IDDI_SLIDER_MEMORY               1043
#define IDDI_SLIDER_CPU                  1044
#define IDDI_SLIDER_INDEXING             1045
#define IDDI_SLIDER_QUERYING             1046
#define IDDI_CUSTOMIZE                   1047
#define IDDI_INHERIT1                    1048
#define IDDI_INHERIT2                    1049
#define IDDI_ACCOUNT_INFORMATION         1050
#define IDDI_INCLUSION                   1051
#define IDDI_SELECT_PATH2                1052
#define IDDI_SELECT_PROPCACHE_SIZE       1053
#define IDDI_SELECT_SIZE                 1054
#define IDDI_SELECT_CATNAME              1055
#define IDDI_SELECT_CATPATH              1056
#define IDDI_SELECT_PROPSET              1057
#define IDDI_SELECT_PROPERTY             1058
#define IDDI_SELECT_DATATYPE             1059
#define IDDI_SELECT_CACHEDSIZE           1060
#define IDDI_SELECT_STORAGELEVEL         1061
#define IDDI_GROUP_INHERIT               1062
#define IDDI_CHARSIZE_STATIC             1063
#define IDDI_SELECT_INDEXING             1064
#define IDDI_SELECT_QUERYING             1065
#define IDDI_LAZY                        1066
#define IDDI_INSTANT                     1067
#define IDDI_LOWLOAD                     1068
#define IDDI_HIGHLOAD                    1069
#define IDDI_CATNAME2                    1070
#define IDDI_SELECT_CATNAME2             1071


#define IDDI_STATIC2                     50000
#define IDDI_STATIC                      -1

#endif // __CIARES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\cmddlg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       CmdDlg.cxx
//
//  Contents:   Dialogs for all context menu commands
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <CIARes.h>
#include <CmdDlg.hxx>
#include <Catalog.hxx>
#include <cierror.h>
#include <catadmin.hxx>
#include <shlobj.h>

extern "C"
{
    #include <lmcons.h>
}

//
// Local prototypes
//

BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText );

BOOL BrowseForDirectory( HWND hwndParent,
                         LPCTSTR pszInitialDir,
                         LPTSTR pszBuf,
                         int cchBuf,
                         LPCTSTR pszDialogTitle,
                         BOOL bRemoveTrailingBackslash );

void SetSliderPositions(HWND hwndDlg, WORD wIndexingPos, WORD wQueryingPos);

INT_PTR APIENTRY AddScopeDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "AddScopeDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK, BST_CHECKED, 0 );

        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );

        ciaDebugOut(( DEB_TRACE, "AddScope (WM_INITDIALOG) - 0x%x\n", lParam ));
        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {

        case IDDI_USER_NAME:
        case IDDI_PASSWORD:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcTemp;

                //
                // Only user name needs to be filled. Password can be empty.
                //

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcTemp ) )
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcTemp.Count() > 0 );
            }

            break;
        }

        case IDDI_DIRPATH:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) &&
                     xawcPath.Count() >= 2 &&
                     xawcPath[0] == L'\\' && xawcPath[1] == L'\\' )
                {
                    WCHAR * pwcsSlash = wcschr( xawcPath.GetPointer() + 2, L'\\' );

                    // Assuming the machinename portion can be no longer than MAX_PATH

                    if ( 0 != pwcsSlash && *(pwcsSlash+1) != L'\0' &&
                         (pwcsSlash - xawcPath.GetPointer() - 2) <= MAX_PATH )
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_USER_NAME, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_PASSWORD, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        // username/pwd are not essential!
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                    }
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), TRUE );
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcPath.Count() > 0 );
                }
            }
            fRet = TRUE;
            break;
        }

        case IDDI_INCLUDE:
        case IDDI_EXCLUDE:
        {
            EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
            break;
        }

        case IDDI_BROWSE:
        {
            // Disable the button so users can't launch multiple dialogs simultaneously
            EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_DIRPATH ), awc );
                    }

                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcPath;
            XArray<WCHAR> xawcAlias;
            XArray<WCHAR> xawcLogon;
            XArray<WCHAR> xawcPassword;

            //
            // Consider adding code to validate path. Warn user if path is invalid.
            // We don't really want to do this as it's a common admin scenario to
            // add paths that don't exist.
            //

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
            {
                //
                // Local or remote?
                //

                if ( IsWindowEnabled( GetDlgItem( hwndDlg, IDDI_ALIAS ) ) )
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_ALIAS, xawcAlias );
                }
                else
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcLogon );
                    GetDlgItemXArrayText( hwndDlg, IDDI_PASSWORD, xawcPassword );
                }

                BOOL fInclude = ( BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDDI_INCLUDE ) );
                Win4Assert( fInclude == ( BST_UNCHECKED == IsDlgButtonChecked( hwndDlg, IDDI_EXCLUDE ) ));

                CCatalog * pCat= (CCatalog *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                SCODE sc = pCat->AddScope(  xawcPath.GetPointer(),
                                            xawcAlias.GetPointer(),
                                            !fInclude,
                                            xawcLogon.GetPointer(),
                                            xawcPassword.GetPointer() ? xawcPassword.GetPointer() : L"" );

                if ( SUCCEEDED(sc) )
                    EndDialog( hwndDlg, TRUE );
                else
                {
                    WCHAR * pBuf = 0;

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    ULONG cchAvailMessage = 1024;

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 )
                        )
                    {
                        MessageBox(hwndDlg, STRINGRESOURCE( srCMUnexpectedError ),
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox(hwndDlg, pBuf,
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);

                        LocalFree( pBuf );
                    }
                }
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_ITRACE, "AddScope (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

// Modify the directory settings

INT_PTR APIENTRY ModifyScopeDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "ModifyScopeDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:
    {
        CScope *pScope = (CScope *)lParam;

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK, BST_CHECKED, 0 );

        SendDlgItemMessage( hwndDlg, IDDI_INCLUDE, BM_SETCHECK,
                            pScope->IsIncluded() ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage( hwndDlg, IDDI_EXCLUDE, BM_SETCHECK,
                            pScope->IsIncluded() ? BST_UNCHECKED : BST_CHECKED, 0);
        SetDlgItemText( hwndDlg, IDDI_DIRPATH, pScope->GetPath() );

        if (0 != pScope->GetAlias())
            SetDlgItemText( hwndDlg, IDDI_ALIAS, pScope->GetAlias() );

        WCHAR szBuffer[UNLEN + 1];

        Win4Assert(UNLEN >= PWLEN);

        szBuffer[0] = 0;
        pScope->GetUsername(szBuffer);
        SetDlgItemText( hwndDlg, IDDI_USER_NAME, szBuffer );
        szBuffer[0] = 0;
        pScope->GetPassword(szBuffer);
        SetDlgItemText( hwndDlg, IDDI_PASSWORD, szBuffer );

        ciaDebugOut(( DEB_ITRACE, "ModifyScope (WM_INITDIALOG) - 0x%x\n", lParam ));

        fRet = TRUE;
        break;
    }

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {

        case IDDI_USER_NAME:
        case IDDI_PASSWORD:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcTemp;

                //
                // Only user name needs to be filled. Password can be empty.
                //

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcTemp ) )
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcTemp.Count() > 0 );
            }

            break;
        }

        // make sure to enable OK button on modify when this is touched
        // irrespective of the change.
        case IDDI_ALIAS:
            if ( EN_CHANGE == HIWORD(wParam) )
                EnableWindow( GetDlgItem(hwndDlg, IDOK), TRUE );
            break;

        case IDDI_DIRPATH:
        {
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) &&
                     xawcPath.Count() >= 2 &&
                     xawcPath[0] == L'\\' && xawcPath[1] == L'\\' )
                {
                    WCHAR * pwcsSlash = wcschr( xawcPath.GetPointer() + 2, L'\\' );

                    // Assuming the machinename portion can be no longer than MAX_PATH

                    if ( 0 != pwcsSlash && *(pwcsSlash+1) != L'\0' &&
                         (pwcsSlash - xawcPath.GetPointer() - 2) <= MAX_PATH )
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_USER_NAME, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), TRUE );
                        SetDlgItemText( hwndDlg, IDDI_PASSWORD, L"" );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        // username/pwd are not essential!
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                    }
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_USER_NAME ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_PASSWORD ), FALSE );
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_ALIAS), TRUE );
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), xawcPath.Count() > 0 );
                }
            }
            fRet = TRUE;
            break;
        }

        case IDDI_INCLUDE:
        case IDDI_EXCLUDE:
        {
            EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
            break;
        }

        case IDDI_BROWSE:
        {
            // Disable the button so users can't launch multiple dialogs simultaneously
            EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_DIRPATH ), awc );
                    }

                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcPath;
            XArray<WCHAR> xawcAlias;
            XArray<WCHAR> xawcLogon;
            XArray<WCHAR> xawcPassword;

            //
            // Consider adding code to validate path. Warn user if path is invalid.
            // We don't really want to do this as it's a common admin scenario to
            // add paths that don't exist.
            //

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_DIRPATH, xawcPath ) )
            {
                //
                // Local or remote?
                //

                if ( IsWindowEnabled( GetDlgItem( hwndDlg, IDDI_ALIAS ) ) )
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_ALIAS, xawcAlias );
                }
                else
                {
                    GetDlgItemXArrayText( hwndDlg, IDDI_USER_NAME, xawcLogon );
                    GetDlgItemXArrayText( hwndDlg, IDDI_PASSWORD, xawcPassword );
                }

                BOOL fInclude = ( BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDDI_INCLUDE ) );
                Win4Assert( fInclude == ( BST_UNCHECKED == IsDlgButtonChecked( hwndDlg, IDDI_EXCLUDE ) ));

                CScope * pScope= (CScope *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                SCODE sc = pScope->GetCatalog().ModifyScope(  *pScope,
                                                              xawcPath.GetPointer(),
                                                              xawcAlias.GetPointer(),
                                                              !fInclude,
                                                              xawcLogon.GetPointer(),
                                                              xawcPassword.GetPointer() ? xawcPassword.GetPointer() : L"" );

                if ( SUCCEEDED(sc) )
                    EndDialog( hwndDlg, TRUE );
                else
                {
                    WCHAR * pBuf = 0;

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    ULONG cchAvailMessage = 1024;

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         0,
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 )
                        )
                    {
                        MessageBox(hwndDlg, STRINGRESOURCE( srCMUnexpectedError ),
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox(hwndDlg, pBuf,
                                   STRINGRESOURCE( srCMInvalidScope ), MB_ICONHAND);

                        LocalFree( pBuf );
                    }
                }
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_ITRACE, "ModifyScope (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

INT_PTR APIENTRY WksTunePerfDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
   BOOL fRet = FALSE;
   static DWORD dwUsage, dwIndexPos, dwQueryPos;

   switch (message)
   {
      case WM_HELP:
      {
          HELPINFO *phi = (HELPINFO *) lParam;

          ciaDebugOut(( DEB_ITRACE, "WksTunePerfDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                        phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                        phi->iCtrlId, phi->dwContextId ));

          if ( HELPINFO_WINDOW == phi->iContextType )
          {
              switch ( phi->iCtrlId )
              {
                  case IDDI_STATIC:
                      break;

                  default :
                      DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                      break;
              }
          }
          break;
      }


      case WM_CONTEXTMENU:
      {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
      }

      case WM_INITDIALOG:
      {
         ciaDebugOut(( DEB_ITRACE, "WksTunePerfDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

         SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

         // Initialize the dialog.
         CCatalogs *pCats = (CCatalogs *)lParam;
         pCats->GetSavedServiceUsage(dwUsage, dwIndexPos, dwQueryPos);

         switch (dwUsage)
         {
            case wUsedOften:
               SendDlgItemMessage( hwndDlg, IDDI_USEDOFTEN, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
               break;

            case wUsedOccasionally:
               SendDlgItemMessage( hwndDlg, IDDI_USEDOCCASIONALLY, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings(wLowPos, wLowPos);
               break;

            case wNeverUsed:
               SendDlgItemMessage( hwndDlg, IDDI_NEVERUSED, BM_SETCHECK, BST_CHECKED, 0 );
               break;

            case wCustom:
               SendDlgItemMessage( hwndDlg, IDDI_CUSTOMIZE, BM_SETCHECK, BST_CHECKED, 0 );
               pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
               break;

            case wDedicatedServer:
            default:
               Win4Assert(!"How did we get here?");
               break;
         }

         EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), dwUsage == wCustom);

         fRet = TRUE;
      }
      break;


   case WM_COMMAND:
   {
       CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);

       switch ( LOWORD( wParam ) )
       {
          case IDDI_USEDOFTEN:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                 dwUsage = wUsedOften;
             }
             break;

          case IDDI_USEDOCCASIONALLY:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                 dwUsage = wUsedOccasionally;
             }
             break;

          case IDDI_NEVERUSED:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                 dwUsage = wNeverUsed;
             }
             break;

          case IDDI_CUSTOMIZE:
             if (BN_CLICKED == HIWORD(wParam))
             {
                 EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), TRUE);
                 dwUsage = wCustom;
                 pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
             }
             break;

          case IDDI_ADVANCED:
          {
             pCats->SetServiceUsage(dwUsage);
             DialogBoxParam( ghInstance,                         // Application instance
                             MAKEINTRESOURCE( IDD_ADVANCED_INFO ), // Dialog box
                             hwndDlg,                      // main frame window
                             AdvPerfTuneDlg,                      // Dialog box function
                             (LPARAM)pCats );   // User parameter
             break;
          }

          case IDOK:
          {
              fRet = TRUE;

              if (wNeverUsed == dwUsage)
              {
                 int iResult;

                 iResult = MessageBox( GetFocus(), STRINGRESOURCE( srCMShutdownService ),
                                  STRINGRESOURCE( srCMShutdownServiceTitle ),
                                  MB_YESNO | /* MB_HELP | */
                                  MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                  switch ( iResult )
                  {
                  case IDYES:
                  {
                      SCODE sc = pCats->DisableService();
                      if (FAILED(sc))
                      {
                          MessageBox( GetFocus(), STRINGRESOURCE( srCMCantShutdownService ),
                                      STRINGRESOURCE( srCMShutdownServiceTitle ),
                                      MB_OK | /* MB_HELP | */
                                      MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );
                      }
                      // Fall through and close the dialog.
                  }
                  case IDNO:
                  default:
                      // Do nothing. Just close the dialog

                      EndDialog( hwndDlg, TRUE );
                      break;
                 }
                 break;
              }

              SCODE sc = pCats->TuneServicePerformance();

              if (FAILED(sc))
              {
                 // Inform user that performance tuning didn't go through.
                 // The only reason this happens is if the registry params couldn't be set, which
                 // should be a rare occurrence.
                 MessageBox( GetFocus(), STRINGRESOURCE( srCMCantSaveSettings ),
                             STRINGRESOURCE( srCMTunePerformance ),
                             MB_OK | /* MB_HELP | */
                             MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                 // About the only reason I can think of that could cause registry
                 // save to fail is if the registry was messed up. In that case, does it
                 // matter if we only saved part of what we wanted to save? Or should we be
                 // careful enough to remember the old settings and restore the registry to
                 // previous state in case we get here?
                 // No real reason to roll back.  There is no actually data loss or confusion.
              }

              if ( wNeverUsed != dwUsage )
              {
                  pCats->EnableService();
              }

              // The Advanced dialog takes care of setting custom settings
              // We don't want to set them here because dwIndexPos and dwQueryPos
              // have not been refreshed from registry since Adv dlg wrote them.

              if ( dwUsage != wCustom)
              {
                  sc = pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
              }

              // Not much to do if SaveServiceUsage fails. Just move on.

              EndDialog( hwndDlg, TRUE );
              break;
          }

          case IDCANCEL:
              ciaDebugOut(( DEB_TRACE, "WksTunePerfDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                            GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
              EndDialog( hwndDlg, FALSE );
       }
   }  // wm_command
   }  // message

   return fRet;
}


INT_PTR APIENTRY SrvTunePerfDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;
    static DWORD dwUsage, dwOldUsage, dwIndexPos, dwQueryPos;

    switch (message)
    {
       case WM_HELP:
       {
           HELPINFO *phi = (HELPINFO *) lParam;

           ciaDebugOut(( DEB_ITRACE, "SrvTunePerfDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                         phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                         phi->iCtrlId, phi->dwContextId ));

           if ( HELPINFO_WINDOW == phi->iContextType )
           {
               switch ( phi->iCtrlId )
               {
                   case IDDI_STATIC:
                       break;

                   default :
                       DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                       break;
               }

           }
           break;
       }

       case WM_CONTEXTMENU:
       {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
       }

       case WM_INITDIALOG:
       {
          ciaDebugOut(( DEB_ITRACE, "SrvTunePerfDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

          SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

          // Initialize the dialog.
          CCatalogs *pCats = (CCatalogs *)lParam;
          pCats->GetSavedServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
          dwOldUsage = dwUsage;
          switch (dwUsage)
          {
             case wDedicatedServer:
                SendDlgItemMessage( hwndDlg, IDDI_DEDICATED, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wHighPos, wHighPos);
                break;

             case wUsedOften:
                SendDlgItemMessage( hwndDlg, IDDI_USEDOFTEN, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                break;

             case wUsedOccasionally:
                SendDlgItemMessage( hwndDlg, IDDI_USEDOCCASIONALLY, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                break;

             case wCustom:
                SendDlgItemMessage( hwndDlg, IDDI_CUSTOMIZE, BM_SETCHECK, BST_CHECKED, 0 );
                pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
                break;

             case wNeverUsed:
                SendDlgItemMessage( hwndDlg, IDDI_NEVERUSED, BM_SETCHECK, BST_CHECKED, 0 );
                break;

             default:
                Win4Assert(!"How did we get here?");
                break;
          }

          EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), dwUsage == wCustom);

          fRet = TRUE;
       }
       break;


    case WM_COMMAND:
    {
        CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch ( LOWORD( wParam ) )
        {
           case IDDI_DEDICATED:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wHighPos, wHighPos);
                  dwUsage = wDedicatedServer;
              }
              break;

           case IDDI_USEDOFTEN:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wHighPos, wMidPos);
                  dwUsage = wUsedOften;
              }
              break;

           case IDDI_USEDOCCASIONALLY:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  pCats->SaveServicePerformanceSettings(wMidPos, wLowPos);
                  dwUsage = wUsedOccasionally;
              }
              break;

           case IDDI_NEVERUSED:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), FALSE);
                  dwUsage = wNeverUsed;
              }
              break;

           case IDDI_CUSTOMIZE:
              if (BN_CLICKED == HIWORD(wParam))
              {
                  EnableWindow(GetDlgItem(hwndDlg, IDDI_ADVANCED), TRUE);
                  pCats->SaveServicePerformanceSettings((WORD)dwIndexPos, (WORD)dwQueryPos);
                  dwUsage = wCustom;
              }
              break;

           case IDDI_ADVANCED:
           {
              pCats->SetServiceUsage(dwUsage);
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_ADVANCED_INFO ), // Dialog box
                              hwndDlg,                      // main frame window
                              AdvPerfTuneDlg,                      // Dialog box function
                              (LPARAM)pCats );   // User parameter
              break;
           }

           case IDOK:
           {
               fRet = TRUE;

               // only pop up the messagebox if old dwUsage != wNeverUsed
               if (wNeverUsed == dwUsage)
               {
                   if ( wNeverUsed != dwOldUsage )
                   {
                       
                       int iResult;

                       iResult = MessageBox( GetFocus(), STRINGRESOURCE( srCMShutdownService ),
                                             STRINGRESOURCE( srCMShutdownServiceTitle ),
                                             MB_YESNO | /* MB_HELP | */
                                             MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                       switch ( iResult )
                       {
                           case IDYES:
                           {
                               SCODE sc = pCats->DisableService();
                               if (FAILED(sc))
                               {
                                   MessageBox( GetFocus(), STRINGRESOURCE( srCMCantShutdownService ),
                                               STRINGRESOURCE( srCMShutdownServiceTitle ),
                                               MB_OK | /* MB_HELP | */
                                               MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );
                               }
                               else
                               {
                                   pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
                               }
                               // Fall through and close the dialog.
                           }
                           case IDNO:
                           default:
                           // Do nothing. Just close the dialog

                           EndDialog( hwndDlg, TRUE );
                           break;
                       }
                       break;
                   }
                   else
                   {
                       EndDialog( hwndDlg, FALSE );
                       break;
                   }
               }

               SCODE sc = pCats->TuneServicePerformance();

               if (FAILED(sc))
               {
                  // Inform user that performance tuning didn't go through.
                  // The only reason this happens is if the registry params couldn't be set, which
                  // should be a rare occurrence.
                  MessageBox( GetFocus(), STRINGRESOURCE( srCMCantSaveSettings ),
                              STRINGRESOURCE( srCMTunePerformance ),
                              MB_OK | /* MB_HELP | */
                              MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL );

                  // About the only reason I can think of that could cause registry
                  // save to fail is if the registry was messed up. In that case, does it
                  // matter if we only saved part of what we wanted to save? Or should we be
                  // careful enough to remember the old settings and restore the registry to
                  // previous state in case we get here?
                  // No real reason to roll back.  There is no actually data loss or confusion.
                  //
               }

               if ( wNeverUsed != dwUsage )
               {
                   pCats->EnableService();
               }

               // The Advanced dialog takes care of setting custom settings
               // We don't want to set them here because dwIndexPos and dwQueryPos
               // have not been refreshed from registry since Adv dlg wrote them.

               if ( dwUsage != wCustom)
               {
                   sc = pCats->SaveServiceUsage(dwUsage, dwIndexPos, dwQueryPos);
               }

               // Not much to do if SaveServiceUsage fails. Just move on.

               EndDialog( hwndDlg, TRUE );
               break;
           }

           case IDCANCEL:
               ciaDebugOut(( DEB_TRACE, "SrvTunePerfDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                             GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
               EndDialog( hwndDlg, FALSE );
        }
    } // wm_command
    } // message

    return fRet;
}

INT_PTR APIENTRY AdvPerfTuneDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
   BOOL fRet = FALSE;
   switch (message)
   {
       case WM_HELP:
       {
           HELPINFO *phi = (HELPINFO *) lParam;

           ciaDebugOut(( DEB_ITRACE, "AdvPerfTuneDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                         phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                         phi->iCtrlId, phi->dwContextId ));

           if ( HELPINFO_WINDOW == phi->iContextType )
           {
               switch ( phi->iCtrlId )
               {
                   case IDDI_STATIC:
                   case IDDI_LOWLOAD:
                   case IDDI_HIGHLOAD:
                   case IDDI_LAZY:
                   case IDDI_INSTANT:
                       break;

                   default :
                       DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                       break;
               }

           }
           break;
       }

      case WM_CONTEXTMENU:
      {
          DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
          break;
      }

      case WM_INITDIALOG:
      {
         // Prepare the controls
         SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_SETRANGE, TRUE, MAKELONG(wLowPos, wHighPos));
         SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_SETRANGE, TRUE, MAKELONG(wLowPos, wHighPos));

         // Set the dialog based on lParam
         DWORD dwUsage, dwIndexingPos, dwQueryingPos;
         CCatalogs *pCats = (CCatalogs *)lParam;
         pCats->GetSavedServiceUsage(dwUsage, dwIndexingPos, dwQueryingPos);
         SetSliderPositions(hwndDlg, (WORD)dwIndexingPos, (WORD)dwQueryingPos);
         SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)lParam );

         fRet = TRUE;
      }
      break;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {
            case IDOK:
            {
               fRet = TRUE;

               WORD wIdxPos = (WORD)SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_GETPOS, 0, 0);
               WORD wQryPos = (WORD)SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_GETPOS, 0, 0);

               CCatalogs *pCats = (CCatalogs *)GetWindowLongPtr(hwndDlg, DWLP_USER);
               pCats->SaveServicePerformanceSettings(wIdxPos, wQryPos);
               pCats->SaveServiceUsage(wCustom, wIdxPos, wQryPos);

               EndDialog( hwndDlg, TRUE );
               break;
            }

            case IDCANCEL:
               ciaDebugOut(( DEB_TRACE, "AdvPerfTuneDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                             GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
               EndDialog( hwndDlg, FALSE );
         }
   }

   return fRet;
}

void SetSliderPositions(HWND hwndDlg, WORD wIndexingPos, WORD wQueryingPos)
{
   SendDlgItemMessage(hwndDlg, IDDI_SLIDER_INDEXING, TBM_SETPOS, TRUE, (LONG)wIndexingPos);
   SendDlgItemMessage(hwndDlg, IDDI_SLIDER_QUERYING, TBM_SETPOS, TRUE, (LONG)wQueryingPos);
}

INT_PTR APIENTRY AddCatalogDlg( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    BOOL fRet = FALSE;

    switch ( message )
    {
    case WM_HELP:
    {
        HELPINFO *phi = (HELPINFO *) lParam;

        ciaDebugOut(( DEB_ITRACE, "AddCatalogDlg WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                      phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                      phi->iCtrlId, phi->dwContextId ));

        if ( HELPINFO_WINDOW == phi->iContextType )
        {
            switch ( phi->iCtrlId )
            {
                case IDDI_STATIC:
                    break;

                default :
                    DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                    break;
            }

        }
        break;
    }


    case WM_CONTEXTMENU:
    {
        DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
        break;
    }

    case WM_INITDIALOG:

        ciaDebugOut(( DEB_ITRACE, "AddCatalogDlg (WM_INITDIALOG) - 0x%x\n", lParam ));

        SetWindowLongPtr( hwndDlg, DWLP_USER, lParam );

        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDDI_CATNAME2:
        case IDDI_CATPATH:
            if ( EN_CHANGE == HIWORD(wParam) )
            {
                //
                // If both fields have data, then enable OK button.
                //

                WCHAR wcsTest[10];

                if ( 0 == GetDlgItemText( hwndDlg, IDDI_CATNAME2, wcsTest, sizeof(wcsTest) / sizeof(WCHAR) ) ||
                     0 == GetDlgItemText( hwndDlg, IDDI_CATPATH, wcsTest, sizeof(wcsTest) / sizeof(WCHAR) ) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );
                }
                else
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
                }
            }
            fRet = TRUE;
            break;

        case IDDI_BROWSE:
        {
            if ( BN_CLICKED == HIWORD( wParam ) )
            {
                // Disable the button so users can't launch multiple dialogs simultaneously
                EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), FALSE);

                XArray<WCHAR> xawcPath;

                if ( GetDlgItemXArrayText( hwndDlg, IDDI_CATPATH, xawcPath ) )
                {
                    if ( xawcPath.IsNull() )
                    {
                        xawcPath.Init( 2 );
                        xawcPath[0] = L'\\';
                        xawcPath[1] = 0;
                    }

                    WCHAR awc[MAX_PATH];

                    if ( BrowseForDirectory( GetParent(hwndDlg),      // Parent
                                             xawcPath.GetPointer(),   // Current path
                                             awc,                     // New path goes here...
                                             MAX_PATH,
                                             0,                       // Title
                                             TRUE ) )                 // Remove trailing slash
                    {
                        SetWindowText( GetDlgItem( hwndDlg, IDDI_CATPATH ), awc );
                    }

                    // Re-enable the button
                    EnableWindow(GetDlgItem( hwndDlg, IDDI_BROWSE ), TRUE);
                    // Set focus on dialog so user can continue working...
                    SetFocus(hwndDlg);
                }
            }

            fRet = TRUE;
            break;
        }

        case IDOK:
        {
            XArray<WCHAR> xawcCatName;
            XArray<WCHAR> xawcPath;

            if ( GetDlgItemXArrayText( hwndDlg, IDDI_CATNAME2, xawcCatName ) &&
                 GetDlgItemXArrayText( hwndDlg, IDDI_CATPATH, xawcPath ) )
            {
                CCatalogs * pCats= (CCatalogs *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                TRY
                {
                    SCODE sc = pCats->AddCatalog( xawcCatName.GetPointer(),
                                                  xawcPath.GetPointer() );

                    if (FAILED(sc))
                    {
                        MessageBox(hwndDlg,
                                   STRINGRESOURCE( srNCError ),
                                   STRINGRESOURCE( srNCErrorT ),
                                   MB_ICONHAND);
                    }
                    else
                    {
                        MessageBox( hwndDlg,
                                    STRINGRESOURCE( srNC ),
                                    STRINGRESOURCE( srNCT ),
                                    MB_OK | MB_ICONWARNING );

                        EndDialog( hwndDlg, TRUE );
                    }
                }
                CATCH( CException, e )
                {
                    WCHAR * pBuf = 0;

                    SCODE sc = GetOleError(e);

                    //
                    // Convert Win32 errors back from HRESULT
                    //

                    if ( (sc & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
                        sc &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

                    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"query.dll"),
                                         sc,
                                         GetSystemDefaultLCID(),
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) &&
                         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         GetModuleHandle(L"kernel32.dll"),
                                         sc,
                                         GetSystemDefaultLCID(),
                                         (WCHAR *)&pBuf,
                                         0,
                                         0 ) )
                    {
                        StringResource srGenericError = { MSG_GENERIC_ERROR };
                        srGenericError.Init( ghInstance );

                        unsigned cc = wcslen( STRINGRESOURCE(srGenericError) ) +
                                      11; // 0xnnnnnnnn + null

                        XArray<WCHAR> xawcText( cc );

                        wsprintf( xawcText.Get(),
                                  STRINGRESOURCE(srGenericError),
                                  GetOleError( e ) );

                        MessageBox( hwndDlg,
                                    xawcText.Get(),
                                    STRINGRESOURCE( srIndexServerCmpManage ),
                                    MB_OK | MB_ICONERROR );
                    }
                    else
                    {
                        MessageBox( hwndDlg,
                                    pBuf,
                                    STRINGRESOURCE( srIndexServerCmpManage ),
                                    MB_OK | MB_ICONERROR );

                        LocalFree( pBuf );
                    }

                }
                END_CATCH
            }

            fRet = TRUE;
            break;
        }

        case IDCANCEL:
            ciaDebugOut(( DEB_TRACE, "AddCatalogDlg (WM_COMMAND, IDCANCEL) - 0x%x\n",
                          GetWindowLongPtr( hwndDlg, DWLP_USER ) ));
            EndDialog( hwndDlg, FALSE );
        }
    }

    return fRet;
}

BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText )
{
    Win4Assert( 0 == xawcText.Count() );

    xawcText.Init( 5 );  // Start with some default size.

    while ( TRUE )
    {
        unsigned cc = GetDlgItemText( hwndDlg, idCtrl, xawcText.GetPointer(), xawcText.Count() );

        if ( 0 == cc )
        {
            xawcText.Free();
            break;
        }

        if ( cc != (xawcText.Count() - 1) )
            break;

        cc = xawcText.Count() * 2;

        xawcText.Free();
        xawcText.Init( cc );
    }

    if ( !xawcText.IsNull() && 0 == xawcText[0] )
        xawcText.Free();

    return TRUE;
}

// Used to initialize the browse directory dialog with the start root

int InitStartDir( HWND hwnd,
                  UINT uMsg,
                  LPARAM lParam,
                  LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}

//----------------------------------------------------------------------------
// Procedure    BrowseForDirectory
//
// Purpose      Displays a dialog that lets the user choose a directory
//              name, either local or UNC.
//
// Parameters   hwndParent              Parent window for the dialog
//              pszInitialDir           Directory to use as the default
//              pszBuf                  Where to store the answer
//              chBuf                   Number of characters in this buffer
//              szDialogTitle           Title for the dialog
//
// Returns      nonzero if successful, zero if not.  If successful, pszBuf
//              will be filled with the full pathname of the chosen directory.
//
// History              10/06/95        KenSh           Created
//                      10/09/95        KenSh           Use lCustData member instead of global
//                      10/28/98        KrishnaN        Using Shell's folder browser
//
//----------------------------------------------------------------------------

BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash )
{
    // Get the necessary interfaces at the beginning. If we fail, we can return
    // immediately.

    // Caller is responsible for cleaning up the pidl returned by the shell
    // NOTE: Docs don't explicitly mention if SHGetMalloc refcounts it. It is
    // COMmon sense that it does, and NT sources supports it. So Release it after use.
    XInterface<IMalloc> xMalloc;

    SCODE sc = SHGetMalloc(xMalloc.GetPPointer());
    if (FAILED(sc))
    {
        // We need to cleaup pidl, but can't get a ptr to the shell task
        // allocator. What else can we do besides displaying an error?

        MessageBox(hwndParent, STRINGRESOURCE( srCMUnexpectedError ),
                   STRINGRESOURCE( srIndexServerCmpManage ), MB_ICONHAND);

        return FALSE;
    }

    BROWSEINFO bi;

    RtlZeroMemory(&bi, sizeof BROWSEINFO);

    bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS;
    TCHAR szInitialDir[MAX_PATH];
    pszBuf[0] = L'\0';

    // Prepare the initial directory... add a backslash if it's
    // a 2-character path
    wcscpy( szInitialDir, pszInitialDir );
    if( !szInitialDir[2] )
    {
        szInitialDir[2] = L'\\';
        szInitialDir[3] = L'\0';
    }

    WCHAR awcTitle[200];
    if( pszDialogTitle )
        bi.lpszTitle = pszDialogTitle;
    else
    {
        LoadString( ghInstance,
                    MSG_DIRECTORY_TITLE,
                    awcTitle,
                    sizeof awcTitle / sizeof WCHAR );
        bi.lpszTitle = awcTitle;
    }

    bi.hwndOwner = hwndParent;
    Win4Assert(cchBuf >= MAX_PATH);
    bi.pszDisplayName = pszBuf;

    if (pszInitialDir)
    {
       // engage these params only if we have an initial directory
       bi.lpfn = InitStartDir;
       bi.lParam = (LPARAM)szInitialDir;
    }

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    BOOL fOk = (BOOL)(0 != pidl);

    fOk = fOk && SHGetPathFromIDList(pidl, pszBuf);

    xMalloc->Free((void *)pidl);

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\dataobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       DataObj.cxx
//
//  Contents:   Data object
//
//  History:    26-Nov-1996     KyleP    Created
//               7/1/98         mohamedn extend comp. mgmt
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <dataobj.hxx>

#include <catalog.hxx>
#include <prop.hxx>

//
// Global variables
//

extern long gulcInstances;

//
// Static member initialization
//

unsigned int CCIAdminDO::_cfNodeType =       RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CCIAdminDO::_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CCIAdminDO::_cfDisplayName =    RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CCIAdminDO::_cfClassId =        RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CCIAdminDO::_cfInternal =       RegisterClipboardFormat(L"IS_SNAPIN_INTERNAL");
unsigned int CCIAdminDO::_cfMachineName =    RegisterClipboardFormat(MMC_MACHINE_NAME_CF);

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IDataObject == riid )
        *ppvObject = (IUnknown *)(IDataObject *) this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminDO::AddRef()
{
    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::AddRef\n" ));

    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminDO::Release()
{
    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::Release\n" ));

    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::Create
//
//  Synopsis:   CDataObject creation
//
//  Arguments:  [pBuffer]   -- buffer
//              [len]       -- buffer length
//              [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{

    //ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::Create\n" ));

    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            // store in smart pointer to release when we're out of scope

            XInterface<IStream>  xStream(lpStream);

            // Write to the stream the number of bytes

            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateNodeTypeData
//
//  Synopsis:   NodeType creation
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateNodeTypeData\n" ));

    return Create(&guidCIRootNode, sizeof(GUID), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateNodeTypeStringData
//
//  Synopsis:   NodeType creation
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateNodeTypeStringData\n" ));

    return Create(wszCIRootNode, (wcslen(wszCIRootNode)+1) * sizeof (WCHAR) , lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateDisplayName
//
//  Synopsis:   CreateDisplayName
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    unsigned cc;
    XGrowable<WCHAR> xwcsTitle;

    if ( 0 == _pwcsMachine )
    {
        cc = wcslen( STRINGRESOURCE(srIndexServerCmpManage) ) + 1;
        xwcsTitle.SetSize(cc);
        wcscpy( xwcsTitle.Get(), STRINGRESOURCE(srIndexServerCmpManage) );
    }
    else
    {
        cc = wcslen( STRINGRESOURCE(srIndexServer) ) + 1;

        xwcsTitle.SetSize(cc);

        wcscpy( xwcsTitle.Get(), STRINGRESOURCE(srIndexServer) );

        if ( _pwcsMachine[0] == L'.' )
        {
            cc += wcslen( STRINGRESOURCE(srLM) );

            xwcsTitle.SetSize( cc );

            wcscat( xwcsTitle.Get(), STRINGRESOURCE(srLM) );
        }
        else
        {
            cc += wcslen( _pwcsMachine );
            cc += 2;  // the UNC slashes

            xwcsTitle.SetSize( cc );

            wcscat( xwcsTitle.Get(), L"\\\\" );
            wcscat( xwcsTitle.Get(), _pwcsMachine );
        }
    }

    return Create( xwcsTitle.Get(), cc * sizeof(WCHAR), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateCoClassID
//
//  Synopsis:   CreateCoClassID
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateCoClassID\n" ));

    const CLSID & clsid = guidCISnapin;

    return Create(&clsid, sizeof(CLSID), lpMedium);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CreateInternal
//
//  Synopsis:   CreateInternal
//
//  Arguments:  [lpMedium]  -- medium
//
//  Returns:    HRESULT upon success or failure.
//
//  History:    7/1/98  mohamedn    created
//
//--------------------------------------------------------------------------

HRESULT CCIAdminDO::CreateInternal(LPSTGMEDIUM lpMedium)
{

    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CreateInternal\n" ));

    void * pThis = this;

    return Create(&pThis, sizeof (DWORD), lpMedium );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::GetData
//
//  Synopsis:   Retrieves requested data type
//
//  Arguments:  [lpFormatetcIn] -- Requested data format
//              [lpMedium]      -- Describes storage format
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::GetData( FORMATETC * lpFormatetcIn,
                                             STGMEDIUM * lpMedium )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::GetData\n" ));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::GetDataHere
//
//  Synopsis:   Retrieves requested data type.  Caller allocated storage.
//
//  Arguments:  [lpFormatetcIn] -- Requested data format
//              [lpMedium]      -- Describes storage format
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCIAdminDO::GetDataHere( FORMATETC * lpFormatetc,
                                      STGMEDIUM * lpMedium )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::GetDataHere\n" ));

    //
    // Simple parameter checking.
    //

    if ( 0 == lpFormatetc || 0 == lpMedium )
        return E_POINTER;

    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == _cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == _cfClassId)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == _cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == _cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == _cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::EnumFormatEtc
//
//  Synopsis:   Enumerate available format types
//
//  Arguments:  [dwDirection]     -- Get vs. Set formats
//              [ppEnumFormatEtc] -- Format(s) returned here
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminDO::EnumFormatEtc( DWORD dwDirection,
                                                   IEnumFORMATETC ** ppEnumFormatEtc )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::EnumFormatEtc\n" ));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::CCIAdminDO
//
//  Synopsis:   Constructor
//
//  Arguments:  [cookie]      -- Cookie (assigned by MMC)
//              [type]        -- Where data object is used (scope, result, ...)
//              [pwcsMachine] -- Name of computer
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminDO::CCIAdminDO( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, WCHAR const * pwcsMachine )
        : _cookie( cookie ),
          _type( type ),
          _pwcsMachine( pwcsMachine ),
          _uRefs( 1 )
{
    // ciaDebugOut(( DEB_ITRACE, "CCIAdminDO::CCIAdminDO, New data object: cookie = 0x%x, type = 0x%x\n",
    //               _cookie, _type ));

    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminDO::~CCIAdminDO
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminDO::~CCIAdminDO()
{
    // ciaDebugOut(( DEB_ITRACE, "Delete data object: cookie = 0x%x, type = 0x%x\n",
    //               _cookie, _type ));

    InterlockedDecrement( &gulcInstances );
}


CCatalog * CCIAdminDO::GetCatalog()
{
    if ( IsACatalog() )
        return (CCatalog *)_cookie;
    else if ( IsADirectoryIntermediate() || IsAPropertyIntermediate() )
        return &((CIntermediate *)_cookie)->GetCatalog();
    else if ( IsAProperty() )
        return &((CCachedProperty *)_cookie)->GetCatalog();
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000
//
//  File:       Header.cxx
//
//  Contents:   Used to maintain / display listview header
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <header.hxx>

CHeaderItem::CHeaderItem( unsigned id,
                          WCHAR const * pwcsName,
                          int Format,
                          int Width,
                          BOOL fInUse )
        : _id( id ),
          _Format( Format ),
          _Width( Width ),
          _fInUse( fInUse )
{
    Win4Assert( wcslen(pwcsName) < ccMaxName );

    wcscpy( _wcsName, pwcsName );
}

CListViewHeader::CListViewHeader()
{
}

void CListViewHeader::Add( unsigned id,
                           WCHAR const * pwcsName,
                           int Format,
                           int Width )
{
    CHeaderItem * pItem = new CHeaderItem( id, pwcsName, Format, Width );

    _aColumn.Add( pItem, _aColumn.Count() );
}

void CListViewHeader::Display( IHeaderCtrl * pHeader )
{
    for ( unsigned i = 0; i < _aColumn.Count(); i++ )
    {
        CHeaderItem * pItem = _aColumn.Get( i );

        if ( pItem->IsInUse() )
            pHeader->InsertColumn( i, pItem->Name(), pItem->Format(), pItem->Width() );
    }
}

void CListViewHeader::Update( IHeaderCtrl * pHeader )
{
    for ( unsigned i = 0; i < _aColumn.Count(); i++ )
    {
        CHeaderItem * pItem = _aColumn.Get( i );

        if ( pItem->IsInUse() )
        {
            int Width;

            SCODE sc = pHeader->GetColumnWidth( i, &Width );

            if ( SUCCEEDED( sc ) )
                pItem->SetWidth( Width );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\ixhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       CIAdmin.hm
//
//  Contents:   Help map for MMC snapin for CI.
//
//  History:    10-Sep-1997     KyleP   Created
//
//--------------------------------------------------------------------------

#pragma once

// Property pages
#define HIDP_GENERATION_FILTER_UNKNOWN             0x18000
#define HIDP_GENERATION_GENERATE_CHARACTERIZATION  0x18001
#define HIDP_GENERATION_MAXIMUM_SIZE               0x18002

#define HIDP_LOCATION_NAME                         0x18003
#define HIDP_LOCATION_LOCATION                     0x18004
#define HIDP_LOCATION_SIZE                         0x18005
#define HIDP_PROPCACHE_SIZE                        0x18006

#define HIDP_WEB_VSERVER                           0x18007
#define HIDP_WEB_NNTPSERVER                        0x18009

#define HIDP_PROPERTY_SET                          0x1800A
#define HIDP_PROPERTY_PROPERTY                     0x1800B
#define HIDP_PROPERTY_CACHED                       0x1800C
#define HIDP_PROPERTY_DATATYPE                     0x1800D
#define HIDP_PROPERTY_SIZE                         0x1800E

#define HIDP_SCOPE_PATH                            0x1800F
#define HIDP_SCOPE_BROWSE                          0x18010
#define HIDP_SCOPE_ALIAS                           0x18011
#define HIDP_SCOPE_USER_NAME                       0x18012
#define HIDP_SCOPE_PASSWORD                        0x18013
#define HIDP_SCOPE_INCLUDE                         0x18014
#define HIDP_SCOPE_EXCLUDE                         0x18015

#define HIDP_CONNECT_LOCAL                         0x18016
#define HIDP_CONNECT_ANOTHER                       0x18017

#define HIDP_PROPERTY_STORAGELEVEL                 0x18018

#define HIDP_LOCATION_BROWSE                       0x18019

#define HIDP_OK                                    0x18020
#define HIDP_CANCEL                                0x18021
#define HIDP_APPLY                                 0x18022

#define HIDP_CATALOG_LOCATION                      0x18023

// Indexing Service usage dialog
#define HIDP_DEDICATED                             0x18024
#define HIDP_USEDOFTEN                             0x18025
#define HIDP_USEDOCCASIONALLY                      0x18026
#define HIDP_NEVERUSED                             0x18027
#define HIDP_ADVANCED_CONFIG                       0x18028
#define HIDP_CUSTOMIZE                             0x18029

// Advanced Indexing Service performance tuning
#define HIDP_INDEXING_PERFORMANCE                  0x18030
#define HIDP_QUERY_PERFORMANCE                     0x18031

// Inheritable settings in property pages
#define HIDP_SETTINGS_INHERIT1                     0x18032
#define HIDP_SETTINGS_INHERIT2                     0x18033

// New additions
#define HIDP_ALIAS_NETWORK_SHARES                  0x18034
#define HIDP_ACCOUNT_INFORMATION                   0x18035
#define HIDP_INCLUSION                             0x18036
#define HIDP_INHERIT                               0x18037
#define HIDP_CATALOG_NAME                          0x18038

BOOL DisplayHelp( HWND hwnd, DWORD dwID );
BOOL DisplayPopupHelp( HWND hwnd, DWORD dwHelpType );
BOOL DisplayHelp( HWND hwnd, DWORD dwID, UINT uCommand );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\catalog.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <params.hxx>
#include <ciregkey.hxx>

#include <snapin.hxx>
#include <catalog.hxx>
#include <catadmin.hxx>
#include <CIARes.h>
#include <callback.hxx>

#include <fsciexps.hxx>

CDynArrayInPlace<CCatalogs *> gapCats;
CDynArrayInPlace<UINT_PTR> gaTimerIds;
UINT gsIndex = 0;
UINT gcMaxCats = 0;
CStaticMutexSem gmtxTimer;
const cRefreshDelay = 5000;

//
// Global data
//

SCatalogColumn coldefCatalog[] = { { CCatalog::GetCat,           MSG_COL_CATNAME },
                                   { CCatalog::GetDrive,         MSG_COL_DRIVE },
                                   { CCatalog::GetSize,          MSG_COL_SIZE },
                                   { CCatalog::GetDocs,          MSG_COL_DOCTOTAL },
                                   { CCatalog::GetDocsToFilter,  MSG_COL_DOCFILTER },
                                   { CCatalog::GetSecQDocuments, MSG_COL_SECQDOCUMENTS },
                                   { CCatalog::GetWordlists,     MSG_COL_WORDLISTS },
                                   { CCatalog::GetPersIndex,     MSG_COL_PERSINDEX },
                                   { CCatalog::GetStatus,        MSG_COL_STATUS }
                                 };

const unsigned cColDefCatalog = sizeof(coldefCatalog) / sizeof(coldefCatalog[0]);

//
// Static command tree to fetch property metadata.
//
// NOTE: There are some funny casts below, because of the requirement to
//       statically initialize a union.
//

const DBID dbcolGuid = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)5 };

const DBID dbcolPropDispid = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                               DBKIND_GUID_PROPID,
                               (LPWSTR)6 };

const DBID dbcolPropName = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)7 };

const DBID dbcolPropLevel = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)8 };

const DBID dbcolPropDataModifiable = { { 0x624c9360, 0x93d0, 0x11cf, 0xa7, 0x87, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x52 },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)9 };

const DBID dbcolPropType = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                             DBKIND_GUID_PROPID,
                             (LPWSTR)4 };

const DBID dbcolSize = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)12 };

const DBID dbcolPath = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                         DBKIND_GUID_PROPID,
                         (LPWSTR)11 };

//
// This is just like PROPVARIANT, but w/o all the arms.  Lets you statically
// assign a VT_CLSID.
//

struct tag_Kyle_PROPVARIANT
{
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    CLSID __RPC_FAR *puuid;
};

GUID psguidStorage = PSGUID_STORAGE;
tag_Kyle_PROPVARIANT stVar = { VT_CLSID, 0, 0, 0, &psguidStorage };
//CStorageVariant stVar((CLSID *)&psguidStorage);

//
// Columns
//

DBCOMMANDTREE dbcmdColumnPath = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPath, S_OK };
DBCOMMANDTREE dbcmdColumnGuid = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolGuid, S_OK };
DBCOMMANDTREE dbcmdColumnPropDispid = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropDispid, S_OK };
DBCOMMANDTREE dbcmdColumnPropName = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropName, S_OK };
DBCOMMANDTREE dbcmdColumnPropType = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropType, S_OK };
DBCOMMANDTREE dbcmdColumnSize = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolSize, S_OK };
DBCOMMANDTREE dbcmdColumnStoreLevel = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropLevel, S_OK };
DBCOMMANDTREE dbcmdColumnModifiable = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPropDataModifiable, S_OK };

//
// Forward declare a few nodes to make linking easy
//

extern DBCOMMANDTREE dbcmdSortListAnchor;
extern DBCOMMANDTREE dbcmdProjectListAnchor;

//
// Select NOT (guid == PSGUID_STORAGE AND dispid == 19)  ; everything but CONTENTS property
//

// the guid == psguid_storage clause

DBCOMMANDTREE dbcmdGuidStorage = { DBOP_scalar_constant,
                                   DBVALUEKIND_VARIANT,
                                   0,
                                   0,
                                   (ULONG_PTR)&stVar,
                                   S_OK };

DBCOMMANDTREE dbcmdColumnGuid2 = { DBOP_column_name,
                                   DBVALUEKIND_ID,
                                   0,
                                   &dbcmdGuidStorage,
                                   (ULONG_PTR)&dbcolGuid,
                                   S_OK };

DBCOMMANDTREE dbcmdEqual = { DBOP_equal,
                            DBVALUEKIND_I4,
                            &dbcmdColumnGuid2,
                            0,
                            0,
                            S_OK };

// the dispid == 19 clause

DBCOMMANDTREE dbcmdContentsId = { DBOP_scalar_constant,
                                   DBVALUEKIND_UI4,
                                   0,
                                   0,
                                   19,
                                   S_OK };

DBCOMMANDTREE dbcmdColumnDispid = { DBOP_column_name,
                                   DBVALUEKIND_ID,
                                   0,
                                   &dbcmdContentsId,
                                   (ULONG_PTR)&dbcolPropDispid,
                                   S_OK };

DBCOMMANDTREE dbcmdEqual2 = { DBOP_equal,
                            DBVALUEKIND_I4,
                            &dbcmdColumnDispid,
                            &dbcmdEqual,
                            0,
                            S_OK };

// the and node between the above two clauses

DBCOMMANDTREE dbcmdAnd =   { DBOP_and,
                            DBVALUEKIND_I4,
                            &dbcmdEqual2,
                            0,
                            0,
                            S_OK };

// the not in front of the above node
DBCOMMANDTREE dbcmdNot =   { DBOP_not,
                            DBVALUEKIND_I4,
                            &dbcmdAnd,
                            0,
                            0,
                            S_OK };

WCHAR wszTable[] = L"Table";

DBCOMMANDTREE dbcmdTable = { DBOP_table_name,
                             DBVALUEKIND_WSTR,
                             0,
                             &dbcmdNot,
                             (ULONG_PTR)&wszTable[0],
                             S_OK };

DBCOMMANDTREE dbcmdSelect = { DBOP_select,
                              DBVALUEKIND_EMPTY,
                              &dbcmdTable,
                              &dbcmdProjectListAnchor,
                              0,
                              S_OK };

//
// Project (Path, GUID, ...)
//
// NOTE: The order here defines the ordinals of columns.
//       The first one here is the last entry in the
//       column list, as it is the last child in the
//       projection list command tree.
//


DBCOMMANDTREE dbcmdProjectModifiable = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnModifiable,
                                       0,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectStoreLevel = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnStoreLevel,
                                       &dbcmdProjectModifiable,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectSize = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnSize,
                                   &dbcmdProjectStoreLevel,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectPropType = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnPropType,
                                       &dbcmdProjectSize,
                                       0,
                                       S_OK };

DBCOMMANDTREE dbcmdProjectPropName = { DBOP_project_list_element,
                                       DBVALUEKIND_EMPTY,
                                       &dbcmdColumnPropName,
                                       &dbcmdProjectPropType,
                                       0,
                                       S_OK };


DBCOMMANDTREE dbcmdProjectPropDispid = { DBOP_project_list_element,
                                         DBVALUEKIND_EMPTY,
                                         &dbcmdColumnPropDispid,
                                         &dbcmdProjectPropName,
                                         0,
                                         S_OK };

DBCOMMANDTREE dbcmdProjectGuid = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnGuid,
                                   &dbcmdProjectPropDispid,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectListAnchor = { DBOP_project_list_anchor,
                                         DBVALUEKIND_EMPTY,
                                         &dbcmdProjectGuid,
                                         0,
                                         0,
                                         S_OK };

DBCOMMANDTREE dbcmdProject = { DBOP_project,
                               DBVALUEKIND_EMPTY,
                               &dbcmdSelect,
                               &dbcmdSortListAnchor,
                               0,
                               S_OK };

//
// Sort (Ascending by GUID)
//

DBSORTINFO dbsortAscending = { FALSE, LOCALE_NEUTRAL };

DBCOMMANDTREE dbcmdSortByGuid = { DBOP_sort_list_element,
                                  DBVALUEKIND_SORTINFO,
                                  &dbcmdColumnGuid,
                                  0,
                                  (ULONG_PTR)&dbsortAscending,
                                  S_OK };

DBCOMMANDTREE dbcmdSortListAnchor = { DBOP_sort_list_anchor,
                                      DBVALUEKIND_EMPTY,
                                      &dbcmdSortByGuid,
                                      0,
                                      0,
                                      S_OK };

DBCOMMANDTREE dbcmdSort =    { DBOP_sort,
                               DBVALUEKIND_EMPTY,
                               &dbcmdProject,
                               0,
                               0,
                               S_OK };

//
// Static set of bindings for fetching property info.
//

struct SPropInfo
{
    GUID      guidPropertySet;
    PROPID    propid;
    ULONG     statusPropid;
    WCHAR *   pwcsName;
    ULONG     statusName;
    ULONG     type;
    ULONGLONG size;
    DWORD     level;
    VARIANT_BOOL fModifiable;
};

DBBINDING abindPropInfo[] = { { 1,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->guidPropertySet, // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->guidPropertySet ),// Value length
                                0,                                          // Flags
                                VT_CLSID,                                   // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 2,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->propid,          // Value offset
                                0,                                          // Length offset
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->statusPropid,    // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE | DBPART_STATUS,               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->propid ),         // Value length
                                0,                                          // Flags
                                DBTYPE_I4,                                  // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 3,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->pwcsName,        // Value offset
                                0,                                          // Length offset
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->statusName,      // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE | DBPART_STATUS,               // Fetch value
                                DBMEMOWNER_PROVIDEROWNED,                   // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->pwcsName ),       // Value length
                                0,                                          // Flags
                                DBTYPE_WSTR | DBTYPE_BYREF,                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 4,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->type,            // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->type ),           // Value length
                                0,                                          // Flags
                                DBTYPE_UI4,                                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 5,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->size,            // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->size ),           // Value length
                                0,                                          // Flags
                                DBTYPE_I8,                                  // Datatype expected
                                0,                                          // Precision (unused)
                                0 },                                        // Scale (unused)

                              { 6,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->level,           // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->level ),          // Value length
                                0,                                          // Flags
                                DBTYPE_UI4,                                 // Datatype expected
                                0,                                          // Precision (unused)
                                0 },

                              { 7,                                          // Ordinal
                                (ULONG) (ULONG_PTR)&((SPropInfo *)0)->fModifiable,     // Value offset
                                0,                                          // Length offset
                                0,                                          // Status offset
                                0,                                          // Typeinfo
                                0,                                          // Object
                                0,                                          // BindExt
                                DBPART_VALUE,                               // Fetch value
                                DBMEMOWNER_CLIENTOWNED,                     // Client owned memory
                                DBPARAMIO_NOTPARAM,                         // Not a parameter
                                sizeof( ((SPropInfo *)0)->fModifiable ),    // Value length
                                0,                                          // Flags
                                DBTYPE_BOOL,                                // Datatype expected
                                0,                                          // Precision (unused)
                                0 }};

BOOL CCatalogs::_fFirstTime = TRUE;

CCatalog::CCatalog( CCatalogs & parent, WCHAR const * pwcsCat )
        : _idScope( 0 ),
          _idResult( 0 ),
          _pwcsDrive( 0 ),
          _pwcsCat( 0 ),
          _parent( parent ),
          _fZombie( FALSE ),
#pragma warning( disable : 4355 )       // this used in base initialization
          _interScopes( *this, Intermediate_Scope ),
          _interProperties( *this, Intermediate_Properties ),
          _interUnfiltered( *this, Intermediate_UnfilteredURL )
#pragma warning( default : 4355 )
{
    //
    // Hack Alert!  This will fake ::Update into thinking all the values need to be
    // changed.
    //

    RtlFillMemory( &_state, sizeof(_state), 0xAA );
    _state.cbStruct = sizeof(_state);

    TRY
    {
        //
        // Initialize string(s)
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( pwcsCat ) );

        Set( xCatalogAdmin->GetLocation(), _pwcsDrive );
        Set( pwcsCat, _pwcsCat );
        _fInactive = xCatalogAdmin->IsCatalogInactive();

        Update();

        //
        // Make sure we think the orignal value is new
        //

        _fSizeChanged = TRUE;
        _fPropCacheSizeChanged = TRUE;
        _fDocsChanged = TRUE;
        _fDocsToFilterChanged = TRUE;
        _fWordlistsChanged = TRUE;
        _fPersIndexChanged = TRUE;
        _fStatusChanged = TRUE;
        _fSecQDocumentsChanged = TRUE;

    }
    CATCH( CException, e )
    {
        delete [] _pwcsDrive;
        delete [] _pwcsCat;

        RETHROW();
    }
    END_CATCH
}


void CCatalog::InitScopeHeader( CListViewHeader & Header )
{
    CScope::InitHeader( Header );
}

void CCatalog::InitPropertyHeader( CListViewHeader & Header )
{
    CCachedProperty::InitHeader( Header );
}

CCatalog::~CCatalog()
{
    delete [] _pwcsDrive;
    delete [] _pwcsCat;
}

SCODE CCatalog::AddScope( WCHAR const * pwszScope,
                          WCHAR const * pwszAlias,
                          BOOL fExclude,
                          WCHAR const * pwszLogon,
                          WCHAR const * pwszPassword )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCatalog::AddScope( %ws, %ws, %s, %ws, %ws )\n",
                  pwszScope,
                  (0 == pwszAlias) ? L"" : pwszAlias,
                  fExclude ? "TRUE" : "FALSE",
                  (0 == pwszLogon) ? L"n/a" : pwszLogon,
                  (0 == pwszPassword) ? L"n/a" : pwszPassword ));

    SCODE sc = S_OK;
    TRY
    {
        //
        // First, add to CI.
        //
   
        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
        xCatalogAdmin->AddScope( pwszScope,
                                 pwszAlias, 
                                 fExclude,
                                 pwszLogon,
                                 pwszPassword );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return (FAILED(sc) ? sc : S_OK);
}

void CCatalog::RemoveScope( CScope * pScope )
{
    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        xCatalogAdmin->RemoveScope( pScope->GetPath() );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    if (FAILED(sc))
    {
        // At this point nothing was removed from the registry, so we shouldn't zombify the scope.
        return;
    }

    //
    // Then, from display.
    //

    pScope->Zombify();
}

SCODE CCatalog::ModifyScope( CScope & rScope,
                             WCHAR const * pwszScope,
                             WCHAR const * pwszAlias,
                             BOOL fExclude,
                             WCHAR const * pwszLogon,
                             WCHAR const * pwszPassword )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCatalog::ModifyScope( %ws, %ws, %s, %ws, %ws )\n",
                  pwszScope,
                  (0 == pwszAlias) ? L"" : pwszAlias,
                  fExclude ? "TRUE" : "FALSE",
                  (0 == pwszLogon) ? L"n/a" : pwszLogon,
                  (0 == pwszPassword) ? L"n/a" : pwszPassword ));

    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _parent.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        //
        // If the path hasn't changed, we should only change properties that have
        // changed. If the path has changed, it will cause the value to be deleted
        // anyway, so we can remove the scope and add the replacement in one shot.
        //
        if (0 == _wcsicmp(rScope.GetPath(), pwszScope))
        {
            XPtr<CScopeAdmin> xScopeAdmin( 
                                 xCatalogAdmin->QueryScopeAdmin(rScope.GetPath()) );

            xScopeAdmin->SetAlias(pwszAlias);

            xScopeAdmin->SetExclude(fExclude);

            xScopeAdmin->SetLogonInfo(pwszLogon, 
                                      pwszPassword, 
                                      xCatalogAdmin.GetReference());
        }
        else
        {
            xCatalogAdmin->RemoveScope( rScope.GetPath() );
   
            // Then add the entry to CI
            xCatalogAdmin->AddScope( pwszScope,
                                     pwszAlias,
                                     fExclude,
                                     pwszLogon,
                                     pwszPassword );
        }

        // Then modify the display entry in place
        rScope.Modify( pwszScope, pwszAlias, fExclude );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

void CCatalog::RescanScope( WCHAR const * pwszScope, BOOL fFull )
{
    SCODE sc = UpdateContentIndex ( pwszScope,
                                    _pwcsCat,
                                    _parent.GetMachine(),
                                    fFull );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "UpdateContentIndex( %ws ) returned 0x%x\n",
                      pwszScope, sc ));

        THROW( CException( sc ) );
    }
}

void CCatalog::Merge()
{
    SCODE sc = ForceMasterMerge ( L"\\",
                                  _pwcsCat,
                                  _parent.GetMachine() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "ForceMasterMerge( %ws ) returned 0x%x\n",
                      _pwcsCat, sc ));

        THROW( CException( sc ) );
    }
}

void CCatalog::DisplayIntermediate( IConsoleNameSpace * pScopePane )
{
    //
    // Now, insert the intermediate nodes.
    //

    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    //
    // 'Scope'
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_CHILDREN;
    item.nImage = ICON_FOLDER;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediateScopeNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) scope item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );

    //
    // 'Properties'
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_CHILDREN;
    item.nImage = ICON_FOLDER;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediatePropNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) property item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );

    //
    // Unfiltered query URL
    //

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN;
    item.nImage = item.nOpenImage = ICON_URL;
    item.displayname = MMC_CALLBACK;
    item.cChildren = 0;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)GetIntermediateUnfilteredNode();

    item.relativeID = ScopeHandle();

    ciaDebugOut(( DEB_ITRACE, "Inserting (intermediate) URL item (lParam = 0x%x)\n", item.lParam ));

    pScopePane->InsertItem( &item );
}

void CCatalog::DisplayScopes( BOOL fFirstTime, IResultData * pResultPane )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalog::DisplayScopes (fFirstTime = %d)\n", fFirstTime ));

    ClearScopes(pResultPane);
    PopulateScopes();

    for ( unsigned i = 0; i < _aScope.Count(); i++ )
    {
        CScope * pScope = _aScope.Get( i );

        Win4Assert(!pScope->IsZombie());

         //
         // All items were freshly enumerated. add them all
         //

         RESULTDATAITEM item;
         RtlZeroMemory( &item, sizeof(item) );

         item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
         item.nCol = 0;

         // item.nImage will be set by ::GetDisplayInfo
         pScope->GetDisplayInfo( &item );

         item.str = MMC_CALLBACK;
         item.lParam = (LPARAM)pScope;

         ciaDebugOut(( DEB_ITRACE, "Inserting result item %ws (lParam = 0x%x)\n",
                       pScope->GetPath(), item.lParam ));

         pResultPane->InsertItem( &item );

         pScope->SetResultHandle( item.itemID );
    }
}

void CCatalog::ClearProperties(IResultData * pResultPane)
{
    // Clear out the display list
    pResultPane->DeleteAllRsltItems();

    // Delete the entries from the property list
    _aProperty.Clear();
}

void CCatalog::DisplayProperties( BOOL fFirstTime, IResultData * pResultPane )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalog::DisplayProperties (fFirstTime = %d)\n", fFirstTime ));

    // If catalog is stopped OR service is stopped, clear the list.
    BOOL fStopped = FALSE;
    TRY
    {
        CMachineAdmin   MachineAdmin( _parent.IsLocalMachine() ? 0 : _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

        fStopped = xCat->IsStopped() || MachineAdmin.IsCIStopped();

        if (fStopped)
           ClearProperties(pResultPane);
    }
    CATCH( CException, e)
    {
       // nothing to do
    }
    END_CATCH

    if (fStopped)
        return;

    if ( fFirstTime )
        UpdateProps();

    for ( unsigned i = 0; i < _aProperty.Count(); i++ )
    {
        CCachedProperty * pProperty = _aProperty.Get( i );

        if ( pProperty->IsZombie() )
        {
            pResultPane->DeleteItem( pProperty->ResultHandle(), 0 );

            //
            // Delete scope and move highest entry down.
            //

            pProperty = _aProperty.Acquire( i );
            delete pProperty;

            if ( _aProperty.Count() > 0 && _aProperty.Count() != i )
            {
                pProperty = _aProperty.Acquire( _aProperty.Count() - 1 );
                _aProperty.Add( pProperty, i );
            }

            continue;
        }

        if ( fFirstTime || pProperty->IsNew() )
        {
            //
            // Add item
            //

            RESULTDATAITEM item;
            RtlZeroMemory( &item, sizeof(item) );

            item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
            item.nCol = 0;

            pProperty->GetDisplayInfo( &item );
            // item.nImage is set from ::GetDisplayInfo

            item.str = MMC_CALLBACK;
            item.lParam = (LPARAM)pProperty;

            ciaDebugOut(( DEB_ITRACE, "Inserting result item %ws (lParam = 0x%x)\n",
                          pProperty->GetProperty(), item.lParam ));

            pResultPane->InsertItem( &item );

            pProperty->SetResultHandle( item.itemID );
            pProperty->MakeOld();
        }


        if ( !fFirstTime && !pProperty->IsNew() )
        {
            if ( !pProperty->IsUnappliedChange() )
            {
                //
                // Set the icon back to normal.
                //

                RESULTDATAITEM rdi;
                RtlZeroMemory(&rdi, sizeof(rdi));

                rdi.mask   = RDI_IMAGE;
                rdi.itemID = pProperty->ResultHandle();

                // item.nImage is set from ::GetDisplayInfo
                pProperty->GetDisplayInfo( &rdi );

                SCODE sc = pResultPane->SetItem( &rdi );
            }
        }
    }
}

void CCatalog::GetGeneration( BOOL  & fFilterUnknown,
                              BOOL  & fGenerateCharacterization,
                              ULONG & ccCharacterization )
{
    // Caller will deal with exceptions.

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    //
    // Filter Unknown
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) )
        dw = CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;

    fFilterUnknown = (0 != dw);

    //
    // Characterization. We should check if generatecharacterization flag is set to
    // TRUE and also check the characterization size. Only when the flag is set to TRUE
    // and size > 0, should we generate characterization.
    //

    DWORD dwGenCharacterization = 0;

    if ( !xCatalogAdmin->GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) &&
         !MachineAdmin.GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) )
        dwGenCharacterization = 1;

    if ( !xCatalogAdmin->GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) &&
         !MachineAdmin.GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) )
        ccCharacterization = CI_MAX_CHARACTERIZATION_DEFAULT;

    fGenerateCharacterization = (ccCharacterization > 0) && (0 != dwGenCharacterization);
}

void CCatalog::SetGeneration( BOOL  fFilterUnknown,
                              BOOL  fGenerateCharacterization,
                              ULONG ccCharacterization )
{
    //
    // fGenerateCharacterization is obsolete.
    //

    if ( !fGenerateCharacterization )
        ccCharacterization = 0;

    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsFilterFilesWithUnknownExtensions, fFilterUnknown );
    xCatalogAdmin->SetDWORDParam( wcsGenerateCharacterization, fGenerateCharacterization );
    xCatalogAdmin->SetDWORDParam( wcsMaxCharacterization, ccCharacterization );
}

void CCatalog::GetTracking( BOOL  & fAutoAlias )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsAutoAlias, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsAutoAlias, dw ) )
        dw = CI_IS_AUTO_ALIAS_DEFAULT;

    fAutoAlias = (0 != dw);
}

void CCatalog::SetTracking( BOOL  fAutoAlias )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsIsAutoAlias, fAutoAlias );
}

void CCatalog::GetWeb( BOOL &  fVirtualRoots,
                       BOOL &  fNNTPRoots,
                       ULONG & iVirtualServer,
                       ULONG & iNNTPServer )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    DWORD dw;

    //
    // Filter Virtual Roots
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsIndexingW3Roots, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsIndexingW3Roots, dw ) )
        dw = CI_IS_INDEXING_W3_ROOTS_DEFAULT;

    fVirtualRoots = (0 != dw);

    //
    // Filter NNTP Roots
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsIsIndexingNNTPRoots, dw ) &&
         !MachineAdmin.GetDWORDParam( wcsIsIndexingNNTPRoots, dw ) )
        dw = CI_IS_INDEXING_NNTP_ROOTS_DEFAULT;

    fNNTPRoots = (0 != dw);

    //
    // Virtual server
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsW3SvcInstance, iVirtualServer ) &&
         !MachineAdmin.GetDWORDParam( wcsW3SvcInstance, iVirtualServer ) )
        iVirtualServer = CI_W3SVC_INSTANCE_DEFAULT;

    //
    // NNTP Virtual server
    //

    if ( !xCatalogAdmin->GetDWORDParam( wcsNNTPSvcInstance, iNNTPServer ) &&
         !MachineAdmin.GetDWORDParam( wcsNNTPSvcInstance, iNNTPServer ) )
        iNNTPServer = CI_NNTPSVC_INSTANCE_DEFAULT;
}

void CCatalog::SetWeb( BOOL  fVirtualRoots,
                       BOOL  fNNTPRoots,
                       ULONG iVirtualServer,
                       ULONG iNNTPServer )
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );

    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

    xCatalogAdmin->SetDWORDParam( wcsIsIndexingW3Roots, fVirtualRoots );
    xCatalogAdmin->SetDWORDParam( wcsIsIndexingNNTPRoots, fNNTPRoots );
    xCatalogAdmin->SetDWORDParam( wcsW3SvcInstance, iVirtualServer );
    xCatalogAdmin->SetDWORDParam( wcsNNTPSvcInstance, iNNTPServer );
}

void CCatalog::UpdateCachedProperty(CCachedProperty *pProperty)
{
    TRY
    {
        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin(GetCat(TRUE)) );

        Win4Assert(pProperty->IsUnappliedChange() );

        xCatalogAdmin->AddCachedProperty( *((CFullPropSpec const *)pProperty->GetFullPropspec()),
                                          pProperty->GetVT(),
                                          pProperty->Allocation(),
                                          pProperty->StoreLevel(),
                                          pProperty->IsModifiable());

        pProperty->ClearUnappliedChange();
    }
    CATCH(CException, e)
    {
        ULONG cc = wcslen(pProperty->GetPropSet());
        cc++;
        cc += wcslen(pProperty->GetProperty());
        cc++;

        XGrowable<WCHAR> xPropDescription(cc);

        wcscpy(xPropDescription.Get(), pProperty->GetPropSet());
        wcscat(xPropDescription.Get(), L" ");
        wcscat(xPropDescription.Get(), pProperty->GetProperty());

        MessageBox(GetFocus(), xPropDescription.Get(),
                   STRINGRESOURCE( srPropCommitErrorT ), MB_ICONWARNING);

    }
    END_CATCH
}

void CCatalog::Set( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    if ( 0 == pwcsSrc )
    {
        pwcsDst = new WCHAR[2];
        RtlCopyMemory( pwcsDst, L" ", 2*sizeof(WCHAR) );
    }
    else
    {
        unsigned cc = wcslen( pwcsSrc ) + 1;

        pwcsDst = new WCHAR [cc];

        RtlCopyMemory( pwcsDst, pwcsSrc, cc * sizeof(WCHAR) );
    }
}

void CCatalog::Stringize( DWORD dwValue, WCHAR * pwcsDst, unsigned ccDst )
{
    //
    // GetNumberFormat places additional decimals at the end...
    //
#if 0
    WCHAR wcTemp[100];

    _ultow( dwValue, wcTemp, 10 );
    GetNumberFormat( LOCALE_USER_DEFAULT,    // Default locale
                     0,                      // Flags
                     wcTemp,                 // Input
                     0,                      // More formatting info
                     pwcsDst,                // Output buffer
                     ccDst );                // Size
#else
    _ultow( dwValue, pwcsDst, 10 );
#endif
}

BOOL CCatalog::Update()
{
    //
    // Get state
    //

    CI_STATE state;
    ULONG ulCacheSizeInKB;

    state.cbStruct = sizeof(state);

    SCODE sc = CIState( _pwcsCat,
                        _parent.GetMachine(),
                        &state );

    if ( FAILED(sc) )
    {
        Null( _awcWordlists );
        Null( _awcPersIndex );
        Null( _awcSize );
        Null( _awcPropCacheSize );
        Null( _awcDocsToFilter );
        Null( _awcSecQDocuments );
        Null( _awcDocs );
        Null( _awcStatus );

        //
        // Make sure when we come back to life we will update values.
        //

        RtlFillMemory( &_state, sizeof(_state), 0xAA );
        _state.cbStruct = sizeof(_state);

        _fSizeChanged = TRUE;
        _fPropCacheSizeChanged = TRUE;
        _fDocsChanged = TRUE;
        _fDocsToFilterChanged = TRUE;
        _fWordlistsChanged = TRUE;
        _fPersIndexChanged = TRUE;
        _fStatusChanged = TRUE;
        _fSecQDocumentsChanged = TRUE;

        TRY
        {
            CMachineAdmin   MachineAdmin( _parent.IsLocalMachine() ? 0 : _parent.GetMachine() );

            XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );

            if (xCat->IsStopped())
            {
                wcscpy( _awcStatus, STRINGRESOURCE(srStopped) );
            }
        }
        CATCH( CException, e)
        {
           // nothing to do
        }
        END_CATCH
    }
    else
    {
        //
        // String-ize
        //

        //
        // Could put more of this in a method, but it seems like overkill.  A table based
        // solution will be necessary if this list grows.
        //

        if ( _state.cWordList != state.cWordList )
        {
            Stringize( state.cWordList, _awcWordlists, sizeof(_awcWordlists)/sizeof(WCHAR) );
            _fWordlistsChanged = TRUE;
        }
        else
            _fWordlistsChanged = FALSE;

        if ( _state.cPersistentIndex != state.cPersistentIndex )
        {
            Stringize( state.cPersistentIndex, _awcPersIndex, sizeof(_awcPersIndex)/sizeof(WCHAR) );
            _fPersIndexChanged = TRUE;
        }
        else
            _fPersIndexChanged = FALSE;

        if ( _state.dwIndexSize != state.dwIndexSize )
        {
            Stringize( state.dwIndexSize, _awcSize, sizeof(_awcSize)/sizeof(WCHAR) );
            _fSizeChanged = TRUE;
        }
        else
            _fSizeChanged = FALSE;

        if (_state.dwPropCacheSize != state.dwPropCacheSize)
        {
            Stringize(state.dwPropCacheSize/1024, _awcPropCacheSize, sizeof(_awcPropCacheSize)/sizeof(WCHAR));
            _fPropCacheSizeChanged = TRUE;
        }
        else
            _fPropCacheSizeChanged = FALSE;

        if ( _state.cDocuments != state.cDocuments )
        {
            Stringize( state.cDocuments, _awcDocsToFilter, sizeof(_awcDocsToFilter)/sizeof(WCHAR) );
            _fDocsToFilterChanged = TRUE;
        }
        else
            _fDocsToFilterChanged = FALSE;

        if ( _state.cSecQDocuments != state.cSecQDocuments )
        {
            Stringize( state.cSecQDocuments, _awcSecQDocuments, sizeof(_awcSecQDocuments)/sizeof(WCHAR) );
            _fSecQDocumentsChanged = TRUE;
        }
        else
            _fSecQDocumentsChanged = FALSE;

        if ( _state.cTotalDocuments != state.cTotalDocuments )
        {
            Stringize( state.cTotalDocuments, _awcDocs, sizeof(_awcDocs)/sizeof(WCHAR) );
            _fDocsChanged = TRUE;
        }
        else
            _fDocsChanged = FALSE;

        if ( _state.eState != state.eState || _state.dwMergeProgress != state.dwMergeProgress )
        {
            FormatStatus( state );
            _fStatusChanged = TRUE;
        }
        else
            _fStatusChanged = FALSE;

        RtlCopyMemory( &_state, &state, sizeof(state) );
    }

    return ChangesPending();
}

BOOL CCatalog::UpdateProps()
{
    if ( 0 != _aProperty.Count() )
        return FALSE;

    //
    // Look for cached properties
    //
    IUnknown * pIUnknown;
    XInterface<ICommand> xCmd;

    SCODE sc = MakeMetadataICommand( &pIUnknown,
                                     CiProperties,
                                     _pwcsCat,
                                     _parent.GetMachine() );
    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x creating metadata ICommand\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<IUnknown> xUnk( pIUnknown );
    sc = pIUnknown->QueryInterface(IID_ICommand, xCmd.GetQIPointer());

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x on QueryInterface IID_ICommand\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<ICommandTree> xCmdTree;

    sc = xCmd->QueryInterface( IID_ICommandTree, xCmdTree.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to ICommandTree\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    DBCOMMANDTREE * pTree = &dbcmdSort;

    sc = xCmdTree->SetCommandTree( &pTree, DBCOMMANDREUSE_NONE, TRUE );

    Win4Assert( 0 != pTree );  // Make sure it wasn't taken from us!

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x setting command tree\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    XInterface<IRowset> xRowset;

    sc = xCmd->Execute( 0, IID_IRowset, 0, 0, (IUnknown **)xRowset.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x creating metadata rowset.\n", sc ));

        //THROW( CException(sc) );
        return FALSE;
    }

    //
    // Now, we have a cursor.  Create some bindings.  Below this point, we shouldn't
    // expect any errors.
    //

    XInterface<IAccessor> xAccessor;

    sc = xRowset->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to IAccessor\n", sc ));
        THROW( CException(sc) );
    }

    HACCESSOR hacc;

    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    sizeof(abindPropInfo) / sizeof(abindPropInfo[0]),
                                    abindPropInfo,
                                    0,
                                    &hacc,
                                    0 );

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Error 0x%x binding to IAccessor\n", sc ));
        THROW( CException(sc) );
    }

    //
    // Now we have a cursor and bindings.  Iterate over the data.
    //

    while ( SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET )
    {
        HROW  ahrow[10];
        DBCOUNTITEM cRow;
        HROW* phrow = ahrow;

        sc = xRowset->GetNextRows( 0,                               // Chapter
                                   0,                               // Skip
                                   sizeof(ahrow)/sizeof(ahrow[0]),  // Count requested
                                   &cRow,                           // Count fetched
                                   &phrow );

        if ( SUCCEEDED(sc) )
        {
            for ( ULONG i = 0; SUCCEEDED(sc) && i < cRow; i++ )
            {
                SPropInfo sprop;

                sc = xRowset->GetData( ahrow[i], hacc, &sprop );

                Win4Assert( DBSTATUS_S_OK == sprop.statusPropid ||
                            DBSTATUS_S_OK == sprop.statusName );

                if ( SUCCEEDED(sc) &&
                     ( DBSTATUS_S_OK == sprop.statusPropid ||
                       DBSTATUS_S_OK == sprop.statusName ) )
                {
                    PROPSPEC ps = { PRSPEC_PROPID, 1 };

                    if ( DBSTATUS_S_OK == sprop.statusName )
                    {
                        ps.ulKind = PRSPEC_LPWSTR;
                        ps.lpwstr = sprop.pwcsName;
                    }
                    else
                        ps.propid = sprop.propid;

                    CCachedProperty * pProp = new CCachedProperty( *this,
                                                                   sprop.guidPropertySet,
                                                                   ps,
                                                                   sprop.type,
                                                                   sprop.size,
                                                                   sprop.level,
                                                                   sprop.fModifiable );

                    _aProperty.Add( pProp, _aProperty.Count() );
                }
            }

            if ( FAILED(sc) || sc == DB_S_ENDOFROWSET )
                xRowset->ReleaseRows( cRow, ahrow, 0, 0, 0 );
            else
                sc = xRowset->ReleaseRows( cRow, ahrow, 0, 0, 0 );
        }
    }

    if ( FAILED(sc) )
    {
        ciaDebugOut(( DEB_ERROR, "Something bad during row fetch (0x%x)\n", sc ));
        THROW( CException(sc) );
    }

    xAccessor->ReleaseAccessor( hacc, 0 );

    return TRUE;
}

void CCatalog::FormatStatus( CI_STATE & state )
{
    //
    // One-shot initialization
    //

    static unsigned       ccScanReq;
    static unsigned       ccScanning;
    static unsigned       ccRecovering;
    static unsigned       ccMMPaused;
    static unsigned       ccHighIo;
    static unsigned       ccLowMemory;
    static unsigned       ccReadOnly;
    static unsigned       ccBattery;
    static unsigned       ccUserActive;
    static unsigned       ccStarting;
    static unsigned       ccReadingUsns;
    static unsigned       ccStarted;

    if ( 0 == ccScanReq )
    {
        ccScanReq = wcslen( STRINGRESOURCE( srScanReq ) );
        ccScanning = wcslen( STRINGRESOURCE( srScanning ) );
        ccRecovering = wcslen( STRINGRESOURCE( srRecovering ) );
        ccMMPaused = wcslen( STRINGRESOURCE( srMMPaused ) );
        ccHighIo = wcslen( STRINGRESOURCE( srHighIo ) );
        ccLowMemory = wcslen( STRINGRESOURCE( srLowMemory ) );
        ccReadOnly = wcslen( STRINGRESOURCE( srReadOnly ) );
        ccBattery = wcslen( STRINGRESOURCE( srBattery ) );
        ccUserActive = wcslen( STRINGRESOURCE( srUserActive ) );
        ccStarting = wcslen( STRINGRESOURCE( srStarting ) );
        ccReadingUsns = wcslen( STRINGRESOURCE( srReadingUsns ) );
        ccStarted = wcslen( STRINGRESOURCE( srStarted ) );
    }

    _awcStatus[0] = 0;

    WCHAR * pwcsStatus = _awcStatus;
    unsigned ccLeft = sizeof(_awcStatus) / sizeof(WCHAR) - 1;

    // Changed srShadow and srAnnealing to just be "Merge" so the end user won't have
    // to be told what shadow and annealing merges are. KISS
    if ( state.eState & CI_STATE_SHADOW_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srShadow ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_ANNEALING_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srAnnealing ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_MASTER_MERGE )
    {
        wsprintf( _awcStatus, STRINGRESOURCE( srMaster ), state.dwMergeProgress );
        ccLeft -= wcslen( _awcStatus );
    }
    else if ( state.eState & CI_STATE_MASTER_MERGE_PAUSED )
    {
        RtlCopyMemory( _awcStatus, STRINGRESOURCE( srMMPaused ), (ccMMPaused + 1) * sizeof(WCHAR) );
        ccLeft -= ccMMPaused;
    }

    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_SCANNING, srScanning, ccScanning );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_HIGH_IO, srHighIo, ccHighIo );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_LOW_MEMORY, srLowMemory, ccLowMemory );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_BATTERY_POWER, srBattery, ccBattery );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_USER_ACTIVE, srUserActive, ccUserActive );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_STARTING, srStarting, ccStarting );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_READING_USNS, srReadingUsns, ccReadingUsns );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_RECOVERING, srRecovering, ccRecovering );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_CONTENT_SCAN_REQUIRED, srScanReq, ccScanReq );
    ccLeft = AppendToStatus( ccLeft, state, CI_STATE_READ_ONLY, srReadOnly, ccReadOnly );

    // If the status is not "Starting", then it should be "Started" so we don't have
    // an empty status field

    if ( (!(state.eState & CI_STATE_STARTING)) && ccLeft >= ccStarted+2)
    {
        if ( _awcStatus[0] == 0 )
        {
            RtlCopyMemory( _awcStatus, STRINGRESOURCE(srStarted), (ccStarted+1) * sizeof(WCHAR) );
            ccLeft -= ccStarted;
        }
        else
        {
            wcscat( _awcStatus, L", " );
            wcscat( _awcStatus, STRINGRESOURCE(srStarted) );
            ccLeft -= ccStarted + 2;
        }
    }
}

unsigned CCatalog::AppendToStatus( unsigned ccLeft,
                                   CI_STATE & state,
                                   DWORD dwFlag,
                                   StringResource & srFlag,
                                   unsigned ccFlag )
{
    if ( state.eState & dwFlag && ccLeft >= ccFlag + 2 )
    {
        if ( _awcStatus[0] == 0 )
        {
            RtlCopyMemory( _awcStatus, STRINGRESOURCE(srFlag), (ccFlag+1) * sizeof(WCHAR) );
            ccLeft -= ccFlag;
        }
        else
        {
            wcscat( _awcStatus, L", " );
            wcscat( _awcStatus, STRINGRESOURCE(srFlag) );
            ccLeft -= ccFlag + 2;
        }
    }

    return ccLeft;
}

void CCatalog::ClearScopes(IResultData * pResultPane)
{
    // Clear out the display list
    pResultPane->DeleteAllRsltItems();

    // Delete the entries from the property list
    _aScope.Clear();
}

void CCatalog::PopulateScopes()
{
    if ( 0 != _aScope.Count() )
        return;

    TRY
    {
        CMachineAdmin MachineAdmin( _parent.GetMachine() );

        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
        XPtr<CScopeEnum>    xScopeEnum( xCatalogAdmin->QueryScopeEnum() );

        for ( ; xScopeEnum->Next(); )
        {
            XPtr<CScopeAdmin> xScopeAdmin( xScopeEnum->QueryScopeAdmin() );

            CScope * pScope = new CScope( *this,
                                         xScopeAdmin->GetPath(),
                                         xScopeAdmin->GetAlias(),
                                         xScopeAdmin->IsExclude(),
                                         xScopeAdmin->IsVirtual(),
                                         xScopeAdmin->IsShadowAlias() );

            _aScope.Add( pScope, _aScope.Count() );
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_WARN, "Error enumerating scopes for %ws.\n", _pwcsCat ));
    }
    END_CATCH
}

// Delete registry values for grouped settings. Deletion ensures that those
// registry parameters are inherited from the service.

// Group1 settings are wcsGenerateCharacterization and 
// wcsFilterFilesWithUnknownExtensions

// Group2 settings are wcsIsAutoAlias
// Check to see if parameter groups are available

BOOL CCatalog::DoGroup1SettingsExist()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    DWORD dwVal;
    BOOL fParamsExist = xCatalogAdmin->GetDWORDParam( wcsGenerateCharacterization, dwVal ) 
                     || xCatalogAdmin->GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dwVal )
                     || xCatalogAdmin->GetDWORDParam( wcsMaxCharacterization, dwVal );

    return fParamsExist;
}


BOOL CCatalog::DoGroup2SettingsExist()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
    
    DWORD dwVal;
    BOOL fParamsExist = xCatalogAdmin->GetDWORDParam( wcsIsAutoAlias, dwVal );

    return fParamsExist;
}

void CCatalog::FillGroup1Settings()
{
    BOOL  fFilterUnknown, fGenerateCharacterization;
    ULONG ccCharacterization;

    // GetGeneration gets registry params from catalog or 
    // service (if they don't exist at catalog level)
    GetGeneration(fFilterUnknown, fGenerateCharacterization, ccCharacterization);
    SetGeneration(fFilterUnknown, fGenerateCharacterization, ccCharacterization);
}

void CCatalog::FillGroup2Settings()
{
   BOOL fTracking;
   GetTracking(fTracking);
   SetTracking(fTracking);
}

void CCatalog::DeleteGroup1Settings()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsGenerateCharacterization );
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsFilterFilesWithUnknownExtensions );
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsMaxCharacterization );
}

// Group2 settings are wcsIsAutoAlias
void CCatalog::DeleteGroup2Settings()
{
    // Caller will deal with exceptions

    CMachineAdmin MachineAdmin( _parent.GetMachine() );
    XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _pwcsCat ) );
  
    xCatalogAdmin->DeleteRegistryParamNoThrow( wcsIsAutoAlias );
}

CCatalogs::CCatalogs()
        : _fFirstScopeExpansion( TRUE ),
          _fAbort( FALSE ),
          _pScopePane( 0 ),
          _uiTimerIndex( 0xFFFFFFFF ),
          _wIndexingPos( -1 ),
          _wQueryingPos( -1 ),
          _pSnapinData( 0 )
{
    //
    // By default, point at local machine.
    //

    _xwcsMachine[0] = L'.';
    _xwcsMachine[1] = 0;
}

CCatalogs::~CCatalogs()
{
    _fAbort = TRUE;

    if (0xFFFFFFFF != _uiTimerIndex && gaTimerIds[_uiTimerIndex])
    {
        CLock lock(gmtxTimer);

        KillTimer(NULL, gaTimerIds[_uiTimerIndex]);
        gapCats[_uiTimerIndex] = 0;
    }

    if ( 0 != _pScopePane )
        _pScopePane->Release();
}

void CCatalogs::SetMachine( WCHAR const * pwcsMachine )
{
    unsigned cc = wcslen( pwcsMachine ) + 1;

    // Remove leading '\' characters. We don't need them, although they 
    // are commonly included as part of server names
    WCHAR const *pwcsStart = pwcsMachine;
    while ( *pwcsStart == L'\\' )
    {
        cc--;
        pwcsStart++;
    }

    _xwcsMachine.SetSize( cc );

    RtlCopyMemory( _xwcsMachine.Get(), pwcsStart, cc * sizeof(WCHAR) );

    ciaDebugOut((DEB_ITRACE, "Input machine name %ws is converted to %ws\n",
                 pwcsMachine, pwcsStart));
}

void CCatalogs::Init( IConsoleNameSpace * pScopePane )
{
    Win4Assert( 0 == _pScopePane );

    _pScopePane = pScopePane;
    _pScopePane->AddRef();

    // timer stuff
    CLock lock(gmtxTimer);

    gsIndex++;
    gapCats[gsIndex-1] = this;
    _uiTimerIndex = gcMaxCats;
    gaTimerIds[_uiTimerIndex] = SetTimer(NULL, 0, cRefreshDelay, (TIMERPROC)DisplayTimerProc);
    gcMaxCats++;
}

void CCatalogs::InitHeader( CListViewHeader & Header )
{
    //
    // Initialize header
    //

    for ( unsigned i = 0; i < sizeof(coldefCatalog)/sizeof(coldefCatalog[0]); i++ )
    {
        if ( _fFirstTime )
            coldefCatalog[i].srTitle.Init( ghInstance );

        Header.Add( i, STRINGRESOURCE( coldefCatalog[i].srTitle ), LVCFMT_LEFT, MMCLV_AUTO );
    }

    _fFirstTime = FALSE;
}

void CCatalogs::DisplayScope( HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::DisplayScope (hScopeItem = 0x%x)\n", hScopeItem ));

    Populate();

    Win4Assert( 0 != _pScopePane );

    //
    // Squirrel away the parent pointer.
    //

    if ( 0xFFFFFFFF != hScopeItem )
        _hRootScopeItem = hScopeItem;

    if ( _hRootScopeItem == 0xFFFFFFFF )
        return;

    for ( unsigned i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() )
        {
            _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );

            //
            // Delete catalog and move highest entry down.
            //

            pCat = _aCatalog.Acquire( i );
            delete pCat;

            if ( _aCatalog.Count() > 0  && _aCatalog.Count() != i )
            {
                pCat = _aCatalog.Acquire( _aCatalog.Count() - 1 );
                _aCatalog.Add( pCat, i );
                i--;
            }

            continue;
        }

        if (pCat->IsInactive())
        {
            RemoveCatalogFromScope(pCat);
            continue;
        }

        if ( pCat->IsAddedToScope())
            continue;

        AddCatalogToScope(pCat);
    }
}

void CCatalogs::AddCatalogToScope(CCatalog *pCat)
{

    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
    item.nImage = item.nOpenImage = ICON_CATALOG;
    //item.displayname = (WCHAR *)pCat->GetCat( TRUE );  
    item.displayname = MMC_CALLBACK;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)pCat;

    item.relativeID = _hRootScopeItem;

    ciaDebugOut(( DEB_ITRACE, "Inserting scope item %ws (lParam = 0x%x)\n",
                  pCat->GetCat( TRUE ), item.lParam ));

    _pScopePane->InsertItem( &item );

    pCat->SetScopeHandle( item.ID );
}


void CCatalogs::RemoveCatalogFromScope(CCatalog *pCat)
{
    if (pCat->ScopeHandle())
    {
        _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );
        pCat->SetScopeHandle(0);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCatalogs::ReInit, public
//
//  Synopsis:   Re-Initialize catalogs node to default state
//
//  History:    27-Jul-1998   KyleP   Created
//
//  Notes:      Used when MMCN_REMOVE_CHILDREN is sent to snapin, and we
//              need to blast away all state.
//
//--------------------------------------------------------------------------

SCODE CCatalogs::ReInit()
{
    SCODE sc = S_OK;

    Win4Assert( 0 != _pScopePane );

    _fAbort = TRUE;

    //
    // Get rid of the old timer.
    //

    if ( 0xFFFFFFFF != _uiTimerIndex && gaTimerIds[_uiTimerIndex] )
    {
        CLock lock(gmtxTimer);

        KillTimer(NULL, gaTimerIds[_uiTimerIndex]);
        gapCats[_uiTimerIndex] = 0;
    }

    //
    // And the old catalogs...
    //

    while ( _aCatalog.Count() > 0 )
    {
        RemoveCatalogFromScope( _aCatalog.Get( _aCatalog.Count()-1 ) );
        delete _aCatalog.AcquireAndShrink( _aCatalog.Count()-1 );
    }

    _fAbort = FALSE;

    //
    // Now, a new timer.
    //

    CLock lock2(gmtxTimer);

    gsIndex++;
    gapCats[gsIndex-1] = this;
    _uiTimerIndex = gcMaxCats;
    gaTimerIds[_uiTimerIndex] = SetTimer(NULL, 0, cRefreshDelay, (TIMERPROC)DisplayTimerProc);
    gcMaxCats++;

    return sc;
}

void CCatalogs::Display( BOOL fFirstTime )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::Display (fFirstTime = %d)\n", fFirstTime ));

    for ( unsigned i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() || !pCat->IsAddedToScope() || pCat->IsInactive() )
            continue;

        if ( pCat->Update() )
        {
            // Ping scope pane...

            SCOPEDATAITEM item;

            RtlZeroMemory( &item, sizeof(item) );

            item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            item.nImage = item.nOpenImage = ICON_CATALOG;

            //item.displayname = (WCHAR *)pCat->GetCat( TRUE ); 
            item.displayname = MMC_CALLBACK;

            item.mask |= SDI_PARAM;
            item.lParam = (LPARAM)pCat;

            item.ID = pCat->ScopeHandle();

            ciaDebugOut(( DEB_ITRACE, "Ping-ing scope item %ws (lParam = 0x%x)\n",
                          pCat->GetCat( TRUE ), item.lParam ));

            _pScopePane->SetItem( &item );
        }
    }
}

SCODE CCatalogs::AddCatalog( WCHAR const * pwszCatName,
                            WCHAR const * pwszLocation )
{
    SCODE sc = S_OK;

    ciaDebugOut(( DEB_ITRACE,
                  "CCatalogs::AddCatalog( %ws, %ws )\n",
                  pwszCatName, pwszLocation ));
    //
    // First, check to see if the catalog name and location are already used
    //
    for (ULONG i = 0; i < _aCatalog.Count(); i++)
    {
        if (0 == _wcsicmp(_aCatalog[i]->GetCat(TRUE), pwszCatName) ||
            0 == _wcsicmp(_aCatalog[i]->GetDrive(TRUE), pwszLocation))
        {
            return E_INVALIDARG;
        }
    }

    TRY
    {
        //
        // First, add to CI.
        //

        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.AddCatalog( pwszCatName, pwszLocation );

        //
        // Then, to display.
        //

        XPtr<CCatalog> xCat(new CCatalog( *this, pwszCatName ));

        _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
        xCat.Acquire();
    }
    CATCH(CException, e)
    {
        ciaDebugOut(( DEB_WARN, "AddCatalog( %ws, %ws ) caught exception 0x%x\n",
                      pwszCatName, pwszLocation, sc ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::RemoveCatalog( CCatalog * pCat )
{
    ciaDebugOut(( DEB_ITRACE, "CCatalogs::RemoveCatalog( %ws )\n", pCat->GetCat(TRUE) ));

    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.RemoveCatalog( pCat->GetCat(TRUE), TRUE );
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    // Then, from display. Go ahead and Zombify even if catalog wasn't successfully
    // removed. Parts of it may have been removed, so it is probably unusable anyway.
    //

    pCat->Zombify();

    return sc;
}

void CCatalogs::Quiesce()
{

    //_Header.Update();
}



void CCatalogs::GetGeneration( BOOL  & fFilterUnknown,
                               BOOL  & fGenerateCharacterization,
                               ULONG & ccCharacterization )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    DWORD dw;

    //
    // Filter Unknown
    //

    if ( !MachineAdmin.GetDWORDParam( wcsFilterFilesWithUnknownExtensions, dw ) )
        dw = CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;

    fFilterUnknown = (0 != dw);

    //
    // Characterization. We should check if generatecharacterization flag is set to
    // TRUE and also check the characterization size. Only when the flag is set to TRUE
    // and size > 0, should we generate characterization.
    //

    DWORD dwGenCharacterization = 0;

    if ( !MachineAdmin.GetDWORDParam( wcsGenerateCharacterization, dwGenCharacterization ) )
        dwGenCharacterization = 1;

    if ( !MachineAdmin.GetDWORDParam( wcsMaxCharacterization, ccCharacterization ) )
        ccCharacterization = CI_MAX_CHARACTERIZATION_DEFAULT;

    fGenerateCharacterization = (ccCharacterization > 0) && (0 != dwGenCharacterization);
}

void CCatalogs::SetGeneration( BOOL  fFilterUnknown,
                               BOOL  fGenerateCharacterization,
                               ULONG ccCharacterization )
{
    //
    // fGenerateCharacterization is obsolete.
    //

    if ( !fGenerateCharacterization )
        ccCharacterization = 0;

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    MachineAdmin.SetDWORDParam( wcsFilterFilesWithUnknownExtensions, fFilterUnknown );
    MachineAdmin.SetDWORDParam( wcsGenerateCharacterization, fGenerateCharacterization );
    MachineAdmin.SetDWORDParam( wcsMaxCharacterization, ccCharacterization );
}

void CCatalogs::GetTracking( BOOL  & fAutoAlias )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    DWORD dw;

    if ( !MachineAdmin.GetDWORDParam( wcsIsAutoAlias, dw ) )
        dw = CI_IS_AUTO_ALIAS_DEFAULT;

    fAutoAlias = (0 != dw);
}

void CCatalogs::SetTracking( BOOL  fAutoAlias )
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    MachineAdmin.SetDWORDParam( wcsIsAutoAlias, fAutoAlias );
}

void CCatalogs::Populate()
{
    if ( 0 != _aCatalog.Count() )
        return;

    //
    // Populate catalog array.
    //

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    XPtr<CCatalogEnum> xCatEnum( MachineAdmin.QueryCatalogEnum() );

    while ( 0 != xCatEnum->Next() )
    {
        TRY
        {
            XPtr<CCatalog> xCat(new CCatalog( *this, xCatEnum->Name() ));

            _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
            xCat.Acquire();
        }
        CATCH(CException, e)
        {
            ciaDebugOut((DEB_WARN,
                         "Unable to populate admin's display with catalog %ws on machine %ws\n",
                         xCatEnum->Name(), _xwcsMachine.Get() ));
        }
        END_CATCH
    }
}

// Differs from Populate in that this only adds newly added catalogs to the
// admin's catalog array.

void CCatalogs::PickupNewCatalogs()
{
    //
    // Populate catalog array. Add only newer catalogs
    //

    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    XPtr<CCatalogEnum> xCatEnum( MachineAdmin.QueryCatalogEnum() );

    while ( 0 != xCatEnum->Next() )
    {
        for (ULONG i = 0; i < _aCatalog.Count(); i++)
        {
            if ( 0 == _wcsicmp(xCatEnum->Name(), _aCatalog[i]->GetCat(TRUE)) )
                break;
        }

        // Have we found the catalog? If so, continue with the next one.
        if (i < _aCatalog.Count())
            continue;

        // We haven't found the catalog in the list. Add it.

        TRY
        {
            XPtr<CCatalog> xCat(new CCatalog( *this, xCatEnum->Name() ));

            _aCatalog.Add( xCat.GetPointer(), _aCatalog.Count() );
            xCat.Acquire();
        }
        CATCH(CException, e)
        {
            ciaDebugOut((DEB_WARN,
                         "Unable to populate admin's display with catalog %ws on machine %ws\n",
                         xCatEnum->Name(), _xwcsMachine.Get() ));
        }
        END_CATCH
    }
}

void CCatalogs::UpdateActiveState()
{
    CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

    // Enumerate all the catalogs and add new additions
    PickupNewCatalogs();

    // Identify what stays and what goes
    for (ULONG i = 0; i < _aCatalog.Count(); i++)
    {
        TRY
        {
            XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _aCatalog[i]->GetCat(TRUE) ) );
            _aCatalog[i]->SetInactive(xCatalogAdmin->IsCatalogInactive());
            if (!_aCatalog[i]->IsInactive() && !_aCatalog[i]->IsAddedToScope())
                AddCatalogToScope(_aCatalog[i]);
        }
        CATCH (CException, e)
        {
            // We have an exception attempting to access a catalog, it is either
            // deleted or has its registry messed up. Remove it from list of displayed scopes.
            RemoveCatalogFromScope(_aCatalog[i]);
            _aCatalog[i]->Zombify();
        }
        END_CATCH
    }

    // Cleanup...
    for ( i = 0; i < _aCatalog.Count(); i++ )
    {
        CCatalog * pCat = _aCatalog.Get( i );

        if ( pCat->IsZombie() )
        {
            _pScopePane->DeleteItem( pCat->ScopeHandle(), TRUE );

            //
            // Delete catalog and move highest entry down.
            //

            pCat = _aCatalog.Acquire( i );
            delete pCat;

            if ( _aCatalog.Count() > 0  && _aCatalog.Count() != i )
            {
                pCat = _aCatalog.Acquire( _aCatalog.Count() - 1 );
                _aCatalog.Add( pCat, i );
                i--;
            }

            continue;
        }

        if ( pCat->IsInactive() )
        {
            if ( pCat->IsAddedToScope() )
                RemoveCatalogFromScope(pCat);

            continue;
        }

        if ( pCat->IsAddedToScope() )
            continue;

        AddCatalogToScope(pCat);
    }
}


//
// Implementation of TuneServicePerformance
// wIndexingPos is on a scale of 1 to 3, where 1 is least aggressive
// and 3 is most aggressive. wQueryingPos is on the same scale.
//

SCODE CCatalogs::TuneServicePerformance()
{
    BOOL fServer = IsNTServer();
    SCODE sc = S_OK;

    // Ensure that these settings were made.
    Win4Assert(_wIndexingPos != -1 && _wQueryingPos != -1);

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.TunePerformance(fServer, _wIndexingPos, _wQueryingPos);
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to tune performance.",
                    sc, sc));
    }
    END_CATCH

    return sc;
}


void CCatalogs::SaveServicePerformanceSettings(WORD wIndexingPos, WORD wQueryingPos)
{
   _wIndexingPos = wIndexingPos;
   _wQueryingPos = wQueryingPos;
}


void  CCatalogs::GetServicePerformanceSettings(WORD &wIndexingPos, WORD &wQueryingPos)
{
   wIndexingPos = _wIndexingPos;
   wQueryingPos = _wQueryingPos;
}

SCODE CCatalogs::DisableService()
{
    SCODE sc = S_OK;

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        MachineAdmin.StopCI();

        sc = MachineAdmin.DisableCI() ? S_OK : E_FAIL;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to tune performance.",
                    sc, sc));
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::EnableService()
{
    SCODE sc = S_OK;

    TRY
    {
        CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

        if ( !MachineAdmin.IsCIEnabled() )
            sc = MachineAdmin.EnableCI() ? S_OK : E_FAIL;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut((DEB_WARN,
                    "Caught exception %d (0x%x) attempting to enable service",
                    sc, sc));
    }
    END_CATCH

    return sc;
}

SCODE CCatalogs::GetSavedServiceUsage(DWORD &dwUsage,
                                      DWORD &dwIdxPos,
                                      DWORD &dwQryPos)
{
   SCODE sc = S_OK;

   TRY
   {
       CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

       if (!MachineAdmin.GetDWORDParam(wcsServiceUsage, dwUsage))
       {
           // plug in a default value
           dwUsage = wUsedOften;
       }

       if (!MachineAdmin.GetDWORDParam(wcsDesiredIndexingPerf, dwIdxPos))
       {
           // plug in a default value
           dwIdxPos = wMidPos;
       }

       if (!MachineAdmin.GetDWORDParam(wcsDesiredQueryingPerf, dwQryPos))
       {
           // plug in a default value
           dwQryPos = wMidPos;
       }
   }
   CATCH( CException, e )
   {
       sc = e.GetErrorCode();
       ciDebugOut((DEB_WARN,
                   "Caught exception %d (0x%x) attempting to retrieve service usage.",
                   sc, sc));
   }
   END_CATCH

   return sc;
}

SCODE CCatalogs::SaveServiceUsage(DWORD dwUsage,
                                  DWORD dwIdxPos,
                                  DWORD dwQryPos)
{
   SCODE sc = S_OK;

   TRY
   {
       CMachineAdmin MachineAdmin( _xwcsMachine.Get() );

       MachineAdmin.SetDWORDParam(wcsServiceUsage, dwUsage);
       MachineAdmin.SetDWORDParam(wcsDesiredIndexingPerf, dwIdxPos);
       MachineAdmin.SetDWORDParam(wcsDesiredQueryingPerf, dwQryPos);
   }
   CATCH( CException, e )
   {
       sc = e.GetErrorCode();
       ciDebugOut((DEB_WARN,
                   "Caught exception %d (0x%x) attempting to save service usage.",
                   sc, sc));
   }
   END_CATCH

   return sc;
}

void CALLBACK DisplayTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CLock lock(gmtxTimer);

    // seek the index of the catalog associated with this timer event
    for (UINT i = 0; i < gcMaxCats; i++)
        if (gaTimerIds[i] == idEvent)
            break;

    if (i >= gcMaxCats)
    {
        Win4Assert(!"How did this happen?");
        return;
    }

    // Fix for bug 150471
    // If the snapin went away just as the timer triggered a timer proc,
    // and the destructor in CCatalogs gets to the lock before this
    // function, then gapCats[i] will be 0. That is what happened in
    CCatalogs *pCats = gapCats[i];

    if (0 == pCats || pCats->_fAbort)
        return;

    // Cause display
    pCats->Display( FALSE );

    // Special case: Update the status of the iconbar. This is only needed for
    // the case where the service was started. Service startup could take a while,
    // and we don't know how long it could take. So we cannot wait to update the
    // display when the service is actually started. Instead, we will check frequently
    // and update the status.



    TRY
    {
        CMachineAdmin   MachineAdmin( pCats->IsLocalMachine() ? 0 : pCats->GetMachine() );

        if ( MachineAdmin.IsCIStarted() && 0 != pCats->SnapinData() )
        {
            pCats->SnapinData()->SetButtonState(comidStartCITop, ENABLED, FALSE);
            pCats->SnapinData()->SetButtonState(comidStopCITop,  ENABLED, TRUE);
            pCats->SnapinData()->SetButtonState(comidPauseCITop, ENABLED, TRUE);

            // We only want to update once after the service has started. If the service
            // is stopped and restarted, the pointer will be set to an appropriate value
            // at a later time, so we can go ahead and get rid of the snapindata ptr for now.

            pCats->SetSnapinData( 0 );
        }
    }
    CATCH(CException, e)
    {
        // Nothing specific to do in this case
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\classfac.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       ClassFac.cxx
//
//  Contents:   Class factory for admin COM object
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <classfac.hxx>
#include <snapin.hxx>

//
// Global variables
//

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::CCIAdminCF
//
//  Synopsis:   CI MMC snap-in class factory constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminCF::CCIAdminCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::~CCIAdminCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    26-Nov-1996     KyleP   Created
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CCIAdminCF::~CCIAdminCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCIAdminCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::CreateInstance
//
//  Synopsis:   Creates new snapin data object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    IUnknown * pIUnk = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        pIUnk = (IUnknown *)(IComponent *)new CCISnapinData();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;

        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCIAdminCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCIAdminCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        if ( guidCISnapin == cid )
            pResult = (IUnknown *)new CCIAdminCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
    }
    CATCH(CException, e)
    {
        if ( pResult )
            pResult->Release();

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\isreg.cxx: ..\query\isreg.cxx
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\propsht.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       Propsht.cxx
//
//  Contents:   Property sheets for for CI snapin.
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cimbmgr.hxx>
#include <strres.hxx>

#include <ciares.h>
#include <propsht.hxx>

#include <catalog.hxx>
#include <prop.hxx>
#include <strings.hxx>

//
// Local prototypes
//

void InitVTList( HWND hwndCombo );
void InitVSList( HWND hwndComboVS, HWND hwndComboNNTP, CCatalog const & cat,
                 ULONG & cVServers, ULONG & cNNTPServers );
void InitStorageLevelList( HWND hwndCombo );
void DisplayError( HWND hwnd, CException & e );
BOOL GetDlgItemXArrayText( HWND hwndDlg, USHORT idCtrl, XArray<WCHAR> & xawcText );
DWORD VSToIndex( HWND hwndDlg, DWORD dwItem, ULONG ulVS, BOOL fTrack );
UINT DBTypeToVT(UINT uidbt);

CIndexSrvPropertySheet0::CIndexSrvPropertySheet0( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCats( pCats ),
          _fFirstActive( TRUE ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE0);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE0_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet0::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet0::~CIndexSrvPropertySheet0()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet0::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet0::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet0 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            //
            // Default to local machine.
            //

            CheckRadioButton( hwndDlg,
                              IDDI_LOCAL_COMPUTER,
                              IDDI_REMOTE_COMPUTER,
                              IDDI_LOCAL_COMPUTER );

            EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
            case IDDI_LOCAL_COMPUTER:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );
                    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    fRet = TRUE;
                }
                break;
            }

            case IDDI_REMOTE_COMPUTER:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), TRUE );

                    //
                    // If we have a string, then enable finish button.
                    //

                    XArray<WCHAR> xawcTemp;

                    if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcTemp ) &&
                         xawcTemp.Count() > 0 )
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_DISABLEDFINISH );
                    }

                    fRet = TRUE;
                }
                break;
            }

            case IDDI_COMPNAME:
            {
                if ( EN_CHANGE == HIWORD(wParam) )
                {
                    //
                    // If we have a string, then enable finish button.
                    //

                    XArray<WCHAR> xawcTemp;

                    if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcTemp ) &&
                         xawcTemp.Count() > 0 )
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_DISABLEDFINISH );
                    }

                    fRet = TRUE;
                }
                break;
            }

            /* Help is not being used...
            case IDHELP:
            {
                DisplayHelp( hwndDlg, HIDD_CONNECT_TO_COMPUTER );
                break;
            }
            */

            } // switch
            break;
        }

        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet0 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_NOTIFY:
        {
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_KILLACTIVE:
            {
                // Allow loss of activation
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, FALSE );

                fRet = TRUE;
                break;
            }

            case PSN_SETACTIVE:
            {
                if ( pthis->_fFirstActive )
                {
                    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );

                    pthis->_fFirstActive = FALSE;
                }
                else
                {
                    // Go to next page
                    SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1 );
                }

                fRet = TRUE;
                break;
            }

            case PSN_WIZBACK:
            {
                // Allow previous page
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR );

                fRet = TRUE;
                break;
            }

            case PSN_WIZNEXT:
            {
                // Allow next page
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR );

                fRet = TRUE;
                break;
            }

            case PSN_WIZFINISH:
            {
                TRY
                {
                    XArray<WCHAR> xawcCompName;

                    if ( IsDlgButtonChecked( hwndDlg, IDDI_LOCAL_COMPUTER ) )
                        pthis->_pCats->SetMachine( L"." );
                    else
                    {
                        if ( GetDlgItemXArrayText( hwndDlg, IDDI_COMPNAME, xawcCompName ) )
                        {
                            pthis->_pCats->SetMachine( xawcCompName.GetPointer() );
                        }
                    }

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    // The only error caught here is a result of an invalid
                    // machine name.

                    Win4Assert(e.GetErrorCode() == E_INVALIDARG);

                    MessageBox( hwndDlg,
                                STRINGRESOURCE( srInvalidComputerName ),
                                STRINGRESOURCE( srIndexServerCmpManage ),
                                MB_OK | MB_ICONINFORMATION );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet0 * pthis = (CIndexSrvPropertySheet0 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet0: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CIndexSrvPropertySheet1::CIndexSrvPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalog * pCat )
        : _pCat( pCat ),
          _pCats( 0 ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet1::CIndexSrvPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCat( 0 ),
          _pCats( pCats ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet1::~CIndexSrvPropertySheet1()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet1::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet1 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet1::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet1 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            BOOL  fUnknown;
            BOOL  fGenerateCharacterization;
            ULONG ccCharacterization;

            if ( pthis->IsTrackingCatalog() )
            {
                pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                // Look in the registry for Group1 params. If at least one of them is listed
                // we should uncheck the "Inherit" checkbox. Otherwise
                // (if none of them is listed), we should check the box.

                SendDlgItemMessage( hwndDlg, 
                                    IDDI_INHERIT1,
                                    BM_SETCHECK,
                                    pthis->_pCat->DoGroup1SettingsExist() ? BST_UNCHECKED : BST_CHECKED,
                                    0 );

                // If at least one setting exists, add the others in the group.
                // We don't want to have an incomplete set.
                if (pthis->_pCat->DoGroup1SettingsExist())
                   pthis->_pCat->FillGroup1Settings();
            }
            else
            {
                // Hide the "Inherit" checkbox because it is not applicable here
                ShowWindow(GetDlgItem(hwndDlg, IDDI_INHERIT1), SW_HIDE);

                pthis->_pCats->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );
            }

            SendDlgItemMessage( hwndDlg,
                                IDDI_FILTER_UNKNOWN,
                                BM_SETCHECK,
                                fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            SendDlgItemMessage( hwndDlg,
                                IDDI_CHARACTERIZATION,
                                BM_SETCHECK,
                                fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            WCHAR wcsSize[120];

            _ultow( ccCharacterization, wcsSize, 10 );
            SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize );

            SendDlgItemMessage( hwndDlg,
                                IDDI_SPIN_CHARACTERIZATION,
                                UDM_SETRANGE,
                                0,
                                (LPARAM) MAKELONG( 10000, 10) );

            // If the generate characterization checkbox is unchecked, we should disable the
            // characterization size controls
            if (!fGenerateCharacterization)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), FALSE);
            }

            // If we are inheriting, we should disable the local setting.
            if ( pthis->IsTrackingCatalog() && !pthis->_pCat->DoGroup1SettingsExist())
            {
                EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), FALSE);
            }

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;
            BOOL fCorrected = TRUE;

            switch ( LOWORD( wParam ) )
            {

               case IDDI_CHARACTERIZATION:
                  if (BN_CLICKED == HIWORD(wParam))
                  {
                      BOOL fGenChar = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, 
                                                                           IDDI_CHARACTERIZATION, 
                                                                           BM_GETCHECK, 0, 0 ) );
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), fGenChar);
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), fGenChar);
                      EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), fGenChar);

                      if( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                  }
                  break;

               case IDDI_FILTER_UNKNOWN:
               {
                   if ( BN_CLICKED == HIWORD(wParam) )
                       fChanged = TRUE;

                   // Fall through
               }
               case IDDI_CHARACTERIZATION_SIZE:
               {
                   if ( EN_KILLFOCUS == HIWORD(wParam) && LOWORD( wParam ) == IDDI_CHARACTERIZATION_SIZE )
                   {
                       fRet = TRUE;
                       ULONG ulVal = 10;
   
                       // Validate the number
                       XArray<WCHAR> xawcTemp;
   
                       if ( (LOWORD(wParam) == IDDI_CHARACTERIZATION_SIZE) &&
                             GetDlgItemXArrayText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, xawcTemp ) &&
                             xawcTemp.Count() > 0 )
                       {
                           // verify that all characters are digits
                           ULONG ulLen = wcslen(xawcTemp.GetPointer());
                           // When correcting, let's do our best
                           ulVal = _wtoi(xawcTemp.GetPointer());
                           for (ULONG i = 0; i < ulLen; i++)
                           {
                               if (!iswdigit(xawcTemp[i]))
                                   break;
                           }
                           if (i == ulLen)
                           {
                               // verify that the number is within range
                               ulVal = _wtoi(xawcTemp.GetPointer());
                               if (ulVal <= 10000 && ulVal >= 10)
                               {
                                   fCorrected = FALSE;
                               }
                               else
                                   ulVal = (ulVal < 10) ? 10 : 10000;
                           }
                       }
   
                       if (fCorrected)
                       {
                           WCHAR wszBuff[20];   // use this instead of a potentially empty xawcTemp

                           ciaDebugOut((DEB_ITRACE, "%ws is NOT a valid number\n", xawcTemp.GetPointer()));
                           MessageBeep(MB_ICONHAND);
                           SetWindowText((HWND)lParam, _itow(ulVal, wszBuff, 10));
                           SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                       }
                   }
                   else if ( EN_CHANGE == HIWORD(wParam) && ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER )) )
                   {
                       fChanged = TRUE;
                       fRet = TRUE;
                   }
   
                   break;
               }

               case IDDI_INHERIT1:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                      if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                      {
                          fChanged = TRUE;
                          fRet = TRUE;

                          // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                          // settings so the values will be inherited from the service.
                             
                          BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT1, BM_GETCHECK, 0, 0 ) );
                          BOOL fUnknown = FALSE, fGenerateCharacterization = FALSE;
                          DWORD ccCharacterization = 0;
       
                          CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );
                          
                          if (fInherit)
                          {
                             Win4Assert(pthis->IsTrackingCatalog());
                             pthis->_pCat->GetParent().GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );
                          }
                          else
                          {
                              pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                              // Enable so we can set controls
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), TRUE);
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), TRUE);
                          }
       
                          SendDlgItemMessage( hwndDlg,
                                              IDDI_FILTER_UNKNOWN,
                                              BM_SETCHECK,
                                              fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                              0 );
                          SendDlgItemMessage( hwndDlg,
                                              IDDI_CHARACTERIZATION,
                                              BM_SETCHECK,
                                              fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                              0 );

                          WCHAR wcsSize[12];
                          _ultow( ccCharacterization, wcsSize, 10 );
                          SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize );


                          // Enable/Disable controls if we need to
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), !fInherit);
                           EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), !fInherit);
                      }
                   }
               }
            } // switch

            if ( fChanged )
                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );

            break;
        } // case

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    BOOL  fUnknown = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_FILTER_UNKNOWN, BM_GETSTATE, 0, 0 ) );
                    BOOL  fGenerateCharacterization = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_CHARACTERIZATION, BM_GETSTATE, 0, 0 ) );

                    WCHAR wcsSize[12];
                    GetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize, sizeof(wcsSize)/sizeof(WCHAR) );
                    ULONG ccCharacterization = wcstoul( wcsSize, 0, 10 );

                    if ( pthis->IsTrackingCatalog() )
                    {

                        // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                        // settings so the values will be inherited from the service.
                        BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT1, BM_GETSTATE, 0, 0 ) );
                        if (fInherit)
                            pthis->_pCat->DeleteGroup1Settings();
                        else
                            pthis->_pCat->SetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                        // Set the values and enable or disable the local controls as appropriate
                        pthis->_pCat->GetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                        SendDlgItemMessage( hwndDlg,
                                            IDDI_FILTER_UNKNOWN,
                                            BM_SETCHECK,
                                            fUnknown ? BST_CHECKED : BST_UNCHECKED,
                                            0 );
                        SendDlgItemMessage( hwndDlg,
                                            IDDI_CHARACTERIZATION,
                                            BM_SETCHECK,
                                            fGenerateCharacterization ? BST_CHECKED : BST_UNCHECKED,
                                            0 );

                        WCHAR wcsSize[12];
                        _ultow( ccCharacterization, wcsSize, 10 );
                        SetDlgItemText( hwndDlg, IDDI_CHARACTERIZATION_SIZE, wcsSize);

                        EnableWindow(GetDlgItem(hwndDlg, IDDI_FILTER_UNKNOWN), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_CHARACTERIZATION_SIZE), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_SPIN_CHARACTERIZATION), !fInherit);
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_STATIC2), !fInherit);
                    }
                    else
                        pthis->_pCats->SetGeneration( fUnknown, fGenerateCharacterization, ccCharacterization );

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet1 * pthis = (CIndexSrvPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet1: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CCatalogBasicPropertySheet::CCatalogBasicPropertySheet( HINSTANCE hInstance,
                                                        LONG_PTR hMmcNotify,
                                                        CCatalog const * pCat )
        : _pCat( pCat ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CCatalogBasicPropertySheet::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CCatalogBasicPropertySheet::~CCatalogBasicPropertySheet()
{
}

INT_PTR APIENTRY CCatalogBasicPropertySheet::DlgProc( HWND hwndDlg,
                                                      UINT message,
                                                      WPARAM wParam,
                                                      LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE,
                          "CCatalogBasicPropertySheet::DlgProc -- WM_HELP: wp 0x%x, lp 0x%x\n",
                          wParam, lParam ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CCatalogBasicPropertySheet::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CCatalogBasicPropertySheet *)lParam)->_PropSheet.lParam;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            CCatalog const * pCat = ((CCatalogBasicPropertySheet *)lParam)->_pCat;

            SetDlgItemText( hwndDlg, IDDI_CATNAME, pCat->GetCat( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_SIZE, pCat->GetSize( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_PATH, pCat->GetDrive( TRUE ) );
            SetDlgItemText( hwndDlg, IDDI_PROPCACHE_SIZE, pCat->GetPropCacheSize( TRUE ) );

            fRet = TRUE;
            break;
        }

        case WM_DESTROY:
        {
            CCatalogBasicPropertySheet * pthis = (CCatalogBasicPropertySheet *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCatalogBasicPropertySheet: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CIndexSrvPropertySheet2::CIndexSrvPropertySheet2( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalog * pCat )
        : _pCat( pCat ),
          _pCats( 0 ),
          _hMmcNotify( hMmcNotify ),
          _fNNTPServer( FALSE ),
          _fWebServer( FALSE )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE2);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE2_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet2::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet2::CIndexSrvPropertySheet2( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCatalogs * pCats )
        : _pCat( 0 ),
          _pCats( pCats ),
          _hMmcNotify( hMmcNotify )
{
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_CATALOG_PAGE2);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_CATALOG_PAGE2_TITLE);
    _PropSheet.pfnDlgProc  = CIndexSrvPropertySheet2::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CIndexSrvPropertySheet2::~CIndexSrvPropertySheet2()
{
}

INT_PTR APIENTRY CIndexSrvPropertySheet2::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet2 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }

            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CIndexSrvPropertySheet2::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CIndexSrvPropertySheet2 *)lParam)->_PropSheet.lParam;
            CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)lthis;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            BOOL  fAutoAlias;
            BOOL  fVirtualRoots;
            BOOL  fNNTPRoots;
            ULONG iVirtualServer;
            ULONG iNNTPServer;


            // It is important to initialize the counters here to guarantee that
            // they will remain 0 if we don't get to invoke the enumerators that
            // count the number of servers.
            ULONG cVServers = 0, cNNTPServers = 0;

            ShowWindow(GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_SERVER), FALSE);

            ShowWindow(GetDlgItem(hwndDlg, IDDI_VSERVER_STATIC), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_STATIC), FALSE);

            if ( 0 != pthis->_pCat )
            {
                if ( AreServersAvailable( *(pthis->_pCat) ) )
                {
                    pthis->_pCat->GetWeb( fVirtualRoots,
                                          fNNTPRoots,
                                          iVirtualServer,
                                          iNNTPServer );

                    InitVSList( GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER),
                                GetDlgItem(hwndDlg, IDDI_NNTP_SERVER),
                                *(pthis->_pCat),
                                cVServers,
                                cNNTPServers );
                }

                pthis->_pCat->GetTracking( fAutoAlias );

                // Look in the registry for Group2 params. If at least one of them is listed
                // we should uncheck the "Inherit" checkbox. Otherwise
                // (if none of them is listed), we should check the box.
                SendDlgItemMessage( hwndDlg, 
                                    IDDI_INHERIT2,
                                    BM_SETCHECK,
                                    pthis->_pCat->DoGroup2SettingsExist() ? BST_UNCHECKED : BST_CHECKED,
                                    0 );

                // If all the settings don't exist, then delete the others in the group.
                // We don't want to have part of the group inherited and part local.
                if (pthis->_pCat->DoGroup2SettingsExist())
                    pthis->_pCat->FillGroup2Settings();
            }
            else
            {
                // Hide the "Inherit" checkbox because it is not applicable here
                ShowWindow(GetDlgItem(hwndDlg, IDDI_INHERIT2), SW_HIDE);

                pthis->_pCats->GetTracking( fAutoAlias );
            }

            if (cVServers)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDDI_VIRTUAL_SERVER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDDI_VSERVER_STATIC), TRUE);
                pthis->_fWebServer = TRUE;
                SendDlgItemMessage( hwndDlg,
                                    IDDI_VIRTUAL_SERVER,
                                    CB_SETCURSEL,
                                    VSToIndex( hwndDlg, IDDI_VIRTUAL_SERVER,
                                               iVirtualServer, fVirtualRoots ), 0 );
            }

            if (cNNTPServers)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_SERVER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDDI_NNTP_STATIC), TRUE);
                pthis->_fNNTPServer = TRUE;
                SendDlgItemMessage( hwndDlg,
                                    IDDI_NNTP_SERVER,
                                    CB_SETCURSEL,
                                    VSToIndex( hwndDlg, IDDI_NNTP_SERVER,
                                               iNNTPServer, fNNTPRoots ), 0 );
            }

            SendDlgItemMessage( hwndDlg,
                                IDDI_AUTO_ALIAS,
                                BM_SETCHECK,
                                fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                0 );

            // If we are inheriting, we should disable the local setting.
            if ( 0 != pthis->_pCat && !pthis->_pCat->DoGroup2SettingsExist())
                EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), FALSE);

            fRet = TRUE;

            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;

            switch ( LOWORD( wParam ) )
            {
               case IDDI_VIRTUAL_SERVER:
               case IDDI_NNTP_SERVER:
               {
                   if ( CBN_SELCHANGE == HIWORD(wParam) )
                   {
                       if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                   }
   
                   break;
               }
   
               case IDDI_AUTO_ALIAS:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                       if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                       {
                           fChanged = TRUE;
                           fRet = TRUE;
                       }
                   }
   
                   break;
               }

               case IDDI_INHERIT2:
               {
                   if ( EN_CHANGE == HIWORD(wParam) || BN_CLICKED == HIWORD(wParam) )
                   {
                      if ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER ) )
                      {
                          fChanged = TRUE;
                          fRet = TRUE;

                          BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT2, BM_GETCHECK, 0, 0 ) );
                          BOOL fAutoAlias = FALSE;

                          CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                          if (fInherit)
                          {
                              Win4Assert(pthis->IsTrackingCatalog());
                              pthis->_pCat->GetParent().GetTracking(fAutoAlias);
                          }
                          else
                          {
                              pthis->_pCat->GetTracking(fAutoAlias);

                              // Enable so we can set controls
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), TRUE);
                          }

                          SendDlgItemMessage( hwndDlg,
                                              IDDI_AUTO_ALIAS,
                                              BM_SETCHECK,
                                              fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                              0 );

                          // Disable controls if we need to
                          if (fInherit)
                              EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), FALSE);
                      }
                   }
               }

            } // switch

            if ( fChanged )
                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );

            break;
        }

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    BOOL  fAutoAlias = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_AUTO_ALIAS, BM_GETSTATE, 0, 0 ) );

                    if ( 0 != pthis->_pCat )
                    {
                        BOOL fVirtualRoots = FALSE;
                        ULONG iVirtualServer = 0;

                        if ( pthis->_fWebServer )
                        {
                            iVirtualServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_VIRTUAL_SERVER, CB_GETCURSEL, 0, 0 );
                            fVirtualRoots = ( 0 != iVirtualServer );
                            iVirtualServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_VIRTUAL_SERVER, CB_GETITEMDATA, iVirtualServer, 0 );
                        }

                        BOOL fNNTPRoots = FALSE;
                        ULONG iNNTPServer = 0;

                        if ( pthis->_fNNTPServer )
                        {
                            iNNTPServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_NNTP_SERVER, CB_GETCURSEL, 0, 0 );
                            fNNTPRoots = ( 0 != iNNTPServer );
                            iNNTPServer = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_NNTP_SERVER, CB_GETITEMDATA, iNNTPServer, 0 );
                        }

                        pthis->_pCat->SetWeb( fVirtualRoots, fNNTPRoots, iVirtualServer, iNNTPServer );

                        // If the Inherit Settings button is checked, we should remove the registry entries from the catalog's
                        // settings so the values will be inherited from the service.
                        BOOL fInherit = ( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDDI_INHERIT2, BM_GETSTATE, 0, 0 ) );
                        if (fInherit)
                            pthis->_pCat->DeleteGroup2Settings();
                        else
                            pthis->_pCat->SetTracking( fAutoAlias );

                        // Set the current values and set state of the local controls
                        BOOL fAutoAlias;

                        pthis->_pCat->GetTracking( fAutoAlias );
                        SendDlgItemMessage( hwndDlg,
                                            IDDI_AUTO_ALIAS,
                                            BM_SETCHECK,
                                            fAutoAlias ? BST_CHECKED : BST_UNCHECKED,
                                            0 );
                        EnableWindow(GetDlgItem(hwndDlg, IDDI_AUTO_ALIAS), !fInherit);
                    }
                    else
                        pthis->_pCats->SetTracking( fAutoAlias );

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                    fRet = TRUE;
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CIndexSrvPropertySheet2 * pthis = (CIndexSrvPropertySheet2 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            //
            // Only gets called on *one* property page!
            //

            // MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }
        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CIndexSrvPropertySheet2: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

CPropertyPropertySheet1::CPropertyPropertySheet1( HINSTANCE hInstance,
                                                  LONG_PTR hMmcNotify,
                                                  CCachedProperty * pProperty,
                                                  CCatalog * pCat )
        : _pProperty( pProperty ),
          _propNew( *pProperty ),
          _hMmcNotify( hMmcNotify ),
          _pCat( pCat )
{
    _PropSheet.dwSize    = sizeof( _PropSheet ) + sizeof( this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_PROPERTY_PAGE1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_PROPERTY_PAGE1_TITLE);
    _PropSheet.pfnDlgProc  = CPropertyPropertySheet1::DlgProc;
    _PropSheet.lParam = (LPARAM)this;

    _hPropSheet = CreatePropertySheetPage( &_PropSheet );
}

CPropertyPropertySheet1::~CPropertyPropertySheet1()
{
}

INT_PTR APIENTRY CPropertyPropertySheet1::DlgProc( HWND hwndDlg,
                                                   UINT message,
                                                   WPARAM wParam,
                                                   LPARAM lParam )
{
    BOOL fRet = FALSE;

    TRY
    {
        switch ( message )
        {
        case WM_HELP:
        {
            HELPINFO *phi = (HELPINFO *) lParam;

            ciaDebugOut(( DEB_ITRACE,
                          "CPropertyPropertySheet1 WM_HELP contexttype: '%s', ctlid: %d, contextid: %d\n",
                          phi->iContextType == HELPINFO_MENUITEM ? "menu" : "window",
                          phi->iCtrlId, phi->dwContextId ));

            if ( HELPINFO_WINDOW == phi->iContextType )
            {
                switch ( phi->iCtrlId )
                {
                    case IDDI_STATIC:
                        break;

                    default :
                        DisplayPopupHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);
                        break;
                }
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DisplayPopupHelp((HWND)wParam, HELP_CONTEXTMENU);
            break;
        }

        case WM_INITDIALOG:
        {
            ciaDebugOut(( DEB_ITRACE, "CPropertyPropertySheet1::DlgProc -- WM_INITDIALOG\n" ));

            LONG_PTR lthis = ((CPropertyPropertySheet1 *)lParam)->_PropSheet.lParam;

            SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

            CCachedProperty const & prop = ((CPropertyPropertySheet1 *)lthis)->_propNew;

            SetDlgItemText( hwndDlg, IDDI_PROPSET, prop.GetPropSet() );
            SetDlgItemText( hwndDlg, IDDI_PROPERTY, prop.GetProperty() );

            SendDlgItemMessage( hwndDlg,
                                IDDI_SPIN_CACHEDSIZE,
                                UDM_SETRANGE,
                                0,
                                (LPARAM) MAKELONG( 500, 4) );


            InitVTList( GetDlgItem(hwndDlg, IDDI_DATATYPE) );
            InitStorageLevelList( GetDlgItem(hwndDlg, IDDI_STORAGELEVEL) );

            if ( prop.IsCached() )
            {
                SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_SETCHECK, BST_CHECKED, 0 );
                SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_SETCURSEL, aulTypeIndex[ prop.GetVT() & ~VT_VECTOR ], 0 );
                // StoreLevel() is 0 for primary, 1 for secondary, which is the sequence in which we added them.
                // So using StoreLevel() as in index will work fine!
                SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL, prop.StoreLevel(), 0 );
                SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, prop.GetAllocation() );

                // Currently we do not allow the storage level to be changed after initial setting
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
            }
            else
            {
                SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_SETCHECK, BST_UNCHECKED, 0 );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), FALSE );
            }

            // If properties cannot be modified, disable all controls
            // Only cached properties can be resitant to modifications!
            if (!prop.IsModifiable() && prop.IsCached())
            {
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHED), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), FALSE );
            }

            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;
            BOOL fCorrected = TRUE;

            switch ( LOWORD( wParam ) )
            {
            case IDDI_DATATYPE:
            {
                if ( CBN_CLOSEUP == HIWORD(wParam) )
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    fChanged = pthis->Refresh( hwndDlg, TRUE );

                    if ( pthis->_propNew.IsFixed() )
                    {
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, pthis->_propNew.GetAllocation() );
                        // Disable the size control
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                    }
                    else
                    {
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, L"4" );
                        // Enable the size control. Variable props can be resized.
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), TRUE );
                    }

                    fRet = TRUE;
                }

                break;
            }


            case IDDI_STORAGELEVEL:
            {
                CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                if ( CBN_CLOSEUP == HIWORD(wParam) )
                {
                    fChanged = pthis->Refresh( hwndDlg, TRUE );
                    fRet = TRUE;
                }

                break;
            }

            case IDDI_CACHEDSIZE:
            {
               if ( EN_KILLFOCUS == HIWORD(wParam) )
               {
                   fRet = TRUE;
                   ULONG ulVal = 4;

                   // Validate the number
                   XArray<WCHAR> xawcTemp;

                   if ( GetDlgItemXArrayText( hwndDlg, IDDI_CACHEDSIZE, xawcTemp ) &&
                            xawcTemp.Count() > 0 )
                   {
                       // verify that all characters are digits
                       ULONG ulLen = wcslen(xawcTemp.GetPointer());
                       // When correcting, let's do our best.
                       ulVal = _wtoi(xawcTemp.GetPointer());
                       for (ULONG i = 0; i < ulLen; i++)
                       {
                           if (!iswdigit(xawcTemp[i]))
                               break;
                       }
                       if (i == ulLen)
                       {
                           // verify that the number is within range
                           ulVal = _wtoi(xawcTemp.GetPointer());

                           ciaDebugOut((DEB_ERROR, "number is %d, string is %ws\n", 
                                        ulVal, xawcTemp.GetPointer()));

                           if (ulVal <= 500)
                               fCorrected = FALSE;
                           else if (ulVal > 500)
                               ulVal = 500;
                       }
                   }

                   // if we are dealing with a vble property, we should ensure that the
                   // size is at least 4 bytes
                   
                   if (ulVal < 4)
                   {
                      CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );
  
                      if ( 0 != pthis )
                      {
                          if (pthis->_propNew.IsCached() && !pthis->_propNew.IsFixed())
                          {
                              ulVal = 4;
                              fCorrected = TRUE;
                          }
                      }
                   }

                   if (fCorrected)
                   {
                       MessageBeep(MB_ICONHAND);
                       // xawcTemp may not have a buffer, so don't use it for _itow. Use a temp vble
                       WCHAR wszBuff[20]; 
                       SetWindowText((HWND)lParam, _itow(ulVal, wszBuff, 10));
                       SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                   }
               }
               else if ( EN_CHANGE == HIWORD(wParam) && ( 0 != GetWindowLongPtr( hwndDlg, DWLP_USER )) )
               {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    if ( 0 != pthis )
                    {
                        fChanged = pthis->Refresh( hwndDlg, FALSE );
                        fRet = TRUE;
                    }
               }

               break;
            }

            case IDDI_CACHED:
            {
                if ( BN_CLICKED == HIWORD(wParam) )
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    ULONG fChecked = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_CACHED, BM_GETSTATE, 0, 0 );

                    if ( fChecked & BST_CHECKED )
                    {
                        pthis->Refresh( hwndDlg, FALSE );

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), TRUE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), TRUE );

                        // If this property is currently being cached in the property store (as indicated
                        // by CCachedProperty), we do not let it's store level be changed. This ensures
                        // that a user cannot change a property between store levels.

                        if (pthis->_propNew.IsCached() && INVALID_STORE_LEVEL != pthis->_propNew.StoreLevel())
                        {
                            SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL,
                                                pthis->_propNew.StoreLevel(), 0 );
                            EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                        }
                        else
                        {
                            // enable and display the storage level. Default to secondary,
                            // if none is available

                            if (PRIMARY_STORE != pthis->_propNew.StoreLevel())
                                pthis->_propNew.SetStoreLevel(SECONDARY_STORE);

                            SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_SETCURSEL,
                                                pthis->_propNew.StoreLevel(), 0 );
                            EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), TRUE );
                        }

                        // if no item is currently selected, set lpwstr by default
                        if (VT_EMPTY == pthis->_propNew.GetVT() || 0 == pthis->_propNew.Allocation())
                        {
                            UINT uiType = DBTypeToVT(pthis->_propNew.GetDefaultType());
                            if (uiType != VT_EMPTY)
                            {
                                ciaDebugOut((DEB_ITRACE, "DIALOG: %ws has type %d (==> %d)\n", 
                                             pthis->_propNew.GetFName(), pthis->_propNew.GetDefaultType(), 
                                             DBTypeToVT(pthis->_propNew.GetDefaultType())));
                                pthis->_propNew.SetVT( uiType );
                                pthis->_propNew.SetAllocation( pthis->_propNew.GetDefaultSize() );
                            }
                            else
                            {
                                // default datatype should be LPWSTR
                                pthis->_propNew.SetVT( VT_LPWSTR );
                                pthis->_propNew.SetAllocation( 4 );
                            }
                        }

                        // Assert that the property is now marked cached
                        Win4Assert( pthis->_propNew.IsCached() );

                        // now display it
                        SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_SETCURSEL,
                                            aulTypeIndex[ pthis->_propNew.GetVT() & ~VT_VECTOR ], 0 );
                        SetDlgItemText( hwndDlg, IDDI_CACHEDSIZE, pthis->_propNew.GetAllocation() );


                        // in case OK was disabled, enable it
                        EnableWindow( GetDlgItem( GetParent(hwndDlg), IDOK), TRUE );
                    }
                    else
                    {
                        pthis->_propNew.SetVT( VT_EMPTY );
                        pthis->_propNew.SetAllocation( 0 );
                        // IMPORTANT: Don't set storage level to invalid. We need to
                        //            know where to delete this from!
                        //pthis->_propNew.SetStoreLevel(INVALID_STORE_LEVEL);

                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DATATYPE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_STORAGELEVEL), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_CACHEDSIZE ), FALSE );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_SPIN_CACHEDSIZE ), FALSE );
                    }

                    fChanged = TRUE;
                    fRet = TRUE;
                }
                break;
            }

            } // switch

            if ( fChanged )
            {
                CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                PropSheet_Changed( GetParent(hwndDlg), hwndDlg );
            }

            break;
        }

        case WM_NOTIFY:
        {
            switch ( ((LPNMHDR) lParam)->code )
            {
            case PSN_APPLY:
            {
                TRY
                {
                    CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

                    *pthis->_pProperty = pthis->_propNew;
                    pthis->_pProperty->MakeUnappliedChange();
                    pthis->_pCat->UpdateCachedProperty(pthis->_pProperty);

                    MMCPropertyChangeNotify( pthis->_hMmcNotify, (LONG_PTR)pthis->_pProperty );

                    MessageBox( hwndDlg,
                                STRINGRESOURCE( srPendingProps ),
                                STRINGRESOURCE( srPendingPropsTitle ),
                                MB_OK | MB_ICONINFORMATION );

                    fRet = TRUE;

                    ciaDebugOut((DEB_ITRACE, "VarType is %d, Allocation size is %d, Store level is %d\n",
                                 pthis->_pProperty->GetVT(), pthis->_pProperty->Allocation(), 
                                 pthis->_pProperty->StoreLevel() ));
                }
                CATCH( CException, e )
                {
                    DisplayError( hwndDlg, e );
                }
                END_CATCH

                break;
            }

            } // switch

            break;
        }

        case WM_DESTROY:
        {
            CPropertyPropertySheet1 * pthis = (CPropertyPropertySheet1 *)GetWindowLongPtr( hwndDlg, DWLP_USER );

            MMCFreeNotifyHandle( pthis->_hMmcNotify );

            delete pthis;

            fRet = TRUE;
            break;
        }

        default:
            fRet = FALSE;
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CPropertyPropertySheet1: Caught 0x%x\n", e.GetErrorCode() ));
        fRet = FALSE;
    }
    END_CATCH

    return fRet;
}

BOOL CPropertyPropertySheet1::Refresh( HWND hwndDlg, BOOL fVTOnly )
{
    BOOL fChanged = FALSE;

    DWORD dwIndex = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_GETCURSEL, 0, 0 );
    ULONG vt = (ULONG)SendDlgItemMessage( hwndDlg, IDDI_DATATYPE, CB_GETITEMDATA, dwIndex, 0 );

    if ( vt != _propNew.GetVT() )
        fChanged = TRUE;

    _propNew.SetVT( vt );

    dwIndex = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_GETCURSEL, 0, 0 );
    DWORD dwStoreLevel = (DWORD)SendDlgItemMessage( hwndDlg, IDDI_STORAGELEVEL, CB_GETITEMDATA, dwIndex, 0 );

    if ( dwStoreLevel != _propNew.StoreLevel() )
        fChanged = TRUE;

    _propNew.SetStoreLevel( dwStoreLevel );

    if ( !fVTOnly )
    {
        XArray<WCHAR> xawcSize;

        if ( GetDlgItemXArrayText( hwndDlg, IDDI_CACHEDSIZE, xawcSize ) && xawcSize.Count() > 0)
        {
            ULONG cb = wcstoul( xawcSize.Get(), 0, 10 );

            if ( cb != _propNew.Allocation() )
                fChanged = TRUE;

            _propNew.SetAllocation( cb );
        }
    }

    return fChanged;
}

void InitVTList( HWND hwndCombo )
{
    DWORD dwIndex;

    //
    // Add an item for each type group.
    //

    int j = 0;

    for ( int i = 0; i < cType; i++ )
    {
        if ( 0 != awcsType[i] )
        {
            dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)awcsType[i] );
            SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, i );
            j++;
        }
    }

    //
    // NOTE: After the first property box, this just sets identical values.
    //

    for ( j--; j >= 0; j-- )
    {
        dwIndex = (DWORD)SendMessage( hwndCombo, CB_GETITEMDATA, j, 0 );
        aulTypeIndex[dwIndex] = j;
    }
}

void InitStorageLevelList( HWND hwndCombo )
{
    DWORD dwIndex;

    //
    // Add an item for each of the two levels.
    //

    dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)STRINGRESOURCE(srPrimaryStore) );
    SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, PRIMARY_STORE );

    dwIndex = (DWORD)SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM)STRINGRESOURCE(srSecondaryStore) );
    SendMessage(hwndCombo, CB_SETITEMDATA, dwIndex, SECONDARY_STORE );
}

//
// Helper class for virtual server callback.
//

//+---------------------------------------------------------------------------
//
//  Class:      CMetaDataVirtualServerCallBack
//
//  Purpose:    Pure virtual for vroot enumeration
//
//  History:    07-Feb-1997   dlee    Created
//
//----------------------------------------------------------------------------

class CVSComboBox : public CMetaDataVirtualServerCallBack
{
public:

    CVSComboBox( HWND hwndCombo ) :
        _hwndCombo( hwndCombo ),
        cEntries( 0 )
    {
    }

    virtual SCODE CallBack( DWORD iInstance, WCHAR const * pwcInstance );

    virtual ~CVSComboBox() {}

    ULONG EntryCount() { return cEntries; }

private:

    HWND _hwndCombo;
    ULONG cEntries;
};

SCODE CVSComboBox::CallBack( DWORD iInstance, WCHAR const * pwcInstance )
{
    // We pass NULL for _hwndCombo when we only need a count of entries.

    if (NULL != _hwndCombo)
    {
        DWORD dwIndex = (DWORD)SendMessage( _hwndCombo, CB_ADDSTRING, 0, (LPARAM)pwcInstance );
        SendMessage( _hwndCombo, CB_SETITEMDATA, dwIndex, (LPARAM)iInstance );
    }

    cEntries++;

    return S_OK;
}

BOOL AreServersAvailable( CCatalog const & cat )
{
    BOOL fEntriesInList = FALSE;

    //
    // Virtual Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, W3VRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( NULL );

        mgr.EnumVServers( vsc );

        fEntriesInList = (0 == vsc.EntryCount()) ? FALSE : TRUE;
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    //
    // Virtual NNTP Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, NNTPVRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( NULL );

        mgr.EnumVServers( vsc );

        fEntriesInList = fEntriesInList || ( (0 == vsc.EntryCount()) ? FALSE : TRUE );
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    return fEntriesInList;
}

void InitVSList( HWND hwndComboVS, HWND hwndComboNNTP, CCatalog const & cat,
                 ULONG & cVServers, ULONG & cNNTPServers )
{
    //
    // Virtual Server(s)
    //

    TRY
    {
        SendMessage( hwndComboVS, CB_ADDSTRING, 0,
                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );

        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, W3VRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( hwndComboVS );

        Win4Assert(0 == vsc.EntryCount());

        mgr.EnumVServers( vsc );

        cVServers = vsc.EntryCount();
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

    //
    // Virtual NNTP Server(s)
    //

    TRY
    {
        SendMessage( hwndComboNNTP, CB_ADDSTRING, 0,
                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );
        //
        // Add an item for each type group.
        //

        CMetaDataMgr mgr( TRUE, NNTPVRoot, 0xffffffff, cat.GetMachine() );

        CVSComboBox  vsc( hwndComboNNTP );

        Win4Assert(0 == vsc.EntryCount());

        mgr.EnumVServers( vsc );

        cNNTPServers = vsc.EntryCount();
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH

#if 0
    //
    // Virtual IMAP Server(s)
    //

    TRY
    {
        //
        // Add an item for each type group.
        //


        CMetaDataMgr mgr( TRUE, IMAPVRoot, 0xffffffff, cat.GetMachine() );

        DWORD dwIndex = SendMessage( hwndComboIMAP, CB_ADDSTRING, 0,
                                     (LPARAM) STRINGRESOURCE( srNoneSelected.wsz ) );

        CVSComboBox  vsc( hwndComboIMAP );

        mgr.EnumVServers( vsc );
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Couldn't enumerate virtual servers.\n" ));
    }
    END_CATCH
#endif
}

void DisplayError( HWND hwnd, CException & e )
{
    WCHAR wcsError[MAX_PATH];

    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                         GetModuleHandle(L"query.dll"),
                         GetOleError( e ),
                         GetSystemDefaultLCID(),
                         wcsError,
                         sizeof(wcsError) / sizeof(WCHAR),
                         0 ) )
    {
        wsprintf( wcsError,
                  STRINGRESOURCE(srGenericError),
                  GetOleError( e ) );
    }

    MessageBox( hwnd,
                wcsError,
                STRINGRESOURCE( srIndexServerCmpManage ),
                MB_OK | MB_ICONERROR );
}

DWORD VSToIndex( HWND hwndDlg, DWORD dwItem, ULONG ulVS, BOOL fTrack )
{
    if ( !fTrack )
        return 0;

    unsigned cItem = (unsigned)SendDlgItemMessage( hwndDlg,
                                                   dwItem,
                                                   CB_GETCOUNT, 0, 0 );

    for ( unsigned i = 1; i < cItem; i++ )
    {
        ULONG ulItem = (ULONG)SendDlgItemMessage( hwndDlg,
                                                  dwItem,
                                                  CB_GETITEMDATA, i, 0 );

        if ( ulVS == ulItem )
            break;
    }

    return i;
} //VSToIndex


// Return of VT_EMPTY could imply an unknown conversion.
UINT DBTypeToVT(UINT uidbt)
{
    if (uidbt <= DBTYPE_GUID)
        return uidbt;
    
    // Some conversions

    DBTYPE dbtSimpler = uidbt &~ DBTYPE_VECTOR &~ DBTYPE_ARRAY &~ DBTYPE_BYREF;
    
    switch (dbtSimpler)
    {
        case DBTYPE_WSTR:
            return VT_LPWSTR;

        case DBTYPE_STR:
            return VT_LPSTR;

        case DBTYPE_FILETIME:
            return VT_FILETIME;

        default:
           return VT_EMPTY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <ctype.h>
#include <process.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

#include <windows.h>
#include <commctrl.h>

//#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <oledb.h>
#include <oledberr.h>
//#include <cmdtree.h>
#include <filter.h>     // FULLPROPSPEC
#include <query.h>
#include <mmc.h>

#define ciDebugOut ciaDebugOut
#define vqDebugOut ciaDebugOut

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>

#include <ciadebug.hxx>

#include <tgrow.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <dynstack.hxx>
#include <dynarray.hxx>
#include <strres.hxx>

#include <strings.hxx>

#include "ixhelp.h"

extern HINSTANCE ghInstance;

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.
//
// File:        Register.cxx
//
// Contents:    Self-registration for CI MMC control.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     21-Nov-96       KyleP       Created
//                                          and CQueryBase to CQueryExecute
//              7/1/98          mohamedn    comp. mgmt extension
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <isreg.hxx>

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
#include <ciares.h>
#endif


//
// global functions
//
HRESULT BasicComRegistration(void);
HRESULT RegisterSnapinAsStandAloneAndExtension(void);

HRESULT RegisterSnapin(const GUID  * pSnapinCLSID,
                       const GUID  * pStaticNodeGUID,
                       const GUID  * pAboutGUID,
                       WCHAR const * pwszNameString,
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                       WCHAR const * pwszNameStringIndirect,
#endif
                       WCHAR const * pwszVersion,
                       WCHAR const * pwszProvider,
                       _NODE_TYPE_INFO_ENTRY * pNodeTypeInfoEntryArray);

HRESULT RegisterNodeType(const GUID* pGuid, WCHAR const * pwszNodeDescription);

HRESULT RegisterNodeExtension(const GUID  * pNodeGuid,
                              WCHAR const * pwszExtensionType,
                              const GUID  * pExtensionSnapinCLSID,
                              WCHAR const * pwszDescription,
                              BOOL          bDynamic);

HRESULT RegisterServerApplicationExtension( const GUID  * pExtensionSnapinCLSID,
                                            WCHAR const * pwszDescription );

//
// registry constant
//
const WCHAR g_wszNODE_TYPES_KEY[] = L"Software\\Microsoft\\MMC\\NodeTypes";
const WCHAR g_wszSNAPINS_KEY[] = L"Software\\Microsoft\\MMC\\SnapIns";
const WCHAR g_wszNodeType[] = L"NodeType";
const WCHAR g_wszNameString[] = L"NameString";
const WCHAR g_wszStandaloneSnap[] = L"Standalone";
const WCHAR g_wszExtensionSnap[] = L"Extension";
const WCHAR g_wszNodeTypes[] = L"NodeTypes";
const WCHAR g_wszExtensions[] = L"Extensions";
const WCHAR g_wszDynamicExtensions[] = L"Dynamic Extensions";
const WCHAR g_wszVersion[] = L"Version";
const WCHAR g_wszProvider[] = L"Provider";
const WCHAR g_wszAbout[] = L"About";

const WCHAR g_wszISDescription[] = L"Indexing Service Snapin";
const WCHAR g_wszISVersion[] = L"1.0";

#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
const WCHAR g_wszNameStringIndirect[] = L"NameStringIndirect";
#endif

//
// Dynamic extension specific reg values
//
const WCHAR CONTROL_KEY[] = L"System\\CurrentControlSet\\Control\\";
const WCHAR g_wszServerApplications[] = L"Server Applications";

//
// Registry constants
//

WCHAR const wszSnapinPath[]  = L"Software\\Microsoft\\MMC\\SnapIns\\";
WCHAR const wszClsidPath[]   = L"CLSID";

WCHAR const * aClassKeyValue[] = { wszCISnapin,       0, L"Indexing Service Snapin",
                                   L"InprocServer32", 0, L"CIAdmin.dll",
                                   0, L"ThreadingModel", L"Both" };
//
// NodeType registration info
//
static _NODE_TYPE_INFO_ENTRY _NodeTypeInfoEntryArray[] =
{
    { &guidCIRootNode, wszCIRootNode, L"Indexing Service Root Subtree" },
    { NULL, NULL }
};

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//              7/1/98      mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

const HKEY HKeyInvalid = 0;

STDAPI DllRegisterServer()
{

    HRESULT hr = 0;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        hr = BasicComRegistration();

        if ( SUCCEEDED(hr) )
        {
            hr = RegisterSnapinAsStandAloneAndExtension();
        }
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();

        ciaDebugOut(( DEB_ERROR, "Exception 0x%x caught in DllRegisterServer\n", hr ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   BasicComRegistration
//
//  Synopsis:   Self-registration
//
//  History:    22-Nov-96   KyleP       Created
//              7/1/98      mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT BasicComRegistration()
{
    //
    // Create key in snapin section
    //

    WCHAR wcTemp[MAX_PATH+1];
    wcscpy( wcTemp, wszSnapinPath );
    wcscat( wcTemp, wszCISnapin );

    long sc;
    HKEY hKey = HKeyInvalid;
    //
    // Then create class entry
    //

    wcscpy( wcTemp, wszClsidPath );

    for ( unsigned i = 0; i < sizeof(aClassKeyValue)/sizeof(aClassKeyValue[0]); i += 3 )
    {
        // Append only if keyname is non-null
        if ( 0 != aClassKeyValue[i] )
        {
            wcscat( wcTemp, L"\\" );
            wcscat( wcTemp, aClassKeyValue[i] );
        }

        DWORD  dwDisposition;

        sc = RegCreateKeyEx( HKEY_CLASSES_ROOT,    // Root
                             wcTemp,               // Sub key
                             0,                    // Reserved
                             0,                    // Class
                             0,                    // Flags
                             KEY_ALL_ACCESS,       // Access
                             0,                    // Security
                             &hKey,                // Handle
                             &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            break;
        }

        sc = RegSetValueEx( hKey,                      // Key
                            aClassKeyValue[i+1],       // Name
                            0,                         // Reserved
                            REG_SZ,                    // Type
                            (BYTE *)aClassKeyValue[i+2], // Value
                            (1 + wcslen(aClassKeyValue[i+2])) *
                                sizeof(WCHAR) );       // Size

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            break;
        }

        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }
    }

    if ( HKeyInvalid != hKey )
        RegCloseKey( hKey );

    return sc;

}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterSnapinAsStandAloneAndExtension
//
//  Synopsis:   StandAlone & extension registration
//
//  History:    7/1/98      mohamedn   created
//
//----------------------------------------------------------------------------

HRESULT RegisterSnapinAsStandAloneAndExtension()
{
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
    WCHAR wszNameStringIndirect[MAX_PATH];
    WCHAR wszModule[MAX_PATH];
    if ( 0 != ::GetModuleFileName( ghInstance, wszModule, MAX_PATH) )
        wsprintf ( wszNameStringIndirect, L"@%s,-%d", wszModule, MSG_SNAPIN_NAME_STRING_INDIRECT );
    else
        wszNameStringIndirect[0] = L'\0';
#endif
  
    HRESULT hr = 0;
    
    // register the standalone ISSnapin into the console snapin list
    // ISnapinAbout is implemented by the same object implementing the snapin
    hr = RegisterSnapin( &guidCISnapin,
                         &guidCIRootNode,
                         &guidCISnapin,
                         STRINGRESOURCE( srIndexServerCmpManage ),
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                         wszNameStringIndirect,
#endif
                         g_wszISVersion,
                         STRINGRESOURCE( srProviderName ),
                         _NodeTypeInfoEntryArray );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // register node types.
    //
    for ( _NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
          pCurrEntry->_pNodeGUID != NULL; pCurrEntry++ )
    {
        hr = RegisterNodeType( pCurrEntry->_pNodeGUID, pCurrEntry->_pwszNodeDescription );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // register IS snapin as a namespace extension for the server apps node.
    //
    hr = RegisterNodeExtension( &CLSID_NodeTypeServerApps,
                                L"NameSpace",
                                &guidCISnapin,
                                g_wszISDescription,
                                TRUE /* dynamic */ );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // regiser under the server apps & services, we're installed on this machine.
    //
    hr = RegisterServerApplicationExtension( &guidCISnapin, STRINGRESOURCE( srIndexServerCmpManage ) );

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterSnapin
//
//  Synopsis:   snapin registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterSnapin( GUID const * pSnapinCLSID,
                        GUID const * pStaticNodeGUID,
                        GUID const * pAboutGUID,
                        WCHAR const * pwszNameString,
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
                        WCHAR const * pwszNameStringIndirect,
#endif
                        WCHAR const * pwszVersion,
                        WCHAR const * pwszProvider,
                        _NODE_TYPE_INFO_ENTRY * pNodeTypeInfoEntryArray )
{

    WCHAR wszSnapinClassID[128], wszStaticNodeGUID[128];

    ::StringFromGUID2(*pSnapinCLSID, wszSnapinClassID, 128);
    ::StringFromGUID2(*pStaticNodeGUID, wszStaticNodeGUID, 128);
    ::StringFromGUID2(*pAboutGUID, wszSnapinClassID, 128);

    {
        CWin32RegAccess     reg( HKEY_LOCAL_MACHINE, g_wszSNAPINS_KEY );
        BOOL                fExists;

        if ( !reg.Ok() || !reg.CreateKey( wszSnapinClassID, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    {
        if ( wcslen(g_wszSNAPINS_KEY) + wcslen(wszSnapinClassID) + 2 > MAX_PATH )
        {
            return E_FAIL;  // insufficient buffer size
        }

        unsigned cc = wcslen(g_wszSNAPINS_KEY) + 2 /* L"\\" */ + wcslen(wszSnapinClassID) + 1;

        XGrowable<WCHAR> xwszSnapinClassIDKey(cc);

        wcscpy( xwszSnapinClassIDKey.Get(), g_wszSNAPINS_KEY );
        wcscat( xwszSnapinClassIDKey.Get(), L"\\" );
        wcscat( xwszSnapinClassIDKey.Get(), wszSnapinClassID );

        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszSnapinClassIDKey.Get() );

        if ( !reg.Ok() )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        if ( !reg.Set( g_wszNameString, pwszNameString ) ||
             !reg.Set( g_wszAbout, wszCISnapin ) ||   // ISnapinAbout is implemented by the main dll
             !reg.Set( g_wszNodeType, wszStaticNodeGUID ) ||
             !reg.Set( g_wszProvider, pwszProvider ) ||
             !reg.Set( g_wszVersion, pwszVersion ) ) 
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
            || !reg.Set( g_wszNameStringIndirect, pwszNameStringIndirect ) )
#endif
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        //
        // create keys for both standalone and extension
        //

        BOOL fExists;

        if ( !reg.CreateKey( g_wszExtensionSnap, fExists ) ||
             !reg.CreateKey( g_wszStandaloneSnap, fExists ) ||
             !reg.CreateKey( g_wszNodeTypes, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    {
        unsigned cc = wcslen(g_wszSNAPINS_KEY) + 2 + wcslen(wszSnapinClassID) + 2 + wcslen(g_wszNodeTypes) + 1;

        XGrowable<WCHAR>   xwszSnapinNodeTypeKey(cc);

        wcscpy( xwszSnapinNodeTypeKey.Get(), g_wszSNAPINS_KEY );
        wcscat( xwszSnapinNodeTypeKey.Get(), L"\\" );
        wcscat( xwszSnapinNodeTypeKey.Get(), wszSnapinClassID );
        wcscat( xwszSnapinNodeTypeKey.Get(), L"\\" );
        wcscat( xwszSnapinNodeTypeKey.Get(), g_wszNodeTypes );

        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszSnapinNodeTypeKey.Get() );

        if ( !reg.Ok() )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        for ( _NODE_TYPE_INFO_ENTRY * pCurrEntry = pNodeTypeInfoEntryArray;
                                      pCurrEntry->_pNodeGUID != NULL;
                                      pCurrEntry++ )
        {
            BOOL fExists;

            if ( !reg.CreateKey( pCurrEntry->_pwszNodeGUID, fExists ) )
            {
                return HRESULT_FROM_WIN32( reg.GetLastError() );
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterNodeType
//
//  Synopsis:   NodeType registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterNodeType( GUID const * pGuid, WCHAR const * pwszNodeDescription )
{
    BOOL    fExists;
    WCHAR   wszNodeGUID[128];

    ::StringFromGUID2( *pGuid, wszNodeGUID, 128 );

    {
        CWin32RegAccess reg ( HKEY_LOCAL_MACHINE, g_wszNODE_TYPES_KEY );

        if ( !reg.Ok() || !reg.CreateKey(wszNodeGUID, fExists) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    unsigned cc = wcslen(g_wszNODE_TYPES_KEY) + 2 + wcslen(wszNodeGUID) + 1;

    XGrowable<WCHAR>   xwszThisNodeType(cc);

    wcscpy( xwszThisNodeType.Get(), g_wszNODE_TYPES_KEY );
    wcscat( xwszThisNodeType.Get(), L"\\" );
    wcscat( xwszThisNodeType.Get(), wszNodeGUID );

    CWin32RegAccess reg ( HKEY_LOCAL_MACHINE, xwszThisNodeType.Get() );

    if ( !reg.Ok() || !reg.Set( NULL, pwszNodeDescription ) )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterNodeExtension
//
//  Synopsis:   NodeExtension registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterNodeExtension( GUID const *  pNodeGuid,
                               WCHAR const * pwszExtensionType,
                               GUID const *  pExtensionSnapinCLSID,
                               WCHAR const * pwszDescription,
                               BOOL          fDynamic )
{
    BOOL  fExists;
    WCHAR wszNodeGUID[128], wszExtensionCLSID[128];

    ::StringFromGUID2(*pNodeGuid, wszNodeGUID, 128 );
    ::StringFromGUID2(*pExtensionSnapinCLSID, wszExtensionCLSID, 128);

    CWin32RegAccess     srvAppsNode( HKEY_LOCAL_MACHINE, g_wszNODE_TYPES_KEY );

    if ( !srvAppsNode.Ok() || !srvAppsNode.CreateKey( wszNodeGUID, fExists ) )
    {
        return HRESULT_FROM_WIN32( srvAppsNode.GetLastError() );
    }

    unsigned cc1 = wcslen( g_wszNODE_TYPES_KEY ) + 2 + wcslen( wszNodeGUID ) + 1;

    XGrowable<WCHAR>  xwszThisNodeType(cc1);

    wcscpy( xwszThisNodeType.Get(), g_wszNODE_TYPES_KEY );
    wcscat( xwszThisNodeType.Get(), L"\\" );
    wcscat( xwszThisNodeType.Get(), wszNodeGUID );

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszThisNodeType.Get() );

    if ( !reg.Ok() )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    if ( !reg.CreateKey( g_wszExtensions, fExists ) )
    {
        return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    unsigned cc2 = wcslen( xwszThisNodeType.Get() ) + 2 + wcslen( g_wszExtensions ) + 1;

    XGrowable<WCHAR> xwszExtensionPath(cc2);

    wcscpy( xwszExtensionPath.Get(), xwszThisNodeType.Get() );
    wcscat( xwszExtensionPath.Get(), L"\\" );
    wcscat( xwszExtensionPath.Get(), g_wszExtensions );

    //
    // create the extension key if it doesn't exist
    //
    {
        CWin32RegAccess regExtensions( HKEY_LOCAL_MACHINE, xwszExtensionPath.Get() );

        if ( !regExtensions.CreateKey( pwszExtensionType, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    //
    // add our snapin clsid to the extension key
    //
    {
        cc2 += 2 + wcslen( pwszExtensionType );

        xwszExtensionPath.SetSize(cc2);

        wcscat ( xwszExtensionPath.Get(), L"\\" );
        wcscat ( xwszExtensionPath.Get(), pwszExtensionType );

        CWin32RegAccess regExt( HKEY_LOCAL_MACHINE, xwszExtensionPath.Get() );

        if ( !reg.Ok() || !regExt.Set( wszExtensionCLSID, pwszDescription ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    //
    // add our snapin clsid to the dynamic extension key.
    //
    if ( fDynamic )
    {
        //
        // create the Dynamic Extensions key if it doesn't exist.
        //
        if ( !reg.CreateKey( g_wszDynamicExtensions, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }

        //
        // Add our snapin clsid to the dynamic key
        //

        unsigned cc = wcslen( xwszThisNodeType.Get() ) + 2 + wcslen(g_wszDynamicExtensions);

        XGrowable<WCHAR> xwszDynamicPath(cc);

        wcscpy( xwszDynamicPath.Get(), xwszThisNodeType.Get() );
        wcscat( xwszDynamicPath.Get(), L"\\" );
        wcscat( xwszDynamicPath.Get(), g_wszDynamicExtensions );

        CWin32RegAccess regDynamicExtensions(HKEY_LOCAL_MACHINE, xwszDynamicPath.Get() );

        if ( !regDynamicExtensions.Ok() ||
             !regDynamicExtensions.Set( wszExtensionCLSID, pwszDescription ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterServerApplicationExtension
//
//  Synopsis:   server application registration
//
//  History:    7/1/98  mohamedn    comp. mgmt extension.
//
//----------------------------------------------------------------------------

HRESULT RegisterServerApplicationExtension( const GUID  * pExtensionSnapinCLSID,
                                            WCHAR const * pwszDescription )
{
    WCHAR wszExtensionGUID[128];

    ::StringFromGUID2( *pExtensionSnapinCLSID, wszExtensionGUID, 128 );

    //
    // create Server Applications key if it doesn't exist.
    //
    {
        BOOL            fExists;
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, CONTROL_KEY );

        if ( !reg.Ok() || !reg.CreateKey( g_wszServerApplications, fExists ) )
        {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
        }
    }

    unsigned cc = wcslen(CONTROL_KEY) + 2 + wcslen(g_wszServerApplications) + 1;

    XGrowable<WCHAR>  xwszServerApplicationsPath(cc);

    wcscpy( xwszServerApplicationsPath.Get(), CONTROL_KEY );
    wcscat( xwszServerApplicationsPath.Get(), g_wszServerApplications );

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, xwszServerApplicationsPath.Get() );

    if ( !reg.Ok() || !reg.Set( wszExtensionGUID, pwszDescription ) )
    {
            return HRESULT_FROM_WIN32( reg.GetLastError() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\prop.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catalog.hxx>
#include <catadmin.hxx>

#include <fsciexps.hxx>

//
// Local prototypes
//

WCHAR * ConvertToString ( GUID & Uuid, WCHAR * String );
WCHAR * ULongToHexString ( WCHAR * String, unsigned long Number );

//
// Global data
//

SPropertyColumn coldefProps[] = { { CCachedProperty::GetPropSet,    MSG_COL_PROPSET,    LVCFMT_LEFT },
                                  { CCachedProperty::GetProperty,   MSG_COL_PROPERTY,   LVCFMT_LEFT },
                                  { CCachedProperty::GetFName,      MSG_COL_FNAME,      LVCFMT_LEFT },
                                  { CCachedProperty::GetDatatype,   MSG_COL_DATATYPE,   LVCFMT_LEFT },
                                  { CCachedProperty::GetAllocation, MSG_COL_DATASIZE,   LVCFMT_LEFT },
                                  { CCachedProperty::GetStoreLevel, MSG_COL_STORELEVEL, LVCFMT_LEFT }
                                };

const unsigned cColDefProps = sizeof coldefProps / sizeof coldefProps[0];

BOOL CCachedProperty::_fFirstTime = TRUE;

WCHAR * awcsType[] = { L"VT_EMPTY",    // 0
                       L"VT_NULL",     // 1
                       L"VT_I2",       // 2
                       L"VT_I4",       // 3
                       L"VT_R4",       // 4
                       L"VT_R8",       // 5
                       L"VT_CY",       // 6
                       L"VT_DATE",     // 7
                       L"VT_BSTR",     // 8
                       0,              // 9
                       L"VT_ERROR",    // 10
                       L"VT_BOOL",     // 11
                       L"VT_VARIANT",  // 12
                       0,              // 13
                       L"VT_DECIMAL",  // 14
                       0,              // 15
                       L"VT_I1",       // 16
                       L"VT_UI1",      // 17
                       L"VT_UI2",      // 18
                       L"VT_UI4",      // 19
                       L"VT_I8",       // 20
                       L"VT_UI8",      // 21
                       L"VT_INT",      // 22
                       L"VT_UINT",     // 23
                       0,              // 24
                       0,              // 25
                       0,              // 26
                       0,              // 27
                       0,              // 28
                       0,              // 29
                       L"VT_LPSTR",    // 30
                       L"VT_LPWSTR",   // 31
                       0,              // 32
                       0,              // 33
                       0,              // 34
                       0,              // 35
                       0,              // 36
                       0,              // 37
                       0,              // 38
                       0,              // 39
                       0,              // 40
                       0,              // 41
                       0,              // 42
                       0,              // 43
                       0,              // 44
                       0,              // 45
                       0,              // 46
                       0,              // 47
                       0,              // 48
                       0,              // 49
                       0,              // 50
                       0,              // 51
                       0,              // 52
                       0,              // 53
                       0,              // 54
                       0,              // 55
                       0,              // 56
                       0,              // 57
                       0,              // 58
                       0,              // 59
                       0,              // 60
                       0,              // 61
                       0,              // 62
                       0,              // 63
                       L"VT_FILETIME", // 64
                       L"VT_BLOB",     // 65
                       0,              // 66
                       0,              // 67
                       0,              // 68
                       0,              // 69
                       0,              // 70
                       L"VT_CF",       // 71
                       L"VT_CLSID" };  // 72

//
// Index of string in packed list box.
//

ULONG aulTypeIndex[] = { 0,  // VT_EMPTY
                         1,  // VT_NULL
                         2,  // VT_I2
                         3,  // VT_I4
                         4,  // VT_R4
                         5,  // VT_R8
                         6,  // VT_CY
                         7,  // VT_DATE
                         8,  // VT_BSTR
                         0,  // 9
                         9,  // VT_ERROR
                         10, // VT_BOOL
                         11, // VT_VARIANT
                         0,  // 13
                         12,  // 14
                         0,  // 15
                         13, // VT_I1
                         14, // VT_UI1
                         15, // VT_UI2
                         16, // VT_UI4
                         17, // VT_I8
                         18, // VT_UI8
                         19, // VT_INT
                         20, // VT_UINT
                         0,  // 24
                         0,  // 25
                         0,  // 26
                         0,  // 27
                         0,  // 28
                         0,  // 29
                         21, // VT_LPSTR
                         22, // VT_LPWSTR
                         0,  // 32
                         0,  // 33
                         0,  // 34
                         0,  // 35
                         0,  // 36
                         0,  // 37
                         0,  // 38
                         0,  // 39
                         0,  // 40
                         0,  // 41
                         0,  // 42
                         0,  // 43
                         0,  // 44
                         0,  // 45
                         0,  // 46
                         0,  // 47
                         0,  // 48
                         0,  // 49
                         0,  // 50
                         0,  // 51
                         0,  // 52
                         0,  // 53
                         0,  // 54
                         0,  // 55
                         0,  // 56
                         0,  // 57
                         0,  // 58
                         0,  // 59
                         0,  // 60
                         0,  // 61
                         0,  // 62
                         0,  // 63
                         23, // VT_FILETIME
                         24, // VT_BLOB
                         0,  // 66
                         0,  // 67
                         0,  // 68
                         0,  // 69
                         0,  // 70
                         25, // VT_CF
                         26 }; // VT_CLSID

CCachedProperty::CCachedProperty( CCatalog & cat,
                                  GUID & guidPropSet,
                                  PROPSPEC & psProperty,
                                  ULONG vt,
                                  ULONGLONG cbAllocation,
                                  DWORD dwStoreLevel,
                                  VARIANT_BOOL  fModifiable,
                                  BOOL fNew )
        : _vt( vt ),
          _cb( (ULONG)cbAllocation ),
          _fZombie( FALSE ),
          _fNew( fNew ),
          _fFixed( FALSE ),
          _fUnapplied( FALSE ),
          _cat( cat ),
          _dwStoreLevel( dwStoreLevel ),
          _fModifiable( fModifiable )
{
    WCHAR wcsFileName[MAX_PATH];

    Win4Assert( (_dwStoreLevel != INVALID_STORE_LEVEL) ||
                (_dwStoreLevel == INVALID_STORE_LEVEL && 0 == cbAllocation) );

    _regEntry.GetDefaultColumnFile( wcsFileName, MAX_PATH );

    //
    // Get the file name from the registry and create a list that
    // will not be refreshed even if the underlying file changes.
    //

    _xPropList.Set(new CLocalGlobalPropertyList(GetGlobalStaticPropertyList(),
                                                FALSE,
                                                wcsFileName));

    if (_fFirstTime)
    {
        for ( unsigned i = 0; i < cColDefProps; i++ )
            coldefProps[i].srTitle.Init( ghInstance );

        _fFirstTime = FALSE;
    }

    CDbColId dbcol;
    dbcol.SetPropSet( guidPropSet );

    _fps.guidPropSet = guidPropSet;
    _fps.psProperty  = psProperty;

    //
    // String-ize GUID
    //

    ConvertToString( guidPropSet, _wcsPropSet );

    //
    // String-ize property
    //

    if ( PRSPEC_LPWSTR == psProperty.ulKind )
    {
        unsigned cc = wcslen( psProperty.lpwstr ) + 1;
        _xwcsProperty.SetSize( cc );
        RtlCopyMemory( _xwcsProperty.Get(), psProperty.lpwstr, cc * sizeof( WCHAR ) );

        _fps.psProperty.lpwstr = _xwcsProperty.Get();

        dbcol.SetProperty( psProperty.lpwstr );
    }
    else
    {
        wcscpy( _xwcsProperty.Get(), L"0x" );

        _ultow( psProperty.propid, _xwcsProperty.Get() + 2, 16 );

        dbcol.SetProperty( psProperty.propid );
    }

    if ( vt == VT_EMPTY && 0 == cbAllocation )
    {
        _wcsDatatype[0] = 0;
        _wcsAllocation[0] = 0;

        Win4Assert(VT_EMPTY == DBTYPE_EMPTY);

        _dbtDefaultType = VT_EMPTY;
        _uiDefaultSize = 0;
    }
    else
        SetVT( vt );

    //
    // Look for friendly name and other details.
    //

    CPropEntry const * pProp = _xPropList->Find( dbcol );

    if ( 0 == pProp )
        _xwcsFName[0] = 0;
    else
    {
        unsigned cc = wcslen( pProp->GetDisplayName() ) + 1;
        _xwcsFName.SetSize( cc );
        RtlCopyMemory( _xwcsFName.Get(), pProp->GetDisplayName(), cc * sizeof(WCHAR) );

        _dbtDefaultType = pProp->GetPropType();
        _uiDefaultSize = pProp->GetWidth();

        ciaDebugOut((DEB_ITRACE, "%ws has type %d (0x%x) and size %d\n", 
                     pProp->GetDisplayName(), _dbtDefaultType, _dbtDefaultType, _uiDefaultSize));
    }

    // If it is not cached, it can be modified!
    if (!IsCached())
        _fModifiable = VARIANT_TRUE;

    END_CONSTRUCTION( CCachedProperty );
}

CCachedProperty::CCachedProperty( CCachedProperty const & prop )
        : _cat( prop._cat ),
          _xwcsProperty( prop._xwcsProperty )
{
    *this = prop;

    END_CONSTRUCTION( CCachedProperty );
}

CCachedProperty & CCachedProperty::operator =( CCachedProperty const & prop )
{
    _vt =      prop._vt;
    _cb =      prop._cb;
    _fZombie = prop._fZombie;
    _fNew =    prop._fNew;
    _fFixed =  prop._fFixed;
    _fUnapplied = prop._fUnapplied;
    _fps =     prop._fps;
    _dwStoreLevel = prop._dwStoreLevel;
    _fModifiable = prop._fModifiable;

    _dbtDefaultType = prop._dbtDefaultType;
    _uiDefaultSize = prop._uiDefaultSize;

    RtlCopyMemory( _wcsPropSet, prop._wcsPropSet, sizeof( _wcsPropSet ) );
    RtlCopyMemory( _wcsDatatype, prop._wcsDatatype, sizeof( _wcsDatatype ) );
    RtlCopyMemory( _wcsAllocation, prop._wcsAllocation, sizeof( _wcsAllocation ) );
    _xwcsProperty = prop._xwcsProperty;

    if ( PRSPEC_LPWSTR == _fps.psProperty.ulKind )
        _fps.psProperty.lpwstr = _xwcsProperty.Get();

    return *this;
}

CCachedProperty::~CCachedProperty()
{
}

void CCachedProperty::SetVT( ULONG vt )
{
    ciaDebugOut(( DEB_ITRACE, "SetVT: _cb is %d before\n", _cb ));
    _vt = vt;

    //
    // Adjust size for fixed types.
    //

    switch ( _vt )
    {
    case VT_I1:
    case VT_UI1:
        _cb = 1;
        _fFixed = TRUE;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _cb = 2;
        _fFixed = TRUE;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        _cb = 4;
        _fFixed = TRUE;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        _cb = 8;
        _fFixed = TRUE;
        break;

    case VT_CLSID:
        _cb = sizeof(GUID);
        _fFixed = TRUE;
        break;

    default:
        _fFixed = FALSE;
    }

    // If storage level is INVALID_STORE_LEVEL, the property is not cached
    // so its allocation size should be set to 0.
    if (_dwStoreLevel == INVALID_STORE_LEVEL)
        _cb = 0;

    //
    // String-ize datatype
    //

    if ( vt & VT_VECTOR )
    {
        wcscpy( _wcsDatatype, L"VT_VECTOR | " );
        vt &= ~VT_VECTOR;
    }
    else
        _wcsDatatype[0] = 0;

    if ( ( vt >= sizeof(awcsType)/sizeof(awcsType[0]) ) ||
         ( 0 == awcsType[vt] ) )
    {
        wcscpy( _wcsDatatype, L"---" );
    }
    else
        wcscat( _wcsDatatype, awcsType[vt] );

    //
    // String-ize allocation.  Assume < 4 Gb!
    //

    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty is %ws and pointer is %d before\n", _xwcsProperty.Get(), _xwcsProperty.Get() ));

    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsAllocation is %ws before\n", _wcsAllocation ));
    
    // Max is 60K to fit a record into one page
    if ( _cb < 61440 )
        _ultow( _cb, _wcsAllocation, 10 );
    else
    {
        _cb = 61440;
        _ultow( 61440, _wcsAllocation, 10 );
    }

    ciaDebugOut(( DEB_ITRACE, "SetVT: _cb is %d after\n", _cb ));  
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty: pointer is %d\n", _xwcsProperty.Get() ));
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsAllocation is %ws after\n", _wcsAllocation ));
    ciaDebugOut(( DEB_ITRACE, "SetVT: _wcsProperty is %ws\n", _xwcsProperty.Get() ));
}

void CCachedProperty::InitHeader( CListViewHeader & Header )
{
    if (_fFirstTime)
    {
        for ( unsigned i = 0; i < cColDefProps; i++ )
            coldefProps[i].srTitle.Init( ghInstance );

        _fFirstTime = FALSE;
    }

    //
    // Initialize header
    //

    for ( unsigned i = 0; i < cColDefProps; i++ )
    {
        Header.Add( i, STRINGRESOURCE(coldefProps[i].srTitle), coldefProps[i].justify, MMCLV_AUTO );
    }
}

void CCachedProperty::GetDisplayInfo( RESULTDATAITEM * item )
{
    //
    // This can happen if you right-click on properties and select refresh
    // while the current selection is something other than properties.
    // Looks like an MMC bug.
    //

    if ( item->nCol >= cColDefProps )
    {
        item->str = L"";
        return;
    }

    item->str = (WCHAR *)(this->*coldefProps[item->nCol].pfGet)();

    if ( 0 == item->nCol && IsUnappliedChange() )
    {
        item->nImage = ICON_MODIFIED_PROPERTY;
        item->mask |= RDI_IMAGE;
    }
    else
        item->nImage = ICON_PROPERTY;
} //GetDisplayInfo


static WCHAR HexDigits[] = L"0123456789abcdef";

static WCHAR * ULongToHexString ( WCHAR * String, unsigned long Number )
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];

    return(String);
}

static WCHAR * UShortToHexString ( WCHAR * String, unsigned short Number )
{
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];

    return(String);
}


static WCHAR * UCharToHexString ( WCHAR * String, WCHAR Number )
{
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}

WCHAR * ConvertToString ( UUID & Uuid, WCHAR * String )
{
    String = ULongToHexString(String, Uuid.Data1);
    *String++ = L'-';
    String = UShortToHexString(String, Uuid.Data2);
    *String++ = L'-';
    String = UShortToHexString(String, Uuid.Data3);
    *String++ = L'-';
    String = UCharToHexString(String, Uuid.Data4[0]);
    String = UCharToHexString(String, Uuid.Data4[1]);
    *String++ = L'-';
    String = UCharToHexString(String, Uuid.Data4[2]);
    String = UCharToHexString(String, Uuid.Data4[3]);
    String = UCharToHexString(String, Uuid.Data4[4]);
    String = UCharToHexString(String, Uuid.Data4[5]);
    String = UCharToHexString(String, Uuid.Data4[6]);
    String = UCharToHexString(String, Uuid.Data4[7]);
    *String++ = 0;

    return(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\rootnode.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       rootnode.cxx
//
//  Contents:   snapin extension root node.
//
//  History:    6-16-98 mohamedn   created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rootnode.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CRootNode::Display, public
//
//  Synopsis:   Inserts the root node item in the scope pane.
//
//  Arguments:  [hScopeItem] -- handle to parent scope item
//
//  Returns:    none.
//
//  History:    01-Jul-1998  mohamedn    created
//
//----------------------------------------------------------------------------

void CRootNode::Display( HSCOPEITEM hScopeItem )
{
    SCOPEDATAITEM item;

    RtlZeroMemory( &item, sizeof(item) );

    item.mask |= SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
    item.nImage = item.nOpenImage = ICON_APP;
    item.displayname = MMC_CALLBACK;

    item.mask |= SDI_PARAM;
    item.lParam = (LPARAM)this;

    item.relativeID = hScopeItem;

    HRESULT hr = _pScopePane->InsertItem( &item );
    if ( FAILED(hr) )
    {
        ciaDebugOut(( DEB_ERROR, "_pScopePane->InsertItem() Failed, hr: %x\n", hr ));
        THROW( CException(hr) );
    }

    _idScope = item.ID;
    _idParent = hScopeItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootNode::Delete, public
//
//  Synopsis:   Deletes root node from scope pane.
//
//  History:    27-Jul-1998    KyleP   Created
//
//  Notes:      Called when MMCN_REMOVE_CHILDREN sent to snap-in.
//
//----------------------------------------------------------------------------

SCODE CRootNode::Delete()
{
    SCODE sc = S_OK;

    if ( -1 != _idScope )
    {
        sc = _pScopePane->DeleteItem( _idScope, TRUE );
        _idScope = -1;
        _idParent = -1;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\scope.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       Catalog.cxx
//
//  Contents:   Used to manage catalog(s) state
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catalog.hxx>
#include <catadmin.hxx>

extern "C"
{
    #include <lmcons.h>
}
#include <cisecret.hxx>

//
// Global data
//

SScopeColumn coldefScope[] = { { CScope::GetPath,       MSG_COL_ROOT },
                               { CScope::GetAlias,      MSG_COL_ALIAS },
                               { CScope::GetInclude,    MSG_COL_EXCLUDE }
                             };

BOOL CScope::_fFirstTime = TRUE;

CScope::CScope( CCatalog & cat,
                WCHAR const * pwcsPath,
                WCHAR const * pwcsAlias,
                BOOL fExclude,
                BOOL fVirtual,
                BOOL fShadowAlias )
        : _pwcsPath( 0 ),
          _pwcsAlias( 0 ),
          _fExclude( fExclude ),
          _fVirtual( fVirtual ),
          _fShadowAlias( fShadowAlias ),
          _fZombie( FALSE ),
          _cat( cat )
{
    TRY
    {
        Set( pwcsPath, _pwcsPath );
        Set( pwcsAlias, _pwcsAlias );
    }
    CATCH( CException, e )
    {
        delete [] _pwcsPath;
        delete [] _pwcsAlias;

        RETHROW();
    }
    END_CATCH
}

CScope::~CScope()
{
    delete [] _pwcsPath;
    delete [] _pwcsAlias;
}

void CScope::Modify(WCHAR const * pwcsPath,
                    WCHAR const * pwcsAlias,
                    BOOL fExclude)
{
    Win4Assert( !IsZombie() );

    Reset( pwcsPath, _pwcsPath );
    Reset( pwcsAlias, _pwcsAlias );

    _fExclude = fExclude;
}

void CScope::InitHeader( CListViewHeader & Header )
{
    //
    // Initialize header
    //

    for ( unsigned i = 0; i < sizeof(coldefScope)/sizeof(coldefScope[0]); i++ )
    {
        if ( _fFirstTime )
            coldefScope[i].srTitle.Init( ghInstance );

        Header.Add( i, STRINGRESOURCE(coldefScope[i].srTitle), LVCFMT_LEFT, MMCLV_AUTO );
    }

    _fFirstTime = FALSE;
}

void CScope::Set( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    if ( 0 == pwcsSrc )
    {
        pwcsDst = new WCHAR[1];
        RtlCopyMemory( pwcsDst, L"", sizeof(WCHAR) );
    }
    else
    {
        unsigned cc = wcslen( pwcsSrc ) + 1;

        pwcsDst = new WCHAR [cc];

        RtlCopyMemory( pwcsDst, pwcsSrc, cc * sizeof(WCHAR) );
    }
}

void CScope::Reset( WCHAR const * pwcsSrc, WCHAR * & pwcsDst )
{
    delete pwcsDst;

    Set(pwcsSrc, pwcsDst);
}

void CScope::Rescan( BOOL fFull )
{
    _cat.RescanScope( _pwcsPath, fFull );
}

// The username and password are not stored locally. They will
// be retrieved on demand from the catadmin object.

SCODE CScope::GetUsername(WCHAR *pwszLogon)
{
    SCODE sc = S_OK;

    TRY
    {
        //
        // First, remove from CI.
        //

        CMachineAdmin MachineAdmin( _cat.GetMachine() );
        XPtr<CCatalogAdmin> xCatalogAdmin( MachineAdmin.QueryCatalogAdmin( _cat.GetCat(TRUE) ) );

        XPtr<CScopeAdmin> xScopeAdmin( xCatalogAdmin->QueryScopeAdmin(_pwcsPath) );

        if ( !xScopeAdmin.IsNull() )
            wcscpy(pwszLogon, xScopeAdmin->GetLogon());
    }
    CATCH (CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

SCODE CScope::GetPassword(WCHAR *pwszPassword)
{
    WCHAR szLogon[UNLEN + 1];
    szLogon[0] = 0;
    GetUsername(szLogon);
    *pwszPassword = 0;
    BOOL fOK = TRUE;
    
    // don't attempt to get pwd of a NULL logon name!
    if (0 != szLogon[0])
        CiGetPassword(_cat.GetCat(TRUE), szLogon, pwszPassword);

    return fOK ? S_OK:S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\snapin.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       Snapin.cxx
//
//  Contents:   MMC snapin for CI.
//
//  History:    26-Nov-1996     KyleP   Created
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ISReg.hxx>
#include <CIARes.h>
#include <snapin.hxx>
#include <dataobj.hxx>
#include <propsht.hxx>
#include <callback.hxx>
#include <cmddlg.hxx>
#include <classid.hxx>
#include <catadmin.hxx>
#include <catalog.hxx>
#include <ntverp.h>

//
// Global data
//


//
// NOTE: Any new menus added to this array must be at the same location as
//       the value of "lCommandID", which is the third member of the
//       struct CONTEXTMENUITEM  ie. comidAddScope = 0 below.
//       Additionally, you should add another Win4Assert in the
//       "CCISnapinData::Initialize" method below.
CONTEXTMENUITEM aContextMenus[] = {
    // Add scope
    { STRINGRESOURCE( srCMScope ),
      STRINGRESOURCE( srCMScopeHelp ),
      comidAddScope,
      CCM_INSERTIONPOINTID_PRIMARY_NEW,
      MF_ENABLED,
      0 },

    // Add catalog
    { STRINGRESOURCE( srCMAddCatalog ),
      STRINGRESOURCE( srCMAddCatalogHelp ),
      comidAddCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_NEW,
      MF_ENABLED,
      0 },

    // Rescan Full scope
    { STRINGRESOURCE( srCMRescanFull ),
      STRINGRESOURCE( srCMRescanFullHelp ),
      comidRescanFullScope,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Force merge
    { STRINGRESOURCE( srCMMerge ),
      STRINGRESOURCE( srCMMergeHelp ),
      comidMergeCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Start CI
    { STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp ),
      comidStartCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Stop CI
    { STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp ),
      comidStopCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Pause CI
    { STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp ),
      comidPauseCI,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Refresh properties list
    { STRINGRESOURCE( srRefreshProperties ),
      STRINGRESOURCE( srRefreshPropertiesHelp ),
      comidRefreshProperties,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Empty catalog
    { STRINGRESOURCE( srCMEmptyCatalog ),
      STRINGRESOURCE( srCMEmptyCatalogHelp ),
      comidEmptyCatalog,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Tune performance
    { STRINGRESOURCE( srCMTunePerformance ),
      STRINGRESOURCE( srCMTunePerformanceHelp ),
      comidTunePerfCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },

    // Duplication of the commonly used menus
    // at the top of the menu.

    // Start CI
    { STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp ),
      comidStartCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Stop CI
    { STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp ),
      comidStopCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Pause CI
    { STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp ),
      comidPauseCITop,
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      MF_ENABLED,
      0 },

    // Rescan Incremental scope
    { STRINGRESOURCE( srCMRescanIncremental ),
      STRINGRESOURCE( srCMRescanIncrementalHelp ),
      comidRescanIncrementalScope,
      CCM_INSERTIONPOINTID_PRIMARY_TASK,
      MF_ENABLED,
      0 },
};

static DWORD aIds[] =
    {
        IDOK,                       HIDP_OK,
        IDCANCEL,                   HIDP_CANCEL,

        // Catalog properties
        IDDI_FILTER_UNKNOWN,        HIDP_GENERATION_FILTER_UNKNOWN,
        IDDI_CHARACTERIZATION,      HIDP_GENERATION_GENERATE_CHARACTERIZATION,
        IDDI_CHARSIZE_STATIC,       HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_CHARACTERIZATION_SIZE, HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_SPIN_CHARACTERIZATION, HIDP_GENERATION_MAXIMUM_SIZE,
        IDDI_SELECT_SIZE,           HIDP_LOCATION_SIZE,
        IDDI_SIZE,                  HIDP_LOCATION_SIZE,
        IDDI_SELECT_PATH2,          HIDP_CATALOG_LOCATION,
        IDDI_PATH,                  HIDP_CATALOG_LOCATION,
        IDDI_SELECT_PROPCACHE_SIZE, HIDP_PROPCACHE_SIZE,
        IDDI_PROPCACHE_SIZE,        HIDP_PROPCACHE_SIZE,
        IDDI_VSERVER_STATIC,        HIDP_WEB_VSERVER,
        IDDI_VIRTUAL_SERVER,        HIDP_WEB_VSERVER,
        IDDI_NNTP_STATIC,           HIDP_WEB_NNTPSERVER,
        IDDI_NNTP_SERVER,           HIDP_WEB_NNTPSERVER,
        IDDI_AUTO_ALIAS,            HIDP_ALIAS_NETWORK_SHARES,
        IDDI_INHERIT1,              HIDP_SETTINGS_INHERIT1,
        IDDI_INHERIT2,              HIDP_SETTINGS_INHERIT2,
        IDDI_GROUP_INHERIT,         HIDP_INHERIT,
        IDDI_SELECT_CATNAME,        HIDP_CATALOG_NAME,
        IDDI_CATNAME,               HIDP_CATALOG_NAME,
        
        // New catalog
        IDDI_SELECT_CATPATH,        HIDP_LOCATION_LOCATION,
        IDDI_CATPATH,               HIDP_LOCATION_LOCATION,
        IDDI_SELECT_CATNAME2,       HIDP_LOCATION_NAME,
        IDDI_CATNAME2,              HIDP_LOCATION_NAME,
        IDDI_BROWSE,                HIDP_LOCATION_BROWSE,

        // Property dialog box
        IDDI_SELECT_PROPSET,        HIDP_PROPERTY_SET,
        IDDI_PROPSET,               HIDP_PROPERTY_SET,
        IDDI_SELECT_PROPERTY,       HIDP_PROPERTY_PROPERTY,
        IDDI_PROPERTY,              HIDP_PROPERTY_PROPERTY,
        IDDI_CACHED,                HIDP_PROPERTY_CACHED,
        IDDI_SELECT_DATATYPE,       HIDP_PROPERTY_DATATYPE,
        IDDI_DATATYPE,              HIDP_PROPERTY_DATATYPE,
        IDDI_SELECT_CACHEDSIZE,     HIDP_PROPERTY_SIZE,
        IDDI_CACHEDSIZE,            HIDP_PROPERTY_SIZE,
        IDDI_SPIN_CACHEDSIZE,       HIDP_PROPERTY_SIZE,
        IDDI_SELECT_STORAGELEVEL,   HIDP_PROPERTY_STORAGELEVEL,
        IDDI_STORAGELEVEL,          HIDP_PROPERTY_STORAGELEVEL,

        //IDDI_COMPNAME,              ,
        IDDI_LOCAL_COMPUTER,        HIDP_CONNECT_LOCAL,
        IDDI_REMOTE_COMPUTER,       HIDP_CONNECT_ANOTHER,
        IDDI_COMPNAME,              HIDP_CONNECT_ANOTHER,

        // New directory
        IDDI_SELECT_PATH,           HIDP_SCOPE_PATH,
        IDDI_DIRPATH,               HIDP_SCOPE_PATH,
        IDDI_BROWSE,                HIDP_SCOPE_BROWSE,
        IDDI_SELECT_ALIAS,          HIDP_SCOPE_ALIAS,
        IDDI_ALIAS,                 HIDP_SCOPE_ALIAS,
        IDDI_SELECT_USER_NAME,      HIDP_SCOPE_USER_NAME,
        IDDI_USER_NAME,             HIDP_SCOPE_USER_NAME,
        IDDI_SELECT_PASSWORD,       HIDP_SCOPE_PASSWORD,
        IDDI_PASSWORD,              HIDP_SCOPE_PASSWORD,
        IDDI_INCLUDE,               HIDP_SCOPE_INCLUDE,
        IDDI_EXCLUDE,               HIDP_SCOPE_EXCLUDE,
        IDDI_ACCOUNT_INFORMATION,   HIDP_ACCOUNT_INFORMATION,
        IDDI_INCLUSION,             HIDP_INCLUSION,

        // Performance Tuning
        IDDI_DEDICATED,             HIDP_DEDICATED,
        IDDI_USEDOFTEN,             HIDP_USEDOFTEN,
        IDDI_USEDOCCASIONALLY,      HIDP_USEDOCCASIONALLY,
        IDDI_NEVERUSED,             HIDP_NEVERUSED,
        IDDI_CUSTOMIZE,             HIDP_CUSTOMIZE,
        IDDI_ADVANCED,              HIDP_ADVANCED_CONFIG,
        IDDI_SELECT_INDEXING,       HIDP_INDEXING_PERFORMANCE,
        IDDI_SLIDER_INDEXING,       HIDP_INDEXING_PERFORMANCE,
        IDDI_SELECT_QUERYING,       HIDP_QUERY_PERFORMANCE,
        IDDI_SLIDER_QUERYING,       HIDP_QUERY_PERFORMANCE,

        0, 0 };


MMCBUTTON aContextButtons[] =
{
    // Start CI
    { comidStartCIButton, // 0
      comidStartCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMStartCI ),
      STRINGRESOURCE( srCMStartCIHelp )
    },

    // Stop CI
    { comidStopCIButton,  // 1
      comidStopCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMStopCI ),
      STRINGRESOURCE( srCMStopCIHelp )
    },

    // Pause CI
    { comidPauseCIButton,  // 1
      comidPauseCITop,
      TBSTATE_ENABLED,
      TBSTYLE_BUTTON,
      STRINGRESOURCE( srCMPauseCI ),
      STRINGRESOURCE( srCMPauseCIHelp )
    }
};

//
// Registry constants
//

WCHAR const wszSnapinPath[]  = L"Software\\Microsoft\\MMC\\SnapIns\\";
WCHAR const wszTriedEnable[] = L"TriedEnable";

//
// Global variables
//

extern long gulcInstances;
extern CStaticMutexSem gmtxTimer;
HINSTANCE ghInstance;

DECLARE_INFOLEVEL(cia)

//
// Function prototypes
//

SCODE StartMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE StopMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE PauseMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE DisabledMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );
SCODE SetStartStopMenu( IContextMenuCallback * piCallback, BOOL fTop = TRUE );


BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason, LPVOID dwReserved )
{
    BOOL fRetval = TRUE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if ( dwReason == DLL_PROCESS_ATTACH )
        {
            ghInstance = (HINSTANCE)hInstance;
            gmtxTimer.Init();
            InitStrings( ghInstance );
        }

    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ciaDebugOut(( DEB_ERROR,
                      "CIADMIN: Exception %#x in DllMain\n",
                      e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "CIADMIN: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "CIADMIN: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
}

// Detect if we are running on a server or a workstation
BOOL IsNTServer()
{
    BOOL fServer = FALSE;

    CRegAccess reg( RTL_REGISTRY_CONTROL,
                    L"ProductOptions" );

    WCHAR awcProductType[ MAX_PATH ];
    reg.Get( L"ProductType",
                  awcProductType,
                  sizeof awcProductType / sizeof WCHAR );

     // winnt, pdc/bdc, server.
     // note: 4.0 bdcs are LanmanNt, 5.0+ are spec'ed to be LansecNt

     if ( !_wcsicmp( awcProductType, L"WinNt" ) )
         fServer = FALSE;
     else if ( ( !_wcsicmp( awcProductType, L"LanmanNt" ) ) ||
               ( !_wcsicmp( awcProductType, L"LansecNt" ) ) ||
               ( !_wcsicmp( awcProductType, L"ServerNt" ) ) )
         fServer = TRUE;

    return fServer;
} //IsNTServer

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::QueryInterface
//
//  Synopsis:   Switch from one interface to another
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::QueryInterface( REFIID riid,
                                                       void ** ppvObject )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryInterface " ));

    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IComponentData == riid )
        *ppvObject = (IUnknown *)(IComponentData *)this;
    else if ( IID_IExtendPropertySheet == riid )
        *ppvObject = (IUnknown *)(IExtendPropertySheet *)this;
    else if ( IID_IExtendContextMenu == riid )
        *ppvObject = (IUnknown *)(IExtendContextMenu *)this;
    else if ( IID_IPersistStream == riid )
        *ppvObject = (IUnknown *)(IPersistStream *)this;
    else if ( IID_ISnapinAbout == riid )
        *ppvObject = (IUnknown *)(ISnapinAbout *)this;
    else if ( IID_ISnapinHelp == riid )
        *ppvObject = (IUnknown *)(ISnapinHelp *)this;
    else if ( IID_IExtendControlbar == riid )
        *ppvObject = (IUnknown *)(IExtendControlbar *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IComponentData *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::AddRef
//
//  Synopsis:   Increment ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapinData::AddRef()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::AddRef\n" ));
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::Release
//
//  Synopsis:   Deccrement ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapinData::Release()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Release\n" ));
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


SCODE STDMETHODCALLTYPE CCISnapinData::Initialize( IUnknown * pUnk )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Initialize\n" ));

    //
    // Parameter checking.
    //

    if ( 0 == pUnk )
        return E_INVALIDARG;

    // Ensure that contex menus are in correct location in menu array. 
    Win4Assert( comidAddScope == aContextMenus[comidAddScope].lCommandID );
    Win4Assert( comidAddCatalog == aContextMenus[comidAddCatalog].lCommandID );
    Win4Assert( comidRescanFullScope == aContextMenus[comidRescanFullScope].lCommandID );
    Win4Assert( comidMergeCatalog == aContextMenus[comidMergeCatalog].lCommandID );
    Win4Assert( comidStartCI == aContextMenus[comidStartCI].lCommandID );
    Win4Assert( comidStopCI == aContextMenus[comidStopCI].lCommandID );
    Win4Assert( comidPauseCI == aContextMenus[comidPauseCI].lCommandID );
    Win4Assert( comidRefreshProperties == aContextMenus[comidRefreshProperties].lCommandID );
    Win4Assert( comidEmptyCatalog == aContextMenus[comidEmptyCatalog].lCommandID );
    Win4Assert( comidTunePerfCITop == aContextMenus[comidTunePerfCITop].lCommandID );
    Win4Assert( comidStartCITop == aContextMenus[comidStartCITop].lCommandID );
    Win4Assert( comidStopCITop == aContextMenus[comidStopCITop].lCommandID );
    Win4Assert( comidPauseCITop == aContextMenus[comidPauseCITop].lCommandID );
    Win4Assert( comidRescanIncrementalScope == aContextMenus[comidRescanIncrementalScope].lCommandID );

    TRANSLATE_EXCEPTIONS;

    SCODE sc;

    TRY
    {
        do
        {
            //
            // Collect interfaces
            //

            sc = pUnk->QueryInterface( IID_IConsole, (void **)&_pFrame );

            if ( FAILED(sc) )
                break;
            
            sc = _pFrame->GetMainWindow(&_hFrameWindow);

            if ( FAILED(sc) )
                break;

            //sc = _pFrame->QueryInterface( IID_IHeaderCtrl, (void **)&_pHeader );
            //
            //if ( FAILED(sc) )
            //    break;

            sc = _pFrame->QueryInterface(IID_IConsoleNameSpace, (void **)&_pScopePane );

            if ( FAILED(sc) )
                break;
            
            _rootNode.Init( _pScopePane );
            _Catalogs.Init( _pScopePane );

            //
            // Initialize resources
            //

            IImageList * pImageList;

            sc = _pFrame->QueryScopeImageList( &pImageList );

            if ( FAILED(sc) )
                break;

            sc = InitImageResources( pImageList );

            pImageList->Release();

            if ( FAILED(sc) )
                break;
        }
        while ( FALSE );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciaDebugOut(( DEB_ERROR, "Exception 0x%x caught in CCISnapinData::Initialize\n", sc ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    //
    // Damage control
    //

    if ( FAILED(sc) )
    {
        if ( 0 != _pScopePane )
        {
            _pScopePane->Release();
            _pScopePane = 0;
        }

        if ( 0 != _pFrame )
        {
            _pFrame->Release();
            _pFrame = 0;
        }
    }

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::CreateComponent( IComponent * * ppComponent )
{
    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCISnapin * p = new CCISnapin( *this, _pChild );

        *ppComponent = p;
        _pChild = p;

    }
    CATCH( CException, e )
    {
        sc = E_FAIL;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


SCODE STDMETHODCALLTYPE CCISnapinData::Notify( IDataObject * pDO,
                                               MMC_NOTIFY_TYPE event,
                                               LPARAM arg,
                                               LPARAM param )
{
    ciaDebugOut(( DEB_ITRACE,
                  "CCISnapinData::Notify (pDO = 0x%x, event = 0x%x)\n",
                  pDO, event ));

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        switch ( event )
        {
        case MMCN_EXPAND:
            ShowFolder( (CCIAdminDO *)pDO,   // Cookie
                        (BOOL)arg,           // TRUE --> Expand, FALSE --> Contract
                        (HSCOPEITEM)param ); // Scope item selected
            break;

        case MMCN_DELETE:
            RemoveCatalog( (CCIAdminDO *)pDO );
            break;

        case MMCN_REMOVE_CHILDREN:
            if ( _rootNode.IsParent( (HSCOPEITEM)arg ) )
            {
                Win4Assert( _fIsExtension );
                sc = _Catalogs.ReInit();

                if ( SUCCEEDED(sc) )
                    sc = _rootNode.Delete();

                _fIsInitialized = FALSE;
            }
            break;

        default:
            ciaDebugOut(( DEB_WARN, "unhandled notify 0x%x\n", event ));
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::Notify\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::Destroy()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::Destroy\n" ));

    if ( 0 != _pFrame )
    {
        _pFrame->Release();
        _pFrame = 0;

        _pScopePane->Release();
        _pScopePane = 0;

        // It's MMC's responsibility to destroy IConsole pointer we give them
        // I checked with Gautam in mmc team and confirmed this.
        _pChild = 0;
    }

    return S_OK;
}

SCODE STDMETHODCALLTYPE CCISnapinData::QueryDataObject( MMC_COOKIE cookie,
                                                        DATA_OBJECT_TYPES type,
                                                        IDataObject * * ppDataObject )
{
    //ciaDebugOut(( DEB_ITRACE,
    //              "CCISnapinData::QueryDataObject (cookie = 0x%x, type = 0x%x)\n",
    //              cookie, type ));

    //
    // Minimal parameter validation
    //

    if ( 0 == ppDataObject )
        return E_INVALIDARG;

    //
    // Create a data object
    //

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        *ppDataObject = new CCIAdminDO( cookie, type, _fIsExtension ? 0 : _Catalogs.GetMachine() );
    }
    CATCH( CException, e )
    {
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetDisplayInfo( SCOPEDATAITEM * pScopeDataItem )
{
    //ciaDebugOut(( DEB_ITRACE, "CCISnapinData::GetDisplayInfo( 0x%x )\n", pScopeDataItem ));
    if (pScopeDataItem == NULL)
        return E_POINTER;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = E_UNEXPECTED;

    TRY
    {
        PCIObjectType * pType = (PCIObjectType *)pScopeDataItem->lParam;

        switch ( pType->Type() )
        {
        case PCIObjectType::RootNode:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = (WCHAR *)GetRootDisplay();

                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Catalog:
        {
            CCatalog * pCat = (CCatalog *)pScopeDataItem->lParam;

            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = (WCHAR *)pCat->GetCat( TRUE );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_Scope:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeDirectories );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_Properties:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeProperties );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Intermediate_UnfilteredURL:
        {
            if ( pScopeDataItem->mask == SDI_STR )
            {
                pScopeDataItem->displayname = STRINGRESOURCE( srNodeUnfiltered );
                sc = S_OK;
            }
            break;
        }

        case PCIObjectType::Property:
        case PCIObjectType::Directory:
        default:
            Win4Assert( !"Oops!" );
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::GetDisplayInfo\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::CompareObjects( IDataObject * lpDataObjectA,
                                                       IDataObject * lpDataObjectB )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::CompareObjects( 0x%x, 0x%x )\n", lpDataObjectA, lpDataObjectB ));

    if ( *((CCIAdminDO *)lpDataObjectA) == *((CCIAdminDO *)lpDataObjectB) )
        return S_OK;
    else
        return S_FALSE;
}

SCODE STDMETHODCALLTYPE CCISnapinData::AddMenuItems( IDataObject * piDataObject,
                                                     IContextMenuCallback * piCallback,
                                                     long * pInsertionAllowed )
{
    if ( 0 == piDataObject )
        return E_UNEXPECTED;

    if ( 0 == (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP ) )
    {
        ciaDebugOut(( DEB_WARN, "Menu Insertion not allowed.\n" ));
        return S_OK;
    }

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;

        ciaDebugOut(( DEB_ITRACE, "CCISnapinData::AddMenuItems (cookie = 0x%x, type = 0x%x)\n",
                      pDO->Cookie(), pDO->Type() ));

        if ( pDO->Type() == CCT_RESULT )

        {
            if ( SUCCEEDED(sc) && pDO->IsACatalog() )
            {
                sc = piCallback->AddItem( &aContextMenus[comidMergeCatalog] );
            }
            else if ( SUCCEEDED(sc) && pDO->IsADirectory() )
            {

                CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );
                if (MachineAdmin.IsCIStarted()) 
                {
                    // Add both Full and Incremental rescan options to menu.
                    sc = piCallback->AddItem( &aContextMenus[comidRescanFullScope] );
                    if ( SUCCEEDED(sc) )
                        sc = piCallback->AddItem( &aContextMenus[comidRescanIncrementalScope] );
                }

            }
            else
                ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                              pDO->Cookie(), pDO->Type() ));
        }
        else if ( SUCCEEDED(sc) && pDO->Type() == CCT_SCOPE )
        {
            if ( (pDO->IsRoot() || pDO->IsStandAloneRoot()) )
            {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
                {
                    //
                    // Adjust state accordingly.
                    //
                    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

                    if ( MachineAdmin.IsCIStarted() )
                    {
                        sc = StartMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                    else if ( MachineAdmin.IsCIPaused() )
                    {
                        sc = PauseMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                    else
                    {
                        Win4Assert( MachineAdmin.IsCIStopped() );
                        sc = StopMenu( piCallback );

                        if (SUCCEEDED(sc))
                        {
                            aContextMenus[comidTunePerfCITop].fFlags = MF_ENABLED;
                            sc = piCallback->AddItem( &aContextMenus[comidTunePerfCITop] );
                        }
                    }
                }

                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddCatalog] );
                }
            }
            else if ( pDO->IsACatalog() )
            {
                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddScope] );
                }

                if (SUCCEEDED(sc) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) )
                {
                    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

                    //
                    // Only append individual catalog control if service is running.
                    //

                    if ( MachineAdmin.IsCIStarted() || MachineAdmin.IsCIPaused() )
                    {

                        // Menu item to trigger clean up of the catalog

                        aContextMenus[comidEmptyCatalog].fFlags = MF_GRAYED;
                        piCallback->AddItem( &aContextMenus[comidEmptyCatalog] );

                        aContextMenus[comidMergeCatalog].fFlags = MF_ENABLED;

                        XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                        if ( xCat->IsStarted() )
                        {
                            aContextMenus[comidMergeCatalog].fFlags = MF_ENABLED;
                            sc = StartMenu( piCallback, FALSE );
                        }
                        else if ( xCat->IsPaused() )
                        {
                            aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                            sc = PauseMenu( piCallback, FALSE );
                        }
                        else
                        {
                            Win4Assert( xCat->IsStopped() );
                            aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                            sc = StopMenu( piCallback, FALSE );
                        }
                    }
                    else
                    {
                        // Menu item to trigger clean up of the catalog

                        aContextMenus[comidEmptyCatalog].fFlags = MF_ENABLED;
                        piCallback->AddItem( &aContextMenus[comidEmptyCatalog] );

                        aContextMenus[comidMergeCatalog].fFlags = MF_GRAYED;
                        sc = DisabledMenu( piCallback, FALSE );
                    }

                    if (SUCCEEDED(sc)) 
                    {
                        sc = piCallback->AddItem( &aContextMenus[comidMergeCatalog] );
                    }
                }
            }
            else if ( pDO->IsADirectoryIntermediate() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) )
            {
                if (SUCCEEDED(sc))
                {
                    sc = piCallback->AddItem( &aContextMenus[comidAddScope] );
                }
            }
            else if ( pDO->IsAPropertyIntermediate() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) )
            {
                if (SUCCEEDED(sc))
                {
                    sc = piCallback->AddItem( &aContextMenus[comidRefreshProperties] );
                }
            }
            else
            {
                ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                              pDO->Cookie(), pDO->Type() ));
            }
        }
        else
        {
            ciaDebugOut(( DEB_WARN, "No menu items for (cookie = 0x%x, type = 0x%x)\n",
                          pDO->Cookie(), pDO->Type() ));
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::AddMenuItems\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::Command( long lCommandID,
                                                IDataObject * piDataObject )
{
    if ( 0 == piDataObject )
        return E_POINTER;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;

        switch ( lCommandID )
        {
        case comidRescanFullScope:
        {
            CScope * pScope = pDO->GetScope();

            Win4Assert( 0 != pScope );

            //
            // Make sure the user wants to do a full rescan.
            //

            WCHAR awcMsg[MAX_PATH];
            WCHAR awcTemp[2 * MAX_PATH];

            LoadString( ghInstance, MSG_RESCAN_FULL_SCOPE_EXPLAIN, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
            wsprintf( awcTemp, awcMsg, pScope->GetPath() );

            int iResult;

            // Pop up YES/NO box
            sc = _pFrame->MessageBox( awcTemp,
                                    STRINGRESOURCE( srMsgRescanFull ),
                                    MB_YESNO | /* MB_HELP | */
                                    MB_ICONWARNING | MB_DEFBUTTON2 |
                                    MB_APPLMODAL,
                                    &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                // Rescan( TRUE ) means "Full scan"
                case IDYES:
                {
                    pScope->Rescan( TRUE );
                    break;
                }
                case IDNO:
                {
                    // Do nothing.
                    break;
                }

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_RESCAN );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }
        case comidRescanIncrementalScope:
        {
            CScope * pScope = pDO->GetScope();

            Win4Assert( 0 != pScope );

            //
            // Make sure the user wants to do an incremental rescan.
            //

            WCHAR awcMsg[MAX_PATH];
            WCHAR awcTemp[2 * MAX_PATH];

            LoadString( ghInstance, MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
            wsprintf( awcTemp, awcMsg, pScope->GetPath() );

            int iResult;

            // Pop up YES/NO box
            sc = _pFrame->MessageBox( awcTemp,
                                    STRINGRESOURCE( srMsgRescanIncremental ),
                                    MB_YESNO | /* MB_HELP | */
                                    MB_ICONWARNING | MB_DEFBUTTON2 |
                                    MB_APPLMODAL,
                                    &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                // Rescan( FALSE ) means "Incremental scan"
                case IDYES:
                {
                    pScope->Rescan( FALSE );
                    break;
                }
                case IDNO:
                {
                    // Do nothing.
                    break;
                }

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_RESCAN );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }

        case comidRefreshProperties:
        {
            // The user has explicitly requested a refresh of the list.
            // Delete the old list and recreate it.
            CCatalog * pcat = pDO->GetCatalog();
            
            if ( CCISnapin::Properties == _pChild->GetCurrentView() &&
                 _pChild->GetCurrentCatalog() == pcat )
            {
                pcat->ClearProperties( _pChild->ResultPane() );
                pcat->DisplayProperties( TRUE, _pChild->ResultPane() );
            }

            break;
        }

        case comidEmptyCatalog:
        {
           // NOTE: The service must be stopped before we can do this. Deleting
           //       files under an active catalog leads to unpredictable results.

           int iResult;

           sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgEmptyCatalogPrompt ),
                                     STRINGRESOURCE( srMsgEmptyCatalogAsk ),
                                     MB_YESNO | /* MB_HELP | */
                                       MB_ICONWARNING | MB_DEFBUTTON2 |
                                       MB_APPLMODAL,
                                     &iResult );

           if ( SUCCEEDED(sc) )
           {
               switch ( iResult )
               {
               case IDYES:
               {

                   CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );
                   XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                   //xCat->EmptyThisCatalog();

                   MachineAdmin.RemoveCatalogFiles(pDO->GetCatalog()->GetCat(TRUE));
                   break;
               }

               case IDNO:

                   // Do nothing.
                   break;

               default:
                   break;
               }
           }
           break;
        }

        case comidAddScope:
        {
            CCatalog * pCat = pDO->GetCatalog();

            Win4Assert( 0 != pCat );

            INT_PTR err = DialogBoxParam( ghInstance,                        // Application instance
                            MAKEINTRESOURCE( IDD_ADD_SCOPE ),  // Dialog box
                            _hFrameWindow,                     // main window
                            AddScopeDlg,                       // Dialog box function
                            (LPARAM)pCat );                    // User parameter

            if ( -1 == err )
                THROW( CException() );

            Refresh();  // Update all result pane(s)

            break;
        }

        case comidMergeCatalog:
        {
            CCatalog * pCat = pDO->GetCatalog();

            Win4Assert( 0 != pCat );

            //
            // Make sure the user wants to remove scope.
            //

            int iResult;

            sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgMerge ),
                                      STRINGRESOURCE( srMsgMerge ),
                                        MB_YESNO | /* MB_HELP | */
                                        MB_ICONWARNING | MB_DEFBUTTON2 |
                                        MB_APPLMODAL,
                                      &iResult );

            if ( SUCCEEDED(sc) )
            {
                switch ( iResult )
                {
                case IDYES:
                {
                    pCat->Merge();
                    break;
                }
                case IDNO:
                case IDCANCEL:
                    // Do nothing.
                    break;

                /* Help is not being used...
                case IDHELP:
                {
                    DisplayHelp( _hFrameWindow, HIDD_MERGE_CATALOG );
                    break;
                }
                */

                default:
                    break;
                }
            }
            break;
        }

        case comidAddCatalog:
        {
            Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );

            INT_PTR err = DialogBoxParam( ghInstance,                         // Application instance
                            MAKEINTRESOURCE( IDD_ADD_CATALOG ), // Dialog box
                            _hFrameWindow,                      // main frame window
                            AddCatalogDlg,                      // Dialog box function
                            (LPARAM)&_Catalogs );               // User parameter


            if ( -1 == err )
                THROW( CException() );

            // Ensure that only and all active catalogs are listed.
            _Catalogs.UpdateActiveState();

            Refresh();  // Update all result pane(s)

            break;
        }


        case comidStartCI:
        case comidStartCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MaybeEnableCI( MachineAdmin );

                MachineAdmin.StartCI();

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();

                _Catalogs.SetSnapinData( this );
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Start();

                // We are using the top-level buttons to control individual catalogs. Accordingly, they
                // should be updated to reflect the selected catalog's state.
                // The toolbar may not be created yet, so check if it is non-zero

                if ( xCat->IsStarted() && _pChild->_xToolbar.GetPointer() )
                {
                    // This is more efficient than calling CCISnapinData::SetButtonState

                    for ( CCISnapin * pCurrent = _pChild;
                         0 != pCurrent;
                         pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, TRUE);
                    }
                }
            }

            break;
        }

        case comidStopCI:
        case comidStopCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MachineAdmin.StopCI();

                // The toolbar may not be created yet, so check if it is non-zero
                if ( MachineAdmin.IsCIStopped() && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Stop();

                // The toolbar may not be created yet, so check if it is non-zero
                if ( xCat->IsStopped()  && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }
            }
            break;
        }

        case comidPauseCI:
        case comidPauseCITop:
        {
            CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

            if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
            {
                MachineAdmin.PauseCI();

                // The toolbar may not be created yet, so check if it is non-zero

                if ( MachineAdmin.IsCIPaused()  && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }

                // Ensure that only and all active catalogs are listed.
                _Catalogs.UpdateActiveState();
            }
            else
            {
                Win4Assert( pDO->IsACatalog() );

                XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                xCat->Pause();

                // The toolbar may bot be created yet, so check if it is non-zero
                if ( xCat->IsPaused() && _pChild->_xToolbar.GetPointer() )
                {
                    for ( CCISnapin * pCurrent = _pChild;
                          0 != pCurrent;
                          pCurrent = pCurrent->Next() )
                    {
                        pCurrent->_xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                        pCurrent->_xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
                    }
                }
            }
            break;
        }

        case comidTunePerfCITop:
        {
           Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );

           if ( IsNTServer() )
           {
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_USAGE_ON_SERVER ), // Dialog box
                              _hFrameWindow,                      // main frame window
                              SrvTunePerfDlg,                      // Dialog box function
                              (LPARAM)&_Catalogs );               // User parameter
           }
           else
           {
              DialogBoxParam( ghInstance,                         // Application instance
                              MAKEINTRESOURCE( IDD_USAGE_ON_WORKSTATION ), // Dialog box
                              _hFrameWindow,                      // main frame window
                              WksTunePerfDlg,                      // Dialog box function
                              (LPARAM)&_Catalogs );               // User parameter
           }


           // Ensure that only and all active catalogs are listed.
           _Catalogs.UpdateActiveState();

           Refresh();  // Update all result pane(s)

           break;
        }

        default:
            sc = E_UNEXPECTED;
            break;
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapinData::Command\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::GetClassID, public
//
//  Synopsis:   Identifies class of storage
//
//  Arguments:  [pClassID] -- Class written here.
//
//  Returns:    S_OK
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::GetClassID( CLSID * pClassID )
{
    *pClassID = guidCISnapin;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::IsDirty, public
//
//  Returns:    TRUE if snapin data has not been saved.
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::IsDirty()
{
    return (_fDirty) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::Load, public
//
//  Synopsis:   Load persistent state
//
//  Arguments:  [pStm] -- State stored in stream.
//
//  Returns:    S_OK on successful load
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::Load( IStream * pStm )
{
    //
    // Read in machine name.
    //

    ULONG cbRead = 0;
    ULONG cc = 0;

    SCODE sc = pStm->Read( &cc, sizeof(cc), &cbRead );

    if ( S_OK != sc || cbRead != sizeof(cc) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not load catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    XGrowable<WCHAR> xwcsMachine( cc );

    sc = pStm->Read( xwcsMachine.Get(), cc * sizeof(WCHAR), &cbRead );

    if ( S_OK != sc || cbRead != cc * sizeof(WCHAR) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not load catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    _Catalogs.SetMachine( xwcsMachine.Get() );

    _fDirty = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::Save, public
//
//  Synopsis:   Save persistent state
//
//  Arguments:  [pStm]        -- Stream into which state can be stored.
//              [fClearDirty] -- TRUE if dirty bit should be cleared
//
//  Returns:    S_OK if save succeeded.
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::Save( IStream * pStm, BOOL fClearDirty )
{
    ULONG cbWritten;
    ULONG cc = wcslen( _Catalogs.GetMachine() ) + 1;

    SCODE sc = pStm->Write( &cc, sizeof(cc), &cbWritten );

    if ( S_OK != sc || cbWritten != sizeof(cc) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not save catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    sc = pStm->Write( _Catalogs.GetMachine(), cc * sizeof(WCHAR), &cbWritten );

    if ( S_OK != sc || cbWritten != cc * sizeof(WCHAR) )
    {
        ciaDebugOut(( DEB_ERROR, "Could not save catalog name: 0x%x\n", sc ));
        return E_FAIL;
    }

    if ( fClearDirty )
        _fDirty = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCISnapinData::GetSizeMax, public
//
//  Synopsis:   Computes size of persistent state
//
//  Arguments:  [pcbSize] -- Size returned here.
//
//  Returns:    S_OK
//
//  History:    14-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CCISnapinData::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    pcbSize->HighPart = 0;
    pcbSize->LowPart =  sizeof(ULONG) +
                        sizeof(WCHAR) * (wcslen(_Catalogs.GetMachine()) + 1);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::CCISnapinData
//
//  Synopsis:   Constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapinData::CCISnapinData( )
        : _pFrame( 0 ),
          _pScopePane( 0 ),
          _pChild( 0 ),
          _uRefs( 1 ),
          _fDirty( TRUE ),
          _fIsInitialized( FALSE ),
          _fIsExtension( FALSE ),
          _fTriedEnable( FALSE ),
          _notifHandle( 0 ),
          _fURLDeselected( FALSE )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::~CCISnapinData
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapinData::~CCISnapinData()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::~CCISnapinData\n" ));

    Win4Assert( 0 == _pFrame );
    Win4Assert( 0 == _pScopePane );

    // Tell catalogs that snapindata is no longer valid!
    _Catalogs.SetSnapinData(0);

    InterlockedDecrement( &gulcInstances );
}

void CCISnapinData::Refresh()
{
    _Catalogs.DisplayScope( 0xFFFFFFFF );

    for ( CCISnapin * pCurrent = _pChild;
          0 != pCurrent;
          pCurrent = pCurrent->Next() )
    {
        pCurrent->Refresh();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::QueryInterface
//
//  Synopsis:   Switch from one interface to another
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapin::QueryInterface( REFIID riid,
                                                   void ** ppvObject )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryInterface\n" ));


    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IComponent == riid )
        *ppvObject = (IUnknown *)(IComponent *)this;
    else if ( IID_IExtendPropertySheet == riid )
        *ppvObject = (IUnknown *)(IExtendPropertySheet *)this;
    else if ( IID_IExtendContextMenu == riid )
        *ppvObject = (IUnknown *)(IExtendContextMenu *)this;
    else if ( IID_IExtendControlbar == riid )
        *ppvObject = (IUnknown *)(IExtendControlbar *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IComponent *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::AddRef
//
//  Synopsis:   Increment ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapin::AddRef()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::AddRef\n" ));
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::Release
//
//  Synopsis:   Deccrement ref count
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCISnapin::Release()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Release\n" ));
    unsigned long uTmp = InterlockedDecrement( &_uRefs );
    
    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


SCODE STDMETHODCALLTYPE CCISnapin::Initialize( IConsole * lpFrame )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Initialize\n" ));

    //
    // Parameter checking.
    //

    if ( 0 == lpFrame )
        return E_INVALIDARG;

    _pFrame = lpFrame;
    _pFrame->AddRef();

    SCODE sc;

    do
    {
        //
        // Collect interfaces
        //

        sc = _pFrame->QueryInterface( IID_IHeaderCtrl, (void **)&_pHeader );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryInterface( IID_IResultData, (void **)&_pResultPane );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryConsoleVerb( &_pConsoleVerb );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->QueryInterface( IID_IDisplayHelp, (void **)&_pDisplayHelp );

        if ( FAILED(sc) )
            break;

        //
        // Initialize resources
        //

        sc = _pFrame->QueryResultImageList( &_pImageList );

        if ( FAILED(sc) )
            break;

        sc = _pFrame->GetMainWindow(&_hFrameWindow);

        if ( FAILED(sc) )
            break;

        //
        // Initialize catalogs
        //

        // _SnapinData.GetCatalogs().InitHeader( _pHeader );

    }
    while ( FALSE );



    //
    // Damage control
    //

    if ( FAILED(sc) )
    {
        if ( 0 != _pImageList )
        {
            _pImageList->Release();
            _pImageList = 0;
        }

        if ( 0 != _pResultPane )
        {
            _pResultPane->Release();
            _pResultPane = 0;
        }

        if ( 0 != _pConsoleVerb )
        {
            _pConsoleVerb->Release();
            _pConsoleVerb = 0;
        }

        if ( 0 != _pHeader )
        {
            _pHeader->Release();
            _pHeader = 0;
        }

        if ( 0 != _pFrame )
        {
            _pFrame->Release();
            _pFrame = 0;
        }
    }

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::Notify( IDataObject * pDataObject,
                                           MMC_NOTIFY_TYPE event,
                                           LPARAM arg,
                                           LPARAM param )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Notify (pDO = 0x%x, event = 0x%x)\n",
                  pDataObject, event ));

    CCIAdminDO * pDO = (CCIAdminDO *)pDataObject;

    TRANSLATE_EXCEPTIONS;

    SCODE sc = S_OK;

    TRY
    {
        switch ( event )
        {
        case MMCN_SHOW:
            ShowItem( pDO,                 // Cookie
                      (BOOL)arg,           // TRUE --> Select, FALSE --> Deselect
                      (HSCOPEITEM)param ); // Scope item selected
            break;

        case MMCN_SELECT:
            if ( (CCIAdminDO *) -2 != pDO )
                EnableStandardVerbs( pDO );
            break;

/*
        case MMCN_COLUMN_CLICK:
            // No need to sort on these columns in this view
            sc = _pResultPane->Sort(arg, RSI_DESCENDING, 0);
            break;
*/

        case MMCN_DBLCLICK:

            if (pDO->Type() == CCT_SCOPE)
            {
                // This is an undocumented feature. Return S_FALSE and that will
                // cause the appropriate node in the scope pane to automagically expand
                // and select the right node. Figured this out after spending a couple of
                // hours trying to find a documented way of doing this...
                // Other components use this undocumented feature.

                sc = S_FALSE;
            }
            else if (pDO->IsADirectory())
            {
                CScope * pScope = pDO->GetScope();
    
                Win4Assert( 0 != pScope );
    
                DialogBoxParam( ghInstance,                        // Application instance
                                MAKEINTRESOURCE( IDD_ADD_SCOPE ),  // Dialog box
                                _hFrameWindow,                     // main window
                                ModifyScopeDlg,                    // Dialog box function
                                (LPARAM)pScope );                  // User parameter
    
                Refresh();  // Update all result pane(s)
            }
            else if (pDO->IsAProperty())
            {
                XPtr<CPropertyPropertySheet1> xPropSheet( 
                          new CPropertyPropertySheet1( ghInstance, 
                                                       _SnapinData.NotifyHandle(),
                                                       pDO->GetProperty(),
                                                       pDO->GetCatalog() 
                                                      ));
                LPCPROPSHEETPAGE psp = xPropSheet->GetPropSheet();

                PROPSHEETHEADER psh;

                psh.dwSize = sizeof (PROPSHEETHEADER);
                psh.dwFlags = PSH_PROPSHEETPAGE;
                psh.hwndParent = _hFrameWindow;
                psh.hInstance = ghInstance;
                psh.pszIcon = NULL;
                psh.pszCaption = pDO->GetProperty()->GetPropSet();
                psh.nPages = 1;
                psh.ppsp = psp;
                
                PropertySheet(&psh);
                xPropSheet.Acquire();
            }
            break;

        case MMCN_PROPERTY_CHANGE:
        {
            PCIObjectType * pType = (PCIObjectType *)param;
            if ( pType->Type() == PCIObjectType::Property )
            {
                ciaDebugOut(( DEB_ITRACE, "PROPERTY CHANGE\n" ));

                HRESULTITEM hItem;

                sc = _pResultPane->FindItemByLParam( param, &hItem );

                if ( SUCCEEDED(sc) )
                {
                    RESULTDATAITEM rdi;
                    ZeroMemory(&rdi, sizeof(rdi));

                    rdi.mask   = RDI_IMAGE;
                    rdi.itemID = hItem;
                    rdi.nImage = ICON_MODIFIED_PROPERTY;

                    sc = _pResultPane->SetItem( &rdi );
                }
            }
            break;
        } // case

        case MMCN_DELETE:
            if ( pDO->IsACatalog() )
                _SnapinData.RemoveCatalog( pDO );
            else
            {
                Win4Assert( pDO->IsADirectory() );
                RemoveScope( pDO );
            }
            break;

        case MMCN_HELP:
        {
            LPOLESTR lpHelpFile;

            if ( S_OK == _SnapinData.GetHelpTopic2(&lpHelpFile) )
               _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;


        case MMCN_CONTEXTHELP:
        {
            LPOLESTR lpHelpFile;
   
            if ( S_OK == _SnapinData.GetHelpTopic2(&lpHelpFile) )
                _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;

        case MMCN_SNAPINHELP:
        {
            LPOLESTR lpHelpFile;

            if ( S_OK == _SnapinData.GetHelpTopic2(&lpHelpFile) )
               _pDisplayHelp->ShowTopic(lpHelpFile);
        }
        break;


        } // switch
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "Exception 0x%x in CCISnapin::Notify\n", e.GetErrorCode() ));
        sc = E_UNEXPECTED;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::Destroy( MMC_COOKIE cookie )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::Destroy\n" ));

    if ( 0 != _pFrame )
    {
        _pFrame->Release();
        _pFrame = 0;

        _pHeader->Release();
        _pHeader = 0;

        _pResultPane->Release();
        _pResultPane = 0;

        _pImageList->Release();
        _pImageList = 0;

        _pConsoleVerb->Release();
        _pConsoleVerb = 0;

        _pDisplayHelp->Release();
        _pDisplayHelp = 0;
    }

    return S_OK;
}

SCODE STDMETHODCALLTYPE CCISnapin::QueryDataObject( MMC_COOKIE cookie,
                                                    DATA_OBJECT_TYPES type,
                                                    IDataObject * * ppDataObject )
{
    return _SnapinData.QueryDataObject( cookie, type, ppDataObject );
}

SCODE STDMETHODCALLTYPE CCISnapin::GetResultViewType( MMC_COOKIE cookie,
                                                      BSTR * ppViewType,
                                                      long * pViewOptions )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::GetResultViewType (cookie = 0x%x)\n", cookie ));


    CIntermediate *pIntermediate = (CIntermediate *) cookie;
    if ( 0 != pIntermediate &&
         PCIObjectType::Intermediate_UnfilteredURL == pIntermediate->Type() )
    {
        Win4Assert(pIntermediate);
        // To display a URL
        WCHAR wszSysPath[MAX_PATH + 1];
        WCHAR wszPath[MAX_PATH + 1];

        GetSystemWindowsDirectory(wszSysPath, MAX_PATH);
        wcscpy(wszPath, L"file://");
        wcscat(wszPath, wszSysPath);

        wcscat(wszPath, L"\\Help\\ciadmin.htm#machine=");
        wcscat(wszPath, _SnapinData.GetCatalogs().GetMachine());
        wcscat(wszPath, L",catalog=");
        wcscat(wszPath, pIntermediate->GetCatalog().GetCat(TRUE));

        MakeOLESTR(ppViewType, wszPath);
        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS ;
        return S_OK;
    }
    else
    {
        //
        // S_FALSE --> Use listview
        //

        return S_FALSE;
    }
}

SCODE STDMETHODCALLTYPE CCISnapin::GetDisplayInfo( RESULTDATAITEM * pResult )
{
    //ciaDebugOut(( DEB_ITRACE, "CCISnapin::GetDisplayInfo (itemID = 0x%x, bScopeItem = %s, lParam = 0x%x)\n",
    //              pResult->itemID, pResult->bScopeItem ? "TRUE" : "FALSE", pResult->lParam ));
    
    if ( 0 == pResult )
        return E_POINTER;

    if ( pResult->mask & RDI_STR )
    {
        PCIObjectType * pType = (PCIObjectType *)pResult->lParam;

        switch ( pType->Type() )
        {
        case PCIObjectType::RootNode:
        {
            switch ( pResult->nCol )
            {
               case 0:
                  pResult->str = (WCHAR *)_SnapinData.GetRootDisplay();
                  break;
               case 1:
                  pResult->str = (WCHAR *)_SnapinData.GetType();
                  break;
               case 2:
                  pResult->str = (WCHAR *)_SnapinData.GetDescription();
                  break;
               default:
                  Win4Assert(!"How did we get here?");
                  pResult->str = L"";
                  break;
            }

            if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                pResult->nImage = ICON_APP;

            break;
        }

        case PCIObjectType::Catalog:
        {
            CCatalog * pCat = (CCatalog *)pResult->lParam;
            pCat->GetDisplayInfo( pResult );
            break;
        }

        case PCIObjectType::Directory:
        {
            CScope * pScope = (CScope *)pResult->lParam;
            pScope->GetDisplayInfo( pResult );
            break;
        }

        case PCIObjectType::Property:
        {
            CCachedProperty * pProperty = (CCachedProperty *)pResult->lParam;
            pProperty->GetDisplayInfo( pResult );
            break;
        }

        case PCIObjectType::Intermediate_Scope:
        {
            if ( 0 == pResult->nCol )
                pResult->str = STRINGRESOURCE( srNodeDirectories );
            else
                pResult->str = L"";

            if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                pResult->nImage = ICON_FOLDER;

            break;
        }

        case PCIObjectType::Intermediate_Properties:
        {
            if ( 0 == pResult->nCol )
                pResult->str = STRINGRESOURCE( srNodeProperties );
            else
                pResult->str = L"";

            if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                pResult->nImage = ICON_FOLDER;

            break;
        }

        case PCIObjectType::Intermediate_UnfilteredURL:
        {
            if ( 0 == pResult->nCol )
                pResult->str = STRINGRESOURCE( srNodeUnfiltered );
            else
                pResult->str = L"";

            if ( pResult->mask & RDI_IMAGE && 0 == pResult->nCol )
                pResult->nImage = ICON_URL;

            break;
        }
        }
    }
    else
        return E_UNEXPECTED;

    return S_OK;
}

SCODE STDMETHODCALLTYPE CCISnapin::CompareObjects( IDataObject * lpDataObjectA,
                                                   IDataObject * lpDataObjectB )
{
    return _SnapinData.CompareObjects( lpDataObjectA, lpDataObjectB );
}

SCODE STDMETHODCALLTYPE CCISnapin::CreatePropertyPages( IPropertySheetCallback * lpProvider,
                                                        LONG_PTR handle,
                                                        IDataObject * lpIDataObject )
{
    return _SnapinData.CreatePropertyPages( lpProvider, handle, lpIDataObject );
}

SCODE STDMETHODCALLTYPE CCISnapinData::CreatePropertyPages( IPropertySheetCallback * lpProvider,
                                                            LONG_PTR handle,
                                                            IDataObject * lpIDataObject )
{
    SCODE sc = S_OK;
    _notifHandle = handle;

    TRY
    {
        CCIAdminDO * pDO = (CCIAdminDO *)lpIDataObject;

        CCatalog * pCat = pDO->GetCatalog();
        CScope * pScope = pDO->GetScope();
        CCachedProperty * pProperty = pDO->GetProperty();

        if ( pDO->Type() == CCT_SNAPIN_MANAGER )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is Catalogs)\n" ));

            XPtr<CIndexSrvPropertySheet0> xFoo( new CIndexSrvPropertySheet0( ghInstance, handle, &_Catalogs ));

            if (S_OK == lpProvider->AddPage( xFoo->GetHandle()) )
                xFoo.Acquire();
        }
        else if ( 0 != pProperty )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is property %ws)\n",
                          pProperty->GetProperty() ));

            XPtr<CPropertyPropertySheet1> xFoo( new CPropertyPropertySheet1( ghInstance, handle, pProperty, pCat ));

            if ( S_OK == lpProvider->AddPage( xFoo->GetHandle()) )
                xFoo.Acquire();
        }
        else if ( 0 != pScope )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is scope %ws)\n",
                          pScope->GetPath() ));
        }
        //
        // NOTE: The following has to be last, because you can derive a pCat from the
        //       preceding choices.
        //

        else if ( 0 != pCat )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is catalog %ws)\n",
                          pCat->GetCat( TRUE ) ));

            XPtr<CCatalogBasicPropertySheet> xCat1( new CCatalogBasicPropertySheet( ghInstance, handle, pCat ));

            if (S_OK == lpProvider->AddPage( xCat1->GetHandle()) )
                xCat1.Acquire();

            XPtr<CIndexSrvPropertySheet2> xCP2( new CIndexSrvPropertySheet2( ghInstance, handle, pCat ));

            if ( S_OK == lpProvider->AddPage( xCP2->GetHandle()) )
                 xCP2.Acquire();

            XPtr<CIndexSrvPropertySheet1> xIS1( new CIndexSrvPropertySheet1( ghInstance, handle, pCat ));

            if (S_OK == lpProvider->AddPage( xIS1->GetHandle()) )
                xIS1.Acquire();

        }
        else if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages (object is root)\n" ));

            XPtr<CIndexSrvPropertySheet1> xIS1( new CIndexSrvPropertySheet1( ghInstance, handle, &_Catalogs) );

            if (S_OK == lpProvider->AddPage( xIS1->GetHandle()) )
                xIS1.Acquire();

            XPtr<CIndexSrvPropertySheet2> xIS2( new CIndexSrvPropertySheet2( ghInstance, handle, &_Catalogs) );

            if (S_OK == lpProvider->AddPage( xIS2->GetHandle()) )
                xIS2.Acquire();
        }
        else
        {
            ciaDebugOut(( DEB_ITRACE, "CCISnapin::CreatePropertyPages.  Invalid call. (cookie = 0x%x, type = 0x%x)\n",
                          ((CCIAdminDO *)lpIDataObject)->Cookie(),
                          ((CCIAdminDO *)lpIDataObject)->Type() ));
        }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCISnapin::CreatePropertyPages: Caught error 0x%x\n", e.GetErrorCode() ));

        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::QueryPagesFor( IDataObject * lpDataObject )
{
    return _SnapinData.QueryPagesFor( lpDataObject );
}


SCODE STDMETHODCALLTYPE CCISnapin::SetControlbar( LPCONTROLBAR pControlbar)
{
    // Notes: This implementation is based on the MMC
    // sample Step4.

    if (0 == pControlbar)
    {
        _xControlbar.Free();
        return S_OK;
    }

    SCODE sc = S_OK;

    // cache the incoming pointer and AddRef it
    _xControlbar.Set(pControlbar);
    _xControlbar->AddRef();


    // If we haven't yet created a toolbar, create now
    if (0 == _xToolbar.GetPointer())
    {
        Win4Assert(0 == _xBmpToolbar.Get());

        sc  = pControlbar->Create(TOOLBAR, this, _xToolbar.GetIUPointer());

        if (SUCCEEDED(sc))
        {
            _xBmpToolbar.Set(LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_TOOLBAR_SMALL)));
            sc = (_xBmpToolbar.Get() ? S_OK : E_FAIL);
        }

        if (SUCCEEDED(sc))
            sc = _xToolbar->AddBitmap(sizeof aContextButtons / sizeof aContextButtons[0],
                                      _xBmpToolbar.Get(), 16, 16, RGB(255, 0, 255));

        if (SUCCEEDED(sc))
            sc = _xToolbar->AddButtons(sizeof aContextButtons / sizeof aContextButtons[0],
                                   aContextButtons);
    }
    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::ControlbarNotify( MMC_NOTIFY_TYPE event,
                                                     LPARAM arg,
                                                     LPARAM param)
{
    Win4Assert(_xControlbar.GetPointer() &&
               _xToolbar.GetPointer() &&
               _xBmpToolbar.Get());

    if (MMCN_SELECT == event && !((BOOL)LOWORD(arg)) && _SnapinData.IsURLDeselected() )
        return E_POINTER;

    SCODE sc = S_OK;

    BOOL fPaused = FALSE;
    BOOL fStopped = FALSE;
    BOOL fStarted = FALSE;

    TRY
    {
        if (MMCN_SELECT == event)
        {
            LPDATAOBJECT pDataObject = (LPDATAOBJECT) param;
            if( NULL == pDataObject )
              return S_FALSE;

            // Completely random MMC behavior (apparently).

            if ( -2 == param )
                return S_FALSE;

            CCIAdminDO * pDO = (CCIAdminDO *)pDataObject;

            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);

            ciaDebugOut((DEB_ITRACE, 
                         "select event: scope: %d, selection %d, lparam: 0x%x\n", 
                         bScope, bSelect, param));

            CMachineAdmin   MachineAdmin( _SnapinData.GetCatalogs().IsLocalMachine() ? 
                                          0 : _SnapinData.GetCatalogs().GetMachine() );

            if (bScope) // scope item selected
            {
                if (pDO->IsRoot() || pDO->IsStandAloneRoot() )
                {
                    sc = _xControlbar->Attach(TOOLBAR, _xToolbar.GetPointer());

                    if ( SUCCEEDED(sc) )
                    {
                        if ( MachineAdmin.IsCIStarted() )
                            fStarted = TRUE;
                        else if ( MachineAdmin.IsCIPaused() )
                            fPaused = TRUE;
                        else
                        {
                            Win4Assert( MachineAdmin.IsCIStopped() );
                            fStopped = TRUE;
                        }
                    }
                }
                else
                {
                    sc = _xControlbar->Detach(_xToolbar.GetPointer());

                    // If the URL on scope pane is deselected, remember that
                    _SnapinData.SetURLDeselected( pDO->IsURLIntermediate() && bSelect == FALSE );
                }
            }
            // result list item selected
            else
            {
                if ( pDO->IsACatalog() )
                {
                    XPtr<CCatalogAdmin> xCat( MachineAdmin.QueryCatalogAdmin( pDO->GetCatalog()->GetCat(TRUE) ) );

                    if ( xCat->IsStarted() )
                        fStarted = TRUE;
                    else if ( xCat->IsPaused() )
                        fPaused = TRUE;
                    else
                    {
                        Win4Assert( xCat->IsStopped() );
                        fStopped = TRUE;
                    }
                 }
                 else if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
                 {
                     sc = _xControlbar->Attach(TOOLBAR, _xToolbar.GetPointer());

                     if ( SUCCEEDED(sc) )
                     {
                         if ( MachineAdmin.IsCIStarted() )
                             fStarted = TRUE;
                         else if ( MachineAdmin.IsCIPaused() )
                             fPaused = TRUE;
                         else
                         {
                             Win4Assert( MachineAdmin.IsCIStopped() );
                             fStopped = TRUE;
                         }
                     }
                 }
            }

            Win4Assert( _xToolbar.GetPointer() );
            if (fStarted)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, FALSE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, TRUE);
            }
            else if (fStopped)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, FALSE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
            }
            else if (fPaused)
            {
                _xToolbar->SetButtonState(comidStartCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidStopCITop, ENABLED, TRUE);
                _xToolbar->SetButtonState(comidPauseCITop, ENABLED, FALSE);
            }
        }
        else if (MMCN_BTN_CLICK == event)
        {
            Win4Assert( comidStartCITop == param ||
                        comidStopCITop  == param ||
                        comidPauseCITop == param );

            LPDATAOBJECT pDataObject = (LPDATAOBJECT) arg;

            CCIAdminDO TempDO( 0, CCT_SCOPE, 0 );

            if( NULL == pDataObject )
                pDataObject = (LPDATAOBJECT)&TempDO;

            return Command( (long)param, pDataObject );
        }
    }
    CATCH( CException, e )
    {
        sc = E_FAIL;
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapinData::QueryPagesFor( IDataObject * lpDataObject )
{
    if ( 0 == lpDataObject || _fURLDeselected )
        return E_POINTER;

    SCODE sc = S_OK;

    TRY
    {
        
       // NOTE: Attempt to open the service and if that fails, we'll be unable to 
       // add property pages. That's expected behavior
       XPtr<CMachineAdmin> xMachineAdmin(new CMachineAdmin( _Catalogs.GetMachine() ));
    
       CCIAdminDO * pDO = (CCIAdminDO *)lpDataObject;
   
       ciaDebugOut(( DEB_ITRACE, "CCISnapin::QueryPagesFor (cookie = 0x%x, type = 0x%x)\n",
                     pDO->Cookie(), pDO->Type() ));
   
       if ( pDO->Type() == CCT_SNAPIN_MANAGER )
           sc = S_OK;
   
       if ( pDO->IsRoot() || pDO->IsStandAloneRoot() || pDO->IsACatalog() || pDO->IsAProperty())
       {
           sc = S_OK;
       }
       else
       {
           ciaDebugOut(( DEB_WARN, "No property pages for (cookie = 0x%x, type = 0x%x)\n",
                         pDO->Cookie(), pDO->Type() ));
           sc = S_FALSE;
       }
    }
    CATCH( CException, e )
    {
        ciaDebugOut(( DEB_ERROR, "CCISnapin::QueryPagesFor: Caught error 0x%x\n", e.GetErrorCode() ));

        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

SCODE STDMETHODCALLTYPE CCISnapin::AddMenuItems( IDataObject * piDataObject,
                                                 IContextMenuCallback * piCallback,
                                                 long * pInsertionAllowed )
{

    EnableStandardVerbs( piDataObject );
    return _SnapinData.AddMenuItems( piDataObject, piCallback, pInsertionAllowed );
}

SCODE STDMETHODCALLTYPE CCISnapin::Command( long lCommandID,
                                            IDataObject * piDataObject )
{
    return _SnapinData.Command( lCommandID, piDataObject );
}

//
// ISnapinAbout methods
//


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinDescription
//
//  Synopsis:   Get description about indexing service.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinDescription(LPOLESTR *lpDescription)
{
    WCHAR szStr[1024];

    wsprintf(szStr, L"%s\r\n%s", STRINGRESOURCE( srProductDescription ),
                                 STRINGRESOURCE( srVendorCopyright ));

    return MakeOLESTR(lpDescription, szStr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetProvider
//
//  Synopsis:   Get provider of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetProvider(LPOLESTR *lpName)
{
    WCHAR szStr[1024];

    wsprintf(szStr, L"%S, %s", VER_COMPANYNAME_STR, STRINGRESOURCE( srVendorName ));
    return MakeOLESTR(lpName, szStr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinVersion
//
//  Synopsis:   Get version of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinVersion(LPOLESTR *lpVersion)
{
    WCHAR szStr[1024];
    wsprintf(szStr, L"%S", VER_PRODUCTVERSION_STR);
    return MakeOLESTR(lpVersion, szStr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetSnapinImage
//
//  Synopsis:   Get image of index server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetSnapinImage(HICON *phAppIcon)
{
    *phAppIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(ICON_ABOUT));
    return (NULL == *phAppIcon) ? E_FAIL : S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::GetStaticFolderImage
//
//  Synopsis:   Get static folder images for use with Index Server.
//
//  History:    02-Feb-1998     KrishanN   Added Header
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCISnapinData::GetStaticFolderImage(
                                             HBITMAP  *hSmallImage,
                                             HBITMAP  *hSmallImageOpen,
                                             HBITMAP  *hLargeImage,
                                             COLORREF *cMask)
{
    *hSmallImage = *hSmallImageOpen = *hLargeImage = NULL;

    *hSmallImage = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_SMALL_CLOSED_FOLDER));
    *hSmallImageOpen = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_SMALL_OPEN_FOLDER));
    *hLargeImage = LoadBitmap(ghInstance, MAKEINTRESOURCE(BMP_LARGE_CLOSED_FOLDER));
    *cMask = RGB(255, 0, 255);

    if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
    {
        if (*hSmallImage)
            DeleteObject(*hSmallImage);
        if (*hSmallImageOpen)
            DeleteObject(*hSmallImageOpen);
        if (*hLargeImage)
            DeleteObject(*hLargeImage);

        return E_FAIL;
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::CCISnapin
//
//  Synopsis:   Constructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapin::CCISnapin( CCISnapinData & SnapinData, CCISnapin * pNext )
        : _pFrame( 0 ),
          _pHeader( 0 ),
          _pResultPane( 0 ),
          _pImageList( 0 ),
          _pConsoleVerb( 0 ),
          _pDisplayHelp( 0 ),
          _CurrentView( CCISnapin::Nothing ),
          _SnapinData( SnapinData ),
          _pNext( pNext ),
          _uRefs( 1 )
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::~CCISnapin
//
//  Synopsis:   Destructor
//
//  History:    26-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

CCISnapin::~CCISnapin()
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::~CCISnapin\n" ));

    Win4Assert( 0 == _pFrame );
    Win4Assert( 0 == _pHeader );
    Win4Assert( 0 == _pResultPane );
    Win4Assert( 0 == _pImageList );
    Win4Assert( 0 == _pConsoleVerb );
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMachineName
//
//  Synopsis:   gets machine name to administer.
//
//  Arguments:  [pDO]             -- dataobject pointer
//              [pwszMachineName] -- out buffer
//              [ cc ]            -- buffer size in wchars
//
//  Returns:    none. throws upon fatal errors (out of memory).
//
//  History:    01-Jul-1998   mohamedn    created
//              31-Aug-1998   KyleP       Support DNS names
//
//--------------------------------------------------------------------------

void GetMachineName(LPDATAOBJECT pDO, XGrowable<WCHAR,MAX_COMPUTERNAME_LENGTH> & xwszMachineName)
{
    Win4Assert( pDO );

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CCIAdminDO::GetMachineNameCF(), NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream

    //
    // What if the computer name is > 512 bytes long?
    //

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, 512);

    XGlobalAllocMem   xhGlobal(stgmedium.hGlobal);

    WCHAR * pwszTmpBuf = NULL;
    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(pDO->GetDataHere(&formatetc, &stgmedium)))
            break;

        pwszTmpBuf = (WCHAR *)stgmedium.hGlobal;

        if ( pwszTmpBuf == NULL || *pwszTmpBuf == L'' )
        {
            xwszMachineName[0] = L'.';
            xwszMachineName[1] = 0;
        }
        else
        {
            unsigned cc = wcslen(pwszTmpBuf) + 1;

            xwszMachineName.SetSize( cc );

            RtlCopyMemory( xwszMachineName.Get(), pwszTmpBuf, cc * sizeof(WCHAR) );
        }
    } while (FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::ShowFolder, private
//
//  Synopsis:   Called when folder is selected.  Displays result in
//              scope pane.
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

void CCISnapinData::ShowFolder( CCIAdminDO * pDO, BOOL fExpanded, HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapinData::ShowFolder (fExpanded = %d, hScopeItem = 0x%x)\n",
                  fExpanded, hScopeItem ));

    Win4Assert( pDO );

    //
    // Only do something on expansion
    //
    if ( fExpanded )
    {
        if ( !_fIsInitialized && pDO->IsStandAloneRoot() )
        {
            _fIsExtension = FALSE;
        }
        else if ( !_fIsInitialized )
        {
            _fIsExtension = TRUE;
        }

        //
        // we're stand alone.
        //
        if ( !_fIsExtension )
        {
            _fIsInitialized = TRUE;

            if ( pDO->IsStandAloneRoot() )
            {
                _Catalogs.DisplayScope( hScopeItem );
            }
            else if ( pDO->IsACatalog() )
            {
                pDO->GetCatalog()->DisplayIntermediate( _pScopePane );
            }
        }
        else if ( _fIsExtension && !_fIsInitialized )
        {
            //
            // we're an extension
            //

            XGrowable<WCHAR,MAX_COMPUTERNAME_LENGTH> xwcsMachine;

            GetMachineName( pDO, xwcsMachine );

            _Catalogs.SetMachine( xwcsMachine.Get() );

            SetRootDisplay();

            _rootNode.Display(hScopeItem);

            _fIsInitialized = TRUE;
        }
        else if ( _fIsExtension && pDO->IsRoot() )
        {
            Win4Assert( _fIsInitialized );

            _Catalogs.DisplayScope( _rootNode.GethScopeItem() );
        }
        else if ( _fIsExtension && pDO->IsACatalog() )
        {
            Win4Assert( _fIsInitialized );

            pDO->GetCatalog()->DisplayIntermediate( _pScopePane );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::SetRootDisplay
//
//  Synopsis:   sets display name string, type string, and description string
//              for static root node
//
//  History:    7/1/98  mohamedn    created
//              9/29/98 KrishnaN    Added type and description.
//
//--------------------------------------------------------------------------

void CCISnapinData::SetRootDisplay()
{
    if ( _fIsExtension )
    {
        unsigned cc = wcslen( STRINGRESOURCE(srIndexServerCmpManage) + 1 );
        _xwcsTitle.SetSize(cc);
        wcscpy( _xwcsTitle.Get(), STRINGRESOURCE(srIndexServerCmpManage) );

        cc = wcslen( STRINGRESOURCE(srType) + 1);
        _xwcsType.SetSize(cc);
        wcscpy( _xwcsType.Get(), STRINGRESOURCE(srType) );

        cc = wcslen( STRINGRESOURCE(srProductDescription) + 1);
        _xwcsDescription.SetSize(cc);
        wcscpy( _xwcsDescription.Get(), STRINGRESOURCE(srProductDescription) );

    }
    else
    {
        unsigned cc = wcslen( STRINGRESOURCE(srIndexServer) ) + 1;

        _xwcsTitle.SetSize(cc);

        wcscpy( _xwcsTitle.Get(), STRINGRESOURCE(srIndexServer) );

        if ( _Catalogs.IsLocalMachine() )
        {
            cc += wcslen( STRINGRESOURCE(srLM) );

            _xwcsTitle.SetSize( cc );

            wcscat( _xwcsTitle.Get(), STRINGRESOURCE(srLM) );
        }
        else
        {
            cc += wcslen( _Catalogs.GetMachine() );
            cc += 2;  // the UNC slashes

            _xwcsTitle.SetSize( cc );

            wcscat( _xwcsTitle.Get(), L"\\\\" );
            wcscat( _xwcsTitle.Get(), _Catalogs.GetMachine() );
        }

        _xwcsType.Free();
        _xwcsDescription.Free();
    }
}

void CCISnapin::EnableStandardVerbs( IDataObject * piDataObject )
{
    SCODE sc = QueryPagesFor( piDataObject );

    if ( S_OK == sc )
    {
        _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    }
    else
        _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);


    if (!_SnapinData.IsURLDeselected() )
    {
       CCIAdminDO * pDO = (CCIAdminDO *)piDataObject;
   
       if ( ( pDO->IsADirectory() && !pDO->GetScope()->IsVirtual() && !pDO->GetScope()->IsShadowAlias() ) ||
            pDO->IsACatalog() )
       {
           _pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
       }
       else
       {
           _pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
       }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapin::ShowItem, private
//
//  Synopsis:   Called when folder is selected.  Displays result in
//              result pane.
//
//  History:    27-Nov-1996     KyleP   Created
//
//--------------------------------------------------------------------------

void CCISnapin::ShowItem( CCIAdminDO * pDO, BOOL fExpanded, HSCOPEITEM hScopeItem )
{
    ciaDebugOut(( DEB_ITRACE, "CCISnapin::ShowItem (fExpanded = %d, hScopeItem = 0x%x)\n",
                  fExpanded, hScopeItem ));

    if ( fExpanded )
    {
        SCODE sc = InitImageResources( _pImageList );

        if ( FAILED(sc) )
        {
            ciaDebugOut(( DEB_ERROR, "InitImageResources returned 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        if ( pDO->IsRoot() || pDO->IsStandAloneRoot() )
        {
            if ( !_CatalogsHeader.IsInitialized() )
            {
                _SnapinData.GetCatalogs().InitHeader( _CatalogsHeader );

                //
                // Start background polling.
                //

                _SnapinData.GetCatalogs().Display( TRUE );
            }

            _CatalogsHeader.Display( _pHeader );

            _CurrentView = CCISnapin::Catalogs;
        }
        else if ( pDO->IsADirectoryIntermediate() )
        {
            CCatalog * pCat = pDO->GetCatalog();

            if ( !_CatalogScopeHeader.IsInitialized() )
                pCat->InitScopeHeader( _CatalogScopeHeader );

            _CatalogScopeHeader.Display( _pHeader );

            pCat->DisplayScopes( TRUE, _pResultPane );

            _CurrentView = CCISnapin::Scopes;
            _CurrentCatalog = pCat;
        }
        else if ( pDO->IsAPropertyIntermediate() )
        {
            CCatalog * pCat = pDO->GetCatalog();

            if ( !_CatalogPropertyHeader.IsInitialized() )
                pCat->InitPropertyHeader( _CatalogPropertyHeader );

            _CatalogPropertyHeader.Display( _pHeader );

            pCat->DisplayProperties( TRUE, _pResultPane );

            _CurrentView = CCISnapin::Properties;
            _CurrentCatalog = pCat;
        }
        else
            _CurrentView = CCISnapin::Nothing;
    }
    else
    {
        switch ( _CurrentView )
        {
        case CCISnapin::Catalogs:
            Win4Assert( pDO->IsRoot() || pDO->IsStandAloneRoot() );
            _CatalogsHeader.Update( _pHeader );
            break;

        case CCISnapin::Scopes:
            Win4Assert( pDO->IsADirectoryIntermediate() );
            _CatalogScopeHeader.Update( _pHeader );
            break;

        case CCISnapin::Properties:
            Win4Assert( pDO->IsAPropertyIntermediate() );
            _CatalogPropertyHeader.Update( _pHeader );
            break;
        }

        _CurrentView = CCISnapin::Nothing;
    }
}

void CCISnapin::Refresh()
{
    switch ( _CurrentView )
    {
    case CCISnapin::Scopes:
        _CurrentCatalog->DisplayScopes( FALSE, _pResultPane );
        break;

    case CCISnapin::Properties:
        _CurrentCatalog->DisplayProperties( FALSE, _pResultPane );
        break;

    case CCISnapin::Catalogs:
    case CCISnapin::Nothing:
    default:
        break;
    }
}

void CCISnapin::RemoveScope( CCIAdminDO * pDO )
{
    Win4Assert( pDO->IsADirectory() && !pDO->GetScope()->IsVirtual() );

    CScope * pScope = pDO->GetScope();

    Win4Assert( 0 != pScope );

    //
    // Make sure the user wants to remove scope.
    //

    WCHAR awcMsg[MAX_PATH];
    WCHAR awcTemp[2 * MAX_PATH];

    LoadString( ghInstance, MSG_REMOVE_SCOPE, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );
    wsprintf( awcTemp, awcMsg, pScope->GetPath() );
    LoadString( ghInstance, MSG_REMOVE_SCOPE_TITLE, awcMsg, sizeof(awcMsg) / sizeof(WCHAR) );

    int iResult;

    SCODE sc = _pFrame->MessageBox( awcTemp,
                                    awcMsg,
                                    MB_YESNO | /* MB_HELP | */
                                      MB_ICONWARNING | MB_DEFBUTTON2 |
                                      MB_APPLMODAL,
                                    &iResult );

    if ( SUCCEEDED(sc) )
    {
        switch ( iResult )
        {
        case IDYES:
        {
            CCatalog & cat = pScope->GetCatalog();
            cat.RemoveScope( pScope );
            Refresh();                          // Update all result pane(s)
            break;
        }
        case IDNO:
            // Do nothing.
            break;

        /* Help is not being used...
        case IDHELP:
        {
           // NTRAID#DB-NTBUG9-83341-2000/07/31-dlee Need online help for several Indexing Service admin dialogs
            DisplayHelp( _hFrameWindow, HIDD_REMOVE_SCOPE );
            break;
        }
        */
        default:
            break;
        }
    }
}

void CCISnapinData::RemoveCatalog( CCIAdminDO * pDO )
{
    CCatalog * pCat = pDO->GetCatalog();

    Win4Assert( 0 != pCat );

    //
    // Make sure we can perform the operation right now.
    //

    CMachineAdmin   MachineAdmin( _Catalogs.IsLocalMachine() ? 0 : _Catalogs.GetMachine() );

    if ( MachineAdmin.IsCIStarted() )
    {
        int iResult;

        SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgCantDeleteCatalog ),
                                        STRINGRESOURCE( srMsgDeleteCatalogTitle ),
                                        MB_OK | /* MB_HELP | */
                                          MB_ICONWARNING | MB_APPLMODAL,
                                        &iResult );

        if ( SUCCEEDED(sc) )
        {
            switch ( iResult )
            {
            case IDOK:
            case IDCANCEL:
                // Do nothing.
                break;
            /* Help is not being used
            case IDHELP:
            {
                DisplayHelp( _hFrameWindow, HIDD_REMOVE_CATALOG );
                break;
            }
            */
            default:
                break;
            }
        }
    }
    else
    {
        int iResult;

        SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgDeleteCatalog ),
                                        STRINGRESOURCE( srMsgDeleteCatalogAsk ),
                                        MB_YESNO | /* MB_HELP | */
                                          MB_ICONWARNING | MB_DEFBUTTON2 |
                                          MB_APPLMODAL,
                                        &iResult );

        if ( SUCCEEDED(sc) )
        {
            switch ( iResult )
            {
            case IDYES:
            {
                if ( FAILED(_Catalogs.RemoveCatalog( pCat )) )
                    _pFrame->MessageBox( STRINGRESOURCE( srMsgCatalogPartialDeletion ),
                                         STRINGRESOURCE( srMsgDeleteCatalogTitle ),
                                         MB_OK | /* MB_HELP | */
                                         MB_ICONWARNING | MB_APPLMODAL,
                                         &iResult);

                Refresh();  // Update all result pane(s)
                break;
            }
            case IDNO:
            case IDCANCEL:
                // Do nothing.
                break;

            /* Help is not being used...
            case IDHELP:
            {
                DisplayHelp( _hFrameWindow, HIDD_REMOVE_CATALOG );
                break;
            }
            */

            default:
                break;
            }
        }
    }
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetHelpTopic( LPOLESTR *lpCompiledHelpFile)
{
    if (0 == lpCompiledHelpFile)
        return E_POINTER;

    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    // ixhelp.hlp is placed in %windir%\help
    wcscat( awc, L"help\\\\is.chm" );
    return MakeOLESTR(lpCompiledHelpFile, awc);
}

SCODE STDMETHODCALLTYPE CCISnapinData::GetLinkedTopics( LPOLESTR *lpCompiledHelpFiles)
{
    if (0 == lpCompiledHelpFiles)
        return E_POINTER;
    
    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    wcscat( awc, L"help\\\\isconcepts.chm" );
    return MakeOLESTR(lpCompiledHelpFiles, awc);
}


SCODE STDMETHODCALLTYPE CCISnapinData::GetHelpTopic2( LPOLESTR *lpCompiledHelpFile)
{
    if (0 == lpCompiledHelpFile)
        return E_POINTER;
    
    WCHAR awc[ MAX_PATH + 1];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return E_UNEXPECTED;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    wcscat( awc, L"help\\\\isconcepts.chm::/sag_INDEXtopnode.htm" );
    return MakeOLESTR(lpCompiledHelpFile, awc);
}

SCODE InitImageResources( IImageList * pImageList )
{
    HBITMAP hbmpSmall = LoadBitmap( ghInstance, MAKEINTRESOURCE( BMP_SMALL_ICONS ) );

    if ( 0 == hbmpSmall )
        return E_FAIL;

    HBITMAP hbmpLarge = LoadBitmap( ghInstance, MAKEINTRESOURCE( BMP_LARGE_ICONS ) );

    if ( 0 == hbmpLarge )
    {
        DeleteObject( hbmpSmall );
        return E_FAIL;
    }

    SCODE sc = pImageList->ImageListSetStrip( (LONG_PTR *)hbmpSmall,
                                              (LONG_PTR *)hbmpLarge,
                                              0,
                                              RGB( 255, 0, 255 ) );

    DeleteObject( hbmpSmall );
    DeleteObject( hbmpLarge );

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Displays context sensitive help
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    20-Sep-1997     dlee        Created
//              14-Sep-1998     KrishnaN    Handle only context sensitive help.
//                                          Regular help is handled by MMC help.
//                                          This fixes 214619.
//
//--------------------------------------------------------------------------

BOOL DisplayHelp( HWND hwnd, DWORD dwID )
{
    if (0 != dwID)  // Display context-sensitive help
        return DisplayHelp( hwnd, dwID, HELP_CONTEXT );
    else
        return TRUE;    // Don't display regular help
} //DisplayHelp

//+-------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Displays context sensitive help
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    20-Sep-1997     dlee   Created
//
//--------------------------------------------------------------------------

BOOL DisplayHelp( HWND hwnd, DWORD dwID, UINT uCommand )
{
    WCHAR awc[ MAX_PATH ];
    const UINT cwcMax = sizeof awc / sizeof WCHAR;

    UINT cwc = GetSystemWindowsDirectory( awc, cwcMax );

    if ( 0 == cwc || cwc > cwcMax )
        return FALSE;

    if ( L'\\' != awc[ cwc-1] )
        wcscat( awc, L"\\" );

    // ixhelp.hlp is placed in %windir%\help
    wcscat( awc, L"help\\\\ixhelp.hlp" );

    return WinHelp( hwnd, awc, uCommand, dwID );
} //DisplayHelp


//+-------------------------------------------------------------------------
//
//  Function:   DisplayPopupHelp
//
//  Synopsis:   Displays context sensitive help as a popup
//
//  Arguments:  [hwnd]   -- The parent window handle
//              [dwID]   -- The help context identifier
//
//  Returns:    TRUE if successful
//
//  History:    11-May-1998     KrishnaN   Created
//
//--------------------------------------------------------------------------

BOOL DisplayPopupHelp( HWND hwnd, DWORD dwHelpType )
{
    return DisplayHelp( hwnd, (DWORD) (DWORD_PTR) aIds, dwHelpType);
} //DisplayPopupHelp


SCODE MakeOLESTR(LPOLESTR *lpBuffer, WCHAR const * pwszText)
{
    if (0 == lpBuffer)
        return E_INVALIDARG;

    ULONG uLen = wcslen(pwszText);
    uLen++;  // string terminator
    uLen = sizeof(WCHAR) * uLen;

    *lpBuffer = (LPOLESTR)CoTaskMemAlloc(uLen);

    if (*lpBuffer)
    {
        RtlCopyMemory(*lpBuffer, pwszText, uLen);
        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCISnapinData::MaybeEnableCI, private
//
//  Synopsis:   Prompt user to set service to automatic start
//
//  Arguments:  [MachineAdmin] -- Machine administration object
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

void CCISnapinData::MaybeEnableCI( CMachineAdmin & MachineAdmin )
{
    if ( _Catalogs.IsLocalMachine() && !_fTriedEnable )
    {
        //
        // Have we tried before?
        //

        if ( MachineAdmin.IsCIEnabled() )
        {
            _fTriedEnable = TRUE;
        }
        else
        {
            WCHAR wcTemp[ (sizeof(wszSnapinPath) + sizeof(wszCISnapin)) / sizeof(WCHAR) + 1];
            wcscpy( wcTemp, wszSnapinPath );
            wcscat( wcTemp, wszCISnapin );

            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcTemp );
            BOOL fTry = FALSE;

            if ( reg.Ok() )
            {
                DWORD dwVal;
                BOOL fOk = reg.Get( wszTriedEnable, dwVal );

                if ( fOk )
                {
                    fTry = (0 == dwVal);
                }
                else
                {
                    if ( reg.GetLastError() == ERROR_FILE_NOT_FOUND )
                        fTry = TRUE;
                }
            }

            if ( fTry )
            {
                int iResult;

                SCODE sc = _pFrame->MessageBox( STRINGRESOURCE( srMsgEnableCI ),
                                                STRINGRESOURCE( srMsgEnableCITitle ),
                                                MB_YESNO | /* MB_HELP | */
                                                  MB_ICONQUESTION | MB_DEFBUTTON1 |
                                                  MB_APPLMODAL,
                                                &iResult );

                if ( SUCCEEDED(sc) )
                {
                    switch ( iResult )
                    {
                    case IDYES:
                        MachineAdmin.EnableCI();
                        break;

                    default:
                        break;
                    }

                    Win4Assert( reg.Ok() );
                    reg.Set( wszTriedEnable, 1 );
                    _fTriedEnable = TRUE;
                }
            }
            else
                _fTriedEnable = TRUE;
        }
    }
}

void CCISnapinData::SetButtonState( int idCommand, MMC_BUTTON_STATE nState, BOOL bState )
{
    for ( CCISnapin * pCurrent = _pChild;
          0 != pCurrent;
          pCurrent = pCurrent->Next() )
    {
        if ( !pCurrent->_xToolbar.IsNull() )
            pCurrent->_xToolbar->SetButtonState( idCommand, nState, bState );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   StartMenu
//
//  Synopsis:   Sets context menu for service started state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE StartMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_GRAYED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_ENABLED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_ENABLED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   StopMenu
//
//  Synopsis:   Sets context menu for service stopped state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE StopMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags    =
    aContextMenus[comidStartCITop].fFlags = MF_ENABLED;
    aContextMenus[comidStopCI].fFlags    =
    aContextMenus[comidStopCITop].fFlags = MF_GRAYED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   PauseMenu
//
//  Synopsis:   Sets context menu for service paused state.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE PauseMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_ENABLED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_ENABLED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   DisabledMenu
//
//  Synopsis:   Disables start/stop/pause menu items
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE DisabledMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    aContextMenus[comidStartCI].fFlags =
    aContextMenus[comidStartCITop].fFlags = MF_GRAYED;
    aContextMenus[comidStopCI].fFlags  =
    aContextMenus[comidStopCITop].fFlags = MF_GRAYED;
    aContextMenus[comidPauseCI].fFlags  =
    aContextMenus[comidPauseCITop].fFlags = MF_GRAYED;

    return SetStartStopMenu( piCallback, fTop );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetStartStopMenu, private
//
//  Synopsis:   Worker routine to call menu callback and set menu items.
//
//  Arguments:  [piCallback] -- Context menu callback routine
//              [fTop]       -- TRUE if menu items should be on top of list
//                              in addition to under Task section.
//
//  History:    07-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE SetStartStopMenu( IContextMenuCallback * piCallback, BOOL fTop )
{
    SCODE sc = S_OK;

    if (SUCCEEDED(sc) && fTop)
        piCallback->AddItem( &aContextMenus[comidStartCITop] );

    if (SUCCEEDED(sc) && fTop)
        sc = piCallback->AddItem( &aContextMenus[comidStopCITop] );

    if (SUCCEEDED(sc) && fTop)
        sc = piCallback->AddItem( &aContextMenus[comidPauseCITop] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidStartCI] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidStopCI] );

    if (SUCCEEDED(sc))
        sc = piCallback->AddItem( &aContextMenus[comidPauseCI] );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\ci\ci.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// PROGRAM:  ci.cxx
//
// PLATFORM: Windows
//
//--------------------------------------------------------------------------

#define UNICODE
#define DBINITCONSTANTS

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <ntquery.h>
#include <mlang.h>
#include <ciodm.h>

#include "ci.hxx"

#ifndef DBOP_firstrows
#define DBOP_firstrows 258
#endif

// This is found in disptree.cxx

extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 );

// These are found in isrch.cxx

extern HRESULT DoISearch( WCHAR const * pwcRestriction,
                          WCHAR const * pwcFilename,
                          BOOL          fPrintFile,
                          BOOL          fDefineCPP,
                          LCID          lcid );
extern HINSTANCE PrepareForISearch();
extern void DoneWithISearch( HINSTANCE h );

const ULONG MAX_CATALOGS = 8;

CIPROPERTYDEF aCPPProperties[] =
{
    {
        L"FUNC",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"func"
        }
    },
    {
        L"CLASS",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"class"
        }
    }
};

unsigned cCPPProperties = sizeof aCPPProperties /
                          sizeof aCPPProperties[0];

//+---------------------------------------------------------------------------
//
//  Class:      XBStr
//
//  Purpose:    Smart BSTR class
//
//----------------------------------------------------------------------------

class XBStr
{
public:
    XBStr(BSTR p = 0) : _p( p ) {}
    XBStr ( XBStr & x ): _p( x.Acquire() ) {}
    ~XBStr() { SysFreeString( _p ); }
    BOOL IsNull() const { return ( 0 == _p ); }
    void Set ( BSTR pOleStr ) { _p = pOleStr; }
    BSTR Acquire()
    {
        BSTR pTemp = _p;
        _p = 0;
        return pTemp;
    }
    BSTR GetPointer() const { return _p; }
    void Free() { SysFreeString( Acquire() ); }
private:
    BSTR _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   XPtr
//
//  Synopsis:   Template for managing ownership of memory
//
//--------------------------------------------------------------------------

template<class T> class XPtr
{
public:
    XPtr( unsigned c ) : _p(0) { if ( 0 != c ) _p = new T [ c ]; }
    ~XPtr() { Free(); }
    void SetSize( unsigned c ) { Free(); _p = new T [ c ]; }
    void Set ( T * p ) { _p = p; }
    T * Get() const { return _p ; }
    void Free() { delete [] Acquire(); }
    T & operator[]( unsigned i ) { return _p[i]; }
    T const & operator[]( unsigned i ) const { return _p[i]; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() const { return ( 0 == _p ); }

private:
    T * _p;
};

//+-------------------------------------------------------------------------
//
//  Template:   CResString
//
//  Synopsis:   Class for loading string resources
//
//--------------------------------------------------------------------------

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }
    CResString( UINT strIDS ) { Load( strIDS ); }
    WCHAR const * Get() const { return _awc; }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( 0, strIDS, _awc, sizeof _awc / sizeof WCHAR );
        return ( 0 != _awc[ 0 ] );
    }

private:
    WCHAR _awc[ 200 ];
};

//+-------------------------------------------------------------------------
//
//  Function:   FormatError
//
//  Synopsis:   Formats an error code into a string
//
//  Arguments:  [sc]   - An Indexing Service or Win32 HRESULT
//              [pwc]  - Where to write the error string
//              [cwc]  - Count of characters in pwc
//              [lcid] - Locale for the error string
//
//--------------------------------------------------------------------------

void FormatError(
    SCODE   sc,
    WCHAR * pwc,
    ULONG   cwc,
    LCID    lcid )
{
    // FormatMessage works best when based on thread locale.

    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( lcid );

    // Is this an Indexing Service error?  These errors are in query.dll.

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                          GetModuleHandle( L"query.dll" ),
                          sc,
                          0,
                          pwc,
                          cwc,
                          0 ) )
    {
        // Is this a Win32 error?  These are in kernel32.dll

        const ULONG facWin32 = ( FACILITY_WIN32 << 16 );
        ULONG Win32Error = sc;

        if ( (Win32Error & facWin32) == facWin32 )
            Win32Error &= ~( 0x80000000 | facWin32 );

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle( L"kernel32.dll" ),
                              Win32Error,
                              0,
                              pwc,
                              cwc,
                              0 ) )
        {
            // It's not from Indexing Service or Win32; display a default error

            CResString str( IDS_UNKNOWNERROR );
            wcscpy( pwc, str.Get() );
        }
    }

    // Restore the original thread locale

    SetThreadLocale( SaveLCID );
} //FormatError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Prints an error message from a string resource
//
//  Arguments:  [uiError]     - The error message resource id
//              [pwcArgument] - A string argument for the error message
//              [hr]          - The error code
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

HRESULT DisplayError(
    UINT          uiError,
    WCHAR const * pwcArgument,
    HRESULT       hr,
    LCID          lcid )
{
    WCHAR awcError[ 200 ];
    FormatError( hr, awcError, sizeof awcError / sizeof WCHAR, lcid );

    CResString str( uiError );
    wprintf( str.Get(), pwcArgument, hr, awcError );

    return hr;
} //DisplayError

//+-------------------------------------------------------------------------
//
//  Function:   DisplayWin32Error
//
//  Synopsis:   Prints an error message taken from GetLastError()
//
//  Arguments:  [uiError]     - The string resource to use for the error
//              [pwcArgument] - A string argument for the error message
//              [lcid]        - Locale for the error string
//
//--------------------------------------------------------------------------

HRESULT DisplayWin32Error(
    UINT          uiError,
    WCHAR const * pwcArgument,
    LCID          lcid )
{
    HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
    DisplayError( uiError, pwcArgument, hr, lcid );
    return hr;
} //DisplayWin32Error

void DisplayStat( DWORD dw, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%8d %ws\n", dw, str.Get() );
} //DisplayStat

void DisplayStat( WCHAR const *pwcMsg, UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws: %ws\n", str.Get(), pwcMsg );
} //DisplayStat

void DisplayStat( UINT uiMsg )
{
    CResString str( uiMsg );
    wprintf( L"%ws\n", str.Get() );
} //DisplayStat

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    HRSRC hrc = FindResource( 0, (LPCWSTR) IDR_USAGE, RT_RCDATA );

    if ( 0 != hrc )
    {
        HGLOBAL hg = LoadResource( 0, hrc );

        if ( 0 != hg )
        {
            void * pv = LockResource( hg );

            if ( 0 != pv )
                wprintf( L"%ws\n", pv );
        }
    }

    exit( -1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Synopsis:   Finds the best matching codepage given a locale id.
//
//  Arguments:  [lcid]  - Locale to check
//
//  Returns:    The best matching codepage.
//
//--------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    ULONG codepage;

    int cwc = GetLocaleInfo( lcid,
                             LOCALE_RETURN_NUMBER |
                                 LOCALE_IDEFAULTANSICODEPAGE,
                             (WCHAR *) &codepage,
                             sizeof ULONG / sizeof WCHAR );

    // If an error occurred, return the Ansi code page

    if ( 0 == cwc )
         return CP_ACP;

    return codepage;
} //LocaleToCodepage

//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleString
//
//  Synopsis:   Looks up a locale string given an LCID
//
//  Arguments:  [lcid] - The lcid to look up
//
//  Returns:    The matching string (in a static buffer, caller beware).
//
//--------------------------------------------------------------------------

WCHAR const * GetLocaleString( LCID lcid )
{
    static WCHAR awcLocale[ 100 ];
    wcscpy( awcLocale, L"Neutral" );

    XInterface<IMultiLanguage> xMultiLang;

    HRESULT hr = CoCreateInstance( CLSID_CMultiLanguage,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IMultiLanguage,
                                   xMultiLang.GetQIPointer() );

    if ( SUCCEEDED( hr ) )
    {
        BSTR bstrLocale;

        hr = xMultiLang->GetRfc1766FromLcid( lcid, &bstrLocale );
        if ( SUCCEEDED( hr ) )
        {
            wcscpy( awcLocale, bstrLocale );
            SysFreeString( bstrLocale );
        }
    }

    return awcLocale;
} //GetLocaleString

//+-------------------------------------------------------------------------
//
//  Function:   LcidFromHttpAcceptLanguage
//
//  Synopsis:   Looks up an LCID given an HTTP Accept Language string
//
//  Arguments:  [pwc] - The string to look up
//
//  Returns:    The matching LCID.
//
//--------------------------------------------------------------------------

LCID LcidFromHttpAcceptLanguage( WCHAR const * pwc )
{
    // Default to the system locale

    LCID lcid = GetSystemDefaultLCID();

    if ( 0 != pwc )
    {
        XInterface<IMultiLanguage> xMultiLang;

        HRESULT hr = CoCreateInstance( CLSID_CMultiLanguage,
                                       0,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IMultiLanguage,
                                       xMultiLang.GetQIPointer() );

        if ( SUCCEEDED( hr ) )
        {
            BSTR bstr = SysAllocString( pwc );

            if ( 0 != bstr )
            {
                hr = xMultiLang->GetLcidFromRfc1766( &lcid, bstr );

                SysFreeString( bstr );

                if ( S_FALSE == hr ||
                     E_FAIL == hr )
                {
                    if ( !_wcsicmp( pwc, L"neutral" ) ||
                         !_wcsicmp( pwc, L"neutr" ) )
                        lcid = 0;
                    else
                        Usage();
                }
                else if ( FAILED( hr ) )
                {
                    Usage();
                }
            }
        }
    }

    return lcid;
} //LcidFromHttpAcceptLanguage

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.  This is set optionally.
//
//              Both of these properties are unique to Indexing Service's
//              OLE DB implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties(
    ICommand * pICommand,
    BOOL       fForceUseContentIndex )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

    DBPROP aProp[2];

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;

    DBPROPSET aPropSet[1];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = fForceUseContentIndex ? 2 : 1;
    aPropSet[0].guidPropertySet = guidQueryExt;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    return xICommandProperties->SetProperties( 1,          // 1 property set
                                               aPropSet ); // the properties
} //SetCommandProperties

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( vt - VT_ARRAY, *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: wprintf( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: wprintf( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: wprintf( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: wprintf( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: wprintf( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: wprintf( L"%d", *(LONG *)pv ); break;
        case VT_UI8: wprintf( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: wprintf( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: wprintf( L"%f", *(float *)pv ); break;
        case VT_R8: wprintf( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( * (CY *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_BOOL: wprintf( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: wprintf( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            VariantTimeToSystemTime( *(DATE *)pv, &st );
            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            wprintf( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        wprintf( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            wprintf( L"," );

        // Get the element and render it

        void *pv;
        SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            wprintf( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            wprintf( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        wprintf( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : break;
        case VT_NULL : break;
        case VT_I4 : wprintf( L"%10d", v.lVal ); break;
        case VT_UI1 : wprintf( L"%10d", v.bVal ); break;
        case VT_I2 : wprintf( L"%10d", v.iVal ); break;
        case VT_R4 : wprintf( L"%10f", v.fltVal ); break;
        case VT_R8 : wprintf( L"%10lf", v.dblVal ); break;
        case VT_BOOL : wprintf( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : wprintf( L"%10d", v.cVal ); break;
        case VT_UI2 : wprintf( L"%10u", v.uiVal ); break;
        case VT_UI4 : wprintf( L"%10u", v.ulVal ); break;
        case VT_INT : wprintf( L"%10d", v.lVal ); break;
        case VT_UINT : wprintf( L"%10u", v.ulVal ); break;
        case VT_I8 : wprintf( L"%20I64d", v.hVal ); break;
        case VT_UI8 : wprintf( L"%20I64u", v.hVal ); break;
        case VT_ERROR : wprintf( L"%#x", v.scode ); break;
        case VT_LPSTR : wprintf( L"%S", v.pszVal ); break;
        case VT_LPWSTR : wprintf( L"%ws", v.pwszVal ); break;
        case VT_BSTR : wprintf( L"%ws", v.bstrVal ); break;
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( v.cyVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;

            if ( VT_DATE == v.vt )
            {
                VariantTimeToSystemTime( v.date, &st );
            }
            else
            {
                FILETIME ft;
                FileTimeToLocalFileTime( &v.filetime, &ft );
                FileTimeToSystemTime( &ft, &st );
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, "%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, "%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%S" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" ); break;
        default : 
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( v.vt - VT_ARRAY, v.parray );
            else
                wprintf( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from the OLE DB error object.
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller
//                               should release this.
//
//  Returns:    HRESULT for whether the error info was retrieved
//
//-----------------------------------------------------------------------------

HRESULT GetOleDBErrorInfo(
    IUnknown *    pErrSrc,
    REFIID        riid,
    LCID          lcid,
    ERRORINFO *   pErrorInfo,
    IErrorInfo ** ppIErrorInfo )
{
    *ppIErrorInfo = 0;

    // See if an error is available that is of interest to us.

    XInterface<ISupportErrorInfo> xSupportErrorInfo;
    HRESULT hr = pErrSrc->QueryInterface( IID_ISupportErrorInfo,
                                          xSupportErrorInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xSupportErrorInfo->InterfaceSupportsErrorInfo( riid );
    if ( FAILED( hr ) )
        return hr;

    // Get the current error object. Return if none exists.

    XInterface<IErrorInfo> xErrorInfo;
    hr = GetErrorInfo( 0, xErrorInfo.GetPPointer() );
    if ( xErrorInfo.IsNull() )
        return hr;

    // Get the IErrorRecord interface and get the count of errors.

    XInterface<IErrorRecords> xErrorRecords;
    hr = xErrorInfo->QueryInterface( IID_IErrorRecords,
                                     xErrorRecords.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG cErrRecords;
    hr = xErrorRecords->GetRecordCount( &cErrRecords );
    if ( 0 == cErrRecords )
        return hr;

#if 1 // A good way to get the complete error message...

    XInterface<IErrorInfo> xErrorInfoRec;
    ERRORINFO ErrorInfo;
    for ( unsigned i=0; i<cErrRecords; i++ )
    {
        // Get basic error information.

        xErrorRecords->GetBasicErrorInfo( i, &ErrorInfo );

        // Get error description and source through the IErrorInfo interface
        // pointer on a particular record.

        xErrorRecords->GetErrorInfo( i, lcid, xErrorInfoRec.GetPPointer() );

        XBStr bstrDescriptionOfError;
        XBStr bstrSourceOfError;

        BSTR bstrDesc = bstrDescriptionOfError.GetPointer();
        BSTR bstrSrc = bstrSourceOfError.GetPointer();

        xErrorInfoRec->GetDescription( &bstrDesc ); 
        xErrorInfoRec->GetSource( &bstrSrc );

        // At this point, you could call GetCustomErrorObject and query for
        // additional interfaces to determine what else happened.

        wprintf( L"%s (%#x)\n%s\n", bstrDesc, ErrorInfo.hrError, bstrSrc );    
    }
#endif

    // Get basic error information for the most recent error

    ULONG iRecord = cErrRecords - 1;
    hr = xErrorRecords->GetBasicErrorInfo( iRecord, pErrorInfo );
    if ( FAILED( hr ) )
        return hr;

    return xErrorRecords->GetErrorInfo( iRecord, lcid, ppIErrorInfo );
} //GetOleDBErrorInfo

//-----------------------------------------------------------------------------
//
//  Function:   DisplayRowsetStatus
//
//  Synopsis:   Retrieves status information about the rowset and catalog.
//
//  Arguments:  [xIRowset] - Rowset about which information is retrieved.
//
//  Returns:    HRESULT result of retrieving the status
//
//-----------------------------------------------------------------------------

HRESULT DisplayRowsetStatus( XInterface<IRowset> & xIRowset )
{
    XInterface<IRowsetInfo> xIRowsetInfo;
    HRESULT hr = xIRowset->QueryInterface( IID_IRowsetInfo,
                                           xIRowsetInfo.GetQIPointer() );

    if ( SUCCEEDED( hr ) )
    {
        // This rowset property is Indexing-Service specific

        DBPROPID propId = MSIDXSPROP_ROWSETQUERYSTATUS;
        DBPROPIDSET propSet;
        propSet.rgPropertyIDs = &propId;
        propSet.cPropertyIDs = 1;
        const GUID guidRowsetExt = DBPROPSET_MSIDXS_ROWSETEXT;
        propSet.guidPropertySet = guidRowsetExt;
    
        ULONG cPropertySets = 0;
        DBPROPSET * pPropertySets;
    
        hr = xIRowsetInfo->GetProperties( 1,
                                          &propSet,
                                          &cPropertySets,
                                          &pPropertySets );

        if ( SUCCEEDED( hr ) )
        {
            DWORD dwStatus = pPropertySets->rgProperties->vValue.ulVal;

            CoTaskMemFree( pPropertySets->rgProperties );
            CoTaskMemFree( pPropertySets );

            DWORD dwFill = QUERY_FILL_STATUS( dwStatus );

            if ( STAT_ERROR == dwFill )
                DisplayStat( IDS_ROWSET_STAT_ERROR );

            DWORD dwReliability = QUERY_RELIABILITY_STATUS( dwStatus );

            if ( 0 != ( STAT_PARTIAL_SCOPE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_PARTIAL_SCOPE );
            if ( 0 != ( STAT_NOISE_WORDS & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_NOISE_WORDS );
            if ( 0 != ( STAT_CONTENT_OUT_OF_DATE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_OUT_OF_DATE );
            if ( 0 != ( STAT_REFRESH_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_REFRESH_INCOMPLETE );
            if ( 0 != ( STAT_CONTENT_QUERY_INCOMPLETE & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_CONTENT_QUERY_INCOMPLETE );
            if ( 0 != ( STAT_TIME_LIMIT_EXCEEDED & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_TIME_LIMIT_EXCEEDED );
            if ( 0 != ( STAT_SHARING_VIOLATION & dwReliability ) )
                DisplayStat( IDS_ROWSET_STAT_SHARING_VIOLATION );
        }
    }

    return hr;
} //DisplayRowsetStatus

ULONG CountEntries( WCHAR const * pwc, WCHAR wc )
{
    WCHAR const * p = wcschr( pwc, wc );
    ULONG c = 1;

    while ( 0 != p )
    {
        c++;
        p++;
        p = wcschr( p, wc );
    }

    return c;
} //CountEntries

//+-------------------------------------------------------------------------
//
//  Function:   IssueQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke isrchdmp.exe
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT IssueQuery(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcQueryRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    BOOL          fDefineCPP )
{
    // Create an ICommand object.  CIMakeICommand is a shortcut for making an
    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent.

    XInterface<ICommand> xICommand;
    HRESULT hr;

    // Handle distributed and single catalog queries

    if ( ( 0 != wcschr( pwcQueryCatalog, L',' ) ) ||
         ( 0 != wcschr( pwcQueryMachine, L',' ) ) )
    {
        ULONG cCat = CountEntries( pwcQueryCatalog, L',' );
        ULONG cMac = CountEntries( pwcQueryMachine, L',' );

        if ( ( ( cCat != cMac ) && ( 1 != cCat ) && ( 1 != cMac ) ) ||
             ( cCat > MAX_CATALOGS || cMac > MAX_CATALOGS ) )
            Usage();

        WCHAR awcCat[ MAX_PATH ];
        wcscpy( awcCat, pwcQueryCatalog );

        WCHAR awcMac[ MAX_PATH ];
        wcscpy( awcMac, pwcQueryMachine );

        WCHAR * aCat[ MAX_CATALOGS ];
        WCHAR * aMac[ MAX_CATALOGS ];
        WCHAR const * aSco[ MAX_CATALOGS ];
        DWORD aFla[ MAX_CATALOGS ];

        WCHAR * pwcCat = awcCat;
        WCHAR * pwcMac = awcMac;

        for ( ULONG i = 0; i < __max( cCat, cMac ); i++ )
        {
            aFla[i] = dwScopeFlags;
            aSco[i] = pwcQueryScope;

            aMac[i] = pwcMac;

            if ( 1 != cMac )
            {
                pwcMac = wcschr( pwcMac, L',' );
                if ( 0 != pwcMac )
                    *pwcMac++ = 0;
            }

            aCat[i] = pwcCat;

            if ( 1 != cCat )
            {
                pwcCat = wcschr( pwcCat, L',' );
                if ( 0 != pwcCat )
                    *pwcCat++ = 0;
            }
        }

        hr = CIMakeICommand( xICommand.GetPPointer(),
                             cCat,
                             aFla,
                             aSco,
                             aCat,
                             aMac );
    }
    else
    {
        hr = CIMakeICommand( xICommand.GetPPointer(),  // result
                             1,                        // 1 scope
                             &dwScopeFlags,            // scope flags
                             &pwcQueryScope,           // scope path
                             &pwcQueryCatalog,         // catalog
                             &pwcQueryMachine );       // machine
    }

    if ( FAILED( hr ) )
        return hr;

    // Get a command tree object

    XInterface<ICommandTree> xICommandTree;
    hr = xICommand->QueryInterface( IID_ICommandTree,
                                    xICommandTree.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Create an OLE DB query tree based on query parameters.

    DBCOMMANDTREE * pTree;
    ULONG cDefinedProperties = fDefineCPP ? cCPPProperties : 0;
    hr = CITextToFullTreeEx( pwcQueryRestriction, // the query itself
                             ulDialect,           // query dialect
                             pwcColumns,          // columns to return
                             pwcSort,             // sort order, may be 0
                             0,                   // reserved
                             &pTree,              // resulting tree
                             cDefinedProperties,  // C++ properties
                             aCPPProperties,      // C++ properties
                             lcid );              // default locale
    if ( FAILED( hr ) )
        return hr;

    // Limit the maximum number of results if requested by putting a DBOP_top
    // node at the top of the query tree.

    if ( 0 != cMaxHits )
    {
        DBCOMMANDTREE * pTop = (DBCOMMANDTREE *) CoTaskMemAlloc( sizeof DBCOMMANDTREE );
        if ( 0 == pTop )
        {
            xICommandTree->FreeCommandTree( &pTree );
            return E_OUTOFMEMORY;
        }

        memset( pTop, 0, sizeof DBCOMMANDTREE );

        if ( fFirstHits )
            pTop->op = DBOP_firstrows;
        else
            pTop->op = DBOP_top;

        pTop->wKind = DBVALUEKIND_UI4;
        pTop->value.ulValue = cMaxHits;
        pTop->pctFirstChild = pTree;
        pTree = pTop;
    }

    // If directed, display the command tree.

    if ( fDisplayTree )
    {
        wprintf( L"%ws\n", pwcQueryRestriction );
        DisplayCommandTree( pTree );
    }

    // If directed, don't issue the query.  Parsing it was sufficient.

    if ( fNoQuery )
    {
        xICommandTree->FreeCommandTree( &pTree );
        return S_OK;
    }

    // Set the tree in the ICommandTree.  Ownership of the tree is transferred.

    hr = xICommandTree->SetCommandTree( &pTree,
                                        DBCOMMANDREUSE_NONE,
                                        FALSE );
    if ( FAILED( hr ) )
    {
        xICommandTree->FreeCommandTree( &pTree );
        return hr;
    }

    // Set required properties on the ICommand

    hr = SetCommandProperties( xICommand.GetPointer(),
                               fForceUseContentIndex );
    if ( FAILED( hr ) )
        return hr;

    // Execute the query.  The query is complete when Execute() returns.

    XInterface<IRowset> xIRowset;
    hr = xICommand->Execute( 0,            // no aggregating IUnknown
                             IID_IRowset,  // IID for interface to return
                             0,            // no DBPARAMs
                             0,            // no rows affected
                             xIRowset.GetIUPointer() ); // result
    if ( FAILED( hr ) )
    {
        // Get the real error; OLE DB permits few Execute() return codes

        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        HRESULT hr2 = GetOleDBErrorInfo( xICommand.GetPointer(),
                                         IID_ICommand,
                                         lcid,
              