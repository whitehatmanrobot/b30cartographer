d)
            {
                //  the browse struct doesnt contain a buffer
                //  size so we assume MAX_PATH here....
                SHGetNameAndFlags(_pidlSelected, SHGDN_NORMAL, _pbfsf->pszDisplayName, MAX_PATH, NULL);
            }
        }
    }

    return hr == S_OK;
}

#define SIZE_MAX_HEIGHT     1600
#define SIZE_MAX_WIDTH      1200

HRESULT CBrowseForFolder::_OnInitSize(HWND hwnd)
{
    // The user hasn't yet sized the dialog, so we need to generate a good
    // default size.  The goal will be to base the window size on the monitor
    // size with scaling properties.
    //
    // Size Algorithm:
    // a) 1/3 hight of screen - Defined in the resource.
    // b) Never larger than max - Based on a 1600x1200 screen
    // c) Never smaller than min - Defined in the resource.

    DWORD dwWidth;
    DWORD dwHeight;
    HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    MONITORINFO monInfo = {sizeof(monInfo), 0};

    EVAL(GetMonitorInfo(hmon, &monInfo));

    // a) 1/3 height of screen - Defined in the resource.
    dwHeight = RECTHEIGHT(monInfo.rcWork) / 3;
    dwWidth = (dwHeight * _dwMinHeight) / _dwMinWidth;    // Scale up the width. Make it have the same ratio as _dwMinWidth/_dwMinHeight

    // b) Never larger than max - Based on a 1600x1200 screen
    if (dwWidth > SIZE_MAX_WIDTH)
        dwWidth = SIZE_MAX_WIDTH;
    if (dwHeight > SIZE_MAX_HEIGHT)
        dwHeight = SIZE_MAX_HEIGHT;

    // c) Never smaller than min - Defined in the resource.
    // Set them to the min sizes if they are too small.
    if (dwWidth < _dwMinWidth)
        dwWidth = _dwMinWidth;
    if (dwHeight < _dwMinHeight)
        dwHeight = _dwMinHeight;

    return _SetDialogSize(hwnd, dwWidth, dwHeight);
}


BOOL_PTR CBrowseForFolder::_OnGetMinMaxInfo(MINMAXINFO * pMinMaxInfo)
{
    BOOL_PTR pfResult = 1;

    if (pMinMaxInfo)
    {
        pMinMaxInfo->ptMinTrackSize.x = _dwMinWidth;
        pMinMaxInfo->ptMinTrackSize.y = _dwMinHeight;

        pfResult = 0;   // Indicate it's handled.
    }

    return pfResult;
}


HRESULT CBrowseForFolder::_OnLoadSize(HWND hwnd)
{
    HRESULT hr = S_FALSE;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD cbSize1 = sizeof(dwWidth);
    DWORD cbSize2 = sizeof(dwHeight);

    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Width"), NULL, (void *)&dwWidth, &cbSize1)) &&
        (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Height"), NULL, (void *)&dwHeight, &cbSize2)))
    {
        HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
        MONITORINFO monInfo = {sizeof(monInfo), 0};
        EVAL(GetMonitorInfo(hmon, &monInfo));

        // Is the saved size within this monitor size?
        if ((dwWidth < (DWORD)RECTWIDTH(monInfo.rcWork)) &&
            (dwHeight < (DWORD)RECTHEIGHT(monInfo.rcWork)))
        {
            // Set them to the min sizes if they are too small.
            if (dwWidth < _dwMinWidth)
                dwWidth = _dwMinWidth;

            if (dwHeight < _dwMinHeight)
                dwHeight = _dwMinHeight;

            hr = _SetDialogSize(hwnd, dwWidth, dwHeight);
        }
    }

    return hr;
}

HRESULT CBrowseForFolder::_OnSaveSize(HWND hwnd)
{
    RECT rc;

    GetClientRect(hwnd, &rc);
    DWORD dwWidth = (rc.right - rc.left);
    DWORD dwHeight = (rc.bottom - rc.top);

    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Width"), REG_DWORD, (void *)&dwWidth, sizeof(dwWidth));
    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Height"), REG_DWORD, (void *)&dwHeight, sizeof(dwHeight));
    return S_OK;
}


HDWP CBrowseForFolder::_SizeControls(HWND hwnd, HDWP hdwp, RECT rcTree, int dx, int dy)
{
    //  Move the controls.
    HWND hwndControl = ::GetWindow(hwnd, GW_CHILD);
    while (hwndControl && hdwp)
    {
        RECT rcControl;

        GetWindowRect(hwndControl, &rcControl);
        MapWindowRect(HWND_DESKTOP, hwnd, &rcControl);

        switch (GetDlgCtrlID(hwndControl))
        {
        case IDD_BROWSETITLE:
            // Increase the width of these controls
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, rcControl.top, (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), (SWP_NOZORDER | SWP_NOACTIVATE));
            InvalidateRect(hwndControl, NULL, TRUE);
            break;

        case IDD_FOLDERLABLE:
            // Move these controls down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;

        case IDD_BROWSEEDIT:
            // Increase the width move down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case IDD_BROWSEINSTRUCTION:
            // Increase the width, move down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case IDD_NEWFOLDER_BUTTON:
            // Keep this guy on the left, and move it down if needed.
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;

        case IDOK:
        case IDCANCEL:
            // Move these controls to the right, down if needed.
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, (rcControl.left + dx), (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;
        }

        hwndControl = ::GetWindow(hwndControl, GW_HWNDNEXT);
    }

    return hdwp;
}


HRESULT CBrowseForFolder::_SetDialogSize(HWND hwnd, DWORD dwWidth, DWORD dwHeight)
{
    HRESULT hr = S_OK;
    RECT rcDlg = {0, 0, dwWidth, dwHeight};

    //  Set the sizing grip to the correct location.
    SetWindowPos(GetDlgItem(hwnd, IDD_BFF_RESIZE_TAB), NULL, (dwWidth - _cxGrip), (dwHeight - _cyGrip), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));

    EVAL(AdjustWindowRect(&rcDlg, (DS_MODALFRAME | DS_3DLOOK | WS_POPUP | WS_CAPTION | WS_SYSMENU | DS_CONTEXTHELP | WS_EX_CLIENTEDGE | WS_SIZEBOX), NULL));
    rcDlg.right -= rcDlg.left;  // Adjust for other side.
    rcDlg.bottom -= rcDlg.top;  //

    SetWindowPos(hwnd, NULL, 0, 0, rcDlg.right, rcDlg.bottom, (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));
    // We don't need to call _OnSizeDialog() because SetWindowPos() will end up calling WS_SIZE so it will automatically get called.
    return hr;
}


HRESULT CBrowseForFolder::_OnSizeDialog(HWND hwnd, DWORD dwWidth, DWORD dwHeight)
{
    RECT rcNew;      // Sizes in window Coords
    RECT rcTree;      // Sizes in window Coords
    DWORD dwFullWidth;
    DWORD dwFullHeight;

    //  Calculate the deltas in the x and y positions that we need to move
    //  each of the child controls.
    GetWindowRect(hwnd, &rcNew);
    dwFullWidth = RECTWIDTH(rcNew);
    dwFullHeight = RECTHEIGHT(rcNew);

    // If it's smaller than the min, fix it for the rest of the dialog.
    if (dwFullWidth < _dwMinWidth)
        dwFullWidth = _dwMinWidth;
    if (dwFullHeight < _dwMinHeight)
        dwFullHeight = _dwMinHeight;

    int dx = (dwFullWidth - _ptLastSize.x);
    int dy = (dwFullHeight - _ptLastSize.y);

    //  Update the new size.
    _ptLastSize.x = dwFullWidth;
    _ptLastSize.y = dwFullHeight;

    //  Size the view.
    GetWindowRect(_hwndBFF, &rcTree);
    MapWindowRect(HWND_DESKTOP, hwnd, &rcTree);

    // Don't do anything if the size remains the same
    if ((dx != 0) || (dy != 0))
    {
        HDWP hdwp = BeginDeferWindowPos(15);

        //  Set the sizing grip to the correct location.
        SetWindowPos(GetDlgItem(hwnd, IDD_BFF_RESIZE_TAB), NULL, (dwWidth - _cxGrip), (dwHeight - _cyGrip), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));

        if (EVAL(hdwp))
        {
            hdwp = DeferWindowPos(hdwp, _hwndBFF, NULL, 0, 0, (RECTWIDTH(rcTree) + dx), (RECTHEIGHT(rcTree) + dy), (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));

            if (hdwp)
                hdwp = _SizeControls(hwnd, hdwp, rcTree, dx, dy);

            if (EVAL(hdwp))
                EVAL(EndDeferWindowPos(hdwp));
        }
        SetWindowPos(_hwndTv, NULL, 0, 0, (RECTWIDTH(rcTree) + dx - (SIZE_ZOOM * GetSystemMetrics(SM_CXEDGE))), (RECTHEIGHT(rcTree) + dy - (SIZE_ZOOM * GetSystemMetrics(SM_CYEDGE))), (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));
    }

    return S_OK;
}

HRESULT CBrowseForFolder::_OnSetSelectPathA(LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return _OnSetSelectPathW(szPath);
}

HRESULT CBrowseForFolder::_OnSetSelectPathW(LPCWSTR pwzPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pwzPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _OnPidlNavigation(pidl, SHBFFN_UPDATE_TREE);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetSelectPidl(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlToFree;
    HRESULT hr = TranslateCloneOrDefault(pidl, CSIDL_PERSONAL, &pidlToFree);
    if (SUCCEEDED(hr))
    {
        hr = _OnPidlNavigation(pidlToFree, SHBFFN_UPDATE_TREE);
        ILFree(pidlToFree);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetExpandedPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pszPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _OnSetExpandedPidl(pidl);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetExpandedPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    if (pidl && _pns)
    {
        IShellNameSpace *psns;
        hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psns));
        if (SUCCEEDED(hr))
        {
            VARIANT varPidl;
            hr = InitVariantFromIDList(&varPidl, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psns->Expand(varPidl, 1); // To a depth of 1
                VariantClear(&varPidl);
            }
            psns->Release();
        }
    }

    return hr;
}

BOOL CBrowseForFolder::_DoesFilterAllow(LPCITEMIDLIST pidl, BOOL fStrictParsing)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = _ShouldShow(psfParent, NULL, pidlChild, fStrictParsing);
        psfParent->Release();
    }

    return ((S_OK == hr) ? TRUE : FALSE);
}


HRESULT CBrowseForFolder::_OnPidlNavigation(LPCITEMIDLIST pidl, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (_DoesFilterAllow(pidl, (SHBFFN_STRICT_PARSING & dwFlags)))
    {
        Pidl_Set(&_pidlSelected, pidl);

        if (_pidlSelected)
        {
            // NOTE: for perf, fUpdateTree is FALSE when closing the dialog, so
            // we don't bother to call INSCTree::SetSelectedItem()
            if ((SHBFFN_UPDATE_TREE & dwFlags) && _pns)
            {
                hr = _pns->SetSelectedItem(_pidlSelected, TRUE, FALSE, 0);
            }
            TCHAR szDisplayName[MAX_URL_STRING];

            hr = SHGetNameAndFlags(_pidlSelected, SHGDN_NORMAL, szDisplayName, SIZECHARS(szDisplayName), NULL);
            if (SUCCEEDED(hr))
            {
                EVAL(SetWindowText(GetDlgItem(_hDlg, IDD_BROWSEEDIT), szDisplayName));
                _fEditboxDirty = FALSE;
            }

            if (SHBFFN_FIRE_SEL_CHANGE & dwFlags)
            {
                // For back compat reasons, we need to re-enable the OK button
                // because the callback may turn it off.
                EnableWindow(GetDlgItem(_hDlg, IDOK), TRUE);
                BFSFCallback(_pbfsf, BFFM_SELCHANGED, (LPARAM)_pidlSelected);
            }

            if (_ppf)  // Tell AutoComplete we are in a new location.
                EVAL(SUCCEEDED(_ppf->Initialize(_pidlSelected)));
        }
    }
    else
    {
        if (SHBFFN_DISPLAY_ERRORS & dwFlags)
        {
            TCHAR szPath[MAX_URL_STRING];

            SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPath, SIZECHARS(szPath), NULL);

            // Display Error UI.
            ShellMessageBox(HINST_THISDLL, _hDlg, MAKEINTRESOURCE(IDS_FOLDER_NOT_ALLOWED),
                            MAKEINTRESOURCE(IDS_FOLDER_NOT_ALLOWED_TITLE), (MB_OK | MB_ICONHAND), szPath);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    return hr;
}

BOOL CBrowseForFolder::_CreateNewFolder(HWND hDlg)
{
    IShellFavoritesNameSpace * psfns;
    if (_pns && SUCCEEDED(_pns->QueryInterface(IID_PPV_ARG(IShellFavoritesNameSpace, &psfns))))
    {
        HRESULT hr = psfns->NewFolder();

        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            // If it failed, then the user doesn't have permission to create a
            // new folder here.  We can't disable the "New Folder" button because
            // it takes too long (perf) to see if it's supported.  The only way
            // is to determine if "New Folder" is in the ContextMenu.
            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NEWFOLDER_NOT_HERE),
                            MAKEINTRESOURCE(IDS_NEWFOLDER_NOT_HERE_TITLE), (MB_OK | MB_ICONHAND));
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                _fEditboxDirty = FALSE; // The newly selected node in the tree is the most up to date.
            }
        }

        psfns->Release();
    }
    return TRUE;
}


HRESULT IUnknown_SetOptions(IUnknown * punk, DWORD dwACLOptions)
{
    IACList2 * pal2;

    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IACList2, &pal2));
    if (SUCCEEDED(hr))
    {
        hr = pal2->SetOptions(dwACLOptions);
        pal2->Release();
    }

    return hr;
}

HRESULT CBrowseForFolder::_InitAutoComplete(HWND hwndEdit)
{
    HRESULT hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &_ppf));
    if (SUCCEEDED(hr))
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))
        {
            hr = pac->Init(hwndEdit, _ppf, NULL, NULL);

            // Set the autocomplete options
            DWORD dwACOptions = 0;
            if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
            {
                dwACOptions |= ACO_AUTOAPPEND;
            }

            if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
            {
                dwACOptions |= ACO_AUTOSUGGEST;
            }

            EVAL(SUCCEEDED(pac->SetOptions(dwACOptions)));
            EVAL(SUCCEEDED(IUnknown_SetOptions(_ppf, ACLO_FILESYSONLY)));
            _OnTreeSelectChange(SHBFFN_UPDATE_TREE | SHBFFN_NONE);
            pac->Release();
        }
    }

    return hr;
}


void CBrowseForFolder::_OnNotify(LPNMHDR pnm)
{
    if (pnm)
    {
        switch (pnm->code)
        {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _OnTreeSelectChange(SHBFFN_DISPLAY_ERRORS);
            break;
        }
    }
}


/***********************************************************************\
    DESCRIPTION:
        If the string was formatted as a UNC or Drive path, offer to
    create the directory path if it doesn't exist.  If the media isn't
    inserted or formated, offer to do that also.

    PARAMETER:
        szPath: The path the user entered into the editbox after it was
                expanded.
        RETURN: S_OK means it's not a file system path or it exists.
                S_FALSE means it's was a file system path but didn't exist
                        or creating it didn't work but NO ERROR UI was displayed.
                FAILURE(): Error UI was displayed, so caller should not
                           display error UI.
\***********************************************************************/
HRESULT CBrowseForFolder::_OfferToPrepPath(OUT LPTSTR szPath, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    BOOL fSkipValidation = FALSE;       // Only skip validation if we display the err UI.

    // TODO: Replace this with CShellUrl->ParseFromOutsideSource(), however, this will require
    //       making CShellUrl (browseui) into a COM object.  This will allow us to parse relative
    //       paths.
    GetDlgItemText(_hDlg, IDD_BROWSEEDIT, szDisplayName, ARRAYSIZE(szDisplayName));

    // Callers
    if (SHExpandEnvironmentStrings(szDisplayName, szPath, cchSize)
        && (PathIsUNC(szPath) || (-1 != PathGetDriveNumber(szPath))))
    {
        hr = E_FAIL;
        // I found a problem where UNC paths to printers
        // will fail SHPathPrepareForWrite().  If the caller is
        // looking for printers, we want to succeed in that case and
        // not fail. 
        if ((_pbfsf->ulFlags & BIF_BROWSEFORPRINTER) && PathIsUNCServerShare(szPath))
        {
            LPITEMIDLIST pidlTest;
            hr = SHParseDisplayName(szPath, NULL, &pidlTest, 0, NULL);
            if (SUCCEEDED(hr))
                ILFree(pidlTest);
        }

        if (FAILED(hr))
        {
            // yes, so make sure the drive is inserted (if ejectable)
            // This will also offer to format unformatted drives.
            hr = SHPathPrepareForWrite(_hDlg, NULL, szPath, SHPPFW_MEDIACHECKONLY);
            if (FAILED_AND_NOT_CANCELED(hr))
            {
                hr = S_OK; // this function needs to succeed for us to be able to send VALIDATEFAILED
            }              
        }
    }
    else
        StrCpyN(szPath, szDisplayName, cchSize);

    return hr;
}

HRESULT CBrowseForFolder::_ProcessEditChangeOnOK(BOOL fUpdateTree)
{
    TCHAR szPath[MAX_URL_STRING];
    HRESULT hr = _OfferToPrepPath(szPath, ARRAYSIZE(szPath));

    // It will succeed if it was successful or DIDN'T display an error
    // dialog and we didn't.
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHParseDisplayName(szPath, NULL, &pidl, 0, NULL)))
        {
            DWORD dwFlags = (SHBFFN_FIRE_SEL_CHANGE | SHBFFN_STRICT_PARSING | SHBFFN_DISPLAY_ERRORS);

            _fEditboxDirty = FALSE;

            if (fUpdateTree)
                dwFlags |= SHBFFN_UPDATE_TREE;

            hr = _OnPidlNavigation(pidl, dwFlags);
            if (SUCCEEDED(hr))
                _fEditboxDirty = FALSE;
        }

        if ((_pbfsf->ulFlags & BIF_VALIDATE) && !pidl)
        {
            LPARAM lParam;
            CHAR szAnsi[MAX_URL_STRING];
            WCHAR wzUnicode[MAX_URL_STRING];

            if (_pbfsf->fUnicode)
            {
                SHTCharToUnicode(szPath, wzUnicode, ARRAYSIZE(wzUnicode));
                lParam = (LPARAM) wzUnicode;
            }
            else
            {
                SHTCharToAnsi(szPath, szAnsi, ARRAYSIZE(szAnsi));
                lParam = (LPARAM) szAnsi;
            }

            ASSERTMSG(_pbfsf->lpfn != NULL, "No BrowseCallbackProc supplied with BIF_VALIDATE flag");

            // 0:EndDialog, 1:continue
            if (0 == BFSFCallback(_pbfsf, (_pbfsf->fUnicode? BFFM_VALIDATEFAILEDW : BFFM_VALIDATEFAILEDA), lParam))
                hr = S_OK; // This is returned so the dialog can close in _OnOK
            else
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }

        ILFree(pidl);
    }

    return hr;
}


HRESULT CBrowseForFolder::_OnTreeSelectChange(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (_pns)
    {
        LPITEMIDLIST pidl;
        hr = _pns->GetSelectedItem(&pidl, 0);
        if (S_OK == hr)
        {
            hr = _OnPidlNavigation(pidl, (SHBFFN_FIRE_SEL_CHANGE | dwFlags));
            ILFree(pidl);
        }
    }

    return hr;
}


HRESULT CBrowseForFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBrowseForFolder, IFolderFilter),         // IID_IFolderFilter
        QITABENT(CBrowseForFolder, IFolderFilterSite),     // IID_IFolderFilterSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG CBrowseForFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBrowseForFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

// We aren't a real COM object yet.
//    delete this;
    return 0;
}


HRESULT CBrowseForFolder::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fStrict)
{
    HRESULT hr = S_OK;
    BOOL fFilterChildern = FALSE;

    // Do we want to filter our all the children of a certain folder?
    if (_pidlChildFilter)
    {
        // Yes, let's see if the tree walking caller is still
        // in this folder?
        if (pidlFolder && ILIsParent(_pidlChildFilter, pidlFolder, FALSE))
        {
            // Yes, so don't use it.
            hr = S_FALSE;
        }
        else
        {
            // The calling tree walker has walked out side of
            // this folder, so remove the filter.
            _FilterThisFolder(NULL, NULL);
        }
    }

    AssertMsg((ILIsEmpty(pidlItem) || ILIsEmpty(_ILNext(pidlItem))), TEXT("CBrowseForFolder::ShouldShow() pidlItem needs to be only one itemID long because we don't handle that case."));
    if (S_OK == hr)
    {
        hr = _DoesMatchFilter(psf, pidlFolder, pidlItem, fStrict);
    }

    // If this pidl has still not been filtered out, give our client filter a chance.
    if (_pClientFilter && (hr == S_OK))
    {
        hr = _pClientFilter->ShouldShow(psf, pidlFolder, pidlItem);
    }

    return hr;
}


HRESULT CBrowseForFolder::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    if (_pbfsf->ulFlags & BIF_SHAREABLE)
        *pgrfFlags |= SHCONTF_SHAREABLE;

    if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        *pgrfFlags |= SHCONTF_NETPRINTERSRCH;

    // Also delegate to client filter.
    if (_pClientFilter)
    {
        return _pClientFilter->GetEnumFlags(psf, pidlFolder, phwnd, pgrfFlags);
    }

    return S_OK;
}

    // *** IFolderFilterSite method ***
HRESULT CBrowseForFolder::SetFilter(IUnknown* punk)
{
    HRESULT hr = S_OK;
    
    ATOMICRELEASE(_pClientFilter);
    if (punk)
        hr = punk->QueryInterface(IID_PPV_ARG(IFolderFilter, &_pClientFilter));

    return hr;
}

HRESULT CBrowseForFolder::_FilterThisFolder(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild)
{
    if (_pidlChildFilter)
        ILFree(_pidlChildFilter);

    if (pidlChild)
        _pidlChildFilter = ILCombine(pidlFolder, pidlChild);
    else
    {
        if (pidlFolder)
            _pidlChildFilter = ILClone(pidlFolder);
        else
            _pidlChildFilter = NULL;
    }

    return S_OK;
}

HRESULT CBrowseForFolder::_InitFilter(void)
{
    HRESULT hr = S_OK;

    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if ((_pbfsf->ulFlags & (BIF_BROWSEFORPRINTER | BIF_NEWDIALOGSTYLE)) == BIF_BROWSEFORPRINTER)
    {
        LPCITEMIDLIST pidl = ILFindLastID(_pbfsf->pidlRoot);
    
        _fPrinterFilter = ((SIL_GetType(pidl) & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
    }

    return hr;
}


BOOL IsPidlUrl(IShellFolder *psf, LPCITEMIDLIST pidlChild)
{
    BOOL fIsURL = FALSE;
    WCHAR wzDisplayName[MAX_URL_STRING];

    if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING, wzDisplayName, ARRAYSIZE(wzDisplayName))))
    {
        fIsURL = PathIsURLW(wzDisplayName);
    }

    return fIsURL;
}

HRESULT CBrowseForFolder::_DoesMatchFilter(IShellFolder *psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild, BOOL fStrict)
{
    HRESULT hr = S_OK;

    // We need to special case here in the netcase where we only
    // browse down to workgroups...
    //
    //
    // Here is where I also need to special case to not go below
    // workgroups when the appropriate option is set.
    
    BYTE bType = SIL_GetType(pidlChild);

    if ((_pbfsf->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
    {
        switch (bType & (SHID_NET | SHID_INGROUPMASK))
        {
        case SHID_NET_SERVER:
            hr = S_FALSE;           // don't add it
            break;
        case SHID_NET_DOMAIN:
            _FilterThisFolder(pidlFolder, pidlChild);      // Force to not have children;
            break;
        }
    }
    else if ((_pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
    {
        if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
            _FilterThisFolder(pidlFolder, pidlChild);      // Don't expand below it...
    }
    else if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
    {
        /* This code is a work in progress and will be refined post beta 1 */
        
        IShellLink* pShortcut = NULL;
        if (SUCCEEDED(psf->BindToObject(pidlChild, NULL, IID_PPV_ARG(IShellLink, &pShortcut))))
        {
            LPITEMIDLIST pShortcutTargetIDList = NULL;
            if (SUCCEEDED(pShortcut->GetIDList(&pShortcutTargetIDList)))
            {
                IShellFolder* pTargetParentFolder;
                LPITEMIDLIST pTargetRelativeIDList;
                if (SUCCEEDED(SHBindToIDListParent(pShortcutTargetIDList, IID_PPV_ARG(IShellFolder, &pTargetParentFolder), (LPCITEMIDLIST*) &pTargetRelativeIDList)))
                {
                    BYTE NetResourceArray[2048];
                    NETRESOURCE* pNetResource = (NETRESOURCE*) NetResourceArray;
                    SHGetDataFromIDList(pTargetParentFolder, pTargetRelativeIDList, SHGDFIL_NETRESOURCE, (void*) &NetResourceArray, sizeof(NetResourceArray));
                    if (RESOURCEDISPLAYTYPE_SHARE == pNetResource->dwDisplayType)
                    {
                        hr = S_FALSE;
                    }
                    pTargetParentFolder->Release();
                }
                ILFree(pShortcutTargetIDList);
            }
            pShortcut->Release();
        }

        if (S_OK == hr) // we don't want S_FALSE
        {
            // Special case when we are only allowing printers.
            // for now I will simply key on the fact that it is non-FS.
            ULONG ulAttr = SFGAO_FILESYSANCESTOR;
            
            psf->GetAttributesOf(1, &pidlChild, &ulAttr);
            if ((ulAttr & (SFGAO_FILESYSANCESTOR)) == 0)
            {
                _FilterThisFolder(pidlFolder, pidlChild);      // Don't expand below it...
            }
            else
            {
                if (_fPrinterFilter)
                    hr = S_FALSE;           // don't add it
            }
        }
    }
    else if (!(_pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES))
    {
        // If the caller wants to include URLs and this is an URL,
        // then we are done.  Otherwise, we need to enter this if and
        // filter out items that don't have the SFGAO_FOLDER attribute
        // set.
        if (!(_pbfsf->ulFlags & BIF_BROWSEINCLUDEURLS) || !IsPidlUrl(psf, pidlChild))
        {
            // Lets not use the callback to see if this item has children or not
            // as some or files (no children) and it is not worth writing our own
            // enumerator as we don't want the + to depend on if there are sub-folders
            // but instead it should be if it has files...
            ULONG ulAttr = SFGAO_FOLDER;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlChild, &ulAttr);
            if ((ulAttr & SFGAO_FOLDER)== 0)
                hr = S_FALSE;           // don't add it
        }
    }

    if (_pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS))
    {
        // If we are only looking for FS level things only add items
        // that are in the name space that are file system objects or
        // ancestors of file system objects
        ULONG ulAttr = 0;

        if (fStrict)
        {
            if (_pbfsf->ulFlags & BIF_RETURNONLYFSDIRS)
                ulAttr |= SFGAO_FILESYSTEM;

            if (_pbfsf->ulFlags & BIF_RETURNFSANCESTORS)
                ulAttr |= SFGAO_FILESYSANCESTOR;
        }
        else
        {
            ulAttr = (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM);
        }

        psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlChild, &ulAttr);
        if ((ulAttr & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM))== 0)
        {
            hr = S_FALSE;           // don't add it
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cdmedia.h ===
// karencar
// file for cd burning help ids

#define CDBURN_HELPFILE         TEXT("cdmedia.hlp")

#define IDH_CDMEDIA_ENABLERECORDING      	 1001
#define IDH_CDMEDIA_STOREDISCIMAGE         	 1010
#define IDH_CDMEDIA_WRITESPEED             	 1020
#define IDH_CDMEDIA_EJECT                	 1030
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\clsobj.h ===
#include "unicpp\deskhtm.h"

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0

EXTERN_C IClassFactory* g_cfWebViewPluggableProtocol;

STDAPI CActiveDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDeskMovr_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCopyToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CMoveToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewMimeFilter_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewPluggableProtocol_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDeskHtmlProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellDispatch_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CShellFolderView_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CShellFolderViewOC_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMigrationWizardAuto_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewFolderContents_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellCmdFileIcon_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CSendToMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CNewMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFolderShortcut_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFileSearchBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMountedVolume_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMTAInjector_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFileTypes_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDelegateFolder_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDragImages_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CExeDropTarget_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellMonikerHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderItemsFDF_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CNetCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWorkgroupCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
STDAPI CPropertyUI_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTimeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFreeSpaceCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDriveSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDriveTypeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CQueryAssociations_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CLocalCopyHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CStgFolder_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTripleD_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenuFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CProgramsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
#ifdef FEATURE_STARTPAGE
STDAPI CMoreDocumentsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
#endif
// STDAPI CSystemRestoreCleaner_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CVerColProvider_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellFileDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellDrvDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellNetDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDrives_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTray_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CBriefcase_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CRecycleBin_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CNetwork_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCopyHook_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CShellLink_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CControlPanel_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CPrinters_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CBitBucket_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CProxyPage_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CScrapData_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFSFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CInetRoot_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFindPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDefViewPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CComputerFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFSBrfFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CURLExec_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CRecycleBinCleaner_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CHWShellExecute_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDeviceEventHandler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CUserNotification_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CStorageProcessor_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);      // isproc.*
STDAPI CVirtualStorageEnum_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);   // vstgenum.*
STDAPI CVirtualStorage_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);       // virtualstorage.*
STDAPI CTransferConfirmation_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv); // confirmationui.*
STDAPI CAutomationCM_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
STDAPI CThumbStore_CreateInstance(IUnknown* punkOther, REFIID riid, void **ppv);
STDAPI CCategoryProvider_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CSharedDocFolder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
STDAPI CPostBootReminder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
STDAPI CISFBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMenuBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CTrackShellMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv);
STDAPI CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv);
STDAPI CQuickLinks_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CUserEventTimer_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CThumbnail_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenuPin_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CClientExtractIcon_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CMyDocsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CMergedCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderCustomize_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWirelessDevices_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CNamespaceWalk_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebWizardPage_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CPersonalStartMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CAutoPlayVerb_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CHWMixedContent_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CFolderViewHost_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\combview.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "vdate.h"
#include "cnctnpt.h"
#include "mshtml.h"
#include <sfview.h>
#include "defviewp.h"
#include "shellp.h"

#define LISTVIEW_PROP   TEXT("CombView_listview_subclass")
#define ISMOUSEDOWN(msg) ((msg) == WM_LBUTTONDOWN || (msg) == WM_RBUTTONDOWN || (msg) == WM_MBUTTONDOWN)
#define HWNDLISTVIEW (g_pdsvlvp->pdsv->_hwndListview)
#define COMBVIEW_SUBCLASS_ID  42

typedef struct  
{
    CDefView   *pdsv;
    BOOL       fInPaint;
    HHOOK      hHookMouse;
    HHOOK      hHookGetMsg;
} DVLVPROP;

//
// We need this global (g_pdsvlvp) for the mouse hook we need to implement the combined
// view.  Since we only have one combined view at this point it is sufficient to have
// a single global, but if we end up with more than one combined view then
// there needs to be some additional code added so the hook(s) can figure out
// which combined view(s) it is associated with.
// 
DVLVPROP * g_pdsvlvp = NULL;

const LPCTSTR c_rgElements[] = {   
    TEXT("A"),
    TEXT("ANCHOR"),   // ???
    TEXT("PLUGINS"),  // ???
    TEXT("APPLET"),
    TEXT("EMBED"),
    TEXT("FORM"),
    TEXT("IFRAME"),
    TEXT("BUTTON"),
    TEXT("INPUT"),
    TEXT("OBJECT") 
};                              

BOOL CombView_EnableAnimations(BOOL fEnable);

// Returns the first sibling window of the passed in window
HWND GetSpecialSibling(HWND hwnd)
{
    HWND hwndT = GetWindow(hwnd, GW_HWNDFIRST);

    while (hwnd == hwndT)
        hwndT = GetWindow(hwndT, GW_HWNDNEXT);

    return hwndT;
}

LRESULT CALLBACK CombView_LV_SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    DVLVPROP *pdsvlvp = (DVLVPROP *)dwRefData;

    //  2000-07-11 vtan: First check g_pdsvlvp for NULL. If this is NULL then the dwRefData
    //  has already been released in EnableCombinedView. There is only one DVLVPROP stored
    //  in the entire process in g_pdsvlvp. This seems like a problem. lamadio should fix
    //  this properly in the future.

    if ((g_pdsvlvp != NULL) &&
        pdsvlvp && 
        pdsvlvp->pdsv->_fCombinedView && 
        !pdsvlvp->fInPaint && 
        uMsg == WM_PAINT) 
    {
        // This code works well for general painting, like minimizing a window or
        // or surfacing the desktop.  However, it doesn't help the drag full windows
        // scenario very much.
        HRGN hrgn, hrgn2;
        RECT rc;
        HWND hwndT = GetSpecialSibling(hwnd);

        // Turn on animations!
        CombView_EnableAnimations(TRUE);

        if (hwndT && (hrgn = CreateRectRgn(0, 0, 0, 0))) 
        {
            if (hrgn2 = CreateRectRgn(0, 0, 0, 0)) 
            {
                pdsvlvp->fInPaint = TRUE;

                if (!GetClassLongPtr(hwndT, GCLP_HBRBACKGROUND))
                    SetClassLongPtr(hwndT, GCLP_HBRBACKGROUND, (LPARAM)GetStockObject(HOLLOW_BRUSH));

                if (GetUpdateRect(hwndT, &rc, FALSE)) 
                {
                    RECT rcLV = rc;
                    MapWindowPoints(hwndT, hwnd, (LPPOINT)&rcLV, 2);

                    SetRectRgn(hrgn2, rcLV.left, rcLV.top, rcLV.right, rcLV.bottom);
                    GetWindowRgn(hwnd, hrgn);
                    CombineRgn(hrgn2, hrgn, hrgn2, RGN_DIFF);
                    SetWindowRgn(hwnd, hrgn2, FALSE);
                    InvalidateRect(hwndT, &rc, FALSE);
                    UpdateWindow(hwndT);
                    SetWindowRgn(hwnd, hrgn, FALSE);
                    InvalidateRect(hwnd, &rcLV, FALSE);
                }
                else
                {
                    DeleteObject(hrgn);
                    DeleteObject(hrgn2);
                }

                pdsvlvp->fInPaint = FALSE;
            }
            else 
            {
                DeleteObject(hrgn);
            }
        }
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

// We need to set capture while we are stealing the mouse so that the
// window manager won't send WM_SETCURSOR messages to the wrong window.
// This function will also, as a side effect, send the WM_SETCURSOR to the
// listview so that it will set the hand cursor when it needs to.
void StealMouse(DVLVPROP * pdvlvp, BOOL fSteal, UINT msg)
{
    HWND hwndCapture = GetCapture();

    if (fSteal && (hwndCapture == NULL || hwndCapture == HWNDLISTVIEW)) 
    {
        // We need to set capture so that the window manager will not
        // try to send the w_setcursor message to the wrong window, and we
        // send it here ourself to the listview.
        SetCapture(HWNDLISTVIEW);
        SendMessage(HWNDLISTVIEW, WM_SETCURSOR, (WPARAM)HWNDLISTVIEW,
            MAKELPARAM(HTCLIENT, LOWORD(msg)));
    }
    else
    {
        // If the listview still has capture release it now
        if (HWNDLISTVIEW == hwndCapture)
            ReleaseCapture();
    }
}

LRESULT CALLBACK CombView_GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    #define LPMSG ((LPMSG)lParam)
    HHOOK hHookNext = NULL;

    if (g_pdsvlvp) 
    {
        if (LPMSG->message >= WM_MOUSEFIRST && LPMSG->message <= WM_MOUSELAST) 
        {
            POINT pt;

            pt.x = GET_X_LPARAM(LPMSG->lParam);
            pt.y = GET_Y_LPARAM(LPMSG->lParam);

            MapWindowPoints(LPMSG->hwnd, HWNDLISTVIEW, &pt, 1);
            int iHit = g_pdsvlvp->pdsv->_HitTest(&pt);

            // Unhook our hook when all of the mouse buttons are up and we're not over
            // an item in the listview
            if (GetKeyState(VK_LBUTTON) >= 0 &&
                GetKeyState(VK_RBUTTON) >= 0 &&
                GetKeyState(VK_MBUTTON) >= 0 &&
                iHit == -1) 
            {
                UnhookWindowsHookEx(g_pdsvlvp->hHookGetMsg);
                g_pdsvlvp->hHookGetMsg = NULL;
            } 
            else 
            {
                hHookNext = g_pdsvlvp->hHookGetMsg;
            }
                       
            if (IsChildOrSelf(GetSpecialSibling(HWNDLISTVIEW), LPMSG->hwnd) == S_OK) 
            {
                // If we have grabbed the mouse, give it to the listview
                LPMSG->hwnd = HWNDLISTVIEW;
                LPMSG->lParam = MAKELPARAM(LOWORD(pt.x), LOWORD(pt.y));
            }
        }
        else
        {
            hHookNext = g_pdsvlvp->hHookGetMsg;
        }

        // If we've just unhooked, or the hover is coming through to the listview and
        // no mouse button is down then clear our ownership of the mouse
        #define MK_BUTTON (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)
        if (!hHookNext ||
            // We need to special case the WM_MOUSEHOVER here so that the listview
            // is able to implement hover select.  If we have capture set when the
            // hover select message goes through then it will ignore the message, so
            // clear the capture now.
            (LPMSG->message == WM_MOUSEHOVER && LPMSG->hwnd == HWNDLISTVIEW && !(LPMSG->wParam & MK_BUTTON)))
            StealMouse(g_pdsvlvp, FALSE, 0);
    }

    if (hHookNext)
        CallNextHookEx(hHookNext, nCode, wParam, lParam);

    return 0;

    #undef LPMSG
}

BOOL DoesElementNeedMouse (LPTSTR psz)
{
    for (int i = 0; i < ARRAYSIZE(c_rgElements); i++) 
    {
        if (lstrcmpi(c_rgElements[i], psz) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL ShouldStealMouseClick(POINT * ppt, DVLVPROP * pdsvlvp)
{
    IHTMLDocument2 *pihtmldoc2;
    IHTMLElement *pielem;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pdsvlvp->pdsv->GetItemObject(SVGIO_BACKGROUND, IID_IHTMLDocument2, (void **)&pihtmldoc2))) 
    {
        // Work around for Trident issue - 
        // elementFromPoint is returning success here even though pielem is
        // still NULL.
        if (SUCCEEDED(pihtmldoc2->elementFromPoint(ppt->x, ppt->y, &pielem)) && pielem) 
        {
            IHTMLElement *pielemT;

            do {
                BSTR bstr = NULL;
                TCHAR sz[MAX_PATH];

                pielem->get_tagName(&bstr);

                SHUnicodeToTChar(bstr, sz, ARRAYSIZE(sz));

                SysFreeString(bstr);

                if (DoesElementNeedMouse(sz))
                {
                    hr = E_FAIL;
                }
                else
                {
                    if (SUCCEEDED(hr = pielem->get_parentElement(&pielemT)))
                    {
                        pielem->Release();
                        pielem = pielemT;
                    }
                    else
                    {
                        hr = S_OK;
                        pielem->Release();
                        pielem = NULL;
                    }
                }
            } while (SUCCEEDED(hr) && pielem);

            if (pielem)
                pielem->Release();
        }
        pihtmldoc2->Release();
    }

    return SUCCEEDED(hr);
}

LRESULT CALLBACK CombView_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    #define PMHS ((MOUSEHOOKSTRUCT *)lParam)

    if ((nCode == HC_ACTION) && g_pdsvlvp && (PMHS->hwnd != HWNDLISTVIEW) && IsWindowVisible(HWNDLISTVIEW)) 
    {
        // If it isn't over the listview and the button is going down or we're
        // moving over an area that would hit a listview icon then
        // we need to start hooking mouse events.  Install the GetMessage hook
        // so that we can do what we need to do.
        HWND hwndParent = GetSpecialSibling(HWNDLISTVIEW);
        POINT ptLV = PMHS->pt;

        HWND hwndHittest = WindowFromPoint(PMHS->pt);

        ScreenToClient(HWNDLISTVIEW, &ptLV);
        int iHit = g_pdsvlvp->pdsv->_HitTest(&ptLV);
        ScreenToClient(hwndParent, &(PMHS->pt));

        BOOL fStealMouse = (ISMOUSEDOWN(wParam) && ShouldStealMouseClick(&(PMHS->pt), g_pdsvlvp)) ||
                           (!GetCapture() && (iHit != -1) && (!hwndHittest || (hwndHittest == HWNDLISTVIEW)));

        if (!g_pdsvlvp->hHookGetMsg) 
        {
            if (hwndHittest && (IsChildOrSelf(hwndParent, hwndHittest) == S_OK)) 
            {
                if (fStealMouse) 
                {
                    // Note:  We have to steal the mouse at this point and use the
                    // GetMessage hook to redirect the mouse messages to our listview
                    // window.  If we do something different like swallow the message here
                    // and then PostMessage faked up events to the listview then all
                    // of the hover select functionality will break because the system
                    // won't detect the mouse as being over the listview.
                    StealMouse(g_pdsvlvp, TRUE, (UINT) wParam);
                    g_pdsvlvp->hHookGetMsg = SetWindowsHookEx(WH_GETMESSAGE, CombView_GetMsgHook,
                                                NULL, GetCurrentThreadId());
                }
            }                                          
        }
        else
        {
            if (fStealMouse) 
                StealMouse(g_pdsvlvp, TRUE, (UINT) wParam);
            else
                SendMessage(HWNDLISTVIEW, WM_SETCURSOR, (WPARAM)HWNDLISTVIEW, MAKELPARAM(HTCLIENT, LOWORD((UINT) wParam)));
        }
    }

    if (g_pdsvlvp)
        return CallNextHookEx(g_pdsvlvp->hHookMouse, nCode, wParam, lParam);
    else
        return 0;

    #undef PMHS
}

/*
 * This is the main entry point where a defview can be turned into a combined
 * view.  The effect of a combined view is to layer an extended view under
 * the listview icons (via a regional listview) of a normal defview.
 *
 * Warnings:
 * 1) This is currently only used by the "Active Desktop", it is optimized
 * to only support one instance.  Multiple combined views are not currently supported.
 * 2) Disabling the combined view doesn't completely unhook itself from the defview
 */
void EnableCombinedView(CDefView *pdsv, BOOL fEnable)
{
    DVLVPROP * pdsvlvp = g_pdsvlvp;

    if (pdsvlvp) 
    {
        if (!fEnable) 
        {
            // Unhook ourselves
            UnhookWindowsHookEx(pdsvlvp->hHookMouse);
            if (pdsvlvp->hHookGetMsg) 
            {
                UnhookWindowsHookEx(pdsvlvp->hHookGetMsg);
                StealMouse(pdsvlvp, FALSE, 0);
            }
            g_pdsvlvp = NULL;
            RemoveWindowSubclass(pdsv->_hwndListview, CombView_LV_SubclassProc, COMBVIEW_SUBCLASS_ID);

            LocalFree((HLOCAL)pdsvlvp);
        }
    }
    else
    {
        if (fEnable) 
        {
            pdsvlvp = (DVLVPROP *)LocalAlloc(LPTR, sizeof(DVLVPROP));
            if (pdsvlvp) 
            {
                // We are only expecting one combined view
                ASSERT(g_pdsvlvp == NULL);

                // Get ourself hooked in
                pdsvlvp->pdsv = pdsv;
                SetWindowSubclass(pdsv->_hwndListview, CombView_LV_SubclassProc, COMBVIEW_SUBCLASS_ID, (DWORD_PTR)pdsvlvp);
                pdsvlvp->hHookMouse = SetWindowsHookEx(WH_MOUSE, CombView_MouseHook, NULL, GetCurrentThreadId());
                g_pdsvlvp = pdsvlvp;
            }
        }
    }
}

/*
 * This function is used to optimize the combined view ("Active Desktop") by turning
 * off any animated html elements or embeddings when it is completely obscured.
 *
 * Note that we always honor enabling animations if they aren't already enabled. 
 * To make the client code easier though we only disable animations if we know
 * the desktop is obscured.
 *
 * Returns: The state of animation after the call
 */
BOOL CombView_EnableAnimations(BOOL fEnable)
{
    static BOOL fEnabled = TRUE;

    if ((fEnable != fEnabled) && g_pdsvlvp)
    {
        IOleCommandTarget* pct;
        BOOL fChangeAnimationState = fEnable;

        if (!fEnable)
        {
            HDC hdc;
            RECT rc;
            HWND hwnd;

            if ((hwnd = GetSpecialSibling(HWNDLISTVIEW)) && (hdc = GetDC(hwnd)))
            {
                fChangeAnimationState = (GetClipBox(hdc, &rc) == NULLREGION);
                ReleaseDC(hwnd, hdc);
            }
        }

        if (fChangeAnimationState &&
            SUCCEEDED(g_pdsvlvp->pdsv->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            VARIANT var = { 0 };

            TraceMsg(DM_TRACE, "Active Desktop: Animation state is changing:%d", fEnable);

            var.vt = VT_I4;
            var.lVal = fEnable;
            pct->Exec(NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            pct->Release();
            fEnabled = fEnable;
        }
    }
    return fEnabled;
}

// IDocHostUIHandler
// This is implemented by the combined view so that we can support various
// Win95 desktop functionality in a compatible way in the extended view.
// Some examples include picking off context menu invocations, configuring the
// host to display the way we want it too, and modifying drag/drop behavior.

HRESULT CSFVSite::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    // For Web View's w/o DVOC, it might be nice to let Trident's menu through...
    if ((dwID == CONTEXT_MENU_DEFAULT || dwID == CONTEXT_MENU_IMAGE) && pView->_hwndListview) 
    {
        // we used to unselect everything first, but that's bogus because it breaks the app key trying
        // to get a context menu on the currently selected items
        
        // BOGUS - Trident blows up if we send the message here and the user
        // turns off webview.  Post it for now.
        PostMessage(pView->_hwndListview, WM_CONTEXTMENU,
            (WPARAM)pView->_hwndListview, MAKELPARAM((short)LOWORD(ppt->x), (short)LOWORD(ppt->y)));
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

// IDocHostUIHandler
HRESULT CSFVSite::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    pInfo->cbSize = sizeof(*pInfo);

    if (pView->_fCombinedView)
    {
        pInfo->dwFlags = DOCHOSTUIFLAG_DISABLE_HELP_MENU |  // We don't want Trident's help
                         DOCHOSTUIFLAG_NO3DBORDER |         // Desktop should be borderless
                         DOCHOSTUIFLAG_SCROLL_NO; // |          // Desktop should never scroll
                         // DOCHOSTUIFLAG_DIALOG;              // Prevent selection in Trident
    }
    else
    {
        pInfo->dwFlags = DOCHOSTUIFLAG_DISABLE_HELP_MENU |
                         DOCHOSTUIFLAG_DIALOG |
                         DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE;
    }

    if (SHIsLowMemoryMachine(ILMM_IE4))
        pInfo->dwFlags = pInfo->dwFlags | DOCHOSTUIFLAG_DISABLE_OFFSCREEN;
    
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default
    return S_OK;
}

HRESULT CSFVSite::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
                         IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    // Host did not display its own UI. Trident will proceed to display its own. 
    return S_OK;
}

HRESULT CSFVSite::HideUI(void)
{
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CSFVSite::UpdateUI(void)
{
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CSFVSite::EnableModeless(BOOL fEnable)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame.

    // Trap F5 alone and handle the refresh ourselves!
    // Note:This code-path will be hit for desktop only if the active desktop
    // is turned on.
    //
    // And probably if focus is on Trident. It's probably good to
    // pick this off for Web View too.
    //
    if ((lpMsg->message == WM_KEYDOWN) && (lpMsg->wParam == VK_F5))
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

        pView->Refresh();

        return S_OK;
    }
    return S_FALSE; // The message was not translated
}

HRESULT CSFVSite::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CSFVSite::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    HRESULT hr;

    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    if (!pView->_IsDesktop())
    {
        hr = S_FALSE;  // Let trident delegate in webview folders
    }
    else
    {
        if (_dt._pdtFrame == NULL) 
        {
            pView->_psb->QueryInterface(IID_PPV_ARG(IDropTarget, &_dt._pdtFrame));
        }

        if (_dt._pdtFrame) 
        {
            *ppDropTarget = &_dt;
            AddRef();

            hr = S_OK;
        }
        else
        {
            ASSERT(0);
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT CSFVSite::GetExternal(IDispatch **ppDisp)
{
    HRESULT hr;

    if (ppDisp)
    {
        *ppDisp = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSFVSite::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    HRESULT hr;

    if (ppchURLOut)
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSFVSite::FilterDataObject(IDataObject *pdtobj, IDataObject **ppdtobjRet)
{
    HRESULT hr;

    if (ppdtobjRet)
    {
        *ppdtobjRet = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\clientxi.cpp ===
#include "shellprv.h"
#include "defcm.h"
#include "datautil.h"

/////////////////////////////////////////////////////////////////////////////
// CClientExtractIcon

class CClientExtractIconCB;

class ATL_NO_VTABLE CClientExtractIcon
    : public IShellExtInit
    , public IExtractIconW
    , public IExtractIconA
    , public IContextMenu
    , public IPersistPropertyBag
    , public IServiceProvider
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CClientExtractIcon, &CLSID_ClientExtractIcon>
{
public:

BEGIN_COM_MAP(CClientExtractIcon)
    COM_INTERFACE_ENTRY(IShellExtInit)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IExtractIconA, IExtractIconA)
    COM_INTERFACE_ENTRY_IID(IID_IExtractIconW, IExtractIconW)
    COM_INTERFACE_ENTRY_IID(IID_IContextMenu,  IContextMenu)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CClientExtractIcon)

public:
    // *** IShellExtInit ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder,
                            IDataObject *pdto,
                            HKEY hkProgID);

    // *** IExtractIconA ***
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

    // *** IExtractIconW ***
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPWSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO pici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_ClientExtractIcon; return S_OK; }

    // *** IPersistPropertyBag methods ***
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *pbg,
                    IErrorLog *plog);
    STDMETHOD(Save)(IPropertyBag *pbg,
                    BOOL fClearDirty,
                    BOOL FSaveAllProperties) { return E_NOTIMPL; }

    // *** IServiceProvider methods ***
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

public:
    CClientExtractIcon() : _idmProperties(-1) { }
    ~CClientExtractIcon();

    // *** IContextMenuCB forwarded back to us ***
    HRESULT CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    IContextMenu *          _pcmInner;
    IAssociationElement *   _pae;
    IPropertyBag *          _pbag;
    LPITEMIDLIST            _pidlObject;
    CComObject<CClientExtractIconCB> *  _pcb;
    HKEY                    _hkClass;
    UINT                    _idmProperties;
    UINT                    _idCmdFirst;
};


/////////////////////////////////////////////////////////////////////////////
// CClientExtractIconCB - DefCM callback
//
class ATL_NO_VTABLE CClientExtractIconCB
    : public IContextMenuCB
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CClientExtractIconCB>
{
public:

BEGIN_COM_MAP(CClientExtractIconCB)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IContextMenuCB, IContextMenuCB)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CClientExtractIconCB)

    void Attach(CClientExtractIcon *pcxi) { _pcxi = pcxi; }

public:
    // *** IContextMenuCB ***
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        if (_pcxi)
            return _pcxi->CallBack(psf, hwnd, pdtobj, uMsg, wParam, lParam);

        return E_FAIL;
    }

public:
    CClientExtractIcon *_pcxi;
};

/////////////////////////////////////////////////////////////////////////////

STDAPI CClientExtractIcon_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppunk)
{
    return CClientExtractIcon::_CreatorClass::CreateInstance(punkOuter, riid, ppunk);
}

CClientExtractIcon::~CClientExtractIcon()
{
    InitNew();
}


// *** IPersistPropertyBag::InitNew ***
HRESULT CClientExtractIcon::InitNew()
{
    ATOMICRELEASE(_pcmInner);
    ATOMICRELEASE(_pae);
    ATOMICRELEASE(_pbag);
    ILFree(_pidlObject);
    if (_hkClass) RegCloseKey(_hkClass);
    if (_pcb)
    {
        _pcb->Attach(NULL); // break circular reference
        _pcb->Release();
        _pcb = NULL;
    }

    return S_OK;
}

//
//  Property bag items:
//
//  Element = CLSID_Assoc* element to create
//  InitString = string to IPersistString2::SetString with
//  opentext = display name for "open" command (if not overridden)
//
//  If the client did not customize a "properties" command, then we
//  also use these values:
//
//      properties = program to execute for "properties"
//      propertiestext = name for the "properties" command
//

// *** IPersistPropertyBag::Load ***
HRESULT CClientExtractIcon::Load(IPropertyBag *pbag, IErrorLog *plog)
{
    HRESULT hr;

    // Erase any old state
    InitNew();

    // Save the property bag so we can mess with him later
    _pbag = pbag;
    if (_pbag)
    {
        _pbag->AddRef();
    }

    // Get the CLSID we are dispatching through and initialize it
    // with the InitString.
    CLSID clsid;
    hr = SHPropertyBag_ReadGUID(pbag, L"Element", &clsid);
    if (SUCCEEDED(hr))
    {
        BSTR bs;
        hr = SHPropertyBag_ReadBSTR(pbag, L"InitString", &bs);
        if (SUCCEEDED(hr))
        {
            hr = THR(AssocElemCreateForClass(&clsid, bs, &_pae));
            ::SysFreeString(bs);

            // Ignore failure of AssocElemCreateForClass
            // It can fail if the user's default client got uninstalled
            hr = S_OK;
        }
    }

    return hr;
}

// *** IServiceProvider::QueryService ***
//
//  We cheat and use ISericeProvider::QueryService as a sort of
//  "QueryInterface that's allowed to break COM identity rules".
//

HRESULT CClientExtractIcon::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (guidService == IID_IAssociationElement && _pae)
    {
        return _pae->QueryInterface(riid, ppvObj);
    }
    *ppvObj = NULL;
    return E_FAIL;
}

// *** IShellExtInit::Initialize
//
//  Only if the HKEY specifies a ClientType.
//
HRESULT CClientExtractIcon::Initialize(LPCITEMIDLIST, IDataObject *pdto, HKEY hkClass)
{
    ILFree(_pidlObject);

    HRESULT hr = PidlFromDataObject(pdto, &_pidlObject);

    if (_hkClass)
    {
        RegCloseKey(_hkClass);
    }
    if (hkClass)
    {
        _hkClass = SHRegDuplicateHKey(hkClass);
    }
    return hr;
}

// *** IExtractIconA::GetIconLocation

HRESULT CClientExtractIcon::GetIconLocation(
            UINT uFlags, LPSTR szIconFile, UINT cchMax,
            int *piIndex, UINT *pwFlags)
{
    WCHAR wszPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, wszPath, ARRAYSIZE(wszPath), piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(wszPath, szIconFile, cchMax);
    }
    return hr;
}

// *** IExtractIconA::Extract

HRESULT CClientExtractIcon::Extract(
            LPCSTR pszFile, UINT nIconIndex,
            HICON *phiconLarge, HICON *phiconSmall,
            UINT nIconSize)
{
    return S_FALSE;
}

// *** IExtractIconW::GetIconLocation

HRESULT CClientExtractIcon::GetIconLocation(
            UINT uFlags, LPWSTR szIconFile, UINT cchMax,
            int *piIndex, UINT *pwFlags)
{
    szIconFile[0] = L'\0';

    if (_pae)
    {
        LPWSTR pszIcon;
        HRESULT hr = _pae->QueryString(AQS_DEFAULTICON, NULL, &pszIcon);
        if (SUCCEEDED(hr))
        {
            lstrcpynW(szIconFile, pszIcon, cchMax);
            SHFree(pszIcon);
        }
    }


    if (!szIconFile[0] && _hkClass)
    {
        LONG cb = cchMax * sizeof(TCHAR);
        RegQueryValueW(_hkClass, L"DefaultIcon", szIconFile, &cb);
    }

    if (szIconFile[0])
    {
        *pwFlags = GIL_PERCLASS;
        *piIndex = PathParseIconLocationW(szIconFile);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

// *** IExtractIconW::Extract

HRESULT CClientExtractIcon::Extract(
            LPCWSTR pszFile, UINT nIconIndex,
            HICON *phiconLarge, HICON *phiconSmall,
            UINT nIconSize)
{
    return S_FALSE;
}

// *** IContextMenuCB forwarded back to us ***
HRESULT CClientExtractIcon::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WCHAR wszBuf[MAX_PATH];

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        {
            QCMINFO *pqcm = (QCMINFO *)lParam;
            //  Add a "Properties" command in case we end up needing one.
            //  (And if not, we'll remove it afterwards.)

            if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"propertiestext", wszBuf, ARRAYSIZE(wszBuf))))
            {
                SHLoadIndirectString(wszBuf, wszBuf, ARRAYSIZE(wszBuf), NULL);
                InsertMenuW(pqcm->hmenu, pqcm->indexMenu, MF_BYPOSITION | MF_STRING, pqcm->idCmdFirst, wszBuf);
                _idmProperties = pqcm->idCmdFirst++;
            }
            return S_OK;            // Please merge the HKEY\shell stuff
        }

    case DFM_MERGECONTEXTMENU_TOP:
        // The app has added its menu items; see what needs to be cleaned up
        {
            QCMINFO *pqcm = (QCMINFO *)lParam;

            // See if they added a "Properties" item.
            // If so, then delete ours.
            if (GetMenuIndexForCanonicalVerb(pqcm->hmenu, _pcmInner, _idCmdFirst, L"properties") != 0xFFFFFFFF)
            {
                // Yes they do, so delete our bogus one
                DeleteMenu(pqcm->hmenu, _idmProperties, MF_BYCOMMAND);
                _idmProperties = -1;
            }

            // Now see if their "open" command uses the default name.
            // If so, then we replace it with a friendlier name.
            BOOL fCustomOpenString = FALSE;
            IAssociationElement *paeOpen;
            if (_pae && SUCCEEDED(_pae->QueryObject(AQVO_SHELLVERB_DELEGATE, L"open", IID_PPV_ARG(IAssociationElement, &paeOpen))))
            {
                if (SUCCEEDED(paeOpen->QueryExists(AQN_NAMED_VALUE, L"MUIVerb")) ||
                    SUCCEEDED(paeOpen->QueryExists(AQN_NAMED_VALUE, NULL)))
                {
                    fCustomOpenString = TRUE;
                }
                paeOpen->Release();
            }

            if (!fCustomOpenString)
            {
                UINT idm = GetMenuIndexForCanonicalVerb(pqcm->hmenu, _pcmInner, _idCmdFirst, L"open");
                if (idm != 0xFFFFFFFF)
                {
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"opentext", wszBuf, ARRAYSIZE(wszBuf))) &&
                        wszBuf[0])
                    {
                        SHLoadIndirectString(wszBuf, wszBuf, ARRAYSIZE(wszBuf), NULL);
                        MENUITEMINFO mii;
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_STRING;
                        mii.dwTypeData = wszBuf;
                        SetMenuItemInfo(pqcm->hmenu, idm, TRUE, &mii);
                    }
                }
            }
        }
        return S_OK;


    case DFM_INVOKECOMMANDEX:
        switch (wParam)
        {
        case 0:     // Properties
            if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"properties", wszBuf, ARRAYSIZE(wszBuf))))
            {
                DFMICS *pdfmics = (DFMICS *)lParam;
                if (ShellExecCmdLine(pdfmics->pici->hwnd, wszBuf, NULL, SW_SHOWNORMAL, NULL, 0))
                {
                    return S_OK;
                }
                else
                {
                    return E_FAIL;
                }
            }
            break;

        default:
            ASSERT(!"Unexpected DFM_INVOKECOMMAND");
            break;
        }
        return E_FAIL;

    default:
        return E_NOTIMPL;
    }
}

// *** IContextMenu::QueryContextMenu ***
HRESULT CClientExtractIcon::QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    HRESULT hr;
    if (!_pcmInner)
    {
        HKEY hk = NULL;
        if (_pae)
        {
            // If this fails, we continue with a NULL key
            AssocKeyFromElement(_pae, &hk);
        }

        if (!_pcb)
        {
            hr = CComObject<CClientExtractIconCB>::CreateInstance(&_pcb);
            if (SUCCEEDED(hr))
            {
                _pcb->Attach(this);
                _pcb->AddRef();
            }
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHGetDesktopFolder(&psf);
            if (SUCCEEDED(hr))
            {
                DEFCONTEXTMENU dcm = {
                    NULL,                       // hwnd
                    _pcb,                       // pcmcb
                    NULL,                       // pidlFolder
                    psf,                        // IShellFolder
                    1,                          // cidl
                    (LPCITEMIDLIST*)&_pidlObject, // apidl
                    NULL,                       // paa
                    1,                          // cKeys
                    &hk,                        // aKeys
                };
                hr = CreateDefaultContextMenu(&dcm, &_pcmInner);
                psf->Release();
            }
        }

        if (hk)
        {
            RegCloseKey(hk);
        }

        if (!_pcmInner)
        {
            return E_FAIL;
        }
    }

    if (_pcmInner)
    {
        _idCmdFirst = idCmdFirst;
        uFlags |= CMF_VERBSONLY; // Don't do cut/copy/paste/link
        hr = _pcmInner->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// *** IContextMenu::InvokeCommand ***
HRESULT CClientExtractIcon::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    if (_pcmInner)
    {
        hr = _pcmInner->InvokeCommand(pici);
    }

    return hr;
}

// *** IContextMenu::GetCommandString ***
HRESULT CClientExtractIcon::GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    if (!_pcmInner) return E_FAIL;

    return _pcmInner->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\confirmationui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File: ConfirmationUI.cpp
//
//  Contents: Confirmation UI for storage based copy engine
//
//  History:  20-Mar-2000 ToddB
//
//--------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop

#include "ConfirmationUI.h"
#include "resource.h"
#include "ntquery.h"
#include "ids.h"

#include <initguid.h>

#define TF_DLGDISPLAY   0x00010000  // messages related to display of the confirmation dialog
#define TF_DLGSTORAGE   0x00020000  // messages related to using the legacy IStorage to get dialog info
#define TF_DLGISF       0x00040000  // messages related to using IShellFolder to get dialog info

#define RECT_WIDTH(rc)  ((rc).right - (rc).left)
#define RECT_HEIGHT(rc) ((rc).bottom - (rc).top)

GUID guidStorage = PSGUID_STORAGE;


// prototype some functions that are local to this file:
void ShiftDialogItem(HWND hDlg, int id, int cx, int cy);
BOOL CALLBACK ShiftLeftProc(HWND hwnd, LPARAM lParam);


STDAPI CTransferConfirmation_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (!ppv)
        return E_POINTER;

    CComObject<CTransferConfirmation> *pObj = NULL;
    // created with ref count of 0
    if (SUCCEEDED(CComObject<CTransferConfirmation>::CreateInstance(&pObj)))
    {
        // QueryInterface ups the refcount to 1
        if (SUCCEEDED(pObj->QueryInterface(riid, ppv)))
        {
            return S_OK;
        }

        // failed to get the right interface, delete the object.
        delete pObj;
    }

    *ppv = NULL;
    return E_FAIL;
}

CTransferConfirmation::CTransferConfirmation() :
    m_fSingle(TRUE)
{
    ASSERT(NULL == m_pszDescription);
    ASSERT(NULL == m_pszTitle);
    ASSERT(NULL == m_hIcon);
    ASSERT(NULL == m_pPropUI);
    ASSERT(NULL == m_cItems);
}

CTransferConfirmation::~CTransferConfirmation()
{
    if (m_pPropUI)
        m_pPropUI->Release();
}

int _TitleFromFileOperation(DWORD dwOp)
{
    switch (dwOp)
    {
    case STGOP_RENAME:
        return IDS_CONFIRM_FILE_RENAME;
    case STGOP_REMOVE:
        return IDS_CONFIRM_FILE_DELETE;
    case STGOP_MOVE:
        return IDS_CONFIRM_FILE_MOVE;
    default:
        AssertMsg(0, TEXT("Inappropriate Operation code in _TitleFromFileOperation"));
    }
    return IDS_DEFAULTTITLE;
}
int _TitleFromFolderOperation(DWORD dwOp)
{
    switch (dwOp)
    {
    case STGOP_RENAME:
        return IDS_CONFIRM_FOLDER_RENAME;
    case STGOP_REMOVE:
        return IDS_CONFIRM_FOLDER_DELETE;
    case STGOP_MOVE:
        return IDS_CONFIRM_FOLDER_MOVE;
    default:
        AssertMsg(0, TEXT("Inappropriate Operation code in _TitleFromFolderOperation"));
    }
    return IDS_DEFAULTTITLE;
}

BOOL CTransferConfirmation::_IsCopyOperation(STGOP stgop)
{
    return (stgop == STGOP_COPY) || (stgop == STGOP_COPY_PREFERHARDLINK);
}

// TODO: Get better icons for "Nuke File" and "Nuke Folder" from design.
// TODO: Get better icons for "Move File" and "Move Folder" from design.
// TODO: Get better icons for "Secondary Attribute loss" from design (stream loss, encrypt loss, ACL loss, etc)
HRESULT CTransferConfirmation::_GetDialogSettings()
{
    _FreeDialogSettings();

    ASSERT(NULL == m_pszDescription);
    ASSERT(NULL == m_pszTitle);
    ASSERT(NULL == m_hIcon);
    ASSERT(NULL == m_cItems);

    m_fSingle = (m_cop.cRemaining<=1);
    // Set the default values of m_crResult so that if the dialog is killed or
    // some error occurs we give a valid default response.
    m_crResult = CONFRES_CANCEL;
    
    if (m_cop.pcc)
    {
        // we already have the strings to use

        switch (m_cop.pcc->dwButtons)
        {
        case CCB_YES_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            break;

        case CCB_RENAME_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            break;

        case CCB_YES_SKIP_RENAME_CANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            break;

        case CCB_RETRY_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
            break;
            
        case CCB_OK:
            m_idDialog = IDD_CONFIRM_OK;
            break;
            
        default:
            return E_INVALIDARG; // REVIEW: should we define more specific error codes like STG_E_INVALIDBUTTONOPTIONS?
        }

        if (m_cop.pcc->dwFlags & CCF_SHOW_SOURCE_INFO)
        {
            _AddItem(m_cop.psiItem);
        }
        
        if (m_cop.pcc->dwFlags & CCF_SHOW_DESTINATION_INFO)
        {
            _AddItem(m_cop.psiDest);
        }
    }
    else
    {
        TCHAR szBuf[2048];    
        int idTitle = 0;
        int idIcon = 0;
        int idDescription = 0;

        ////////////////////////////////////////////////////////////////////////////////
        // These are "confirmations", i.e. conditions the user can choose to ignore.
        // You can typically answer "Yes", "Skip", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
    
        if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_READONLY_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_READONLY_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_READONLY_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_READONLY_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_SYSTEM_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_SYSTEM_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_TOOLARGE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_NUKE_FILE;
            idDescription = IDS_DELETE_TOOBIG_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_TOOLARGE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_NUKE_FOLDER;
            idDescription = IDS_DELETE_TOOBIG_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_WONT_RECYCLE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_NUKE_FILE;
            idDescription = IDS_NUKE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_WONT_RECYCLE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_NUKE_FOLDER;
            idDescription = IDS_NUKE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_PROGRAM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_PROGRAM_FILE;
            m_fShowARPLink = TRUE;  // TODO)) implement ShowARPLink
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_MOVE_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_MOVE;
            idIcon = IDI_MOVE;
            idDescription = IDS_MOVE_SYSTEM_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_MOVE_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_MOVE;
            idIcon = IDI_MOVE;
            idDescription = IDS_MOVE_SYSTEM_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_RENAME_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_RENAME;
            idIcon = IDI_RENAME;
            idDescription = IDS_RENAME_SYSTEM_FILE;  // Two Arg
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_RENAME_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_RENAME;
            idIcon = IDI_RENAME;
            idDescription = IDS_RENAME_SYSTEM_FOLDER;  // Two Arg
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_STREAM_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_STREAM_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_STREAM_LOSS_COPY_FILE : IDS_STREAM_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_STREAM_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_STREAM_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_STREAM_LOSS_COPY_FOLDER : IDS_STREAM_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_METADATA_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_METADATA_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_METADATA_LOSS_COPY_FILE : IDS_METADATA_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_METADATA_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_METADATA_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_METADATA_LOSS_COPY_FOLDER : IDS_METADATA_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_COMPRESSION_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_COMPRESSION_LOSS_COPY_FILE : IDS_COMPRESSION_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_COMPRESSION_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_COMPRESSION_LOSS_COPY_FOLDER : IDS_COMPRESSION_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_SPARSEDATA_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_SPARSE_LOSS_COPY_FILE : IDS_SPARSE_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ENCRYPTION_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_ENCRYPTION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_ENCRYPTION_LOSS_COPY_FILE : IDS_ENCRYPTION_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            // is it on purpose that we are not adding item here
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ENCRYPTION_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_ENCRYPTION_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_ENCRYPTION_LOSS_COPY_FOLDER : IDS_ENCRYPTION_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }

        else if (IsEqualIID(m_cop.stc, STCONFIRM_ACCESSCONTROL_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_ACL_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ACCESSCONTROL_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_ACL_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_LFNTOFAT_STREAM))
        {
            idTitle = IDS_SELECT_FILE_NAME;
            idIcon = IDI_RENAME;
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_LFNTOFAT_STORAGE))
        {
            idTitle = IDS_SELECT_FOLDER_NAME;
            idIcon = IDI_RENAME;
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        ////////////////////////////////////////////////////////////////////////////////
        // These are the "do you want to replace something" cases, they are special in
        // that you can answer "Yes", "Skip", "Rename", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_REPLACE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_REPLACE;
            idIcon = IDI_REPLACE_FILE;
            idDescription = IDS_REPLACE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            _AddItem(m_cop.psiDest, IDS_REPLACEEXISTING_FILE);
            _AddItem(m_cop.psiItem, IDS_WITHTHIS);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_REPLACE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_REPLACE;
            idIcon = IDI_REPLACE_FOLDER;
            idDescription = IDS_REPLACE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            _AddItem(m_cop.psiDest, IDS_REPLACEEXISTING_FOLDER);
            _AddItem(m_cop.psiItem, IDS_INTOTHIS);
        }
    
        ////////////////////////////////////////////////////////////////////////////////
        // This group is "error messages", you can typically reply with "Skip",
        // "Retry", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
        else
        {
            // See if the guid is one of our phony guids that's really just an HRESULT and a bunch of zeros.
            // To do this we treat the guid like an array of 4 DWORDS and check the last 3 DWORDs against 0.
            AssertMsg(sizeof(m_cop.stc) == 4*sizeof(DWORD), TEXT("Size of STGTRANSCONFIRMATION is not 128 bytes!"));
            DWORD *pdw = (DWORD*)&m_cop.stc;
            if (pdw[1] == 0 && pdw[2] == 0 && pdw[3] == 0)
            {
                HRESULT hrErr = pdw[0];
                switch (hrErr)
                {
                case STG_E_FILENOTFOUND:
                case STG_E_PATHNOTFOUND:

                case STG_E_ACCESSDENIED:

                case STG_E_INUSE:
                case STG_E_SHAREVIOLATION:
                case STG_E_LOCKVIOLATION:

                case STG_E_DOCFILETOOLARGE:
                case STG_E_MEDIUMFULL:

                case STG_E_INSUFFICIENTMEMORY:

                case STG_E_DISKISWRITEPROTECTED:

                case STG_E_FILEALREADYEXISTS:

                case STG_E_INVALIDNAME:

                case STG_E_REVERTED:

                case STG_E_DOCFILECORRUPT:

                    // these are expected errors for which we should have custom friendly strings:

                    // TODO: Get friendly messages for these errors from UA
                    idTitle = IDS_DEFAULTTITLE;
                    idIcon = IDI_DEFAULTICON;
                    idDescription = IDS_DEFAULTDESC;
                    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
                    break;

                // these are errors I don't think we should ever see, so I'm asserting but then falling through to the
                // default case anyway.  In most cases I simply don't know what these mean.
                case E_PENDING:
                case STG_E_CANTSAVE:
                case STG_E_SHAREREQUIRED:
                case STG_E_NOTCURRENT:
                case STG_E_WRITEFAULT:
                case STG_E_READFAULT:
                case STG_E_SEEKERROR:
                case STG_E_NOTFILEBASEDSTORAGE:
                case STG_E_NOTSIMPLEFORMAT:
                case STG_E_INCOMPLETE:
                case STG_E_TERMINATED:
                case STG_E_BADBASEADDRESS:
                case STG_E_EXTANTMARSHALLINGS:
                case STG_E_OLDFORMAT:
                case STG_E_OLDDLL:
                case STG_E_UNKNOWN:
                case STG_E_UNIMPLEMENTEDFUNCTION:
                case STG_E_INVALIDFLAG:
                case STG_E_PROPSETMISMATCHED:
                case STG_E_ABNORMALAPIEXIT:
                case STG_E_INVALIDHEADER:
                case STG_E_INVALIDPARAMETER:
                case STG_E_INVALIDFUNCTION:
                case STG_E_TOOMANYOPENFILES:
                case STG_E_INVALIDHANDLE:
                case STG_E_INVALIDPOINTER:
                case STG_E_NOMOREFILES:

                    TraceMsg(TF_ERROR, "We should never be asked to confirm this error (%08x)", hrErr);
                  
                    // fall through...

                default:
                    // Use FormatMessage to get the default description for this error message.  Sure that's totally
                    // useless to the end user, but its more useful that nothing which is the altnerative.

                    idTitle = IDS_DEFAULTTITLE;
                    idIcon = IDI_DEFAULTICON;
                    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hrErr, 0, szBuf, ARRAYSIZE(szBuf), NULL))
                    {
                        m_pszDescription = StrDup(szBuf);
                    }
                    else
                    {
                        idDescription = IDS_DEFAULTDESC;
                    }
                    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
                    break;
                }
            }
            else
            {
                // for the default case we show an "unknown error" message and offer
                // "skip", "retry", and "cancel".  We should never get to this code path.
                TraceMsg(TF_ERROR, "An unknown non-custom error is being display in CTransferConfirmation!");
        
                idTitle = IDS_DEFAULTTITLE;
                idIcon = IDI_DEFAULTICON;
                idDescription = IDS_DEFAULTDESC;
                m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
            }
        }

        if (idTitle && LoadString(_Module.GetResourceInstance(), idTitle, szBuf, ARRAYSIZE(szBuf)))
        {
            m_pszTitle = StrDup(szBuf);
        }
        if (idIcon)
        {
            m_hIcon = (HICON)LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(idIcon), IMAGE_ICON, 0,0, LR_DEFAULTSIZE);
        }
        if (idDescription && LoadString(_Module.GetResourceInstance(), idDescription, szBuf, ARRAYSIZE(szBuf)))
        {
            m_pszDescription = StrDup(szBuf);
        }
    }

    if (m_fSingle)
    {
        // we don't show the "skip" button if only a single item is being moved.
        switch(m_idDialog)
        {
            case IDD_CONFIRM_RETRYSKIPCANCEL:
                m_idDialog = IDD_CONFIRM_RETRYCANCEL;
                break;
            case IDD_CONFIRM_YESSKIPCANCEL:
                m_idDialog = IDD_CONFIRM_YESCANCEL;
                break;
            case IDD_CONFIRM_RENAMESKIPCANCEL:
                m_idDialog = IDD_CONFIRM_RENAMECANCEL;
                break;
            case IDD_CONFIRM_YESSKIPRENAMECANCEL:
                m_idDialog = IDD_CONFIRM_YESRENAMECANCEL;
                break;
            default:
                break;      // unknown dialog
        }
    }

    // rename - not really implemented yet
    switch(m_idDialog)
    {
        case IDD_CONFIRM_RENAMESKIPCANCEL:
            m_idDialog = IDD_CONFIRM_SKIPCANCEL;
            break;
        case IDD_CONFIRM_RENAMECANCEL:
            m_idDialog = IDD_CONFIRM_CANCEL;
            break;
        case IDD_CONFIRM_YESSKIPRENAMECANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            break;
        case IDD_CONFIRM_YESRENAMECANCEL:
            m_idDialog = IDD_CONFIRM_YESCANCEL;
            break;
        default:
            break;      // Non-rename dialog
    }

    return S_OK;
}

// free everything loaded or allocated in _GetDialogSetttings.
HRESULT CTransferConfirmation::_FreeDialogSettings()
{
    if (m_pszTitle)
    {
        LocalFree(m_pszTitle);
        m_pszTitle = NULL;
    }
    if (m_hIcon)
    {
        DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }
    if (m_pszDescription)
    {
        LocalFree(m_pszDescription);
        m_pszDescription = NULL;
    }

    // This array is zeroed before usage, anything that's no longer zero needs to
    // be freed in the appropriate mannor.
    for (int i=0; i<ARRAYSIZE(m_rgItemInfo); i++)
    {
        if (m_rgItemInfo[i].pwszIntro)
        {
            delete [] m_rgItemInfo[i].pwszIntro;
            m_rgItemInfo[i].pwszIntro = NULL;
        }
        if (m_rgItemInfo[i].pwszDisplayName)
        {
            CoTaskMemFree(m_rgItemInfo[i].pwszDisplayName);
            m_rgItemInfo[i].pwszDisplayName = NULL;
        }
        if (m_rgItemInfo[i].pwszAttribs)
        {
            SHFree(m_rgItemInfo[i].pwszAttribs);
            m_rgItemInfo[i].pwszAttribs = NULL;
        }
        if (m_rgItemInfo[i].hBitmap)
        {
            DeleteObject(m_rgItemInfo[i].hBitmap);
            m_rgItemInfo[i].hBitmap = NULL;
        }
        if (m_rgItemInfo[i].hIcon)
        {
            DestroyIcon(m_rgItemInfo[i].hIcon);
            m_rgItemInfo[i].hIcon = NULL;
        }
    }
    m_cItems = 0;

    return S_OK;
}

HRESULT CTransferConfirmation::_ClearSettings()
{
    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
    m_fShowARPLink = 0;
    m_fApplyToAll = 0;
    m_cItems = 0;
    m_hfont = 0;
    ZeroMemory(m_rgItemInfo, sizeof(m_rgItemInfo));

    return S_OK;
}

HRESULT CTransferConfirmation::_Init()
{
    HRESULT hr = S_OK;

    ASSERT(m_pszTitle == NULL);
    ASSERT(m_hIcon == NULL);
    ASSERT(m_pszDescription == NULL);

    _ClearSettings();

    if (!m_pPropUI)
    {
        hr = CoCreateInstance(CLSID_PropertiesUI, NULL, CLSCTX_INPROC_SERVER,
                                IID_PPV_ARG(IPropertyUI, &m_pPropUI));
    }

    return hr;
}

STDMETHODIMP CTransferConfirmation::Confirm(CONFIRMOP *pcop, LPCONFIRMATIONRESPONSE pcr, BOOL *pbAll)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pcop && pcr)
    {
        hr = _Init();
        if (SUCCEEDED(hr))
        {
            m_cop = *pcop;
            hr = _GetDialogSettings();
            if (SUCCEEDED(hr))
            {
                HWND hwnd;
                IUnknown_GetWindow(pcop->punkSite, &hwnd);

                int res = (int)DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_idDialog), hwnd, s_ConfirmDialogProc, (LPARAM)this);
            
                if (pbAll)
                    *pbAll = m_fApplyToAll;
        
                *pcr = m_crResult;
            }

            _FreeDialogSettings();
        }
    }
    return hr;
}

INT_PTR CALLBACK CTransferConfirmation::s_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTransferConfirmation *pThis;
    if (WM_INITDIALOG == uMsg)
    {
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
        pThis = (CTransferConfirmation *)lParam;
    }
    else
    {
        pThis = (CTransferConfirmation *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    }

    if (!pThis)
        return 0;

    return pThis->ConfirmDialogProc(hwndDlg, uMsg, wParam, lParam);
}

BOOL CTransferConfirmation::ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return OnInitDialog(hwndDlg, wParam, lParam);

    case WM_COMMAND:
        return OnCommand(hwndDlg, LOWORD(wParam), (HWND)lParam);

    // TODO: In WM_DESTROY I need to free the icon in IDD_ICON
    }

    return 0;
}

BOOL CTransferConfirmation::OnInitDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[1024];
    
    _CalculateMetrics(hwndDlg);

    int cxShift = 0;
    int cyShift = 0;
    int i;

    GetWindowRect(hwndDlg, &m_rcDlg);

    // We have one or more items that are part of this confirmation, we must get more
    // information about these items.  For example, we want to use full path names instead
    // of just the file name, we need to know file size, modifided data, and if possible
    // the two "most important" attributes of the file.

    // set the title
    if (m_cop.pcc)
    {
        SetWindowTextW(hwndDlg, m_cop.pcc->pwszTitle);
    }
    else if (m_pszTitle)
    {
        SetWindowText(hwndDlg, m_pszTitle);
    }

    // set the icon
    HICON hicon = NULL;
    if (m_cop.pcc)
    {
        hicon = m_cop.pcc->hicon;
    }
    else
    {
        hicon = m_hIcon;
    }
    if (hicon)
    {
        SendDlgItemMessage(hwndDlg, IDD_ICON, STM_SETICON, (LPARAM)hicon, 0);
    }
    else
    {
        HWND hwnd = GetDlgItem(hwndDlg, IDD_ICON);
        RECT rc;
        GetClientRect(hwnd, &rc);
        ShowWindow(hwnd, SW_HIDE);
        cxShift -= rc.right + m_cxControlPadding;
    }

    // Set the description text.  We need to remember the size and position of this window
    // so that we can position other controls under this text
    HWND hwndDesc = GetDlgItem(hwndDlg, ID_CONDITION_TEXT);
    RECT rcDesc;
    GetClientRect(hwndDesc, &rcDesc);

    USES_CONVERSION;
    szBuf[0] = NULL;
    if (m_cop.pcc)
    {
        StrCpyN(szBuf, W2T(m_cop.pcc->pwszDescription), ARRAYSIZE(szBuf));
    }
    else if (m_pszDescription)
    {
        DWORD_PTR rg[2];
        rg[0] = (DWORD_PTR)m_rgItemInfo[0].pwszDisplayName;
        rg[1] = (DWORD_PTR)m_rgItemInfo[1].pwszDisplayName;
        FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  m_pszDescription, 0, 0, szBuf, ARRAYSIZE(szBuf),
                  (va_list*)rg);
    }

    if (szBuf[0])
    {
        int cyWndHeight = _WindowHeightFromString(hwndDesc, RECT_WIDTH(rcDesc), szBuf);

        cyShift += (cyWndHeight - rcDesc.bottom);
        SetWindowPos(hwndDesc, NULL, 0,0, RECT_WIDTH(rcDesc), cyWndHeight, SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
        SetWindowText(hwndDesc, szBuf);
    }

    // We need to convert from the client coordinates of hwndDesc to the client coordinates of hwndDlg.
    // We do this converstion after adjusting the size of hwndDesc to fit the description text.
    MapWindowPoints(hwndDesc, hwndDlg, (LPPOINT)&rcDesc, 2);

    // Create the folder item(s).  The first one starts at cyShift+2*cyControlPadding
    // The begining insertion point is one spaceing below the description text
    rcDesc.bottom += cyShift + m_cyControlPadding;
    AssertMsg(m_cItems<=2, TEXT("Illegal m_cItems value (%d) should never be larger than 2."), m_cItems);
    for (i=0; i<m_cItems; i++)
    {
        int cyHeightOtItem = _DisplayItem(i, hwndDlg, rcDesc.left,  rcDesc.bottom);
        cyShift += cyHeightOtItem;
        rcDesc.bottom += cyHeightOtItem;
        TraceMsg(TF_DLGDISPLAY, "_DisplayItem returned a height of: %d", cyHeightOtItem);
    }

    if (m_cop.pcc && m_cop.pcc->pwszAdvancedDetails)
    {
        // TODO: if there is "advanced text" create a read-only edit control and put the text in it.
    }

    if (m_fSingle)
    {
        HWND hwnd = GetDlgItem(hwndDlg, IDD_REPEAT);
        if (hwnd)
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            ShowWindow(hwnd, SW_HIDE);
            m_rcDlg.bottom -= rc.bottom + m_cyControlPadding;
        }
    }

    if (cxShift)
    {
        // shift all child windows by cxShift pixels
        EnumChildWindows(hwndDlg, ShiftLeftProc, cxShift);
        // don't ask!  SetWindowPos in ShiftLeftProc, for some reason, does not do anything on mirrored builds
        if (!(GetWindowLong(hwndDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL))
            m_rcDlg.right += cxShift;
    }

    if (cyShift)
    {
        ShiftDialogItem(hwndDlg, IDCANCEL, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDYES, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDNO, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDRETRY, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDOK, 0, cyShift);

        if (!m_fSingle)
            ShiftDialogItem(hwndDlg, IDD_REPEAT, 0, cyShift);

        m_rcDlg.bottom += cyShift;
    }

    // now adjust the dialog size to account for all the things we've added and position it properly
    int x = 0;
    int y = 0;
    UINT uFlags = SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE;
    HMONITOR hMonitor = MonitorFromWindow(GetParent(hwndDlg), MONITOR_DEFAULTTONEAREST);
    if (hMonitor)
    {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (GetMonitorInfo(hMonitor, &mi))
        {
            RECT rcMonitor = mi.rcMonitor;
            x = max((RECT_WIDTH(rcMonitor)-RECT_WIDTH(m_rcDlg))/2, 0);
            y = max((RECT_HEIGHT(rcMonitor)-RECT_HEIGHT(m_rcDlg))/2, 0);
            uFlags &= ~SWP_NOMOVE;
        }
    }

    TraceMsg(TF_DLGDISPLAY, "Setting dialog size to %dx%d", RECT_WIDTH(m_rcDlg), RECT_HEIGHT(m_rcDlg));
    SetWindowPos(hwndDlg, NULL, x, y, RECT_WIDTH(m_rcDlg), RECT_HEIGHT(m_rcDlg), uFlags);

    return 1;
}

BOOL CTransferConfirmation::OnCommand(HWND hwndDlg, int wID, HWND hwndCtl)
{
    BOOL fFinish = TRUE;

    switch (wID)
    {
    case IDD_REPEAT:
        fFinish = FALSE;
        break;

    case IDRETRY:       // "Retry"
        m_crResult = CONFRES_RETRY;
        break;

    case IDOK:
    case IDYES:         // "Yes"
        m_crResult = CONFRES_CONTINUE;
        break;

    case IDNO:          // "Skip"
        m_crResult = CONFRES_SKIP;
        break;

    case IDCANCEL:      // "Cancel"
        m_crResult = CONFRES_CANCEL;
        break;

    default:
        // if we get to here, then the command ID was not one of our buttons, and since the
        // only command IDs we have our the buttons this should not happen.

        AssertMsg(0, TEXT("Invalid command recieved in CTransferConfirmation::OnCommand."));
        fFinish = FALSE;
        break;
    }

    if (fFinish)
    {
        // ignore apply to all for retry case or we can have infinite loop
        m_fApplyToAll = (m_crResult != CONFRES_RETRY && BST_CHECKED == SendDlgItemMessage(hwndDlg, IDD_REPEAT, BM_GETCHECK, 0, 0));
        EndDialog(hwndDlg, wID);
        return 1;
    }

    return 0;
}

HRESULT CTransferConfirmation::_AddItem(IShellItem *psi, int idIntro)
{
    if (idIntro)
    {
        TCHAR szBuf[1024];
        if (LoadString(_Module.GetResourceInstance(), idIntro, szBuf, ARRAYSIZE(szBuf)))
        {
            m_rgItemInfo[m_cItems].pwszIntro = StrDup(szBuf);
        }
    }

    HRESULT hr = psi->GetDisplayName(SIGDN_NORMALDISPLAY, &m_rgItemInfo[m_cItems].pwszDisplayName);
    if (SUCCEEDED(hr))
    {
        IQueryInfo *pqi;
        hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IQueryInfo, &pqi));
        if (SUCCEEDED(hr))
        {
            hr = pqi->GetInfoTip(0, &m_rgItemInfo[m_cItems].pwszAttribs);
            pqi->Release();
        }

        IExtractImage *pImg;
        hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pImg));
        if (SUCCEEDED(hr))
        {
            WCHAR szImage[MAX_PATH];
            SIZE sz = {120, 120};
            DWORD dwFlags = 0;
            hr = pImg->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = pImg->Extract(&m_rgItemInfo[m_cItems].hBitmap);
            }
            pImg->Release();
        }

        if (FAILED(hr))
        {
            IExtractIcon *pIcon;
            hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractIcon, &pIcon));
            if (SUCCEEDED(hr))
            {
                TCHAR szIconName[MAX_PATH];
                int iIconIndex = 0;
                UINT dwFlags = 0;
                hr = pIcon->GetIconLocation(0, szIconName, ARRAYSIZE(szIconName), &iIconIndex, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    hr = pIcon->Extract(szIconName, iIconIndex, &m_rgItemInfo[m_cItems].hIcon, NULL, GetSystemMetrics(SM_CXICON));
                }
                pIcon->Release();
            }
        }

        if (FAILED(hr))
        {
            IQueryAssociations *pAssoc;
            hr = CoCreateInstance(CLSID_QueryAssociations, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IQueryAssociations, &pAssoc));
            if (SUCCEEDED(hr))
            {
                WCHAR wszAssocInit[MAX_PATH];
                DWORD dwFlags = 0;
                SFGAOF flags = SFGAO_STREAM;
                if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & SFGAO_STREAM))
                {
                    dwFlags = ASSOCF_INIT_DEFAULTTOSTAR;
                    StrCpyW(wszAssocInit, PathFindExtensionW(m_rgItemInfo[m_cItems].pwszDisplayName));
                }
                else
                {
                    dwFlags = ASSOCF_INIT_DEFAULTTOFOLDER;
                    StrCpyW(wszAssocInit, L"Directory");    // NB: "Directory is a cannonical name and should not be localized
                }

                hr = pAssoc->Init(dwFlags, wszAssocInit, NULL,NULL);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszIconPath[MAX_PATH];
                    DWORD dwSize = ARRAYSIZE(wszIconPath);
                    hr = pAssoc->GetString(0, ASSOCSTR_DEFAULTICON, NULL, wszIconPath, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        int iIndex = 0;
                        LPWSTR pszArg = StrChrW(wszIconPath, L',');
                        if (pszArg)
                        {
                            *pszArg = NULL;
                            pszArg++;
                            iIndex = StrToIntW(pszArg);
                        }

                        ExtractIconEx(W2T(wszIconPath), iIndex, &m_rgItemInfo[m_cItems].hIcon, NULL, 1);
                        if (!m_rgItemInfo[m_cItems].hIcon)
                        {
                            TraceMsg(TF_WARNING, "LoadImage(%S) failed", wszIconPath);
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "pAssoc->GetString() failed");
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "pAssoc->Init(%S) failed", wszAssocInit);
                }

                pAssoc->Release();
            }
        }

        // if we fail to extract an image then we show the remaining info anyway:
        if (FAILED(hr))
            hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        m_cItems++;
    }

    return hr;
}

BOOL CTransferConfirmation::_CalculateMetrics(HWND hwndDlg)
{
    // We space the controls 6 dialog units apart, convert that to pixels
    // REVIEW: Is it valid to hardcode this, or does the height in dialog units need to be localized?
    RECT rc = {CX_DIALOG_PADDING, CY_DIALOG_PADDING, 0, CY_STATIC_TEXT_HEIGHT};
    BOOL bRes = MapDialogRect(hwndDlg, &rc);
    m_cxControlPadding = rc.left;
    m_cyControlPadding = rc.top;
    m_cyText = rc.bottom;

    m_hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0,0);

    return bRes;
}

DWORD CTransferConfirmation::_DisplayItem(int iItem, HWND hwndDlg, int x, int y)
{
    // We are told what X coordinate to place our left edge, we calculate from that how much room
    // we have available for our controls.
    int cxAvailable = RECT_WIDTH(m_rcDlg) - x - 2 * m_cxControlPadding;
    int yOrig = y;
    USES_CONVERSION;
    HWND hwnd;

    TraceMsg(TF_DLGDISPLAY, "_DisplayItem %d at location (%d,%d) in dialog %08x", iItem, x, y, hwndDlg);

    if (m_rgItemInfo[iItem].pwszIntro)
    {
            TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                        m_rgItemInfo[iItem].pwszIntro,
                        x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
            hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszIntro,
                                        WS_CHILD|WS_VISIBLE,
                                        x,y, cxAvailable,m_cyText,
                                        hwndDlg, NULL,
                                        _Module.GetModuleInstance(), 0);
            if (hwnd)
            {
                // we successfully added the title string for the item
                SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
                x += m_cxControlPadding;
                y += m_cyText+m_cyControlPadding;
            }
    }

    RECT rcImg = {0};
    if (m_rgItemInfo[iItem].hBitmap)
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                    "_Icon Window_",
                    x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
        hwnd = CreateWindowEx(0, TEXT("STATIC"), NULL,
                WS_CHILD|WS_VISIBLE|SS_BITMAP,
                x,y,
                120,120,
                hwndDlg, NULL,
                _Module.GetModuleInstance(), 0);

        if (hwnd)
        {
            SendMessage(hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_rgItemInfo[iItem].hBitmap);
            GetClientRect(hwnd, &rcImg);
            x += rcImg.right + m_cxControlPadding;
            cxAvailable -= rcImg.right + m_cxControlPadding;
            rcImg.bottom += y;
        }
    }
    else if (m_rgItemInfo[iItem].hIcon)
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                    "_Icon Window_",
                    x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
        hwnd = CreateWindowEx(0, TEXT("STATIC"), NULL,
                WS_CHILD|WS_VISIBLE|SS_ICON,
                x,y,
                GetSystemMetrics(SM_CXICON),GetSystemMetrics(SM_CYICON),
                hwndDlg, NULL,
                _Module.GetModuleInstance(), 0);

        if (hwnd)
        {
            SendMessage(hwnd, STM_SETICON, (WPARAM)m_rgItemInfo[iItem].hIcon, NULL);
            GetClientRect(hwnd, &rcImg);
            x += rcImg.right + m_cxControlPadding;
            cxAvailable -= rcImg.right + m_cxControlPadding;
            rcImg.bottom += y;
        }
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "Not using an image for item %d.", iItem);
    }

    TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                m_rgItemInfo[iItem].pwszDisplayName,
                x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());

    int cyWnd = _WindowHeightFromString(hwndDlg, cxAvailable, W2T(m_rgItemInfo[iItem].pwszDisplayName));
    hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszDisplayName,
                          WS_CHILD|WS_VISIBLE,
                          x,y, cxAvailable,cyWnd,
                          hwndDlg, NULL,
                          _Module.GetModuleInstance(), 0);
    if (hwnd)
    {
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
        y += cyWnd;
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx for display name failed.");
    }

    TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                m_rgItemInfo[iItem].pwszAttribs,
                x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());

    cyWnd = _WindowHeightFromString(hwndDlg, cxAvailable, W2T(m_rgItemInfo[iItem].pwszAttribs));
    hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszAttribs,
                          WS_CHILD|WS_VISIBLE|SS_LEFT,
                          x,y, cxAvailable,cyWnd,
                          hwndDlg, NULL,
                          _Module.GetModuleInstance(), 0);
    if (hwnd)
    {
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
        y += cyWnd;
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx for attribs failed.");
    }

    if (rcImg.bottom > y)
        y = rcImg.bottom;

    return (y-yOrig) + m_cyControlPadding;
}

int CTransferConfirmation::_WindowHeightFromString(HWND hwnd, int cx, LPTSTR psz)
{
    RECT rc = {0,0, cx,0 };
    HDC hdc = GetDC(hwnd);
    HFONT hfontOld = NULL;
    DWORD dtFlags = DT_CALCRECT|DT_WORDBREAK;
    if (m_hfont)
    {
        // We need to select the font that the dialog will use so that we calculate the correct size
        hfontOld = (HFONT)SelectObject(hdc, m_hfont);
    }
    else
    {
        // a NULL m_hfont means we are using the system font, using DT_INTERNAL should do the
        // calculation based on the system font.
        dtFlags |= DT_INTERNAL;
    }
    DrawText(hdc, psz, -1, &rc, dtFlags);
    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return rc.bottom;
}

void ShiftWindow(HWND hwnd, int cx, int cy)
{
    RECT rc;

    // rect in screen coordinates
    GetWindowRect(hwnd, &rc);
    // shift it over
    if (GetWindowLong(GetParent(hwnd), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
        rc.left -= cx;
    else
        rc.left += cx;

    rc.top += cy;
    // convert to parent windows coords
    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rc, 2);
    // and move the window
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0,0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
}


void ShiftDialogItem(HWND hDlg, int id, int cx, int cy)
{
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);
    if (NULL != hwnd)
    {
        ShiftWindow(hwnd, cx, cy);
    }
}

BOOL CALLBACK ShiftLeftProc(HWND hwnd, LPARAM lParam)
{
    ShiftWindow(hwnd, (int)(INT_PTR)lParam, 0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\clsobj.c ===
//
// This file contains the DllGetClassObject for the shell32.dll COM objects
//
#include "shellprv.h"
#pragma  hdrstop

#include <shguidp.h>    // get the CLSID definitions, the bits are built into shguidp.lib
#include <shlguid.h>
#include <shldisp.h>

#include "actdesk.h"
#include "ovrlaymn.h"
#include "treewalk.h"
#include "openwith.h"
#include "clsobj.h"

#define DllAddRef()     // once we implement DllCanUnloadNow we need these
#define DllRelease()    


// static class factory (no allocs!)

typedef struct {
    const IClassFactoryVtbl *cf;
    REFCLSID rclsid;
    HRESULT (*pfnCreate)(IUnknown *, REFIID, void **);
    ULONG flags;
} OBJ_ENTRY;

// flags:
#define OBJ_AGGREGATABLE 1

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
// we save code by checking aggregation on our side (have a bit in this const table)
// instead of having each CreateInstance function do it (since most are not aggregatable)
//
const OBJ_ENTRY c_clsmap[] = {
    { &c_CFVtbl, &CLSID_QueryAssociations,          CQueryAssociations_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MyDocuments,                CMyDocsFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellDesktop,               CDesktop_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFSFolder,              CFSFolder_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_MyComputer,                 CDrives_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NetworkPlaces,              CNetwork_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFileDefExt,            CShellFileDefExt_CreateInstance, OBJ_AGGREGATABLE },

    { &c_CFVtbl, &CLSID_ShellItem,                  CShellItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_OpenWithMenu,               COpenWithMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellLink,                  CShellLink_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellDrvDefExt,             CShellDrvDefExt_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_ShellNetDefExt,             CShellDrvDefExt_CreateInstance, OBJ_AGGREGATABLE },

    { &c_CFVtbl, &CLSID_ShellCopyHook,              CCopyHook_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ControlPanel,               CControlPanel_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_Printers,                   CPrinters_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_RecycleBin,                 CBitBucket_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_PifProperties,              CProxyPage_CreateInstance, 0 },

    { &c_CFVtbl, &CLSID_CFSIconOverlayManager,      CFSIconOverlayManager_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_RecycleBinCleaner,          CRecycleBinCleaner_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindFolder,              CDocFindFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindPersistHistory,      CFindPersistHistory_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DefViewPersistHistory,      CDefViewPersistHistory_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ComputerFindFolder,         CComputerFindFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindCommand,             CDocFindCommand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CShellTreeWalker,           CShellTreeWalker_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_BriefcaseFolder,            CFSBrfFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFileColumnProvider,      CDocFileColumns_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_LinkColumnProvider,         CLinkColumnProvider_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FileSysColumnProvider,      CFileSysColumnProvider_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FileSearchBand,             CFileSearchBand_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_FolderShortcut,             CFolderShortcut_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MountedVolume,              CMountedVolume_CreateInstance, 0 },
    // menuband objects
    { &c_CFVtbl, &CLSID_MenuBand,                   CMenuBand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ISFBand,                    CISFBand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_QuickLinks,                 CQuickLinks_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_TrackShellMenu,             CTrackShellMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MenuBandSite,               CMenuBandSite_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MenuDeskBar,                CMenuDeskBar_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ActiveDesktop,              CActiveDesktop_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DeskMovr,                   CDeskMovr_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_CopyToMenu,                 CCopyToMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MoveToMenu,                 CMoveToMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CDeskHtmlProp,              CDeskHtmlProp_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFldSetExt,             CFolderOptionsPsx_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_Shell,                      CShellDispatch_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFolderView,            CShellFolderView_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFolderViewOC,          CShellFolderViewOC_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_MigrationWizardAuto,        CMigrationWizardAuto_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_WebViewFolderContents,      CWebViewFolderContents_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_StartMenu,                  CStartMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CmdFileIcon,                CShellCmdFileIcon_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NewMenu,                    CNewMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SendToMenu,                 CSendToMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FileTypes,                  CFileTypes_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MIMEFileTypesHook,          CFileTypes_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DragDropHelper,             CDragImages_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ExeDropTarget,              CExeDropTarget_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FolderItem,                 CFolderItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FolderItemsFDF,             CFolderItemsFDF_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_NetCrawler,                 CNetCrawler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_WorkgroupNetCrawler,        CWorkgroupCrawler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_EncryptionContextMenuHandler, CEncryptionContextMenuHandler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_PropertiesUI,               CPropertyUI_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_TimeCategorizer,            CTimeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SizeCategorizer,            CSizeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DriveSizeCategorizer,       CDriveSizeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DriveTypeCategorizer,       CDriveTypeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FreeSpaceCategorizer,       CFreeSpaceCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MergedCategorizer,          CMergedCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_StgFolder,                  CStgFolder_CreateInstance, OBJ_AGGREGATABLE},
    { &c_CFVtbl, &CLSID_DynamicStorage,             CDynamicStorage_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CDBurn,                     CCDBurn_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_BurnAudioCDExtension,       CBurnAudioCDExtension_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_LocalCopyHelper,            CLocalCopyHelper_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MergedFolder,               CMergedFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CDBurnFolder,               CCDBurnFolder_CreateInstance, 0},
//  { &c_CFVtbl, &CLSID_TripleD,                    CTripleD_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CompositeFolder,            CCompositeFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_StartMenuFolder,            CStartMenuFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ProgramsFolder,             CProgramsFolder_CreateInstance, 0},
#ifdef FEATURE_STARTPAGE
    { &c_CFVtbl, &CLSID_MoreDocumentsFolder,        CMoreDocumentsFolder_CreateInstance, 0},
#endif
//  { &c_CFVtbl, &CLSID_SyreCleaner,                CSystemRestoreCleaner_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_VersionColProvider,         CVerColProvider_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_HWShellExecute,             CHWShellExecute_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellAutoplay,              CDeviceEventHandler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_AutoPlayVerb,               CAutoPlayVerb_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_UserNotification,           CUserNotification_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_UserEventTimer,             CUserEventTimer_CreateInstance, 0},    
    { &c_CFVtbl, &CLSID_StorageProcessor,           CStorageProcessor_CreateInstance,   0},
    { &c_CFVtbl, &CLSID_TransferConfirmationUI,     CTransferConfirmation_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_AutomationCM,               CAutomationCM_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellThumbnailDiskCache,    CThumbStore_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DefCategoryProvider,        CCategoryProvider_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SharedDocuments,            CSharedDocFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_PostBootReminder,           CPostBootReminder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_Thumbnail,                  CThumbnail_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_StartMenuPin,               CStartMenuPin_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ClientExtractIcon,          CClientExtractIcon_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FolderCustomize,            CFolderCustomize_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CWebViewMimeFilter,         CWebViewMimeFilter_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_WebViewRegTreeItem,         CWebViewRegTreeItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ThemesRegTreeItem,          CThemesRegTreeItem_CreateInstance, 0},
//    { &c_CFVtbl, &CLSID_WirelessDevices,            CWirelessDevices_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NamespaceWalker,            CNamespaceWalk_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_WebWizardHost,              CWebWizardPage_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_PersonalStartMenu,          CPersonalStartMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FadeTask,                   CFadeTask_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FolderViewHost,             CFolderViewHost_CreateInstance, 0 },
    { NULL, NULL, NULL }
};


STDMETHODIMP CCF_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    // OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCF_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CCF_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CCF_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);

    *ppvObject = NULL; // to avoid nulling it out in every create function...

    if (punkOuter && !(this->flags & OBJ_AGGREGATABLE))
        return CLASS_E_NOAGGREGATION;

    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CCF_LockServer(IClassFactory *pcf, BOOL fLock)
{
/*  SHELL32.DLL does not implement DllCanUnloadNow, thus does not have a DLL refcount
    This means we can never unload!

    if (fLock)
        DllAddRef();
    else
        DllRelease();
*/
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CCF_QueryInterface, CCF_AddRef, CCF_Release,
    CCF_CreateInstance,
    CCF_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->rclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->rclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();
                return NOERROR;
            }
        }
#ifdef DEBUG
        {
            TCHAR szClass[GUIDSTR_MAX];
            SHStringFromGUID(rclsid, szClass, ARRAYSIZE(szClass));
            AssertMsg(TF_ERROR,
                      TEXT("DllGetClassObject !!! %s not in shell32; ")
                      TEXT("corrupted registry?"), szClass);
        }
#endif
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\confirmationui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File: ConfirmationUI.h
//
//  Contents: Confirmation UI for storage based copy engine
//
//  History:  20-Mar-2000 ToddB
//
//--------------------------------------------------------------------------

#pragma once

// these heights are in Dialog Uints, they get converted to pixels before use
#define CX_DIALOG_PADDING       6
#define CY_DIALOG_PADDING       6
#define CY_STATIC_TEXT_HEIGHT   10

// This is the max string length of the attribute fields for an item
#define CCH_DESC_LENGTH     MAX_PATH


class CTransferConfirmation :
    public ITransferConfirmation,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTransferConfirmation, &CLSID_TransferConfirmationUI>
{
public:
    typedef struct tagITEMINFO
    {
        LPWSTR pwszIntro;           // resource ID of the intro string, or 0 if there is none
        LPWSTR pwszDisplayName;     // The display name of the item
        LPWSTR pwszAttribs;         // The attributes for this item.  Can be a variable number of lines in length
        HBITMAP hBitmap;
        HICON hIcon;
    } ITEMINFO, * LPITEMINFO;

    BEGIN_COM_MAP(CTransferConfirmation)
        COM_INTERFACE_ENTRY(ITransferConfirmation)
    END_COM_MAP()

    // IStorageProcessor
    STDMETHOD(Confirm)(CONFIRMOP * pcop, LPCONFIRMATIONRESPONSE pcr, BOOL * pbAll);

protected:
    CTransferConfirmation();
    ~CTransferConfirmation();

    static INT_PTR CALLBACK s_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam);
    BOOL OnCommand(HWND hwndDlg, int wID, HWND hwndCtl);

    HRESULT _Init();
    HRESULT _ClearSettings();
    HRESULT _GetDialogSettings();
    HRESULT _FreeDialogSettings();
    HRESULT _AddItem(IShellItem *psi, int idIntro=0);
    BOOL _CalculateMetrics(HWND hwndDlg);
    DWORD _DisplayItem(int iItem, HWND hwndDlg, int x, int y);
    int _WindowWidthFromString(HWND hwnd, LPTSTR psz);
    int _WindowHeightFromString(HWND hwnd, int cx, LPTSTR psz);
    BOOL _IsCopyOperation(STGOP stgop);

    // Input information
    CONFIRMOP m_cop;
    IPropertyUI * m_pPropUI;

    // Output results
    CONFIRMATIONRESPONSE m_crResult;
    BOOL m_fApplyToAll;

    // Stuff to control the display of the dialog
    int     m_cxControlPadding;
    int     m_cyControlPadding;
    int     m_cyText;               // the height of a static text control (10 dialog units converted into pixels)
    RECT    m_rcDlg;                // we remember the size of the dialog's client area since we use this a lot
    HFONT   m_hfont;                // the font used by the dialog, used to calculate sizes

    TCHAR * m_pszTitle;
    HICON m_hIcon;
    TCHAR * m_pszDescription;

    int m_idDialog;

    ITEMINFO m_rgItemInfo[2];
    int m_cItems;

    BOOL m_fSingle;
    BOOL m_fShowARPLink;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\colhndlr.cpp ===
#include "shellprv.h"

#include "intshcut.h"
#include "ids.h"
#include <ntquery.h>    // defines some values used for fmtid and pid
#include <sddl.h>       // For ConvertSidToStringSid()
#include "prop.h"       // SCID_ stuff
#include "netview.h"    // SHWNetGetConnection
#include "clsobj.h"

HRESULT ReadProperty(IPropertySetStorage *ppss, REFFMTID fmtid, PROPID pid, VARIANT *pVar)
{
    VariantInit(pVar);

    IPropertyStorage *pps;
    HRESULT hr = ppss->Open(fmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC PropSpec;
        PROPVARIANT PropVar = {0};

        PropSpec.ulKind = PRSPEC_PROPID;
        PropSpec.propid = pid;

        hr = SHPropStgReadMultiple( pps, 0, 1, &PropSpec, &PropVar );
        if (SUCCEEDED(hr))
        {
            hr = PropVariantToVariant(&PropVar, pVar);
            PropVariantClear(&PropVar);
        }
        pps->Release();
    }
    return hr;
}

BOOL IsSlowProperty(IPropertySetStorage *ppss, REFFMTID fmtid, PROPID pid)
{
    IPropertyStorage *pps;
    BOOL bRet = FALSE;

    if (SUCCEEDED(ppss->Open(fmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &pps)))
    {
        IQueryPropertyFlags *pqsp;
        if (SUCCEEDED(pps->QueryInterface(IID_PPV_ARG(IQueryPropertyFlags, &pqsp))))
        {
            PROPSPEC PropSpec;
            PROPVARIANT PropVar = {0};

            PropSpec.ulKind = PRSPEC_PROPID;
            PropSpec.propid = pid;

            SHCOLSTATEF csFlags;
            if (SUCCEEDED(pqsp->GetFlags(&PropSpec, &csFlags)))
            {
                bRet = ((csFlags & SHCOLSTATE_SLOW) == SHCOLSTATE_SLOW);
            }

            // If the property isn't part of this property set, IsSlowProperty will return fairlure,
            // which we'll treat as a fast property.

            pqsp->Release();
        }

        pps->Release();
    }
    return bRet;  
}

class CBaseColumnProvider : public IPersist, public IColumnProvider
{
    // IUnknown methods
public:
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CBaseColumnProvider, IColumnProvider),     // IID_IColumnProvider
            QITABENT(CBaseColumnProvider, IPersist),            // IID_IPersist
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    };
    
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&_cRef);
    };

    STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&_cRef))
            return _cRef;

        delete this;
        return 0;
    };

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID) { *pClassID = *_pclsid; return S_OK; };

    // IColumnProvider
    STDMETHODIMP Initialize(LPCSHCOLUMNINIT psci)    { return S_OK ; }
    STDMETHODIMP GetColumnInfo(DWORD dwIndex, LPSHCOLUMNINFO psci);

    CBaseColumnProvider(const CLSID *pclsid, const COLUMN_INFO rgColMap[], int iCount, const LPCWSTR rgExts[]) : 
       _cRef(1), _pclsid(pclsid), _rgColumns(rgColMap), _iCount(iCount), _rgExts(rgExts)
    {
        DllAddRef();
    }

protected:
    virtual ~CBaseColumnProvider()
    {
        DllRelease();
    }

    BOOL _IsHandled(LPCWSTR pszExt);
    int _iCount;
    const COLUMN_INFO *_rgColumns;

private:
    long _cRef;
    const CLSID * _pclsid;
    const LPCWSTR *_rgExts;
};

// the index is an arbitrary zero based index used for enumeration

STDMETHODIMP CBaseColumnProvider::GetColumnInfo(DWORD dwIndex, SHCOLUMNINFO *psci)
{
    ZeroMemory(psci, sizeof(*psci));

    if (dwIndex < (UINT) _iCount)
    {
        psci->scid = *_rgColumns[dwIndex].pscid;
        psci->cChars = _rgColumns[dwIndex].cChars;
        psci->vt = _rgColumns[dwIndex].vt;
        psci->fmt = _rgColumns[dwIndex].fmt;
        psci->csFlags = _rgColumns[dwIndex].csFlags;

        TCHAR szTemp[MAX_COLUMN_NAME_LEN];
        LoadString(HINST_THISDLL, _rgColumns[dwIndex].idTitle, szTemp, ARRAYSIZE(szTemp));
        SHTCharToUnicode(szTemp, psci->wszTitle, ARRAYSIZE(psci->wszTitle));      

        return S_OK;
    }
    return S_FALSE;
}

// see if this file type is one we are interested in
BOOL CBaseColumnProvider::_IsHandled(LPCWSTR pszExt)
{
    if (_rgExts)
    {
        for (int i = 0; _rgExts[i]; i++)
        {
            if (0 == StrCmpIW(pszExt, _rgExts[i]))
                return TRUE;
        }
        return FALSE;
    }
    return TRUE;
}

// col handler that works over IPropertySetStorage handlers

const COLUMN_INFO c_rgDocObjColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_Author,           20, IDS_EXCOL_AUTHOR),
    DEFINE_COL_STR_ENTRY(SCID_Title,            20, IDS_EXCOL_TITLE),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Subject,      20, IDS_EXCOL_SUBJECT),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Category,     20, IDS_EXCOL_CATEGORY),
    DEFINE_COL_INT_DLG_ENTRY(SCID_PageCount,    10, IDS_EXCOL_PAGECOUNT),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Copyright,    30, IDS_EXCOL_COPYRIGHT),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Artist,     15, IDS_EXCOL_ARTIST),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Album,      15, IDS_EXCOL_ALBUM),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Year,       10, IDS_EXCOL_YEAR),
    DEFINE_COL_INT_ENTRY(SCID_MUSIC_Track,      5,  IDS_EXCOL_TRACK),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Genre,      20, IDS_EXCOL_GENRE),
    DEFINE_COL_STR_ENTRY(SCID_AUDIO_Duration,   15, IDS_EXCOL_DURATION),
    DEFINE_COL_STR_ENTRY(SCID_AUDIO_Bitrate,    15, IDS_EXCOL_BITRATE),
    DEFINE_COL_STR_ENTRY(SCID_DRM_Protected,    10, IDS_EXCOL_PROTECTED),
    DEFINE_COL_STR_ENTRY(SCID_CameraModel,      20, IDS_EXCOL_CAMERAMODEL),
    DEFINE_COL_STR_ENTRY(SCID_WhenTaken,        20, IDS_EXCOL_WHENTAKEN),

    DEFINE_COL_STR_ENTRY(SCID_ImageDimensions,  20, IDS_EXCOL_DIMENSIONS),
    DEFINE_COL_INT_HIDDEN_ENTRY(SCID_ImageCX),
    DEFINE_COL_INT_HIDDEN_ENTRY(SCID_ImageCY),

    DEFINE_COL_DATE_HIDDEN_ENTRY(SCID_DocCreated),
};

class CPropStgColumns : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    // help on initializing base classes: mk:@ivt:vclang/FB/DD/S44B5E.HTM
    CPropStgColumns() : 
       CBaseColumnProvider(&CLSID_DocFileColumnProvider, c_rgDocObjColumns, ARRAYSIZE(c_rgDocObjColumns), NULL)
    {
        ASSERT(_wszLastFile[0] == 0);
        ASSERT(_bSlowPropertiesCached == FALSE);
    };
    
    ~CPropStgColumns()
    {
        _FreeCache();
    }
    
    // for the cache
    VARIANT _rgvCache[ARRAYSIZE(c_rgDocObjColumns)]; // zero'ing allocator will fill with VT_EMPTY
    BOOL _rgbSlow[ARRAYSIZE(c_rgDocObjColumns)]; // Store if each property is "slow".
    WCHAR _wszLastFile[MAX_PATH];
    HRESULT _hrCache;
    BOOL _bSlowPropertiesCached;

#ifdef DEBUG
    int deb_dwTotal, deb_dwMiss;
#endif
    
    void _FreeCache();

    friend HRESULT CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

void CPropStgColumns::_FreeCache()
{
    for (int i = 0; i < ARRAYSIZE(_rgvCache); i++)
        VariantClear(&_rgvCache[i]);

    _hrCache = S_OK;
}

STDMETHODIMP CPropStgColumns::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr;

    // VariantCopy requires input to be initialized, and we handle failure case
    VariantInit(pvarData);

    // is this even a property we support?
    for (int iProp = 0; iProp < _iCount; iProp++)
    {
        if (IsEqualSCID(*_rgColumns[iProp].pscid, *pscid))
        {
            goto found;
        }
    }

    // Unknown property
    return S_FALSE;

found:

#ifdef DEBUG
    deb_dwTotal++;
#endif

    // Three cases here:
    // 1) We need to update the cache. Fetch the properties again (and only get fast props if we asked for a fast prop)
    // 2) We've only cached fast properties so far, and we asked for a slow property, so now we need to get slow props.
    // 3) The property we want is cached.

    if ((pscd->dwFlags & SHCDF_UPDATEITEM) || (StrCmpW(_wszLastFile, pscd->wszFile) != 0))
    {
        // 1) Cache is no good - item has been updated, or this is a different file.

        // SHCDF_UPDATEITEM flag is a hint
        // that the file for which we are getting data has changed since the last call.  This flag
        // is only passed once per filename, not once per column per filename so update the entire
        // cache if this flag is set.

        // sanity check our caching.  If the shell thread pool is > 1, we will thrash like mad, and should change this
#ifdef DEBUG
        deb_dwMiss++;
        if ((deb_dwTotal > 3) && (deb_dwTotal / deb_dwMiss <= 3))
            TraceMsg(TF_DEFVIEW, "Column data caching is ineffective (%d misses for %d access)", deb_dwMiss, deb_dwTotal);
#endif
        _FreeCache();

        StrCpyW(_wszLastFile, pscd->wszFile);

        IPropertySetStorage *ppss;
        hr = SHFileSysBindToStorage(pscd->wszFile, pscd->dwFileAttributes, STGM_READ | STGM_SHARE_DENY_WRITE, 0, 
                                    IID_PPV_ARG(IPropertySetStorage, &ppss));

        _hrCache = hr;

        if (SUCCEEDED(hr))
        {
            // Did we ask for a slow property?
            BOOL bSlowProperty = IsSlowProperty(ppss, _rgColumns[iProp].pscid->fmtid, _rgColumns[iProp].pscid->pid);

            hr = E_INVALIDARG; // normally overwritten by hrT below
            for (int i = 0; i < _iCount; i++)
            {
                // For every property, take note if it is "slow"
                _rgbSlow[i] = IsSlowProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid);

                // Only retrieve a value right now if we asked for a slow property, or this is not a slow property.
                if (bSlowProperty || (!_rgbSlow[i]))
                {
                    // it would be slightly more efficient, but more code, to set up the propid array to call ReadMultiple
                    HRESULT hrT = ReadProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid, &_rgvCache[i]);
                    if (i == iProp)
                    {
                        hr = (SUCCEEDED(hrT) ? VariantCopy(pvarData, &_rgvCache[i]) : hrT);
                    }
                }
            }

            ppss->Release();
            _bSlowPropertiesCached = bSlowProperty;
        }        
    }
    else if (_rgbSlow[iProp] && !_bSlowPropertiesCached)
    {
        // 2) We asked for a slow property, but slow properties haven't been cached yet.

        // Bind to the storage a second time.  This is a perf hit, but should be
        // minor compared to getting slow properties.
        IPropertySetStorage *ppss;
        hr = SHFileSysBindToStorage(pscd->wszFile, pscd->dwFileAttributes, STGM_READ | STGM_SHARE_DENY_WRITE, 0, 
                                    IID_PPV_ARG(IPropertySetStorage, &ppss));

        _hrCache = hr;

        if (SUCCEEDED(hr))
        {
            hr = E_INVALIDARG; // normally overwritten by hrT below
            for (int i = 0; i < _iCount; i++)
            {
                if (_rgbSlow[i]) // If it's slow, get it.
                {
                    ASSERT(_rgvCache[i].vt == VT_EMPTY); // Because we haven't retrieved it yet.

                    HRESULT hrT = ReadProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid, &_rgvCache[i]);
                    if (i == iProp)
                    {
                        hr = (SUCCEEDED(hrT) ? VariantCopy(pvarData, &_rgvCache[i]) : hrT);
                    }
                }
            }
            ppss->Release();

            _bSlowPropertiesCached = TRUE;
        }

    }
    else 
    {
        // 3) It's not a slow property, or slow properties are already cached.
        ASSERT(!_rgbSlow[iProp] || _bSlowPropertiesCached);

        hr = S_FALSE;       // assume we don't have it

        if (SUCCEEDED(_hrCache))
        {
            if (_rgvCache[iProp].vt != VT_EMPTY)
            {
                hr = VariantCopy(pvarData, &_rgvCache[iProp]);
            }
        }
    }

    return hr;
}


STDAPI CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CPropStgColumns *pdocp = new CPropStgColumns;
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Shortcut handler

// W because pidl is always converted to widechar filename
const LPCWSTR c_szURLExtensions[] = {
    L".URL", 
    L".LNK", 
    NULL
};

const COLUMN_INFO c_rgURLColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_Author,           20, IDS_EXCOL_AUTHOR),
    DEFINE_COL_STR_ENTRY(SCID_Title,            20, IDS_EXCOL_TITLE),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
};

class CLinkColumnProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    // help on initializing base classes: mk:@ivt:vclang/FB/DD/S44B5E.HTM
    CLinkColumnProvider() : CBaseColumnProvider(&CLSID_LinkColumnProvider, c_rgURLColumns, ARRAYSIZE(c_rgURLColumns), c_szURLExtensions)
    {};

    // friends
    friend HRESULT CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

const struct 
{
    DWORD dwSummaryPid;
    DWORD dwURLPid;
} c_URLMap[] =  {
    { PIDSI_AUTHOR,   PID_INTSITE_AUTHOR },
    { PIDSI_TITLE,    PID_INTSITE_TITLE },
    { PIDSI_COMMENTS, PID_INTSITE_COMMENT },
};

DWORD _MapSummaryToSitePID(DWORD pid)
{
    for (int i = 0; i < ARRAYSIZE(c_URLMap); i++)
    {
        if (c_URLMap[i].dwSummaryPid == pid)
            return c_URLMap[i].dwURLPid;
    }
    return -1;
}

STDMETHODIMP CLinkColumnProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr;
    USES_CONVERSION;
    const CLSID *pclsidLink = &CLSID_ShellLink;

    // Some of the code-paths below assume pvarData is initialized
    VariantInit(pvarData);

    // should we match against a list of known extensions, or always try to open?

    if (FILE_ATTRIBUTE_DIRECTORY & pscd->dwFileAttributes)
    {
        if (PathIsShortcut(W2CT(pscd->wszFile), pscd->dwFileAttributes))
        {
            pclsidLink = &CLSID_FolderShortcut;     // we are dealing with a folder shortcut now
        }
        else
        {
            return S_FALSE;
        }
    }
    else
    {
        if (!_IsHandled(pscd->pwszExt))
        {
            return S_FALSE;
        }
    }

    if (StrCmpIW(pscd->pwszExt, L".URL") == 0)
    {
        //
        // its a .URL so lets handle it by creating the Internet Shortcut object, loading
        // the file and then reading the properties from it.
        //
        IPropertySetStorage *ppss;
        hr = LoadFromFile(CLSID_InternetShortcut, W2CT(pscd->wszFile), IID_PPV_ARG(IPropertySetStorage, &ppss));
        if (SUCCEEDED(hr))
        {
            UINT pid;
            GUID fmtid;

            if (IsEqualGUID(pscid->fmtid, FMTID_SummaryInformation))
            {
                fmtid = FMTID_InternetSite;
                pid = _MapSummaryToSitePID(pscid->pid);
            }
            else
            {
                fmtid = pscid->fmtid;
                pid = pscid->pid;
            }

            hr = ReadProperty(ppss, fmtid, pid, pvarData);
            ppss->Release();
        }
    }
    else
    {
        //
        // open the .LNK file, load it and then read the description for it.  we then
        // return this a the comment for this object.
        //

        if (IsEqualSCID(*pscid, SCID_Comment))
        {
            IShellLink *psl;
            hr = LoadFromFile(*pclsidLink, W2CT(pscd->wszFile), IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH];

                hr = psl->GetDescription(szBuffer, ARRAYSIZE(szBuffer));            
                if (SUCCEEDED(hr) && szBuffer[0])
                {
                    hr = InitVariantFromStr(pvarData, szBuffer);
                }
                else
                {
                    IQueryInfo *pqi;
                    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IQueryInfo, &pqi))))
                    {
                        WCHAR *pwszTip;

                        if (SUCCEEDED(pqi->GetInfoTip(0, &pwszTip)) && pwszTip)
                        {
                            hr = InitVariantFromStr(pvarData, W2CT(pwszTip));
                            SHFree(pwszTip);
                        }
                        pqi->Release();
                    }
                }

                psl->Release();
            }
        }
        else
            hr = S_FALSE;
    }

    return hr;
}

STDAPI CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLinkColumnProvider *pdocp = new CLinkColumnProvider;
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

const COLUMN_INFO c_rgFileSysColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_OWNER,            20, IDS_EXCOL_OWNER),
};

class COwnerColumnProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    COwnerColumnProvider() : CBaseColumnProvider(&CLSID_FileSysColumnProvider, c_rgFileSysColumns, ARRAYSIZE(c_rgFileSysColumns), NULL)
    {
        ASSERT(_wszLastFile[0] == 0);
        ASSERT(_psid==NULL && _pwszName==NULL && _psd==NULL);
        LoadString(HINST_THISDLL, IDS_BUILTIN_DOMAIN, _szBuiltin, ARRAYSIZE(_szBuiltin));
    };

    ~COwnerColumnProvider() { _CacheSidName(NULL, NULL, NULL); }

    WCHAR _wszLastFile[MAX_PATH];

    //  Since we typically get pinged for files all in the same folder,
    //  cache the "folder to server" mapping to avoid calling
    //  WNetGetConnection five million times.
    //
    //  Since files in the same directory tend to have the same owner,
    //  we cache the SID/Name mapping.
    //
    //  Column providers do not have to support multithreaded clients,
    //  so we won't take any critical sections.
    //

    HRESULT _LookupOwnerName(LPCTSTR pszFile, VARIANT *pvar);
    void _CacheSidName(PSECURITY_DESCRIPTOR psd, void *psid, LPCWSTR pwszName);

    void                *_psid;
    LPWSTR               _pwszName;
    PSECURITY_DESCRIPTOR _psd;          // _psid points into here

    int                  _iCachedDrive; // What drive letter is cached in _pszServer?
    LPTSTR               _pszServer;    // What server to use (NULL = local machine)
    TCHAR                _szBuiltin[MAX_COMPUTERNAME_LENGTH + 1];

    friend HRESULT CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

//
//  _CacheSidName takes ownership of the psd.  (psid points into the psd)
//
void COwnerColumnProvider::_CacheSidName(PSECURITY_DESCRIPTOR psd, void *psid, LPCWSTR pwszName)
{
    LocalFree(_psd);
    _psd = psd;
    _psid = psid;

    Str_SetPtrW(&_pwszName, pwszName);
}

//
//  Given a string of the form \\server\share\blah\blah, stomps the
//  inner backslash (if necessary) and returns a pointer to "server".
//
STDAPI_(LPTSTR) PathExtractServer(LPTSTR pszUNC)
{
    if (PathIsUNC(pszUNC))
    {
        pszUNC += 2;            // Skip over the two leading backslashes
        LPTSTR pszEnd = StrChr(pszUNC, TEXT('\\'));
        if (pszEnd) 
            *pszEnd = TEXT('\0'); // nuke the backslash
    }
    else
    {
        pszUNC = NULL;
    }
    return pszUNC;
}

HRESULT COwnerColumnProvider::_LookupOwnerName(LPCTSTR pszFile, VARIANT *pvar)
{
    pvar->vt = VT_BSTR;
    pvar->bstrVal = NULL;

    PSECURITY_DESCRIPTOR psd;
    void *psid;

    DWORD err = GetNamedSecurityInfo(const_cast<LPTSTR>(pszFile),
                               SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION,
                               &psid, NULL, NULL, NULL, &psd);
    if (err == ERROR_SUCCESS)
    {
        if (_psid && EqualSid(psid, _psid) && _pwszName)
        {
            pvar->bstrVal = SysAllocString(_pwszName);
            LocalFree(psd);
            err = ERROR_SUCCESS;
        }
        else
        {
            LPTSTR pszServer;
            TCHAR szServer[MAX_PATH];

            //
            //  Now go figure out which server to resolve the SID against.
            //
            if (PathIsUNC(pszFile))
            {
                lstrcpyn(szServer, pszFile, ARRAYSIZE(szServer));
                pszServer = PathExtractServer(szServer);
            }
            else if (pszFile[0] == _iCachedDrive)
            {
                // Local drive letter already in cache -- use it
                pszServer = _pszServer;
            }
            else
            {
                // Local drive not cached -- cache it
                _iCachedDrive = pszFile[0];
                DWORD cch = ARRAYSIZE(szServer);
                if (SHWNetGetConnection(pszFile, szServer, &cch) == NO_ERROR)
                    pszServer = PathExtractServer(szServer);
                else
                    pszServer = NULL;
                Str_SetPtr(&_pszServer, pszServer);
            }

            TCHAR szName[MAX_PATH];
            DWORD cchName = ARRAYSIZE(szName);
            TCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD cchDomain = ARRAYSIZE(szDomain);
            SID_NAME_USE snu;
            LPTSTR pszName;
            BOOL fFreeName = FALSE; // Do we need to LocalFree(pszName)?

            if (LookupAccountSid(pszServer, psid, szName, &cchName,
                                 szDomain, &cchDomain, &snu))
            {
                //
                //  If the domain is the bogus "BUILTIN" or we don't have a domain
                //  at all, then just use the name.  Otherwise, use domain\userid.
                //
                if (!szDomain[0] || StrCmpC(szDomain, _szBuiltin) == 0)
                {
                    pszName = szName;
                }
                else
                {
                    // Borrow szServer as a scratch buffer
                    wnsprintf(szServer, ARRAYSIZE(szServer), TEXT("%s\\%s"), szDomain, szName);
                    pszName = szServer;
                }
                err = ERROR_SUCCESS;
            }
            else
            {
                err = GetLastError();

                // Couldn't map the SID to a name.  Use the horrid raw version
                // if available.
                if (ConvertSidToStringSid(psid, &pszName))
                {
                    fFreeName = TRUE;
                    err = ERROR_SUCCESS;
                }
                else
                    pszName = NULL;
            }

            // Even on error, cache the result so we don't keep trying over and over
            // on the same SID.

            _CacheSidName(psd, psid, pszName);
            pvar->bstrVal = SysAllocString(pszName);

            if (fFreeName)
                LocalFree(pszName);
        }
    }

    if (err == ERROR_SUCCESS && pvar->bstrVal == NULL)
        err = ERROR_OUTOFMEMORY;

    return HRESULT_FROM_WIN32(err);
}

STDMETHODIMP COwnerColumnProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr = S_FALSE;   // return S_FALSE on failure
    VariantInit(pvarData);

    if (IsEqualSCID(SCID_OWNER, *pscid))
    {
        hr = _LookupOwnerName(pscd->wszFile, pvarData);
    }

    return hr;
}

STDAPI CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    COwnerColumnProvider *pfcp = new COwnerColumnProvider;
    if (pfcp)
    {
        hr = pfcp->QueryInterface(riid, ppv);
        pfcp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI SHReadProperty(IShellFolder *psf, LPCITEMIDLIST pidl, REFFMTID fmtid, PROPID pid, VARIANT *pvar)
{
    IPropertySetStorage *ppss;
    HRESULT hr = psf->BindToStorage(pidl, NULL, IID_PPV_ARG(IPropertySetStorage, &ppss));
    if (SUCCEEDED(hr))
    {
        hr = ReadProperty(ppss, fmtid, pid, pvar);
        ppss->Release();
    }
    return hr;
}

// 66742402-F9B9-11D1-A202-0000F81FEDEE
// const CLSID CLSID_VersionColProvider = {0x66742402,0xF9B9,0x11D1,0xA2,0x02,0x00,0x00,0xF8,0x1F,0xED,0xEE};

//  FMTID_ExeDllInformation,
//// {0CEF7D53-FA64-11d1-A203-0000F81FEDEE}
#define PSFMTID_VERSION { 0xcef7d53, 0xfa64, 0x11d1, 0xa2, 0x3, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee }

#define PIDVSI_FileDescription   0x003
#define PIDVSI_FileVersion       0x004
#define PIDVSI_InternalName      0x005
#define PIDVSI_OriginalFileName  0x006
#define PIDVSI_ProductName       0x007
#define PIDVSI_ProductVersion    0x008

//  Win32 PE (exe, dll) Version Information column identifier defs...
DEFINE_SCID(SCID_FileDescription,   PSFMTID_VERSION, PIDVSI_FileDescription);
DEFINE_SCID(SCID_FileVersion,       PSFMTID_VERSION, PIDVSI_FileVersion);
DEFINE_SCID(SCID_InternalName,      PSFMTID_VERSION, PIDVSI_InternalName);
DEFINE_SCID(SCID_OriginalFileName,  PSFMTID_VERSION, PIDVSI_OriginalFileName);
DEFINE_SCID(SCID_ProductName,       PSFMTID_VERSION, PIDVSI_ProductName);
DEFINE_SCID(SCID_ProductVersion,    PSFMTID_VERSION, PIDVSI_ProductVersion);

const COLUMN_INFO c_rgExeDllColumns[] =
{
    DEFINE_COL_STR_ENTRY(SCID_CompanyName,        30, IDS_VN_COMPANYNAME),
    DEFINE_COL_STR_ENTRY(SCID_FileDescription,    30, IDS_VN_FILEDESCRIPTION),
    DEFINE_COL_STR_ENTRY(SCID_FileVersion,        20, IDS_VN_FILEVERSION),
    DEFINE_COL_STR_MENU_ENTRY(SCID_ProductName,   30, IDS_VN_PRODUCTNAME),
    DEFINE_COL_STR_MENU_ENTRY(SCID_ProductVersion,20, IDS_VN_PRODUCTVERSION),
};


class CVersionColProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    CVersionColProvider() : 
       CBaseColumnProvider(&CLSID_VersionColProvider, c_rgExeDllColumns, ARRAYSIZE(c_rgExeDllColumns), NULL)
    {
        _pvAllTheInfo = NULL;
        _szFileCache[0] = 0;
    };

    virtual ~CVersionColProvider() 
    {
        _ClearCache();
    }

    FARPROC _GetVerProc(LPCSTR pszName);
    HRESULT _CacheFileVerInfo(LPCWSTR pszFile);
    void _ClearCache();

    WCHAR _szFileCache[MAX_PATH];
    void  *_pvAllTheInfo;
    HRESULT _hrCache;

    friend HRESULT CVerColProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

void CVersionColProvider::_ClearCache()
{
    if (_pvAllTheInfo)
    {
        delete _pvAllTheInfo;
        _pvAllTheInfo = NULL;
    }
    _szFileCache[0] = 0;
}

HRESULT CVersionColProvider::_CacheFileVerInfo(LPCWSTR pszFile)
{
    if (StrCmpW(_szFileCache, pszFile))
    {
        HRESULT hr;
        _ClearCache();

        DWORD dwVestigial;
        DWORD versionISize = GetFileVersionInfoSizeW((LPWSTR)pszFile, &dwVestigial); // cast for bad API design
        if (versionISize)
        {
            _pvAllTheInfo = new BYTE[versionISize];
            if (_pvAllTheInfo)
            {
                // read the data
                if (GetFileVersionInfoW((LPWSTR)pszFile, dwVestigial, versionISize, _pvAllTheInfo))
                {
                    hr = S_OK;
                }
                else
                {
                    _ClearCache();
                    hr = E_FAIL;
                }
            }
            else
                hr = E_OUTOFMEMORY; // error, out of memory.
        }
        else
            hr = S_FALSE;

        StrCpyNW(_szFileCache, pszFile, ARRAYSIZE(_szFileCache));
        _hrCache = hr;
    }
    return _hrCache;
}

STDMETHODIMP CVersionColProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    VariantInit(pvarData);

    if (pscd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        return S_FALSE;

    HRESULT hr = _CacheFileVerInfo(pscd->wszFile);
    if (hr != S_OK)
        return hr;

    TCHAR szString[128], *pszVersionInfo = NULL; //A pointer to the specific version info I am looking for
    LPCTSTR pszVersionField = NULL;

    switch (pscid->pid)
    {
    case PIDVSI_FileVersion:
        {
            VS_FIXEDFILEINFO *pffi;
            UINT uInfoSize;
            if (VerQueryValue(_pvAllTheInfo, TEXT("\\"), (void **)&pffi, &uInfoSize))
            {
                wnsprintf(szString, ARRAYSIZE(szString), TEXT("%d.%d.%d.%d"), 
                    HIWORD(pffi->dwFileVersionMS),
                    LOWORD(pffi->dwFileVersionMS),
                    HIWORD(pffi->dwFileVersionLS),
                    LOWORD(pffi->dwFileVersionLS));

                pszVersionInfo = szString;
            }
            else
                pszVersionField = TEXT("FileVersion");      
        }
        break;

    case PIDDSI_COMPANY:            pszVersionField = TEXT("CompanyName");      break;
    case PIDVSI_FileDescription:    pszVersionField = TEXT("FileDescription");  break;
    case PIDVSI_InternalName:       pszVersionField = TEXT("InternalName");     break;
    case PIDVSI_OriginalFileName:   pszVersionField = TEXT("OriginalFileName"); break;
    case PIDVSI_ProductName:        pszVersionField = TEXT("ProductName");      break;
    case PIDVSI_ProductVersion:     pszVersionField = TEXT("ProductVersion");   break;
    default: 
        return E_FAIL;
    }
    //look for the intended language in the examined object.

    if (pszVersionInfo == NULL)
    {
        struct _VERXLATE
        {
            WORD wLanguage;
            WORD wCodePage;
        } *pxlate;                     /* ptr to translations data */

        //this is a fallthrough set of if statements.
        //on a failure, it just tries the next one, until it runs out of tries.
        UINT uInfoSize;
        if (VerQueryValue(_pvAllTheInfo, TEXT("\\VarFileInfo\\Translation"), (void **)&pxlate, &uInfoSize))
        {
            TCHAR szVersionKey[60];   //a string to hold all the format string for VerQueryValue
            wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\%04X%04X\\%s"),
                                                pxlate[0].wLanguage, pxlate[0].wCodePage, pszVersionField);
            if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
            {
                wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904B0\\%s"), pszVersionField);
                if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                {
                    wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904E4\\%s"), pszVersionField);
                    if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                    {
                        wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\04090000\\%s"), pszVersionField);
                        if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                        {
                            pszVersionInfo = NULL;
                        }
                    }
                }
            }
        }
    }
    
    if (pszVersionInfo)
    {
        PathRemoveBlanks(pszVersionInfo);
        hr = InitVariantFromStr(pvarData, pszVersionInfo);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI CVerColProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CVersionColProvider *pvcp = new CVersionColProvider;
    if (pvcp)
    {
        hr = pvcp->QueryInterface(riid, ppv);
        pvcp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\contextmenu.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#include "contextmenu.h"

// Context Menu Forwarding base class, desinged to delegate
// to a real IContextMenu, and provide inheriting class
// an easy way to override minor bits of functionality
//
CContextMenuForwarder::CContextMenuForwarder(IUnknown* punk) : _cRef(1)
{
    _punk = punk;
    _punk->AddRef();

    _punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &_pows));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu, &_pcm));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3));
}

CContextMenuForwarder::~CContextMenuForwarder()
{
    if (_pows) _pows->Release();
    if (_pcm)  _pcm->Release();
    if (_pcm2) _pcm2->Release();
    if (_pcm3) _pcm3->Release();
    _punk->Release();
}

STDMETHODIMP CContextMenuForwarder::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = _punk->QueryInterface(riid, ppv);

    if (SUCCEEDED(hr))
    {
        IUnknown* punkTmp = (IUnknown*)(*ppv);

        static const QITAB qit[] = {
            QITABENT(CContextMenuForwarder, IObjectWithSite),                     // IID_IObjectWithSite
            QITABENT(CContextMenuForwarder, IContextMenu3),                       // IID_IContextMenu3
            QITABENTMULTI(CContextMenuForwarder, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
            QITABENTMULTI(CContextMenuForwarder, IContextMenu, IContextMenu3),    // IID_IContextMenu
            { 0 },
        };

        HRESULT hrTmp = QISearch(this, qit, riid, ppv);

        if (SUCCEEDED(hrTmp))
        {
            punkTmp->Release();
        }
        else
        {
            RIPMSG(FALSE, "CContextMenuForwarder asked for an interface it doesn't support");
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


// A context menu implementation on an array of context menus
//
// use the Create_ContextMenuOnContextMenuArray construction function
//

#define MAX_CM_WRAP 5
class CContextMenuOnContextMenuArray : public IContextMenu3, public CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite); // override

    BOOL IsEmpty() { return 0 == _count; }

protected:
    CContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm);
    ~CContextMenuOnContextMenuArray();

    friend HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv);

private:
    LONG                _cRef;

    UINT                _count;
    UINT                _idFirst;                       // The begining of the first range is _idFirst
    UINT                _idOffsets[MAX_CM_WRAP];        // The END of each range (BEGINing of next range is +1)
    IContextMenu        *_pcmItem[MAX_CM_WRAP];         // The contextmenu for the item
    IContextMenu2       *_pcm2Item[MAX_CM_WRAP];        // The contextmenu for the item
    IContextMenu3       *_pcm3Item[MAX_CM_WRAP];        // The contextmenu for the item
};

CContextMenuOnContextMenuArray::CContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm) : _cRef(1)
{
    ASSERT(cpcm <= MAX_CM_WRAP);

    ASSERT(0 == _count);

    for (UINT i = 0 ; i < cpcm ; i++)
    {
        if (rgpcm[i])
        {
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu, &_pcmItem[_count]));
            ASSERT(_pcmItem[_count]);
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2Item[_count]));
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3Item[_count]));

            _count++;
        }
    }
}

HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (cpcm < MAX_CM_WRAP)
    {
        CContextMenuOnContextMenuArray* p = new CContextMenuOnContextMenuArray(rgpcm, cpcm);
        if (p)
        {
            if (p->IsEmpty())
            {
                hr = E_OUTOFMEMORY; // caller didn't check the array it gave us?
            }
            else
            {
                hr = p->QueryInterface(riid, ppv);
            }
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        RIPMSG(FALSE, "Create_ContextMenuOnContextMenuArray with too many items!");
        hr = E_INVALIDARG;
    }

    return hr;
}

CContextMenuOnContextMenuArray::~CContextMenuOnContextMenuArray()
{
    for (UINT i = 0 ; i < _count ; i++)
    {
        _pcmItem[i]->Release();
        if (_pcm2Item[i])
            _pcm2Item[i]->Release();
        if (_pcm3Item[i])
            _pcm3Item[i]->Release();
    }
}

STDMETHODIMP CContextMenuOnContextMenuArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CContextMenuOnContextMenuArray, IContextMenu, IContextMenu3),    // IID_IContextMenu
        QITABENTMULTI(CContextMenuOnContextMenuArray, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
        QITABENT(CContextMenuOnContextMenuArray, IContextMenu3),                       // IID_IContextMenu3
        QITABENT(CContextMenuOnContextMenuArray, IObjectWithSite),                     // IID_IObjectWithSite
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CContextMenuOnContextMenuArray::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuOnContextMenuArray::Release()
{
    if (InterlockedDecrement(&_cRef))
       return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CContextMenuOnContextMenuArray::SetSite(IUnknown *punkSite)
{
    // let all the kids know
    for (UINT i = 0; i < _count; i++)
    {
        IUnknown_SetSite(_pcmItem[i], punkSite);
    }

    return CObjectWithSite::SetSite(punkSite);
}

STDMETHODIMP CContextMenuOnContextMenuArray::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    _idFirst = idCmdFirst;
    
    // We need the placeholder for the below to work
    if (InsertMenu(hmenu, indexMenu, MF_BYPOSITION|MF_STRING, 0, L"{44075D61-2050-4DF4-BC5D-CBA88A84E75B}"))
    {
        BOOL fIndexMenuIsPlaceholder = TRUE;

        // For each of our context menus...
        for (UINT i = 0; i < _count  && idCmdFirst < idCmdLast; i++)
        {
            HRESULT hr = _pcmItem[i]->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
            if (SUCCEEDED(hr))
            {
                fIndexMenuIsPlaceholder = FALSE;

                _idOffsets[i] = idCmdFirst - _idFirst + (UINT)ShortFromResult(hr);
                idCmdFirst = idCmdFirst + (UINT)ShortFromResult(hr) + 1;

                // Find the placeholder so we know where to insert the next menu
                int cMenuItems = GetMenuItemCount(hmenu);
                for (int iItem = 0; iItem < cMenuItems; iItem++)
                {
                    WCHAR szName[60];
                    if (GetMenuString(hmenu, (iItem + indexMenu) % cMenuItems, szName, ARRAYSIZE(szName), MF_BYPOSITION)
                    &&  !lstrcmp(szName, L"{44075D61-2050-4DF4-BC5D-CBA88A84E75B}"))
                    {
                        indexMenu = (iItem + indexMenu) % cMenuItems;
                        fIndexMenuIsPlaceholder = TRUE;
                        break;
                    }
                }

                RIPMSG(fIndexMenuIsPlaceholder, "CContextMenuOnContextMenuArray::QueryContextMenu - some context menu removed our placeholder string");
            }
            else
            {
                if (0 == i)
                    _idOffsets[i] = 0;
                else
                    _idOffsets[i] = _idOffsets[i-1];
            }
        }

        // Remove the placeholder
        if (fIndexMenuIsPlaceholder)
        {
            DeleteMenu(hmenu, indexMenu, MF_BYPOSITION);
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "CContextMenuOnContextMenuArray::QueryContextMenu - could not add placeholder element");
    }

    return idCmdFirst - _idFirst;
}

STDMETHODIMP CContextMenuOnContextMenuArray::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hr;
    
    for (UINT i = 0; i < _count; i++)
    {
        if (IS_INTRESOURCE(lpici->lpVerb))
        {
            UINT idCmd = (UINT)LOWORD((DWORD_PTR)lpici->lpVerb);
            if (idCmd <= _idOffsets[i])
            {
                // adjust id to be in proper range for this pcm
                if (i > 0)
                {
                    lpici->lpVerb = MAKEINTRESOURCEA(idCmd - _idOffsets[i-1] - 1);
                }
                hr = _pcmItem[i]->InvokeCommand(lpici);
                return hr;
            }
        }
        else
        {
            // I guess we try until it works
            hr = _pcmItem[i]->InvokeCommand(lpici);
            if (SUCCEEDED(hr))
                return hr;
        }
    }
    
    TraceMsg(TF_ERROR, "Someone's passing CContextMenuOnContextMenuArray::InvokeCommand an id we didn't insert...");
    return E_FAIL;
}

STDMETHODIMP CContextMenuOnContextMenuArray::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT * pmf, LPSTR pszName, UINT  cchMax)
{
    for (UINT i = 0; i < _count; i++)
    {
        if (idCmd <= _idOffsets[i])
        {
            // adjust id to be in proper range for this pcm
            if (i>0)
            {
                idCmd = idCmd - _idOffsets[i-1] - 1;
            }
        
            return _pcmItem[i]->GetCommandString(idCmd, wFlags, pmf, pszName, cchMax);
        }
    }

    TraceMsg(TF_ERROR, "Someone's passing CContextMenuOnContextMenuArray::GetCommandString an id we didn't insert...");
    return E_FAIL;
}

STDMETHODIMP CContextMenuOnContextMenuArray::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

STDMETHODIMP CContextMenuOnContextMenuArray::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = E_FAIL;
    UINT idCmd;

    // Find the menu command id -- it's packed differently depending on the message
    //
    switch (uMsg) 
    {
    case WM_MEASUREITEM:
        idCmd = ((MEASUREITEMSTRUCT *)lParam)->itemID;
        break;

    case WM_DRAWITEM:
        idCmd = ((LPDRAWITEMSTRUCT)lParam)->itemID;
        break;

    case WM_INITMENUPOPUP:
        idCmd = GetMenuItemID((HMENU)wParam, 0);
        break;

    case WM_MENUSELECT:
        {
            idCmd = GET_WM_MENUSELECT_CMD(wParam, lParam);
            UINT wFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);

            // if idCmd is an offset, convert it to a menu id
            if (wFlags & MF_POPUP)
            {
                MENUITEMINFO miiSubMenu;

                miiSubMenu.cbSize = sizeof(MENUITEMINFO);
                miiSubMenu.fMask = MIIM_ID;
                miiSubMenu.cch = 0;     // just in case

                if (GetMenuItemInfo(GET_WM_MENUSELECT_HMENU(wParam, lParam), idCmd, TRUE, &miiSubMenu))
                {
                    idCmd = miiSubMenu.wID;
                }
                else
                {
                    return E_FAIL;
                }
            }
        }
        break;

    case WM_MENUCHAR:
        if (NULL != plResult)
        {
            for (UINT i = 0; i < _count; i++)
            {
                if (_pcm3Item[i])
                {
                    hr = _pcm3Item[i]->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
                    if (S_OK == hr)
                        return hr;
                }
            }
        }
        return E_FAIL;

    default:
        return E_FAIL;
    }

    // make sure it's in our range
    if (idCmd >= _idFirst)
    {
        idCmd -= _idFirst;
        
        for (UINT i = 0; i < _count; i++)
        {
            if (idCmd <= _idOffsets[i])
            {
                if (_pcm3Item[i])
                    hr = _pcm3Item[i]->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
                else if (_pcm2Item[i] && NULL == plResult)
                    hr = _pcm2Item[i]->HandleMenuMsg(uMsg, wParam, lParam);
                break;
            }
        }
    }

    return hr;
}

// CContextMenuOnHMENU takes ownership of HMENU and creates
// an IContextMenu implementation out of it, forwarding all
// messages to hwndOwner.
//
class CContextMenuOnHMENU : IContextMenu3
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

protected:
    CContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner);
    virtual ~CContextMenuOnHMENU();
    friend HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID iid, void** ppv);

private:
    LONG _cRef;

    HMENU _hmenu;    // menu to wrap
    HWND  _hwndOwner;// window to forward menu messages to

    UINT  _idCmdFirst;

    UINT  _rgid[200]; // mapping of context menu ids to the original hmenu command ids (arbitrary limit to the size of an hmenu we support)
    UINT  _crgid;

    void _RebaseMenu(HMENU hmenu, UINT uFlags); // maps _hmenu's ids such that _rgid[newid-1]=oldid
    BOOL _IsValidID(UINT wID) { return (wID > 0 && wID <= _crgid); } // can we index _rgid[] with [wID-1]?
};

CContextMenuOnHMENU::CContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner) : _cRef(1)
{
    _hmenu = hmenu;
    _hwndOwner = hwndOwner;
}

// takes ownership of hmenu
HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;
    
    if (hmenu)
    {
        CContextMenuOnHMENU* p = new CContextMenuOnHMENU(hmenu, hwndOwner);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
        {
            DestroyMenu(hmenu);
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY; // caller probably just didn't check for this error case
    }

    return hr;
}

CContextMenuOnHMENU::~CContextMenuOnHMENU()
{
    DestroyMenu(_hmenu);
}

STDMETHODIMP CContextMenuOnHMENU::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CContextMenuOnHMENU, IContextMenu3),                       // IID_IContextMenu3
        QITABENTMULTI(CContextMenuOnHMENU, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
        QITABENTMULTI(CContextMenuOnHMENU, IContextMenu, IContextMenu3),    // IID_IContextMenu
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CContextMenuOnHMENU::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuOnHMENU::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// What is the lowest menu id used in hmenu?
// (Note that "-1" is often used for separators,
// but that is a very LARGE number...)
//
void CContextMenuOnHMENU::_RebaseMenu(HMENU hmenu, UINT uFlags)
{
    for (int nItem = GetMenuItemCount(hmenu) - 1; nItem >= 0; nItem--)
    {
        MENUITEMINFO mii = {0};

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        if (!GetMenuItemInfo(hmenu, nItem, TRUE, &mii))
        {
            continue;
        }

        if (!mii.hSubMenu || (uFlags & MM_SUBMENUSHAVEIDS))
        {
            if (_crgid < ARRAYSIZE(_rgid))
            {
                _rgid[_crgid] = mii.wID;
                mii.wID = ++_crgid;
                SetMenuItemInfo(hmenu, nItem, TRUE, &mii);
            }
            else
            {
                RIPMSG(FALSE, "CContextMenuOnHMENU::_RebaseMenu() - Someone is using an HMENU that's too big...");
                DeleteMenu(hmenu, nItem, MF_BYPOSITION);
                continue;
            }
        }

        if (mii.hSubMenu)
        {
            _RebaseMenu(mii.hSubMenu, uFlags);
        }
    }
}

HRESULT CContextMenuOnHMENU::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    _idCmdFirst = idCmdFirst;

    _RebaseMenu(_hmenu, uFlags);
    
    UINT idMax = Shell_MergeMenus(hmenu, _hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);

    return idMax - _idCmdFirst;
}

HRESULT CContextMenuOnHMENU::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    if (IS_INTRESOURCE(lpici->lpVerb))
    {
        UINT wID = LOWORD((UINT_PTR)lpici->lpVerb);

        RIPMSG(_IsValidID(wID), "CContextMenuOnHMENU::InvokeCommand() received invalid wID");

        if (_IsValidID(wID))
        {
            wID = _rgid[wID-1];

            SendMessage(_hwndOwner, WM_COMMAND, GET_WM_COMMAND_MPS(wID, 0, 0));

            return S_OK;
        }
    }

    return E_INVALIDARG;
}

HRESULT CContextMenuOnHMENU::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    if (cchMax)
        pszName[0] = 0;

    if (IS_INTRESOURCE(idCmd))
    {
        RIPMSG(_IsValidID(idCmd), "CContextMenuOnHMENU::InvokeCommand() received invalid idCmd");

        if (_IsValidID(idCmd))
        {
            UINT wID = _rgid[idCmd - 1];

            switch (uType)
            {
            case GCS_HELPTEXT:
                // The only time this seems to be called is in response to a WM_MENUSELECT,
                // so forward it back to _hwndOwner so it can be the real WM_MENUSELECT
                SendMessage(_hwndOwner, WM_MENUSELECT, GET_WM_MENUSELECT_MPS(wID, 0, _hmenu));
                return E_FAIL;
            }

            return E_NOTIMPL;
        }
    }

    return E_INVALIDARG;
}

HRESULT CContextMenuOnHMENU::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

HRESULT CContextMenuOnHMENU::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = E_FAIL;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        lRes = SendMessage(_hwndOwner, uMsg, (WPARAM)_hmenu, lParam);
        hr = S_OK;
        break;

    case WM_DRAWITEM:
    {
        LPDRAWITEMSTRUCT pdi = ((LPDRAWITEMSTRUCT)lParam);
        DRAWITEMSTRUCT di = *pdi;
        RIPMSG(_IsValidID(di.itemID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_DRAWITEM) received invalid itemID");
        if (_IsValidID(di.itemID - _idCmdFirst))
        {
            di.itemID = _rgid[di.itemID - _idCmdFirst - 1];
            lRes = SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)&di);
            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;
    }

    case WM_MEASUREITEM:
    {
        LPMEASUREITEMSTRUCT pmi =((LPMEASUREITEMSTRUCT)lParam);
        MEASUREITEMSTRUCT mi = *pmi;
        RIPMSG(_IsValidID(mi.itemID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_MEASUREITEM) received invalid itemID");
        if (_IsValidID(mi.itemID - _idCmdFirst))
        {
            mi.itemID = _rgid[mi.itemID - _idCmdFirst - 1];
            lRes = SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)&mi);
            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;
    }

    case WM_MENUSELECT:
    {
        UINT wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
        UINT wFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);

        if (!(wFlags & MF_POPUP))
        {
            RIPMSG(_IsValidID(wID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_MENUSELECT) received invalid wID");
            if (_IsValidID(wID - _idCmdFirst))
            {
                wID = _rgid[wID - _idCmdFirst - 1];
            }
            else
            {
                hr = E_INVALIDARG;
                break;
            }
        }

        lRes = SendMessage(_hwndOwner, uMsg, GET_WM_MENUSELECT_MPS(wID, wFlags, _hmenu));
        hr = S_OK;
        break;
    }

    case WM_MENUCHAR:
        // should probably be SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)_hmenu)
        // but our WM_MENUCHAR forwarding doesn't find the correct owner...
        //
        lRes = DefWindowProc(_hwndOwner, uMsg, wParam, (LPARAM)_hmenu);
        hr = (0 == lRes) ? S_FALSE : S_OK;
        break;

    default:
        RIPMSG(FALSE, "CContextMenuOnHMENU::HandleMenuMsg2 was forwarded an unexpected window message");
        lRes = 0;
        hr = E_FAIL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}


// Forward everything to the given context menu,
// but remove menu items with the canonical verbs
// given in the semicolon-separated list of canonical verbs
//
class CContextMenuWithoutVerbs : CContextMenuForwarder
{
public:
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);

protected:
    CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList);

    friend HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);

private:
    LPCWSTR _pszVerbList;
};

CContextMenuWithoutVerbs::CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList) : CContextMenuForwarder(punk) 
{
    _pszVerbList = pszVerbList; // no reference - this should be a pointer to the code segment
}

HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    if (pszVerbList)
    {
        CContextMenuWithoutVerbs* p = new CContextMenuWithoutVerbs(punk, pszVerbList);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
    }

    return hr;
}

HRESULT CContextMenuWithoutVerbs::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    HRESULT hr = CContextMenuForwarder::QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszVerb = _pszVerbList;

        while (*pszVerb)
        {
            WCHAR szVerb[64];

            LPCWSTR pszNext = StrChrW(pszVerb, L';');

            if (pszNext)
            {
                UINT cch = (UINT)(pszNext - pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyN(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb = pszNext + 1;
            }
            else
            {
                UINT cch = lstrlen(pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyN(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb += cch - 1; // point at NULL
            }

            ContextMenu_DeleteCommandByName(_pcm, hmenu, idCmdFirst, szVerb);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\copyfgd.cpp ===
/*****************************************************************************\
    FILE: copyfgd.cpp

    DESCRIPTION:
        Copy a FileGroupDescriptor.
\*****************************************************************************/

#include "shellprv.h"

#include <ynlist.h>
#include "ids.h"
#include "pidl.h"
#include "fstreex.h"
#include "copy.h"
#include <shldisp.h>
#include <shlwapi.h>
#include <wininet.h>    // InternetGetLastResponseInfo
#include "ynlist.h"
#include "datautil.h"

class CCopyThread;
HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct);

extern "C" {
    #include "undo.h"
    #include "defview.h"
};

BOOL GetWininetError(DWORD dwError, BOOL fCopy, LPTSTR pszErrorMsg, DWORD cchSize)
{
    TCHAR szErrorMsg[MAX_PATH];
    BOOL fIsWininetError = ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST));

    // Default message if FormatMessage doesn't recognize hres
    szErrorMsg[0] = 0;
    LoadString(HINST_THISDLL, (fCopy ? IDS_COPYERROR : IDS_MOVEERROR), szErrorMsg, ARRAYSIZE(szErrorMsg));

    if (fIsWininetError)
    {
        static HINSTANCE s_hinst = NULL;

        if (!s_hinst)
            s_hinst = GetModuleHandle(TEXT("WININET")); // It's okay if we leak it.

        // Can wininet give us extended error messages?
        // We ignore them because it's too late to call InternetGetLastResponseInfo.
        if (ERROR_INTERNET_EXTENDED_ERROR != dwError)
        {
            TCHAR szDetails[MAX_PATH*2];

            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)s_hinst, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);
            StrCatBuff(szErrorMsg, TEXT("%s"), ARRAYSIZE(szErrorMsg));
            wnsprintf(pszErrorMsg, cchSize, szErrorMsg, szDetails);
        }
        else
            StrCpyN(pszErrorMsg, szErrorMsg, cchSize);
    }
    else
    {
        StrCpyN(pszErrorMsg, szErrorMsg, cchSize);
    }

    return TRUE;
}


// thunk A/W funciton to access A/W FILEGROUPDESCRIPTOR
// this relies on the fact that the first part of the A/W structures are
// identical. only the string buffer part is different. so all accesses to the
// cFileName field need to go through this function.
//

FILEDESCRIPTOR *GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName)
{
    if (fUnicode)
    {
        // Yes, so grab the data because it matches.
        FILEGROUPDESCRIPTORW * pfgdW = (FILEGROUPDESCRIPTORW *)pfgd;    // cast to what this really is

        // If the filename starts with a leading / we're going to be in trouble, since the rest
        // of the code assumes its going to be a \.  Web folders does the leading /, so just lop it
        // off right here.

        WCHAR *pwz = pfgdW->fgd[nIndex].cFileName;
        if (pfgdW->fgd[nIndex].cFileName[0] == '/')
        {
            memmove(pwz, pwz+1, sizeof(pfgdW->fgd[nIndex].cFileName) - sizeof(WCHAR));
        }

        // Now flip all the /'s to \'s.  No dbcs issues, we're unicode!
        for (; *pwz; ++pwz)
        {
            if (*pwz == '/')
            {
                *pwz = '\\';
            }
        }

        if (pszName)
            SHUnicodeToTChar(pfgdW->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdW->fgd[nIndex];   // cast assume the non string parts are the same!
    }
    else
    {
        FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA *)pfgd;     // cast to what this really is

        if (pfgdA->fgd[nIndex].cFileName[0] == '/' &&
            CharNextA(pfgdA->fgd[nIndex].cFileName) == pfgdA->fgd[nIndex].cFileName+1)
        {
            memmove (pfgdA->fgd[nIndex].cFileName, pfgdA->fgd[nIndex].cFileName+1, sizeof(pfgdA->fgd[nIndex].cFileName)-sizeof(char));
        }

        if (pszName)
            SHAnsiToTChar(pfgdA->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdA->fgd[nIndex];   // cast assume the non string parts are the same!
    }
}


void CreateProgressStatusStr(LPCTSTR pszDirTo, LPWSTR pwzProgressStr, DWORD cchSize)
{
    // IDS_COPYTO also works in move operations. (It doesn't use the work "Copy")
    LPTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_COPYTO), pszDirTo);

    if (pszMsg)
    {
        SHTCharToUnicode(pszMsg, pwzProgressStr, cchSize);
        LocalFree(pszMsg);
    }
    else
        pwzProgressStr[0] = 0;
}


void CalcBytesInFileGrpDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, ULARGE_INTEGER * puliTotal)
{
    puliTotal->QuadPart = 0; // Init.
    for (UINT i = 0; i < pfgd->cItems; i++)
    {
        // WARNING: This may point to a FILEDESCRIPTOR *A or W, but that's ok as long as we ignore the filename.
        ULARGE_INTEGER uliFileSize;
        FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, NULL);

        if (pfd->dwFlags & FD_FILESIZE)
        {
            uliFileSize.HighPart = pfd->nFileSizeHigh;
            uliFileSize.LowPart = pfd->nFileSizeLow;
            puliTotal->QuadPart += uliFileSize.QuadPart;
        }
    }
}

BOOL IsNameInDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, LPCTSTR pszName, UINT iMax)
{
    for (UINT i = 0; i < iMax; i++)
    {
        TCHAR szName[MAX_PATH];
        // WARNING: This may point to a FILEDESCRIPTOR *A or W, but that's ok as long as we ignore the filename.
        FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, szName);
        if (lstrcmpi(szName, pszName) == 0)
            return TRUE;
    }
    return FALSE;
}


BOOL ShowProgressUI(FILEGROUPDESCRIPTOR *pfgd)
{
    return (0 < pfgd->cItems) && (FD_PROGRESSUI & pfgd->fgd->dwFlags);
}


class CCopyThread
                : public IUnknown
{
public:
    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

    HRESULT DoCopy(void) {return _DoCopy(_pdtobj);};
    HRESULT DoAsynchCopy(void);
    HRESULT GetEffect(DWORD *pdwEffect) {*pdwEffect = _dwEffect; return S_OK;}; // For synchronous case only.

    friend HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct);

protected:
    CCopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget);
    ~CCopyThread();

private:
    HRESULT _CopyThreadProc(void);
    static DWORD CALLBACK CopyThreadProc(void *pvThis) { return ((CCopyThread *) pvThis)->_CopyThreadProc(); };
    HRESULT _DoCopy(IDataObject * pdo);

    LONG                _cRef;

    HWND                _hwnd;
    LPCTSTR             _pszPath;
    IDataObject *       _pdtobj;        // Unmarshalled
    IStream *           _pstmDataObjMarshal;  // Carrying the IDataObject across threads
    DWORD               _dwEffect;
    BOOL                _fWindowIsTarget;
};


CCopyThread::CCopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget) : _cRef(1)
{
    DllAddRef();

    // Assert this class was zero inited.
    ASSERT(!_pdtobj);
    ASSERT(!_pstmDataObjMarshal);
    ASSERT(!_dwEffect);
    ASSERT(!_hwnd);
    ASSERT(!_pszPath);

    _hwnd = hwnd;

    // If we are dropping onto the background of the window, we can assume that the window we
    // are passed is the target window of the copy.
    _fWindowIsTarget = fIsBkDropTarget;

    Str_SetPtr((LPTSTR *) &_pszPath, pszPath);
    IUnknown_Set((IUnknown **)&_pdtobj, (IUnknown *)pdtobj);

    // The caller doesn't get the return value in pdwEffect because it happens on a background thread.
    // take these out of this because we don't want a cancel operation to not make it back to a caller
    // and have them delete the files anyway.  We also need to make sure moves are done in such a way that the
    // destination (us) moves the files and not the caller.  This is the caller will return from ::Drop() before
    // the files finish copying (moving).
    _dwEffect = *pdwEffect;
}


CCopyThread::~CCopyThread()
{
    IUnknown_Set((IUnknown **)&_pdtobj, NULL);
    IUnknown_Set((IUnknown **)&_pstmDataObjMarshal, NULL);
    Str_SetPtr((LPTSTR *) &_pszPath, NULL);

    DllRelease();
}

HRESULT CCopyThread::DoAsynchCopy(void)
{
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, _pdtobj, &_pstmDataObjMarshal);
    if (SUCCEEDED(hr))
    {
        IUnknown_Set((IUnknown **)&_pdtobj, NULL);

        AddRef();   // pass to thread

        if (SHCreateThread(CCopyThread::CopyThreadProc, this, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            Release();  // thread did not take, we need to release
        }
    }

    return hr;
}

HRESULT CCopyThread::_CopyThreadProc(void)
{
    IDataObject * pdo;
    HRESULT hr = CoGetInterfaceAndReleaseStream(_pstmDataObjMarshal, IID_PPV_ARG(IDataObject, &pdo));

    _pstmDataObjMarshal = NULL; // CoGetInterfaceAndReleaseStream() released the ref.
    if (S_OK == hr)
    {
        hr = _DoCopy(pdo);

        IAsyncOperation * pao;
        if (SUCCEEDED(pdo->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pao))))
        {
            pao->EndOperation(hr, NULL, _dwEffect);
            pao->Release();
        }

        pdo->Release();
    }

    Release();      // Releae the background thread's ref.
    return hr;
}


HRESULT ConvertCallerFDToTCharFD(const FILEDESCRIPTOR * pfdSource, BOOL fUnicode, FILEDESCRIPTOR * pfdDest)
{
#ifdef UNICODE
    if (fUnicode)
    {
        *pfdDest = *pfdSource;
    }
    else
    {
        // pfdSource is really ansi.
        const FILEDESCRIPTORA * pfdSourceA = (const FILEDESCRIPTORA *) pfdSource;

        // We need to convert, so copy the small part.
        *(FILEDESCRIPTORA *)pfdDest = *pfdSourceA;
        SHAnsiToUnicode(pfdSourceA->cFileName, pfdDest->cFileName, ARRAYSIZE(pfdDest->cFileName));
    }
#else // UNICODE
    if (fUnicode)
    {
        // pfdSource is really unicode.
        const FILEDESCRIPTORW * pfdSourceW = (const FILEDESCRIPTORW *) pfdSource;

        // We need to convert, so copy the small part.
        *(FILEDESCRIPTORA *)pfdDest = *(const FILEDESCRIPTORA *)pfdSource;
        SHUnicodeToAnsi(pfdSourceW->cFileName, pfdDest->cFileName, ARRAYSIZE(pfdDest->cFileName));
    }
    else
    {
        *pfdDest = *pfdSource;
    }
#endif // UNICODE

    return S_OK;
}


BOOL IsWininetHRESULT(IN HRESULT hr)
{
    // One way to tell if the error is from wininet is to check for the FACILITY_INTERNET
    // facility.
    BOOL fIsWininet = (FACILITY_INTERNET == HRESULT_FACILITY(hr));
    DWORD dwError = HRESULT_CODE(hr);

    // However, sometimes that facility won't be set but it will still be a wininet error.
    if (!fIsWininet &&
        (FACILITY_WIN32 == HRESULT_FACILITY(hr)) &&
        ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST)))
    {
        // Win #147295.  The root of the problem is that an API that returns a dwError can only
        // return error numbers in one FACILITY.  However, wininet APIs will return error values
        // in the FACILITY_INTERNET facility (ERROR_INTERNET_* which is 12000 to INTERNET_ERROR_LAST)
        // AND from the FACILITY_WIN32 facility (like ERROR_NO_MORE_FILES).  Therefore the caller
        // can't just blindly set the FACILITY_INTERNET facility when converting the dwError to an
        // HRESULT.
        //
        // If wininet was smart, they would just use the WIN32 facility since they reserved the 12000
        // range.
        fIsWininet = TRUE;
    }

    return fIsWininet;
}


// Puts up a message box if necessary.
// we don't want to see any error with FACILITY_ITF, since we
// can't make sense of those errors anyway.
void MessageBoxIfNecessary(HRESULT hr, DWORD dwEffect, HWND hwndDlgParent)
{
    TCHAR szTitle[MAX_PATH];
    LoadString(HINST_THISDLL, ((DROPEFFECT_COPY == dwEffect) ? IDS_FILEERRORCOPY : IDS_FILEERRORCOPY), szTitle, ARRAYSIZE(szTitle));

    if (IsWininetHRESULT(hr))
    {
        TCHAR szErrorMsg[MAX_PATH];

        if (GetWininetError(HRESULT_CODE(hr), (DROPEFFECT_COPY == dwEffect),
                            szErrorMsg, ARRAYSIZE(szErrorMsg)))
        {
            MessageBox(hwndDlgParent, szErrorMsg, szTitle, (MB_ICONERROR | MB_OK | MB_SYSTEMMODAL));
        }
    }
    else if (HRESULT_FACILITY(hr) != FACILITY_ITF)
    {
        // dont display an error if caused by a user cancel.
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            TCHAR szErrorMsg[MAX_PATH];

            if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hr),
                              0L, szErrorMsg, ARRAYSIZE(szErrorMsg), NULL))
            {
                MessageBox(hwndDlgParent, szErrorMsg, szTitle, (MB_ICONERROR | MB_OK | MB_SYSTEMMODAL));
            }
        }
    }
    // All other errors don't make any sense to the user, so don't put
    // up any UI.
}


HRESULT CCopyThread::_DoCopy(IDataObject * pdo)
{
    HRESULT hr = S_OK;
    FORMATETC fmteA = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteW = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteOffset = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM mediumFGD = {0}, mediumOffset = {0};
    BOOL fUnicode = FALSE;
    PROGRESSINFO progInfo = {0};

    // We should have only one bit set.
    ASSERT(_dwEffect==DROPEFFECT_COPY || _dwEffect==DROPEFFECT_LINK || _dwEffect==DROPEFFECT_MOVE);

    // Display the progress now because pdo->GetData may be slow, especially if we have to call it
    // twice.IDA_FILEMOVE
    progInfo.ppd = CProgressDialog_CreateInstance(((DROPEFFECT_COPY == _dwEffect) ? IDS_ACTIONTITLECOPY : IDS_ACTIONTITLEMOVE), ((DROPEFFECT_COPY == _dwEffect) ? IDA_FILECOPY : IDA_FILEMOVE), g_hinst);
    if (progInfo.ppd)
    {
        WCHAR wzCalcTime[MAX_PATH];

        progInfo.uliBytesCompleted.QuadPart = progInfo.uliBytesTotal.QuadPart = 0;
        progInfo.ppd->StartProgressDialog(_hwnd, NULL, PROGDLG_AUTOTIME, NULL);
        
        LoadStringW(HINST_THISDLL, ((DROPEFFECT_COPY == _dwEffect) ? IDS_CALCCOPYTIME : IDS_CALCMOVETIME), wzCalcTime, ARRAYSIZE(wzCalcTime));
        progInfo.ppd->SetLine(2, wzCalcTime, FALSE, NULL);
    }


    // First try to massage the IDataObject into a virtual storage that we can use as the
    // source of a storage engine copy

    bool bPerformManually = true;

    if (bPerformManually)
    {
        // Try for UNICODE group descriptor first.  If that succeeds, we won't bother trying to
        // ASCII since UNICODE is the "preferred" format.  For ANSI builds, we only try for ANSI
        hr = pdo->GetData(&fmteW, &mediumFGD);
        if (SUCCEEDED(hr))
            fUnicode = TRUE;
        else
            hr = pdo->GetData(&fmteA, &mediumFGD);

        if (SUCCEEDED(hr))
        {
            UINT i, iConflict = 1;
            UINT iTopLevelItem = 0;
            YNLIST ynl;
            DROPHISTORY dh = {0};

            // WARNING: pfgd is really an A or W struct. to deal with this all code needs to use
            // the GetFileDescriptor() function

            FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(mediumFGD.hGlobal);  
            DECLAREWAITCURSOR;

            SetWaitCursor();
            BOOL fCantUseDialogHWND = FALSE;
            if (progInfo.ppd)
            {
                CalcBytesInFileGrpDescriptor(pfgd, fUnicode, &progInfo.uliBytesTotal);
                // We displayed progress above because pdo->GetData() and CalcBytesInFileGrpDescriptor are slow, but most likely it
                // was just eating into the delay time before the progress appears.  If the caller
                // didn't want UI, we will close it down now.
                if (!ShowProgressUI(pfgd))
                {
                    progInfo.ppd->StopProgressDialog();
                    fCantUseDialogHWND = TRUE;
                }
                else
                    progInfo.ppd->Timer(PDTIMER_RESET, NULL);
            }

            CreateYesNoList(&ynl);

            // Try & get the offsets too.
            HRESULT hrOffset = pdo->GetData(&fmteOffset, &mediumOffset);
            if (SUCCEEDED(hrOffset))
            {
                dh.pptOffset = (POINT *)GlobalLock(mediumOffset.hGlobal);
                dh.pptOffset++;  // First item is the anchor
            }

            for (i = 0; i < pfgd->cItems; i++)
            {
                BOOL fTopLevel;
                TCHAR szFullPath[MAX_PATH], szFileName[MAX_PATH];
                FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, szFileName);

                StrCpyN(szFullPath, _pszPath, ARRAYSIZE(szFullPath));

                // if the source gave us duplicate file names we make them unique here
                // foo (1).txt, foo (2).txt, etc
                // name conflicts with targets still get the replace file confirm UI
                if (IsNameInDescriptor(pfgd, fUnicode, szFileName, i))
                {
                    TCHAR szBuf[MAX_PATH], *pszExt = PathFindExtension(szFileName);
                    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT(" (%d)%s"), iConflict++, pszExt);  // " (xxx).msg"
                    // make sure it will fit
                    if (((int)ARRAYSIZE(szFileName) - lstrlen(szFileName)) > (lstrlen(szBuf) - lstrlen(pszExt))) 
                        lstrcpy(pszExt, szBuf);
                }

                // do PathCleanupSpec on the filespec part of the filename because names
                // can be relative paths "Folder\foo.txt", "Folder\Folder2\foo.txt"
                PathCleanupSpec(szFullPath, PathFindFileName(szFileName));

                // the filename in the descriptor should not be a fully qualified path
                if (PathIsRelative(szFileName))
                {
                    PathAppend(szFullPath, szFileName);
                    fTopLevel = (StrChr(szFileName, TEXT('\\')) == NULL &&
                                    StrChr(szFileName, TEXT('/')) == NULL);
                }
                else
                {
                    TraceMsg(TF_WARNING, "CopyFGD: FGD contains full path - ignoring path");
                    PathAppend(szFullPath, PathFindFileName(szFileName));
                    fTopLevel = TRUE;
                }

                if (IsInNoList(&ynl, szFullPath))
                {
                    continue;
                }

                HWND hwndDlgParent;
                if (fCantUseDialogHWND || FAILED(IUnknown_GetWindow(progInfo.ppd, &hwndDlgParent)))
                {
                    hwndDlgParent = _hwnd;
                }

                BOOL fDirectory = (pfd->dwFlags & FD_ATTRIBUTES) && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

                // NOTE: SHPathPrepareForWrite() was moved here to insure that we check for replace operations
                // against a real directory (not an empty a: drive, for example).  However, the result is not checked
                // until later - make sure that we don't overwrite 'hr' between here and there.
                hr = SHPathPrepareForWrite(hwndDlgParent, NULL, szFullPath, SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME);

                FILEDESCRIPTOR fd = {0};

                ConvertCallerFDToTCharFD(pfd, fUnicode, &fd);
                switch (ValidateCreateFileFromClip(hwndDlgParent, &fd, szFullPath, &ynl))
                {
                case IDYES:
                    break;

                case IDNO:
                    // mil bug 127038
                    // when somebody says "no don't overwrite", we don't want the performed
                    // drop effect to get set to DROPEFFECT_MOVE, so we set it to DROPEFFECT_NONE
                    // here.
                    _dwEffect = 0;
                    continue;

                case IDCANCEL:
                    // NOTE: This doesn't do anything because the caller never gets this back
                    //       in the asynch case.
                    _dwEffect = 0;
                    i = (int)pfgd->cItems - 1;
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    continue;
                }

                if (progInfo.ppd)
                {
                    WCHAR wzFileName[MAX_PATH];
                    WCHAR wzTemplateStr[MAX_PATH];
                    WCHAR wzProgressStr[MAX_PATH];

                    if (DROPEFFECT_COPY == _dwEffect)
                        LoadStringW(HINST_THISDLL, IDS_COPYING, wzTemplateStr, ARRAYSIZE(wzTemplateStr));
                    else
                        LoadStringW(HINST_THISDLL, IDS_MOVING, wzTemplateStr, ARRAYSIZE(wzTemplateStr));

                    // Display "Copying 'filename'" or "Moving 'filename'" on line 1
                    SHTCharToUnicode(szFileName, wzFileName, ARRAYSIZE(wzFileName));
                    wnsprintfW(wzProgressStr, ARRAYSIZE(wzProgressStr), wzTemplateStr, wzFileName);
                    progInfo.ppd->SetLine(1, wzProgressStr, FALSE, NULL);

                    // Display the dir on line 2
                    CreateProgressStatusStr(_pszPath, wzProgressStr, ARRAYSIZE(wzProgressStr));
                    progInfo.ppd->SetLine(2, wzProgressStr, FALSE, NULL);
                }


                if (fDirectory)
                {
                    // Call SHPathPrepareForWrite() again without SHPPFW_IGNOREFILENAME so that it
                    // will create the directory if it doesn't already exist.
                    hr = SHPathPrepareForWrite(hwndDlgParent, NULL, szFullPath, SHPPFW_DEFAULT);
                
                    if (FAILED(hr))
                    {
                        // NOTE: This doesn't do anything because the caller never gets this back
                        //       in the asynch case.
                        _dwEffect = 0;
                        break;
                    }
                }
                else
                {
                    // We want to prepare the path both before and after errors in order to catch different cases.
                
                    // NOTE: We should be checking the result of SHPathPrepareForWrite() here
                    if (SUCCEEDED(hr))
                    {
                        hr = DataObj_SaveToFile(pdo, g_cfFileContents, i, szFullPath, pfd, &progInfo);
                    }

                    if (FAILED(hr))
                    {
                        MessageBoxIfNecessary(hr, _dwEffect, hwndDlgParent);

                        // NOTE: This doesn't do anything because the caller never gets this back
                        //       in the asynch case.
                        _dwEffect = 0;
                        break;
                    }
                }

                // Only position item if it was created successfully
                // and it is not tucked in a subdir.

                // The last condition is because there is some confusion about whether _hwnd is the
                // target window of the copy or not. If it is, we should tell the window
                // to position the item we just dropped.
                if (SUCCEEDED(hr) && fTopLevel && _fWindowIsTarget)
                {
                    dh.iItem = iTopLevelItem;

                    if (SUCCEEDED(hrOffset) && dh.pptOffset)
                    {
                        // need to range check the points in case # of items in the list does not match the #
                        // of points. this happens when defview does not know the right number of items
                        // in the data object.
                        SIZE_T cbSize = GlobalSize(mediumOffset.hGlobal);
                        if (((dh.iItem + 1) * sizeof(dh.pptOffset[0])) > cbSize)
                        {
                            dh.pptOffset = NULL;
                            ReleaseStgMediumHGLOBAL(NULL, &mediumOffset);
                            hrOffset = E_FAIL;    // for test below
                        }
                    }

                    PositionFileFromDrop(_hwnd, szFullPath, &dh);
                    iTopLevelItem++;
                }

                if (progInfo.ppd)
                {
                    ULARGE_INTEGER uliFileSize;
                    uliFileSize.HighPart = pfd->nFileSizeHigh;
                    uliFileSize.LowPart = pfd->nFileSizeLow;
                    progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;
                    progInfo.ppd->SetProgress64(progInfo.uliBytesCompleted.QuadPart, progInfo.uliBytesTotal.QuadPart);

                    if (progInfo.ppd->HasUserCancelled())
                        break;   // Cancel the copy.
                }
            }

            DestroyYesNoList(&ynl);

            if (SUCCEEDED(hrOffset))
                ReleaseStgMediumHGLOBAL(NULL, &mediumOffset);

            ResetWaitCursor();
            ReleaseStgMediumHGLOBAL(pfgd, &mediumFGD);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Inform the caller of what we did.  We don't do optimized moves
        // so the caller is responsible for the delete half of the move and
        // this is now we notify them of that.
        DataObj_SetDWORD(pdo, g_cfPerformedDropEffect, _dwEffect);
        DataObj_SetDWORD(pdo, g_cfLogicalPerformedDropEffect, _dwEffect);
    }

    if (progInfo.ppd)
    {
        progInfo.ppd->StopProgressDialog();
        progInfo.ppd->Release();
    }

    return hr;
}


//===========================
// *** IUnknown Interface ***
HRESULT CCopyThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CCopyThread, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CCopyThread::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCopyThread::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct)
{
    *ppct = new CCopyThread(hwnd, pszPath, pdtobj, pdwEffect, fIsBkDropTarget);
    return (*ppct ? S_OK : E_FAIL);
}

HRESULT CFSFolder_CreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget)
{
    CCopyThread * pct;
    HRESULT hr = CreateInstance_CopyThread(hwnd, pszPath, pdtobj, pdwEffect, fIsBkDropTarget, &pct);
    if (SUCCEEDED(hr))
    {
        hr = pct->DoCopy();
        pct->Release();
    }

    return hr;
}

/*****************************************************************************\
        We know that the IDataObject (pdo) supports the CF_FILEGROUPDESCRIPTOR
    clipboard format, so copy that data to the file system directory pszPath.
    The caller will want to know if this completed or if it was cancelled or
    errored out.  This result will come in the DROPEFFECT out param (pdwEffect).
    Zero (0) will indicate either error or cancel and this code will take care
    of displaying error messages.
\*****************************************************************************/
HRESULT CFSFolder_AsyncCreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdo, 
                                          POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget)
{
    CCopyThread * pct;
    HRESULT hr = CreateInstance_CopyThread(hwnd, pszPath, pdo, pdwEffect, fIsBkDropTarget, &pct);
    if (SUCCEEDED(hr))
    {
        if (DataObj_CanGoAsync(pdo))
            hr = pct->DoAsynchCopy();
        else
            hr = pct->DoCopy();

        pct->Release();
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\control1.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "control.h"

#ifdef WX86

#include <wx86dll.h>

LONG g_cRefWx86;
HMODULE g_hmodWx86;

WX86LOADX86DLL_ROUTINE g_pfnWx86LoadX86Dll;
WX86FREEX86Dll_ROUTINE g_pfnWx86FreeX86Dll;
WX86THUNKPROC_ROUTINE g_pfnWx86ThunkProc;
WX86COMPACT_ROUTINE g_pfnWx86Compact;

#define Wx86LoadX86Dll(libname) (*g_pfnWx86LoadX86Dll)(libname, 0)
#define Wx86FreeX86Dll(hmod) (*g_pfnWx86FreeX86Dll)(hmod)
#define Wx86ThunkProc(pvAddress, pvCBDispatch, fNativeToX86) (*g_pfnWx86ThunkProc)(pvAddress, pvCBDispatch, fNativeToX86)
#define Wx86Compact() (*g_pfnWx86Compact)()

/*++
    This routine will increment Shell32's usage count of Wx86. When the use
    count transitions from 0 to 1 then Wx86 is loaded. The companion function
    Wx86Disable will decrement Shell32's usage count of Wx86 and unload Wx86
    when the count transitions from 1 to 0.

    If we have trouble loading wx86 then we will decide that wx86 is not
    installed and never try again.
--*/
BOOL Wx86Enable(void)
{
    ENTERCRITICAL;
    if (++g_cRefWx86 == 1)
    {
        g_hmodWx86 = LoadLibrary(TEXT("wx86.dll"));
        if (g_hmodWx86)
        {
            g_pfnWx86LoadX86Dll = (void *)GetProcAddress(g_hmodWx86, "Wx86LoadX86Dll");
            g_pfnWx86FreeX86Dll = (void *)GetProcAddress(g_hmodWx86, "Wx86FreeX86Dll");
            g_pfnWx86ThunkProc = (void *)GetProcAddress(g_hmodWx86, "Wx86ThunkProc");
            g_pfnWx86Compact  = (void *)GetProcAddress(g_hmodWx86, "Wx86Compact");


            if (!g_pfnWx86LoadX86Dll || !g_pfnWx86FreeX86Dll ||
                !g_pfnWx86ThunkProc || !g_pfnWx86Compact)
            {
                FreeLibrary(g_hmodWx86);
                g_hmodWx86 = NULL;
            }
        }
    }

    LEAVECRITICAL;
    
    return g_hmodWx86 != NULL;
}


void Wx86Disable(void)
{
    ENTERCRITICAL;

    if (--g_cRefWx86 == 0)
    {    
        FreeLibrary(g_hmodWx86);
        g_hmodWx86 = NULL;
        g_pfnWx86LoadX86Dll = NULL;
        g_pfnWx86FreeX86Dll = NULL;
        g_pfnWx86ThunkProc = NULL;
        g_pfnWx86Compact = NULL;
    }

    LEAVECRITICAL;
}

#endif // WX86


HDSA g_hacplmLoaded = NULL;

void ConvertCplInfo(void * lpv)
{
#ifdef UNICODE
   NEWCPLINFOA   CplInfoA;
   LPNEWCPLINFOW lpCplInfoW = (LPNEWCPLINFOW)lpv;

   memcpy(&CplInfoA, lpv, sizeof(NEWCPLINFOA));

   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szName, ARRAYSIZE(CplInfoA.szName),
                        lpCplInfoW->szName, ARRAYSIZE(lpCplInfoW->szName));
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szInfo, ARRAYSIZE(CplInfoA.szInfo),
                        lpCplInfoW->szInfo, ARRAYSIZE(lpCplInfoW->szInfo));
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szHelpFile, ARRAYSIZE(CplInfoA.szHelpFile),
                        lpCplInfoW->szHelpFile, ARRAYSIZE(lpCplInfoW->szHelpFile));
   lpCplInfoW->dwSize = sizeof(NEWCPLINFOW);
#else
   NEWCPLINFOW   CplInfoW;
   LPNEWCPLINFOA lpCplInfoA = (LPNEWCPLINFOA)lpv;

   memcpy(&CplInfoW, lpv, sizeof(NEWCPLINFOW));

   WideCharToMultiByte(CP_ACP, 0,
                        CplInfoW.szName, ARRAYSIZE(CplInfoW.szName),
                        lpCplInfoA->szName, ARRAYSIZE(lpCplInfoA->szName),
                        NULL, NULL);

   WideCharToMultiByte(CP_ACP, 0,
                        CplInfoW.szInfo, ARRAYSIZE(CplInfoW.szInfo),
                        lpCplInfoA->szInfo, ARRAYSIZE(lpCplInfoA->szInfo),
                        NULL, NULL);

   WideCharToMultiByte(CP_ACP, 0,
                        CplInfoW.szHelpFile, ARRAYSIZE(CplInfoW.szHelpFile),
                        lpCplInfoA->szHelpFile, ARRAYSIZE(lpCplInfoA->szHelpFile),
                        NULL, NULL);
   lpCplInfoA->dwSize = sizeof(NEWCPLINFOA);

#endif
}

//  See if pszShort is a truncated version of the string referred to by
//  hinst/id.  If so, then use the long string.  This is to work around
//  a "bad design feature" of CPL_NEWINQUIRE where the app returns a buffer
//  (which is only 32 or 64 chars long) rather than a resource id
//  like CPL_INQUIRE.  So if the app responds to both messages, and the
//  NEWINQUIRE string is a truncated version of the INQUIRE string, then
//  switch to the INQUIRE string.

LPTSTR _RestoreTruncatedCplString(
        HINSTANCE hinst,
        int id,
        LPTSTR pszShort,
        LPTSTR pszBuf,
        int cchBufMax)
{
    int cchLenShort, cchLen;

    cchLenShort = lstrlen(pszShort);
    cchLen = LoadString(hinst, id, pszBuf, cchBufMax);

    // Don't use SHTruncateString since KERNEL32 doesn't either
    if (StrCmpNC(pszShort, pszBuf, cchLenShort) == 0) 
    {
        pszShort = pszBuf;
    }
    return pszShort;
}

//
//  Initializes *pcpli.
//
// Requires:
//  *pcpli is filled with 0 & NULL's.
//
BOOL _InitializeControl(LPCPLMODULE pcplm, LPCPLITEM pcpli)
{
    BOOL fSucceed = TRUE;
    union {
        NEWCPLINFO  Native;
        NEWCPLINFOA NewCplInfoA;
        NEWCPLINFOW NewCplInfoW;
    } Newcpl;
    CPLINFO cpl;
    TCHAR szName[MAX_CCH_CPLNAME];
    TCHAR szInfo[MAX_CCH_CPLINFO];
    LPTSTR pszName = Newcpl.Native.szName, pszInfo = Newcpl.Native.szInfo;
    HICON hIconTemp = NULL;

    //
    // always do the old method to get the icon ID
    //
    cpl.idIcon = 0;

    CPL_CallEntry(pcplm, NULL, CPL_INQUIRE, (LONG)pcpli->idControl, (LONG_PTR)(LPCPLINFO)&cpl);

    //
    // if this is a 32bit CPL and it gave us an ID then validate it
    // this fixes ODBC32 which gives back a bogus ID but a correct HICON
    // note that the next load of the same icon should be very fast
    //
    if (cpl.idIcon)
    {
        hIconTemp = LoadImage(pcplm->minst.hinst, MAKEINTRESOURCE(cpl.idIcon),
            IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

        if (!hIconTemp)
        {
            // the id was bogus, make it a negative number (invalid resource)...
            cpl.idIcon = -1;
            TraceMsg(TF_GENERAL, "_InitializaControl: %s returned an invalid icon id, ignoring", pcplm->szModule);
        }
    }

    pcpli->idIcon = cpl.idIcon;

    //
    //  Try the new method first and call it with the largest structure
    //  so it doesn't overwrite anything on the stack.  If you put a
    //  Unicode applet on Windows '95 it will kill the Explorer because
    //  it trashes memory by overwriting the stack.
    //
    memset(&Newcpl,0,sizeof(Newcpl));

    CPL_CallEntry(pcplm, NULL, CPL_NEWINQUIRE, (LONG)pcpli->idControl,
                    (LONG_PTR)(LPCPLINFO)&Newcpl);

    //
    //  If the call is to an ANSI applet, convert strings to Unicode
    //
#ifdef UNICODE
#define UNNATIVE_SIZE   sizeof(NEWCPLINFOA)
#else
#define UNNATIVE_SIZE   sizeof(NEWCPLINFOW)
#endif

    if (Newcpl.Native.dwSize == UNNATIVE_SIZE)
    {
        ConvertCplInfo(&Newcpl);        // This will set Newcpl.Native.dwSize
    }

    if (Newcpl.Native.dwSize == sizeof(NEWCPLINFO))
    {
       pszName = _RestoreTruncatedCplString(pcplm->minst.hinst, cpl.idName, pszName, szName, ARRAYSIZE(szName));
       pszInfo = _RestoreTruncatedCplString(pcplm->minst.hinst, cpl.idInfo, pszInfo, szInfo, ARRAYSIZE(szInfo));
    }
    else
    {
        Newcpl.Native.hIcon = LoadImage(pcplm->minst.hinst, MAKEINTRESOURCE(cpl.idIcon), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
        pszName = szName;
        LoadString(pcplm->minst.hinst, cpl.idName, szName, ARRAYSIZE(szName));
        pszInfo = szInfo;
        LoadString(pcplm->minst.hinst, cpl.idInfo, szInfo, ARRAYSIZE(szInfo));
        Newcpl.Native.szHelpFile[0] = 0;
        Newcpl.Native.lData = cpl.lData;
        Newcpl.Native.dwHelpContext = 0;
    }

    pcpli->hIcon = Newcpl.Native.hIcon;

    if (hIconTemp)
        DestroyIcon(hIconTemp);

    fSucceed = Str_SetPtr(&pcpli->pszName, pszName)
            && Str_SetPtr(&pcpli->pszInfo, pszInfo)
            && Str_SetPtr(&pcpli->pszHelpFile, Newcpl.Native.szHelpFile);

    pcpli->lData = Newcpl.Native.lData;
    pcpli->dwContext = Newcpl.Native.dwHelpContext;

#ifdef DEBUG
    if (!pcpli->idIcon)
        TraceMsg(TF_GENERAL, "PERFORMANCE: cannot cache %s because no icon ID for <%s>", pcplm->szModule, pcpli->pszName);
#endif

    return fSucceed;
}


//
// Terminate the control
//
void _TerminateControl(LPCPLMODULE pcplm, LPCPLITEM pcpli)
{
    if (pcpli->hIcon)
    {
        DestroyIcon(pcpli->hIcon);
        pcpli->hIcon = NULL;
    }

    Str_SetPtr(&pcpli->pszName, NULL);
    Str_SetPtr(&pcpli->pszInfo, NULL);
    Str_SetPtr(&pcpli->pszHelpFile, NULL);
    CPL_CallEntry(pcplm, NULL, CPL_STOP, pcpli->idControl, pcpli->lData);
}


void _FreeLibraryForControlPanel(MINST *pminst)
{
#ifdef WX86
    if (pminst->fIsX86Dll)
    {
        Wx86FreeX86Dll(pminst->hinst);
        Wx86Disable();
    } 
    else 
    {
        FreeLibrary(pminst->hinst);
    }
#else
    FreeLibrary(pminst->hinst);
#endif
}

//
//  For each control of the specified CPL module, call the control entry
//  with CPL_STOP. Then, call it with CPL_EXIT.
//
void _TerminateCPLModule(LPCPLMODULE pcplm)
{
    if (pcplm->minst.hinst)
    {
        ULONG_PTR dwCookie = 0;
        //DebugMsg(DM_TRACE,"** Terminating CPL %s", pcplm->szModule);

        if (pcplm->lpfnCPL)
        {
            if (pcplm->hacpli)
            {
                int cControls, i;

                for (i = 0, cControls = DSA_GetItemCount(pcplm->hacpli); i < cControls; ++i)
                {
                    LPCPLITEM pcpli = DSA_GetItemPtr(pcplm->hacpli, i);
                    _TerminateControl(pcplm, pcpli);
                }

                DSA_DeleteAllItems(pcplm->hacpli);
                DSA_Destroy(pcplm->hacpli);
                pcplm->hacpli=NULL;
            }

            CPL_CallEntry(pcplm, NULL, CPL_EXIT, 0, 0);
            pcplm->lpfnCPL=NULL;
        }

        ActivateActCtx(pcplm->hActCtx, &dwCookie);
        _FreeLibraryForControlPanel(&pcplm->minst);
        if (dwCookie != 0)
            DeactivateActCtx(0, dwCookie);

        pcplm->minst.hinst = NULL;
    }

    pcplm->minst.idOwner = (DWORD)-1;

    if (pcplm->hActCtx != NULL)
    {
        ReleaseActCtx(pcplm->hActCtx);
        pcplm->hActCtx = NULL;
    }

    if (pcplm->minst.hOwner)
    {
        CloseHandle(pcplm->minst.hOwner);
        pcplm->minst.hOwner = NULL;
    }
}


//
// Initializes the CPL Module.
//
// Requires:
//  *pcplm should be initialized appropriately.
//
//
BOOL _InitializeCPLModule(LPCPLMODULE pcplm)
{
    BOOL fSuccess = FALSE;

    pcplm->lpfnCPL32 = (APPLET_PROC)GetProcAddress(pcplm->minst.hinst, "CPlApplet");
#ifdef WX86
    if (pcplm->minst.fIsX86Dll)
    {
        pcplm->lpfnCPL32 = (APPLET_PROC)Wx86ThunkProc(pcplm->lpfnCPL32, (void *)4, TRUE);
        if (pcplm->lpfnCPL32 == (APPLET_PROC)-1)
        {
            pcplm->lpfnCPL32 = NULL;
        }
    }
#endif

    //
    // Initialize the CPL
    if (pcplm->lpfnCPL &&
        CPL_CallEntry(pcplm, NULL, CPL_INIT, 0, 0))
    {
        int cControls = (int)CPL_CallEntry(pcplm, NULL, CPL_GETCOUNT, 0, 0);

        if (cControls>0)
        {
            //
            // By passing in the number of applets, we should speed up allocation
            // of this array.
            //

            pcplm->hacpli = DSA_Create(sizeof(CPLITEM), cControls);

            if (pcplm->hacpli)
            {
                int i;

                fSuccess = TRUE; // succeded, so far.

                // Go through the applets and load the information about them

                for (i = 0; i < cControls; ++i)
                {
                    CPLITEM control = {i, 0};

                    if (_InitializeControl(pcplm, &control))
                    {
                        // removing this now saves us from doing it later

                        CPL_StripAmpersand(control.pszName);

                        if (DSA_AppendItem(pcplm->hacpli, &control) >= 0)
                        {
                            continue;
                        }
                    }

                    _TerminateControl(pcplm, &control);
                    fSuccess=FALSE;
                    break;
                }
            }
        }
    }
    else
    {
        // don't ever call it again if we couldn't CPL_INIT
        pcplm->lpfnCPL = NULL;
    }

    return fSuccess;
}


//
// Returns:
//   The index to the g_hacplmLoaded, if the specified DLL is already
//  loaded; -1 otherwise.
//
int _FindCPLModule(const MINST * pminst)
{
    int i = -1; // Assumes error

    ENTERCRITICAL;
    if (g_hacplmLoaded)
    {
        for (i=DSA_GetItemCount(g_hacplmLoaded)-1; i>=0; --i)
        {
            LPCPLMODULE pcplm = DSA_GetItemPtr(g_hacplmLoaded, i);

            //
            // owner id tested last since hinst is more varied
            //

            if ((pcplm->minst.hinst == pminst->hinst) &&
                (pcplm->minst.idOwner == pminst->idOwner))
            {
                break;
            }
        }
    }
    LEAVECRITICAL;
    return i;
}

LPCPLMODULE FindCPLModule(const MINST * pminst)
{
    return (LPCPLMODULE) DSA_GetItemPtr(g_hacplmLoaded, _FindCPLModule(pminst));
}


//
// Returns:
//   The index to the g_hacplmLoaded, if the specified DLL is already
//  loaded; -1 otherwise.
//
int _FindCPLModuleByName(LPCTSTR pszModule)
{
    int i = -1; // Assumes error

    ENTERCRITICAL;
    if (g_hacplmLoaded)
    {
        for (i=DSA_GetItemCount(g_hacplmLoaded)-1; i>=0; --i)
        {
            LPCPLMODULE pcplm = DSA_GetItemPtr(g_hacplmLoaded, i);

            if (!lstrcmpi(pcplm->szModule, pszModule))
            {
                break;
            }
        }
    }
    LEAVECRITICAL;
    return i;
}

//
// Adds the specified CPL module to g_hacplmLoaded.
//
// Requires:
//  The specified CPL module is not in g_hacplmLoaded yet.
//
// Returns:
//  The index to the CPL module if succeeded; -1 otherwise.
//
int _AddModule(LPCPLMODULE pcplm)
{
    int     result;

    //
    // Create the Loaded Modules guy if necessary
    //
    ENTERCRITICAL;
    if (g_hacplmLoaded == NULL)
        g_hacplmLoaded = DSA_Create(sizeof(CPLMODULE), 4);
    //
    // Add this CPL to our list
    //
    if (g_hacplmLoaded == NULL)
        result = -1;
    else
        result = DSA_AppendItem(g_hacplmLoaded, pcplm);
    LEAVECRITICAL;
    return(result);
}


#define SZ_RUNDLL32_NOEXCEPT_ARGS       TEXT("/d ")
BOOL CatchCPLExceptions(UINT msg)
{
    LPCTSTR pszCmdLine = GetCommandLine();
    BOOL fCatch = TRUE;

    // Some callers don't want to run and have exceptions caught.
    // This will allow crashes to be uploaded to PCHealth.
    if (((CPL_STARTWPARMSA == msg) || (CPL_STARTWPARMS == msg) || (CPL_DBLCLK == msg)) &&
        StrCmpNI(pszCmdLine, SZ_RUNDLL32_NOEXCEPT_ARGS, (ARRAYSIZE(SZ_RUNDLL32_NOEXCEPT_ARGS) - 1)))
    {
        fCatch = FALSE;
    }

    return fCatch;
}


LRESULT CPL_CallEntry(LPCPLMODULE pcplm, HWND hwnd, UINT msg, LPARAM lParam1, LPARAM lParam2)
{
    LRESULT lres;
    ULONG_PTR dwCookie = 0;

    ActivateActCtx(pcplm->hActCtx, &dwCookie);

    if (!CatchCPLExceptions(msg))
    {
        lres = pcplm->lpfnCPL32(hwnd, msg, lParam1, lParam2);
    }
    else
    {
        _try
        {
            lres = pcplm->lpfnCPL32(hwnd, msg, lParam1, lParam2);
#ifdef WX86
            if (pcplm->minst.fIsX86Dll)
            {
                Wx86Compact();
            }
#endif
        }
        _except(SetErrorMode(SEM_NOGPFAULTERRORBOX),UnhandledExceptionFilter(GetExceptionInformation()))
        {
            TraceMsg(TF_ERROR, "CPL: Exception calling CPL module: %s", pcplm->szModule);
            ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_CPL_EXCEPTION),
                    MAKEINTRESOURCE(IDS_CONTROLPANEL),
                    MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL,
                    (LPTSTR)pcplm->szModule);
            lres = 0;
        }
    }

    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);

    return lres;
}

//
// Loads the specified CPL module and returns the index to g_hacplmLoaded.
//
int _LoadCPLModule(LPCTSTR pszModule)
{
    TCHAR szManifest[MAX_PATH];
    HANDLE hActCtx = NULL;
    MINST minst;
    int iModule;
    ULONG_PTR dwCookie;
    ACTCTX act = {0};

    minst.idOwner = GetCurrentProcessId();
    minst.hOwner = OpenProcess(SYNCHRONIZE,FALSE,minst.idOwner);

    // See if this application has a context
    StrCpyN(szManifest, pszModule, ARRAYSIZE(szManifest));
    StrCat(szManifest, TEXT(".manifest"));
    if (PathFileExists(szManifest))
    {
        act.cbSize = sizeof(act);
        act.dwFlags = 0;
        act.lpSource = szManifest;
        hActCtx = CreateActCtx(&act);
    }
    else
    {
        act.cbSize = sizeof(act);
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpSource = pszModule;
        act.lpResourceName = MAKEINTRESOURCE(123);

        hActCtx = CreateActCtx(&act);
    }

    if (hActCtx == INVALID_HANDLE_VALUE)
        hActCtx = NULL;

    ActivateActCtx(hActCtx, &dwCookie);

    minst.hinst = LoadLibrary(pszModule);

    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);


#ifdef WX86
    minst.fIsX86Dll = FALSE;
    if ((minst.hinst == NULL) &&
        (GetLastError() == ERROR_BAD_EXE_FORMAT) &&
        (Wx86Enable()))
    {
        // If we got a DLL type mismatch loading the dll then it
        // may be an x86 dll. Lets try to load it as an x86 dll.
        minst.hinst = (HINSTANCE)Wx86LoadX86Dll(pszModule);
        minst.fIsX86Dll = TRUE;             
    }
#endif
    if (!ISVALIDHINSTANCE(minst.hinst))
    {
        CloseHandle(minst.hOwner);
#ifdef WX86
        if (minst.fIsX86Dll)
        {
            Wx86Disable();
        }
#endif
        return -1;
    }

    //
    // Check if this module is already in the list.
    //

    iModule = _FindCPLModule(&minst);

    if (iModule >= 0)
    {
        //
        // Yes. Increment the reference count and return the ID.
        //
        LPCPLMODULE pcplm;

        ENTERCRITICAL;
        pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        ++pcplm->cRef;
        LEAVECRITICAL;

        ActivateActCtx(hActCtx, &dwCookie);
        //
        // Decrement KERNELs reference count
        //
        _FreeLibraryForControlPanel(&minst);
        if (dwCookie != 0)
            DeactivateActCtx(0, dwCookie);

        if (hActCtx != NULL)
            ReleaseActCtx(hActCtx);

        CloseHandle(minst.hOwner);
    }
    else
    {
        CPLMODULE sModule = {0};
        

        //
        // No. Append it.
        //

        sModule.cRef = 1;
        sModule.minst = minst;
        sModule.hActCtx = hActCtx;

        GetModuleFileName(minst.hinst, sModule.szModule, ARRAYSIZE(sModule.szModule));

        if (_InitializeCPLModule(&sModule))
        {
            iModule = _AddModule(&sModule);
        }

        if (iModule < 0)
        {
            _TerminateCPLModule(&sModule);
        }
    }
    return iModule;
}


int _FreeCPLModuleIndex(int iModule)
{
    LPCPLMODULE pcplm;

    ENTERCRITICAL;
    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);

    if (!pcplm)
    {
        LEAVECRITICAL;
        return(-1);
    }

    //
    // Dec the ref count; return if not 0
    //

    --pcplm->cRef;

    if (pcplm->cRef)
    {
        LEAVECRITICAL;
        return(pcplm->cRef);
    }

    //
    // Free up the whole thing and return 0
    //

    _TerminateCPLModule(pcplm);

    DSA_DeleteItem(g_hacplmLoaded, iModule);

    //
    // Destroy this when all CPLs have been removed
    //

    if (DSA_GetItemCount(g_hacplmLoaded) == 0)
    {
        DSA_Destroy(g_hacplmLoaded);
        g_hacplmLoaded = NULL;
    }
    LEAVECRITICAL;
    return(0);
}


int _FreeCPLModuleHandle(const MINST * pminst)
{
    int iModule;

    //
    // Check if the module is actually loaded (major error if not)
    //

    iModule = _FindCPLModule(pminst);

    if (iModule < 0)
    {
        return(-1);
    }

    return _FreeCPLModuleIndex(iModule);
}

int CPL_FreeCPLModule(LPCPLMODULE pcplm)
{
    return _FreeCPLModuleHandle(&pcplm->minst);
}


void CPL_StripAmpersand(LPTSTR szBuffer)
{
    LPTSTR pIn, pOut;

    //
    // copy the name sans '&' chars
    //

    pIn = pOut = szBuffer;
    do
    {
        //
        // strip FE accelerators with parentheses.  e.g. "foo(&F)" -> "foo"
        //
        if (*pIn == TEXT('(') && *(pIn+1) == TEXT('&') &&
            *(pIn+2) && *(pIn+3) == TEXT(')')) {
            pIn += 4;
        }

#ifdef DBCS
        // Also strip FE accelerators in old win31 cpl, i.e, 01EH/01FH.
        if (*pIn == 0x1e && *++pIn) {


            // Assumes a character right before the mnemonic
            // is a parenthesis or something to be removed as well.
            //
            pOut=CharPrev(szBuffer, pOut);

            // Skip Alphabet accelerator.
            pIn = CharNext(pIn);

            if (*pIn) {
                if (*pIn == 0x1f && *++pIn) {

                    // Skip FE accelelator
                    //
                    pIn = CharNext(pIn);
                }
                // Skip second parenthesis.
                //
                pIn = CharNext(pIn);
            }
        }
#endif
        if (*pIn != TEXT('&')) {
            *pOut++ = *pIn;
        }
        if (IsDBCSLeadByte(*pIn)) {
            *pOut++ = *++pIn;
        }
    } while (*pIn++) ;
}


//
// filter out bogus old ini keys... we may be able to blow this off
BOOL IsValidCplKey(LPCTSTR pszKey)
{
    return lstrcmpi(pszKey, TEXT("NumApps")) &&
        !((*(pszKey+1) == 0) &&
        ((*pszKey == TEXT('X')) || (*pszKey == TEXT('Y')) || (*pszKey == TEXT('W')) || (*pszKey == TEXT('H'))));
}


LPCPLMODULE CPL_LoadCPLModule(LPCTSTR szModule)
{
    LPCPLMODULE result;

    int iModule = _LoadCPLModule(szModule);

    if (iModule < 0)
        result = NULL;
    else
    {
        ENTERCRITICAL;
        result = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        LEAVECRITICAL;
    }
    return result;
}

BOOL DontLoadCPL(LPCTSTR pszName)
{
    // the first reg location is the old alias for control.ini [don't load] 
    // entries that map into the registry on NT. the next is for per 
    // machine support to hide cpls, new for whistler
    return (SHGetValue(HKEY_CURRENT_USER,  TEXT("Control Panel\\don't load"), pszName, NULL, NULL, NULL) == ERROR_SUCCESS) ||
           (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\don't load"), pszName, NULL, NULL, NULL) == ERROR_SUCCESS);
}

// Called for each CPL module file which we may want to load
void _InsertModuleName(ControlData *lpData, LPCTSTR szPath, PMODULEINFO pmi)
{
    pmi->pszModule = NULL;
    Str_SetPtr(&pmi->pszModule, szPath);

    if (pmi->pszModule)
    {
        int i;

        pmi->pszModuleName = PathFindFileName(pmi->pszModule);

        if (DontLoadCPL(pmi->pszModuleName))
        {
            Str_SetPtr(&pmi->pszModule, NULL);
            goto skip;
        }

        // don't insert the module if it's already in the list!

        for (i = DSA_GetItemCount(lpData->hamiModule)-1 ; i >= 0 ; i--)
        {
            PMODULEINFO pmi1 = DSA_GetItemPtr(lpData->hamiModule, i);

            if (!lstrcmpi(pmi1->pszModuleName, pmi->pszModuleName))
            {
                Str_SetPtr(&pmi->pszModule, NULL);
                goto skip;
            }
        }

        DSA_AppendItem(lpData->hamiModule, pmi);
skip:
        ;
    }
}

#define GETMODULE(haminst,i)     ((MINST *)DSA_GetItemPtr(haminst, i))
#define ADDMODULE(haminst,pminst) DSA_AppendItem(haminst, (void *)pminst)

int _LoadCPLModuleAndAdd(ControlData *lpData, LPCTSTR szModule)
{
    int iModule, i;
    LPCPLMODULE pcplm;

    //
    // Load the module and controls (or get the previous one if already
    // loaded).
    //

    iModule = _LoadCPLModule(szModule);

    if (iModule < 0)
    {
        TraceMsg(TF_WARNING, "_LoadCPLModuleAndAdd: _LoadControls refused %s", szModule);
        return -1;
    }

    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);

    if (pcplm == NULL)
    {
        TraceMsg(TF_WARNING, "_LoadCPLModuleAndAdd: DSA returned NULL structure");
        return -1;
    }

    //
    // Check if this guy has already loaded this module
    //

    for (i = DSA_GetItemCount(lpData->haminst) - 1; i >= 0; --i)
    {
        const MINST * pminst = GETMODULE(lpData->haminst,i);

        //
        // note: owner id tested last since hinst is more varied
        //

        if ((pminst->hinst == pcplm->minst.hinst) &&
            (pminst->idOwner == pcplm->minst.idOwner))
        {
FreeThisModule:

            //
            // This guy already loaded this module, so dec
            // the reference and return failure
            //

            _FreeCPLModuleIndex(iModule);
            return(-1);
        }
    }

    //
    // this is a new module, so add it to the list
    //

    if (ADDMODULE(lpData->haminst, &pcplm->minst) < 0)
    {
        goto FreeThisModule;
    }

    return iModule;
}


void _AddItemsFromKey(ControlData *pcd, HKEY hkRoot)
{
    HKEY hkey;
    MODULEINFO mi = {0};

    mi.flags = MI_FIND_FILE;
    
    if (ERROR_SUCCESS == RegOpenKey(hkRoot, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs"), &hkey))
    {    
        TCHAR szData[MAX_PATH], szValue[128];
        DWORD dwSizeData, dwValue, dwIndex;

        for (dwIndex = 0; 
            ERROR_SUCCESS == (dwValue = ARRAYSIZE(szValue), dwSizeData = sizeof(szData),
                RegEnumValue(hkey, dwIndex, szValue, &dwValue, NULL, NULL, (BYTE *)szData, &dwSizeData));
            dwIndex++)
        {
            TCHAR szPath[MAX_PATH];
            if (SHExpandEnvironmentStrings(szData, szPath, ARRAYSIZE(szPath)))
            {
                WIN32_FIND_DATA fd;
                HANDLE hfind = FindFirstFile(szPath, &fd);
                if (hfind != INVALID_HANDLE_VALUE)
                {
                    mi.ftCreationTime = fd.ftCreationTime;
                    mi.nFileSizeHigh = fd.nFileSizeHigh;
                    mi.nFileSizeLow = fd.nFileSizeLow;
                    FindClose(hfind);

                    _InsertModuleName(pcd, szPath, &mi);
                }
            }
        }
        RegCloseKey(hkey);
    }
}


/* Get the keynames under [MMCPL] in CONTROL.INI and cycle
   through all such keys to load their applets into our
   list box.  Also allocate the array of CPLMODULE structs.
   Returns early if can't load old WIN3 applets.
*/
BOOL CPLD_GetModules(ControlData *lpData)
{
    LPTSTR       pStr;
    HANDLE   hFindFile;
    WIN32_FIND_DATA findData;
    MODULEINFO mi;
    TCHAR szPath[MAX_PATH], szSysDir[MAX_PATH], szName[MAX_PATH];

    ASSERT(lpData->hamiModule == NULL);

    lpData->hamiModule = DSA_Create(sizeof(mi), 4);

    if (!lpData->hamiModule)
    {
        return FALSE;
    }

    lpData->haminst = DSA_Create(sizeof(MINST), 4);

    if (!lpData->haminst)
    {
        DSA_Destroy(lpData->hamiModule);
        lpData->hamiModule = NULL; // no one is freeing hamiModule in the caller if this fails, but just to make sure ...
        return FALSE;
    }

    //
    // So here's the deal:
    // We have this global list of all modules that have been loaded, along
    // with a reference count for each.  This is so that we don't need to
    // load a CPL file again when the user double clicks on it.
    // We still need to keep a list for each window that is open, so that
    // we will not load the same CPL twice in a single window.  Therefore,
    // we need to keep a list of all modules that are loaded (note that
    // we cannot just keep indexes, since the global list can move around).
    //
    // hamiModule contains the module name, the instance info if loaded,
    // and some other information for comparing with cached information
    //

    ZeroMemory(&mi, sizeof(mi));

    //
    // don't special case main, instead sort the data by title
    //

    GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir));

    // load the modules specified in CONTROL.INI under [MMCPL]
    {
        TCHAR szKeys[512];    // from section of extra cpls to load
        GetPrivateProfileString(TEXT("MMCPL"), NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), TEXT("control.ini"));

        for (pStr = szKeys; *pStr; pStr += lstrlen(pStr) + 1)
        {
            GetPrivateProfileString(TEXT("MMCPL"), pStr, c_szNULL, szName, ARRAYSIZE(szName), TEXT("control.ini"));
            if (IsValidCplKey(pStr))
            {
                _InsertModuleName(lpData, szName, &mi);
            }
        }
    }

    // load applets from the system directory

    PathCombine(szPath, szSysDir, TEXT("*.CPL"));

    mi.flags |= MI_FIND_FILE;

    hFindFile = FindFirstFile(szPath, &findData);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                BOOL fOkToUse = TRUE;

                if (IsOS(OS_WOW6432))
                {
                    GetWindowsDirectory(szPath,ARRAYSIZE(szPath));
                    PathCombine(szPath, szPath, TEXT("system32"));

                    //
                    // Don't use any CPLs which exist in the real system32
                    // directory, since we only have them in the fake system
                    // directory for compatibility reasons.
                    //
                    PathCombine(szPath, szPath, findData.cFileName);
                    if (PathFileExists(szPath))
                    {
                        fOkToUse = FALSE;
                    }
                }

                if (fOkToUse)
                {
                    PathCombine(szPath, szSysDir, findData.cFileName);

                    mi.ftCreationTime = findData.ftCreationTime;
                    mi.nFileSizeHigh = findData.nFileSizeHigh;
                    mi.nFileSizeLow = findData.nFileSizeLow;

                    _InsertModuleName(lpData, szPath, &mi);
                }
            }
        } while (FindNextFile(hFindFile, &findData));

        FindClose(hFindFile);
    }

    _AddItemsFromKey(lpData, HKEY_CURRENT_USER);
    _AddItemsFromKey(lpData, HKEY_LOCAL_MACHINE);

#ifdef WX86
    // For Wx86 we need to also search the wx86 system directory for any
    // x86 CPL files

    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = TRUE;
    GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir));
    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;

    PathCombine(szPath, szSysDir, TEXT("*.CPL"));

    mi.flags |= MI_FIND_FILE;

    hFindFile = FindFirstFile(szPath, &findData);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                PathCombine(szPath, szSysDir, findData.cFileName);

                mi.ftCreationTime = findData.ftCreationTime;
                mi.nFileSizeHigh = findData.nFileSizeHigh;
                mi.nFileSizeLow = findData.nFileSizeLow;

                _InsertModuleName(lpData, szPath, &mi);
            }
        } while (FindNextFile(hFindFile, &findData));

        FindClose(hFindFile);
    }
#endif

    lpData->cModules = DPA_GetPtrCount(lpData->hamiModule);

    return TRUE;
}

//  Read the registry for cached CPL info.
//  If this info is up-to-date with current modules (from CPLD_GetModules),
//  then we can enumerate these without loading the CPLs.

void CPLD_GetRegModules(ControlData *lpData)
{
    HKEY hkey;
    LPCTSTR lpszRegKey;

    // dont cache any-thing in clean boot.
    if (GetSystemMetrics(SM_CLEANBOOT))
        return;

    if (IsOS(OS_WOW6432))
    {
        lpszRegKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder (Wow64)");
    }
    else
    {
        lpszRegKey = REGSTR_PATH_CONTROLSFOLDER;
    }

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, lpszRegKey, &hkey))
    {
        DWORD cbSize;
        DWORD dwLCID = 0;
        cbSize = sizeof(dwLCID);

        // fail if this cache is not tagged with the UI language ID, or we are not in
        // the language ID that the cache was saved in.
        if (ERROR_SUCCESS != SHQueryValueEx(hkey, TEXT("Presentation LCID"),
                NULL, NULL, (LPBYTE) &dwLCID, &cbSize) || dwLCID != GetUserDefaultUILanguage())
        {
            RegCloseKey(hkey);
            return;
        }
        if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("Presentation Cache"),
                NULL, NULL, NULL, &cbSize))
        {
            lpData->pRegCPLBuffer = LocalAlloc(LPTR, cbSize);

            if (lpData->pRegCPLBuffer)
            {
                if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("Presentation Cache"),
                        NULL, NULL, lpData->pRegCPLBuffer, &cbSize))
                {
                    lpData->hRegCPLs = DPA_Create(4);

                    if (lpData->hRegCPLs)
                    {
                        REG_CPL_INFO * p;
                        DWORD cbOffset;

                        for (cbOffset = 0          ;
                              cbOffset < cbSize     ;
                              cbOffset += p->cbSize)
                        {
                            p = (REG_CPL_INFO *)&(lpData->pRegCPLBuffer[cbOffset]);
                            p->flags |= REGCPL_FROMREG;
                            DPA_AppendPtr(lpData->hRegCPLs, p);

                            //DebugMsg(DM_TRACE,"sh CPLD_GetRegModules: %s (%s)", REGCPL_FILENAME(p), REGCPL_CPLNAME(p));
                        }

                        lpData->cRegCPLs = DPA_GetPtrCount(lpData->hRegCPLs);
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "CPLD_GetRegModules: failed read!");
                }
            } // Alloc
        } // SHQueryValueEx for size

        RegCloseKey(hkey);

    } // RegOpenKey
}


//
// On a typical system, we will successfully cache all the CPLs.  So this
// function will write out the data only once.
//

void CPLD_FlushRegModules(ControlData *lpData)
{
    if (lpData->fRegCPLChanged)
    {
        int         num = DPA_GetPtrCount(lpData->hRegCPLs);
        DWORD       cbSize = num * sizeof(REG_CPL_INFO);
        REG_CPL_INFO * prcpli = LocalAlloc(LPTR, cbSize);
        LPCTSTR lpszRegKey;

        if (IsOS(OS_WOW6432))
        {
            lpszRegKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder (Wow64)");
        }
        else
        {
            lpszRegKey = REGSTR_PATH_CONTROLSFOLDER;
        }
        
        if (prcpli)
        {
            REG_CPL_INFO * pDest;
            HKEY hkey;
            int i;
            
            //
            // 0<=i<=num && CPLs 0..i-1 have been copied to prcpli or skipped
            //
            
            for (i = 0, pDest = prcpli; i < num ;)
            {
                REG_CPL_INFO * p = DPA_GetPtr(lpData->hRegCPLs, i);
                int j;
                
                //
                // if any CPL in this module has a dynamic icon, we cannot cache
                // any of this module's CPLs.
                //
                // i<=j<=num && CPLs i..j-1 are in same module
                //
                
                for (j = i; j < num; j++)
                {
                    REG_CPL_INFO * q = DPA_GetPtr(lpData->hRegCPLs, j);
                    
                    if (lstrcmp(REGCPL_FILENAME(p), REGCPL_FILENAME(q)))
                    {
                        // all CPLs in this module are okay, save 'em
                        break;
                    }
                    
                    if (q->idIcon == 0)
                    {
                        TraceMsg(TF_GENERAL, "CPLD_FlushRegModules: SKIPPING %s (%s) [dynamic icon]",REGCPL_FILENAME(p),REGCPL_CPLNAME(p));
                        
                        // this module has a dynamic icon, skip it
                        for (j++ ; j < num ; j++)
                        {
                            q = DPA_GetPtr(lpData->hRegCPLs, j);
                            if (lstrcmp(REGCPL_FILENAME(p), REGCPL_FILENAME(q)))
                                break;
                        }
                        i = j;
                        break;
                    }
                }
                
                // CPLs i..j-1 are in the same module and need to be saved
                // (if j<num, CPL j is in the next module)
                for (; i < j ; i++)
                {
                    p = DPA_GetPtr(lpData->hRegCPLs, i);
                    
                    hmemcpy(pDest, p, p->cbSize);
                    pDest = (REG_CPL_INFO *)(((LPBYTE)pDest) + pDest->cbSize);
                    //DebugMsg(DM_TRACE,"CPLD_FlushRegModules: %s (%s)",REGCPL_FILENAME(p),REGCPL_CPLNAME(p));
                }
            } // for (i=0,pDest=prcpli
            
            
            // prcpli contains packed REG_CPL_INFO structures to save to the registry
            
            if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, lpszRegKey, &hkey))
            {
                DWORD dwLCID;
                DWORD dwSize = sizeof(dwLCID);
                dwLCID = GetUserDefaultUILanguage();
                
                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("Presentation LCID"), 0, REG_DWORD, (LPBYTE) &dwLCID, dwSize))
                {
                    TraceMsg(TF_WARNING, "CPLD_FLushRegModules: failed to write the LCID!");
                }
                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("Presentation Cache"), 0, REG_BINARY, (LPBYTE)prcpli, (DWORD) ((LPBYTE)pDest-(LPBYTE)prcpli)))
                {
                    TraceMsg(TF_WARNING, "CPLD_FLushRegModules: failed write!");
                }
                RegCloseKey(hkey);
            }
            
            LocalFree((HLOCAL)prcpli);
            
            lpData->fRegCPLChanged = FALSE; // no longer dirty
        } // if (prcpli)
    } // if dirty
}


//---------------------------------------------------------------------------
void CPLD_Destroy(ControlData *lpData)
{
    int i;

    if (lpData->haminst)
    {
        for (i=DSA_GetItemCount(lpData->haminst)-1 ; i>=0 ; --i)
            _FreeCPLModuleHandle(DSA_GetItemPtr(lpData->haminst, i));

        DSA_Destroy(lpData->haminst);
    }

    if (lpData->hamiModule)
    {
        for (i=DSA_GetItemCount(lpData->hamiModule)-1 ; i>=0 ; --i)
        {
            PMODULEINFO pmi = DSA_GetItemPtr(lpData->hamiModule, i);

            Str_SetPtr(&pmi->pszModule, NULL);
        }

        DSA_Destroy(lpData->hamiModule);
    }

    if (lpData->hRegCPLs)
    {
        CPLD_FlushRegModules(lpData);

        for (i = DPA_GetPtrCount(lpData->hRegCPLs)-1 ; i >= 0 ; i--)
        {
            REG_CPL_INFO * p = DPA_GetPtr(lpData->hRegCPLs, i);
            if (!(p->flags & REGCPL_FROMREG))
                LocalFree((HLOCAL)p);
        }
        DPA_Destroy(lpData->hRegCPLs);
    }
    if (lpData->pRegCPLBuffer)
        LocalFree((HLOCAL)lpData->pRegCPLBuffer);
}


//
// Loads module lpData->hamiModule[nModule] and returns # cpls in module
int CPLD_InitModule(ControlData *lpData, int nModule, MINST *pminst)
{
    PMODULEINFO pmi;
    LPCPLMODULE pcplm;
    int iModule;

    pmi = DSA_GetItemPtr(lpData->hamiModule, nModule);

    if (pmi == NULL)
    {
        TraceMsg(TF_WARNING, "CPLD_InitModule: DSA returned NULL structure");
        return 0;
    }

    iModule = _LoadCPLModuleAndAdd(lpData, pmi->pszModule);

    if (iModule < 0)
    {
        return(0);
    }

    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
    *pminst = pcplm->minst;

    return DSA_GetItemCount(pcplm->hacpli);
}

BOOL CPLD_AddControlToReg(ControlData *lpData, const MINST * pminst, int nControl)
{
    int iModule;
    LPCPLMODULE pcplm;
    LPCPLITEM  pcpli = NULL;

    TCHAR buf[MAX_PATH];
    HANDLE hFindFile;
    WIN32_FIND_DATA findData;

    iModule = _FindCPLModule(pminst);
    if (iModule >= 0)
    {
        pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        if (pcplm != NULL)
            pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
    }
    if (pcpli == NULL)
        return FALSE;

    //
    // PERF: Why are we using GetModuleFileName instead of the name
    // of the file we used to load this module?  (We have the name both
    // in the calling function and in lpData.)
    //

    GetModuleFileName(pcplm->minst.hinst, buf, MAX_PATH);

    if (*buf != 0)
        hFindFile = FindFirstFile(buf, &findData);
    else
        hFindFile = INVALID_HANDLE_VALUE;

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        REG_CPL_INFO * prcpli = LocalAlloc(LPTR, sizeof(REG_CPL_INFO));

        FindClose(hFindFile);

        if (prcpli)
        {
            lstrcpyn(REGCPL_FILENAME(prcpli), buf, MAX_PATH);

            prcpli->flags = FALSE;
            prcpli->ftCreationTime = findData.ftCreationTime;
            prcpli->nFileSizeHigh = findData.nFileSizeHigh;
            prcpli->nFileSizeLow = findData.nFileSizeLow;

            prcpli->idIcon = pcpli->idIcon;

            prcpli->oName = lstrlen(REGCPL_FILENAME(prcpli)) + 1;

            lstrcpyn(REGCPL_CPLNAME(prcpli), pcpli->pszName, MAX_CCH_CPLNAME);

            prcpli->oInfo = prcpli->oName + lstrlen(REGCPL_CPLNAME(prcpli)) + 1;

            lstrcpyn(REGCPL_CPLINFO(prcpli), pcpli->pszInfo, MAX_CCH_CPLINFO);

            prcpli->cbSize = FIELD_OFFSET(REG_CPL_INFO, buf) + (prcpli->oInfo
                                            + lstrlen(REGCPL_CPLINFO(prcpli))
                                            + 1) * sizeof(TCHAR);

            //
            // Force struct size to be DWORD aligned since these are packed
            // together in registry, then read and accessed after reading
            // cache from registry.
            //

            if (prcpli->cbSize & 3)
                prcpli->cbSize += sizeof(DWORD) - (prcpli->cbSize & 3);

            if (!lpData->hRegCPLs)
            {
                lpData->hRegCPLs = DPA_Create(4);
            }
            if (lpData->hRegCPLs)
            {
                DPA_AppendPtr(lpData->hRegCPLs, prcpli);

                //
                // don't update cRegCPLs.  We don't need it any more, and
                // it is also the upper-end counter for ESF_Next registry enum.
                //lpData->cRegCPLs++;
                //

                lpData->fRegCPLChanged = TRUE;
            }
            else
                LocalFree((HLOCAL)prcpli);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\copy.h ===
#ifndef _COPY_H
#define _COPY_H

#include "ynlist.h"

#define ISDIRFINDDATA(finddata) ((finddata).dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#define ISREPARSEFINDDATA(finddata) ((finddata).dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

#define DE_SAMEFILE         0x71    // aahhh! these overlap winerror.h values
#define DE_MANYSRC1DEST     0x72
#define DE_DIFFDIR          0x73
#define DE_ROOTDIR          0x74

#define DE_DESTSUBTREE      0x76
#define DE_WINDOWSFILE      0x77
#define DE_ACCESSDENIEDSRC  0x78
#define DE_PATHTODEEP       0x79
#define DE_MANYDEST         0x7A
// DE_RENAMREPLACE (0x7B) collided with ERROR_INVALID_NAME - but luckily was not used
#define DE_INVALIDFILES     0x7C        // dos device name or too long
#define DE_DESTSAMETREE     0x7D
#define DE_FLDDESTISFILE    0x7E
#define DE_COMPRESSEDVOLUME 0x7F
#define DE_FILEDESTISFLD    0x80
#define DE_FILENAMETOOLONG  0x81
#define DE_DEST_IS_CDROM    0x82
#define DE_DEST_IS_DVD      0x83
#define DE_DEST_IS_CDRECORD 0x84
#define DE_ERROR_MAX        0xB7 

#define ERRORONDEST         0x10000     // indicate error on destination file

STDAPI_(int) CallFileCopyHooks(HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
                                LPCTSTR pszSrcFile, DWORD dwSrcAttribs,
                                LPCTSTR pszDestFile, DWORD dwDestAttribs);
STDAPI_(int) CallPrinterCopyHooks(HWND hwnd, UINT wFunc, PRINTEROP_FLAGS fFlags,
                                LPCTSTR pszSrcPrinter, DWORD dwSrcAttribs,
                                LPCTSTR pszDestPrinter, DWORD dwDestAttribs);
STDAPI_(void) CopyHooksTerminate(void);


#define CONFIRM_DELETE_FILE             0x00000001
#define CONFIRM_DELETE_FOLDER           0x00000002
#define CONFIRM_REPLACE_FILE            0x00000004
#define CONFIRM_WONT_RECYCLE_FILE       0x00000008
#define CONFIRM_REPLACE_FOLDER          0x00000010
#define CONFIRM_MOVE_FILE               0x00000020
#define CONFIRM_MOVE_FOLDER             0x00000040
#define CONFIRM_WONT_RECYCLE_FOLDER     0x00000080
#define CONFIRM_RENAME_FILE             0x00000100
#define CONFIRM_RENAME_FOLDER           0x00000200
#define CONFIRM_SYSTEM_FILE             0x00000400       // any destructive op on a system file
#define CONFIRM_READONLY_FILE           0x00001000       // any destructive op on a read-only file
#define CONFIRM_PROGRAM_FILE            0x00002000       // any destructive op on a program
#define CONFIRM_MULTIPLE                0x00004000       // multiple file/folder confirm setting
#define CONFIRM_LFNTOFAT                0x00008000
#define CONFIRM_STREAMLOSS              0x00010000       // Multi-stream file copied from NTFS -> FAT
#define CONFIRM_PATH_TOO_LONG           0x00020000       // give warning before really nuking paths that are too long to move to recycle bin
#define CONFIRM_FAILED_ENCRYPT          0x00040000       // we failed to encrypt a file that we were moving into an encrypted directory
#define CONFIRM_WONT_RECYCLE_OFFLINE    0x00080000       // give warning before really nuking paths that are offline and can't be recycled
#define CONFIRM_LOST_ENCRYPT_FILE       0x00100000       // Can't move over encryption flag
#define CONFIRM_LOST_ENCRYPT_FOLDER     0x00200000       // Can't move over encryption flag

    /// these parts below are true flags, those above are pseudo enums
#define CONFIRM_WASTEBASKET_PURGE       0x01000000

typedef LONG CONFIRM_FLAG;

#define CONFIRM_FLAG_FLAG_MASK    0xFF000000
#define CONFIRM_FLAG_TYPE_MASK    0x00FFFFFF

typedef struct {
    CONFIRM_FLAG   fConfirm;    // confirm things with their bits set here
    CONFIRM_FLAG   fNoToAll;    // do "no to all" on things with these bits set
} CONFIRM_DATA;


//
// BBDeleteFile returns one of the flags below in a out variable so that
// the caller can detect why BBDeleteFile succeeded/failed.
//
#define BBDELETE_SUCCESS        0x00000000
#define BBDELETE_UNKNOWN_ERROR  0x00000001
#define BBDELETE_FORCE_NUKE     0x00000002
#define BBDELETE_CANNOT_DELETE  0x00000004
#define BBDELETE_SIZE_TOO_BIG   0x00000008
#define BBDELETE_PATH_TOO_LONG  0x00000010
#define BBDELETE_NUKE_OFFLINE   0x00000020
#define BBDELETE_CANCELLED      0x00000040


#ifndef INTERNAL_COPY_ENGINE
STDAPI_(INT_PTR) ConfirmFileOp(HWND hwnd, LPVOID pcs, CONFIRM_DATA *pcd,
                              int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
                              LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
                              LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
                              LPCTSTR pStreamNames);
STDAPI_(int) CountFiles(LPCTSTR pInput);
#endif

STDAPI_(INT_PTR) ValidateCreateFileFromClip(HWND hwnd, LPFILEDESCRIPTOR pfdSrc, TCHAR *szPathDest, PYNLIST pynl);

STDAPI_(void) StartCopyEngine(HANDLE *phEventRunning);
STDAPI_(void) EndCopyEngine(HANDLE hEventRunning);
STDAPI_(BOOL) IsCopyEngineRunning();

#endif  // _COPY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\control.h ===
#ifdef __cplusplus
extern "C" {
#endif

#include <cpl.h>
#include "shell32p.h"

extern TCHAR const c_szCPLCache[];
extern TCHAR const c_szCPLData[];

// Structures used to enumerate CPLs.
//
typedef struct
{
    HDSA    haminst;        // MINST for each loaded dll
    
    HDSA    hamiModule;     // Array of MODULEINFOs of modules in system
    int     cModules;       // size of hamiModule
    
    LPBYTE  pRegCPLBuffer;  // Buffer for hRegCPLs (read from registry)
    HDPA    hRegCPLs;       // Array of RegCPLInfo structs from registry
    int     cRegCPLs;       // size of hRegCPLs
    BOOL    fRegCPLChanged; // TRUE iff hRegCPLs changed
} ControlData, *PControlData;

typedef struct
{
    LPTSTR  pszModule;      // Name of .cpl module
    LPTSTR  pszModuleName;  // points into pszModule to the name sans path
    
    BOOL    flags;          // MI_ flags defined below
    
    FILETIME ftCreationTime;// WIN32_FIND_DATA.ftCreationTime
    DWORD   nFileSizeHigh;  // WIN32_FIND_DATA.nFileSizeHigh
    DWORD   nFileSizeLow;   // WIN32_FIND_DATA.nFileSizeLow
} MODULEINFO, *PMODULEINFO;
// flags:
#define MI_FIND_FILE  1 // WIN32_FIND_FILE info filled in
#define MI_REG_ENUM   2 // Module already enumerated thru registry
#define MI_CPL_LOADED 4 // CPLD_InitModule called for this module

//
//  These values are larger than the NEWCPLINFO structure because some
//  languages (German, for example) can't fit "Scanners and Cameras" into
//  just 32 characters of NEWCPLINFO.szName, and even in English,
//  you can't fit very much helptext into only 64 characters of
//  NEWCPLINFO.szInfo.  (The Network applet writes a small novel for its
//  helptext.)
//
#define MAX_CCH_CPLNAME     MAX_PATH    // Arbitrary
#define MAX_CCH_CPLINFO     512         // Arbitrary


typedef struct
{
    UINT    cbSize;         // We write the first cbSize bytes of this
    // structure to the registry.  This saves about
    // 250 bytes per structure in the registry.
    BOOL    flags;
    
    // what file does this CPL come from?
    //      UINT    oFileName;      // file name // always 0, so don't need it
    FILETIME ftCreationTime;// WIN32_FIND_DATA.ftCreationTime
    DWORD   nFileSizeHigh;  // WIN32_FIND_DATA.nFileSizeHigh
    DWORD   nFileSizeLow;   // WIN32_FIND_DATA.nFileSizeLow
    
    // what's the display info for this CPL?
    int     idIcon;
    UINT    oName;          // (icon title) short name
    UINT    oInfo;          // (details view) description
    
    // buffer for information
    TCHAR   buf[MAX_PATH +  // oFileName
        MAX_CCH_CPLNAME +   // oName
        MAX_CCH_CPLINFO];   // oInfo
} REG_CPL_INFO;

// flags:
#define REGCPL_FROMREG  0x0001  // this REG_CPL_INFO was loaded from the registry
                                // (used to optimize reading from registry)
// helper defines:
#define REGCPL_FILENAME(pRegCPLInfo) ((pRegCPLInfo)->buf)
#define REGCPL_CPLNAME(pRegCPLInfo)  (&((pRegCPLInfo)->buf[(pRegCPLInfo)->oName]))
#define REGCPL_CPLINFO(pRegCPLInfo)  (&((pRegCPLInfo)->buf[(pRegCPLInfo)->oInfo]))

// Information about control modules and individual controls
//
typedef struct // cpli
{
    int     idControl;      // control index
    HICON   hIcon;          // handle of icon
    int     idIcon;         // ID of the icon (used for links)
    LPTSTR  pszName;        // ptr to name string
    LPTSTR  pszInfo;        // ptr to info string
    LPTSTR  pszHelpFile;    // help file
    LONG_PTR lData;         // user supplied data
    DWORD   dwContext;      // help context
} CPLITEM, *LPCPLITEM;

typedef struct // minst
{
#ifdef WX86
    BOOL        fIsX86Dll;      // TRUE if dll is an x86 dll
#endif
    HINSTANCE   hinst;          // either a 16 or 32 bit HINSTANCE (fIs16bit)
    DWORD       idOwner;        // process id of owner (system unique)
    HANDLE      hOwner;         // keeps id valid (against reuse)
} MINST;

typedef struct // cplm
{
    int             cRef;
    MINST           minst;
    TCHAR           szModule[MAX_PATH];
    union
    {
        APPLET_PROC lpfnCPL32;      // minst.fIs16bit=FALSE
        FARPROC     lpfnCPL;        // for opaque operation
    };
    HDSA            hacpli;         // array of CPLITEM structs
    HANDLE          hActCtx;
} CPLMODULE, *PCPLMODULE, *LPCPLMODULE;


LRESULT CPL_CallEntry(LPCPLMODULE, HWND, UINT, LPARAM, LPARAM);

void CPL_StripAmpersand(LPTSTR szBuffer);
BOOL CPL_Init(HINSTANCE hinst);
int _FindCPLModuleByName(LPCTSTR pszModule);

LPCPLMODULE CPL_LoadCPLModule(LPCTSTR szModule);
int CPL_FreeCPLModule(LPCPLMODULE pcplm);

void CPLD_Destroy(PControlData lpData);
BOOL CPLD_GetModules(PControlData lpData);
void CPLD_GetRegModules(PControlData lpData);
int CPLD_InitModule(PControlData lpData, int nModule, MINST *lphModule);
BOOL CPLD_AddControlToReg(PControlData lpData, const MINST * pminst, int nControl);
void CPLD_FlushRegModules(PControlData lpData);

STDAPI_(int) MakeCPLCommandLine(LPCTSTR pszModule, LPCTSTR pszName, LPTSTR pszCommandLine, DWORD cchCommandLine);

HRESULT CALLBACK CControls_DFMCallBackBG(LPSHELLFOLDER psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
IShellFolderViewCB* Controls_CreateSFVCB(IShellFolder* psf, LPCITEMIDLIST pidl);

LPCPLMODULE FindCPLModule(const MINST * pminst);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\contextmenu.h ===
// An IContextMenu on an array of context menus
HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv);


// An IContextMenu on an existing HMENU
// NOTE: always takes ownership of the HMENU (in success and failure)
HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID riid, void** ppv);


// An IContextMenu on an existing IContextMenu, which removes the ';'-separated list of verbs from the resulting menu
HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);


// CContextMenuForwarder is designed as a base class that forwards all
// context menu stuff to another IContextMenu implementation.  You override
// whatever functions you want to modify.  (Like QueryContextMenu - delegate then modify the results)
// For example, CContextMenuWithoutVerbs inherits from this class.
//
class CContextMenuForwarder : IContextMenu3, IObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu3
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags) { return _pcm->QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags); }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici) { return _pcm->InvokeCommand(lpici); }
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax) { return _pcm->GetCommandString(idCmd,uType,pwReserved,pszName,cchMax); }

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { return _pcm2->HandleMenuMsg(uMsg,wParam,lParam); }

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult) { return _pcm3->HandleMenuMsg2(uMsg,wParam,lParam,plResult); }

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite) { return _pows->SetSite(punkSite); }
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite) { return _pows->GetSite(riid,ppvSite); }

protected:
    CContextMenuForwarder(IUnknown* punk);
    virtual ~CContextMenuForwarder();

private:
    LONG _cRef;

protected:
    IUnknown*        _punk;

    IObjectWithSite* _pows;
    IContextMenu*    _pcm;
    IContextMenu2*   _pcm2;
    IContextMenu3*   _pcm3;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\copyhook.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "copy.h"

UINT DefView_CopyHook(const COPYHOOKINFO *pchi);
int PathCopyHookCallback(HWND hwnd, UINT wFunc, LPCTSTR pszSrc, LPCTSTR pszDest);

void _CopyHookTerminate(HDSA hdsaCopyHooks, BOOL fProcessDetach);

typedef struct {
    ICopyHook * pcphk;              // Either ICopyHookA *or LPCOPYHOOK
    BOOL        fAnsiCrossOver;     // TRUE for ICopyHookA *on UNICODE build
} CALLABLECOPYHOOK;

typedef struct
{
    ICopyHook           cphk;
    ICopyHookA          cphkA;
    LONG                cRef;
} CCopyHook;

STDMETHODIMP_(ULONG) CCopyHook_AddRef(ICopyHook *pcphk);	// forward


STDMETHODIMP CCopyHook_QueryInterface(ICopyHook *pcphk, REFIID riid, void **ppvObj)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);
    if (IsEqualIID(riid, &IID_IShellCopyHook) || 
        IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = pcphk;
    }
    else if (IsEqualIID(riid, &IID_IShellCopyHookA))
    {
        *ppvObj = &this->cphkA;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    CCopyHook_AddRef(&this->cphk);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CCopyHook_AddRef(ICopyHook *pcphk)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);
    return InterlockedIncrement(&this->cRef);
}

STDMETHODIMP_(ULONG) CCopyHook_Release(ICopyHook *pcphk)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);

    if (InterlockedDecrement(&this->cRef))
        return this->cRef;

    LocalFree((HLOCAL)this);
    return 0;
}

STDMETHODIMP_(UINT) CCopyHook_CopyCallback(ICopyHook *pcphk, HWND hwnd, UINT wFunc, UINT wFlags, 
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    COPYHOOKINFO chi = { hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs };
    
    DebugMsg(DM_TRACE, TEXT("Event = %d, File = %s , %s"), wFunc, pszSrcFile,
        Dbg_SafeStr(pszDestFile));
    
    // check Special Folders first...
    if (PathCopyHookCallback(hwnd, wFunc, pszSrcFile, pszDestFile) == IDNO)
    {
        return IDNO;
    }
    
    if (wFunc != FO_COPY && !(wFlags & FOF_NOCONFIRMATION))
    {
        TCHAR szShortName[MAX_PATH];
        BOOL fInReg = (RLIsPathInList(pszSrcFile) != -1);
        BOOL fInBitBucket = IsFileInBitBucket(pszSrcFile);
        UINT iLength = GetShortPathName(pszSrcFile, szShortName, ARRAYSIZE(szShortName));
        
        // Don't double search for names that are the same (or already found)
        if (iLength != 0 && lstrcmpi(pszSrcFile, szShortName) != 0)
        {
            if (!fInReg)
                fInReg = (RLIsPathInList(szShortName) != -1);
            if (!fInBitBucket)
                fInBitBucket = IsFileInBitBucket(szShortName);
        }
        
        if (fInReg && !fInBitBucket)
        {
            LPCTSTR pszSpec = PathFindFileName(pszSrcFile);
            return ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RENAMEFILESINREG),
                pszSpec, MB_YESNO | MB_ICONEXCLAMATION, pszSpec);
        }
    }
    return DefView_CopyHook(&chi);
}

ICopyHookVtbl c_CCopyHookVtbl = {
    CCopyHook_QueryInterface, CCopyHook_AddRef, CCopyHook_Release,
    CCopyHook_CopyCallback,
};

STDMETHODIMP CCopyHookA_QueryInterface(ICopyHookA *pcphkA, REFIID riid, void **ppvObj)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_QueryInterface(&this->cphk,riid,ppvObj);
}

STDMETHODIMP_(ULONG) CCopyHookA_AddRef(ICopyHookA *pcphkA)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_AddRef(&this->cphk);
}

STDMETHODIMP_(ULONG) CCopyHookA_Release(ICopyHookA *pcphkA)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_Release(&this->cphk);
}

STDMETHODIMP_(UINT) CCopyHookA_CopyCallback(ICopyHookA *pcphkA, HWND hwnd, UINT wFunc, UINT wFlags, 
    LPCSTR pszSrcFile, DWORD dwSrcAttribs, LPCSTR pszDestFile, DWORD dwDestAttribs)
{
    WCHAR szSrcFileW[MAX_PATH];
    WCHAR szDestFileW[MAX_PATH];
    LPWSTR pszSrcFileW = NULL;
    LPWSTR pszDestFileW = NULL;
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);

    if (pszSrcFile)
    {
        SHAnsiToUnicode(pszSrcFile, szSrcFileW, ARRAYSIZE(szSrcFileW));
        pszSrcFileW = szSrcFileW;
    }

    if (pszDestFile)
    {
        SHAnsiToUnicode(pszDestFile, szDestFileW, ARRAYSIZE(szDestFileW));
        pszDestFileW = szDestFileW;
    }

    return CCopyHook_CopyCallback(&this->cphk, hwnd, wFunc, wFlags,
                                         pszSrcFileW, dwSrcAttribs,
                                         pszDestFileW, dwDestAttribs);
}

ICopyHookAVtbl c_CCopyHookAVtbl = {
    CCopyHookA_QueryInterface, CCopyHookA_AddRef, CCopyHookA_Release,
    CCopyHookA_CopyCallback,
};


STDAPI SHCreateShellCopyHook(ICopyHook **pcphkOut, REFIID riid)
{
    HRESULT hres = E_OUTOFMEMORY;      // assume error;
    CCopyHook *pcphk = (void*)LocalAlloc(LPTR, SIZEOF(CCopyHook));
    if (pcphk)
    {
        pcphk->cphk.lpVtbl = &c_CCopyHookVtbl;
        pcphk->cphkA.lpVtbl = &c_CCopyHookAVtbl;
        pcphk->cRef = 1;
        hres = CCopyHook_QueryInterface(&pcphk->cphk, riid, pcphkOut);
        CCopyHook_Release(&pcphk->cphk);
    }
    return hres;
}

HRESULT CCopyHook_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return SHCreateShellCopyHook((ICopyHook **)ppv, riid);
}


// create the HDSA of copyhook objects

HDSA CreateCopyHooks(LPCTSTR pszKey)
{
    HDSA hdsaCopyHooks = DSA_Create(SIZEOF(CALLABLECOPYHOOK), 4);
    if (hdsaCopyHooks)
    {
        HKEY hk;

        if (RegOpenKey(HKEY_CLASSES_ROOT, pszKey, &hk) == ERROR_SUCCESS) 
        {
            int i;
            TCHAR szKey[128];

            // iterate through the subkeys
            for (i = 0; RegEnumKey(hk, i, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS; ++i) 
            {
                TCHAR szCLSID[128];
                LONG cb = SIZEOF(szCLSID);

                // for each subkey, get the class id and do a cocreateinstance
                if (SHRegQueryValue(hk, szKey, szCLSID, &cb) == ERROR_SUCCESS) 
                {
                    IUnknown *punk;
                    HRESULT hres = SHExtCoCreateInstance(szCLSID, NULL, NULL, &IID_IUnknown, &punk);
                    if (SUCCEEDED(hres)) 
                    {
                        CALLABLECOPYHOOK cc;

                        SHPinDllOfCLSIDStr(szCLSID);

                        cc.pcphk = NULL;
                        cc.fAnsiCrossOver = FALSE;
                        hres = punk->lpVtbl->QueryInterface(punk, &IID_IShellCopyHook, &cc.pcphk);
                        if (SUCCEEDED(hres))
                        {
                            DSA_AppendItem(hdsaCopyHooks, &cc);
                        }
                        else
                        {
                            hres = punk->lpVtbl->QueryInterface(punk, &IID_IShellCopyHookA, &cc.pcphk);
                            if (SUCCEEDED(hres))
                            {
                                cc.fAnsiCrossOver = TRUE;
                                DSA_AppendItem(hdsaCopyHooks, &cc);
                            }
                        }
                        punk->lpVtbl->Release(punk);
                    }
                }
            }
            RegCloseKey(hk);
        }
    }
    return hdsaCopyHooks;
}

int CallCopyHooks(HDSA *phdsaHooks, LPCTSTR pszKey, HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    int i;

    if (!*phdsaHooks)
    {
        HDSA hdsaTemp = CreateCopyHooks(pszKey);
        if (hdsaTemp == NULL)
            return IDYES;

        // we don't hold a CritSection when doing the above to avoid deadlocks,
        // now we need to atomicaly store our results. if someone beat us to this
        // we free the hdsa we created. SHInterlockedCompareExchange does this for us
        // letting us know where there is a race condition so we can free the dup copy
        if (SHInterlockedCompareExchange((void **)phdsaHooks, hdsaTemp, 0))
        {
            // some other thread raced with us, blow this away now
            _CopyHookTerminate(hdsaTemp, FALSE);
        }
    }

    for (i = DSA_GetItemCount(*phdsaHooks) - 1; i >= 0; i--) 
    {
        int iReturn;
        CALLABLECOPYHOOK *pcc = (CALLABLECOPYHOOK *)DSA_GetItemPtr(*phdsaHooks, i);
        if (!pcc->fAnsiCrossOver)
        {
            iReturn = pcc->pcphk->lpVtbl->CopyCallback(pcc->pcphk,
                hwnd, wFunc, fFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
        }
        else
        {
            CHAR szSrcFileA[MAX_PATH];
            CHAR szDestFileA[MAX_PATH];
            LPSTR pszSrcFileA = NULL;
            LPSTR pszDestFileA = NULL;
            ICopyHookA *pcphkA = (LPCOPYHOOKA)pcc->pcphk;

            if (pszSrcFile)
            {
                SHUnicodeToAnsi(pszSrcFile, szSrcFileA, ARRAYSIZE(szSrcFileA));
                pszSrcFileA = szSrcFileA;
            }
            if (pszDestFile)
            {
                SHUnicodeToAnsi(pszDestFile, szDestFileA, ARRAYSIZE(szDestFileA));
                pszDestFileA = szDestFileA;
            }
            iReturn = pcphkA->lpVtbl->CopyCallback(pcphkA,
                                       hwnd, wFunc, fFlags,
                                       pszSrcFileA, dwSrcAttribs,
                                       pszDestFileA, dwDestAttribs);
        }
        if (iReturn != IDYES)
            return iReturn;
    }
    return IDYES;
}

// These need to be per-instance since we are storing interfaces pointers
HDSA g_hdsaFileCopyHooks = NULL;
HDSA g_hdsaPrinterCopyHooks = NULL;

int CallFileCopyHooks(HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    return CallCopyHooks(&g_hdsaFileCopyHooks, STRREG_SHEX_COPYHOOK, hwnd, 
        wFunc, fFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
}

int CallPrinterCopyHooks(HWND hwnd, UINT wFunc, PRINTEROP_FLAGS fFlags,
    LPCTSTR pszSrcPrinter, DWORD dwSrcAttribs, LPCTSTR pszDestPrinter, DWORD dwDestAttribs)
{
    return CallCopyHooks(&g_hdsaPrinterCopyHooks, STRREG_SHEX_PRNCOPYHOOK, hwnd, 
        wFunc, fFlags, pszSrcPrinter, dwSrcAttribs, pszDestPrinter, dwDestAttribs);
}

//
// We will only call this on process detach, and these are per-process
// globals, so we do not need a critical section here
//
//  This function is also called from CreateCopyHooks when the second
// thread is cleaning up its local hdsaCopyHoos, which does not require
// a critical section either.
//
void _CopyHookTerminate(HDSA hdsaCopyHooks, BOOL fProcessDetach)
{
    //  Note that we must no call any of virtual functions when we are
    // processing PROCESS_DETACH signal, because the DLL might have been
    // already unloaded before shell32. We just hope that they don't
    // allocate any global thing to be cleaned. USER does the same thing
    // with undestroyed window. It does not send call its window procedure
    // when it is destroying an undestroyed window within its PROCESS_DETACH
    // code. (SatoNa/DavidDS)
    //
    if (!fProcessDetach)
    {
        int i;
        for (i = DSA_GetItemCount(hdsaCopyHooks) - 1; i >= 0; i--) 
        {
            CALLABLECOPYHOOK *pcc = (CALLABLECOPYHOOK *)DSA_GetItemPtr(hdsaCopyHooks, i);
            pcc->pcphk->lpVtbl->Release(pcc->pcphk);
        }
    }

    DSA_Destroy(hdsaCopyHooks);
}


// called from ProcessDetatch
// NOTE: we are seralized at this point, don't need critical sections

void CopyHooksTerminate(void)
{
    ASSERTDLLENTRY;      // does not require a critical section

    if (g_hdsaFileCopyHooks)
    {
        _CopyHookTerminate(g_hdsaFileCopyHooks, TRUE);
        g_hdsaFileCopyHooks = NULL;
    }

    if (g_hdsaPrinterCopyHooks)
    {
        _CopyHookTerminate(g_hdsaPrinterCopyHooks, TRUE);
        g_hdsaPrinterCopyHooks = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\copy.c ===
// Copyright (c) <1995-1999> Microsoft Corporation

#include "shellprv.h"
#pragma  hdrstop

#include <msi.h>
#include <msip.h>

#include <aclapi.h>     // for TreeResetNamedSecurityInfo

#include "shlwapip.h" // for SHGlobalCounterDecrement
#include "ynlist.h"

#define INTERNAL_COPY_ENGINE
#include "copy.h"
#include "shell32p.h"
#include "control.h"
#include "cdburn.h"
#include "propsht.h"
#include "prshtcpp.h"

#define REG_VAL_GENERAL_RENAMEHTMLFILE  TEXT("RenameHtmlFile")

#define TF_DEBUGCOPY 0x00800000

#define VERBOSE_STATUS

// REVIEW, we should tune this size down as small as we can
// to get smoother multitasking (without effecting performance)
#define COPYMAXBUFFERSIZE       0x10000 // 0xFFFF this is 32-bit code!
#define MIN_MINTIME4FEEDBACK    5       // is it worth showing estimated time to completion feedback?
#define MS_RUNAVG               10000   // ms, window for running average time to completion estimate
#define MS_TIMESLICE             2000    // ms, (MUST be > 1000!) first average time to completion estimate

#define MAXDIRDEPTH             128     // # of directories we will deal with recursivly

#define SHOW_PROGRESS_TIMEOUT   1000    // 1 second
#define MINSHOWTIME             1000    // 1 sec

// progress dialog message
#define PDM_SHUTDOWN     WM_APP
#define PDM_NOOP        (WM_APP + 1)
#define PDM_UPDATE      (WM_APP + 2)


#define OPER_MASK           0x0F00
#define OPER_ENTERDIR       0x0100
#define OPER_LEAVEDIR       0x0200
#define OPER_DOFILE         0x0300
#define OPER_ERROR          0x0400

#define FOFuncToStringID(wFunc) (IDS_UNDO_FILEOP + wFunc)

//
//  The following is a list of folder suffixes in all international languages. This list is NOT
// read from a resource because we do NOT want the strings in this list to be mistakenly localized.
// This list will allow NT5 shell to operate on files created by any international version of 
// office 9.
//  This list is taken from "http://officeweb/specs/webclient/files.htm"
//
//  WARNING: Do not localize the strings in this table. Do not make any changes to this table 
//  without consulting AlanRa (Office9 PM)
//
static const LPCTSTR c_apszSuffixes[] = 
{
    TEXT(".files"),
    TEXT("_files"),
    TEXT("-Dateien"),
    TEXT("_fichiers"),
    TEXT("_bestanden"),
    TEXT("_file"),
    TEXT("_archivos"),
    TEXT("-filer"),
    TEXT("_tiedostot"),
    TEXT("_pliki"),
    TEXT("_soubory"),
    TEXT("_elemei"),
    TEXT("_ficheiros"),
    TEXT("_arquivos"),
    TEXT("_dosyalar"),
    TEXT("_datoteke"),
    TEXT("_fitxers"),
    TEXT("_failid"),
    TEXT("_fails"),
    TEXT("_bylos"),
    TEXT("_fajlovi"),
    TEXT("_fitxategiak"),
};

// The reg value under HKCU\REGSTR_PATH_EXPLORER that specifies Connection ON/OFF switch
#define REG_VALUE_NO_FILEFOLDER_CONNECTION  TEXT("NoFileFolderConnection")

////////////////////////////////////////////////////////////////////////////
///// directory tree cache.


// this is set if pdtnChild has not been traversed (as opposed to NULL which means
// there are no children
#define DTN_DELAYED ((PDIRTREENODE)-1)


// DIRTREENODE is a node in a linked list/tree cache of the directory structure.
// except for the top level (which is specified by the caller of the api), the order
// are all files first, then all directories.

typedef struct _dirtreenode {

    struct _dirtreenode *pdtnNext; // sibling
    struct _dirtreenode *pdtnChild; // head of children linked list
    struct _dirtreenode *pdtnParent;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeLow;
    DWORD nFileSizeHigh;

    LARGE_INTEGER liFileSizeCopied;
    BOOL  fNewRoot : 1;
    BOOL  fDummy : 1;   // this marks the node as a dummy node (a wildcard that didn't match anything)
    BOOL  fConnectedElement : 1; // this marks the node as an element that was implicitly added
    // to the Move/Copy source list because of an office9 type of
    // connection established in the registry.

    //The following is a union because not all nodes need all the fields.
    union {
        // The following is valid only if fConnectedElement is FALSE.
        struct  _dirtreenode *pdtnConnected;  

        // The following structure is valid only if fConnectedElemet is TRUE.
        struct  {
            LPTSTR  pFromConnected;     // if fNewRoot && fConnectedElement, then these two elements
            LPTSTR  pToConnected;       // have the pFrom and pTo.
            DWORD   dwConfirmation;     // The result of confirnation given by end-user
        } ConnectedInfo;
    };

    TCHAR szShortName[14];
    TCHAR szName[1]; // this struct is dynamic

} DIRTREENODE, *PDIRTREENODE;

typedef struct {
    BOOL  fChanged;
    DWORD dwFiles; // number of files
    DWORD dwFolders; // number of folders
    LARGE_INTEGER liSize; // total size of all files
} DIRTOTALS, *PDIRTOTALS;

typedef struct {
    UINT oper;
    DIRTOTALS dtAll; // totals for all files
    DIRTOTALS dtDone; // totals of what's done
    BOOL fChangePosted;

    PDIRTREENODE pdtn; // first directory tree node
    PDIRTREENODE pdtnCurrent;
    PDIRTREENODE pdtnConnectedItems;  //Pointer to the begining of connected elements node.
    TCHAR    bDiskCheck[26];

    // how much does each operation cost in the progress...
    int iFilePoints;
    int iFolderPoints;
    int iSizePoints;


    LPTSTR pTo;  // this holds the top level target list
    LPTSTR pFrom; // this holds the top level source list
    BOOL    fMultiDest;

    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH]; // this is the current destination for pdtn and all it's children (not siblings)
    // lpszDestPath includes pdtn's first path component

    HDSA hdsaRenamePairs;

} DIRTREEHEADER, *PDIRTREEHEADER;

//  We spend a lot of time creating simple PIDLs, so use this cache
//  to speed things up.
typedef struct SIMPLEPIDLCACHE {
    IBindCtx *pbcFile;          // Empty filesys bind context for files
    IBindCtx *pbcFolder;        // Empty filesys bind context for folders
    IShellFolder *psfDesktop;   // Desktop folder (for ParseDisplayName)
    int iInit;                  // 0 = not inited; 1 = inited; -1 = init failed
    IShellFolder *psf;          // Current folder
    LPITEMIDLIST pidlFolder;    // Current folder
    TCHAR szFolder[MAX_PATH];   // Current folder
} SIMPLEPIDLCACHE, *PSIMPLEPIDLCACHE;

typedef struct {
    int          nRef;          // struct reference count

    int          nSourceFiles;
    LPTSTR       lpCopyBuffer; // global file copy buffer
    UINT         uSize;         // size of this buffer
    FILEOP_FLAGS fFlags;        // from SHFILEOPSTRUCT
    HWND         hwndProgress;  // dialog/progress window
    HWND         hwndDlgParent; // parent window for message boxes
    CONFIRM_DATA cd;            // confirmation stuff

    UNDOATOM    *lpua;           // the undo atom that this file operation will make
    BOOL        fNoConfirmRecycle;
    BOOL        bAbort;
    BOOL        fMerge;   // are we doing a merge of folders

    BOOL        fDone;
    BOOL        fProgressOk;
    BOOL        fDTBuilt;
    BOOL        fLostEncryptOk;
    BOOL        fFromCDRom;         // Clear readonly bits if copying from CDRom

    // folowing fields are used for giving estimated time for completion
    // feedback to the user during longer than MINTIME4FEEDBACK operations
    BOOL  fFlushWrites;     // Should we flush writes for destinations on slow links

    DWORD dwPreviousTime;       // calculate transfer rate
    int  iLastProgressPoints;   // how many progress points we had the last time we updated the time est
    DWORD dwPointsPerSec;
    LPCTSTR lpszProgressTitle;
    LPSHFILEOPSTRUCT lpfo;

    DIRTREEHEADER dth;
    BOOL        fInitialize;
    const WIN32_FIND_DATA* pfd;
    BOOL        bStreamLossPossible;    // Could stream loss happen in this directory?

    SIMPLEPIDLCACHE spc;
} COPY_STATE, *LPCOPY_STATE;

// we have a seperate struct that we pass off to the FOUIThread so that he can get to the pcs,
// but since the FOUIThread can outlive the main thread (!!) in some cases, we can't let him have a
// ref to pcs->lpfo since it is owned by SHFileOperations caller and we crash if we try to refrence
// it after SHFileOperation returns and the caller has freed the memory. The only two things the 
// FOUIThread uses out of the pcs->lpfo are the wFunc and the lpszProgressTitle (to see if the
// recycle bin was being emptied or not), so we make private copies of that info for the thread.
typedef struct {
    COPY_STATE* pcs;
    UINT wFunc;
    BOOL bIsEmptyRBOp;
} FOUITHREADINFO, *PFOUITHREADINFO;

// Information to determine folder's movability to the recycle bin
typedef struct {
    BOOL            bProcessedRoot; // tells if we are the first call in the recursive chain and we need to do root-specific processing
    int             cchBBDir;       // count of characters in the recycle bin dir (eg "C:\Recycler\<sid>")
    int             cchDelta;       // count of characters that the path will increase (or decrease if negative) by when moved under the recycle bin directory
    ULONGLONG       cbSize;         // size of the folder
    TCHAR           szNonDeletableFile[MAX_PATH];   // an output buffer that holds the name of the file that cannot be deleted, if one exists
    TCHAR           szPath[MAX_PATH];   // scratch buffer for stack savings when recursing
    WIN32_FIND_DATA fd;             // also for stack savings
} FOLDERDELETEINFO;


// function declarations
void _ProcessNameMappings(LPTSTR pszTarget, HDSA hdsaRenamePairs);
int GetNameDialog(HWND hwnd, COPY_STATE *pcs, BOOL fMultiple,UINT wOp, LPTSTR pFrom, LPTSTR pTo);
void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs);
BOOL FOQueryAbort(COPY_STATE *pcs);
UINT DTAllocConnectedItemNodes(PDIRTREEHEADER pdth, COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR pszPath, BOOL fRecurse, PDIRTREENODE *ppdtnConnectedItems);
void CALLBACK FOUndo_Invoke(UNDOATOM *lpua);
LONG CheckFolderSizeAndDeleteability(LPCTSTR pszDir, FOLDERDELETEINFO* pfdi, LPCOPY_STATE pcs);
BOOL DeleteFileBB(LPTSTR pszFile, INT *piReturn, COPY_STATE *pcs, BOOL fIsDir, WIN32_FIND_DATA *pfd, HDPA *phdpaDeletedFiles);


BOOL DTDiskCheck(PDIRTREEHEADER pdth, COPY_STATE *pcs, LPTSTR pszPath)
{
    int iDrive = PathGetDriveNumber(pszPath);

    if (iDrive != -1)
    {
        if (!pdth->bDiskCheck[iDrive])
        {
            HWND hwnd = pcs->hwndDlgParent;
            TCHAR szDrive[] = TEXT("A:\\");
            szDrive[0] += (CHAR)iDrive;

            // Sometimes pszPath is a dir and sometimes it's a file.  All we really care about is if the
            // drive is ready (inserted, formated, net path mapped, etc).  We know that we don't have a
            // UNC path because PathGetDriveNumber would have failed and we are already busted in terms
            // of mounted volumes, again because we use PathGetDriveNumber, so we don't have to worry about
            // these two cases.  As such we build the root path and use that instead.
            pdth->bDiskCheck[iDrive] = SUCCEEDED(SHPathPrepareForWrite(((pcs->fFlags & FOF_NOERRORUI) ? NULL : hwnd), NULL, szDrive, 0));
        }
        return pdth->bDiskCheck[iDrive];
    }

    return TRUE;    // always succeed for net drives
}


//--------------------------------------------------------------------------------------------
// Simple pidl cache stuff
//--------------------------------------------------------------------------------------------

void SimplePidlCache_Release(SIMPLEPIDLCACHE *pspc)
{
    ATOMICRELEASE(pspc->pbcFile);
    ATOMICRELEASE(pspc->pbcFolder);
    ATOMICRELEASE(pspc->psfDesktop);
    ATOMICRELEASE(pspc->psf);
    ILFree(pspc->pidlFolder);
}

const WIN32_FIND_DATA c_fdFolder = { FILE_ATTRIBUTE_DIRECTORY };

BOOL SimplePidlCache_Init(SIMPLEPIDLCACHE *pspc)
{
    ASSERT(pspc->iInit == 0);

    if (SUCCEEDED(SHCreateFileSysBindCtx(NULL, &pspc->pbcFile)) &&
            SUCCEEDED(SHCreateFileSysBindCtx(&c_fdFolder, &pspc->pbcFolder)) &&
            SUCCEEDED(SHGetDesktopFolder(&pspc->psfDesktop)))
    {
        pspc->psf = pspc->psfDesktop;
        pspc->psf->lpVtbl->AddRef(pspc->psf);
        // It's okay to leave pidlFolder as NULL; ILCombine won't barf

        pspc->iInit = 1;
        return TRUE;
    }
    else
    {
        pspc->iInit = -1;
        return FALSE;
    }
}

LPITEMIDLIST SimplePidlCache_GetFilePidl(SIMPLEPIDLCACHE *pspc, LPCTSTR pszFile)
{
    LPITEMIDLIST pidlChild;
    LPITEMIDLIST pidlRet;
    LPTSTR pszFileName;
    TCHAR szFolder[MAX_PATH];
    USES_CONVERSION;

    if (pspc->iInit < 0)
        return NULL;                // Initialization failed

    if (!pspc->iInit && !SimplePidlCache_Init(pspc))
        return NULL;

    // If this file is in a different folder from the one we cached,
    // need to dump the old one and get a new one.

    lstrcpyn(szFolder, pszFile, ARRAYSIZE(szFolder));
    PathRemoveFileSpec(szFolder);

    // We use StrCmpC instead of lstrcmpi because the vast majority
    // of the time, the path will match even in case, and if we get
    // it wrong, it's no big whoop: we just don't use the cache.

    if (StrCmpC(pspc->szFolder, szFolder) != 0)
    {
        LPITEMIDLIST pidlFolder = NULL; // In case it's on the desktop
        IShellFolder *psf;

        if (szFolder[0])            // An actual folder
        {
            // Get a simple pidl to the folder.
            if (FAILED(pspc->psfDesktop->lpVtbl->ParseDisplayName(pspc->psfDesktop, NULL,
                            pspc->pbcFolder, T2W(szFolder), NULL, &pidlFolder, NULL)))
                return NULL;
        }
        else                        // Going for the desktop
        {
            /* pidlFolder already preinitialized to NULL */
        }

        // Bind to that folder
        if (FAILED(SHBindToObject(pspc->psfDesktop, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf))))
        {
            ILFree(pidlFolder);
            return NULL;
        }

        // Woo-hoo, everybody is happy.  Save the results into our cache.

        ATOMICRELEASE(pspc->psf);
        pspc->psf = psf;

        ILFree(pspc->pidlFolder);
        pspc->pidlFolder = pidlFolder;

        lstrcpyn(pspc->szFolder, szFolder, ARRAYSIZE(pspc->szFolder));

    }

    // Get a simple pidl to the filename
    pszFileName = PathFindFileName(pszFile);        // T2W is a macro with multiple evaluation
    if (FAILED(pspc->psf->lpVtbl->ParseDisplayName(pspc->psf, NULL, pspc->pbcFile,
                    T2W(pszFileName), NULL, &pidlChild, NULL)))
        return NULL;

    // Combine it with the parent
    pidlRet = ILCombine(pspc->pidlFolder, pidlChild);
    ILFree(pidlChild);

    return pidlRet;
}

//--------------------------------------------------------------------------------------------
// ConvertToConnectedItemname:
//      Given a file/folder name, this function checks to see if it has any connection and if 
// there is a connection, then it will convert the given name to that of the connected element
// and return length of the prefix. If no connection exists, it returns zero.
//  The fDirectory parameter specifies if the given filename is a FOLDER or not!
//
//  dwBuffSize: The size of pszFileName buffer in CHARACTERS.
//
//  Examples:
//      "foo.htm"   =>  "foo*"  (returns 3 because the prefix("foo") length is 3)
//      "foobar files" =>  "foobar.htm?"  (returns 6 as the prefix length)
//                                          
//--------------------------------------------------------------------------------------------
int ConvertToConnectedItemName(LPTSTR pszFileName, DWORD dwBuffSize, BOOL fDirectory)
{
    LPTSTR  pszDest, pszConnectedElemSuffix;
    int     iPrefixLength;

    if (fDirectory)
    {
        // Look for a suffix which is one of the standard suffixes.
        if (!(pszDest = (LPTSTR)PathFindSuffixArray(pszFileName, c_apszSuffixes, ARRAYSIZE(c_apszSuffixes))))
            return FALSE;

        // " files" suffix is found. Replace it with ".htm?"
        pszConnectedElemSuffix = TEXT(".htm?");
    }
    else
    {
        // Look for the extension ".htm" or ".html" and replace it with "*".
        if (!(pszDest = PathFindExtension(pszFileName)))
            return FALSE;

        if (lstrcmpi(pszDest, TEXT(".htm")) && (lstrcmpi(pszDest, TEXT(".html"))))
            return FALSE;

        // Extension ".htm" or ".html" is found. Replace it with "*"
        pszConnectedElemSuffix = (LPTSTR)c_szStar;
    }

    iPrefixLength = (int)(pszDest - pszFileName);

    //Check if the input buffer is big enough to over-write the suffix in-place
    if ((((int)dwBuffSize - iPrefixLength) - 1) < lstrlen(pszConnectedElemSuffix))
        return 0;

    //Replace the source suffix with the connected element's suffix.
    lstrcpy(pszDest, pszConnectedElemSuffix);

    return(iPrefixLength);
}

PDIRTREENODE DTAllocNode(PDIRTREEHEADER pdth, WIN32_FIND_DATA* pfd, PDIRTREENODE pdtnParent, PDIRTREENODE pdtnNext, BOOL fConnectedElement)
{
    int iLen = pfd ? lstrlen(pfd->cFileName) * sizeof(TCHAR) : 0;
    PDIRTREENODE pdtn = (PDIRTREENODE)LocalAlloc(LPTR, sizeof(DIRTREENODE) + iLen);
    if (pdtn)
    {
        pdtn->fConnectedElement = fConnectedElement;

        // Initializing the following to NULL is not needed because of the LPTR (zero init) done
        // above.
        // if (fConnectedElement)
        //{
        //    pdtn->ConnectedInfo.pFromConnected = pdtn->ConnectedInfo.pToConnected = NULL;
        //    pdtn->ConnectedInfo.dwConfirmation = 0;
        //}
        //else
        //    pdtn->pdtnConnected = NULL;

        pdtn->pdtnParent = pdtnParent;
        pdtn->pdtnNext   = pdtnNext;

        if (pfd)
        {
            pdtn->dwFileAttributes = pfd->dwFileAttributes;
            pdtn->ftCreationTime   = pfd->ftCreationTime;
            pdtn->ftLastWriteTime  = pfd->ftLastWriteTime;
            pdtn->nFileSizeLow     = pfd->nFileSizeLow;
            pdtn->nFileSizeHigh    = pfd->nFileSizeHigh;

            // only the stuff we care about
            lstrcpy(pdtn->szShortName, pfd->cAlternateFileName);
            lstrcpy(pdtn->szName, pfd->cFileName);


            if (ISDIRFINDDATA(*pfd))
            {
                pdth->dtAll.dwFolders++;
                pdtn->pdtnChild = DTN_DELAYED;
            }
            else
            {
                LARGE_INTEGER li;

                li.LowPart = pfd->nFileSizeLow;
                li.HighPart = pfd->nFileSizeHigh;

                pdth->dtAll.liSize.QuadPart += li.QuadPart;
                pdth->dtAll.dwFiles++;
            }
            // increment the header stats
            pdth->dtAll.fChanged = TRUE;
        }
    }

    return pdtn;
}

#if defined(DEBUG)  /// && defined(DEBUGCOPY)
void DebugDumpPDTN(PDIRTREENODE pdtn, LPTSTR ptext)
{
    DebugMsg(TF_DEBUGCOPY, TEXT("***** PDTN %x  (%s)"), pdtn, ptext);
    //Safe-guard against pdtn being NULL!
    if (pdtn)
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("** %s %s"), pdtn->szShortName, pdtn->szName);
        DebugMsg(TF_DEBUGCOPY, TEXT("** %x %d"), pdtn->dwFileAttributes, pdtn->nFileSizeLow);
        DebugMsg(TF_DEBUGCOPY, TEXT("** %x %x %x"), pdtn->pdtnParent, pdtn->pdtnNext, pdtn->pdtnChild);
        DebugMsg(TF_DEBUGCOPY, TEXT("** NewRoot:%x, Connected:%x, Dummy:%x"), pdtn->fNewRoot, pdtn->fConnectedElement, pdtn->fDummy);
        if (pdtn->fConnectedElement)
        {
            DebugMsg(TF_DEBUGCOPY, TEXT("**** Connected: pFromConnected:%s, pToConnected:%s, dwConfirmation:%x"), pdtn->ConnectedInfo.pFromConnected, 
                    pdtn->ConnectedInfo.pToConnected, pdtn->ConnectedInfo.dwConfirmation);
        }
        else
        {
            DebugMsg(TF_DEBUGCOPY, TEXT("**** Origin: pdtnConnected:%x"), pdtn->pdtnConnected);
        }
    }
    else
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("** NULL pointer(PDTN)"));
    }
}
#else
#define DebugDumpPDTN(p, x) 0
#endif

BOOL  DoesSuffixMatch(LPTSTR  lpSuffix, const LPCTSTR *apSuffixes, int iArraySize)
{
    while (iArraySize--)
    {
        // Note: This must be a case sensitive compare, because we don't want to pickup 
        // "Program Files".
        if (!lstrcmp(lpSuffix, *apSuffixes++))
            return TRUE;
    }

    return FALSE;
}


//--------------------------------------------------------------------------------------------
//
//  DTPathToDTNode:
//      This function is used to build a list of nodes that correspond to the given pszPath.
// This list is built under "ppdtn".  If ppdtnConnectedItems is given, another list of nodes that
// correspond to the connected elements(files/folders) of the nodes in the first list is also built
// under "ppdtnConnectedItems".
//
// WARNING: This parties directly on pszPath and pfd so that it doesn't need to allocate
// on the stack.  This recurses, so we want to use as little stack as possible
//
// this will wack off one component from pszPath
//
//
// ppdtn: Points to where the header of the list being built will be stored.
// ppdtnConnectedItems: If this is NULL, then we are not interested in finding and building the 
//                      connected elements. If this is NOT null, it points to where the header of
//                      the connected items list will be stored.
// fConnectedElement: Each node being built under ppdtn needs to be marked with this bit.
// iPrefixLength: This parameter is zero if fConnectedElement is FALSE. Otherwise, it contains the
//              Length of the prefix part of the file or foldername (path is NOT included).
//              For example, if "c:\windows\foo*" is passed in, iPrefixLength is 3 (length of "foo")
//
// dwFilesOrFolders parameter can specify if we need to look for only FILES or FOLDERs or BOTH.

#define     DTF_FILES_ONLY      0x00000001      //Operate only on Files.
#define     DTF_FOLDERS_ONLY    0x00000002      //Operate only on Folders.
#define     DTF_FILES_AND_FOLDERS  (DTF_FILES_ONLY | DTF_FOLDERS_ONLY)  //Operate on files AND folders.

UINT DTPathToDTNode(PDIRTREEHEADER pdth, COPY_STATE *pcs, LPTSTR pszPath, BOOL fRecurse,
        DWORD dwFilesOrFolders, PDIRTREENODE* ppdtn, WIN32_FIND_DATA *pfd,
        PDIRTREENODE pdtnParent, PDIRTREENODE* ppdtnConnectedItems, BOOL fConnectedElement,
        int iPrefixLength)
{
    int iError = 0;

    // this points to the var where all items are inserted.
    // folders are placed after it, files are placed before

    // keep the stack vars to a minimum because this is recursive
    PDIRTREENODE *ppdtnMiddle = ppdtn;
    BOOL fNeedToFindNext = TRUE;
    HANDLE hfind = FindFirstFile(pszPath, pfd);

    DebugMsg(TF_DEBUGCOPY, TEXT("DTPathToDTNode Entering %s"), pszPath);
    *ppdtnMiddle = NULL; // in case there are no children

    if (hfind == INVALID_HANDLE_VALUE)
    {
        // this is allowable only if the path is wild...
        // and the parent exists
        if (PathIsWild(pszPath))
        {
            PathRemoveFileSpec(pszPath);
            if (PathFileExists(pszPath))
            {
                return 0;
            }
        }
        return OPER_ERROR | ERROR_FILE_NOT_FOUND;
    }

    //Remove the filespec before passing it onto DTAllocConnectedItemNodes.
    PathRemoveFileSpec(pszPath);

    do
    {
        // We skip the following files:
        //      "." and ".." filenames
        //      Folders when DTF_FILES_ONLY is set
        //      Files when DTF_FOLDERS_ONLY is set

        if (!PathIsDotOrDotDot(pfd->cFileName) &&
                (((dwFilesOrFolders & DTF_FILES_ONLY) && !ISDIRFINDDATA(*pfd)) || 
                 ((dwFilesOrFolders & DTF_FOLDERS_ONLY) && ISDIRFINDDATA(*pfd)))) 
        {
            //Check if we are looking for connected elements
            if ((!pdtnParent) && fConnectedElement)
            {
                // We found what we are looking for. If we are looking for a top-level connected item and 
                // if it is a folder, then we need to make sure that the suffix exactly matches one of the
                // suffixes in the array c_apszSuffixes[].
                LPTSTR  lpSuffix = (LPTSTR)(pfd->cFileName + iPrefixLength);

                if (ISDIRFINDDATA(*pfd))  
                {
                    // What we found is a directory!
                    // See if it has one of the standard suffixes for connected folders.
                    if (!DoesSuffixMatch(lpSuffix, c_apszSuffixes, ARRAYSIZE(c_apszSuffixes)))
                        continue; //This is not what we look for. So, find next.
                }
                else
                {
                    // What we found is a file (i.e Not a directory)
                    // See if it has one of the standard suffixes for html files.
                    if (lstrcmpi(lpSuffix, TEXT(".htm")) && lstrcmpi(lpSuffix, TEXT(".html")))
                        continue; //This is not what we look for. So, find next.
                }

                // Now we know that we found the connected element that we looked for.
                // So, no need to FindNext again. We can get out of the loop after processing
                // it once.
                fNeedToFindNext = FALSE;
            }

            *ppdtnMiddle = DTAllocNode(pdth, pfd, pdtnParent, *ppdtnMiddle, fConnectedElement);

            if (!*ppdtnMiddle)
            {
                FindClose(hfind);
                return OPER_ERROR | ERROR_NOT_ENOUGH_MEMORY;
            }

            // make sure that the parent's pointer always points to the head of
            // this linked list
            if (*ppdtn == (*ppdtnMiddle)->pdtnNext)
                *ppdtn = (*ppdtnMiddle);

            DebugDumpPDTN(*ppdtnMiddle, TEXT("DTPathToDTNode, DTAllocNode"));

            //We need to check for Connected elements only for the top level items
            if ((!(pcs->fFlags & FOF_NO_CONNECTED_ELEMENTS)) && ppdtnConnectedItems)
            {
                //Make sure this is a top level item
                ASSERT(!pdtnParent);

                //Create a list of connected items and attach it to the head of the list.
                iError = DTAllocConnectedItemNodes(pdth, pcs, pfd, pszPath, fRecurse, ppdtnConnectedItems);

                DebugDumpPDTN(*ppdtnConnectedItems, TEXT("DTPathToDTNode, DTAllocConnectedNodes"));

                // It is possible that the connected files do not exist. That condition is not really
                // an error. So, we check for insufficient memory error condition alone here.
                if (iError == (OPER_ERROR | ERROR_NOT_ENOUGH_MEMORY))
                {
                    FindClose(hfind);
                    return(iError);
                }

                //If a connected item exists, then make the origin item point to this connected item.
                if (*ppdtnConnectedItems)
                {
                    (*ppdtnMiddle)->pdtnConnected = *ppdtnConnectedItems;
                    // Also by default, set the Confirmation result to NO so that the connected element
                    // will not be copied/moved etc., in case of a conflict. However, if the origin had
                    // a conflict, we would put up a confirmation dlg and the result of that dlg will 
                    // over-write this value.
                    (*ppdtnConnectedItems)->ConnectedInfo.dwConfirmation = IDNO;
                }

                //Move to the last node in the connected items list.
                while (*ppdtnConnectedItems)
                    ppdtnConnectedItems = &((*ppdtnConnectedItems)->pdtnNext);
            }
            else
            {
                // This should have been initialized to zero during allocation, but lets be paranoid
                ASSERT(NULL == (*ppdtnMiddle)->pdtnConnected);
            }

            // if this is not a directory, move the ppdtnMiddle up one
            if (!ISDIRFINDDATA(*pfd))
            {
                ppdtnMiddle = &(*ppdtnMiddle)->pdtnNext;
            }

        }

    } while (fNeedToFindNext && !FOQueryAbort(pcs) && FindNextFile(hfind, pfd));

    iError = 0;  //It is possible that iError contains other errors value now! So, reset it!

    FindClose(hfind);

    // now go and recurse into folders (if desired)
    // we don't have to check to see if these pdtn's are dirs, because the
    // way we inserted them above ensures that everything in from of
    // ppdtnMiddle are folders

    // we're going to tack on a specific child
    // then add the *.* after that

    while (!FOQueryAbort(pcs) && *ppdtnMiddle)
    {
        BOOL fRecurseThisItem = fRecurse;

        if ((*ppdtnMiddle)->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
        {
            // Recurse into reparse points unless they asked not to
            if (pcs->fFlags & FOF_NORECURSEREPARSE)
            {
                fRecurseThisItem = FALSE;
            }
        }

        if (fRecurseThisItem)
        {
            if (PathAppend(pszPath, (*ppdtnMiddle)->szName))
            {
                if (PathAppend(pszPath, c_szStarDotStar))
                {

                    // NULL indicates that we do not want to get the connected elements.
                    // This is because we want the connected elements only for the top-level items.
                    iError = DTPathToDTNode(pdth, pcs, pszPath, TRUE, DTF_FILES_AND_FOLDERS,
                            &((*ppdtnMiddle)->pdtnChild), pfd, *ppdtnMiddle, NULL, fConnectedElement, 0);

                }
                else
                {
                    iError = OPER_ERROR | DE_INVALIDFILES;
                }

                PathRemoveFileSpec(pszPath);
            }
            else
            {
                iError = OPER_ERROR | DE_INVALIDFILES;
            }
        }
        else
        {
            // if we don't want to recurse, just mark them all as having no children
            (*ppdtnMiddle)->pdtnChild = NULL;
        }

        if (iError)
        {
            return iError;
        }

        ppdtnMiddle = &(*ppdtnMiddle)->pdtnNext;
    }

    return 0;
}

UINT DTAllocConnectedItemNodes(PDIRTREEHEADER pdth, COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR pszPath, BOOL fRecurse, PDIRTREENODE *ppdtnConnectedItems)
{
    // Since DTAllocConnectedItemNodes() gets called only for the top-level items in the src list,
    // there is no danger of this function getting called recursively. Hence, I didn't worry about
    // allocating the following on the stack.
    // If "too-much-stack-is-used" problem arises, we can optimize the stack usage by splitting
    // the following function into two such that the most common case (of no connection) 
    // doesn't use much stack. 
    DWORD   dwFileOrFolder;
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szFileName[MAX_PATH];
    WIN32_FIND_DATA  fd;
    int     iPrefixLength;  //This is the length of "foo" if the filename is "foo.htm" or "foo files"

    //Make a copy of the filename; This copy will get munged by ConvertToConnectedItemName().
    lstrcpy(szFileName, pfd->cFileName);
    // Convert the given file/foder name into the connected item's name with wild card characters.
    if (!(iPrefixLength = ConvertToConnectedItemName(szFileName, ARRAYSIZE(szFileName), ISDIRFINDDATA(*pfd))))
        return 0; //No connections exist for the given folder/file.

    // Now szFileName has the name of connected element with wildcard character.

    // If the given element is a directory, we want to look for connected FILES only  and
    // if the given element is a file, we want to look for connected FOLDERS only.
    dwFileOrFolder = ISDIRFINDDATA(*pfd) ? DTF_FILES_ONLY : DTF_FOLDERS_ONLY;

    // Form the file/folder name with the complete path!
    lstrcpy(szFullPath, pszPath);
    PathAppend(szFullPath, szFileName); 

    // The file-element has some "connected" items.
    DebugMsg(TF_DEBUGCOPY, TEXT("DTAllocConnectedItemNodes Looking for %s"), szFullPath);

    return(DTPathToDTNode(pdth, pcs, szFullPath, fRecurse, dwFileOrFolder, ppdtnConnectedItems, &fd, NULL, NULL, TRUE, iPrefixLength));
}

void DTInitProgressPoints(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    pdth->iFilePoints = 1;
    pdth->iFolderPoints = 1;

    switch (pcs->lpfo->wFunc)
    {
        case FO_RENAME:
        case FO_DELETE:
            pdth->iSizePoints = 0;
            break;

        case FO_COPY:
            pdth->iSizePoints = 1;
            break;

        case FO_MOVE:
            if (PathIsSameRoot(pcs->lpfo->pFrom, pcs->lpfo->pTo))
            {
                pdth->iSizePoints = 0;
            }
            else
            {
                // if it's across volumes, these points increase
                // because we need to nuke the source as well as
                // create the target...
                // whereas we don't need to nuke the "size" of the source
                pdth->iFilePoints = 2;
                pdth->iFolderPoints = 2;
                pdth->iSizePoints = 1;
            }
            break;
    }
}

UINT DTBuild(COPY_STATE* pcs)
{
    PDIRTREEHEADER pdth = &pcs->dth;
    WIN32_FIND_DATA fd;
    TCHAR szPath[MAX_PATH];
    PDIRTREENODE *ppdtn;
    PDIRTREENODE *ppdtnConnectedItems;
    int iError = 0;

    pcs->dth.pFrom = (LPTSTR)pcs->lpfo->pFrom;
    pcs->dth.pTo = (LPTSTR)pcs->lpfo->pTo;
    // A tree of original items will be built under ppdtn.
    ppdtn = &pdth->pdtn;
    // A tree of items "connected" to the orginal items will be built under ppdtnConnectedItems.
    ppdtnConnectedItems = &pdth->pdtnConnectedItems;

    DTInitProgressPoints(pdth, pcs);
    while (!FOQueryAbort(pcs) && *pdth->pFrom)
    {
        BOOL fRecurse = TRUE;

        switch (pcs->lpfo->wFunc)
        {
            case FO_MOVE:
                // The move operation doesn't need to recurse if we are moving from and to the same
                // volume.  In this case we know that we don't need to display any warnings for
                // things like LFN to 8.3 filename conversion or stream loss.  Instead, we can do
                // the operation with one single win32 file operation that just does a rename.

                // NTRAID89119-2000/02/25-toddb
                // This is only true if we don't cross a mount point!  If we cross
                // a mount point then we might have to warn about these things.

                if ((pcs->fFlags & FOF_NORECURSION) || PathIsSameRoot(pdth->pFrom, pdth->pTo))
                {
                    fRecurse = FALSE;
                }
                break;

            case FO_COPY:
                // For a copy we always recurse unless we're told not to.
                if (pcs->fFlags & FOF_NORECURSION)
                {
                    fRecurse = FALSE;
                }
                break;

            case FO_RENAME:
                // for a rename we never recurse
                fRecurse = FALSE;
                break;

            case FO_DELETE:
                // for a delete we don't need to recurse IF the recycle bin will be able to handle
                // the given item.  If the recycle bin handles the delete then we can undo from
                // the recycle bin if we need to.
                if ((pcs->fFlags & FOF_ALLOWUNDO) && BBWillRecycle(pdth->pFrom, NULL))
                {
                    fRecurse = FALSE;
                }
                break;
        }

        lstrcpy(szPath, pdth->pFrom);

        DebugMsg(TF_DEBUGCOPY, TEXT("DTBuild: %s"), szPath);

        // If the file is on removable media, we need to check for media in the drive.
        // Prompt the user to insert the media if it's missing.
        if (!DTDiskCheck(pdth, pcs, szPath))
        {
            iError = ERROR_CANCELLED;
            break;
        }

        iError = DTPathToDTNode(pdth, pcs, szPath, fRecurse,
                ((PathIsWild(pdth->pFrom) && (pcs->lpfo->fFlags & FOF_FILESONLY)) ? DTF_FILES_ONLY : DTF_FILES_AND_FOLDERS), 
                ppdtn,&fd, NULL, ppdtnConnectedItems, FALSE, 0);

        DebugMsg(TF_DEBUGCOPY, TEXT("DTBuild: returned %d"), iError);

        // FEATURE: If an error occured we should allow the user to skip the file that caused the error.  That way
        // if one of the source files doesn't exists the rest will still get copied.  Do this only in the multi-
        // source case, blah blah blah.  This helps in the case where one of the source files cannot be moved or
        // copied (usually due to Access Denied, could be insuffecent permissions or file is in use, etc).

        if (iError)
            break;

        if (!(*ppdtn) && PathIsWild(pdth->pFrom))
        {
            // no files are associated with this path... this
            // can happen when we have wildcards...
            // alloc a dummy node
            *ppdtn = DTAllocNode(pdth, NULL, NULL, NULL, FALSE);
            if (*ppdtn)
            {
                (*ppdtn)->fDummy = TRUE;
            }
        }


        if (*ppdtn)
        {
            // mark this as the start of a root spec... this is
            // necessary in case we have several wild specs
            (*ppdtn)->fNewRoot = TRUE;
        }

        if (*ppdtnConnectedItems)
        {
            // Mark this as the start of a root spec.
            (*ppdtnConnectedItems)->fNewRoot = TRUE;
            // For connected items, we need to remember the path.
            (*ppdtnConnectedItems)->ConnectedInfo.pFromConnected = pdth->pFrom;
            (*ppdtnConnectedItems)->ConnectedInfo.pToConnected = pdth->pTo;
        }


        while (*ppdtn)
        {
            ppdtn = &(*ppdtn)->pdtnNext;
        }

        while (*ppdtnConnectedItems)
        {
            ppdtnConnectedItems = &(*ppdtnConnectedItems)->pdtnNext;
        }

        pdth->pFrom += lstrlen(pdth->pFrom) + 1;
        if (pcs->lpfo->wFunc != FO_DELETE && (pcs->lpfo->fFlags & FOF_MULTIDESTFILES))
        {
            pdth->pTo += lstrlen(pdth->pTo) + 1;
        }
    }

    //Attach the "ConnectedElements" Tree to the end of the source element tree.
    *ppdtn = pcs->dth.pdtnConnectedItems;

    pcs->dth.pFrom = (LPTSTR)pcs->lpfo->pFrom;
    pcs->dth.pTo = (LPTSTR)pcs->lpfo->pTo;
    pcs->fDTBuilt = TRUE;

    // set up the initial time information
    pcs->dwPreviousTime = GetTickCount();
    pcs->dwPointsPerSec = 0;
    pcs->iLastProgressPoints = 0;
    return iError;
}

#define DTNIsRootNode(pdtn) ((pdtn)->pdtnParent == NULL)
#define DTNIsDirectory(pdtn) (pdtn->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
// This macro determines if the given node is an "Origin" of a connection. i.e. Does this node 
// point to a connected element that needs to be moved/copied etc., along with it?
// For example, if "foo.htm" is moved, "foo files" is also moved. 
// Here, "foo.htm" is the "Connect origin" (fConnectedElement = FALSE; pdtnConnected is valid)
// and "foo files" is the "connected element". (fConnectedElement = TRUE;)
#define DTNIsConnectOrigin(pdtn) ((!pdtn->fConnectedElement) && (pdtn->pdtnConnected != NULL))
#define DTNIsConnected(pdtn)    (pdtn && (pdtn->fConnectedElement))

//
UINT DTEnumChildren(PDIRTREEHEADER pdth, COPY_STATE *pcs, BOOL fRecurse, DWORD dwFileOrFolder)
{
    int iError = 0;
    if (pdth->pdtnCurrent->pdtnChild == DTN_DELAYED)
    {
        WIN32_FIND_DATA fd;

        // fill in all the children and update the stats in pdth
        if (PathAppend(pdth->szSrcPath, c_szStarDotStar))
        {
            iError = DTPathToDTNode(pdth, pcs, pdth->szSrcPath, fRecurse, dwFileOrFolder,
                    &pdth->pdtnCurrent->pdtnChild, &fd, pdth->pdtnCurrent, NULL, pdth->pdtnCurrent->fConnectedElement, 0);
        }
        else
        {
            iError = OPER_ERROR | DE_INVALIDFILES;
        }

        // If we get "File Not Found" Error now and if it is a connected item, then this item 
        // must have already been moved/renamed/deleted etc., So, this is not really an error. 
        // All this means is that this connected item was also explicitly selected and hence appeared
        // as or "Origin" item earlier in the list and it had already been operated upon.
        // So, reset the error here.
        // (Example: If end-user selects "foo.htm" AND "foo files" folder and moves them, then we
        // will get a file-not-found error when we attempt to move the connected items. To avoid
        // this error dialog, we reset the error here.)

        if (DTNIsConnected(pdth->pdtnCurrent) && (iError == (OPER_ERROR | ERROR_FILE_NOT_FOUND)))
            iError = 0;  
    }
    return iError;
}

//
// DTNGetConfirmationResult:
//    When a file("foo.htm") is moved/copied, we may put up a confirmation dialog in case 
// of a conflict and the end-user might have responded saying "Yes", "no" etc., When the 
// corresponding connected element ("foo files") is also moved/copied etc., we should NOT put up
// a confirmation dialog again. We must simply store the answer to the original confirmation and
// use it later. 
//  This function retries the result of the original confirmation from the top-level connected 
// element.
int  DTNGetConfirmationResult(PDIRTREENODE pdtn)
{
    //Confirmation results are saved only for Connected items; Not for Connection Origins.
    if (!pdtn || !DTNIsConnected(pdtn))
        return 0;

    //Confirmation results are stored only at the top-level node. So, go there.
    while (pdtn->pdtnParent)
        pdtn = pdtn->pdtnParent;

    return(pdtn->ConnectedInfo.dwConfirmation);
}

void DTGetWin32FindData(PDIRTREENODE pdtn, WIN32_FIND_DATA* pfd)
{
    // only the stuff we care about
    lstrcpy(pfd->cAlternateFileName, pdtn->szShortName);
    lstrcpy(pfd->cFileName, pdtn->szName);

    pfd->dwFileAttributes = pdtn->dwFileAttributes;
    pfd->ftCreationTime   = pdtn->ftCreationTime;
    pfd->ftLastWriteTime  = pdtn->ftLastWriteTime;
    pfd->nFileSizeLow     = pdtn->nFileSizeLow;
    pfd->nFileSizeHigh     = pdtn->nFileSizeHigh;
}

void DTSetFileCopyProgress(PDIRTREEHEADER pdth, LARGE_INTEGER liRead)
{
    LARGE_INTEGER liDelta;

    liDelta.QuadPart = (liRead.QuadPart - pdth->pdtnCurrent->liFileSizeCopied.QuadPart);

    DebugMsg(TF_DEBUGCOPY, TEXT("DTSetFileCopyProgress %d %d %d"), liDelta.LowPart, liRead.LowPart, pdth->dtDone.liSize.QuadPart);
    pdth->pdtnCurrent->liFileSizeCopied.QuadPart += liDelta.QuadPart;
    pdth->dtDone.liSize.QuadPart += liDelta.QuadPart;
    DebugMsg(TF_DEBUGCOPY, TEXT("DTSetFileCopyProgress %d %d"), liDelta.LowPart, pdth->dtDone.liSize.LowPart);
    pdth->dtDone.fChanged = TRUE;
}

void DTFreeNode(PDIRTREEHEADER pdth, PDIRTREENODE pdtn)
{
    if (pdth)
    {
        ASSERT(pdtn->pdtnChild == NULL || pdtn->pdtnChild == DTN_DELAYED);

        // we're done with this node..  update the header totals
        if (DTNIsDirectory(pdtn))
        {
            pdth->dtDone.dwFolders++;
        }
        else
        {
            LARGE_INTEGER li;

            li.LowPart = pdtn->nFileSizeLow;
            li.HighPart = pdtn->nFileSizeHigh;

            pdth->dtDone.dwFiles++;
            pdth->dtDone.liSize.QuadPart += (li.QuadPart - pdtn->liFileSizeCopied.QuadPart);
        }

        pdth->dtDone.fChanged = TRUE;

        // repoint parent pointer
        if (!pdtn->pdtnParent)
        {

            // no parent... must be a root type thing
            ASSERT(pdth->pdtn == pdtn);
            pdth->pdtn = pdtn->pdtnNext;

        }
        else
        {

            ASSERT(pdtn->pdtnParent->pdtnChild == pdtn);
            if (pdtn->pdtnParent->pdtnChild == pdtn)
            {
                // if my parent was pointing to me, point him to my sib
                pdtn->pdtnParent->pdtnChild = pdtn->pdtnNext;
            }
        }
    }

    LocalFree(pdtn);
}

// this frees all children of (but NOT including) the current node.
// it doesn' free the current node because it's assumed that
// DTGoToNextNode will be called right afterwards, and that will
// free the current node
void DTFreeChildrenNodes(PDIRTREEHEADER pdth, PDIRTREENODE pdtn)
{
    PDIRTREENODE pdtnChild = pdtn->pdtnChild;
    while (pdtnChild && pdtnChild != DTN_DELAYED)
    {
        PDIRTREENODE pdtnNext = pdtnChild->pdtnNext;

        // recurse and free these children
        if (DTNIsDirectory(pdtnChild))
        {
            DTFreeChildrenNodes(pdth, pdtnChild);
        }

        DTFreeNode(pdth, pdtnChild);
        pdtnChild = pdtnNext;
    }

    pdtn->pdtnChild = NULL;
}

void DTForceEnumChildren(PDIRTREEHEADER pdth)
{
    if (!pdth->pdtnCurrent->pdtnChild)
        pdth->pdtnCurrent->pdtnChild = DTN_DELAYED;
}

void DTAbortCurrentNode(PDIRTREEHEADER pdth)
{
    DTFreeChildrenNodes((pdth), (pdth)->pdtnCurrent);
    if (pdth->oper == OPER_ENTERDIR)
        pdth->oper = OPER_LEAVEDIR;
}

void DTCleanup(PDIRTREEHEADER pdth)
{
    PDIRTREENODE pdtn;

    while (pdth->pdtnCurrent && pdth->pdtnCurrent->pdtnParent)
    {
        // in case we bailed deep in a tree
        pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnParent;
    }

    while (pdth->pdtnCurrent)
    {
        pdtn = pdth->pdtnCurrent;
        pdth->pdtnCurrent = pdtn->pdtnNext;
        DTFreeChildrenNodes(NULL, pdtn);
        DTFreeNode(NULL, pdtn);
    }
}

BOOL DTInitializePaths(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    ASSERT(pdth->pdtnCurrent);    // If we have no current node then how can we Initialize its paths?

    lstrcpyn(pdth->szSrcPath, pdth->pFrom, ARRAYSIZE(pdth->szSrcPath));

    // For the "Origins" we need to do this only if a wild card exists. However, for connected elements,
    // we need to do this everytime because connected elements may not exist for every "Origins"
    if (PathIsWild(pdth->pFrom) || (pdth->pdtnCurrent->fNewRoot && DTNIsConnected(pdth->pdtnCurrent)))
    {
        PathRemoveFileSpec(pdth->szSrcPath);
        if (!PathAppend(pdth->szSrcPath, pdth->pdtnCurrent->szName))
            return FALSE;
    }

    if (!pdth->pTo)
    {
        // no dest, make it the same as the source and we're done
        lstrcpyn(pdth->szDestPath, pdth->szSrcPath, ARRAYSIZE(pdth->szSrcPath));
        return TRUE;
    }

    if (pdth->pTo)
    {
        lstrcpyn(pdth->szDestPath, pdth->pTo, ARRAYSIZE(pdth->szSrcPath));
    }

    if (!pdth->fMultiDest)
    {
        if (!PathAppend(pdth->szDestPath, pdth->pdtnCurrent->szName))
            return FALSE;
    }
    else
    {
        //When undo of a move operation is done, fMultiDest is set.
        // When fMultiDest is set, we need to strip out the filename given by pTo and 
        // append the current filename.
        // For RENAME operations, the source and destination names are different. This is handled 
        // seperately below. So, we handle only other operations here where source and dest names are the same.
        if ((pcs->lpfo->wFunc != FO_RENAME) && pdth->pdtnCurrent->fNewRoot && DTNIsConnected(pdth->pdtnCurrent))
        {
            PathRemoveFileSpec(pdth->szDestPath);
            if (!PathAppend(pdth->szDestPath, pdth->pdtnCurrent->szName))
                return FALSE;
        }
    }

    //We will never try to rename a connected element! Make sure we don't hit this!
    ASSERT(!((pcs->lpfo->wFunc == FO_RENAME) && DTNIsConnected(pdth->pdtnCurrent)));

    return TRUE;

}

UINT DTValidatePathNames(PDIRTREEHEADER pdth, UINT operation, COPY_STATE * pcs)
{
    if (pcs->lpfo->wFunc != FO_DELETE)
    {
        // Why process name mappings?  Here's why.  If we are asked to copy directory "c:\foo" and
        // file "c:\foo\file" to another directory (say "d:\") we might have a name confilct when
        // we copy "c:\foo" so instead we create "d:\Copy Of foo".  Later, we walk to the second
        // dirtree node and we are asked to copy "c:\foo\file" to "d:\foo", all of which is valid.
        // HOWEVER, it's not what we want to do.  We use _ProccessNameMappings to convert
        // "d:\foo\file" into "d:\Copy of foo\file".
        _ProcessNameMappings(pdth->szDestPath, pdth->hdsaRenamePairs);

        // REVIEW, do we need to do the name mapping here or just let the
        // VFAT do it?  if vfat does it we need to rip out all of the GetNameDialog() stuff.

        if ((operation != OPER_LEAVEDIR) &&
                !IsLFNDrive(pdth->szDestPath) &&
                PathIsLFNFileSpec(PathFindFileName(pdth->szSrcPath)) &&
                PathIsLFNFileSpec(PathFindFileName(pdth->szDestPath)))
        {

            int iRet;
            TCHAR szOldDest[MAX_PATH];

            lstrcpyn(szOldDest, pdth->szDestPath, ARRAYSIZE(szOldDest));
            iRet = GetNameDialog(pcs->hwndDlgParent, pcs,
                    (pcs->nSourceFiles != 1) || !DTNIsRootNode(pdth->pdtnCurrent), // if we're entering a dir, multiple spec, or not at root
                    operation, pdth->szSrcPath, pdth->szDestPath);

            switch (iRet)
            {
                case IDNO:
                case IDCANCEL:
                    return iRet;

                default:
                    AddRenamePairToHDSA(szOldDest, pdth->szDestPath, &pcs->dth.hdsaRenamePairs);
                    break;
            }
        }

        if (operation == OPER_ENTERDIR)
        {
            // Make sure the new directory is not a subdir of the original...

            int cchFrom = lstrlen(pdth->szSrcPath);

            // NTRAID89511-2000/02/25-KishoreP
            // Shouldn't we get the short names for both these directories and compair those?
            // Otherwise I can copy "C:\Long Directory Name" to "C:\LongDi~1\foo" without error.

            if (!(pcs->fFlags & FOF_RENAMEONCOLLISION) &&
                    !StrCmpNI(pdth->szSrcPath, pdth->szDestPath, cchFrom))
            {
                TCHAR chNext = pdth->szDestPath[cchFrom]; // Get the next char in the dest.

                if (!chNext)
                {
                    return OPER_ERROR | DE_DESTSAMETREE;
                }
                else if (chNext == TEXT('\\'))
                {
                    // The two fully qualified strings are equal up to the end
                    // of the source directory ==> the destination is a subdir.
                    // Must return an error.

                    // if, stripping the last file name and the backslash give the same length, they are the
                    // same file/folder
                    if ((PathFindFileName(pdth->szDestPath) - pdth->szDestPath - 1) ==
                            lstrlen(pdth->szSrcPath))
                    {
                        return OPER_ERROR | DE_DESTSAMETREE;
                    }
                    else
                    {
                        return OPER_ERROR | DE_DESTSUBTREE;
                    }
                }
            }
        }
    }
    return 0;
}

// this moves to the next node (child, sib, parent) and sets up the
// directory path info and oper state
UINT DTGoToNextNode(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    UINT oper = OPER_ENTERDIR; // the default
    int iError;

    if (!pdth->pdtnCurrent)
    {
        pdth->pdtnCurrent = pdth->pdtn;

        if (pdth->pdtnCurrent)
        {
            if (pdth->pdtnCurrent->fDummy)
            {
                // if this is just a placeholder... go on to the next one
                return DTGoToNextNode(pdth, pcs);
            }

            if (!DTInitializePaths(pdth, pcs))
            {
                return OPER_ERROR | DE_INVALIDFILES;
            }
        }
        else
        {
            // Our tree is completely empty.

            // REVIEW: What do we do here?  If pdtnCurrent is still NULL then our list is completely empty.
            // Is that a bug or what?  My hunch is that we should return an error code here, most likely
            // OPER_ERROR | DE_INVALIDFILES.  If we do nothing here then we will fail silently.
            return OPER_ERROR | DE_INVALIDFILES;
        }
    }
    else
    {
        UINT iError;
        BOOL fFreeLastNode = TRUE;
        PDIRTREENODE pdtnLastCurrent = pdth->pdtnCurrent;
        TCHAR szTemp[MAX_PATH];

        if (iError = DTEnumChildren(pdth, pcs, FALSE, DTF_FILES_AND_FOLDERS))
            return iError;

        if (pdth->pdtnCurrent->pdtnChild)
        {

            fFreeLastNode = FALSE;
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnChild;

            // if the source long name is too long, try the short name
            if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szName))
            {
                if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szShortName))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }
            }
            StrCpyN(pdth->szSrcPath, szTemp, ARRAYSIZE(pdth->szSrcPath));

            // if the dest long name is too long, try the short name
            if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szName))
            {
                if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szShortName))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }
            }
            StrCpyN(pdth->szDestPath, szTemp, ARRAYSIZE(pdth->szDestPath));
        }
        else if (pdth->oper == OPER_ENTERDIR)
        {
            // if the last operation was an enterdir and it has no children
            // (because it failed the above test
            // then we should do a leave dir on it now
            oper = OPER_LEAVEDIR;
            fFreeLastNode = FALSE;

        }
        else if (pdth->pdtnCurrent->pdtnNext)
        {
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnNext;

            if (!pdth->pdtnCurrent->pdtnParent)
            {
                // if this was the top, we need to build the next path info
                // from scratch

                if (pdth->pdtnCurrent->fNewRoot)
                {
                    if (pdth->pdtnCurrent->fConnectedElement)
                    {
                        // Since this is a new root in a Connected list, the pFrom and pTo are
                        // stored in the node itself. This is needed because Connected elements may
                        // not exist for every item in the source list and we do not want to create dummy
                        // nodes for each one of them. So, pFrom and pTo are stored for every NewRoot of
                        // connected elements and we use these here.
                        pdth->pFrom = pdth->pdtnCurrent->ConnectedInfo.pFromConnected;
                        pdth->pTo = pdth->pdtnCurrent->ConnectedInfo.pToConnected;
                    }
                    else
                    {
                        // go to the next path pair
                        pdth->pFrom += lstrlen(pdth->pFrom) + 1;
                        if (pdth->pTo)
                        {
                            if (pdth->fMultiDest)
                            {
                                pdth->pTo += lstrlen(pdth->pTo) + 1;
                            }
                        }
                    }
                }

                if (pdth->pdtnCurrent->fDummy)
                {
                    // if this is just a placeholder... go on to the next one
                    if (fFreeLastNode)
                    {
                        DTFreeNode(pdth, pdtnLastCurrent);
                    }
                    return DTGoToNextNode(pdth, pcs);
                }

                DTInitializePaths(pdth, pcs);
            }
            else
            {

                PathRemoveFileSpec(pdth->szSrcPath);
                PathRemoveFileSpec(pdth->szDestPath);

                // if the source long name is too long, try the short name
                if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szName))
                {
                    if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szShortName))
                    {
                        return OPER_ERROR | DE_INVALIDFILES;
                    }
                }
                StrCpyN(pdth->szSrcPath, szTemp, ARRAYSIZE(pdth->szSrcPath));

                // if the dest long name is too long, try the short name
                if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szName))
                {
                    if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szShortName))
                    {
                        return OPER_ERROR | DE_INVALIDFILES;
                    }
                }
                StrCpyN(pdth->szDestPath, szTemp, ARRAYSIZE(pdth->szDestPath));
            }
        }
        else
        {
            oper = OPER_LEAVEDIR;
            PathRemoveFileSpec(pdth->szSrcPath);
            PathRemoveFileSpec(pdth->szDestPath);
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnParent;
        }

        if (fFreeLastNode)
        {
            DTFreeNode(pdth, pdtnLastCurrent);
        }
    }

    if (!pdth->pdtnCurrent)
    {
        // no more!  we're done!
        return 0;
    }

    DebugDumpPDTN(pdth->pdtnCurrent, TEXT("PDTNCurrent"));

    if (oper == OPER_ENTERDIR)
    {
        if (pcs->lpfo->wFunc == FO_RENAME || !DTNIsDirectory(pdth->pdtnCurrent))
        {
            oper = OPER_DOFILE;
        }
    }

    if (DTNIsRootNode(pdth->pdtnCurrent))
    {
        // we need to diskcheck the source and target because this might
        // be the first time we've seen this drive
        if (!DTDiskCheck(pdth, pcs, pdth->szSrcPath) ||
                !DTDiskCheck(pdth, pcs, pdth->szDestPath))
        {
            pcs->bAbort = TRUE;
            return 0;
        }
    }

    iError = DTValidatePathNames(pdth, oper, pcs);
    if (iError)
    {
        if (iError & OPER_ERROR)
        {
            //For connected nodes, ignore the error and silently abort the node!
            if (DTNIsConnected(pdth->pdtnCurrent))
            {
                DTAbortCurrentNode(pdth);
                return DTGoToNextNode(pdth, pcs);
            }
            else
                return iError;
        }
        else
        {
            switch (iError) 
            {
                case IDNO:
                    DTAbortCurrentNode(pdth);
                    pcs->lpfo->fAnyOperationsAborted = TRUE;
                    return DTGoToNextNode(pdth, pcs);

                case IDCANCEL:
                    // User cancelled the operation
                    pcs->bAbort = TRUE;
                    return 0;
            }
        }
    }

    pdth->oper = oper;
    return oper;
}

int  CopyMoveRetry(COPY_STATE *pcs, LPCTSTR pszDest, int error, ULARGE_INTEGER* puliFileSize);
void CopyError(LPCOPY_STATE, LPCTSTR, LPCTSTR, int, UINT, int);

void SetProgressTime(COPY_STATE *pcs);
void SetProgressText(COPY_STATE *pcs, LPCTSTR pszFrom, LPCTSTR pszTo);
void FOUndo_AddInfo(UNDOATOM *lpua, LPTSTR lpszSrc, LPTSTR lpszDest, DWORD dwAttributes);
void CALLBACK FOUndo_Release(UNDOATOM *lpua);
void FOUndo_FileReallyDeleted(LPTSTR lpszFile);
void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs);
BOOL_PTR CALLBACK FOFProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

typedef struct {
    LPTSTR lpszName;
    DWORD dwAttributes;
} FOUNDO_DELETEDFILEINFO, *LPFOUNDO_DELETEDFILEINFO;

typedef struct {
    HDPA hdpa;
    HDSA hdsa;
} FOUNDODATA, *LPFOUNDODATA;


void ReleasePCS(COPY_STATE *pcs)
{
    if (0 == InterlockedDecrement(&pcs->nRef))
    {
        SimplePidlCache_Release(&pcs->spc);
        LocalFree(pcs);
    }
}

DWORD CALLBACK AddRefPCS(COPY_STATE *pcs)
{
    return InterlockedIncrement(&pcs->nRef);
}

DWORD CALLBACK FOUIThreadProc(COPY_STATE *pcs)
{
    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- Begin"));

    Sleep(SHOW_PROGRESS_TIMEOUT);

    if (!pcs->fDone)
    {
        HWND hwndParent;
        FOUITHREADINFO fouiti = {0};

        ENTERCRITICAL;
        if (!pcs->fDone)
        {
            // need to check again within the critsec to make sure that pcs->lpfo is still valid
            fouiti.pcs = pcs;
            fouiti.wFunc = pcs->lpfo->wFunc;
            fouiti.bIsEmptyRBOp = ((pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)) ||
                    (pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES)));

            hwndParent = pcs->lpfo->hwnd;
        }
        LEAVECRITICAL;

        if (fouiti.pcs)
        {
            HWND hwnd = CreateDialogParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_MOVECOPYPROGRESS),
                    hwndParent, FOFProgressDlgProc, (LPARAM)&fouiti);
            if (hwnd)
            {
                MSG msg;
                DWORD dwShowTime;
                int iShowTimeLeft;

                // crit section to sync with main thread termination
                ENTERCRITICAL;
                if (!pcs->fDone)
                {
                    pcs->hwndProgress = hwnd;
                }
                LEAVECRITICAL;

                dwShowTime = GetTickCount();
                while (!pcs->fDone && GetMessage(&msg, NULL, 0, 0)) 
                {
                    if (!pcs->fDone && !IsDialogMessage(pcs->hwndProgress, &msg)) 
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                // if we've put it up, we need to keep it up for at least some minimal amount of time
                iShowTimeLeft = MINSHOWTIME - (GetTickCount() - dwShowTime);
                if (iShowTimeLeft > 0) 
                {
                    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- doing an extra sleep"));
                    Sleep(iShowTimeLeft);
                }

                // Keep us from doing this while other thread processing...
                ENTERCRITICAL;
                pcs->hwndProgress = NULL;
                LEAVECRITICAL;

                DestroyWindow(hwnd);
            }
        }
        else
        {
            // main thread must have finished
            ASSERT(pcs->fDone);
        }
    }
    ReleasePCS(pcs);

    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- End . Completed"));
    return 0;
}


// this queries the progress dialog for a cancel and yields.
// it also will show the progress dialog if a certain amount of time has passed
//
// returns:
//    TRUE      cacnel was pressed, abort the operation
//    FALSE     continue
BOOL FOQueryAbort(COPY_STATE *pcs)
{
    if (!pcs->bAbort && pcs->hwndProgress) 
    {
        if (pcs->hwndProgress != pcs->hwndDlgParent) 
        {
            // do this here rather than on the FOUIThreadProc so that we don't have
            // synchronization problems with this thread popping up a dialog on
            // hwndDlgParent then the progress dialog coming up afterwards on top.
            pcs->hwndDlgParent = pcs->hwndProgress;
            ShowWindow(pcs->hwndProgress, SW_SHOW);
            SetForegroundWindow(pcs->hwndProgress);
            SetFocus(GetDlgItem(pcs->hwndProgress, IDCANCEL));

            SetProgressText(pcs, pcs->dth.szSrcPath,
                    pcs->lpfo->wFunc == FO_DELETE ? NULL : pcs->dth.szDestPath);
        } 
        else 
        {
            MSG msg;

            // win95 handled messages in here.
            // we need to do the same in order to flush the input queue as well as
            // for backwards compatability.

            // we need to flush the input queue now because hwndProgress is
            // on a different thread... which means it has attached thread inputs
            // inorder to unlock the attached threads, we need to remove some
            // sort of message until there's none left... any type of message..
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (!IsDialogMessage(pcs->hwndProgress, &msg)) 
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (pcs->dth.dtAll.fChanged || pcs->dth.dtDone.fChanged) 
        {
            if (!pcs->dth.fChangePosted) 
            {
                // set the flag first because with async threads
                // the progress window could handle it and clear the
                // bit before we set it.. then we'd lose further messages
                // thinking that one was still pending
                pcs->dth.fChangePosted = TRUE;
                if (!PostMessage(pcs->hwndProgress, PDM_UPDATE, 0, 0))
                    pcs->dth.fChangePosted = FALSE;
            }
        }
    }

    return pcs->bAbort;
}




typedef struct _confdlg_data {
    LPCTSTR pFileDest;
    LPCTSTR pFileSource;
    LPCTSTR pStreamNames;
    const WIN32_FIND_DATA *pfdDest;
    const WIN32_FIND_DATA *pfdSource;

    BOOL bShowCancel;           // allow cancel out of this operation
    BOOL bShowDates;            // use date/size info in message
    UINT uDeleteWarning;        // warn that the delete's not going to the wastebasket
    BOOL bFireIcon;
    BOOL bShrinkDialog;         // should we move the buttons up to the text?
    int  nSourceFiles;          // if != 1 used to build "n files" string
    int idText;                 // if != 0 use to override string in dlg template
    CONFIRM_FLAG fConfirm;      // we will confirm things set here
    CONFIRM_FLAG fYesMask;      // these bits are cleared in fConfirm on "yes"
    // Only use fYesMask for things that should be confirmed once per operation
    CONFIRM_FLAG fYesToAllMask; // these bits are cleared in fConfirm on "yes to all"
    //COPY_STATE *pcs;
    CONFIRM_DATA *pcd;
    void (*InitConfirmDlg)(HWND hDlg, struct _confdlg_data *pcd);  // routine to initialize dialog
    BOOL bARPWarning; 
} CONFDLG_DATA;


BOOL BuildDateLine(LPTSTR pszDateLine, const WIN32_FIND_DATA *pFind, LPCTSTR pFileName)
{
    TCHAR szTemplate[64];
    TCHAR szNum[32], szTmp[64];
    WIN32_FIND_DATA fd;
    ULARGE_INTEGER liFileSize;

    if (!pFind) 
    {
        HANDLE hfind = FindFirstFile(pFileName, &fd);
        ASSERT(hfind != INVALID_HANDLE_VALUE);
        FindClose(hfind);
        pFind = &fd;
    }

    liFileSize.LowPart  = pFind->nFileSizeLow;
    liFileSize.HighPart = pFind->nFileSizeHigh;

    // There are cases where the date is 0, this is especially true when the 
    // source is from a file contents...
    if (pFind->ftLastWriteTime.dwLowDateTime || pFind->ftLastWriteTime.dwHighDateTime)
    {
        DWORD dwFlags = FDTF_LONGDATE | FDTF_RELATIVE | FDTF_LONGTIME;

        SHFormatDateTime(&pFind->ftLastWriteTime, &dwFlags, szTmp, SIZECHARS(szTmp));

        LoadString(HINST_THISDLL, IDS_DATESIZELINE, szTemplate, ARRAYSIZE(szTemplate));
        wsprintf(pszDateLine, szTemplate, StrFormatByteSize64(liFileSize.QuadPart, szNum, ARRAYSIZE(szNum)),
                szTmp);
    }
    else
    {
        // Simpy output the number to the string
        StrFormatByteSize64(liFileSize.QuadPart, pszDateLine, 64);
        if (liFileSize.QuadPart == 0)
            return FALSE;
    }
    return TRUE;    // valid data in the strings
}


// hide the cancel button and move "Yes" and "No" over to the right positions.
//
// "Yes" is IDYES
// "No"  is IDNO
//

#define HideYesToAllAndCancel(hdlg) HideConfirmButtons(hdlg, IDCANCEL)
#define HideYesToAllAndNo(hdlg) HideConfirmButtons(hdlg, IDNO)

void HideConfirmButtons(HWND hdlg, int idHide)
{
    HWND hwndCancel = GetDlgItem(hdlg, IDCANCEL);
    HWND hwndYesToAll = GetDlgItem(hdlg, IDD_YESTOALL);
    if (hwndCancel)
    {
        RECT rcCancel;
        HWND hwndNo;
        GetWindowRect(hwndCancel, &rcCancel);

        hwndNo = GetDlgItem(hdlg, IDNO);
        if (hwndNo)
        {
            RECT rcNo;
            HWND hwndYes;

            GetWindowRect(hwndNo, &rcNo);

            MapWindowRect(NULL, hdlg, &rcCancel);

            SetWindowPos(hwndNo, NULL, rcCancel.left, rcCancel.top,
                    0, 0, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);

            hwndYes = GetDlgItem(hdlg, IDYES);
            if (hwndYes)
            {
                MapWindowRect(NULL, hdlg, &rcNo);

                SetWindowPos(hwndYes, NULL, rcNo.left, rcNo.top,
                        0, 0, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);
            }
        }

        // Although the function is called "Hide", we actually destroy
        // the windows, because keyboard accelerators for hidden windows
        // are still active!
        if (hwndYesToAll)
            DestroyWindow(hwndYesToAll);
        DestroyWindow(GetDlgItem(hdlg, idHide));
    }
}

int MoveDlgItem(HWND hDlg, UINT id, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, id);
    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        MapWindowRect(NULL, hDlg, &rc);
        SetWindowPos(hwnd, NULL, rc.left, y, 0,0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        return rc.top - y; // return how much it moved
    }
    return 0;
}

void ShrinkDialog(HWND hDlg, UINT idText)
{
    RECT rc;
    int y;
    HWND hwnd;
    hwnd = GetDlgItem(hDlg, idText);
    ASSERT(hwnd);
    GetWindowRect(hwnd, &rc);
    MapWindowRect(NULL, hDlg, &rc);
    y = rc.bottom + 12;

    // move all the buttons
    MoveDlgItem(hDlg, IDNO, y);
    MoveDlgItem(hDlg, IDCANCEL, y);
    MoveDlgItem(hDlg, IDD_YESTOALL, y);
    y = MoveDlgItem(hDlg, IDYES, y);

    // now resize the entire dialog
    GetWindowRect(hDlg, &rc);
    SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, rc.bottom - y - rc.top, SWP_NOMOVE | SWP_NOZORDER |SWP_NOACTIVATE);
}

void InitConfirmDlg(HWND hDlg, CONFDLG_DATA *pcd)
{
    TCHAR szMessage[255];
    TCHAR szDeleteWarning[80];
    TCHAR szSrc[32];
    TCHAR szFriendlyName[MAX_PATH];
    SHFILEINFO  sfi;
    SHFILEINFO sfiDest;
    LPTSTR pszFileDest = NULL;
    LPTSTR pszMsg, pszSource;
    int i;
    int cxWidth;
    RECT rc;
    HDC hdc;
    HFONT hfont;
    HFONT hfontSave;
    SIZE size;

    BOOL bIsARPWarning = pcd->bARPWarning;

    ASSERT((bIsARPWarning && (pcd->nSourceFiles == 1)) || (!bIsARPWarning));

    hdc = GetDC(hDlg);
    hfont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0);
    hfontSave = (HFONT)SelectObject(hdc, hfont);

    // get the size of the text boxes
    GetWindowRect(GetDlgItem(hDlg, pcd->idText), &rc);
    cxWidth = rc.right - rc.left;

    //
    // There are cases where, if the filename has no spaces, the static text
    // control will put the entire file name with our quote character down
    // on the 2nd line.  To account for this, we subtract off the width of a
    // the quote character. Since the quote character comes from the resource
    // string, it could really be just about an character, with just about
    // any width.  So we assume its about the width of the letter 0, which
    // should be more than wide enough.
    size.cx = 0;
    GetTextExtentPoint(hdc, TEXT("0"), 1, &size);
    cxWidth -= size.cx * 2;

    if (!bIsARPWarning && !pcd->bShowCancel)
        HideYesToAllAndCancel(hDlg);

    switch (pcd->nSourceFiles) 
    {
        case -1:
            LoadString(HINST_THISDLL, IDS_SELECTEDFILES, szSrc, ARRAYSIZE(szSrc));
            pszSource = szSrc;
            break;

        case 1:
            if (bIsARPWarning)
            {
                TCHAR szTarget[MAX_PATH];
                DWORD cchFriendlyName = ARRAYSIZE(szFriendlyName);
                HRESULT hres = GetPathFromLinkFile(pcd->pFileSource, szTarget, ARRAYSIZE(szTarget));
                if (S_OK == hres)
                {
                    if (SUCCEEDED(AssocQueryString(ASSOCF_VERIFY | ASSOCF_OPEN_BYEXENAME, ASSOCSTR_FRIENDLYAPPNAME,
                                    szTarget, NULL, szFriendlyName, &cchFriendlyName)))
                    {
                        pszSource = szFriendlyName;
                    }
                    else
                    {
                        pszSource = PathFindFileName(szTarget);
                    }
                }
                else if (S_FALSE == hres)
                {
                    TCHAR szProductCode[MAX_PATH];
                    szProductCode[0] = 0;

                    if ((ERROR_SUCCESS == MsiDecomposeDescriptor(szTarget, szProductCode, NULL, NULL, NULL)) && 
                            (ERROR_SUCCESS == MsiGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szFriendlyName, &cchFriendlyName)))
                    {
                        pszSource = szFriendlyName;
                    }
                    else
                        goto UNKNOWNAPP;

                }
                else
                {
UNKNOWNAPP:
                    LoadString(HINST_THISDLL, IDS_UNKNOWNAPPLICATION, szSrc, ARRAYSIZE(szSrc));
                    pszSource = szSrc;
                }
            }
            else
            {
                SHGetFileInfo(pcd->pFileSource,
                        (pcd->fConfirm==CONFIRM_DELETE_FOLDER || pcd->fConfirm==CONFIRM_WONT_RECYCLE_FOLDER)? FILE_ATTRIBUTE_DIRECTORY : 0,
                        &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
                pszSource = sfi.szDisplayName;
                PathCompactPath(hdc, pszSource, cxWidth);
            }
            break;

        default:
            pszSource = AddCommas(pcd->nSourceFiles, szSrc, ARRAYSIZE(szSrc));
            break;
    }

    // if we're supposed to show the date info, grab the icons and format the date string
    if (pcd->bShowDates) 
    {
        SHFILEINFO  sfi2;
        TCHAR szDateSrc[64], szDateDest[64];

        BuildDateLine(szDateSrc, pcd->pfdSource, pcd->pFileSource);
        SetDlgItemText(hDlg, IDD_FILEINFO_NEW,  szDateSrc);

        BuildDateLine(szDateDest, pcd->pfdDest, pcd->pFileDest);
        SetDlgItemText(hDlg, IDD_FILEINFO_OLD,  szDateDest);

        SHGetFileInfo(pcd->pFileDest, pcd->pfdDest ? pcd->pfdDest->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdDest ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_OLD, sfi2.hIcon);

        SHGetFileInfo(pcd->pFileSource, pcd->pfdSource ? pcd->pfdSource->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdSource ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_NEW, sfi2.hIcon);
    }


    if (!bIsARPWarning)
    {
        // there are multiple controls:
        // IDD_TEXT contains regular text (normal file/folder)
        // IDD_TEXT1 - IDD_TEXT4 contain optional secondary text

        for (i = IDD_TEXT; i <= IDD_TEXT4; i++) 
        {
            if (i == pcd->idText) 
            {
                szMessage[0] = 0;
                GetDlgItemText(hDlg, i, szMessage, ARRAYSIZE(szMessage));
            } 
            else 
            {
                HWND hwndCtl = GetDlgItem(hDlg, i);
                if (hwndCtl)
                    ShowWindow(hwndCtl, SW_HIDE);
            }
        }
    }
    else
    {
        GetDlgItemText(hDlg, IDD_ARPWARNINGTEXT, szMessage, ARRAYSIZE(szMessage));
    }

    // REVIEW Is there some better way?  The code above always hides
    // this control, and I don't see a way around this

    if (pcd->pStreamNames) 
    {
        SetDlgItemText(hDlg, IDD_TEXT1, pcd->pStreamNames);
        ShowWindow(GetDlgItem(hDlg, IDD_TEXT1), SW_SHOW);
    }

    if (pcd->bShrinkDialog)
        ShrinkDialog(hDlg, pcd->idText);

    if (pcd->pFileDest) 
    {
        SHGetFileInfo(pcd->pFileDest, 0,
                &sfiDest, sizeof(sfiDest), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
        pszFileDest = sfiDest.szDisplayName;
        PathCompactPath(hdc, pszFileDest, cxWidth);
    }

    if (pcd->uDeleteWarning) 
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidl)))
        {
            SHFILEINFO fi;

            if (SHGetFileInfo((LPCTSTR)pidl, 0, &fi, sizeof(fi), SHGFI_PIDL | SHGFI_ICON |SHGFI_LARGEICON))
            {
                ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, fi.hIcon);
            }
            ILFree(pidl);
        }
        LoadString(HINST_THISDLL, pcd->uDeleteWarning, szDeleteWarning, ARRAYSIZE(szDeleteWarning));
    } 
    else
        szDeleteWarning[0] = 0;

    if (pcd->bFireIcon) 
    {
        ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_NUKEFILE), IMAGE_ICON, 0, 0, LR_LOADMAP3DCOLORS));
    }

    pszMsg = ShellConstructMessageString(HINST_THISDLL, szMessage,
            pszSource, pszFileDest, szDeleteWarning);

    if (pszMsg) 
    {
        SetDlgItemText(hDlg, pcd->idText, pszMsg);
        LocalFree(pszMsg);
    }


    SelectObject(hdc, hfontSave);
    ReleaseDC(hDlg, hdc);
}


BOOL_PTR CALLBACK ConfirmDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CONFDLG_DATA *pcd = (CONFDLG_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            pcd = (CONFDLG_DATA *)lParam;
            pcd->InitConfirmDlg(hDlg, pcd);
            break;

        case WM_DESTROY:
            // Handle case where the allocation of the PCD failed.
            if (!pcd)
                break;

            if (pcd->bShowDates) 
            {
                ReplaceDlgIcon(hDlg, IDD_ICON_NEW, NULL);
                ReplaceDlgIcon(hDlg, IDD_ICON_OLD, NULL);
            }

            ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, NULL);
            break;

        case WM_COMMAND:
            if (!pcd)
                break;

            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDNO:
                    if (GetKeyState(VK_SHIFT) < 0)      // force NOTOALL
                    {
                        // I use the fYesToAllMask here.  There used to be a fNoToAllMask but I
                        // removed it.  When you select "No To All" what you are saying is that
                        // anything I would be saying yes to all for I am actually saying "no to
                        // all" for.  I feel that it is confusing and unnecessary to have both.
                        pcd->pcd->fNoToAll |= pcd->fYesToAllMask;
                    }
                    EndDialog(hDlg, IDNO);
                    break;

                case IDD_YESTOALL:
                    // pcd is the confirmation data for just this file/folder.  pcd->pcd is the
                    // confirm data for the entire copy operation.  When we get a Yes To All we
                    // remove the coresponding bits from the entire operation.
                    pcd->pcd->fConfirm &= ~pcd->fYesToAllMask;
                    EndDialog(hDlg, IDYES);
                    break;

                case IDYES:
                    // There are some messages that we only want to tell the use once even if they
                    // select Yes instead of Yes To All.  As such we sometimes remove bits from the
                    // global confirm state even on a simple Yes.  This mask is usually zero.
                    pcd->pcd->fConfirm &= ~pcd->fYesMask;
                    EndDialog(hDlg, IDYES);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code)
            {
                case NM_RETURN:
                case NM_CLICK:
                    {
                        TCHAR szModule[MAX_PATH];
                        if (GetSystemDirectory(szModule, ARRAYSIZE(szModule)))
                        {
                            if (PathAppend(szModule, TEXT("appwiz.cpl")))
                            {
                                TCHAR szParam[1 + MAX_PATH + 2 + MAX_CCH_CPLNAME]; // See MakeCPLCommandLine function
                                TCHAR szAppwiz[64];

                                LoadString(g_hinst, IDS_APPWIZCPL, szAppwiz, SIZECHARS(szAppwiz));
                                MakeCPLCommandLine(szModule, szAppwiz, szParam, ARRAYSIZE(szParam));
                                SHRunControlPanelEx(szParam, NULL, FALSE);
                            }
                        }
                        EndDialog(hDlg, IDNO);
                    }
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void SetConfirmMaskAndText(CONFDLG_DATA *pcd, DWORD dwFileAttributes, LPCTSTR pszFile)
{
    if (IS_SYSTEM_HIDDEN(dwFileAttributes) && !ShowSuperHidden())
    {
        dwFileAttributes &= ~FILE_ATTRIBUTE_SUPERHIDDEN;
    }

    // we used to have a desktop.ini "ConfirmFileOp" flag that was set
    // to avoid this case, but there are no folders that are marked READONLY
    // or SYSTEM for a reason other than the shell, so don't consider any as such
    if ((dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)) &&
            (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        dwFileAttributes &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY);
    }

    if (dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
    {
        pcd->fConfirm = CONFIRM_SYSTEM_FILE;
        pcd->fYesToAllMask |= CONFIRM_SYSTEM_FILE;
        pcd->idText = IDD_TEXT2;
    }
    else if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        pcd->fConfirm = CONFIRM_READONLY_FILE;
        pcd->fYesToAllMask |= CONFIRM_READONLY_FILE;
        pcd->idText = IDD_TEXT1;
    }
    else if (pszFile && ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            PathIsRegisteredProgram(pszFile))
    {
        pcd->fConfirm = CONFIRM_PROGRAM_FILE;
        pcd->fYesToAllMask |= CONFIRM_PROGRAM_FILE;
        pcd->idText = IDD_TEXT3;
    }
}


void PauseAnimation(COPY_STATE *pcs, BOOL bStop)
{
    // only called from within the hwndProgress wndproc so assum it's there
    if (bStop)
        Animate_Stop(GetDlgItem(pcs->hwndProgress, IDD_ANIMATE));
    else
        Animate_Play(GetDlgItem(pcs->hwndProgress, IDD_ANIMATE), -1, -1, -1);
}

// confirm a file operation UI.
//
// this routine uses the CONFIRM_DATA in the copy state structure to
// decide if it needs to put up a dailog to confirm the given file operation.
//
// in:
//    pcs           current copy state (confirm flags, hwnd)
//    fConfirm      only one bit may be set! (operation to confirm)
//    pFileSource   source file
//    pFileDest     optional destination file
//    pfdSource
//    pfdDest       find data describing the destination
//
// returns:
//      IDYES
//      IDNO
//      IDCANCEL
//      ERROR_ (DE_) error codes (DE_MEMORY)
//
int ConfirmFileOp(HWND hwnd, COPY_STATE *pcs, CONFIRM_DATA *pcd,
        int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
        LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
        LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
        LPCTSTR pStreamNames)
{
    int dlg;
    int ret;
    CONFDLG_DATA cdd;
    CONFIRM_FLAG fConfirmType;

    if (pcs)
        nSourceFiles = pcs->nSourceFiles;

    cdd.pfdSource = pfdSource;
    cdd.pfdDest = NULL; // pfdDest is only partially filed in
    cdd.pFileSource = pFileSource;
    cdd.pFileDest = pFileDest;
    cdd.pcd = pcd;
    cdd.fConfirm      = fConfirm;       // default, changed below
    cdd.fYesMask      = 0;
    cdd.fYesToAllMask = 0;
    cdd.nSourceFiles = 1;               // default to individual file names in message
    cdd.idText = IDD_TEXT;              // default string from the dlg template
    cdd.bShowCancel = ((nSourceFiles != 1) || cDepth);
    cdd.uDeleteWarning = 0;
    cdd.bFireIcon = FALSE;
    cdd.bShowDates = FALSE;
    cdd.bShrinkDialog = FALSE;
    cdd.InitConfirmDlg = InitConfirmDlg;
    cdd.pStreamNames   = NULL;
    cdd.bARPWarning    = FALSE;

    fConfirmType = fConfirm & CONFIRM_FLAG_TYPE_MASK;

    switch (fConfirmType)
    {
        case CONFIRM_DELETE_FILE:
        case CONFIRM_DELETE_FOLDER:
            {
                BOOL bIsFolderShortcut = FALSE;

                cdd.bShrinkDialog = TRUE;
                // find data for source is in pdfDest
                if ((nSourceFiles != 1) && (pcd->fConfirm & CONFIRM_MULTIPLE))
                {
                    // this is the special CONFIRM_MULTIPLE case (usuall SHIFT+DELETE, or
                    // SHIFT+DRAG to Recycle Bin). if the user says yes to this, they 
                    // basically get no more warnings.
                    cdd.nSourceFiles = nSourceFiles;
                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE) ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO)) ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // have the fire icon and the REALLY delete warning
                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                        cdd.bFireIcon = TRUE;
                        if (pcs)
                            pcs->fFlags &= ~FOF_ALLOWUNDO;

                        if (nSourceFiles == -1)
                        {
                            // -1 indicates that there were >= MAX_EMPTY_FILES files, so we stoped counting
                            // them all up for perf. We use the more generic message in this case.
                            cdd.idText = IDD_TEXT3;
                        }
                        else
                        {
                            // use the "are you sure you want to nuke XX files?" message
                            cdd.idText = IDD_TEXT4;
                        }
                    }
                    else
                    {
                        // uDeleteWarning must be set for the proper recycle icon to be loaded.
                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                    }

                    if (!pcs || !pcs->fNoConfirmRecycle)
                    {
                        POINT ptInvoke;
                        HWND hwndPos = NULL;

                        if ((GetNumberOfMonitors() > 1) && GetCursorPos(&ptInvoke))
                        {
                            HMONITOR hMon = MonitorFromPoint(ptInvoke, MONITOR_DEFAULTTONULL);
                            if (hMon)
                            {
                                hwndPos = _CreateStubWindow(&ptInvoke, hwnd);
                            }
                        }

                        ret = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DELETE_MULTIPLE), hwndPos ? hwndPos : hwnd, ConfirmDlgProc, (LPARAM)&cdd);

                        if (hwndPos)
                        {
                            DestroyWindow(hwndPos);
                        }

                        if (ret != IDYES)
                        {
                            return IDCANCEL;
                        }
                    }

                    // clear all other possible warnings
                    pcd->fConfirm &= ~(CONFIRM_MULTIPLE | CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER);
                    cdd.fConfirm &= ~(CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER);
                    cdd.nSourceFiles = 1;       // use individual file name
                }

                SetConfirmMaskAndText(&cdd, pfdDest->dwFileAttributes, cdd.pFileSource);

                if ((pfdDest->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                        PathIsShortcut(cdd.pFileSource, pfdDest->dwFileAttributes))
                {
                    // Its a folder and its a shortcut... must be a FolderShortcut!
                    bIsFolderShortcut = TRUE;

                    // since its a folder, we need to clear out all of these warnings
                    cdd.fYesMask      |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                    cdd.fYesToAllMask |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                }

                // we want to treat FolderShortcuts as "files" instead of folders. We do this so we don't display dialogs
                // that say stuff like "do you want to delete this and all of its contents" when to the user, this looks like
                // an item instead of a folder (eg nethood shortcut).
                if ((fConfirmType == CONFIRM_DELETE_FILE) || bIsFolderShortcut)
                {
                    dlg = DLG_DELETE_FILE;
                    if ((nSourceFiles == 1) && PathIsShortcutToProgram(cdd.pFileSource))
                    {
                        dlg = DLG_DELETE_FILE_ARP;
                        cdd.idText = IDD_ARPWARNINGTEXT;
                        cdd.bShrinkDialog = FALSE;
                        cdd.bARPWarning = TRUE;
                    }

                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE)      ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO))    ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // we are really nuking it, so show the appropriate icon/dialog
                        cdd.bFireIcon = TRUE;

                        if (pcs)
                        {
                            pcs->fFlags &= ~FOF_ALLOWUNDO;
                        }

                        cdd.uDeleteWarning = IDS_FILEDELETEWARNING;

                        if (cdd.idText == IDD_TEXT)
                        {
                            cdd.idText = IDD_TEXT4;
                        }
                    }
                    else
                    {
                        // we are recycling it
                        cdd.uDeleteWarning = IDS_FILERECYCLEWARNING;
                    }

                }
                else
                {
                    // fConfirmType == CONFIRM_DELETE_FOLDER
                    if (pcs)
                    {
                        // show cancel on NEXT confirm dialog
                        pcs->nSourceFiles = -1;
                    }

                    cdd.fYesMask      |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                    cdd.fYesToAllMask |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;

                    dlg = DLG_DELETE_FOLDER;

                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE)      ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO))    ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // we are really nuking it, so show the appropriate icon/dialog
                        cdd.bFireIcon = TRUE;

                        if (pcs)
                        {
                            pcs->fFlags &= ~FOF_ALLOWUNDO;
                        }

                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                    }
                    else
                    {
                        // we are recycling it
                        cdd.uDeleteWarning = IDS_FOLDERRECYCLEWARNING;
                    }
                }

                //
                // NTRAID#NTBUG9-100335-2001/01/03-jeffreys
                // See also #128485 in the OSR v 4.1 database
                //
                // The fix for 128485 added the BBWillRecycle check below, but this
                // caused NTBUG9-100335.  These 2 bugs say the opposite things.
                // We've had several customer complaints (see dupes of 100335)
                // so I'm putting it back to the way it worked in Windows 2000.
                //
                if (pcs && pcs->fNoConfirmRecycle /*&& BBWillRecycle(cdd.pFileSource, NULL)*/)
                {
                    cdd.fConfirm = 0;
                }
            }
            break;

        case CONFIRM_WONT_RECYCLE_FILE:
        case CONFIRM_WONT_RECYCLE_FOLDER:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = fConfirmType;
            cdd.fYesToAllMask = fConfirmType | CONFIRM_MULTIPLE;

            // set the dialog to be file or folder
            if (fConfirmType == CONFIRM_WONT_RECYCLE_FOLDER)
            {
                dlg = DLG_WONT_RECYCLE_FOLDER;
            }
            else
            {
                dlg = DLG_WONT_RECYCLE_FILE;
            }
            break;

        case CONFIRM_PATH_TOO_LONG:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = CONFIRM_PATH_TOO_LONG;
            cdd.fYesToAllMask = CONFIRM_PATH_TOO_LONG | CONFIRM_MULTIPLE;
            dlg = DLG_PATH_TOO_LONG;
            break;

        case CONFIRM_WONT_RECYCLE_OFFLINE:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = fConfirmType;
            cdd.fYesToAllMask = fConfirmType | CONFIRM_MULTIPLE;
            dlg = DLG_WONT_RECYCLE_OFFLINE;
            break;

        case CONFIRM_STREAMLOSS:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles  = 1;
            cdd.idText        = IDD_TEXT;
            cdd.fConfirm      = CONFIRM_STREAMLOSS;
            cdd.fYesToAllMask = CONFIRM_STREAMLOSS;
            cdd.pStreamNames  = pStreamNames;
            dlg = DLG_STREAMLOSS_ON_COPY;
            break;

        case CONFIRM_FAILED_ENCRYPT:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles = 1;
            cdd.idText = IDD_TEXT;
            cdd.bShowCancel = TRUE;
            cdd.fConfirm = CONFIRM_FAILED_ENCRYPT;
            cdd.fYesToAllMask = CONFIRM_FAILED_ENCRYPT;
            dlg = DLG_FAILED_ENCRYPT;
            break;

        case CONFIRM_LOST_ENCRYPT_FILE:
        case CONFIRM_LOST_ENCRYPT_FOLDER:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles = 1;
            cdd.idText = IDD_TEXT;
            cdd.bShowCancel = TRUE;
            cdd.fConfirm = CONFIRM_LOST_ENCRYPT_FILE | CONFIRM_LOST_ENCRYPT_FOLDER;
            cdd.fYesToAllMask = CONFIRM_LOST_ENCRYPT_FILE | CONFIRM_LOST_ENCRYPT_FOLDER;
            if (fConfirmType == CONFIRM_LOST_ENCRYPT_FILE)
            {
                dlg = DLG_LOST_ENCRYPT_FILE;
            }
            else
            {
                dlg = DLG_LOST_ENCRYPT_FOLDER;
            }
            break;

        case CONFIRM_REPLACE_FILE:
            cdd.bShowDates = TRUE;
            cdd.fYesToAllMask = CONFIRM_REPLACE_FILE;
            SetConfirmMaskAndText(&cdd, pfdDest->dwFileAttributes, NULL);
            dlg = DLG_REPLACE_FILE;
            break;

        case CONFIRM_REPLACE_FOLDER:
            cdd.bShowCancel = TRUE;
            if (pcs) pcs->nSourceFiles = -1;        // show cancel on NEXT confirm dialog
            // this implies operations on the files
            cdd.fYesMask = CONFIRM_REPLACE_FILE;
            cdd.fYesToAllMask = CONFIRM_REPLACE_FILE | CONFIRM_REPLACE_FOLDER;
            dlg = DLG_REPLACE_FOLDER;
            break;

        case CONFIRM_MOVE_FILE:
            cdd.fYesToAllMask = CONFIRM_MOVE_FILE;
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, NULL);
            dlg = DLG_MOVE_FILE;
            break;

        case CONFIRM_MOVE_FOLDER:
            cdd.bShowCancel = TRUE;
            cdd.fYesToAllMask = CONFIRM_MOVE_FOLDER;
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, cdd.pFileSource);
            dlg = DLG_MOVE_FOLDER;
            break;

        case CONFIRM_RENAME_FILE:
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, NULL);
            dlg = DLG_RENAME_FILE;
            break;

        case CONFIRM_RENAME_FOLDER:
            cdd.bShowCancel = TRUE;
            if (pcs) pcs->nSourceFiles = -1;        // show cancel on NEXT confirm dialog
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, cdd.pFileSource);
            dlg = DLG_RENAME_FOLDER;
            break;

        default:
            DebugMsg(DM_WARNING, TEXT("bogus confirm option"));
            return IDCANCEL;
    }

    // Does this operation need to be confirmed?
    if (pcd->fConfirm & cdd.fConfirm)
    {
        // Has the user already said "No To All" for this operation?
        if ((pcd->fNoToAll & cdd.fConfirm) == cdd.fConfirm)
        {
            ret = IDNO;
        }
        else
        {
            // HACK for multimon, make sure the file operation dialog box comes
            // up on the correct monitor
            POINT ptInvoke;
            HWND hwndPos = NULL;

            if ((GetNumberOfMonitors() > 1) && GetCursorPos(&ptInvoke))
            {
                HMONITOR hMon = MonitorFromPoint(ptInvoke, MONITOR_DEFAULTTONULL);
                if (hMon)
                {
                    hwndPos = _CreateStubWindow(&ptInvoke, hwnd);
                }
            }
            ret = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(dlg), (hwndPos ? hwndPos : hwnd), ConfirmDlgProc, (LPARAM)&cdd);

            if (hwndPos)
                DestroyWindow(hwndPos);

            if (ret == -1)
                ret = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        ret = IDYES;
    }

    return ret;
}

//
//  DTNIsParentConnectOrigin()
//
//      When a folder ("c:\foo files") is moved to a different drive ("a:\"), the source and the
//  destinations have different roots, and therefore the "fRecursive" flag is turned ON by default.
//  This results in confirmations obtained for the individual files ("c:\foo files\aaa.gif") 
// rather than the folder itself. We need to first find the parent and then save the confirmation 
// in the connected element of it's parent. This function gets the top-most parent and then
// checks to see if it is a connect origin and if so returns that parent pointer.
//

PDIRTREENODE DTNGetConnectOrigin(PDIRTREENODE pdtn)
{
    PDIRTREENODE    pdtnParent = pdtn;

    //Get the top-level parent of the given node.
    while (pdtn)
    {
        pdtnParent = pdtn;
        pdtn = pdtn->pdtnParent;
    }

    //Now check if the parent is a connect origin.
    if (pdtnParent && DTNIsConnectOrigin(pdtnParent))
        return pdtnParent; //If so, return him.
    else
        return NULL;
}

//
// CachedConfirmFileOp()
//
//    When a file("foo.htm") is moved/copied, we may put up a confirmation dialog in case 
// of a conflict and the end-user might have responded saying "Yes", "no" etc., When the 
// corresponding connected element ("foo files") is also moved/copied etc., we should NOT put up
// a confirmation dialog again. We must simply store the answer to the original confirmation and
// use it later. 
//  
//  What this function does is: if the given node is a connected element, it simply retrieves the
// confirmation for the original operation and returns.  If the given element is NOT a connected 
// element, then this function calls the ConfirmFileOp and stores the confirmation result in 
// it's connected element sothat, it later it can be used by the connected element.
//

int CachedConfirmFileOp(HWND hwnd, COPY_STATE *pcs, CONFIRM_DATA *pcd,
        int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
        LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
        LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
        LPCTSTR pStreamNames)

{
    int result;

    //See if this is a connected item.
    if (DTNIsConnected(pcs->dth.pdtnCurrent))
    {
        // Since this is a connected item, the confirmation must already have been obtained from
        // the user and get it from the cache!
        result = DTNGetConfirmationResult(pcs->dth.pdtnCurrent);
    }
    else
    {
        PDIRTREENODE    pdtnConnectOrigin;

        result = ConfirmFileOp(hwnd, pcs, pcd, nSourceFiles, cDepth, fConfirm, pFileSource, 
                pfdSource, pFileDest, pfdDest, pStreamNames);

        //Check if this node has a connection.
        if (pdtnConnectOrigin = DTNGetConnectOrigin(pcs->dth.pdtnCurrent))
        {
            pdtnConnectOrigin->pdtnConnected->ConnectedInfo.dwConfirmation = result;

            // PERF: Can we check for the result to be IDCANCEL or IDNO and if so make the
            // connected node a Dummy? Currently this won't work because current code assumes
            // that dummy nodes do not have children. This connected node might have some children.
            // if ((result == IDCANCEL) || (result == IDNO))
            //    pdtnConnectOrigin->pdtnConnected->fDummy = TRUE;
        }

    }

    return result;
}

void GuessAShortName(LPCTSTR p, LPTSTR szT)
{
    int i, j, fDot, cMax;

    for (i = j = fDot = 0, cMax = 8; *p; p++)
    {
        if (*p == TEXT('.'))
        {
            // if there was a previous dot, step back to it
            // this way, we get the last extension
            if (fDot)
                i -= j+1;

            // set number of chars to 0, put the dot in
            j = 0;
            szT[i++] = TEXT('.');

            // remember we saw a dot and set max 3 chars.
            fDot = TRUE;
            cMax = 3;
        }
        else if (j < cMax && (PathGetCharType(*p) & GCT_SHORTCHAR))
        {
            // if *p is a lead byte, we move forward one more
            if (IsDBCSLeadByte(*p))
            {
                szT[i] = *p++;
                if (++j >= cMax)
                    continue;
                ++i;
            }
            j++;
            szT[i++] = *p;
        }
    }
    szT[i] = 0;
}

/* GetNameDialog
 *
 *  Runs the dialog box to prompt the user for a new filename when copying
 *  or moving from HPFS to FAT.
 */

typedef struct {
    LPTSTR pszDialogFrom;
    LPTSTR pszDialogTo;
    BOOL bShowCancel;
} GETNAME_DATA;

BOOL_PTR CALLBACK GetNameDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szT[14];
    TCHAR szTo[MAX_PATH];
    GETNAME_DATA * pgn = (GETNAME_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) 
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pgn = (GETNAME_DATA *)lParam;

            // inform the user of the old name
            PathSetDlgItemPath(hDlg, IDD_FROM, pgn->pszDialogFrom);

            // directory the file will go into
            PathRemoveFileSpec(pgn->pszDialogTo);
            PathSetDlgItemPath(hDlg, IDD_DIR, pgn->pszDialogTo);

            // generate a guess for the new name
            GuessAShortName(PathFindFileName(pgn->pszDialogFrom), szT);

            lstrcpy(szTo, pgn->pszDialogTo);
            PathAppend(szTo, szT);
            // make sure that name is unique
            PathYetAnotherMakeUniqueName(szTo, szTo, NULL, NULL);
            SetDlgItemText(hDlg, IDD_TO, PathFindFileName(szTo));
            SendDlgItemMessage(hDlg, IDD_TO, EM_LIMITTEXT, 13, 0L);

            SHAutoComplete(GetDlgItem(hDlg, IDD_TO), 0);

            if (!pgn->bShowCancel)
                HideYesToAllAndNo(hDlg);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDD_YESTOALL:
                case IDYES:
                    GetDlgItemText(hDlg, IDD_TO, szT, ARRAYSIZE(szT));
                    PathAppend(pgn->pszDialogTo, szT);
                    PathQualify(pgn->pszDialogTo);
                    // fall through
                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg,GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                case IDD_TO:
                    {
                        LPCTSTR p;
                        GetDlgItemText(hDlg, IDD_TO, szT, ARRAYSIZE(szT));
                        for (p = szT; *p; p = CharNext(p)) 
                        {
                            if (!(PathGetCharType(*p) & GCT_SHORTCHAR))
                                break;
                        }

                        EnableWindow(GetDlgItem(hDlg,IDYES), ((!*p) && (p != szT)));
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetNameDialog(HWND hwnd, COPY_STATE *pcs, BOOL fMultiple,UINT wOp, LPTSTR pFrom, LPTSTR pTo)
{
    int iRet;

    // if we don't want to confirm this, just mock up a string and return ok
    if (!(pcs->cd.fConfirm & CONFIRM_LFNTOFAT)) 
    {
        TCHAR szTemp[MAX_PATH];
        GuessAShortName(PathFindFileName(pFrom), szTemp);
        PathRemoveFileSpec(pTo);
        PathAppend(pTo, szTemp);
        // make sure that name is unique
        PathYetAnotherMakeUniqueName(pTo, pTo, NULL, NULL);
        iRet = IDYES;
    } 
    else 
    {
        GETNAME_DATA gn;
        gn.pszDialogFrom = pFrom;
        gn.pszDialogTo = pTo;
        gn.bShowCancel = fMultiple;

        iRet = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_LFNTOFAT), hwnd, GetNameDlgProc, (LPARAM)(GETNAME_DATA *)&gn);
        if (iRet == IDD_YESTOALL)
            pcs->cd.fConfirm &= ~CONFIRM_LFNTOFAT;
    }
    return iRet;
}

STDAPI_(void) SHFreeNameMappings(void *hNameMappings)
{
    HDSA hdsaRenamePairs = (HDSA)hNameMappings;
    int i;

    if (!hdsaRenamePairs)
        return;

    i = DSA_GetItemCount(hdsaRenamePairs) - 1;
    for (; i >= 0; i--)
    {
        SHNAMEMAPPING FAR* prp = DSA_GetItemPtr(hdsaRenamePairs, i);

        LocalFree(prp->pszOldPath);
        LocalFree(prp->pszNewPath);
    }

    DSA_Destroy(hdsaRenamePairs);
}

void _ProcessNameMappings(LPTSTR pszTarget, HDSA hdsaRenamePairs)
{
    int i;

    if (!hdsaRenamePairs)
        return;

    for (i = DSA_GetItemCount(hdsaRenamePairs) - 1; i >= 0; i--)
    {
        TCHAR  cTemp;
        SHNAMEMAPPING FAR* prp = DSA_GetItemPtr(hdsaRenamePairs, i);

        //  I don't call StrCmpNI 'cause I already know cchOldPath, and
        //  it has to do a couple of lstrlen()s to calculate it.
        cTemp = pszTarget[prp->cchOldPath];
        pszTarget[prp->cchOldPath] = 0;

        //  Does the target match this collision renaming entry?
        // NOTE: We are trying to compare a path to a path.  prp->pszOldPath
        // does not have a trailing "\" character, so this isn't covered
        // by the lstrcmpi below.  As such, cTemp had best be the path
        // seperator character to ensure that the modified pszTarget is actually
        // a path and not a filename or a longer path name that doesn't match
        // but happens to start with the same characters as prp->pszOldPath.
        if ((cTemp == TEXT('\\')) && !lstrcmpi(pszTarget, prp->pszOldPath))
        {
            // Get subtree string of the target.
            TCHAR *pszSubTree = &(pszTarget[prp->cchOldPath + 1]);

            // Generate the new target path.
            PathCombine(pszTarget, prp->pszNewPath, pszSubTree);

            break;
        }
        else
        {
            // Restore the trounced character.
            pszTarget[prp->cchOldPath] = cTemp;
        }
    }
}

/* Sets the status dialog item in the modeless status dialog box. */

// used for both the drag drop status dialogs and the manual user
// entry dialogs so be careful what you change

void SetProgressText(COPY_STATE *pcs, LPCTSTR pszFrom, LPCTSTR pszTo)
{
    HWND hwndProgress = pcs->hwndProgress;

    if (hwndProgress && !(pcs->fFlags & FOF_SIMPLEPROGRESS))
    {
        TCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
        LPTSTR pszMsg = NULL;

        HDC hdc;
        HFONT hfont;
        HFONT hfontSave;
        RECT rc;
        int cxWidth;
        SIZE size;

        //
        // Compute the size we can use for our file names (REVIEW: Cache this result?)
        //
        hdc = GetDC(hwndProgress);
        hfont = (HFONT)SendMessage(hwndProgress, WM_GETFONT, 0, 0);
        hfontSave = (HFONT)SelectObject(hdc, hfont);

        GetWindowRect(GetDlgItem(hwndProgress, IDD_TONAME), &rc);
        cxWidth = rc.right - rc.left;

        if (NULL != pszTo && pcs->fFlags & FOF_MULTIDESTFILES)
        {
            lstrcpy(szFrom, pszTo);
        }
        else
        {
            lstrcpy(szFrom, pszFrom);
        }
        PathStripPath(szFrom);
        PathCompactPath(hdc, szFrom, cxWidth);
        SetDlgItemText(hwndProgress, IDD_NAME, szFrom);

        lstrcpy(szFrom, pszFrom);
        if (szFrom[0]) 
        {
            LPTSTR pszResource = MAKEINTRESOURCE(IDS_FROM);
            LPTSTR pszToUsable = NULL;

            szTo[0] = TEXT('\0');
            if (pszTo)
            {
                pszToUsable = szTo;
                pszResource = MAKEINTRESOURCE(IDS_FROMTO);
            }

            pszMsg = ShellConstructMessageString(HINST_THISDLL,
                    pszResource, "", pszToUsable);

            if (NULL != pszMsg)
            {
                GetTextExtentPoint(hdc, pszMsg, lstrlen(pszMsg), &size);
                cxWidth -= size.cx;
                LocalFree(pszMsg);
            }

            //
            // Now build the file names
            //
            PathRemoveFileSpec(szFrom);
            PathStripPath(szFrom);

            if (pszTo)
            {
                lstrcpy(szTo, pszTo);
                PathRemoveFileSpec(szTo);
                PathStripPath(szTo);

                PathCompactPath(hdc, szFrom, cxWidth/2);
                PathCompactPath(hdc, szTo, cxWidth/2);
            }
            else
            {
                PathCompactPath(hdc, szFrom, cxWidth);
            }

            //
            // Now create the real message
            //
            pszMsg = ShellConstructMessageString(HINST_THISDLL,
                    pszResource, szFrom, pszToUsable);

        } 
        else if (!pcs->fDTBuilt) 
        {
            TCHAR szFunc[80];
            if (LoadString(HINST_THISDLL, FOFuncToStringID(pcs->lpfo->wFunc),
                        szFunc, ARRAYSIZE(szFunc))) 
            {
                pszMsg = ShellConstructMessageString(HINST_THISDLL,
                        MAKEINTRESOURCE(IDS_PREPARINGTO), szFunc);
            }
        }

        if (pszMsg)
        {
            SetDlgItemText(hwndProgress, IDD_TONAME, pszMsg);
            LocalFree(pszMsg);
        }

        SelectObject(hdc, hfontSave);
        ReleaseDC(hwndProgress, hdc);

    }
}

void SetProgressTimeEst(COPY_STATE *pcs, DWORD dwTimeLeft)
{
    TCHAR szFmt[60];
    TCHAR szOut[70];
    DWORD dwTime;

    if (pcs->hwndProgress) 
    {
        if (dwTimeLeft > 4*60*60)           // 4 hours and over you get no text
        {
            szFmt[0] = TEXT('\0');
        }
        else if (dwTimeLeft > 60)
        {
            // Note that dwTime is at least 2, so we only need a plural form
            LoadString(HINST_THISDLL, IDS_TIMEEST_MINUTES, szFmt, ARRAYSIZE(szFmt));
            dwTime = (dwTimeLeft / 60) + 1;
        }
        else
        {
            LoadString(HINST_THISDLL, IDS_TIMEEST_SECONDS, szFmt, ARRAYSIZE(szFmt));
            // Round up to 5 seconds so it doesn't look so random
            dwTime = ((dwTimeLeft+4) / 5) * 5;
        }

        wsprintf(szOut, szFmt, dwTime);

        SetDlgItemText(pcs->hwndProgress, IDD_TIMEEST, szOut);
    }
}


// this updates the animation, which could change because we could switch between 
// doing a move to recycle bin and really nuke if the file/folder was bigger that
// the allowable size of the recycle bin.
void UpdateProgressAnimation(COPY_STATE *pcs)
{
    if (pcs->hwndProgress && pcs->lpfo)
    {
        INT_PTR idAni, idAniCurrent;
        HWND hwndAnimation;
        switch (pcs->lpfo->wFunc) 
        {
            case FO_DELETE:
                if ((pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)) ||
                        (pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES))) 
                {
                    idAni = IDA_FILENUKE;
                    break;
                } 
                else if (!(pcs->fFlags & FOF_ALLOWUNDO)) 
                {
                    idAni = IDA_FILEDELREAL;
                    break;
                } // else fall through to default

            default:
                idAni = (IDA_FILEMOVE + (int)pcs->lpfo->wFunc - FO_MOVE);
        }

        hwndAnimation = GetDlgItem(pcs->hwndProgress,IDD_ANIMATE);

        idAniCurrent = (INT_PTR) GetProp(hwndAnimation, TEXT("AnimationID"));

        if (idAni != idAniCurrent)
        {
            // the one we should be using is different from the one we have, 
            // so update it

            // close the old clip
            Animate_Close(hwndAnimation);

            // open the new one
            Animate_Open(hwndAnimation, idAni);

            // if the window is enabled, start the new animation playing
            if (IsWindowEnabled(pcs->hwndProgress))
                Animate_Play(hwndAnimation, -1, -1, -1);

            // set the current idAni
            SetProp(hwndAnimation, TEXT("AnimationID"), (HANDLE)idAni);

            // at the same time we update the animation, we also update the text,
            // so that the two will always be in sync
            SetProgressText(pcs, pcs->dth.szSrcPath, pcs->lpfo->wFunc == FO_DELETE ? NULL : pcs->dth.szDestPath);
        }
    }
}


void SendProgressMessage(COPY_STATE *pcs, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (pcs->hwndProgress)
        SendDlgItemMessage(pcs->hwndProgress, IDD_PROBAR, uMsg, wParam, lParam);
}


//
// creates folder and all parts of the path if necessary (parent does not need
// to exists) and verifies that the contents of the folder will be visibile.
//
// in:
//    hwnd      hwnd to post UI on
//    pszPath   full path to create
//    psa       security attributes
//
// returns:
//      ERROR_SUCCESS (0)   success
//      ERROR_              failure
//

STDAPI_(int) SHCreateDirectoryEx(HWND hwnd, LPCTSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    int ret = ERROR_SUCCESS;

    if (PathIsRelative(pszPath))
    {
        // if not a "full" path bail
        // to ensure that we dont create a dir in the current working directory
        SetLastError(ERROR_BAD_PATHNAME);
        return ERROR_BAD_PATHNAME;
    }

    if (!Win32CreateDirectory(pszPath, psa)) 
    {
        TCHAR *pEnd, *pSlash, szTemp[MAX_PATH];

        ret = GetLastError();

        // There are certain error codes that we should bail out here
        // before going through and walking up the tree...
        switch (ret)
        {
            case ERROR_FILENAME_EXCED_RANGE:
            case ERROR_FILE_EXISTS:
            case ERROR_ALREADY_EXISTS:
                return ret;
        }

        lstrcpyn(szTemp, pszPath, ARRAYSIZE(szTemp));
        pEnd = PathAddBackslash(szTemp); // for the loop below

        // assume we have 'X:\' to start this should even work
        // on UNC names because will will ignore the first error

        pSlash = szTemp + 3;

        // create each part of the dir in order

        while (*pSlash) 
        {
            while (*pSlash && *pSlash != TEXT('\\'))
                pSlash = CharNext(pSlash);

            if (*pSlash) 
            {
                ASSERT(*pSlash == TEXT('\\'));

                *pSlash = 0;    // terminate path at seperator

                ret = Win32CreateDirectory(szTemp, pSlash + 1 == pEnd ? psa : NULL) ? ERROR_SUCCESS : GetLastError();

            }
            *pSlash++ = TEXT('\\');     // put the seperator back
        }
    }

    if (ERROR_SUCCESS != ret)
    {
        // We failed, so let's try to display error UI.
        if (hwnd && ERROR_CANCELLED != ret)
        {               
            SHSysErrorMessageBox(hwnd, NULL, IDS_CANNOTCREATEFOLDER, ret,
                    pszPath ? PathFindFileName(pszPath) : NULL, 
                    MB_OK | MB_ICONEXCLAMATION);

            ret = ERROR_CANCELLED; // Indicate we already displayed Error UI.
        }
    }   
    return ret;
}

STDAPI_(int) SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    return SHCreateDirectoryEx(hwnd, pszPath, NULL);
}

#ifdef UNICODE
STDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    WCHAR wsz[MAX_PATH];
    SHAnsiToUnicode(pszPath, wsz, SIZECHARS(wsz));
    return SHCreateDirectoryEx(hwnd, wsz, psa);
}
#else
STDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    char sz[MAX_PATH];
    SHUnicodeToAnsi(pszPath, sz, SIZECHARS(sz));
    return SHCreateDirectoryEx(hwnd, sz, psa);
}
#endif


// call MPR to find out the speed of a given path
//
// returns
//        0 for unknown
//      144 for 14.4 modems
//       96 for 9600
//       24 for 2400
//
// if the device does not return a speed we return 0
//

DWORD GetPathSpeed(LPCTSTR pszPath)
{
    NETCONNECTINFOSTRUCT nci;
    NETRESOURCE nr;
    TCHAR szPath[MAX_PATH];

    lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
    PathStripToRoot(szPath);    // get a root to this path

    memset(&nci, 0, sizeof(nci));
    nci.cbStructure = sizeof(nci);

    memset(&nr, 0, sizeof(nr));
    if (PathIsUNC(szPath))
        nr.lpRemoteName = szPath;
    else
    {
        // Don't bother for local drives
        if (!IsRemoteDrive(DRIVEID(szPath)))
            return 0;

        // we are passing in a local drive and MPR does not like us to pass a
        // local name as Z:\ but only wants Z:
        szPath[2] = 0;   // Strip off after character and :
        nr.lpLocalName = szPath;
    }

    // dwSpeed is returned by MultinetGetConnectionPerformance
    MultinetGetConnectionPerformance(&nr, &nci);

    return nci.dwSpeed;
}


DWORD CopyCallbackProc(LARGE_INTEGER liTotSize, LARGE_INTEGER liBytes,
        LARGE_INTEGER liStreamSize, LARGE_INTEGER liStreamBytes,
        DWORD dwStream, DWORD dwCallback,
        HANDLE hSource, HANDLE hDest, void *pv)
{
    COPY_STATE *pcs = (COPY_STATE *)pv;

    DebugMsg(DM_TRACE, TEXT("CopyCallbackProc[%08lX], totsize=%08lX, bytes=%08lX"),
            dwCallback,  liTotSize.LowPart, liBytes.LowPart);

    if (FOQueryAbort(pcs))
        return PROGRESS_CANCEL;

    DTSetFileCopyProgress(&pcs->dth, liBytes);

    if (pcs->fInitialize)
    {
        // preserve the create date when moving across volumes, otherwise use the
        // create date the file system picked when we did the CreateFile()
        // always preserve modified date (ftLastWriteTime)
        // bummer is we loose accuracy when going to VFAT compared to NT servers

        SetFileTime((HANDLE)hDest, (pcs->lpfo->wFunc == FO_MOVE) ? &pcs->pfd->ftCreationTime : NULL,
                NULL, &pcs->pfd->ftLastWriteTime);

        pcs->fInitialize = FALSE;
    }

    switch (dwCallback)
    {
        case CALLBACK_STREAM_SWITCH:
            break;
        case CALLBACK_CHUNK_FINISHED:
            break;
        default:
            break;
    }
    return PROGRESS_CONTINUE;
}

// copy the SECURITY_DESCRIPTOR for two files
//
// in:
//      pszSource       fully qualified source path
//      pszDest         fully qualified destination path
//
// returns:
//      0       ERROR_SUCCESS
//      WIN32 error codes
//

    DWORD 
CopyFileSecurity(LPCTSTR pszSource, LPCTSTR pszDest)
{
    DWORD err = ERROR_SUCCESS;
    BOOL fRet = TRUE;
    BYTE buf[512];

    //    arbitrarily saying do everything we can
    //    except SACL_SECURITY_INFORMATION because
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) buf;
    DWORD cbPsd = sizeof(buf);

    if (!SHRestricted(REST_FORCECOPYACLWITHFILE))
    {
        // shell restriction so return access denied?
        return ERROR_ACCESS_DENIED;
    }    

    fRet = GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd);
    if (!fRet)
    {
        err = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == err)
        {
            // just need to resize the buffer and try again

            psd = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbPsd);
            if (psd)
            {
                fRet = GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd);
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if (fRet)
    {
        fRet = SetFileSecurity(pszDest, si, psd);
        if (!fRet)
            err = GetLastError();
    }

    if (psd && psd != buf)
        LocalFree(psd);

    if (fRet)
        return ERROR_SUCCESS;

    return err;
}

// reset the SECURITY_DESCRIPTOR on a file or directory
//
// in:
//      pszDest         fully qualified destination path
//
// returns:
//      0       ERROR_SUCCESS
//      WIN32 error codes
//

    DWORD 
ResetFileSecurity(LPCTSTR pszDest)
{
    DWORD err = ERROR_SUCCESS;

    if (!SHRestricted(REST_FORCECOPYACLWITHFILE))
    {
        ACL acl;
        InitializeAcl(&acl, sizeof(acl), ACL_REVISION);

        // TreeResetNamedSecurityInfo has a callback mechanism, but
        // we currently don't use it. Note that the paths passed to
        // the callback look like
        //     "\Device\HarddiskVolume1\dir\name"

        err = TreeResetNamedSecurityInfo((LPTSTR)pszDest,
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &acl,
                NULL,
                FALSE, // KeepExplicit (perms on children)
                NULL,
                ProgressInvokeNever,
                NULL);
    }

    return err;
}

//
// in:
//      hwnd            Window to report things to.
//      pszSource       fully qualified source path
//      pszDest         fully qualified destination path
//      pfd             source file find data (size/date/time/attribs)
//
// returns:
//      ERROR_SUCCESS (0)
//      other Win32 ERROR_ codes
//

UINT FileCopy(COPY_STATE *pcs, LPCTSTR pszSource, LPCTSTR pszDest, const WIN32_FIND_DATA *pfd, BOOL fCreateAlways)
{
    UINT iRet = ERROR_CANCELLED;
    BOOL fRetryPath = FALSE;
    BOOL fRetryAttr = FALSE;
    BOOL fCopyOrMoveSucceeded = FALSE;
    BOOL fSecurityObtained = FALSE;
    DWORD dwCopyFlags;

    // Buffers for security info

    BYTE rgbSecurityDescriptor[512];
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) rgbSecurityDescriptor;
    DWORD cbPsd = sizeof(rgbSecurityDescriptor);

    // Make sure we can start
    if (FOQueryAbort(pcs))
        return ERROR_CANCELLED;

    //
    // Now do the file copy/move
    //

    // Get the security info from the source file.  If there is a problem
    // (e.g. the file is on FAT) we ignore it and proceed with the copy/move.

    if (!(pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS))
    {
        if (SHRestricted(REST_FORCECOPYACLWITHFILE))
        {
            if (GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd))
            {
                fSecurityObtained = TRUE;
            }
            else
            {
                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    psd = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbPsd);
                    if (psd)
                    {
                        if (GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd))
                        {
                            fSecurityObtained = TRUE;
                        }
                    }
                }
            }
        }
    }

TryCopyAgain:

    pcs->fInitialize = TRUE;
    pcs->pfd = pfd;
    SetProgressText(pcs, pszSource, pszDest);

    dwCopyFlags = 0;
    if (pcs->fLostEncryptOk)
    {
        dwCopyFlags |= COPY_FILE_ALLOW_DECRYPTED_DESTINATION;
    }

    if (FO_MOVE == pcs->lpfo->wFunc)
    {
        fCopyOrMoveSucceeded = MoveFileWithProgress(pszSource, pszDest, CopyCallbackProc, pcs, MOVEFILE_COPY_ALLOWED | (fCreateAlways ? MOVEFILE_REPLACE_EXISTING : 0));
    }
    else
    {
        if (!fCreateAlways)
        {
            dwCopyFlags |= COPY_FILE_FAIL_IF_EXISTS;
        }
        fCopyOrMoveSucceeded = CopyFileEx(pszSource, pszDest, CopyCallbackProc, pcs, &pcs->bAbort, dwCopyFlags);
    }

    if (!fCopyOrMoveSucceeded)  
    {
        int iLastError = (int)GetLastError();

        DebugMsg(TF_DEBUGCOPY, TEXT("FileCopy() failed, get last error returned 0x%08x"), iLastError);

        switch (iLastError)
        {
            // Let the caller handle this one
            case ERROR_FILE_EXISTS:
            case ERROR_ALREADY_EXISTS: // nt5 221893 CopyFileEx now returns this for some reason...
                iRet = ERROR_FILE_EXISTS;
                goto Exit;

            case ERROR_DISK_FULL:
                if (PathIsUNC(pszDest) || !IsRemovableDrive(DRIVEID(pszDest)) || PathIsSameRoot(pszDest,pszSource))
                {
                    break;
                }

                iLastError = ERROR_DISK_FULL;
                // Fall through

            case ERROR_PATH_NOT_FOUND:
                if (!fRetryPath)
                {
                    // ask the user to stick in another disk or empty wastebasket
                    ULARGE_INTEGER ulFileSize;
                    ulFileSize.LowPart = pfd->nFileSizeLow;
                    ulFileSize.HighPart = pfd->nFileSizeHigh;
                    iLastError = CopyMoveRetry(pcs, pszDest, iLastError, &ulFileSize);
                    if (!iLastError)
                    {
                        fRetryPath = TRUE;
                        goto TryCopyAgain;
                    }
                    CopyError(pcs, pszSource, pszDest, (UINT)iLastError | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    iRet = ERROR_CANCELLED;
                    goto Exit;
                }
                break;

            case ERROR_ENCRYPTION_FAILED:
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED && FALSE == pcs->fLostEncryptOk)
                {
                    int result;
                    result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                            &pcs->cd, pcs->nSourceFiles,
                            FALSE,
                            CONFIRM_LOST_ENCRYPT_FILE,
                            pszSource, pfd, pszDest, NULL, NULL);

                    switch (result)
                    {
                        case IDYES:
                            pcs->fLostEncryptOk = TRUE;
                            goto TryCopyAgain;

                        case IDNO:
                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            iRet = result;
                            break;

                        default:
                            iRet = result;
                            break;
                    }
                }
                break;

            case ERROR_ACCESS_DENIED:
                // check if the filename is too long
                if (lstrlen(PathFindFileName(pszSource)) + lstrlen(pszDest) >= MAX_PATH)
                {
                    iLastError = DE_FILENAMETOOLONG;
                }
                else if (!fRetryAttr)
                {
                    // If the file is readonly, reset the readonly attribute
                    // and have another go at it
                    DWORD dwAttributes = GetFileAttributes(pszDest);
                    if (0xFFFFFFFF != dwAttributes)
                    {
                        dwAttributes &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
                        if (SetFileAttributes(pszDest, dwAttributes))
                        {
                            fRetryAttr = TRUE;
                            goto TryCopyAgain;
                        }
                    }

                    // GetFileAttributes() 10 lines above clobers GetLastError() and CopyError()
                    // needs it.
                    SetLastError(iLastError);
                }
                break;
        }

        if (!pcs->bAbort)
        {
            CopyError(pcs, pszSource, pszDest, iLastError, FO_COPY, OPER_DOFILE);
        }

        iRet = ERROR_CANCELLED;  // error already reported
        goto Exit;
    }

    // If copying from a CDRom - clear the read-only bit
    if (pcs->fFromCDRom)
    {
        SetFileAttributes(pszDest, pfd->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);
    }

    // Set the source's security on the destination, ignoring any error.
    if (fSecurityObtained)
    {
        SetFileSecurity(pszDest, si, psd);
    }


    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszDest, NULL);

    if (FO_MOVE == pcs->lpfo->wFunc)
    {
        // Let windows waiting on notifications of Source know of change.  We have to check
        // to see if the file is actually gone in order to tell if it actually moved or not.

        if (!PathFileExists(pszSource))
            SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, pszSource, NULL);
    }
    else if (0 == StrCmpIC(pfd->cFileName, TEXT("desktop.ini")))
    {
        // clean out stuff from the desktop.ini
        WritePrivateProfileSection(TEXT("DeleteOnCopy"), NULL, pszDest);
    }

    iRet = ERROR_SUCCESS;   // 0

Exit:

    // If we had to alloc a buffer for the security descriptor,
    // free it now.

    if (psd && (rgbSecurityDescriptor != psd))
        LocalFree(psd);

    return iRet;
}

// note: this is a very slow call
DWORD GetFreeClusters(LPCTSTR szPath)
{
    DWORD dwFreeClus;
    DWORD dwTemp;

    if (GetDiskFreeSpace(szPath, &dwTemp, &dwTemp, &dwFreeClus, &dwTemp))
        return dwFreeClus;
    else
        return (DWORD)-1;
}

// note: this is a very slow call
BOOL TotalCapacity(LPCTSTR szPath, ULARGE_INTEGER *puliDiskSize)
{
    int idDrive = PathGetDriveNumber(szPath);
    if (idDrive != -1) 
    {
        TCHAR szDrive[5];
        ULARGE_INTEGER ullDiskFreeForUser;

        PathBuildRoot(szDrive, idDrive);

        return GetDiskFreeSpaceEx(szDrive, &ullDiskFreeForUser, puliDiskSize, NULL);
    }

    return FALSE;
}


typedef struct
{
    LPTSTR pszTitle;
    LPTSTR pszText;
} DISKERRORPARAM;

BOOL_PTR CALLBACK DiskErrDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
            {
                DISKERRORPARAM *pDiskError = (DISKERRORPARAM *) lParam;
                if (pDiskError)
                {
                    SetWindowText(hDlg, pDiskError->pszTitle);
                    SetDlgItemText(hDlg, IDC_DISKERR_EXPLAIN, pDiskError->pszText);
                }
                Static_SetIcon(GetDlgItem(hDlg, IDC_DISKERR_STOPICON), 
                        LoadIcon(NULL, IDI_HAND));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                case IDC_DISKERR_LAUNCHCLEANUP:
                    EndDialog (hDlg, LOWORD(wParam));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


void DisplayFileOperationError(HWND hParent, int idVerb, int wFunc, int nError, LPCTSTR pszReason, LPCTSTR pszPath, LPCTSTR pszDest)
{
    TCHAR szBuffer[80];
    DISKERRORPARAM diskparams;

    // Grab title from resource 
    if (LoadString(HINST_THISDLL, IDS_FILEERROR + wFunc, szBuffer, ARRAYSIZE(szBuffer)))
    {
        diskparams.pszTitle = szBuffer;
    }
    else
    { 
        diskparams.pszTitle = NULL;
    }

    // Build Message to display
    diskparams.pszText = ShellConstructMessageString(HINST_THISDLL, 
            MAKEINTRESOURCE(idVerb), pszReason, PathFindFileName(pszPath));

    if (diskparams.pszText)
    {
        int idDrive = DriveIDFromBBPath(pszDest);
        //if we want to show Disk cleanup do our stuff, otherwise do MessageBox
        if (nError == ERROR_DISK_FULL && 
                IsBitBucketableDrive(idDrive) &&
                !PathIsUNC(pszDest) &&
                GetDiskCleanupPath(NULL, 0))
        {
            if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DISKERR), hParent,
                        DiskErrDlgProc, (LPARAM)&diskparams) == IDC_DISKERR_LAUNCHCLEANUP)
            {
                LaunchDiskCleanup(hParent, idDrive, DISKCLEANUP_NOFLAG);
            }
        }
        else
        {
            MessageBox(hParent, diskparams.pszText, diskparams.pszTitle, 
                    MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
        }
        LocalFree(diskparams.pszText);
    }
}


/***********************************************************************\
DESCRIPTION:
We received an SHARINGVIOLATION or ACCESSDENIED error.  We want
to generate the most accruate error message for the user to inform
them better.  These are the cases we care about:

ERROR_ACCESS_DENIED: This is the legacy case with the message:
"Access is denied. The source file may be in use."
DE_DEST_IS_CDROM:  This is displayed in case the user copies a file to
their cd-rom drive.
DE_DEST_IS_CDRECORD: user deletes from CD recordable drive, we need an error
message that isn't so scary about "cant copy files to CD".
DE_DEST_IS_DVD:  This is displayed in case the user copies a file to
their DVD drive
DE_SHARING_VIOLATION: The file can't be copied because it's open by someone
who doesn't allow others to read the file while they
use it.
DE_PERMISSIONDENIED:  This should be displayed if the user doesn't have
the ACLs (security permissions) to read/copy the file.
\***********************************************************************/
int GenAccessDeniedError(LPCTSTR pszSource, LPCTSTR pszDest, int nError)
{
    int nErrorMsg = ERROR_ACCESS_DENIED;
    int iDrive = PathGetDriveNumber(pszDest);

    if (iDrive != -1)
    {
        if (IsCDRomDrive(iDrive))
        {
            WCHAR szDrive[4];
            // check if user is deleting from cd-r drive.  error message saying "cant copy or move files to cd drive"
            // doesn't apply.  since we're about to put up ui its not like we have to be super fast here, call into cdburning code.
            if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))) &&
                    (DRIVEID(szDrive) == iDrive))
            {
                nErrorMsg = DE_DEST_IS_CDRECORD;
            }
            else
            {
                nErrorMsg = DE_DEST_IS_CDROM;
            }
        }

        if (DriveIsDVD(iDrive))
            nErrorMsg = DE_DEST_IS_DVD;
    }

    // TODO: DE_SHARING_VIOLATION, DE_PERMISSIONDENIED
    return nErrorMsg;
}


//
// The following function reports errors for the copy engine
//
// Parameters
//      pszSource       source file name
//      pszDest         destination file name
//      nError          dos (or our exteneded) error code
//                      0xFFFF for special case NET error
//      wFunc           FO_* values
//      nOper           OPER_* values, operation being performed
//

void CopyError(LPCOPY_STATE pcs, LPCTSTR pszSource, LPCTSTR pszDest, int nError, UINT wFunc, int nOper)
{
    TCHAR szReason[200];
    TCHAR szFile[MAX_PATH];
    int idVerb;
    BOOL bDest;
    BOOL fSysError = FALSE;
    DWORD dwError = GetLastError();       // get Extended error now before we blow it away.

    if (!pcs || (pcs->fFlags & FOF_NOERRORUI))
        return;      // caller doesn't want to report errors

    bDest = nError & ERRORONDEST;        // was dest file cause of error
    nError &= ~ERRORONDEST;              // clear the dest bit

    // We also may need to remap some new error codes into old error codes
    //
    if (nError == ERROR_BAD_PATHNAME)
        nError = DE_INVALIDFILES;

    if (nError == ERROR_CANCELLED)        // user abort
        return;

    lstrcpyn(szFile, bDest ? pszDest : pszSource, ARRAYSIZE(szFile));
    if (!szFile[0])
    {
        LoadString(HINST_THISDLL, IDS_FILE, szFile, ARRAYSIZE(szFile));
    }
    else
    {
        // make the path fits on the screen
        RECT rcMonitor;
        HWND hwnd = pcs->hwndProgress ? pcs->hwndProgress : pcs->hwndDlgParent;
        GetMonitorRect(MonitorFromWindow(hwnd, TRUE), &rcMonitor);

        PathCompactPath(NULL, szFile, (rcMonitor.right - rcMonitor.left) / 3);
    }

    // get the verb string
    // since we now recycle folders as well as files, added OPER_ENTERDIR check here
    if ((nOper == OPER_DOFILE) || (nOper == OPER_ENTERDIR) || (nOper == 0))
    {
        if ((nError != -1) && bDest)
        {
            idVerb = IDS_REPLACING;
        }
        else
        {
            idVerb = IDS_VERBS + wFunc;
        }
    }
    else
    {
        idVerb = IDS_ACTIONS + (nOper >> 8);
    }

    // get the reason string
    if (nError == 0xFFFF)
    {
        DWORD dw;
        WNetGetLastError(&dw, szReason, ARRAYSIZE(szReason), NULL, 0);
    }
    else
    {
        // transform some error cases

        if (bDest)
        {
            // This caseing of error codes is error prone.. it would
            // be better to find the explicit ones we wish to map to
            // this one instead of trying to guess all the ones
            // we don't want to map...
            if ((nError == ERROR_DISK_FULL) ||
                    ((nError != ERROR_ACCESS_DENIED) &&
                     (nError != ERROR_NETWORK_ACCESS_DENIED) &&
                     (nError != ERROR_WRITE_PROTECT) &&
                     (nError != ERROR_BAD_NET_NAME) &&
                     (GetFreeClusters(pszDest) == 0L)))
            {
                nError = ERROR_DISK_FULL;
            }
            else if (dwError == ERROR_WRITE_FAULT)
            {
                nError = ERROR_WRITE_FAULT;
            }
            else if (dwError == ERROR_INVALID_NAME)
            {
                nError = ERROR_INVALID_NAME;
            }
        }
        else
        {
            if (nError == ERROR_ACCESS_DENIED)
            {
                // Check the extended error for more info about the error...
                // We just map these errors to something generic that
                // tells the user something weird is going on.
                switch (dwError)
                {
                    case ERROR_CRC:
                    case ERROR_SEEK:
                    case ERROR_SECTOR_NOT_FOUND:
                    case ERROR_READ_FAULT:
                    case ERROR_GEN_FAILURE:
                        nError = ERROR_GEN_FAILURE;
                        break;


                        // We can't test for ERROR_FILE_NOT_FOUND because in the case where we copy to
                        // a write-protected dest we check to see if the reason we got access denied was
                        // because there's already a read-only file there.  If there isn't _that_ test is
                        // going to SetLastError() to ERROR_FILE_NOT_FOUND and that's what we're going to
                        // report as an error. [davepl]
                        // 
                        // case ERROR_FILE_NOT_FOUND:
                        //    nError = ERROR_GEN_FAILURE;
                        //    break;

                    case ERROR_SHARING_VIOLATION:
                    case ERROR_ACCESS_DENIED:
                        nError = GenAccessDeniedError(pszSource, pszDest, nError);
                        break;
                    default:
                        TraceMsg(TF_WARNING, "CopyEngine: hit error %x , not currently special cased", dwError);
                        break;
                }
            }
            else
            {
                // This error occures when a user drags & drops a file from point a to
                // point b twice.  The second time fails because the first time hasn't finished.
                if (nError == (OPER_ERROR | ERROR_FILE_NOT_FOUND))
                {
                    nError = ERROR_GEN_FAILURE;
                }
            }
        }
    }

    // the error munging above is in several places, but there are some errors that we
    // know for SURE the user will never want to see so zap them to generic failures.
    // this whole thing needs a redesign... we shouldnt depend generally on errors getting
    // UI ("There is not enough space on the disk.") because then we get crap like this.
    // but everybody already knows that.
    switch (nError)
    {
        case ERROR_SWAPERROR:             //  Error performing inpage operation.
            nError = ERROR_GEN_FAILURE;
            break;
    }

    if (nError <= DE_ERROR_MAX)
    {
        BOOL fOverridden = FALSE;

        if (nError == ERROR_SHARING_VIOLATION)
        {
            // in the sharing violation case we can try to be a little better in the error UI by
            // going through the running object table and seeing if the file is registered in there.
            // if it's not in there, no biggie, just use our normal handling.
            PWSTR pszApp;
            if (SUCCEEDED(FindAppForFileInUse(bDest ? pszDest : pszSource, &pszApp)))
            {
                PWSTR pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SHAREVIOLATION_HINT), pszApp);
                if (pszMessage)
                {
                    StrCpyN(szReason, pszMessage, ARRAYSIZE(szReason));
                    fOverridden = TRUE;
                    LocalFree(pszMessage);
                }
                LocalFree(pszApp);
            }
        }

        if (!fOverridden)
        {
            fSysError = !LoadString(HINST_THISDLL, IDS_REASONS + nError, szReason, ARRAYSIZE(szReason));
        }
    }

    if (nOper == OPER_DOFILE)
    {
        PathRemoveExtension(szFile);
    }

    if (fSysError)
    {
        SHSysErrorMessageBox(pcs->hwndDlgParent, MAKEINTRESOURCE(IDS_FILEERROR + wFunc),
                idVerb, nError, PathFindFileName(szFile),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
    }
    else
    {
        if (nError > DE_ERROR_MAX &&
                0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    nError,
                    0,
                    szReason,
                    ARRAYSIZE(szReason),
                    NULL))
        {
            szReason[0] = 0;
        }

        DisplayFileOperationError(pcs->hwndDlgParent, idVerb, wFunc, nError, szReason, szFile, pszDest);
    }
}


//
// The following function is used to retry failed move/copy operations
// due to out of disk situations or path not found errors
// on the destination.
//
// parameters:
//      pszDest         Fully qualified path to destination file (ANSI)
//      nError          type of error: ERROR_DISK_FULL or ERROR_PATH_NOT_FOUND
//      dwFileSize      amount of space needed for this file if ERROR_DISK_FULL
//
// returns:
//      0       success (destination path has been created)
//      != 0    dos error code including ERROR_CANCELLED
//

int CopyMoveRetry(COPY_STATE *pcs, LPCTSTR pszDest, int nError, ULARGE_INTEGER* pulFileSize)
{
    UINT wFlags;
    int  result;
    LPCTSTR wID;
    TCHAR szTemp[MAX_PATH];
    BOOL fFirstRetry = TRUE;

    if (pcs->fFlags & FOF_NOERRORUI)
    {
        result = ERROR_CANCELLED;
        goto ErrorExit;
    }

    lstrcpyn(szTemp, pszDest, ARRAYSIZE(szTemp));
    PathRemoveFileSpec(szTemp);

    do
    {
        // until the destination path has been created
        if (nError == ERROR_PATH_NOT_FOUND)
        {
            if (!(pcs->fFlags & FOF_NOCONFIRMMKDIR))
            {
                wID = MAKEINTRESOURCE(IDS_PATHNOTTHERE);
                wFlags = MB_ICONEXCLAMATION | MB_YESNO;
            }
            else
            {
                wID = 0;
            }
        }
        else  // ERROR_DISK_FULL
        {
            ULARGE_INTEGER ulDiskSize;

            wFlags = MB_ICONEXCLAMATION | MB_RETRYCANCEL;
            if (pulFileSize && TotalCapacity(pszDest, &ulDiskSize) && pulFileSize->QuadPart > ulDiskSize.QuadPart)
            {
                wID = MAKEINTRESOURCE(IDS_FILEWONTFIT);
            }
            else
            {
                wID = MAKEINTRESOURCE(IDS_DESTFULL);
            }
        }

        if (wID)
        {
            // szTemp will be ignored if there's no %1%s in the string.
            result = ShellMessageBox(HINST_THISDLL, pcs->hwndDlgParent, wID, MAKEINTRESOURCE(IDS_UNDO_FILEOP + pcs->lpfo->wFunc), wFlags, (LPTSTR)szTemp);
        }
        else
        {
            result = IDYES;
        }

        if (result == IDRETRY || result == IDYES)
        {
            TCHAR szDrive[5];
            int idDrive;

            // Allow the disk to be formatted
            // REVIEW, could this be FO_MOVE as well?
            if (FAILED(SHPathPrepareForWrite(((pcs->fFlags & FOF_NOERRORUI) ? NULL : pcs->hwndDlgParent), NULL, szTemp, SHPPFW_DEFAULT)))
                return ERROR_CANCELLED;

            idDrive = PathGetDriveNumber(szTemp);
            if (idDrive != -1)
                PathBuildRoot(szDrive, idDrive);
            else
                szDrive[0] = 0;

            // if we're not copying to the root
            if (lstrcmpi(szTemp, szDrive))
            {
                result = SHCreateDirectory(pcs->hwndDlgParent, szTemp);

                if (result == ERROR_CANCELLED)
                    goto ErrorExit;
                if (result == ERROR_ALREADY_EXISTS)
                {
                    // if SHPathPrepareForWrite created the directory we shouldn't treat this as an error
                    result = 0;
                }
                else if (result && (nError == ERROR_PATH_NOT_FOUND))
                {
                    result |= ERRORONDEST;

                    //  We try twice to allow the recyclebin to be flushed.
                    if (fFirstRetry)
                        fFirstRetry = FALSE;
                    else
                        goto ErrorExit;
                }
            }
            else
            {
                result = 0;
            }
        }
        else
        {
            result = ERROR_CANCELLED;
            goto ErrorExit;
        }
    } while (result);

ErrorExit:
    return result;            // success
}


BOOL ValidFilenames(LPCTSTR pList)
{
    if (!*pList)
        return FALSE;

    for (; *pList; pList += lstrlen(pList) + 1)
    {
        if (PathIsInvalid(pList))
        {
            return FALSE;
        }
    }

    return TRUE;
}

void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs)
{
    //
    //  Update our collision mapping table
    //
    if (!*phdsaRenamePairs)
        *phdsaRenamePairs = DSA_Create(sizeof(SHNAMEMAPPING), 4);

    if (*phdsaRenamePairs)
    {
        SHNAMEMAPPING rp;
        rp.cchOldPath = lstrlen(pszOldPath);
        rp.cchNewPath = lstrlen(pszNewPath);

        rp.pszOldPath = StrDup(pszOldPath);
        if (rp.pszOldPath)
        {
            rp.pszNewPath = StrDup(pszNewPath);
            if (rp.pszNewPath)
            {
                if (DSA_AppendItem(*phdsaRenamePairs, &rp) == -1)
                {
                    LocalFree(rp.pszOldPath);
                    LocalFree(rp.pszNewPath);
                }
            }
            else
            {
                LocalFree(rp.pszOldPath);
            }
        }
    }
}

BOOL _HandleRename(LPCTSTR pszSource, LPTSTR pszDest, FILEOP_FLAGS fFlags, COPY_STATE * pcs)
{
    TCHAR *pszConflictingName = PathFindFileName(pszSource);
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemplate[MAX_PATH];
    LPTSTR lpszLongPlate;

    PathRemoveFileSpec(pszDest);

    if (LoadString(HINST_THISDLL, IDS_COPYLONGPLATE, szTemplate, ARRAYSIZE(szTemplate)))
    {
        LPTSTR lpsz;
        lpsz = pszConflictingName;
        lpszLongPlate = szTemplate;
        // see if the first part of the template is the same as the name "Copy #"
        while (*lpsz && *lpszLongPlate &&
                *lpsz == *lpszLongPlate &&
                *lpszLongPlate != TEXT('('))
        {
            lpsz++;
            lpszLongPlate++;
        }

        if (*lpsz == TEXT('(') && *lpszLongPlate == TEXT('('))
        {
            // conflicting name already in the template, use it instead
            lpszLongPlate = pszConflictingName;
        }
        else
        {
            // otherwise build our own
            // We need to make sure not to overflow a max buffer.
            int ichFixed = lstrlen(szTemplate) + lstrlen(pszDest) + 5;
            lpszLongPlate = szTemplate;

            if ((ichFixed + lstrlen(pszConflictingName)) <= MAX_PATH)
            {
                lstrcat(lpszLongPlate, pszConflictingName);
            }
            else
            {
                // Need to remove some of the name
                LPTSTR pszExt = StrRChr(pszConflictingName, NULL, TEXT('.'));
                if (pszExt)
                {
                    int ichTemplate = lstrlen(lpszLongPlate);
                    lstrcpyn(lpszLongPlate + ichTemplate,
                            pszConflictingName,
                            max(MAX_PATH - ichFixed - lstrlen(pszExt), 0));

                    // use as much of the buffer as possible
                    StrCatBuff(lpszLongPlate, pszExt, max(MAX_PATH - ichFixed + ichTemplate, 0));
                }
                else
                {
                    lstrcpyn(lpszLongPlate + lstrlen(lpszLongPlate),
                            pszConflictingName,
                            MAX_PATH - ichFixed);
                }
            }
        }
    }
    else
    {
        lpszLongPlate = NULL;
    }

    if (PathYetAnotherMakeUniqueName(szTemp, pszDest, pszConflictingName, lpszLongPlate))
    {
        //
        //  If there are any other files in the queue which are to
        //  be copied into a subtree of pszDest, we must update them
        //  as well.
        //

        //  Put the new (renamed) target in pszDest.
        lstrcpy(pszDest, szTemp);

        //  Rebuild the old dest name and put it in szTemp.
        //  I'm going for minimum stack usage here, so I don't want more
        //  than one MAX_PATH lying around.
        PathRemoveFileSpec(szTemp);
        PathAppend(szTemp, pszConflictingName);

        AddRenamePairToHDSA(szTemp, pszDest, &pcs->dth.hdsaRenamePairs);

        return TRUE;
    }

    return FALSE;
}

// test input for "multiple" filespec
//
// examples:
//      1       foo.bar                 (single non directory file)
//      -1      *.exe                   (wild card on any of the files)
//      n       foo.bar bletch.txt      (number of files)
//

int CountFiles(LPCTSTR pInput)
{
    int count;
    for (count = 0; *pInput; pInput += lstrlen(pInput) + 1, count++)
    {
        // wild cards imply multiple files
        if (PathIsWild(pInput))
            return -1;
    }
    return count;

}

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

BOOL IsCompressedVolume(LPCTSTR pszSource, DWORD dwAttributes)
{
    int i;
    LPTSTR pszFileName, pszExtension;
    TCHAR szPath[MAX_PATH];

    // must be marked system and hidden
    if (!IS_SYSTEM_HIDDEN(dwAttributes))
        return FALSE;

    lstrcpy(szPath, pszSource);
    pszFileName = PathFindFileName(szPath);
    pszExtension = PathFindExtension(pszFileName);

    // make sure the extension is a 3 digit number
    if (!*pszExtension)
        return FALSE;       // no extension

    for (i = 1; i < 4; i++) 
    {
        if (!pszExtension[i] || !ISDIGIT(pszExtension[i]))
            return FALSE;
    }

    // make sure it's null terminated here
    if (pszExtension[4])
        return FALSE;

    // now knock off the extension and make sure the stem matches
    *pszExtension = 0;
    if (lstrcmpi(pszFileName, TEXT("DRVSPACE")) &&
            lstrcmpi(pszFileName, TEXT("DBLSPACE"))) 
    {
        return FALSE;
    }

    // make sure it's in the root
    PathRemoveFileSpec(szPath);
    if (!PathIsRoot(szPath)) 
    {
        return FALSE;
    }

    return TRUE;        // passed all tests!
}

void _DeferMoveDlgItem(HDWP hdwp, HWND hDlg, int nItem, int x, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, nItem);

    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hDlg, (LPPOINT) &rc, 2);

    DeferWindowPos(hdwp, hwnd, 0, rc.left + x, rc.top + y, 0, 0,
            SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
}

void _RecalcWindowHeight(HWND hWnd, LPTSTR lpszText)
{
    HDC hdc = GetDC(hWnd);
    RECT rc;
    HWND hwndText = GetDlgItem(hWnd,IDC_MBC_TEXT);
    HDWP hdwp;
    int iHeightDelta, cx;

    // Get the starting rect of the text area (for the width)
    GetClientRect(hwndText, &rc);
    MapWindowPoints(hwndText, hWnd, (LPPOINT) &rc, 2);

    // Calc how high the static text area needs to be, given the above width
    iHeightDelta = RECTHEIGHT(rc);
    cx = RECTWIDTH(rc);
    DrawText(hdc, lpszText, -1, &rc, DT_CALCRECT | DT_WORDBREAK | DT_LEFT | DT_INTERNAL | DT_EDITCONTROL);

    iHeightDelta = RECTHEIGHT(rc) - iHeightDelta;
    cx = RECTWIDTH(rc) - cx; // Should only change for really long words w/o spaces
    if (cx < 0)
        cx = 0;

    ReleaseDC(hWnd, hdc);

    hdwp = BeginDeferWindowPos(4);
    if (hdwp)
    {
        hdwp = DeferWindowPos(hdwp, hwndText, 0, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
        if (hdwp)
        {
            _DeferMoveDlgItem(hdwp, hWnd, IDC_MESSAGEBOXCHECKEX, 0, iHeightDelta);
            _DeferMoveDlgItem(hdwp, hWnd, IDYES, cx, iHeightDelta);
            _DeferMoveDlgItem(hdwp, hWnd, IDNO, cx, iHeightDelta);

            EndDeferWindowPos(hdwp);
        }
    }

    GetWindowRect(hWnd, &rc);
    SetWindowPos(hWnd, 0, rc.left - (cx/2), rc.top - (iHeightDelta/2), RECTWIDTH(rc)+cx, RECTHEIGHT(rc)+iHeightDelta, SWP_NOZORDER | SWP_NOACTIVATE);
    return;
}

BOOL_PTR CALLBACK RenameMsgBoxCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // we only handle the WM_INITDIALOG so that we can resize the dialog
        // approprately and to set the default button to IDNO
        case WM_INITDIALOG:
            {
                HWND hwndNO = GetDlgItem(hDlg, IDNO);

                _RecalcWindowHeight(hDlg, (LPTSTR)lParam);

                SetDlgItemText(hDlg,IDC_MBC_TEXT,(LPTSTR)lParam);

                SendMessage(hDlg, DM_SETDEFID, IDNO, 0);
                SetFocus(hwndNO);

                return FALSE; // we set the focus, so return false
            }
    }

    // didnt handle this message
    return FALSE;
}

int ConfirmRenameOfConnectedItem(COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR szSource)
{
    int result = IDYES; //For non-connected elements, the default is IDYES!
    LPTSTR  pszMessage;
    LPTSTR  lpConnectedItem, lpConnectOrigin;
    LPTSTR  lpStringID;

    //Check if this item being renamed has a connected item.
    if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
    {
        //Yes! It has a connected element! Form the strings to create the confirmation dialog!

        //Get the name of the connected element
        lpConnectedItem = PathFindFileName(pcs->dth.pdtnCurrent->pdtnConnected->szName);
        lpConnectOrigin = PathFindFileName(pcs->dth.pFrom);

        // Mark the connected item as dummy as this will never get renamed.
        // (Note that this connected node could be a folder. It is still OK to mark it as 
        // dummy because for rename operation, a folder is treated just like a file in 
        // DTGotoNextNode()).
        pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;

        if (pfd && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            lpStringID = MAKEINTRESOURCE(IDS_HTML_FOLDER_RENAME);
        else
            lpStringID = MAKEINTRESOURCE(IDS_HTML_FILE_RENAME);

        //Load the confirmation message and format it!
        pszMessage = ShellConstructMessageString(HINST_THISDLL, lpStringID, 
                lpConnectedItem, lpConnectOrigin);

        if (pszMessage)
        {
            //Get the confirmation from the end-user;
            result = SHMessageBoxCheckEx(pcs->hwndDlgParent, HINST_THISDLL, 
                    MAKEINTRESOURCE(DLG_RENAME_MESSAGEBOXCHECK), 
                    RenameMsgBoxCheckDlgProc,
                    (void *)pszMessage,
                    IDYES, 
                    REG_VAL_GENERAL_RENAMEHTMLFILE);
            //It is possible we get IDCANCEL if the "X" in the caption is clicked to clost
            // the dialog. The following code makes sure we get one of the return code that we want.
            if ((result != IDYES) && (result != IDNO))
                result = IDNO;

            SHFree(pszMessage);
        }
        else
            result = IDNO;  //For connected elements, the default is "Don't rename";
    }
    else
    {
        if (DTNIsConnected(pcs->dth.pdtnCurrent))
            result = IDNO;  //Connected elements, do not get renamed.
    }

    return result;
}

int AllConfirmations(COPY_STATE *pcs, WIN32_FIND_DATA *pfd, UINT oper, UINT wFunc,
        LPTSTR szSource, LPTSTR szDest, BOOL bTimeToUpdate, 
        WIN32_FIND_DATA *pfdDest, LPINT lpret)
{
    int result = IDYES;
    LPTSTR p;
    LPTSTR pszStatusDest = NULL;
    CONFIRM_FLAG fConfirm;
    WIN32_FIND_DATA *pfdUse1 = NULL;
    WIN32_FIND_DATA *pfdUse2;
    BOOL fSetProgress = FALSE;
    BOOL fShowConfirm = FALSE;

    switch (oper | wFunc)
    {
        case OPER_ENTERDIR | FO_MOVE:
            if (PathIsSameRoot(szSource, szDest))
            {
                fConfirm = CONFIRM_MOVE_FOLDER;
                pfdUse1 = pfd;
                pfdUse2 = pfdDest;
                fShowConfirm = TRUE;
            }
            break;

        case OPER_ENTERDIR | FO_DELETE:
            // Confirm removal of directory on this pass.  The directories
            // are actually removed on the OPER_LEAVEDIR pass
            if (DTNIsRootNode(pcs->dth.pdtnCurrent))
                fSetProgress = TRUE;        

            if (!PathIsRoot(szSource))
            {
                fShowConfirm = TRUE;
                pfdUse2 = pfd;
                fConfirm = CONFIRM_DELETE_FOLDER;
                szDest = NULL;
            }

            break;

        case OPER_DOFILE | FO_RENAME:
            // pszStatusDest = szDest;
            fSetProgress = TRUE;

            p = PathFindFileName(szSource);
            if (!IntlStrEqNI(szSource, szDest, (int)(p - szSource)))
            {
                result = DE_DIFFDIR;
            }
            else
            {
                if (pfd && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    fConfirm = CONFIRM_RENAME_FOLDER;
                else
                    fConfirm =  CONFIRM_RENAME_FILE;

                if (PathIsRoot(szSource) || (PathIsRoot(szDest)))
                {
                    result = DE_ROOTDIR | ERRORONDEST;
                }
                else
                {
                    // We need to bring up a special confirmation dialog if this file/folder being
                    // renamed has a connected element (if "foo.htm" or "foo files" is renamed that
                    // will break the links).
                    result = ConfirmRenameOfConnectedItem(pcs, pfd, szSource);

                    if (result != IDNO)
                    {
                        fShowConfirm = TRUE;
                        pfdUse2 = pfdDest;
                        pfdUse1 = pfd;
                    }
                }
            }
            break;

        case OPER_DOFILE | FO_MOVE:

            fSetProgress = TRUE;
            pszStatusDest = szDest;
            if (PathIsRoot(szSource))
            {
                result = DE_ROOTDIR;
            }
            else if (PathIsRoot(szDest))
            {
                result = DE_ROOTDIR | ERRORONDEST;
            }
            else
            {
                fConfirm = CONFIRM_MOVE_FILE;
                fShowConfirm = TRUE;
                pfdUse2 = pfdDest;
                pfdUse1 = pfd;
            }
            break;

        case OPER_DOFILE | FO_DELETE:
            fSetProgress = TRUE;

            if (IsCompressedVolume(szSource, pfd->dwFileAttributes))
            {
                CopyError(pcs, szSource, szDest, DE_COMPRESSEDVOLUME, wFunc, oper);
                result = IDNO;
            }
            else
            {
                fShowConfirm = TRUE;
                szDest = NULL;
                pfdUse2 = pfd;
                fConfirm = CONFIRM_DELETE_FILE;
            }
            break;

    }

    if (fShowConfirm)
    {
        result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd, pcs->nSourceFiles, !DTNIsRootNode(pcs->dth.pdtnCurrent), fConfirm,
                szSource, pfdUse1, szDest, pfdUse2, NULL);
    }

    if (oper == OPER_DOFILE || oper == OPER_ENTERDIR)
    {
        if ((wFunc == FO_MOVE) || (wFunc == FO_COPY))
        {
            if ((result != IDNO) && (result != IDCANCEL))
            {   
                LPTSTR pszDataToBeLost;
                WCHAR wszDestDir[MAX_PATH];
                BOOL  bNoStreamLossThisDir = FALSE;

                lstrcpy(wszDestDir, szDest);
                PathRemoveFileSpec(wszDestDir);

                // Files with multiple streams will suffer stream loss on a downlevel
                // copy, but CopyFile special-cases native structure storage.

                pszDataToBeLost = GetDownlevelCopyDataLossText(szSource, wszDestDir, (oper == OPER_ENTERDIR), &bNoStreamLossThisDir);
                if (pszDataToBeLost)
                {
                    fConfirm     = CONFIRM_STREAMLOSS;
                    pfdUse2      = pfd;

                    result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd, pcs->nSourceFiles, !DTNIsRootNode(pcs->dth.pdtnCurrent), fConfirm,
                            szSource, pfdUse1, szDest, pfdUse2, pszDataToBeLost);
                    LocalFree(pszDataToBeLost);
                }
                else if (bNoStreamLossThisDir)
                {
                    // pcs->bStreamLossPossible = FALSE;                    
                }
            }
        }   
    }

    // We only really care about OPER_ENTERDIR when deleting and
    // OPER_DOFILE when renaming, but I guess the hook will figure it out

    if ((result == IDYES) &&
            ISDIRFINDDATA(*pfd) &&
            (oper==OPER_ENTERDIR || oper==OPER_DOFILE))
    {

        result = CallFileCopyHooks(pcs->hwndDlgParent, wFunc, pcs->fFlags,
                szSource, pfd->dwFileAttributes,
                szDest, pfdDest->dwFileAttributes);
    }

    if ((result != IDCANCEL) && (result != IDNO) && fSetProgress && bTimeToUpdate)
        SetProgressText(pcs, szSource, pszStatusDest);

    return result;
}


// return TRUE if they're the same file
// assumes that given two file specs, the short name will
// be identical (except case)
BOOL SameFile(LPTSTR pszSource, LPTSTR pszDest)
{
    TCHAR szShortSrc[MAX_PATH];
    if (GetShortPathName(pszSource, szShortSrc, ARRAYSIZE(szShortSrc)))
    {
        TCHAR szShortDest[MAX_PATH];
        if (GetShortPathName(pszDest, szShortDest, ARRAYSIZE(szShortDest)))
            return !lstrcmpi(szShortSrc, szShortDest);
    }

    return FALSE;
}


// make sure we aren't operating on the current dir to avoid
// ERROR_CURRENT_DIRECTORY kinda errors

void AvoidCurrentDirectory(LPCTSTR p)
{
    TCHAR szTemp[MAX_PATH];

    GetCurrentDirectory(ARRAYSIZE(szTemp), szTemp);
    if (lstrcmpi(szTemp, p) == 0)
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("operating on current dir(%s), cd .."), p);
        PathRemoveFileSpec(szTemp);
        SetCurrentDirectory(szTemp);
    }
}

// this resolves short/long name collisions such as moving
// "NewFolde" onto a dir with "New Folder" whose short name is "NEWFOLDE"
//
// we resolve this by renaming "New Folder" to a unique short name (like TMP1)
//
// making a temporary file of name "NEWFOLDE"
//
// renaming TMP1 back to "New Folder"  (at which point it will have a new short
// name like "NEWFOL~1"

// PERF: it'd be faster if we didn't make the temporary file, but that
// would require that we rename the file back to the long name at the
// end of the operation.. which would mean we'd need to queue them all up..
// too much for right now.
BOOL ResolveShortNameCollisions(LPCTSTR lpszDest, WIN32_FIND_DATA *pfd)
{
    BOOL fRet = FALSE;

    // first verify that we're in the name collision.
    // we are if lpszDest is the same as the pfd's short name which is different
    // than it's long name.

    if (!lstrcmpi(PathFindFileName(lpszDest), pfd->cAlternateFileName) &&
            lstrcmpi(pfd->cAlternateFileName, pfd->cFileName))
    {
        // yes... do the renaming
        TCHAR szTemp[MAX_PATH];
        TCHAR szLongName[MAX_PATH];

        lstrcpy(szTemp, lpszDest);
        PathRemoveFileSpec(szTemp);

        // build the original long name
        lstrcpy(szLongName, szTemp);
        PathAppend(szLongName, pfd->cFileName);

        GetTempFileName(szTemp, c_szNULL, 1, szTemp);
        DebugMsg(TF_DEBUGCOPY, TEXT("Got %s as a temp file"), szTemp);
        // rename "New Folder" to "tmp1"
        if (Win32MoveFile(szLongName, szTemp, ISDIRFINDDATA(*pfd)))
        {
            // make a temporary "NewFolde"
            fRet = CreateWriteCloseFile(NULL, lpszDest, NULL, 0);
            ASSERT(fRet);

            // move it back...

            if (!Win32MoveFile(szTemp, szLongName, ISDIRFINDDATA(*pfd)))
            {
                //
                //  Can't move it back, so delete the empty dir and then
                //  move it back.  Return FALSE to denote failure.
                //
                DeleteFile(lpszDest);
                Win32MoveFile(szTemp, szLongName, ISDIRFINDDATA(*pfd));
                fRet = FALSE;
            }
            else
            {
                // send this out because we could have confused views
                // with this swapping files around...  by the time they get the first
                // move file notification, the temp file is likely gone
                // so they could blow that off.. which would mess up the rest of this.
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szLongName, NULL);
                //
                //  We've now created an empty dir entry of this name type.
                //
                Win32DeleteFile(lpszDest);
            }

            DebugMsg(TF_DEBUGCOPY, TEXT("ResolveShortNameCollision: %s = original, %s = destination,\n %s = temp file, %d = return"), szLongName, lpszDest, szTemp, fRet);
        }
    }
    return fRet;
}


typedef struct { LPTSTR szFilename; int iResult; } RENAMEEXEMPTIONINFO;
RENAMEEXEMPTIONINFO g_rgExemptions[] = {
    { TEXT("thumbs.db"), IDYES }
};
    
// return values.
//
// IDCANCEL = bail out of all operations
// IDNO = skip this one
// IDRETRY = try operation again
// IDUNKNOWN = this (collision) is not the problem
#define IDUNKNOWN IDOK
int CheckForRenameCollision(COPY_STATE *pcs, UINT oper, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfdDest, WIN32_FIND_DATA* pfd)
{
    int iRet = IDUNKNOWN;

    ASSERT((pcs->lpfo->wFunc != FO_DELETE) && (oper != OPER_LEAVEDIR));


    /* Check to see if we are overwriting an existing file or
       directory.  If so, better confirm */

    if ((oper == OPER_DOFILE) ||
            ((oper == OPER_ENTERDIR) && (pcs->fFlags & FOF_RENAMEONCOLLISION)))
    {
        HANDLE  hfindT;

        // REVIEW this slows things down checking for the dest file
        if ((hfindT = FindFirstFile(pszDest, pfdDest)) != INVALID_HANDLE_VALUE)
        {
            FindClose(hfindT);

            iRet = IDCANCEL;

            if (pcs->lpfo->wFunc != FO_RENAME || !SameFile(pszSource, pszDest))
            {

                if (!ResolveShortNameCollisions(pszDest, pfdDest))
                {
                    if (pcs->fFlags & FOF_RENAMEONCOLLISION)
                    {
                        //  The client wants us to generate a new name for the
                        //  source file to avoid a collision at the destination
                        //  dir.  Must also update the current queue and the
                        //  copy root.
                        _HandleRename(pszSource, pszDest, pcs->fFlags, pcs);
                        iRet = IDRETRY;
                    }
                    else
                    {
                        int result = IDRETRY;

                        if (pcs->lpfo->wFunc == FO_RENAME)
                        {
                            return ERROR_ALREADY_EXISTS;
                        }

                        // Is this a super-hidden file we don't want to prompt the
                        // user regarding?
                        if (IS_SYSTEM_HIDDEN(pfd->dwFileAttributes) &&
                            IS_SYSTEM_HIDDEN(pfdDest->dwFileAttributes) && 
                            !ShowSuperHidden())
                        {
                            int cExempt = 0;
                            for (; cExempt < ARRAYSIZE(g_rgExemptions); cExempt++)
                            {
                                if (0 == StrCmpI(g_rgExemptions[cExempt].szFilename, PathFindFileName(pszSource)))
                                {
                                    result = g_rgExemptions[cExempt].iResult;
                                    break;
                                }
                            }
                        }
                        
                        // REVIEW, if the destination file we are copying over
                        // is actually a directory we are doomed.  we can
                        // try to remove the dir but that will fail if there
                        // are files there.  we probably need a special error message
                        // for this case.

                        if (result == IDRETRY)
                        {
                            result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                                    &pcs->cd, pcs->nSourceFiles,
                                    !DTNIsRootNode(pcs->dth.pdtnCurrent),
                                    CONFIRM_REPLACE_FILE,
                                    pszSource, pfd, pszDest, pfdDest, NULL);
                        }
                        switch (result)
                        {
                            case IDYES:

                                if ((pcs->lpfo->wFunc == FO_MOVE) && (PathIsSameRoot(pszSource, pszDest)))
                                {
                                    int ret;
                                    // For FO_MOVE we need to delete the
                                    // destination first.  Do that now.

                                    // FEATURE this replace options should be undable
                                    ret = Win32DeleteFile(pszDest) ? 0 : GetLastError();

                                    if (ret)
                                    {
                                        ret |= ERRORONDEST;
                                        result = ret;
                                    }
                                }
                                if (pcs->lpua)
                                    FOUndo_Release(pcs->lpua);
                                iRet = IDRETRY;
                                break;

                            case IDNO:
                            case IDCANCEL:
                                pcs->lpfo->fAnyOperationsAborted = TRUE;
                                iRet = result;
                                break;

                            default:
                                iRet = result;
                                break;
                        }
                    }
                }
                else
                {
                    iRet = IDRETRY;
                }
            }
        }
    }

    return iRet;
}

int LeaveDir_Delete(COPY_STATE *pcs, LPTSTR pszSource)
{
    int ret;
    if (PathIsRoot(pszSource))
        return 0;

    AvoidCurrentDirectory(pszSource);

    // We already confirmed the delete at MKDIR time, so attempt
    // to delete the directory

    ret = Win32RemoveDirectory(pszSource) ? 0 : GetLastError();
    if (!ret)
    {
        FOUndo_FileReallyDeleted(pszSource);
    }
    return ret;
}


int EnterDir_Copy(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    int ret;
    int result;
    BOOL fSetDestAttributes = FALSE;
    DWORD dwDesiredAttributes = pfd->dwFileAttributes;

    // Whenever we enter a directory, we need to reset the bStreamLossPossible flag,
    // since we could have stepped out from an NTFS->NTFS to NTFS->FAT scenario via
    // a junction point

    pcs->bStreamLossPossible = TRUE;

    // SHMoveFile restricts the based on path length. To be consistent, we make the same
    // restricton on Copy directory also.
    if (IsDirPathTooLongForCreateDir(pszDest))
    {
        ret = ERROR_FILENAME_EXCED_RANGE;
    }
    else
    {
        BOOL fWithoutTemplate = FALSE;

        if (pcs->fLostEncryptOk)
        {
            dwDesiredAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;     // Pretend its not encrypted
            fSetDestAttributes = TRUE;
            fWithoutTemplate = TRUE;
        }

        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
        {
            if (!(pcs->fFlags & FOF_NORECURSEREPARSE))
            {
                dwDesiredAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;  // Pretend like its just a folder
                fSetDestAttributes = TRUE;
                fWithoutTemplate = TRUE;
            }
        }

        if (fWithoutTemplate)
        {
            ret = (CreateDirectory(pszDest, NULL) ? 0 : GetLastError());

            // Since we didn't call CreateDirectoryEx, we need to manually
            // propogate the attributes to the dest directory.
            fSetDestAttributes = TRUE;
        }
        else
        {
            ret = (CreateDirectoryEx(pszSource, pszDest, NULL) ? 0 : GetLastError());
        }

        if (ret == ERROR_SUCCESS)
        {
            SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszDest, NULL);
        }
    }

    switch (ret)
    {
        case 0:     // successful folder creation (or it already exists)
            // propogate the attributes (if there are any)

            if (pcs->fFromCDRom)
            {
                // Don't propogate read-only from CDRoms
                dwDesiredAttributes &= ~FILE_ATTRIBUTE_READONLY;
                fSetDestAttributes = TRUE;
            }

            if (fSetDestAttributes)
            {
                // Avoid setting FILE_ATTRIBUTE_DIRECTORY, since its
                // already a directory, and is less error prone.
                SetFileAttributes(pszDest, dwDesiredAttributes);
            }

            //  we should set the security ACLs here on NT
            //  we ignore any kind of failure though, is that OK?
            //
            CopyFileSecurity(pszSource, pszDest);

            // add to the undo atom
            if (pcs->lpua)
            {
                if (DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                    FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
            }
            break;

        case ERROR_ALREADY_EXISTS:
        case ERROR_DISK_FULL:
        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_NAME:
            {
                DWORD dwFileAttributes;

                if (!fRenameTried)
                {
                    int result = CheckForRenameCollision(pcs, OPER_ENTERDIR, pszSource, pszDest, pfdDest, pfd);
                    switch (result)
                    {
                        case IDUNKNOWN:
                            break;

                        case IDRETRY:
                            return EnterDir_Copy(pcs, pszSource, pszDest, pfd, pfdDest, TRUE);

                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            return result;

                        case IDNO:
                            return result;

                        default:
                            return result;
                    }
                }

                dwFileAttributes = GetFileAttributes(pszDest);

                if (dwFileAttributes == (DWORD)-1)
                {
                    // The dir does not exist, so it looks like a problem
                    // with a read-only drive or disk full

                    if (ret == ERROR_DISK_FULL &&
                            IsRemovableDrive(DRIVEID(pszDest)) &&
                            !PathIsSameRoot(pszDest, pszSource))
                    {
                        ret = CopyMoveRetry(pcs, pszDest, ERROR_DISK_FULL, NULL);
                        if (!ret)
                        {
                            return EnterDir_Copy(pcs, pszSource, pszDest, pfd, pfdDest, fRenameTried);
                        }
                        else
                        {
                            pcs->bAbort = TRUE;
                            return ret;
                        }
                    }

                    // Maybe its an encrypted folder thats losing its encryption?
                    if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                    {
                        int result;
                        result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                                &pcs->cd, pcs->nSourceFiles,
                                FALSE,
                                CONFIRM_LOST_ENCRYPT_FOLDER,
                                pszSource, pfd, pszDest, NULL, NULL);

                        switch (result)
                        {
                            case IDYES:
                                pcs->fLostEncryptOk = TRUE;
                                return EnterDir_Copy(pcs, pszSource, pszDest, pfd, pfdDest, fRenameTried);

                            case IDNO:
                            case IDCANCEL:
                                pcs->bAbort = TRUE;
                                ret = result;
                                break;

                            default:
                                ret = result;
                                break;
                        }
                        return ret;
                    }

                    CopyError(pcs, pszSource, pszDest, ERROR_ACCESS_DENIED | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    pcs->bAbort = TRUE;
                    return ret;
                }

                if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    // A file with this name already exists
                    CopyError(pcs, pszSource, pszDest, DE_FLDDESTISFILE | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    pcs->bAbort = TRUE;
                    return ret;
                }

                result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd,
                        pcs->nSourceFiles,
                        !DTNIsRootNode(pcs->dth.pdtnCurrent),
                        CONFIRM_REPLACE_FOLDER,
                        pszSource, pfd, pszDest, pfdDest, NULL);
                switch (result)
                {
                    case IDYES:
                        ret = 0;    // convert to no error
                        pcs->fMerge = TRUE;
                        if (pcs->lpua)
                            FOUndo_Release(pcs->lpua);
                        break;

                    case IDNO:
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
                        pcs->lpfo->fAnyOperationsAborted = TRUE;
                        ret = IDNO;  // Don't put up error message on this one...
                        // Since the end-user cancelled the copy operation on this folder, we can cancel the 
                        // copy operation on the corresponding connected file too!
                        if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                        break;

                    case IDCANCEL:
                        pcs->lpfo->fAnyOperationsAborted = TRUE;
                        pcs->bAbort = TRUE;
                        // Since the end-user cancelled the copy operation on this folder, we can cancel the 
                        // copy operation on the corresponding connected file too!
                        if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                        break;

                    default:
                        result = ret;
                        break;
                }
                break;
            }

        case ERROR_CANCELLED:
            pcs->bAbort = TRUE;
            break;

        case ERROR_FILENAME_EXCED_RANGE:
            DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
            break;

        default:    // ret != 0 (dos error code)
            ret |= ERRORONDEST;
            break;
    }

    return ret;
}

int EnterDir_Move(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    int ret;

    // Whenever we enter a directory, we need to reset the bStreamLossPossible flag,
    // since we could have stepped out from an NTFS->NTFS to NTFS->FAT scenario via
    // a junction point

    pcs->bStreamLossPossible = TRUE;

    // if these are in the same drive, try using MoveFile on it.
    // if that fails then fail through to the copy

    if (PathIsSameRoot(pszSource, pszDest))
    {
        AvoidCurrentDirectory(pszSource);

        ret = Win32MoveFile(pszSource, pszDest, TRUE) ? 0 : GetLastError();

        switch (ret)
        {
            case 0:

                DebugMsg(TF_DEBUGCOPY, TEXT("Move Folder worked!"));

                DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                // add to the undo atom
                if (pcs->lpua && DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                    FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);

                if (!SHRestricted(REST_NOENCRYPTONMOVE) && 
                        !(pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
                {
                    TCHAR szDestDir[MAX_PATH];
                    DWORD dwAttribs;

                    StrCpyN(szDestDir, pszDest, ARRAYSIZE(szDestDir));
                    PathRemoveFileSpec(szDestDir);
                    dwAttribs = GetFileAttributes(szDestDir);

                    if ((dwAttribs != -1) && (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
                    {
                        // Encrypt the directory by pretending we are the
                        // property sheet properties->Advanced.  Fill in the fake 
                        // information and call the helper.
                        FILEPROPSHEETPAGE fpsp;
                        FOLDERCONTENTSINFO fci;
                        fci.fIsCompressionAvailable = FALSE; 
                        fci.fMultipleFiles = TRUE;          
                        ZeroMemory(&fpsp, SIZEOF(fpsp));
                        fpsp.hDlg = GetWindow(pcs->hwndDlgParent, GW_CHILD);
                        fpsp.fRecursive = TRUE;
                        fpsp.fIsDirectory = TRUE;
                        fpsp.pfci = &fci;
                        // As long as asInitial.* == asCurrent.* it won't be changed 
                        fpsp.asInitial.fReadOnly = BST_INDETERMINATE;
                        fpsp.asInitial.fHidden   = BST_INDETERMINATE;
                        fpsp.asInitial.fIndex    = BST_INDETERMINATE;
                        fpsp.asInitial.fArchive  = BST_INDETERMINATE;
                        fpsp.asInitial.fCompress = BST_INDETERMINATE;
                        fpsp.asInitial.fEncrypt  = BST_UNCHECKED; // Not encrypted yet
                        fpsp.asInitial.fRecordingEnabled = BST_INDETERMINATE;
                        fpsp.asCurrent.fReadOnly = BST_INDETERMINATE;
                        fpsp.asCurrent.fHidden   = BST_INDETERMINATE;
                        fpsp.asCurrent.fIndex    = BST_INDETERMINATE;
                        fpsp.asCurrent.fArchive  = BST_INDETERMINATE;
                        fpsp.asCurrent.fCompress = BST_INDETERMINATE;
                        fpsp.asCurrent.fEncrypt  = BST_CHECKED;  // Now encrypt
                        fpsp.asCurrent.fRecordingEnabled = BST_INDETERMINATE;
                        ApplyRecursiveFolderAttribs(pszDest, &fpsp);
                    }
                }

                // Win32MoveFile on a single-volume leaves the original ACL
                // intact.  If necessary, pick up perms from the destination.
                if (pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS)
                {
                    ResetFileSecurity(pszDest);
                }
                return 0;

            case ERROR_PATH_NOT_FOUND:
                ret = CopyMoveRetry(pcs, pszDest, ret, NULL);
                if (!ret)
                    return EnterDir_Move(pcs, pszSource, pszDest, pfd, pfdDest, fRenameTried);
                return ret;

            case ERROR_ALREADY_EXISTS:
            case ERROR_FILE_EXISTS:
                if (!fRenameTried)
                {
                    int result = CheckForRenameCollision(pcs, OPER_ENTERDIR, pszSource, pszDest, pfdDest, pfd);
                    switch (result)
                    {
                        case IDUNKNOWN:
                            break;
                        case IDRETRY:
                            return EnterDir_Move(pcs, pszSource, pszDest, pfd, pfdDest, TRUE);

                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            return result;

                        case IDNO:
                            return result;

                        default:
                            return result;
                    }
                }
                break;

            case ERROR_FILENAME_EXCED_RANGE:
            case ERROR_ONLY_IF_CONNECTED:
                DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
                return ret;
        }
    }

    // we're going to recurse in.... if we've not enumerated the children for
    // this folder, set it for delayed enumeration now.
    if (!pcs->dth.pdtnCurrent->pdtnChild)
    {
        pcs->dth.pdtnCurrent->pdtnChild = DTN_DELAYED;
    }

    if (DTNIsConnected(pcs->dth.pdtnCurrent) && !PathFileExists(pszSource))
    {
        // This can happen if the end-user moved "foo.htm" AND "foo files" together.
        // As a result the connected element "foo files" has already been moved.
        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
        return(0); //No error! This connected element seems to have been moved.
    }

    return EnterDir_Copy(pcs, pszSource, pszDest, pfd, pfdDest, FALSE);
}

int EnterDir_Delete(COPY_STATE * pcs, WIN32_FIND_DATA *pfdSrc, LPTSTR pszSource, HDPA *phdpaDeletedFiles)
{
    int iRet = 0;

    if (!DTNIsRootNode(pcs->dth.pdtnCurrent))
    {
        // we are not at a root node... when doing a delete this can only mean
        // that we are really nuking the folder. we dont need to enum children
        // because we already did a non-lazy enum at the root node.
        return iRet;
    }
    else if (!pcs->lpua)
    {
NukeFolder:
        // we are at a root node and we have no undo atom, this means that we
        // really want to nuke this whole dir, so enum the children
        DTForceEnumChildren(&pcs->dth);
        // do a non-layz enum of the children to prevent the progress
        // bar from going back and forth as we recurse down into any subdirs.
        DTEnumChildren(&pcs->dth, pcs, TRUE, DTF_FILES_AND_FOLDERS);
        return iRet;
    }

    if (DeleteFileBB(pszSource, &iRet, pcs, TRUE, pfdSrc, phdpaDeletedFiles)) 
    {
        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
    } 
    else 
    {
        // DeleteFileBB failed, check iRet to find out why

        switch (iRet)
        {
            case BBDELETE_PATH_TOO_LONG:
            case BBDELETE_SIZE_TOO_BIG:
            case BBDELETE_NUKE_OFFLINE:
                {
                    // This is the case where the folder is too big to fit in the Recycle Bin or the folder
                    // is offline. We have no choice but to really nuke it, but we warn the user first since
                    // they may have thought that it was being sent to the recycle bin.
                    int result = CachedConfirmFileOp(pcs->hwndDlgParent, 
                            pcs,
                            &pcs->cd, 
                            pcs->nSourceFiles, 
                            FALSE, 
                            (iRet == BBDELETE_SIZE_TOO_BIG) ?
                            CONFIRM_WONT_RECYCLE_FOLDER :
                            ((iRet == BBDELETE_NUKE_OFFLINE) ?
                             CONFIRM_WONT_RECYCLE_OFFLINE :
                             CONFIRM_PATH_TOO_LONG), 
                            pszSource, 
                            pfdSrc, 
                            NULL, 
                            NULL,
                            NULL);
                    switch (result) 
                    {
                        case IDNO:
                            // user said "please dont really nuke the file"
                            DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                            pcs->lpfo->fAnyOperationsAborted = TRUE;

                            iRet = IDNO;  // Don't put up error message for this case

                            //Because the Delete on this FOLDER is aborted, we can cancel the "Delete"
                            // on the corresponding FILE too!
                            if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            {
                                pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                            }
                            break;

                        case IDCANCEL:
                            // user canceled the operation
                            pcs->lpfo->fAnyOperationsAborted = TRUE;

                            pcs->bAbort = TRUE;

                            //Because the Delete on this FOLDER is cancelled, we can cancel the "Delete"
                            // on the corresponding FILE too!
                            if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            {
                                pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                            }
                            break;

                        case IDYES:
                        default:
                            // user said "please nuke the file"
                            // assume noerror
                            iRet = 0;

                            // set this so the is correct progress animation is displayed
                            if (pcs)
                            {
                                pcs->fFlags &= ~FOF_ALLOWUNDO;
                            }

                            // dont allow undo since we are really nuking it (cant bring it back...)
                            if (pcs->lpua)
                            {
                                FOUndo_Release(pcs->lpua);
                            }

                            UpdateProgressAnimation(pcs);
                            goto NukeFolder;
                            break;
                    }
                }
                break;

            case BBDELETE_CANNOT_DELETE:
                {
                    // This is the non-deletable file case. Note: this is an NT only case, and
                    // it could be caused by acls or the fact that the file is currently in use.
                    // We attemt to really delete the file (which should fail) so we can generate
                    // the proper error value
                    DWORD dwAttributes = GetFileAttributes(pszSource);

                    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        iRet = Win32RemoveDirectory(pszSource);
                    }
                    else
                    {
                        iRet = Win32DeleteFile(pszSource);
                    }

                    if (!iRet)
                    {
                        // indeed, the file/folder could not be deleted. 
                        // Get last error to find out why
                        iRet = GetLastError();
                    }
                    else
                    {
                        // DeleteFileBB said that it couldn't be deleted, but we just nuked it. We will
                        // end up falling into this case when we hit things like Mounted Volumes.

                        // As Obi-Wan would say: "You don't need to see his identification... these aren't
                        // the droids you are looking for... He can go about his business... Move along."
                        iRet = ERROR_SUCCESS;
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                        // dont allow undo since we reall nuked it (cant bring it back...)
                        if (pcs->lpua)
                        {
                            FOUndo_Release(pcs->lpua);
                        }
                    }
                }
                break;

            case BBDELETE_FORCE_NUKE:
                {
                    // This is the catch-all case. If iRet = BDETETE_FORCE_NUKE, then we just nuke the 
                    // file without warning.

                    // return noerror so we recurse into this dir and nuke it
                    iRet = ERROR_SUCCESS;

                    // set this so the is correct progress animation is displayed
                    if (pcs)
                    {
                        pcs->fFlags &= ~FOF_ALLOWUNDO;
                    }

                    // dont allow undo since we are really nuking it (cant bring it back...)
                    if (pcs->lpua)
                    {
                        FOUndo_Release(pcs->lpua);
                    }

                    UpdateProgressAnimation(pcs);

                    goto NukeFolder;
                }
                break;

            case BBDELETE_CANCELLED:
                {
                    // user canceled the operation
                    pcs->lpfo->fAnyOperationsAborted = TRUE;

                    pcs->bAbort = TRUE;

                    //Because the Delete on this FOLDER is cancelled, we can cancel the "Delete"
                    // on the corresponding FILE too!
                    if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                    {
                        pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                    }
                }

            case BBDELETE_UNKNOWN_ERROR:
            default:
                {
                    iRet = GetLastError();
                    ASSERT(iRet != ERROR_SUCCESS);
                }
                break;

        }
    } // DeleteFileBB

    return iRet;
}

BOOL DoFile_Win32DeleteFileWithPidl(LPCTSTR pszFile, SIMPLEPIDLCACHE *pspc)
{
    LPITEMIDLIST pidlFile = NULL;
    int iRet;
    if (pspc)
    {
        pidlFile = SimplePidlCache_GetFilePidl(pspc, pszFile);
    }
    iRet = Win32DeleteFilePidl(pszFile, pidlFile);
    ILFree(pidlFile);
    return iRet;
}

int DoFile_Delete(COPY_STATE* pcs, WIN32_FIND_DATA *pfdSrc, LPTSTR pszSource, HDPA *phdpaDeletedFiles, BOOL fShouldSuspendEvents)
{
    int iRet = 0;

    // if we dont have an undo atom or this isint a root node or if this is a network file 
    // then we need to really nuke it
    if (!pcs->lpua || !DTNIsRootNode(pcs->dth.pdtnCurrent) || IsNetDrive(PathGetDriveNumber(pszSource)))
    {
        iRet = DoFile_Win32DeleteFileWithPidl(pszSource, fShouldSuspendEvents ? NULL : &pcs->spc) ? 0 : GetLastError();
        if (!iRet)
        {
            FOUndo_FileReallyDeleted(pszSource);
        }
    }
    else if (!DeleteFileBB(pszSource, &iRet, pcs, FALSE, pfdSrc, phdpaDeletedFiles))
    {
        // DeleteFileBB failed, check iRet to find out why

        switch (iRet)
        {
            case BBDELETE_SIZE_TOO_BIG:
            case BBDELETE_NUKE_OFFLINE:
                {
                    // This is the case where the file is too big to fit in the Recycle Bin. We have no
                    // choice but to really nuke it, but we warn the user first since they may have thought
                    // that it was being sent to the recycle bin.
                    int result = CachedConfirmFileOp(pcs->hwndDlgParent, 
                            pcs,
                            &pcs->cd, 
                            pcs->nSourceFiles, 
                            FALSE, 
                            (iRet == BBDELETE_SIZE_TOO_BIG) ?
                            CONFIRM_WONT_RECYCLE_FOLDER :
                            CONFIRM_WONT_RECYCLE_OFFLINE, 
                            pszSource, 
                            pfdSrc, 
                            NULL, 
                            NULL,
                            NULL);

                    switch (result) 
                    {
                        case IDNO:
                            // user said "please dont really nuke the file"
                            pcs->lpfo->fAnyOperationsAborted = TRUE;
                            iRet = IDNO;  // Don't put up error message for this case
                            // WARNING: It is tempting to mark the corresponding connected folder as dummy here.
                            // But, this will not work because currently folders (nodes with children) can not be
                            // marked as dummy.
                            break;

                        case IDCANCEL:
                            // user canceled the operation
                            pcs->lpfo->fAnyOperationsAborted = TRUE;
                            pcs->bAbort = TRUE;
                            // WARNING: It is tempting to mark the corresponding connected folder as dummy here.
                            // But, this will not work because currently folders (nodes with children) can not be
                            // marked as dummy.
                            break;

                        case IDYES:
                        default:
                            // user said "please nuke the file"
                            // set this so the is correct progress animation is displayed
                            if (pcs)
                            {
                                pcs->fFlags &= ~FOF_ALLOWUNDO;
                            }

                            // dont allow undo since we are really nuking it
                            if (pcs->lpua)
                            {
                                FOUndo_Release(pcs->lpua);
                            }

                            UpdateProgressAnimation(pcs);

                            iRet = DoFile_Win32DeleteFileWithPidl(pszSource, &pcs->spc) ? 0 : GetLastError();
                            break;
                    }
                }
                break;

            case BBDELETE_CANNOT_DELETE:
                {
                    // This is the non-deletable file case. Note: this is an NT only case, and
                    // it could be caused by acls or the fact that the file is currently in use.
                    // We attemt to really delete the file (which should fail) so we can generate
                    // the proper error value
                    iRet = Win32DeleteFile(pszSource);

                    if (!iRet)
                    {
                        // indeed, the file/folder could not be deleted.
                        // Get last error to find out why
                        iRet = GetLastError();
                    }
                    else
                    {
                        // DeleteFileBB said that it couldn't be deleted, but we just nuked it. We will
                        // end up falling into this case when we hit things like Mounted Volumes and other
                        // reparse points that we can't "recycle".

                        // As Obi-Wan would say: "You don't need to see his identification... these aren't
                        // the droids you are looking for... He can go about his business... Move along."
                        iRet = ERROR_SUCCESS;
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                        // dont allow undo since we really nuked it (cant bring it back...)
                        if (pcs->lpua)
                        {
                            FOUndo_Release(pcs->lpua);
                        }
                    }
                }
                break;

            case BBDELETE_FORCE_NUKE:
                {
                    // This is the catch-all case. If iRet = BDETETE_FORCE_NUKE, then we just nuke the 
                    // file without warning.

                    // set this so the is correct progress animation is displayed
                    if (pcs)
                    {
                        pcs->fFlags &= ~FOF_ALLOWUNDO;
                    }

                    // dont allow undo since we are going to nuke this file
                    if (pcs->lpua)
                    {
                        FOUndo_Release(pcs->lpua);
                    }

                    UpdateProgressAnimation(pcs);

                    iRet = DoFile_Win32DeleteFileWithPidl(pszSource, &pcs->spc) ? 0 : GetLastError();
                }
                break;

            case BBDELETE_CANCELLED:
                {
                    // user canceled the operation
                    pcs->lpfo->fAnyOperationsAborted = TRUE;
                    pcs->bAbort = TRUE;
                }
                break;

            case BBDELETE_UNKNOWN_ERROR:
            default:
                {
                    iRet = GetLastError();
                    ASSERT(iRet != ERROR_SUCCESS);
                }
                break;

        }
    } // !DeleteFileBB

    return iRet;
}

int DoFile_Copy(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    /* Now try to copy the file.  Do extra error processing only
       in 2 cases:
       1) If a removeable drive is full let the user stick in a new disk
       2) If the path doesn't exist (the user typed in
       and explicit path that doesn't exits) ask if
       we should create it for him. */

    int ret = FileCopy(pcs, pszSource, pszDest, pfd, fRenameTried);

    if (ret == ERROR_CANCELLED)
    {
        pcs->bAbort = TRUE;
        return ret;
    }

    if ((ret & ~ERRORONDEST) == ERROR_FILE_EXISTS)
    {
        if (!fRenameTried)
        {
            int result = CheckForRenameCollision(pcs, OPER_DOFILE, pszSource, pszDest, pfdDest, pfd);
            switch (result)
            {
                case IDUNKNOWN:
                    break;

                case IDRETRY:
                    return DoFile_Copy(pcs, pszSource, pszDest, pfd, pfdDest, TRUE);

                case IDCANCEL:
                    pcs->bAbort = TRUE;
                    return result;

                case IDNO:
                    return result;

                default:
                    return result;
            }
        }
    }


    if ((((ret & ~ERRORONDEST) == ERROR_DISK_FULL) &&
                IsRemovableDrive(DRIVEID(pszDest))) ||
            ((ret & ~ERRORONDEST) == ERROR_PATH_NOT_FOUND))
    {
        ULARGE_INTEGER ulFileSize;
        ulFileSize.LowPart = pfd->nFileSizeLow;
        ulFileSize.HighPart = pfd->nFileSizeHigh;
        ret = CopyMoveRetry(pcs, pszDest, ret & ~ERRORONDEST, &ulFileSize);
        if (!ret)
        {
            return DoFile_Copy(pcs, pszSource, pszDest, pfd, pfdDest, fRenameTried);
        }
        else
        {
            pcs->bAbort = TRUE;
            return ret;
        }
    }

    if (!ret)
    {
        // add to the undo atom
        // if we're doing a copy, only keep track of the highest most
        // level.. unless we're doing a merge sort of copy
        if (pcs->lpua)
        {
            if (DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
        }

        // if we copied in a new desktop ini, send out an update event for the paretn
        if (!lstrcmpi(PathFindFileName(pszDest), c_szDesktopIni))
        {
            TCHAR szDest[MAX_PATH];
            lstrcpyn(szDest, pszDest, ARRAYSIZE(szDest));
            PathRemoveFileSpec(szDest);
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szDest, NULL);
        }
    }

    return ret;
}

int DoFile_Move(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    int ret = 0;
    if (PathIsRoot(pszSource))
    {
        return DE_ROOTDIR;
    }
    if (PathIsRoot(pszDest))
    {
        return DE_ROOTDIR | ERRORONDEST;
    }

    AvoidCurrentDirectory(pszSource);

    if (PathIsSameRoot(pszSource, pszDest))
    {
TryAgain:
        ret = Win32MoveFile(pszSource, pszDest, ISDIRFINDDATA(*pfd)) ? 0 : GetLastError();

        // try to create the destination if it is not there
        if (ret == ERROR_PATH_NOT_FOUND)
        {
            ret = CopyMoveRetry(pcs, pszDest, ret, NULL);
            if (!ret)
            {
                goto TryAgain;
            }
        }

        if (ret == ERROR_ALREADY_EXISTS)
        {
            if (!fRenameTried)
            {
                int result = CheckForRenameCollision(pcs, OPER_DOFILE, pszSource, pszDest, pfdDest, pfd);
                switch (result)
                {
                    case IDUNKNOWN:
                        break;
                    case IDRETRY:
                        fRenameTried = TRUE;
                        goto TryAgain;

                    case IDCANCEL:
                        pcs->bAbort = TRUE;
                        return result;

                    case IDNO:
                        return result;

                    default:
                        return result;
                }
            }
        }

        if ((ret == ERROR_SUCCESS)                              &&
                !SHRestricted(REST_NOENCRYPTONMOVE)                 &&
                !(pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                !(pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
        {
            TCHAR szDestDir[MAX_PATH];
            DWORD dwAttribs;

            // We are moving a file that is NOT encrypted. On Win2k, we need to check to see if this was a move to 
            // an encrypted folder. If so, we automatically encrypt the file.

            lstrcpyn(szDestDir, pszDest, ARRAYSIZE(szDestDir));
            PathRemoveFileSpec(szDestDir);
            dwAttribs = GetFileAttributes(szDestDir);

            if ((dwAttribs != -1) && (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
            {
                // sainity check
                ASSERT(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);

                // attempt to encrypt the file
                if (!SHEncryptFile(pszDest, TRUE))
                {
                    int result = CachedConfirmFileOp(pcs->hwndDlgParent, 
                            pcs,
                            &pcs->cd, 
                            pcs->nSourceFiles, 
                            FALSE, 
                            CONFIRM_FAILED_ENCRYPT, 
                            pszDest, 
                            pfd,   // since we just moved it, the attibs should be the same as the src 
                            NULL, 
                            NULL,
                            NULL);
                    switch (result)
                    {
                        case IDCANCEL:
                            // user canceled the operation
                            pcs->lpfo->fAnyOperationsAborted = TRUE;
                            pcs->bAbort = TRUE;
                            break;

                        case IDNO:
                            // user choose to "restore" the file to its original location
                            ret = Win32MoveFile(pszDest, pszSource, ISDIRFINDDATA(*pfd)) ? 0 : GetLastError();

                        case IDYES:
                        default:
                            // user ignored the error
                            break;
                    }
                }
            }
        }

        if (ret == ERROR_SUCCESS)
        {
            if (pcs->lpua && DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
            {
                // add to the undo atom
                FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
            }

            // Win32MoveFile on a single-volume leaves the original ACL
            // intact.  If necessary, pick up perms from the destination.
            if (pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS)
            {
                ResetFileSecurity(pszDest);
            }

            // if we copied in a new desktop ini, send out an update event for the paretn
            if (!lstrcmpi(PathFindFileName(pszDest), c_szDesktopIni))
            {
                TCHAR szDest[MAX_PATH];
                lstrcpyn(szDest, pszDest, ARRAYSIZE(szDest));
                PathRemoveFileSpec(szDest);
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szDest, NULL);
            }
        }
    }
    else
    {
        // we must force all copies to go through
        // straight so we can remove the source
        if (DTNIsConnected(pcs->dth.pdtnCurrent) && !PathFileExists(pszSource))
        {
            //This can happen if "foo.htm" and "foo files" were moved by the end-user.
            // The connected file had already been moved and hence this is not an error!
            ret = 0; //No error! That file has been moved already!
        }
        else
        {
            ret = DoFile_Copy(pcs, pszSource, pszDest, pfd, pfdDest, FALSE);
        }
    }

    return ret;
}

int DoFile_Rename(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest,
        WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    LPTSTR p = PathFindFileName(pszSource);

    /* Get raw source and dest paths.  Check to make sure the
       paths are the same */
    int ret = !IntlStrEqNI(pszSource, pszDest, (int)(p - pszSource));
    if (ret)
    {
        return DE_DIFFDIR;
    }

    return DoFile_Move(pcs, pszSource, pszDest, pfd, pfdDest, fRenameTried);
}


int MoveCopyInitPCS(COPY_STATE * pcs)
{
    BOOL fMultiDest = FALSE;
    int ret = 0;
    LPTSTR p = NULL;
    TCHAR szDestPath[MAX_PATH];

    pcs->nSourceFiles = CountFiles(pcs->lpfo->pFrom);      // multiple source files?

    pcs->fProgressOk = TRUE;

    // skip destination processing if we are deleting files
    if (pcs->lpfo->wFunc != FO_DELETE)
    {
        lstrcpyn(szDestPath, pcs->lpfo->pTo, ARRAYSIZE(szDestPath));
        if (!szDestPath[0])           // NULL dest is same as "."
        {
            szDestPath[0] = TEXT('.');
            szDestPath[1] = 0;
        }

        if (PathIsInvalid(szDestPath))
        {
            CopyError(pcs, c_szNULL, c_szNULL, DE_INVALIDFILES | ERRORONDEST, pcs->lpfo->wFunc, 0);
            return ERROR_ACCESS_DENIED;
        }

        if (pcs->lpfo->wFunc == FO_RENAME)
        {
            // don't let them rename multiple files to one single file

            if ((pcs->nSourceFiles != 1) && !PathIsWild(szDestPath))
            {
                CopyError(pcs, c_szNULL, c_szNULL, DE_MANYSRC1DEST, pcs->lpfo->wFunc, 0);
                return DE_MANYSRC1DEST;
            }
            fMultiDest = TRUE;
        }
        else    // FO_COPY or FO_MOVE at this point
        {
            fMultiDest = ((pcs->fFlags & FOF_MULTIDESTFILES) &&
                    (pcs->nSourceFiles == CountFiles(pcs->lpfo->pTo)));

            if (!fMultiDest)
            {
                // for backwards compat.
                // copy c:\foo.bar c:\folder\foo.bar  means
                // multi dest if foo.bar doesn't exist.
                // Hack if it is a root we special case this for the offline 
                // floppy case...
                if (pcs->nSourceFiles == 1 && !PathIsRoot(szDestPath) && 
                        !PathIsDirectory(szDestPath))
                {
                    fMultiDest = TRUE;
                }
            }

        }
    }

    pcs->dth.fMultiDest = fMultiDest;

    return 0;
}


DWORD   g_dwStopWatchMode = 0xffffffff;  // Shell performance mode

// actually this does move/copy/rename/delete
int MoveCopyDriver(COPY_STATE *pcs)
{
    int ret;
    WIN32_FIND_DATA fdSrc;
    WIN32_FIND_DATA fdDest;
    HDPA hdpaDeletedFiles = NULL;
    LPSHFILEOPSTRUCT lpfo = pcs->lpfo;
    TCHAR szText[28];
    BOOL bInitialAllowUndo = FALSE;
    DWORD dwLastUpdateTime = 0;
    BOOL fShouldSuspendEvents = FALSE;
    HANDLE hEventRunning;

    if (g_dwStopWatchMode)
    {
        if (g_dwStopWatchMode == 0xffffffff)
        {
            g_dwStopWatchMode = StopWatchMode();    // Since the stopwatch funcs live in shdocvw, delay this call so we don't load shdocvw until we need to
        }

        if (g_dwStopWatchMode)
        {
            lstrcpy((LPTSTR)szText, TEXT("Shell "));
            switch (lpfo->wFunc)
            {
                case FO_COPY:
                    lstrcat((LPTSTR)szText, TEXT("Copy  "));
                    break;
                case FO_MOVE:
                    lstrcat((LPTSTR)szText, TEXT("Move  "));
                    break;
                case FO_DELETE:
                    lstrcat((LPTSTR)szText, TEXT("Delete"));
                    break;
                case FO_RENAME:
                    lstrcat((LPTSTR)szText, TEXT("Rename"));
                    break;
                default:
                    lstrcat((LPTSTR)szText, TEXT("Copy? "));
                    break;
            }
            lstrcat((LPTSTR)szText, TEXT(": Start"));
            StopWatch_Start(SWID_COPY, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }

    // start by assuming an error.  Non-zero means an error has occured.  If we don't
    // start with this assumption then we will return success if MoveCopyInitPCS fails.
    ret = ERROR_GEN_FAILURE;

    if (!ValidFilenames(lpfo->pFrom))
    {
        CopyError(pcs, c_szNULL, c_szNULL, DE_INVALIDFILES, lpfo->wFunc, 0);
        return ERROR_ACCESS_DENIED;
    }

    StartCopyEngine(&hEventRunning);

    // Check the pcs destination directory to make sure it is valid for the given source file list
    if (MoveCopyInitPCS(pcs))
    {
        goto ExitLoop;          // Destination is invalid so we bail out
    }

    // Build a tree where each node is a source file, a dest file, and an operation to perform
    ret = DTBuild(pcs);
    if (ret)
    {
        goto ShowMessageBox;
    }

    // Speed optimization: for a delete, sending all FSNotifies really bogs down the system,
    // so we skip it and rely on the file system notifies.
    if ((lpfo->wFunc == FO_DELETE || lpfo->wFunc == FO_MOVE) && pcs->dth.dtAll.dwFiles > 100)
    {
        // Only suspend notifies for local moves
        if (lpfo->wFunc == FO_MOVE)
        {
            if (lpfo->pTo)
            {
                int idDrive = PathGetDriveNumber(lpfo->pFrom);
                if (idDrive == PathGetDriveNumber(lpfo->pTo) && !IsNetDrive(idDrive))
                {
                    fShouldSuspendEvents = TRUE;
                }
            }
        }
        else
        {
            fShouldSuspendEvents = TRUE;
        }
    }

    if (fShouldSuspendEvents)
    {
        // SuspendSHNotify can fail if another thread is using it. Only one thread at a time can suspend notify.
        fShouldSuspendEvents = SuspendSHNotify();
    }


    // save off the initial state of the allowundo flag
    if (pcs->fFlags & FOF_ALLOWUNDO)
    {
        bInitialAllowUndo = TRUE;
    }

    // When first starting, we assume that stream loss is possible until we prove
    // otherwise for the current directory.  This gets reset to true each time we
    // enter a new dir via EnterDir_Move or EnterDir_Copy

    pcs->bStreamLossPossible = TRUE;

    for (;;)
    {
        BOOL bUpdateAnimation = FALSE;
        int result;
        DWORD dwTickCount;
        BOOL bTimeToUpdate = FALSE;

        pcs->dth.oper = DTGoToNextNode(&pcs->dth,pcs);

        dwTickCount = GetTickCount();
        if ((dwTickCount - dwLastUpdateTime) > 10)
        {
            dwLastUpdateTime = dwTickCount;
            bTimeToUpdate = TRUE;
        }

        if ((pcs->dth.oper & OPER_MASK) == OPER_ERROR)
        {
            CopyError(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, LOBYTE(pcs->dth.oper), pcs->lpfo->wFunc, OPER_DOFILE);
            // If the directory is copied but a file inside that directory could not 
            // be copied because of long filename, check to see if this is
            // a connected element. If so, invoke undo, sothat we getback the orginal html file 
            // in the same place as the associated folder.
            if ((pcs->dth.oper == (OPER_ERROR | DE_INVALIDFILES)) &&
                    (DTNIsConnected(pcs->dth.pdtnCurrent)))
            {
                if (pcs->lpua)
                {
                    pcs->lpua->foFlags |= FOF_NOCONFIRMATION;
                    FOUndo_Invoke(pcs->lpua);
                    pcs->lpua = NULL;
                }
            }
            break;
        }

        if (!pcs->dth.oper || pcs->bAbort)     // all done?
        {
            break;
        }

        if (DTNIsRootNode(pcs->dth.pdtnCurrent) && (pcs->dth.oper != OPER_LEAVEDIR))
        {
            int iDrive;

            // check to see if we switched between doing a move to
            // recycle bin and a true delete (this would happen when
            // there was an object that was too big for the recycle bin)
            if (!(pcs->fFlags & FOF_ALLOWUNDO) && bInitialAllowUndo)
            {
                // reset the allowundo flag since we have a new root node, and we
                // want to attempt to send it to the recycle bin
                pcs->fFlags |= FOF_ALLOWUNDO;

                // we delay to update the progress animation till we are basically
                // done, which allows us to keep the progress and animation in sync
                bUpdateAnimation = TRUE;
            }

            pcs->fMerge = FALSE;
            pcs->fFromCDRom = FALSE;

            // Check source for being a CDRom
            iDrive = PathGetDriveNumber(pcs->dth.szSrcPath);
            if (-1 != iDrive)
            {
                TCHAR szDrive[4];
                if (DRIVE_CDROM == GetDriveType(PathBuildRoot(szDrive, iDrive)))
                {
                    pcs->fFromCDRom = TRUE;
                }
            }
        }

        DTGetWin32FindData(pcs->dth.pdtnCurrent, &fdSrc);
        fdDest.dwFileAttributes = 0;

        DebugMsg(TF_DEBUGCOPY, TEXT("MoveCopyDriver(): Oper %x From(%s) To(%s)"), pcs->dth.oper, (LPCTSTR)pcs->dth.szSrcPath, (LPCTSTR)pcs->dth.szDestPath);

        // some operation that may effect the destination (have a collision)
        if ((pcs->lpfo->wFunc != FO_DELETE) && (pcs->dth.oper != OPER_LEAVEDIR))
        {
            // this compare needs to be case sensitive, and locale insensitive
            if (!StrCmpC(pcs->dth.szSrcPath, pcs->dth.szDestPath) &&
                    !(pcs->fFlags & FOF_RENAMEONCOLLISION))
            {
                // Source and dest are the same file, and name collision
                // resolution is not turned on, so we just return an error.

                // TODO: Show the error dialog here and allow for SKIP

                ret = DE_SAMEFILE;
                goto ShowMessageBox;
            }
        }

        result = AllConfirmations(pcs, &fdSrc, pcs->dth.oper, pcs->lpfo->wFunc, pcs->dth.szSrcPath, 
                pcs->dth.szDestPath, bTimeToUpdate, &fdDest, &ret);
        switch (result)
        {
            case IDNO:
                DTAbortCurrentNode(&pcs->dth);
                lpfo->fAnyOperationsAborted = TRUE;
                continue;

            case IDCANCEL:
                pcs->bAbort = TRUE;
                goto ExitLoop;

            case IDYES:
                break;

            default:
                ret = result;
                goto ShowMessageBox;
        }

        /* Now determine which operation to perform */

        switch (pcs->dth.oper | pcs->lpfo->wFunc)
        {
            // Note that ENTERDIR is not done for a root, even though LEAVEDIR is
            case OPER_ENTERDIR | FO_MOVE:  // Create dest, verify source delete
                ret = EnterDir_Move(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, &fdSrc, &fdDest, FALSE);
                break;

            case OPER_ENTERDIR | FO_COPY:  // Create destination directory
                ret = EnterDir_Copy(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, &fdSrc, &fdDest, FALSE);
                break;

            case OPER_LEAVEDIR | FO_MOVE:
            case OPER_LEAVEDIR | FO_DELETE:
                ret = LeaveDir_Delete(pcs, pcs->dth.szSrcPath);
                break;

            case OPER_LEAVEDIR | FO_COPY:
                break;

            case OPER_DOFILE | FO_COPY:
                ret = DoFile_Copy(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, &fdSrc, &fdDest, FALSE);
                break;

            case OPER_DOFILE | FO_RENAME:
                ret = DoFile_Rename(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, &fdSrc, &fdDest, FALSE);
                break;

            case OPER_DOFILE | FO_MOVE:
                ret = DoFile_Move(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, &fdSrc, &fdDest, FALSE);
                break;

            case OPER_ENTERDIR | FO_DELETE:
                ret = EnterDir_Delete(pcs, &fdSrc, pcs->dth.szSrcPath, &hdpaDeletedFiles);
                break;

            case OPER_DOFILE | FO_DELETE:
                ret = DoFile_Delete(pcs, &fdSrc, pcs->dth.szSrcPath, &hdpaDeletedFiles, fShouldSuspendEvents);
                break;

            default:
                DebugMsg(DM_ERROR, TEXT("Invalid file operation"));
                ret = 0;         // internal error
                break;
        } // switch (pcs->dth.oper | pcs->lpfo->wFunc)

        if (pcs->bAbort)
            break;

        if (ret == IDNO)
        {
            pcs->lpfo->fAnyOperationsAborted = TRUE;
        }
        else if (ret)
        {      // any errors?
ShowMessageBox:
            // If source file is a connected item and is not found, that means that
            // we have already moved/deleted/renamed it. So, don't report that as error!
            if ((!pcs->dth.pdtnCurrent) || (!pcs->dth.pdtnCurrent->fConnectedElement) || 
                    ((ret != ERROR_FILE_NOT_FOUND) && (ret != ERROR_PATH_NOT_FOUND)))
            {
                CopyError(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ret, pcs->lpfo->wFunc, pcs->dth.oper);

                // If the directory is copied but a file inside that directory could not 
                // be copied because of long filename, check to see if this is
                // a connected element. If so, invoke undo, sothat we getback the orginal html file 
                // in the same place as the associated folder.
                if ((ret == ERROR_FILENAME_EXCED_RANGE) &&
                        (DTNIsConnected(pcs->dth.pdtnCurrent)))
                {
                    if (pcs->lpua)
                    {
                        pcs->lpua->foFlags |= FOF_NOCONFIRMATION;
                        FOUndo_Invoke(pcs->lpua);
                        pcs->lpua = NULL;
                    }
                }
                break;
            }
        }

        if (bTimeToUpdate)
        {
            // perform the delayed update of the dialog
            if (bUpdateAnimation)
            {
                UpdateProgressAnimation(pcs);
                bUpdateAnimation = FALSE;
            }
            // We check to see if we are finished here (instead of at the
            // start) since we want to keep the progress a step behind what
            // we are doing to ensure we have the correct progress animation
            // and text (since FOQueryAbort updates the progress text)
            if (FOQueryAbort(pcs))
                break;
        }
    }

ExitLoop:

    // this happens in error cases where we broke out of the pcr loop
    // without hitting the end

    lpfo->hNameMappings = pcs->dth.hdsaRenamePairs;

    DTCleanup(&pcs->dth);
    BBFinishDelete(hdpaDeletedFiles);

    if (fShouldSuspendEvents)
    {
        ResumeSHNotify();

        if (lpfo->wFunc == FO_DELETE)
        {
            TCHAR szBBPath[MAX_PATH];

            // Since we probably blew away any chance at having the FSNotify work, make sure
            // we update item for this path...  we can send the message on any drive since
            // the bitbucket listens for changes on all drives.
            DriveIDToBBPath(DriveIDFromBBPath(lpfo->pFrom), szBBPath);
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, szBBPath, NULL);
        }
    }


    if (g_dwStopWatchMode)
    {
        lstrcpy((LPTSTR)&szText[12], TEXT(": Stop "));
        StopWatch_Stop(SWID_COPY, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
    }

    EndCopyEngine(hEventRunning);
    
    return ret;
}



void SetWindowTextFromRes(HWND hwnd, int id)
{
    TCHAR szTemp[80];

    LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
    SetWindowText(hwnd, szTemp);
}

int CountProgressPoints(COPY_STATE *pcs, PDIRTOTALS pdt)
{
    // point value for each item
    int iTotal = 0;
    UINT uSize = pcs->uSize;

    if (!uSize)
    {
        uSize = 32*1024;
    }
    // now add it up.
    iTotal += (UINT)((pdt->liSize.QuadPart/uSize) * pcs->dth.iSizePoints);
    iTotal += pdt->dwFiles * pcs->dth.iFilePoints;
    iTotal += pdt->dwFolders * pcs->dth.iFolderPoints;

    return iTotal;
}

void UpdateProgressDialog(COPY_STATE* pcs)
{
    int iRange;  // from 0 to iRange
    int iPos;  // how much is done.

    if (pcs->fProgressOk)
    {

        if (pcs->dth.dtAll.fChanged)
        {
            pcs->dth.dtAll.fChanged = FALSE;
            iRange = CountProgressPoints(pcs, &pcs->dth.dtAll);
            SendProgressMessage(pcs, PBM_SETRANGE32, 0, iRange);
            DebugMsg(TF_DEBUGCOPY, TEXT("UpdateProgressDialog iRange = %d "), iRange);
        }

        if (pcs->dth.dtDone.fChanged)
        {
            pcs->dth.dtDone.fChanged = FALSE;
            iPos = CountProgressPoints(pcs, &pcs->dth.dtDone);
            SendProgressMessage(pcs, PBM_SETPOS, iPos, 0);
            DebugMsg(TF_DEBUGCOPY, TEXT("UpdateProgressDialog iPos = %d "), iPos);
        }
    }
}

// NOTE: !! do NOT refrence pcs->lpfo anywhere in this dialog proc !! 
//
// It can be freed while we are still running. If you need to get information from it, 
// add a new member to the FOUITHREADINFO struct and copy the value from the pcs->lpfo
// into the member (while holding the critsec) right before we create this dlg.
BOOL_PTR CALLBACK FOFProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    FOUITHREADINFO* pfouiti = (FOUITHREADINFO*)GetWindowLongPtr(hDlg, DWLP_USER);
    COPY_STATE *pcs = (pfouiti ? pfouiti->pcs : NULL);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        pfouiti = (FOUITHREADINFO*)lParam;
        pcs = pfouiti->pcs;

        SetWindowTextFromRes(hDlg, IDS_ACTIONTITLE + pfouiti->wFunc);

        if (pcs->fFlags & FOF_SIMPLEPROGRESS)
        {
            TCHAR szFrom[MAX_PATH];
            if (pcs->lpszProgressTitle)
            {
                if (IS_INTRESOURCE(pcs->lpszProgressTitle))
                {
                    LoadString(HINST_THISDLL, PtrToUlong(pcs->lpszProgressTitle), szFrom, ARRAYSIZE(szFrom));
                    pcs->lpszProgressTitle = szFrom;
                }
                SetDlgItemText(hDlg, IDD_NAME, pcs->lpszProgressTitle);
                // null it so we only set it once
                pcs->lpszProgressTitle = NULL;
            }
        }

        return FALSE;
    }

    if (pcs)
    {
        switch (wMsg)
        {
            case WM_TIMER:
                if (IsWindowEnabled(hDlg))
                    SetProgressTime(pcs);
                break;

            case WM_SHOWWINDOW:
                if (wParam)
                {
                    int idAni;
                    HWND hwndAnimation;

                    ASSERT(pfouiti->wFunc >= FO_MOVE && pfouiti->wFunc <= FO_DELETE);
                    ASSERT(FO_COPY==FO_MOVE+1);
                    ASSERT(FO_DELETE==FO_COPY+1);
                    ASSERT(IDA_FILECOPY==IDA_FILEMOVE+1);
                    ASSERT(IDA_FILEDEL ==IDA_FILECOPY+1);

                    switch (pfouiti->wFunc)
                    {
                        case FO_DELETE:
                            if (pfouiti->bIsEmptyRBOp)
                            {
                                idAni = IDA_FILENUKE;
                                break;
                            }
                            else if (!(pcs->fFlags & FOF_ALLOWUNDO))
                            {
                                idAni = IDA_FILEDELREAL;
                                break;
                            }
                            // else fall through

                        default:
                            idAni = (IDA_FILEMOVE + (int)pfouiti->wFunc - FO_MOVE);
                    }

                    hwndAnimation = GetDlgItem(hDlg,IDD_ANIMATE);

                    Animate_Open(hwndAnimation, IntToPtr(idAni));

                    SetProp(hwndAnimation, TEXT("AnimationID"), IntToPtr(idAni));

                    // a timer every MS_TIMESLICE seconds to update the progress time estimate
                    SetTimer(hDlg, 1, MS_TIMESLICE, NULL);
                }
                break;

            case WM_ENABLE:
                if (wParam)
                {
                    if (pcs->dwPreviousTime)
                    {
                        // if we're enabling it, set the previous time to now
                        // because no action has happened while we were disabled
                        pcs->dwPreviousTime = GetTickCount();
                    }
                }
                else
                {
                    SetProgressTime(pcs);
                }
                PauseAnimation(pcs, wParam == 0);
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                    case IDCANCEL:
                        pcs->bAbort = TRUE;
                        ShowWindow(hDlg, SW_HIDE);
                        break;
                }
                break;

            case PDM_SHUTDOWN:
                // Make sure this window is shown before telling the user there
                // is a problem
                // ignore FOF_NOERRORUI here because of the nature of the situation
                ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_CANTSHUTDOWN),
                        NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                break;

            case PDM_NOOP:
                // a dummy id that we can take so that folks can post to us and make
                // us go through the main loop
                break;

            case PDM_UPDATE:
                pcs->dth.fChangePosted = FALSE;
                UpdateProgressDialog(pcs);
                break;

            case WM_QUERYENDSESSION:
                // Post a message telling the dialog to show the "We can't shutdown now"
                // dialog and return to USER right away, so we don't have to worry about
                // the user not clicking the OK button before USER puts up its "this
                // app didn't respond" dialog
                PostMessage(hDlg, PDM_SHUTDOWN, 0, 0);

                // Make sure the dialog box procedure returns FALSE
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;

            default:
                return FALSE;
        }
    }
    return TRUE;
}

int CALLBACK FOUndo_FileReallyDeletedCallback(UNDOATOM *lpua, LPARAM lParam)
{
    LPTSTR * ppsz = (LPTSTR*)lParam;
    // this is our signal to nuke the rest
    if (!*ppsz)
        return EUA_DELETE;

    switch (lpua->uType) 
    {
        case IDS_RENAME:
        case IDS_COPY:
        case IDS_MOVE:
        case IDS_DELETE: 
            {
                LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
                HDPA hdpa = lpud->hdpa;
                // only the destinations matter.
                int i, iMax = DPA_GetPtrCount(hdpa);
                for (i = 1; i <= iMax; i += 2) 
                {
                    LPTSTR lpsz = DPA_GetPtr(hdpa, i);
                    if (lstrcmpi(lpsz, *ppsz) == 0) 
                    {
                        *ppsz = NULL;
                        break;
                    }
                }
            }
            break;
    }

    // this is our signal to nuke the rest
    if (!*ppsz)
        return EUA_DELETE;
    else
        return EUA_DONOTHING;
}

// someone really really deleted a file.  make sure we no longer have
// any undo information pointing to it.
void FOUndo_FileReallyDeleted(LPTSTR lpszFile)
{
    EnumUndoAtoms(FOUndo_FileReallyDeletedCallback, (LPARAM)&lpszFile);
}


int CALLBACK FOUndo_FileRestoredCallback(UNDOATOM *lpua, LPARAM lParam)
{
    LPTSTR psz = (LPTSTR)lParam;

    switch (lpua->uType) 
    {
        case IDS_DELETE: 
            {
                LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
                HDPA hdpa = lpud->hdpa;
                LPTSTR lpsz;
                int i, iMax;

                ASSERT(hdpa);
                // only the destinations matter.
                iMax = DPA_GetPtrCount(hdpa);
                for (i = 1; i <= iMax; i += 2) 
                {
                    lpsz = DPA_GetPtr(hdpa, i);
                    if (lstrcmpi(lpsz, psz) == 0) 
                    {
                        ENTERCRITICAL;

                        Str_SetPtr(&lpsz, NULL);
                        lpsz = DPA_GetPtr(hdpa, i - 1);
                        Str_SetPtr(&lpsz, NULL);
                        DPA_DeletePtr(hdpa, i);
                        DPA_DeletePtr(hdpa, i - 1);

                        LEAVECRITICAL;

                        if (DPA_GetPtrCount(hdpa))
                            return EUA_ABORT;
                        else
                            return EUA_DELETEABORT;
                    }
                }
            }
            break;
    }
    return EUA_DONOTHING;
}

// this means someone restored a file (via ui in the bitbucket)
// so we need to clean up the undo info.
void FOUndo_FileRestored(LPCTSTR lpszFile)
{
    EnumUndoAtoms(FOUndo_FileRestoredCallback, (LPARAM)lpszFile);
}


void FOUndo_AddInfo(UNDOATOM *lpua, LPTSTR lpszSrc, LPTSTR lpszDest, DWORD dwAttributes)
{
    HDPA hdpa;
    LPTSTR lpsz = NULL;
    int i;
    LPFOUNDODATA lpud;

    if (lpua->lpData == (void *)-1)
        return;

    if (!lpua->lpData) 
    {
        lpua->lpData = LocalAlloc(LPTR, sizeof(FOUNDODATA));
        if (!lpua->lpData)
            return;

        ((LPFOUNDODATA)lpua->lpData)->hdpa = (void *)DPA_Create(4);
    }

    lpud = lpua->lpData;

    hdpa = lpud->hdpa;
    if (!hdpa)
        return;

    // if it's a directory that got deleted, we're just going to save it's
    // attributes so that we can recreate it later.
    // directories do NOT get moved into the wastebasket
    if ((lpua->uType == IDS_DELETE) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        FOUNDO_DELETEDFILEINFO dfi;
        if (!lpud->hdsa)
        {
            lpud->hdsa = DSA_Create(sizeof(FOUNDO_DELETEDFILEINFO),  4);
            if (!lpud->hdsa)
                return;
        }

        Str_SetPtr(&lpsz, lpszSrc);
        dfi.lpszName = lpsz;
        dfi.dwAttributes = dwAttributes;
        DSA_AppendItem(lpud->hdsa, &dfi);
    }
    else
    {    
        Str_SetPtr(&lpsz, lpszSrc);
        if (!lpsz)
            return;

        if ((i = DPA_AppendPtr(hdpa, lpsz)) == -1)
        {
            return;
        }

        lpsz = NULL;
        Str_SetPtr(&lpsz, lpszDest);
        if (!lpsz ||
                DPA_AppendPtr(hdpa, lpsz) == -1)
        {
            DPA_DeletePtr(hdpa, i);
        }
    }
}


LPTSTR DPA_ToFileList(HDPA hdpa, int iStart, int iEnd, int iIncr)
{
    LPTSTR lpsz;
    LPTSTR lpszReturn;
    int ichSize;
    int ichTemp;
    int i;

    // undo copy by deleting destinations
    lpszReturn = (LPTSTR)(void*)LocalAlloc(LPTR, 1);
    if (!lpszReturn)
    {
        return NULL;
    }

    ichSize = 1;
    // build the NULL separated file list
    // go from the end to the front.. restore in reverse order!
    for (i = iEnd; i >= iStart ; i -= iIncr)
    {
        LPTSTR psz;

        lpsz = DPA_GetPtr(hdpa, i);
        ASSERT(lpsz);

        ichTemp  = ichSize - 1;

        ichSize += (lstrlen(lpsz) + 1);
        psz = (LPTSTR)(void*)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
                LMEM_MOVEABLE|LMEM_ZEROINIT);
        if (!psz)
        {
            break;
        }
        lpszReturn = psz;
        lstrcpy(lpszReturn + ichTemp, lpsz);
    }

    if ((i + iIncr) != iStart)
    {
        LocalFree((HLOCAL)lpszReturn);
        lpszReturn = NULL;
    }
    return lpszReturn;
}

// from dpa to:
// 'file 1', 'file 2' and 'file 3'
LPTSTR DPA_ToQuotedFileList(HDPA hdpa, int iStart, int iEnd, int iIncr)
{
    LPTSTR lpsz;
    LPTSTR lpszReturn;
    TCHAR szFile[MAX_PATH];
    int ichSize;
    int ichTemp;
    int i;
    SHELLSTATE ss;

    // undo copy by deleting destinations
    lpszReturn = (LPTSTR)(void*)LocalAlloc(LPTR, 1);
    if (!lpszReturn)
    {
        return NULL;
    }

    SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS|SSF_SHOWALLOBJECTS, FALSE);

    ichSize = 1;
    // build the quoted file list
    for (i = iStart; i < iEnd ; i += iIncr)
    {
        LPTSTR psz;

        ichTemp  = ichSize - 1;

        // get the name (filename only without extension)
        lpsz = DPA_GetPtr(hdpa, i);
        lstrcpy(szFile, PathFindFileName(lpsz));
        if (!ss.fShowExtensions)
        {
            PathRemoveExtension(szFile);
        }

        // grow the buffer and add it in
        ichSize += lstrlen(szFile) + 2;
        psz = (LPTSTR)(void*)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
                LMEM_MOVEABLE|LMEM_ZEROINIT);
        if (!psz)
        {
            LocalFree(lpszReturn);
            lpszReturn = NULL;
            break;
        }
        lpszReturn = psz;

        // is it too long?
        if (ichSize >= MAX_PATH)
        {
            lstrcat(lpszReturn, c_szEllipses);
            return lpszReturn;
        }
        else
        {
            StrCatBuff(lpszReturn, TEXT("'"), ichSize); //A single quote BEFORE the filename.
            StrCatBuff(lpszReturn, szFile, ichSize);
            StrCatBuff(lpszReturn, TEXT("'"), ichSize); //A single quote AFTER the filename.
        }

        ASSERT(ichSize == ichTemp + (lstrlen(lpszReturn + ichTemp) + 1));
        ichTemp  = ichSize - 1;

        // check to see if we need the "and"
        if ((i + iIncr) < iEnd)
        {
            TCHAR szTemp[40];
            int id;

            ichSize += 40;

            if ((i + (iIncr*2)) >= iEnd)
            {
                id = IDS_SPACEANDSPACE;
            }
            else
            {
                id = IDS_COMMASPACE;
            }

            psz = (LPTSTR)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
                    LMEM_MOVEABLE|LMEM_ZEROINIT);
            if (!psz)
            {
                LocalFree(lpszReturn);
                lpszReturn = NULL;
                break;
            }
            lpszReturn = psz;
            LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
            StrCatBuff(lpszReturn, szTemp, ichSize);
            ichSize = ichTemp + (lstrlen(lpszReturn + ichTemp) + 1);
        }
    }
    return lpszReturn;
}


void CALLBACK FOUndo_GetText(UNDOATOM *lpua, TCHAR * buffer, int type)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    HDPA hdpa = lpud->hdpa;

    if (type == UNDO_MENUTEXT)
    {
        LoadString(HINST_THISDLL, lpua->uType, buffer, MAX_PATH);
    }
    else
    {
        TCHAR szTemplate[80];
        // thank god for growable stacks..
        TCHAR szFile1[MAX_PATH];
        TCHAR szFile2[MAX_PATH];
        TCHAR szFile1Short[30];
        TCHAR szFile2Short[30];
        TCHAR *lpszFile1;
        TCHAR *lpszFile2;

        // get the template
        LoadString(HINST_THISDLL, lpua->uType + (IDS_UNDO_FILEOPHELP - IDS_UNDO_FILEOP), szTemplate, ARRAYSIZE(szTemplate));

        if (lpua->uType == IDS_RENAME)
        {
            SHELLSTATE ss;
            LPTSTR pszTemp;

            // fill in the file names
            lpszFile1 = DPA_GetPtr(hdpa, 0);
            lpszFile2 = DPA_GetPtr(hdpa, 1);
            lstrcpy(szFile1, PathFindFileName(lpszFile1));
            lstrcpy(szFile2, PathFindFileName(lpszFile2));

            SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
            if (!ss.fShowExtensions)
            {
                PathRemoveExtension(szFile1);
                PathRemoveExtension(szFile2);
            }

            // length sanity check
            // don't just whack "..." at 30 bytes into szFile1 since that may be a dbcs character...
            PathCompactPathEx(szFile1Short, szFile1, ARRAYSIZE(szFile1Short), 0);
            PathCompactPathEx(szFile2Short, szFile2, ARRAYSIZE(szFile2Short), 0);

            pszTemp = ShellConstructMessageString(HINST_THISDLL, szTemplate, szFile1Short, szFile2Short);
            if (pszTemp)
            {
                StrCpyN(buffer, pszTemp, MAX_PATH);
                LocalFree(pszTemp);
            }
        }
        else
        {
            TCHAR *lpszFile1;
            HDPA hdpaFull = hdpa;
            // in the case of delete (where ther's an hdsa)
            // we need to add in the names of folders deleted
            // we do this by cloning the hdpa and tacking on our names.
            if (lpud->hdsa)
            {
                hdpaFull = DPA_Clone(hdpa, NULL);
                if (hdpaFull)
                {
                    int iMax;
                    int i;
                    LPFOUNDO_DELETEDFILEINFO lpdfi;
                    iMax = DSA_GetItemCount(lpud->hdsa);
                    for (i = 0; i < iMax; i++)
                    {
                        lpdfi = DSA_GetItemPtr(lpud->hdsa, i);
                        DPA_AppendPtr(hdpaFull, lpdfi->lpszName);
                        DPA_AppendPtr(hdpaFull, lpdfi->lpszName);
                    }
                }
                else
                {
                    hdpaFull = hdpa;
                }
            }
            lpszFile1 = DPA_ToQuotedFileList(hdpaFull, 0, DPA_GetPtrCount(hdpaFull), 2);
            wnsprintf(buffer, MAX_PATH, szTemplate, lpszFile1);
            LocalFree((HLOCAL)lpszFile1);
            if (hdpaFull != hdpa)
            {
                DPA_Destroy(hdpaFull);
            }
        }
    }
}


void CALLBACK FOUndo_Release(UNDOATOM *lpua)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    int i;
    LPTSTR lpsz;
    if (lpud && (lpud != (void *)-1))
    {
        HDPA hdpa = lpud->hdpa;
        HDSA hdsa = lpud->hdsa;
        if (hdpa)
        {
            i = DPA_GetPtrCount(hdpa) - 1;
            for (; i >= 0; i--)
            {
                lpsz = DPA_FastGetPtr(hdpa, i);
                Str_SetPtr(&lpsz, NULL);
            }
            DPA_Destroy(hdpa);
        }

        if (hdsa)
        {
            LPFOUNDO_DELETEDFILEINFO lpdfi;
            i = DSA_GetItemCount(hdsa) - 1;
            for (; i >= 0 ; i--)
            {
                lpdfi = DSA_GetItemPtr(hdsa, i);
                Str_SetPtr(&lpdfi->lpszName, NULL);
            }
            DSA_Destroy(hdsa);
        }
        LocalFree(lpud);
        lpua->lpData = (void *)-1;
    }
}

DWORD WINAPI FOUndo_InvokeThreadInit(UNDOATOM *lpua)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    HDPA hdpa = lpud->hdpa;
    HWND hwnd = lpua->hwnd;
    BOOL fNukeAtom = TRUE;
    SHFILEOPSTRUCT sFileOp =
    {
        hwnd,
        0,
        NULL,
        NULL,
        0,
    } ;
    int iMax;

    SuspendUndo(TRUE);
    iMax = DPA_GetPtrCount(hdpa);
    switch (lpua->uType)
    {
        case IDS_RENAME:
            {
                TCHAR szFromPath[MAX_PATH + 1];
                if (iMax < 2)
                    goto Exit;

                sFileOp.wFunc = FO_RENAME;
                sFileOp.pFrom = DPA_GetPtr(hdpa, 1);
                sFileOp.pTo = DPA_GetPtr(hdpa, 0);
                if (sFileOp.pFrom && sFileOp.pTo)
                {
                    lstrcpy(szFromPath, sFileOp.pFrom);
                    szFromPath[lstrlen(sFileOp.pFrom) + 1] = 0;
                    sFileOp.pFrom = szFromPath;
                    SHFileOperation(&sFileOp);
                    if (sFileOp.fAnyOperationsAborted)
                    {
                        fNukeAtom = FALSE;
                    }
                }
                // In the rename case the DPA owns these pointers, in all other cases
                // they must be freed below.  To prevent freeing these during a rename
                // we NULL them out when we're done with them
                sFileOp.pFrom = NULL;
                sFileOp.pTo = NULL;
            }
            break;

        case IDS_COPY:
            sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax - 1, 2);
            if (!sFileOp.pFrom)
                goto Exit;
            sFileOp.wFunc = FO_DELETE;
            //
            // If this delete is occuring because of an automatic undo caused by
            // connected files, then do not ask for confirmation.
            //
            if (lpua->foFlags & FOF_NOCONFIRMATION)
                sFileOp.fFlags |= FOF_NOCONFIRMATION;

            SHFileOperation(&sFileOp);
            if (sFileOp.fAnyOperationsAborted)
            {
                fNukeAtom = FALSE;
            }
            break;

        case IDS_MOVE:
            sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax-1, 2);
            sFileOp.pTo = DPA_ToFileList(hdpa, 0, iMax-2, 2);
            if (!sFileOp.pFrom || !sFileOp.pTo)
                goto Exit;
            sFileOp.wFunc = FO_MOVE;
            sFileOp.fFlags = FOF_MULTIDESTFILES;
            if (lpua->foFlags & FOF_NOCOPYSECURITYATTRIBS)
            {
                sFileOp.fFlags |= FOF_NOCOPYSECURITYATTRIBS;
            }
            SHFileOperation(&sFileOp);
            if (sFileOp.fAnyOperationsAborted)
            {
                fNukeAtom = FALSE;
            }
            break;

        case IDS_DELETE:
            {
                // first create any directories
                if (lpud->hdsa)
                {
                    HDSA hdsa = lpud->hdsa;
                    int i;
                    // do it in reverse order to get the parentage right
                    for (i = DSA_GetItemCount(hdsa) - 1; i >= 0; i--)
                    {
                        LPFOUNDO_DELETEDFILEINFO lpdfi = DSA_GetItemPtr(hdsa, i);
                        if (lpdfi)
                        {
                            if (Win32CreateDirectory(lpdfi->lpszName, NULL))
                            {
                                SetFileAttributes(lpdfi->lpszName, lpdfi->dwAttributes & ~FILE_ATTRIBUTE_DIRECTORY);
                            }
                        }
                    }
                }

                if (iMax)
                {
                    sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax-1, 2);
                    sFileOp.pTo = DPA_ToFileList(hdpa, 0, iMax-2, 2);
                    if (!sFileOp.pFrom || !sFileOp.pTo)
                        goto Exit;
                    UndoBBFileDelete(sFileOp.pTo, sFileOp.pFrom);
                }
                break;
            }
    }
    SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);

Exit:
    if (sFileOp.pFrom)
        LocalFree((HLOCAL)sFileOp.pFrom);
    if (sFileOp.pTo)
        LocalFree((HLOCAL)sFileOp.pTo);

    SuspendUndo(FALSE);
    if (fNukeAtom)
        NukeUndoAtom(lpua);
    return 1;
}

void CALLBACK FOUndo_Invoke(UNDOATOM *lpua)
{
    DWORD idThread;
    HANDLE hthread = CreateThread(NULL, 0, FOUndo_InvokeThreadInit, lpua, 0, &idThread);
    if (hthread) 
        CloseHandle(hthread);
}

UNDOATOM *FOAllocUndoAtom(LPSHFILEOPSTRUCT lpfo)
{
    UNDOATOM *lpua = (UNDOATOM *)LocalAlloc(LPTR, sizeof(*lpua));
    if (lpua)
    {
        lpua->uType = FOFuncToStringID(lpfo->wFunc);
        lpua->GetText = FOUndo_GetText;
        lpua->Invoke = FOUndo_Invoke;
        lpua->Release = FOUndo_Release;
        lpua->foFlags = 0;

        if (lpfo->fFlags & FOF_NOCOPYSECURITYATTRIBS)
        {
            lpua->foFlags |= FOF_NOCOPYSECURITYATTRIBS;
        }
    }
    return lpua;
}

//============================================================================
//
// The following function is the mainline function for COPYing, RENAMEing,
// DELETEing, and MOVEing single or multiple files.
//
// in:
// hwnd         the parent to create the progress dialog from if FOF_CREATEPROGRESSDLG is set.
//
//
// wFunc        operation to be performed:
//              FO_DELETE - Delete files in pFrom (pTo unused)
//              FO_RENAME - Rename files
//              FO_MOVE   - Move files in pFrom to pTo
//              FO_COPY   - Copy files in pFrom to pTo
//
// pFrom        list of source file specs either qualified or
//              unqualified.  unqualified names will be qualified based on the current
//              global current directories.  examples include
//              "foo.txt bar.txt *.bak ..\*.old dir_name"
//
// pTo          destination file spec.
//
// fFlags       flags that control the operation
//
// returns:
//      0 indicates success
//      != 0 is the DE_ (dos error code) of last failed operation
//
//
//===========================================================================

int WINAPI SHFileOperation(LPSHFILEOPSTRUCT lpfo)
{
    int ret;
    BOOL bRecycledStuff = FALSE;
    COPY_STATE *pcs; 

    if (!lpfo || !lpfo->pFrom)
    {
        // return an error instead of waiting to AV
        return ERROR_INVALID_PARAMETER;
    }

    lpfo->fAnyOperationsAborted = FALSE;
    lpfo->hNameMappings = NULL;

    if (lpfo->wFunc < FO_MOVE || lpfo->wFunc > FO_RENAME)   // validate
    {
        // NOTE: We used to return 0 here (win95gold -> IE401). 
        //
        // If we run into app compat bugs because they were relying on the old 
        // buggy return value, then add an app hack here.
        // 
        // this is not a DE_ error, and I don't care!
        return ERROR_INVALID_PARAMETER;
    }

    pcs = (COPY_STATE*)LocalAlloc(LPTR, sizeof(COPY_STATE));
    if (!pcs)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pcs->nRef = 1;

    //
    //  REVIEW:  We want to allow copying of a file within a given directory
    //           by having default renaming on collisions within a directory.
    //
    if (!(lpfo->fFlags & FOF_NOCONFIRMATION))
    {
        pcs->cd.fConfirm =
            CONFIRM_DELETE_FILE         |
            CONFIRM_DELETE_FOLDER       |
            CONFIRM_REPLACE_FILE        |
            CONFIRM_REPLACE_FOLDER      |
            CONFIRM_WONT_RECYCLE_FILE   |
            CONFIRM_WONT_RECYCLE_FOLDER |
            CONFIRM_PATH_TOO_LONG       |
            //          CONFIRM_MOVE_FILE           |
            //          CONFIRM_MOVE_FOLDER         |
            //          CONFIRM_RENAME_FILE         |
            //          CONFIRM_RENAME_FOLDER       |
            CONFIRM_SYSTEM_FILE         |
            CONFIRM_READONLY_FILE       |
            CONFIRM_MULTIPLE            |
            CONFIRM_PROGRAM_FILE        |
            CONFIRM_STREAMLOSS          |
            CONFIRM_FAILED_ENCRYPT      |
            CONFIRM_LFNTOFAT            |
            CONFIRM_WONT_RECYCLE_OFFLINE |
            CONFIRM_LOST_ENCRYPT_FILE |
            CONFIRM_LOST_ENCRYPT_FOLDER;
    }

    if (lpfo->fFlags & FOF_WANTNUKEWARNING)
    {
        // We will warn the user that the thing they thought was going to be recycled is
        // now really going to be nuked. (eg drag-drop folder on recycle bin, but it turns
        // out that the folder is too big for the bitbucket, so we confirm on the wont-recycle
        // cases).
        // 
        // Also, we keep the system file / readonly file / progran file warnings around for good
        // measure.
        pcs->cd.fConfirm |= CONFIRM_WONT_RECYCLE_FILE   |
            CONFIRM_WONT_RECYCLE_FOLDER |
            CONFIRM_PATH_TOO_LONG       |
            CONFIRM_SYSTEM_FILE         |
            CONFIRM_READONLY_FILE       |
            CONFIRM_PROGRAM_FILE        |
            CONFIRM_WONT_RECYCLE_OFFLINE;
    }


    pcs->fFlags = lpfo->fFlags;   // duplicate some stuff here
    pcs->lpszProgressTitle = lpfo->lpszProgressTitle;
    pcs->lpfo = lpfo;

    // Check to see if we need to operate on the "connected" files and folders too!
    if (!(pcs->fFlags & FOF_NO_CONNECTED_ELEMENTS))
    {
        DWORD   dwFileFolderConnection = 0;
        DWORD   dwSize = sizeof(dwFileFolderConnection);
        DWORD   dwType = REG_DWORD;

        if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, 
                    REG_VALUE_NO_FILEFOLDER_CONNECTION, &dwType, &dwFileFolderConnection, 
                    &dwSize) == ERROR_SUCCESS)
        {
            //If the registry says "No connection", then set the flags accordingly.
            if (dwFileFolderConnection == 1)
            {
                pcs->fFlags = pcs->fFlags | FOF_NO_CONNECTED_ELEMENTS;
            }
        }
    }

    // Always create a progress dialog
    // Note that it will be created invisible, and will be shown if the
    // operation takes longer than a second to perform
    // Note the parent of this window is NULL so it will get the QUERYENDSESSION
    // message
    if (!(pcs->fFlags & FOF_SILENT))
    {
        SHCreateThread(FOUIThreadProc, pcs, 0, AddRefPCS);
    }
    else 
    {
        // To be compatible with Win95 semantics...
        if (!lpfo->hwnd)
        {
            pcs->fFlags |= FOF_NOERRORUI;
        }
    }

    if (lpfo->hwnd)
    {
        // The caller will be disabled if we ever show the progress window
        // We need to make sure this is not disabled now because if it is and
        // another dialog uses this as its parent, USER code will tell this
        // window it got the focus while it is still disabled, which keeps it
        // from passing that focus down to its children
        // EnableWindow(lpfo->hwnd, FALSE);
        pcs->hwndDlgParent = lpfo->hwnd;
    }

    // do this always.. even if this is not an undoable op, we could be
    // affecting something that is.
    SuspendUndo(TRUE);

    if (lpfo->fFlags & FOF_ALLOWUNDO)
    {
        pcs->lpua = FOAllocUndoAtom(lpfo);
        if (lpfo->wFunc == FO_DELETE)
        {
            // We check the shell state to see if the user has turned on the
            // "Don't confirm deleting recycle bin contents" flag.  If yes,
            // then we store this flag and check against it if this case occures.
            // Review: Not a super common case, why not just check when the
            // flag is actually needed?
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);
            pcs->fNoConfirmRecycle = ss.fNoConfirmRecycle;

            if (InitBBGlobals())
            {
                // since we are going to be recycling stuff, we add ourselves to the
                // global list of threads who are recycling
                SHGlobalCounterIncrement(g_hgcNumDeleters);
                bRecycledStuff = TRUE;
            }
            else
            {
                // this shouldnt happen, but if it does we can't send stuff to the Recycle
                // Bin, instead we remove the undo flag so that everything is really nuked.
                lpfo->fFlags &= ~FOF_ALLOWUNDO;
                LocalFree(pcs->lpua);
                pcs->lpua = NULL;
            }
        }

    }

    // While doing the file operation, tell PnP not to suspend
    // the machine.  Otherwise, you could be copying a lot of files
    // over the network and have the laptop suddenly hibernate on you
    // because PnP thought you were idle.
    //
    // Indicate that we only need the system.  It's okay if the display
    // goes into low-power mode, as long as we can keep copying.
    //

    SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

    ret = MoveCopyDriver(pcs);

    SetThreadExecutionState(ES_CONTINUOUS);

    if (pcs->bAbort)
    {
        ASSERT(pcs->lpfo == lpfo);
        lpfo->fAnyOperationsAborted = TRUE;
    }

    if (bRecycledStuff)
    {
        SHUpdateRecycleBinIcon();

        if (0 == SHGlobalCounterDecrement(g_hgcNumDeleters))
        {
            // We were the last guy who was deleting stuff. Thus, we need to
            // check to see if any of the bitbuckets info files neeed compacting or purging
            CheckCompactAndPurge();
        }
    }

    if (pcs->lpCopyBuffer)
    {
        LocalFree((HLOCAL)pcs->lpCopyBuffer);
        pcs->lpCopyBuffer = NULL;
    }

    if (pcs->lpua)
    {
        if (pcs->lpua->lpData && (pcs->lpua->lpData != (void *)-1))
        {
            AddUndoAtom(pcs->lpua);
        }
        else
        {
            FOUndo_Release(pcs->lpua);
            NukeUndoAtom(pcs->lpua);
        }
    }

    // NTRAID89119 (toddb): This code is totally busted in respect to mounted volumes.
    // We will send a change notify for the drive on which your volume is mounted
    // instead of on the volume which actually had a free space change.  We need
    // to update PathGetDriveNumber to handle mounted volumes

    // notify of freespace changes
    // rename doesn't change drive usage
    if (lpfo->wFunc != FO_RENAME)
    {
        int idDriveSrc;
        int idDriveDest = -1;
        DWORD dwDrives = 0; // bitfield for drives

        if (lpfo->wFunc == FO_COPY)
        {
            // nothing changes on the source
            idDriveSrc = -1;
        }
        else
        {
            idDriveSrc = PathGetDriveNumber(lpfo->pFrom);
        }

        if (lpfo->pTo)
        {
            idDriveDest = PathGetDriveNumber(lpfo->pTo);
        }

        if ((lpfo->wFunc == FO_MOVE) && (idDriveDest == idDriveSrc))
        {
            // no freespace nothing changes
            idDriveSrc = -1;
            idDriveDest = -1;
        }

        // NTRAID89119: What if idDriveSrc or idDriveDest are > 32?  This is totally
        // possible under NT by using mounted volumes.  SHChangeNotify is busted
        // in this respect.

        if (idDriveSrc != -1)
        {
            dwDrives |= (1 << idDriveSrc);
        }

        if (idDriveDest != -1)
        {
            dwDrives |= (1 << idDriveDest);
        }

        if (dwDrives)
        {
            SHChangeNotify(SHCNE_FREESPACE, SHCNF_DWORD, IntToPtr(dwDrives), 0);
        }
    }

    SuspendUndo(FALSE);

    if (!(lpfo->fFlags & FOF_WANTMAPPINGHANDLE))
    {
        SHFreeNameMappings(lpfo->hNameMappings);
        lpfo->hNameMappings = NULL;
    }

    // shut down the progress dialog
    //    
    // this is necessary so that the ui thread won't block
    pcs->fProgressOk = TRUE;

    ENTERCRITICAL;  // need to take critsec to sync w/ the UI thread
    pcs->fDone = TRUE;
    if (pcs->hwndProgress)
    {
        PostMessage(pcs->hwndProgress, PDM_NOOP, 0, 0);
    }
    LEAVECRITICAL;

    if (lpfo->hwnd)
    {
        EnableWindow(lpfo->hwnd, TRUE);
    }

    ReleasePCS(pcs);

    return ret;
}

#ifdef UNICODE
int WINAPI SHFileOperationA(LPSHFILEOPSTRUCTA lpfo)
{
    int iResult;
    UINT uTotalSize;
    UINT uSize;
    UINT uSizeTitle;
    UINT uSizeW;
    SHFILEOPSTRUCTW shop;
    LPCSTR lpAnsi;
    LPWSTR lpBuffer;
    LPWSTR lpTemp;

    COMPILETIME_ASSERT(sizeof(SHFILEOPSTRUCTW) == sizeof(SHFILEOPSTRUCTA));

    hmemcpy(&shop, lpfo, sizeof(SHFILEOPSTRUCTW));

    //
    // Thunk the strings as appropriate
    //
    uTotalSize = 0;
    if (lpfo->pFrom)
    {
        lpAnsi = lpfo->pFrom;
        do {
            uSize = lstrlenA(lpAnsi) + 1;
            uTotalSize += uSize;
            lpAnsi += uSize;
        } while (uSize != 1);
    }

    if (lpfo->pTo)
    {
        lpAnsi = lpfo->pTo;
        do {
            uSize = lstrlenA(lpAnsi) + 1;
            uTotalSize += uSize;
            lpAnsi += uSize;
        } while (uSize != 1);
    }

    if ((lpfo->fFlags & FOF_SIMPLEPROGRESS) && lpfo->lpszProgressTitle != NULL)
    {
        uSizeTitle = lstrlenA(lpfo->lpszProgressTitle) + 1;
        uTotalSize += uSizeTitle;
    }

    if (uTotalSize != 0)
    {
        lpTemp = lpBuffer = LocalAlloc(LPTR, uTotalSize*sizeof(WCHAR));
        if (!lpBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        lpBuffer = NULL;
    }

    //
    // Now convert the strings
    //
    if (lpfo->pFrom)
    {
        shop.pFrom = lpTemp;
        lpAnsi = lpfo->pFrom;
        do
        {
            uSize = lstrlenA(lpAnsi) + 1;
            uSizeW = MultiByteToWideChar(CP_ACP, 0,
                    lpAnsi, uSize,
                    lpTemp, uSize);
            lpAnsi += uSize;
            lpTemp += uSizeW;
        } while (uSize != 1);
    }
    else
    {
        shop.pFrom = NULL;
    }

    if (lpfo->pTo)
    {
        shop.pTo = lpTemp;
        lpAnsi = lpfo->pTo;
        do
        {
            uSize = lstrlenA(lpAnsi) + 1;
            uSizeW = MultiByteToWideChar(CP_ACP, 0,
                    lpAnsi, uSize,
                    lpTemp, uSize);
            lpAnsi += uSize;
            lpTemp += uSizeW;
        } while (uSize != 1);
    }
    else
    {
        shop.pTo = NULL;
    }


    if ((lpfo->fFlags & FOF_SIMPLEPROGRESS) && lpfo->lpszProgressTitle != NULL)
    {
        shop.lpszProgressTitle = lpTemp;
        MultiByteToWideChar(CP_ACP, 0,
                lpfo->lpszProgressTitle, uSizeTitle,
                lpTemp, uSizeTitle);
    }
    else
    {
        shop.lpszProgressTitle = NULL;
    }

    iResult = SHFileOperationW(&shop);

    // link up the two things in the SHFILEOPSTRUCT that could have changed
    lpfo->fAnyOperationsAborted = shop.fAnyOperationsAborted;
    lpfo->hNameMappings = shop.hNameMappings;

    if (lpBuffer)
        LocalFree(lpBuffer);

    return iResult;
}

#else

int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpfo)
{
    return E_NOTIMPL;   
}
#endif


// In:
//      pcs:  copy_state structure containing the state of the copy
//
// feedback: If the estimated time to copmplete a copy is larger than
//   MINTIME4FEEDBACK, the user is given a time to completion estimate in minutes.
//   The estimate is calculated using a MS_RUNAVG seconds running average.  The
//   initial estimate is done after MS_TIMESLICE

void SetProgressTime(COPY_STATE *pcs)
{
    DWORD dwNow = GetTickCount();

    if (pcs->dwPreviousTime)
    {

        int iPointsTotal = CountProgressPoints(pcs, &pcs->dth.dtAll);
        int iPointsDone = CountProgressPoints(pcs, &pcs->dth.dtDone);
        int iPointsDelta = iPointsDone - pcs->iLastProgressPoints;
        DWORD dwTimeLeft;

        //
        // A couple of times the shell has reported bad time remaining
        // we need to find out why.
        //
        ASSERT(iPointsTotal >= 0);
        ASSERT(iPointsDone >= 0);
        ASSERT(iPointsTotal >= iPointsDone);
        ASSERT(iPointsDelta >= 0);

        // has enough time elapsed to update the display
        // We do this every 10 seconds, but we'll do the first one after
        // only a few seconds

        if (iPointsDelta && (iPointsDone > 0) && (dwNow - pcs->dwPreviousTime))
        {
            DWORD dwPointsPerSec;
            DWORD dwTime; // how many tenths of a second have gone by

            // We take 10 times the number of Points and divide by the number of
            // tenths of a second to minimize both overflow and roundoff
            dwTime = (dwNow - pcs->dwPreviousTime)/100;
            if (dwTime == 0)
                dwTime = 1;
            dwPointsPerSec = iPointsDelta * 10 / dwTime;
            if (!dwPointsPerSec)
            {
                // This could happen if the net went to sleep for a couple
                // minutes while trying to copy a small (512 byte) buffer
                dwPointsPerSec = 1;
            }

            // if we didn't have enough time to get a good sample,
            // don't use this last bit as a time estimater
            if ((dwNow - pcs->dwPreviousTime) < (MS_TIMESLICE/2))
            {
                dwPointsPerSec = pcs->dwPointsPerSec;
            }

            if (pcs->dwPointsPerSec)
            {
                // Take a weighted average of the current transfer rate and the
                // previously computed one, just to try to smooth out
                // some random fluctuations

                dwPointsPerSec = (dwPointsPerSec + (pcs->dwPointsPerSec * 2)) / 3;
            }

            // never allow 0 points per second.. just tack it on to next time
            if (dwPointsPerSec)
            {
                pcs->dwPointsPerSec = dwPointsPerSec;

                // Calculate time remaining (round up by adding 1)
                // We only get here every 10 seconds, so always update
                dwTimeLeft = ((iPointsTotal - iPointsDone) / dwPointsPerSec) + 1;

                // It would be odd to show "1 second left" and then immediately
                // clear it
                if (dwTimeLeft >= MIN_MINTIME4FEEDBACK)
                {
                    // display new estimate of time left
                    SetProgressTimeEst(pcs, dwTimeLeft);
                }
            }

        }
        // Reset previous time and # of Points read
        pcs->dwPreviousTime = dwNow;
        pcs->iLastProgressPoints = iPointsDone;
    }
}

void InitClipConfirmDlg(HWND hDlg, CONFDLG_DATA *pcd)
{
    TCHAR szMessage[255];
    TCHAR szDeleteWarning[80];
    SHFILEINFO sfiDest;
    LPTSTR pszFileDest = NULL;
    LPTSTR pszMsg, pszSource;
    int i;
    int cxWidth;
    RECT rc;

    // get the size of the text boxes
    GetWindowRect(GetDlgItem(hDlg, pcd->idText), &rc);
    cxWidth = rc.right - rc.left;

    // get the source display name
    pszSource = PathFindFileName(pcd->pFileSource);
    PathCompactPath(NULL, pszSource, cxWidth);

    // get the dest display name
    SHGetFileInfo(pcd->pFileDest, 0,
            &sfiDest, sizeof(sfiDest), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    pszFileDest = sfiDest.szDisplayName;
    PathCompactPath(NULL, pszFileDest, cxWidth);

    // if we're supposed to show the date info, grab the icons and format the date string
    if (pcd->bShowDates) 
    {
        SHFILEINFO sfi2;
        TCHAR szDateSrc[64], szDateDest[64];

        // likely that this data may be incomplete... leave it saying "Unknown date and size"
        if (BuildDateLine(szDateSrc, pcd->pfdSource, pcd->pFileSource))
            SetDlgItemText(hDlg, IDD_FILEINFO_NEW,  szDateSrc);

        BuildDateLine(szDateDest, pcd->pfdDest, pcd->pFileDest);
        SetDlgItemText(hDlg, IDD_FILEINFO_OLD,  szDateDest);

        SHGetFileInfo(pcd->pFileSource, pcd->pfdSource ? pcd->pfdSource->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdSource ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_NEW, sfi2.hIcon);

        SHGetFileInfo(pcd->pFileDest, pcd->pfdDest ? pcd->pfdDest->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdDest ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_OLD, sfi2.hIcon);
    }

    // there are 5 controls:
    // IDD_TEXT contains regular text (normal file/folder)
    // IDD_TEXT1 through IDD_TEXT4 contain optional secondary text
    for (i = IDD_TEXT; i <= IDD_TEXT4; i++)
    {
        if (i == pcd->idText)
        {
            szMessage[0] = 0;
            GetDlgItemText(hDlg, i, szMessage, ARRAYSIZE(szMessage));
        }
        else
        {
            HWND hwndCtl = GetDlgItem(hDlg, i);
            if (hwndCtl)
            {
                ShowWindow(hwndCtl, SW_HIDE);
            }
        }
    }

    szDeleteWarning[0] = 0;

    pszMsg = ShellConstructMessageString(HINST_THISDLL, szMessage,
            pszSource, pszFileDest, szDeleteWarning);

    if (pszMsg)
    {
        SetDlgItemText(hDlg, pcd->idText, pszMsg);
        LocalFree(pszMsg);
    }
}

void FileDescToWin32FileData(LPFILEDESCRIPTOR pfdsc, LPWIN32_FIND_DATA pwfd)
{
    ZeroMemory(pwfd, sizeof(*pwfd));

    if (pfdsc->dwFlags & FD_ATTRIBUTES)
        pwfd->dwFileAttributes = pfdsc->dwFileAttributes;
    if (pfdsc->dwFlags & FD_CREATETIME)
        hmemcpy(&pwfd->ftCreationTime, &pfdsc->ftCreationTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_ACCESSTIME)
        hmemcpy(&pwfd->ftLastAccessTime, &pfdsc->ftLastAccessTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_WRITESTIME)
        hmemcpy(&pwfd->ftLastWriteTime, &pfdsc->ftLastWriteTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_FILESIZE)
    {
        pwfd->nFileSizeHigh = pfdsc->nFileSizeHigh;
        pwfd->nFileSizeLow = pfdsc->nFileSizeLow;
    }
    lstrcpy(pwfd->cFileName, pfdsc->cFileName);
}

INT_PTR ValidateCreateFileFromClip(HWND hwnd, LPFILEDESCRIPTOR pfdscSrc, TCHAR *pszPathDest, PYNLIST pynl)
{
    WIN32_FIND_DATA wfdSrc, wfdDest;
    CONFDLG_DATA cdd;
    CONFIRM_DATA cd;
    COPY_STATE cs;
    INT_PTR result;

    //
    // If the destination does not exist, we are done.
    //
    HANDLE hff = FindFirstFile(pszPathDest, &wfdDest);
    if (hff == INVALID_HANDLE_VALUE)
    {
        return IDYES;
    }
    FindClose(hff);

    //
    // Maybe this was just a short name collision and
    // we can quickly get out of here.
    //
    if (ResolveShortNameCollisions(pszPathDest, &wfdDest))
    {
        return IDYES;
    }

    //
    // Most of the helper functions want a WIN32_FILE_DATA
    // and not a FILEDESCRIPTOR, so we create wfd for the
    // source file on the fly.
    //
    FileDescToWin32FileData(pfdscSrc, &wfdSrc);

    //
    // Take care of the easy cases - can't copy a file to a dir
    // or a dir to a file.
    //
    if ((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            ((wfdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
        ZeroMemory(&cs, sizeof(cs));
        cs.hwndDlgParent = hwnd;

        CopyError(&cs, wfdSrc.cFileName, pszPathDest, DE_FILEDESTISFLD | ERRORONDEST, FO_COPY, OPER_DOFILE);
        return IDNO;
    }
    else if (((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            (wfdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ZeroMemory(&cs, sizeof(cs));
        cs.hwndDlgParent = hwnd;

        CopyError(&cs, wfdSrc.cFileName, pszPathDest, DE_FLDDESTISFILE | ERRORONDEST, FO_COPY, OPER_DOFILE);

        AddToNoList(pynl, pszPathDest);

        return IDNO;
    }

    //
    // We need a confirmation dialog.  Fill in the
    // ConfirmDialogData (cdd) here.
    //

    ZeroMemory(&cdd, sizeof(cdd));

    cdd.InitConfirmDlg = InitClipConfirmDlg;
    cdd.idText = IDD_TEXT;
    cdd.pFileSource = pfdscSrc->cFileName;
    cdd.pfdSource = &wfdSrc;
    cdd.pFileDest = pszPathDest;
    cdd.pfdDest = &wfdDest;
    cdd.bShowDates = FALSE;
    cdd.pcd = &cd;

    ZeroMemory(&cd, sizeof(cd));
    cd.fConfirm = CONFIRM_REPLACE_FILE;
    cdd.fYesToAllMask = CONFIRM_REPLACE_FILE;

    if (((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            (wfdDest.dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
    {
        if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
        {
            cdd.idText = IDD_TEXT2;
        }
        else if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
        {
            cdd.idText = IDD_TEXT1;
        }
    }

    //
    // What we do now depends on whether we are processing a directory
    // or a file.
    //
    if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        //
        // If this directory is already in the yes list,
        // the parent directory must have already conflicted
        // and the user said "yes, move the dir contents over".
        //
        if (IsInYesList(pynl, pszPathDest))
        {
            result = IDYES;
        }
        else
        {
            //
            // Copying directory to a destination with the same directory.
            //
            result = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_REPLACE_FOLDER), hwnd, ConfirmDlgProc, (LPARAM)&cdd);

            if (result == IDYES)
            {
                if (cd.fConfirm & CONFIRM_REPLACE_FILE)
                {
                    AddToYesList(pynl, pszPathDest);
                }
                else
                {
                    SetYesToAll(pynl);
                }
            }
            else if (result == IDNO)
            {
                AddToNoList(pynl, pszPathDest);
            }
        }
    }
    else
    {
        if (IsInYesList(pynl, pszPathDest))
        {
            result = IDYES;
        }
        else
        {
            //
            // Copying a file to a destination with the same file.
            //
            cdd.bShowDates = TRUE;

            result = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_REPLACE_FILE), hwnd, ConfirmDlgProc, (LPARAM)&cdd);

            if (result == IDYES)
            {
                if ((cd.fConfirm & CONFIRM_REPLACE_FILE) == 0)
                {
                    SetYesToAll(pynl);
                }
            }
        }
    }

    return result;
}


// We can get transient file locks for moving files, for example extracting a thumbnail on a background task
// so we wrap our single check in a loop of multiple checks with a short nap between.  We'd expect
// to get the ERROR_SHARING_VIOLATION, but in practice we also say ERROR_ACCESS_DENIED, so we'll try that
// as well

#define MAX_DELETE_ATTEMPTS  5
#define SLEEP_DELETE_ATTEMPT 1000

BOOL _IsFileDeletable(LPCTSTR pszFile)
{
    int iAttempt = 0;
    BOOL bRet;
    while (!(bRet = IsFileDeletable(pszFile)) && (iAttempt < MAX_DELETE_ATTEMPTS))
    {
        DWORD dwError = GetLastError();

        if ((dwError == ERROR_ACCESS_DENIED) || (dwError == ERROR_SHARING_VIOLATION))
        {
            iAttempt++;
            Sleep(SLEEP_DELETE_ATTEMPT);
        }
        else
        {
            break;
        }
    }

    return (bRet);
}

BOOL _IsDirectoryDeletable(LPCTSTR pszDir)
{
    int iAttempt = 0;
    BOOL bRet;
    while (!(bRet = IsDirectoryDeletable(pszDir)) && (iAttempt < MAX_DELETE_ATTEMPTS))
    {
        DWORD dwError = GetLastError();

        if ((dwError == ERROR_ACCESS_DENIED) || (dwError == ERROR_SHARING_VIOLATION))
        {
            iAttempt++;
            Sleep(SLEEP_DELETE_ATTEMPT);
        }
        else
        {
            break;
        }
    }

    return (bRet);
}

// This function adds up the sizes of the files in pszDir, and
// also makes sure that all those files are "delete-able"
//
// return:  ERROR_SUCCESS - everything is fine, all the files in the dir are deleteable
//          else          - the dir cant be deleted because something inside is non-deletable
//
// NOTE: other in-out params are in the pfdi
//
LONG CheckFolderSizeAndDeleteability(LPCTSTR pszDir, FOLDERDELETEINFO* pfdi, LPCOPY_STATE pcs)
{
    LONG lRet = ERROR_SUCCESS;  // keep stack to a minimum as this is a recursive function!
    BOOL bHasChildren = FALSE;

    if (FOQueryAbort(pcs))
        return ERROR_CANCELLED;

    if (NULL == pszDir)
        return E_INVALIDARG;

    // do the root specific processing
    if (!pfdi->bProcessedRoot)
    {
        // since the the destination folder could be something like "DC100000.oldext", calculate how many characters are
        // going to be in the new destination directory: "C:\recycler\sid" + "\" + "DC100000.oldext" == the new root directory length
        pfdi->cchDelta = (pfdi->cchBBDir + 1 + 8 + 1 + lstrlen(PathFindExtension(pszDir))) - lstrlen(pszDir);

        // set this so that we only do the above processing for the root folder
        pfdi->bProcessedRoot = TRUE;
    }

    if (PathCombine(pfdi->szPath, pszDir, c_szStarDotStar))
    {
        HANDLE hfind = FindFirstFile(pfdi->szPath, &pfdi->fd);

        // remove the *.* we added, because we will be recycling this buffer
        PathRemoveFileSpec(pfdi->szPath);

        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!PathIsDotOrDotDot(pfdi->fd.cFileName))
                {
                    bHasChildren = TRUE;

                    // append the subfile/subfolder to the parent path
                    if (!PathAppend(pfdi->szPath, pfdi->fd.cFileName))
                    {
                        // PathAppend failed, try to append the short name
                        if (!pfdi->fd.cAlternateFileName[0] || !PathAppend(pfdi->szPath, pfdi->fd.cAlternateFileName))
                        {
                            // no alternate name or we failed to append that as well, assume we failed because the path is too long
                            lRet = ERROR_FILENAME_EXCED_RANGE;

                            // pass back the name of the non-deleteable file/folder in pfdi->szNonDeletableFile
                            lstrcpyn(pfdi->szNonDeletableFile, pfdi->szPath, ARRAYSIZE(pfdi->szNonDeletableFile));
                        }
                    }

                    if (lRet == ERROR_SUCCESS)
                    {
                        // we have to check to see if the path will exceed MAX_PATH if we were to move this file to the recycle
                        // bin (C:\Recycler\<sid>). the increase in path length due to the recycle bin dir could be enough to 
                        // put us over MAX_PATH and we would have problems later.
                        if ((lstrlen(pfdi->szPath) + pfdi->cchDelta + 1) > MAX_PATH) // +1 for NULL
                        {
                            TraceMsg(TF_BITBUCKET, "CheckFolderSizeAndDeleteability: path '%s' would exceed MAX_PATH if moved to the recycle bin!", pfdi->szPath);
                            lRet = ERROR_FILENAME_EXCED_RANGE;

                            // pass back the name of the non-deleteable file/folder in pfdi->szNonDeletableFile
                            lstrcpyn(pfdi->szNonDeletableFile, pfdi->szPath, ARRAYSIZE(pfdi->szNonDeletableFile));
                        }
                        else
                        {
                            if (pfdi->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                // its a directory, so recurse
                                lRet = CheckFolderSizeAndDeleteability(pfdi->szPath, pfdi, pcs);
                            }
                            else 
                            {
                                // its a file.
                                ULARGE_INTEGER ulTemp;

                                if (!_IsFileDeletable(pfdi->szPath))
                                {
                                    // we cant delete this file, find out why
                                    lRet = GetLastError();
                                    ASSERT(lRet != ERROR_SUCCESS);

                                    // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                                    lstrcpyn(pfdi->szNonDeletableFile, pfdi->szPath, ARRAYSIZE(pfdi->szNonDeletableFile));
                                }

                                ulTemp.LowPart  = pfdi->fd.nFileSizeLow;
                                ulTemp.HighPart = pfdi->fd.nFileSizeHigh;
                                pfdi->cbSize += ulTemp.QuadPart;
                            }
                        }
                    }

                    // remove the file/dir name we appended
                    PathRemoveFileSpec(pfdi->szPath);
                }

            } while ((lRet == ERROR_SUCCESS) && FindNextFile(hfind, &pfdi->fd));

            FindClose(hfind);

            // if this dir has no children, see if we can simply delete it
            if (!bHasChildren && !_IsDirectoryDeletable(pszDir))
            {
                lRet = GetLastError();
                ASSERT(lRet != ERROR_SUCCESS);

                // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                lstrcpyn(pfdi->szNonDeletableFile, pszDir, ARRAYSIZE(pfdi->szNonDeletableFile));
            }
        }
        else
        {
            // if FindFirstFile fails, check to see if the directory itself is deleteable
            if (!_IsDirectoryDeletable(pszDir))
            {
                lRet = GetLastError();
                ASSERT(lRet != ERROR_SUCCESS);

                // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                lstrcpyn(pfdi->szNonDeletableFile, pszDir, ARRAYSIZE(pfdi->szNonDeletableFile));
            }
        }
    }
    else
    {
        // if PathCombine fails, assume its because the path is too long
        lRet = ERROR_FILENAME_EXCED_RANGE;

        // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
        lstrcpyn(pfdi->szNonDeletableFile, pszDir, ARRAYSIZE(pfdi->szNonDeletableFile));
    }

    return lRet;
}

// This takes over for what BBDeleteFile used to do (init, check, delete)... but does it with the ability to cancel
BOOL DeleteFileBB(LPTSTR pszFile, INT *piRet, COPY_STATE *pcs, BOOL fIsDir, WIN32_FIND_DATA *pfd, HDPA *phdpaDeletedFiles)
{
    ULARGE_INTEGER ulSize;
    int idDrive = DriveIDFromBBPath(pszFile);

    // Init
    if (!BBDeleteFileInit(pszFile, piRet))
        return FALSE;

    // Check if we can delete this properly
    if (fIsDir) 
    {
        DWORD dwError;
        FOLDERDELETEINFO fdi = {0};

        fdi.cchBBDir = BBRecyclePathLength(idDrive);

        dwError = CheckFolderSizeAndDeleteability(pszFile, &fdi, pcs);

        if (dwError != ERROR_SUCCESS) 
        {
            // if CheckFolderSizeAndDeleteability can fail if a file cant be recycled.
            // In this case, it appends the name of the file to pszFile, so we know who 
            // the undeletable file is. 
            if ((dwError == ERROR_FILENAME_EXCED_RANGE) ||
                    (dwError == ERROR_BUFFER_OVERFLOW))
            {
                // it failed because a new path would be to long after being moveed under the "C:\recycler\sid" directory
                *piRet = BBDELETE_PATH_TOO_LONG;
            }
            else if (dwError == ERROR_CANCELLED)
            {
                // user hit the cancel button
                *piRet = BBDELETE_CANCELLED;
            }
            else
            {
                // must be a non-deletable directory, so set piRet = BBDELETE_CANNOT_DELETE so our caller
                // can detect this case, also pass the name of the non-deletable file back out so we can give
                // a better error message to the user
                *piRet = BBDELETE_CANNOT_DELETE;
                ASSERT(*fdi.szPath);
                lstrcpy(pszFile, fdi.szNonDeletableFile);
            }

            TraceMsg(TF_BITBUCKET, "DeleteFileBB : early error (%x) on file (%s)", dwError, pszFile);
            return FALSE;
        }

        ulSize.QuadPart = fdi.cbSize;
    }
    else 
    {
        if (!_IsFileDeletable(pszFile))
        {
            // We set piRet = BBDELETE_CANNOT_DELETE so our caller can detect
            // that this file cant be recycled.
            *piRet = BBDELETE_CANNOT_DELETE;
            return FALSE;
        }

        ulSize.LowPart  = pfd->nFileSizeLow;
        ulSize.HighPart = pfd->nFileSizeHigh;
    }

    // check to make sure it's not bigger than the allowed wastebasket..
    if (!BBCheckDeleteFileSize(idDrive, ulSize)) 
    {
        // we set piRet = BBDELETE_SIZE_TOO_BIG so our caller can 
        // detect the "file/folder too big" case
        *piRet = BBDELETE_SIZE_TOO_BIG;

        return FALSE;
    }

    return BBDeleteFile(pszFile, piRet, pcs->lpua, fIsDir, phdpaDeletedFiles, ulSize);
}

void StartCopyEngine(HANDLE *phEventRunning)
{
    *phEventRunning = CreateEvent(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), TRUE, FALSE, L"ShellCopyEngineRunning");
    if (*phEventRunning)
    {
        SetEvent(*phEventRunning);
    }
}

void EndCopyEngine(HANDLE hEventRunning)
{
    // signal that we're done.  this will always trigger so there will be some weirdness if the
    // user does simultaneous copies, but it's not worth making a semaphore to keep track.
    HANDLE hEventFinished = CreateEvent(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), TRUE, FALSE, L"ShellCopyEngineFinished");
    if (hEventFinished)
    {
        SetEvent(hEventFinished);
        CloseHandle(hEventFinished);
    }

    if (hEventRunning)
    {
        // close out the event that says we're running.
        ResetEvent(hEventRunning);
        CloseHandle(hEventRunning);
    }
}

BOOL IsCopyEngineRunning()
{
    BOOL bRet=FALSE;
    HANDLE hEventCopyRunning = OpenEvent(SYNCHRONIZE, FALSE, L"ShellCopyEngineRunning");
    if (hEventCopyRunning)
    {
        // probe the event with a wait, if it times out the copy engine isn't running so we're done.
        bRet = (WAIT_OBJECT_0 == WaitForSingleObject(hEventCopyRunning, 0));
        CloseHandle(hEventCopyRunning);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpguids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpguids.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <initguid.h>
#include "cpguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpduihlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpduihlp.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"
#include <uxtheme.h>
#include "cpviewp.h"
#include "cpduihlp.h"
#include "cputil.h"


HRESULT 
CPL::Dui_AddAtom(
    LPCWSTR pszName, 
    ATOM *pAtom
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pAtom);
    ASSERT(!IsBadWritePtr(pAtom, sizeof(*pAtom)));

    HRESULT hr = S_OK;
    *pAtom = AddAtomW(pszName);
    if (0 == *pAtom)
    {
        hr = CPL::ResultFromLastError();
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_DeleteAtom(
    ATOM atom
    )
{
    HRESULT hr = S_OK;
    if (0 != atom)
    {
        if (0 != DeleteAtom(atom))
        {
            hr = CPL::ResultFromLastError();
        }
    }
    return THR(hr);
}



HRESULT
CPL::Dui_AddOrDeleteAtoms(
    struct CPL::ATOMINFO *pAtomInfo,
    UINT cEntries,
    bool bAdd
    )
{
    ASSERT(NULL != pAtomInfo);
    HRESULT hr = S_OK;
    for (UINT i = 0; i < cEntries && SUCCEEDED(hr); i++)
    {
        if (bAdd)
        {
            ASSERT(0 == *(pAtomInfo->pAtom));
            hr = Dui_AddAtom(pAtomInfo->pszName, pAtomInfo->pAtom);
        }
        else
        {
            if (0 != *(pAtomInfo->pAtom))
            {
                Dui_DeleteAtom(*(pAtomInfo->pAtom));
            }
        }
        pAtomInfo++;
    }
    return THR(hr);
}



HRESULT
CPL::Dui_FindDescendent(
    DUI::Element *pe,
    LPCWSTR pszDescendent,
    DUI::Element **ppeDescendent
    )
{
    HRESULT hr = E_FAIL;
    DUI::Element *peDescendent = pe->FindDescendent(DUI::StrToID(pszDescendent));
    if (NULL != peDescendent)
    {
        *ppeDescendent = peDescendent;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_DestroyDescendentElement(
    DUI::Element *pe, 
    LPCWSTR pszDescendent
    )
{
    HRESULT hr = E_FAIL;
    DUI::Element *peDescendent = pe->FindDescendent(DUI::StrToID(pszDescendent));
    if (NULL != peDescendent)
    {
        hr = peDescendent->Destroy();
    }
    return THR(hr);
}


HRESULT
CPL::Dui_CreateElement(
    DUI::Parser *pParser,
    LPCWSTR pszTemplate,
    DUI::Element *peSubstitute,
    DUI::Element **ppe
    )
{
    DUI::Element *pe = NULL;
    HRESULT hr = pParser->CreateElement(pszTemplate, peSubstitute, &pe);
    if (SUCCEEDED(hr))
    {
        //
        // ISSUE-2000/12/22-BrianAu  DUI bug.
        //   DUI::Parser::CreateElement will return S_OK if 
        //   the element doesn't exist.  I've notified MarkFi
        //   about the issue.  I think he'll fix it.
        //
        if (NULL == pe)
        {
            ASSERT(0 && "DUI::Parser::CreateElement returned S_OK for non-existent element");
            hr = E_FAIL;
        }
    }
    *ppe = pe;
    return THR(hr);
}



HRESULT 
CPL::Dui_GetStyleSheet(
    DUI::Parser *pParser, 
    LPCWSTR pszSheet,
    DUI::Value **ppvSheet
    )
{
    HRESULT hr = E_FAIL;
    DUI::Value *pvSheet = pParser->GetSheet(pszSheet);
    if (NULL != pvSheet)
    {
        *ppvSheet = pvSheet;
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT 
CPL::Dui_CreateElementWithStyle(
    DUI::Parser *pParser, 
    LPCWSTR pszTemplate, 
    LPCWSTR pszStyleSheet, 
    DUI::Element **ppe
    )
{
    HRESULT hr = CPL::Dui_CreateElement(pParser, pszTemplate, NULL, ppe);
    if (SUCCEEDED(hr))
    {
        CPL::CDuiValuePtr pvStyle;
        hr = CPL::Dui_GetStyleSheet(pParser, pszStyleSheet, &pvStyle);
        if (SUCCEEDED(hr))
        {
            hr = Dui_SetElementProperty(*ppe, SheetProp, pvStyle);
        }
    }
    return THR(hr);
}



HRESULT
CPL::Dui_CreateString(
    LPCWSTR pszText,
    DUI::Value **ppvString
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    HINSTANCE hInstance = NULL;
    if (IS_INTRESOURCE(pszText))
    {
        hInstance = HINST_THISDLL;
    }
    DUI::Value *pvString = DUI::Value::CreateString(pszText, hInstance);
    if (NULL != pvString)
    {
        *ppvString = pvString;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetElementProperty_Int(
    DUI::Element *pe, 
    DUI::PropertyInfo *ppi,
    int i
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CPL::CDuiValuePtr pv = DUI::Value::CreateInt(i);
    if (!pv.IsNULL())
    {
        hr = CPL::Dui_SetValue(pe, ppi, pv);
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetElementProperty_String(
    DUI::Element *pe, 
    DUI::PropertyInfo *ppi,
    LPCWSTR psz
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CPL::CDuiValuePtr pv = DUI::Value::CreateString(psz);
    if (!pv.IsNULL())
    {
        hr = CPL::Dui_SetValue(pe, ppi, pv);
    }
    return THR(hr);
}



HRESULT 
CPL::Dui_SetElementText(
    DUI::Element *peElement,
    LPCWSTR pszText
    )
{
    CPL::CDuiValuePtr  pvString;
    HRESULT hr = CPL::Dui_CreateString(pszText, &pvString);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementProperty(peElement, ContentProp, pvString);
    }
    return THR(hr);
}



HRESULT 
CPL::Dui_SetDescendentElementText(
    DUI::Element *peElement, 
    LPCWSTR pszDescendent,
    LPCWSTR pszText
    )
{
    DUI::Element *peDescendent;
    HRESULT hr = CPL::Dui_FindDescendent(peElement, pszDescendent, &peDescendent);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementText(peDescendent, pszText);
    }
    return THR(hr);
}


//
// Retrieve the width and height of an element.
//
HRESULT
CPL::Dui_GetElementExtent(
    DUI::Element *pe,
    SIZE *pext
    )
{
    HRESULT hr = E_FAIL;
    CPL::CDuiValuePtr pv;
    *pext = *(pe->GetExtent(&pv));
    if (!pv.IsNULL())
    {
        hr = S_OK;
    }
    return THR(hr);
}

HRESULT 
CPL::Dui_CreateGraphic(
    HICON hIcon, 
    DUI::Value **ppValue
    )
{
    HRESULT hr = E_OUTOFMEMORY;

    DUI::Value *pvGraphic;
    pvGraphic = DUI::Value::CreateGraphic(hIcon);
    if (NULL != pvGraphic)
    {
        *ppValue = pvGraphic;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetElementIcon(
    DUI::Element *pe, 
    HICON hIcon
    )
{
    CPL::CDuiValuePtr pvGraphic;
    HRESULT hr = CPL::Dui_CreateGraphic(hIcon, &pvGraphic);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementProperty(pe, ContentProp, pvGraphic);
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetDescendentElementIcon(
    DUI::Element *peElement, 
    LPCWSTR pszDescendent, 
    HICON hIcon
    )
{
    DUI::Element *peDescendent;
    HRESULT hr = CPL::Dui_FindDescendent(peElement, pszDescendent, &peDescendent);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementIcon(peDescendent, hIcon);
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_GetElementRootHWND(
    DUI::Element *pe, 
    HWND *phwnd
    )
{
    HRESULT hr = E_FAIL;
    const HWND hwnd = ((DUI::HWNDElement *)pe->GetRoot())->GetHWND();
    if (NULL != hwnd)
    {
        hr = S_OK;
    }
    *phwnd = hwnd;
    return THR(hr);
}


HRESULT
CPL::Dui_MapElementPointToRootHWND(
    DUI::Element *pe,
    const POINT& ptElement,
    POINT *pptRoot,
    HWND *phwndRoot            // Optional.  Default == NULL;
    )
{
    HWND hwndRoot;
    HRESULT hr = CPL::Dui_GetElementRootHWND(pe, &hwndRoot);
    if (SUCCEEDED(hr))
    {
        pe->GetRoot()->MapElementPoint(pe, &ptElement, pptRoot);
        if (NULL != phwndRoot)
        {
            *phwndRoot = hwndRoot;
        }
        hr = S_OK;
    }
    return THR(hr);
}


void CALLBACK
Dui_ParserErrorCallback(
    LPCWSTR pszError,
    LPCWSTR pszToken,
    int iLine
    )
{
    WCHAR szBuffer[1024];
    if (-1 != iLine)
    {
        wsprintfW(szBuffer, L"%s '%s' at line %d.", pszError, pszToken, iLine);
    }
    else
    {
        wsprintfW(szBuffer, L"%s '%s'", pszError, pszToken);
    }
    MessageBoxW(NULL, szBuffer, L"DUI Parser Message", MB_OK | MB_ICONERROR);
}



HRESULT
CPL::Dui_CreateParser(
    const char *pszUiFile,
    int cchUiFile,
    HINSTANCE hInstance,
    DUI::Parser **ppParser
    )
{
    ASSERT(NULL != pszUiFile);
    ASSERT(!IsBadStringPtrA(pszUiFile, cchUiFile));
    ASSERT(NULL != ppParser);
    ASSERT(!IsBadWritePtr(ppParser, sizeof(*ppParser)));

    HRESULT hr = E_FAIL;
    DUI::Parser *pParser;
    HANDLE arHandles[2];

    arHandles[0] = hInstance;
    arHandles[1] = OpenThemeData(NULL, L"Scrollbar");

    DUI::Parser::Create(pszUiFile, cchUiFile, arHandles, Dui_ParserErrorCallback, &pParser);

    if (NULL != pParser)
    {
        if (!pParser->WasParseError())
        {
            hr = S_OK;
        }
        else
        {
            pParser->Destroy();
            pParser = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (arHandles[1])
    {
        CloseThemeData (arHandles[1]);
    }

    *ppParser = pParser;
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CDuiValuePtr
//-----------------------------------------------------------------------------

CPL::CDuiValuePtr& 
CPL::CDuiValuePtr::operator = (
    const CDuiValuePtr& rhs
    )
{
    if (this != &rhs)
    {
        Attach(rhs.Detach());
    }
    return *this;
}


void 
CPL::CDuiValuePtr::Attach(
    DUI::Value *pv
    )
{
    _Release();
    m_pv    = pv;
    m_bOwns = true;
}


DUI::Value *
CPL::CDuiValuePtr::Detach(
    void
    ) const
{ 
    DUI::Value *pv = m_pv;
    m_pv    = NULL;
    m_bOwns = false; 
    return pv; 
}


void
CPL::CDuiValuePtr::_ReleaseAndReset(
    void
    )
{
    _Release();
    m_pv    = NULL;
    m_bOwns = false;
}


void 
CPL::CDuiValuePtr::_Release(
    void
    )
{
    if (NULL != m_pv && m_bOwns) 
    {
        m_pv->Release(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpduihlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpduihlp.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_DUIHELPERS_H
#define __CONTROLPANEL_DUIHELPERS_H

#include "cpviewp.h"

namespace CPL {


HRESULT Dui_FindDescendent(DUI::Element *pe, LPCWSTR pszDescendent, DUI::Element **ppeDescendent);
HRESULT Dui_GetStyleSheet(DUI::Parser *pParser, LPCWSTR pszSheet, DUI::Value **ppvSheet);
HRESULT Dui_SetElementText(DUI::Element *peElement, LPCWSTR pszText);
HRESULT Dui_SetDescendentElementText(DUI::Element *peElement, LPCWSTR pszDescendent, LPCWSTR pszText);
HRESULT Dui_SetDescendentElementIcon(DUI::Element *peElement, LPCWSTR pszDescendent, HICON hIcon);
HRESULT Dui_CreateElement(DUI::Parser *pParser, LPCWSTR pszTemplate, DUI::Element *peSubstitute, DUI::Element **ppe);
HRESULT Dui_CreateElementWithStyle(DUI::Parser *pParser, LPCWSTR pszTemplate, LPCWSTR pszStyleSheet, DUI::Element **ppe);
HRESULT Dui_DestroyDescendentElement(DUI::Element *pe, LPCWSTR pszDescendent);
HRESULT Dui_CreateString(LPCWSTR pszText, DUI::Value **ppvString);
HRESULT Dui_CreateGraphic(HICON hIcon, DUI::Value **ppValue);
HRESULT Dui_GetElementExtent(DUI::Element *pe, SIZE *pext);
HRESULT Dui_GetElementRootHWND(DUI::Element *pe, HWND *phwnd);
HRESULT Dui_SetElementIcon(DUI::Element *pe, HICON hIcon);
HRESULT Dui_MapElementPointToRootHWND(DUI::Element *pe, const POINT& ptElement, POINT *pptRoot, HWND *phwndRoot = NULL);
HRESULT Dui_SetElementProperty_Int(DUI::Element *pe, DUI::PropertyInfo *ppi, int i);
HRESULT Dui_SetElementProperty_String(DUI::Element *pe, DUI::PropertyInfo *ppi, LPCWSTR psz);
HRESULT Dui_CreateParser(const char *pszUiFile, int cchUiFile, HINSTANCE hInstance, DUI::Parser **ppParser);


inline HRESULT
Dui_SetValue(
    DUI::Element *pe,
    DUI::PropertyInfo *ppi,
    DUI::Value *pv
    )
{
    return pe->SetValue(ppi, PI_Local, pv);
}

#define Dui_SetElementProperty(pe, prop, pv) Dui_SetValue((pe), DUI::Element::##prop, (pv))
#define Dui_SetElementPropertyInt(pe, prop, i) Dui_SetElementProperty_Int((pe), DUI::Element::##prop, (i))
#define Dui_SetElementPropertyString(pe, prop, s) Dui_SetElementProperty_String((pe), DUI::Element::##prop, (s))

inline HRESULT 
Dui_SetElementStyleSheet(
    DUI::Element *pe, 
    DUI::Value *pvSheet
    )
{
    return Dui_SetElementProperty(pe, SheetProp, pvSheet);
}


struct ATOMINFO
{
    LPCWSTR pszName;
    ATOM *pAtom;
};


HRESULT Dui_AddAtom(LPCWSTR pszName, ATOM *pAtom);
HRESULT Dui_DeleteAtom(ATOM atom);
HRESULT Dui_AddOrDeleteAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries, bool bAdd);
inline HRESULT Dui_AddAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries)
{
    return Dui_AddOrDeleteAtoms(pAtomInfo, cEntries, true);
}
inline HRESULT Dui_DeleteAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries)
{
    return Dui_AddOrDeleteAtoms(pAtomInfo, cEntries, true);
}



//
// This is a simple smart-pointer class for DUI::Value pointers.
// It's important that the referenced DUI::Value object be released when the
// pointer is no longer needed.  Use of this class ensures proper cleanup
// when the object goes out of scope.
//
class CDuiValuePtr
{
    public:
        CDuiValuePtr(DUI::Value *pv = NULL)
            : m_pv(pv),
              m_bOwns(true) { }

        CDuiValuePtr(const CDuiValuePtr& rhs)
            : m_bOwns(false),
              m_pv(NULL) { Attach(rhs.Detach()); }

        CDuiValuePtr& operator = (const CDuiValuePtr& rhs);

        ~CDuiValuePtr(void)
            { _Release(); }

        DUI::Value *Detach(void) const;

        void Attach(DUI::Value *pv);

        DUI::Value **operator & ()
            { ASSERTMSG(NULL == m_pv, "Attempt to overwrite non-NULL pointer value"); 
               m_bOwns = true; 
               return &m_pv; 
            }

        operator !() const
            { return NULL == m_pv; }

        bool IsNULL(void) const
            { return NULL == m_pv; }

        operator const DUI::Value*() const
            { return m_pv; }

        operator DUI::Value*()
            { return m_pv; }

    private:
        mutable DUI::Value *m_pv;
        mutable bool       m_bOwns;

        void _Release(void);
        void _ReleaseAndReset(void);
};


} // namespace CPL


#endif // __CONTROLPANEL_DUIHELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpguids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpguids.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_GUIDS_H
#define __CONTROLPANEL_GUIDS_H

namespace CPL {


// {3BE962E5-C533-4602-9E7D-B785EDA0B9D4}
DEFINE_GUID(IID_ICpUiCommand, 
0x3be962e5, 0xc533, 0x4602, 0x9e, 0x7d, 0xb7, 0x85, 0xed, 0xa0, 0xb9, 0xd4);

// {E75C5E43-D6D1-4336-8504-0E8E55A2ACCD}
DEFINE_GUID(IID_ICpUiElementInfo, 
0xe75c5e43, 0xd6d1, 0x4336, 0x85, 0x4, 0xe, 0x8e, 0x55, 0xa2, 0xac, 0xcd);

// {B46CBBCD-3F6B-433c-9422-BF9BEE5125C1}
DEFINE_GUID(IID_ICplWebViewInfo, 
0xb46cbbcd, 0x3f6b, 0x433c, 0x94, 0x22, 0xbf, 0x9b, 0xee, 0x51, 0x25, 0xc1);

// {A4AFCDE8-175A-4735-A7AE-2310C3AF247B}
DEFINE_GUID(IID_IEnumCplWebViewInfo, 
0xa4afcde8, 0x175a, 0x4735, 0xa7, 0xae, 0x23, 0x10, 0xc3, 0xaf, 0x24, 0x7b);

// {EE031859-D046-4103-9C02-94CBA01F76F1}
DEFINE_GUID(IID_ICplView, 
0xee031859, 0xd046, 0x4103, 0x9c, 0x2, 0x94, 0xcb, 0xa0, 0x1f, 0x76, 0xf1);

// {029CF875-6FE7-4d1c-AF72-2CCE925B5AB6}
DEFINE_GUID(IID_ICplCategory, 
0x29cf875, 0x6fe7, 0x4d1c, 0xaf, 0x72, 0x2c, 0xce, 0x92, 0x5b, 0x5a, 0xb6);

// {A9D37997-77AD-4b32-A6BF-CF8306A94060}
DEFINE_GUID(IID_ICplNamespace, 
0xa9d37997, 0x77ad, 0x4b32, 0xa6, 0xbf, 0xcf, 0x83, 0x6, 0xa9, 0x40, 0x60);

// {5581A2AD-6F46-42d6-92CC-6A35786D7E92}
DEFINE_GUID(SID_SControlPanelView, 
0x5581a2ad, 0x6f46, 0x42d6, 0x92, 0xcc, 0x6a, 0x35, 0x78, 0x6d, 0x7e, 0x92);



} // namespace CPL


#endif //__CONTROLPANEL_GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpaction.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpaction.cpp
//
//  This module implements the various 'action' objects used by the 
//  Control Panel's 'category' view.  Each 'link' in the UI has an 
//  associated 'action'.  The action objects are defined in cpnamespc.cpp.
//  All 'action' objects are designed so that object construction is 
//  very cheap and that minimal processing is performed until the action
//  is invoked.  
//  
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <idhidden.h> 

#include "cpviewp.h"
#include "cpaction.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cputil.h"


//// from shell\sdspatch\sdfolder.cpp
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);


//
// Disable warning.  ShellExecute uses SEH.
//  "nonstandard extension used: 'Execute' uses SEH and 'se' has destructor".
//
#pragma warning( push )
#pragma warning( disable:4509 )


using namespace CPL;


HRESULT 
CRestrictApplet::IsRestricted(
    ICplNamespace *pns
    ) const
{
    UNREFERENCED_PARAMETER(pns);
    
    DBG_ENTER(FTF_CPANEL, "RestrictApplet");

    HRESULT hr = S_FALSE;
    if (!IsAppletEnabled(m_pszFile, m_pszApplet))
    {
        hr = S_OK;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "RestrictApplet", hr);
    return hr;
}



//--------------------------------------------------------------------------
// CAction implementation
//--------------------------------------------------------------------------

CAction::CAction(
    const CPL::IRestrict *pRestrict  // optional.  default = NULL
    ) : m_pRestrict(pRestrict)
{


}


//
// Returns:
//     S_FALSE    - Not restricted.
//     S_OK       - Restricted.
//     Failure    - Cannot determine.
//
HRESULT
CAction::IsRestricted(
    ICplNamespace *pns
    ) const
{
    HRESULT hr = S_FALSE;  // Assume not restricted.

    if (NULL != m_pRestrict)
    {
        hr = m_pRestrict->IsRestricted(pns);
    }
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenUserMgrApplet implementation
//--------------------------------------------------------------------------

COpenUserMgrApplet::COpenUserMgrApplet(
    const CPL::IRestrict *pRestrict  // optional.  default = NULL
    ): CAction(pRestrict)
{

}


HRESULT
COpenUserMgrApplet::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenUserMgrApplet::Execute");

    HRESULT hr = E_FAIL;
    if (IsOsServer())
    {
        CShellExecute action(L"lusrmgr.msc");
        hr = action.Execute(hwndParent, punkSite);
    }
    else
    {
        COpenCplApplet action(L"nusrmgr.cpl");
        hr = action.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenUserMgrApplet::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplApplet implementation
//--------------------------------------------------------------------------

COpenCplApplet::COpenCplApplet(
    LPCWSTR pszApplet,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszApplet(pszApplet)
{
    ASSERT(NULL != pszApplet);
}


HRESULT
COpenCplApplet::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplApplet::Execute");

    ASSERT(NULL != m_pszApplet);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    WCHAR szArgs[MAX_PATH];
    wsprintfW(szArgs, L"shell32.dll,Control_RunDLL %s", m_pszApplet);

    TraceMsg(TF_CPANEL, "Executing: \"rundll32.exe %s\"", szArgs);

    SHELLEXECUTEINFOW sei = {
        sizeof(sei),           // cbSize;
        SEE_MASK_DOENVSUBST,   // fMask
        hwndParent,            // hwnd
        NULL,                  // lpVerb
        L"rundll32.exe",       // lpFile
        szArgs,                // lpParameters
        NULL,                  // lpDirectory
        SW_SHOWNORMAL,         // nShow
        0,                     // hInstApp
        NULL,                  // lpIDList
        NULL,                  // lpClass
        NULL,                  // hkeyClass
        0,                     // dwHotKey
        NULL,                  // hIcon
        NULL                   // hProcess
    };

    HRESULT hr = S_OK;
    if (!ShellExecuteExW(&sei))
    {
        hr = CPL::ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplApplet::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenDeskCpl implementation
//--------------------------------------------------------------------------

COpenDeskCpl::COpenDeskCpl(
    eDESKCPLTAB eCplTab,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCplTab(eCplTab)
{

}


HRESULT
COpenDeskCpl::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenDeskCpl::Execute");
    TraceMsg(TF_CPANEL, "Desk CPL tab ID = %d", m_eCplTab);

    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_FAIL;
    WCHAR szTab[MAX_PATH];

    const int iTab = CPL::DeskCPL_GetTabIndex(m_eCplTab, szTab, ARRAYSIZE(szTab));
    if (CPLTAB_ABSENT != iTab)
    {
        WCHAR szArgs[MAX_PATH];

        wnsprintfW(szArgs, ARRAYSIZE(szArgs), L"desk.cpl ,@%ls", szTab);
        COpenCplApplet oca(szArgs);
        hr = oca.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenDeskCpl::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CNavigateURL implementation
//--------------------------------------------------------------------------

CNavigateURL::CNavigateURL(
    LPCWSTR pszURL,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszURL(pszURL)
{
    ASSERT(NULL != pszURL);
}


HRESULT
CNavigateURL::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CNavigateURL::Execute");

    ASSERT(NULL != m_pszURL);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(hwndParent);

    TraceMsg(TF_CPANEL, "URL = \"%s\"", m_pszURL);

    IWebBrowser2 *pwb;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SWebBrowserApp, IID_IWebBrowser2, (void **)&pwb);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszExpanded;
        hr = CPL::ExpandEnvironmentVars(m_pszURL, &pszExpanded);
        if (SUCCEEDED(hr))
        {
            VARIANT varURL;
            hr = InitVariantFromStr(&varURL, pszExpanded);
            if (SUCCEEDED(hr))
            {
                VARIANT varEmpty;
                VariantInit(&varEmpty);
                
                VARIANT varFlags;
                varFlags.vt      = VT_UINT;
                varFlags.uintVal = 0;
                
                hr = pwb->Navigate2(&varURL, &varFlags, &varEmpty, &varEmpty, &varEmpty);
                VariantClear(&varURL);
            }
            LocalFree(pszExpanded);
        }
        pwb->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CNavigateURL::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenTroubleshooter implementation
//--------------------------------------------------------------------------

COpenTroubleshooter::COpenTroubleshooter(
    LPCWSTR pszTs,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszTs(pszTs)
{
    ASSERT(NULL != pszTs);
}


HRESULT
COpenTroubleshooter::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenTroubleshooter::Execute");

    ASSERT(NULL != m_pszTs);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    WCHAR szPath[MAX_PATH];
    wnsprintfW(szPath, ARRAYSIZE(szPath), L"hcp://help/tshoot/%s", m_pszTs);

    CNavigateURL actionURL(szPath);

    HRESULT hr = actionURL.Execute(hwndParent, punkSite);

    DBG_EXIT_HRES(FTF_CPANEL, "COpenTroubleshooter::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CShellExecute implementation
//--------------------------------------------------------------------------

CShellExecute::CShellExecute(
    LPCWSTR pszExe,
    LPCWSTR pszArgs,                // optional.  default = NULL.
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszExe(pszExe),
        m_pszArgs(pszArgs)
{
    ASSERT(NULL != pszExe);
}


HRESULT
CShellExecute::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CShellExecute::Execute");

    ASSERT(NULL != m_pszExe);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    TraceMsg(TF_CPANEL, "ShellExecute: \"%s %s\"", m_pszExe, m_pszArgs ? m_pszArgs : L"<no args>");

    SHELLEXECUTEINFOW sei = {
        sizeof(sei),           // cbSize;
        SEE_MASK_DOENVSUBST,   // fMask
        hwndParent,            // hwnd
        L"open",               // lpVerb
        m_pszExe,              // lpFile
        m_pszArgs,             // lpParameters
        NULL,                  // lpDirectory
        SW_SHOWNORMAL,         // nShow
        0,                     // hInstApp
        NULL,                  // lpIDList
        NULL,                  // lpClass
        NULL,                  // hkeyClass
        0,                     // dwHotKey
        NULL,                  // hIcon
        NULL                   // hProcess
    };

    HRESULT hr = S_OK;
    if (!ShellExecuteExW(&sei))
    {
        hr = CPL::ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CShellExecute::Execute", hr);
    return THR(hr);
}


//--------------------------------------------------------------------------
// CRundll32 implementation
// This is a simple wrapper around CShellExecute that saves an instance
// definition from having to type L"%SystemRoot%\\system32\\rundll32.exe".
//--------------------------------------------------------------------------

CRunDll32::CRunDll32(
    LPCWSTR pszArgs,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszArgs(pszArgs)
{
    ASSERT(NULL != pszArgs);
}


HRESULT
CRunDll32::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CRunDll32::Execute");

    ASSERT(NULL != m_pszArgs);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    TraceMsg(TF_CPANEL, "CRunDll32: \"%s\"", m_pszArgs);

    CShellExecute se(L"%SystemRoot%\\system32\\rundll32.exe", m_pszArgs);
    HRESULT hr = se.Execute(hwndParent, punkSite);

    DBG_EXIT_HRES(FTF_CPANEL, "CRunDll32::Execute", hr);
    return THR(hr);
}



    
//--------------------------------------------------------------------------
// CExecDiskUtil implementation
//--------------------------------------------------------------------------

CExecDiskUtil::CExecDiskUtil(
    eDISKUTILS eUtil,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eUtil(eUtil)
{
    ASSERT(eDISKUTIL_NUMUTILS > m_eUtil);
}


HRESULT
CExecDiskUtil::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CExecDiskUtil::Execute");
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbValue = sizeof(szValue);

    //
    // These strings must remain in sync with the eDISKUTILS enumeration.
    //
    static LPCTSTR rgpszRegNames[] = {
        TEXT("MyComputer\\backuppath"),  // eDISKUTIL_BACKUP
        TEXT("MyComputer\\defragpath"),  // eDISKUTIL_DEFRAG
        TEXT("MyComputer\\cleanuppath"), // eDISKUTIL_CLEANUP
    };

    HRESULT hr = SKGetValue(SHELLKEY_HKLM_EXPLORER, 
                            rgpszRegNames[int(m_eUtil)], 
                            NULL, 
                            &dwType, 
                            szValue, 
                            &cbValue);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszExpanded = NULL;
        //
        // Expand environment strings.
        // According to the code in shell32\drvx.cpp, some apps
        // use embedded env vars even if the value type is REG_SZ.
        //
        hr = CPL::ExpandEnvironmentVars(szValue, &pszExpanded);
        if (SUCCEEDED(hr))
        {
            //
            // The drive utility command strings were designed to be
            // invoked from the drives property page.  They therefore
            // accept a drive letter.  Since control panel launches
            // the utilities for no particular drive, we need to remove
            // the "%c:" format specifier.
            //
            hr = _RemoveDriveLetterFmtSpec(pszExpanded);
            if (SUCCEEDED(hr))
            {
                TCHAR szArgs[MAX_PATH] = {0};
                PathRemoveBlanks(pszExpanded);
                PathSeperateArgs(pszExpanded, szArgs);
                //
                // Note that it's valid to use a NULL restriction here.
                // If there's a restriction on the CExecDiskUtil object
                // we won't get this far (i.e. Execute isn't called).
                //
                CShellExecute exec(pszExpanded, szArgs);
                hr = exec.Execute(hwndParent, punkSite);
            }
            LocalFree(pszExpanded);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CExecDiskUtil::Execute", hr);
    return THR(hr);
}


//
// The command line strings for the backup, defrag and disk cleanup utilities 
// can contain a format specifier for the drive letter.  That's because
// they're designed to be opened from a particular volume's "Tools" property
// page.  Control Panel launches these from outside the context of any particular
// volume.  Therefore, the drive letter is not available and the the format
// specifier is unused.  This function removes that format specifier if it exists.
//
// i.e.:  "c:\windows\system32\ntbackup.exe"        -> "c:\windows\system32\ntbackpu.exe"
//        "c:\windows\system32\cleanmgr.exe /D %c:" -> "c:\windows\system32\cleanmgr.exe"
//        "c:\windows\system32\defrg.msc %c:"       -> "c:\windows\system32\defrg.msc"
//
HRESULT
CExecDiskUtil::_RemoveDriveLetterFmtSpec(  // [static]
    LPTSTR pszCmdLine
    )
{
    LPCTSTR pszRead = pszCmdLine;
    LPTSTR pszWrite = pszCmdLine;

    while(*pszRead)
    {
        if (TEXT('%') == *pszRead && TEXT('c') == *(pszRead + 1))
        {
            //
            // Skip over the "%c" or "%c:" fmt specifier.
            //
            pszRead += 2;
            if (TEXT(':') == *pszRead)
            {
                pszRead++;
            }
        }
        if (*pszRead)
        {
            *pszWrite++ = *pszRead++;
        }
    }
    *pszWrite = *pszRead; // pick up null terminator.
    return S_OK;
}



//--------------------------------------------------------------------------
// COpenCplCategory implementation
//--------------------------------------------------------------------------

COpenCplCategory::COpenCplCategory(
    eCPCAT eCategory,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCategory(eCategory)
{

}



HRESULT
COpenCplCategory::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory::Execute");
    TraceMsg(TF_CPANEL, "Category ID = %d", m_eCategory);

    ASSERT(NULL != punkSite);

    UNREFERENCED_PARAMETER(hwndParent);

    IShellBrowser *psb;
    HRESULT hr = CPL::ShellBrowserFromSite(punkSite, &psb);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFolder;
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
        if (SUCCEEDED(hr))
        {
            WCHAR szCategory[10];
            wsprintfW(szCategory, L"%d", m_eCategory);

            LPITEMIDLIST pidlTemp = ILAppendHiddenStringW(pidlFolder, IDLHID_NAVIGATEMARKER, szCategory);
            if (NULL == pidlTemp)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pidlFolder = pidlTemp;
                pidlTemp   = NULL;

                hr = CPL::BrowseIDListInPlace(pidlFolder, psb);
            }
            ILFree(pidlFolder);
        }
        psb->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplCategory2 implementation
//--------------------------------------------------------------------------

COpenCplCategory2::COpenCplCategory2(
    eCPCAT eCategory,
    const IAction *pDefAction,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCategory(eCategory),
        m_pDefAction(pDefAction)
{

}



HRESULT
COpenCplCategory2::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory2::Execute");
    TraceMsg(TF_CPANEL, "Category ID = %d", m_eCategory);

    ASSERT(NULL != punkSite);

    bool bOpenCategory = false;
    HRESULT hr = _ExecuteActionOnSingleCplApplet(hwndParent, punkSite, &bOpenCategory);
    if (SUCCEEDED(hr))
    {
        if (bOpenCategory)
        {
            //
            // Category has more than one CPL.
            // Open the category page.
            //
            COpenCplCategory action(m_eCategory);
            hr = action.Execute(hwndParent, punkSite);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory2::Execute", hr);
    return THR(hr);
}



HRESULT
COpenCplCategory2::_ExecuteActionOnSingleCplApplet(
    HWND hwndParent,
    IUnknown *punkSite,
    bool *pbOpenCategory    // optional.  Can be NULL
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory2::_ExecuteActionOnSingleCplApplet");

    bool bOpenCategory = true;
    ICplView *pview;
    HRESULT hr = CPL::ControlPanelViewFromSite(punkSite, &pview);
    if (SUCCEEDED(hr))
    {   
        IServiceProvider *psp;
        hr = pview->QueryInterface(IID_IServiceProvider, (void **)&psp);
        if (SUCCEEDED(hr))
        {
            ICplNamespace *pns;
            hr = psp->QueryService(SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
            if (SUCCEEDED(hr))
            {
                ICplCategory *pCategory;
                hr = pns->GetCategory(m_eCategory, &pCategory);
                if (SUCCEEDED(hr))
                {
                    IEnumUICommand *penum;
                    hr = pCategory->EnumCplApplets(&penum);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // See if the category has more than one CPL applet
                        // assigned to it.  
                        //
                        ULONG cApplets = 0;
                        IUICommand *rgpuic[2] = {0};
                        if (SUCCEEDED(hr = penum->Next(ARRAYSIZE(rgpuic), rgpuic, &cApplets)))
                        {
                            for (int i = 0; i < ARRAYSIZE(rgpuic); i++)
                            {
                                ATOMICRELEASE(rgpuic[i]);
                            }
                            if (2 > cApplets)
                            {
                                //
                                // There's zero or one CPLs registered for this category.
                                // Simply execute the default action.  If there's one
                                // we assume it's the "default" applet (i.e. ARP or
                                // User Accounts).
                                //
                                hr =  m_pDefAction->IsRestricted(pns);
                                if (SUCCEEDED(hr))
                                {
                                    if (S_FALSE == hr)
                                    {
                                        bOpenCategory = false;
                                        hr = m_pDefAction->Execute(hwndParent, punkSite);
                                    }
                                    else
                                    {
                                        //
                                        // Default action is restricted.  
                                        // Open the category page.  Note that the
                                        // category page may be displayed as a 'barrier'
                                        // if no tasks or CPL applets are available.
                                        //
                                        ASSERT(bOpenCategory);
                                    }
                                }
                            }
                        }
                        penum->Release();
                    }
                    pCategory->Release();
                }
                pns->Release();
            }
            psp->Release();
        }
        pview->Release();
    }
    if (NULL != pbOpenCategory)
    {
        *pbOpenCategory = bOpenCategory;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory2::_ExecuteActionOnSingleCplApplet", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplView implementation
//--------------------------------------------------------------------------

COpenCplView::COpenCplView(
    eCPVIEWTYPE eViewType,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eViewType(eViewType)
{

}


HRESULT
COpenCplView::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    UNREFERENCED_PARAMETER(hwndParent);

    ASSERT(NULL != punkSite);

    HRESULT hr = _SetFolderBarricadeStatus();
    if (SUCCEEDED(hr))
    {
        IShellBrowser *psb;
        hr = CPL::ShellBrowserFromSite(punkSite, &psb);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder;
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
            if (SUCCEEDED(hr))
            {
                hr = CPL::BrowseIDListInPlace(pidlFolder, psb);
                ILFree(pidlFolder);
            }
            psb->Release();
        }
    }
    return THR(hr);
}


HRESULT
COpenCplView::_SetFolderBarricadeStatus(
    void
    ) const
{
    VARIANT_BOOL vtb = VARIANT_FALSE;
    if (eCPVIEWTYPE_CATEGORY == m_eViewType)
    {
        vtb = VARIANT_TRUE;
    }
    else
    {
        ASSERT(eCPVIEWTYPE_CLASSIC == m_eViewType);
    }

    HRESULT hr = CPL::SetControlPanelBarricadeStatus(vtb);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CAddPrinter implementation
//--------------------------------------------------------------------------

CAddPrinter::CAddPrinter(
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict)
{

}



HRESULT
CAddPrinter::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CAddPrinter::Execute");

    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_FAIL;
    if (SHInvokePrinterCommandW(hwndParent, 
                               PRINTACTION_OPEN, 
                               L"WinUtils_NewObject", 
                               NULL, 
                               FALSE))
    {
        //
        // Navigate to the printers folder after invoking the add-printer wizard.
        // This gives the user visual feedback when a printer is added.  We navigate
        // even if the user cancels the wizard because we cannot determine if the
        // wizard was cancelled.  We've determined this is acceptable.
        //
        CNavigateURL prnfldr(L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}");
        hr = prnfldr.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CAddPrinter::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CTrayCommand implementation
//--------------------------------------------------------------------------

CTrayCommand::CTrayCommand(
    UINT idm,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_idm(idm)
{

}


HRESULT
CTrayCommand::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(punkSite);

    // APPHACK!  221008 DesktopX creates their own window with class
    // name "Shell_TrayWnd", so if we're not careful we will end
    // posting the messages to the wrong window.  They create their
    // window with the title "CTrayServer"; ours has a null title.
    // Use the null title to find the correct window.

    HWND hwndTray = FindWindowA(WNDCLASS_TRAYNOTIFY, "");
    if (hwndTray)
    {
        PostMessage(hwndTray, WM_COMMAND, m_idm, 0);
    }
    return S_OK;
}



//--------------------------------------------------------------------------
// CActionNYI implementation
//--------------------------------------------------------------------------

CActionNYI::CActionNYI(
    LPCWSTR pszText
    ) : m_pszText(pszText)
{

}


HRESULT
CActionNYI::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_OUTOFMEMORY;
    if (NULL != m_pszText)
    {
        MessageBoxW(hwndParent, m_pszText, L"Action Not Yet Implemented", MB_OK);
        hr = S_OK;
    }
    return THR(hr);
}



#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpaction.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpaction.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_ACTION_H
#define __CONTROLPANEL_ACTION_H


#include "cputil.h"
#include "cpnamespc.h"


namespace CPL {


//
// Restriction function must return an HRESULT with the following semantics.
//
//     S_FALSE    - Action not restricted.
//     S_OK       - Action restricted.
//     Failure    - Cannot determine.
//
typedef HRESULT (*PFNRESTRICT)(ICplNamespace *pns);


class IRestrict
{
    public:
        virtual ~IRestrict(void) { }

        virtual HRESULT IsRestricted(ICplNamespace *pns) const = 0;

};


class CRestrictFunc : public IRestrict
{
    public:
        CRestrictFunc(PFNRESTRICT pfnRestrict)
            : m_pfnRestrict(pfnRestrict) { }

        HRESULT IsRestricted(ICplNamespace *pns) const
            { return (*m_pfnRestrict)(pns); }

    private:
        PFNRESTRICT m_pfnRestrict;
};



class CRestrictApplet : public IRestrict
{
    public:
        CRestrictApplet(LPCWSTR pszFile, LPCWSTR pszApplet)
            : m_pszFile(pszFile),
              m_pszApplet(pszApplet) { }

        HRESULT IsRestricted(ICplNamespace *pns) const;

    private:
        LPCWSTR m_pszFile;
        LPCWSTR m_pszApplet;
};


//
// Class IAction abstractly represents an action to perform.
//
// The intent is to associate an action object with a particular link
// object in the Control Panel UI.  This decoupling makes it easy to 
// change the action associated with a link.  It also allows us to 
// easily associate an action with multiple links as well as a 
// 'restriction' with a particular action.  As a result of this
// Link->Action->Restriction relationship, we can hide a link if it's
// action is restricted.  The link needs to know only about the 
// action and nothing about the restriction.
//
class IAction
{
    public:
        virtual HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const = 0;
        virtual HRESULT IsRestricted(ICplNamespace *pns) const = 0;
};


class CAction : public IAction
{
    public:
        CAction(const IRestrict *pRestrict = NULL);
        HRESULT IsRestricted(ICplNamespace *pns) const;

    private:
        const IRestrict *m_pRestrict;
};


class COpenCplCategory : public CAction
{
    public:
        explicit COpenCplCategory(eCPCAT eCategory, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPCAT m_eCategory;
};


//
// This class is similar to COpenCplCategory except that it first checks to see if
// the category has only one CPL applet and no tasks.  If this is the case,
// the action is automatically forwarded to the single CPL applet.  The initial
// requirement for this is to support the addition of keymgr.cpl to the "User Accounts"
// category, however keymgr may not be present on all SKUs.  Therefore, when keymgr
// is present, we will display the category page containing both the User Accounts CPL
// and the KeyMgr CPL.  If User Accounts CPL is the only CPL in this category, we simply
// launch it.
//
class COpenCplCategory2 : public CAction
{
    public:
        explicit COpenCplCategory2(eCPCAT eCategory, const IAction *pDefAction, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPCAT         m_eCategory;
        const IAction *m_pDefAction;

        HRESULT _ExecuteActionOnSingleCplApplet(HWND hwndParent, IUnknown *punkSite, bool *pbOpenCategory) const;
};


class COpenUserMgrApplet : public CAction
{
    public:
        explicit COpenUserMgrApplet(const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class COpenCplApplet : public CAction
{
    public:
        explicit COpenCplApplet(LPCWSTR pszApplet, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszApplet;
};


class COpenDeskCpl : public CAction
{
    public:
        explicit COpenDeskCpl(eDESKCPLTAB eCplTab, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eDESKCPLTAB m_eCplTab;
};


class CShellExecute : public CAction
{
    public:
        explicit CShellExecute(LPCWSTR pszExe, LPCWSTR pszArgs = NULL, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszExe;
        LPCWSTR m_pszArgs;
};


class CRunDll32 : public CAction
{
    public:
        explicit CRunDll32(LPCWSTR pszArgs, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszArgs;
};


enum eDISKUTILS { 
    eDISKUTIL_BACKUP, 
    eDISKUTIL_DEFRAG, 
    eDISKUTIL_CLEANUP,
    eDISKUTIL_NUMUTILS 
    };
    
class CExecDiskUtil : public CAction
{
    public:
        explicit CExecDiskUtil(eDISKUTILS util, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eDISKUTILS m_eUtil;

        static HRESULT _RemoveDriveLetterFmtSpec(LPTSTR pszCmdLine);
};


class CNavigateURL : public CAction
{
    public:
        explicit CNavigateURL(LPCWSTR pszURL, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszURL;
};


class COpenTroubleshooter : public CAction
{
    public:
        explicit COpenTroubleshooter(LPCWSTR pszTs, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszTs;
};

class COpenCplView : public CAction
{
    public:
        explicit COpenCplView(eCPVIEWTYPE eViewType, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPVIEWTYPE m_eViewType;

        HRESULT _SetFolderBarricadeStatus(void) const;

};


class CTrayCommand : public CAction
{
    public:
        explicit CTrayCommand(UINT idm, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        UINT m_idm;
};


class CAddPrinter : public CAction
{
    public:
        explicit CAddPrinter(const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class CActionNYI : public CAction
{
    public:
        explicit CActionNYI(LPCWSTR pszText);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszText;
};


} // namespace CPL





#endif // __CONTROLPANEL_ACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpnamespc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpnamespc.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_NAMESPACE_H
#define __CONTROLPANEL_NAMESPACE_H


namespace CPL {

//
// Generates a new namespace object to represent the Control Panel
// categorized namespace.
//
HRESULT CplNamespace_CreateInstance(IEnumIDList *penumIDs, REFIID riid, void **ppvOut);
//
// Retrieve the count of applets in a particular category.
//
HRESULT CplNamespace_GetCategoryAppletCount(ICplNamespace *pns, eCPCAT eCategory, int *pcApplets);


} // namespace CPL


#endif // __CONTROLPANEL_NAMESPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cplnkele.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cplnkele.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_LINKELEM_H
#define __CONTROLPANEL_LINKELEM_H

#include "cpviewp.h"
#include "cpuiele.h"
#include "cputil.h"

namespace CPL {


class CLinkElement : public DUI::Button
{
    public:
        virtual ~CLinkElement(void);

        void OnEvent(DUI::Event *pev);

        void OnInput(DUI::InputEvent *pev);

        void OnPropertyChanged(DUI::PropertyInfo *ppi, int iIndex, DUI::Value *pvOld, DUI::Value *pvNew);

        void OnDestroy(void);
        
        static HRESULT Create(DUI::Element **ppElement);

        HRESULT Initialize(IUICommand *pUiCommand, eCPIMGSIZE eIconSize);

        //
        // ClassInfo accessors (static and virtual instance-based)
        //
        static DUI::IClassInfo *Class;

        virtual DUI::IClassInfo *GetClassInfo(void)
            { return Class; }
        static HRESULT Register();

    private:
        //
        // These are the 3 states of a drag operation that we transition
        // through.  See the OnInput() method for usage and description.
        //
        enum { DRAG_IDLE, DRAG_HITTESTING, DRAG_DRAGGING };
        
        IUICommand    *m_pUiCommand;     // Link command object associated with element.
        eCPIMGSIZE     m_eIconSize;
        HWND           m_hwndInfotip;    // Infotip window.
        ATOM           m_idTitle;
        ATOM           m_idIcon;
        int            m_iDragState;
        RECT           m_rcDragBegin;

        //
        // Prevent copy.
        //
        CLinkElement(const CLinkElement& rhs);              // not implemented.
        CLinkElement& operator = (const CLinkElement& rhs); // not implemented.

    public:
        CLinkElement(void);

    private:
        HRESULT _Initialize(void);
        HRESULT _InitializeAccessibility(void);
        HRESULT _CreateElementTitle(void);
        HRESULT _CreateElementIcon(void);
        HRESULT _GetElementIcon(HICON *phIcon);
        HRESULT _AddOrDeleteAtoms(bool bAdd);
    
        HRESULT _OnContextMenu(DUI::ButtonContextEvent *peButton);
        HRESULT _OnSelected(void);

        void _Destroy(void);
        void _OnElementResized(DUI::Value *pvNewExtent);
        void _OnElementMoved(DUI::Value *pvNewLocation);
        void _OnMouseOver(DUI::Value *pvNewMouseWithin);

        HRESULT _GetInfotipText(LPWSTR *ppszInfotip);
        HRESULT _GetTitleText(LPWSTR *ppszTitle);
        HRESULT _ShowInfotipWindow(bool bShow);
        HRESULT _GetDragDropData(IDataObject **ppdtobj);
        HRESULT _BeginDrag(int iClickPosX, int iClickPosY);
        HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect);
        HRESULT _GetDragImageBitmap(HBITMAP *phbm, LONG *plWidth, LONG *plHeight);
        HRESULT _SetDragImage(IDataObject *pdtobj, int iClickPosX, int iClickPosY);
};


} // namespace CPL



#endif // __CONTROLPANEL_LINKELEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cplnkele.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cplnkele.cpp
//
//  This module implements a 'link' element in the Control Panel's DUI
//  view.  Link elements have a title, infotip, icon and an associated
//  command that is invoked when the link is selected.  The CLinkElement
//  object is an extension of the DUI::Button class.  Direct UI automatically
//  creates an instance of CLinkElement when a 'linkelement' item from 
//  cpview.ui is instantiated.
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cpaction.h"
#include "cpduihlp.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cplnkele.h"
#include "cputil.h"
#include "defviewp.h"
#include "dobjutil.h"
#include "ids.h"

using namespace CPL;


CLinkElement::CLinkElement(
    void
    ) : m_pUiCommand(NULL),
        m_eIconSize(eCPIMGSIZE(-1)),
        m_hwndInfotip(NULL),
        m_idTitle(0),
        m_idIcon(0),
        m_iDragState(DRAG_IDLE)
{
    TraceMsg(TF_LIFE, "CLinkElement::CLinkElement, this = 0x%x", this);

    SetRect(&m_rcDragBegin, 0, 0, 0, 0);
}



CLinkElement::~CLinkElement(
    void
    )
{
    TraceMsg(TF_LIFE, "CLinkElement::~CLinkElement, this = 0x%x", this);
    _Destroy();
}



//
// This is called by the DUI engine when the link element is 
// created.
//
HRESULT
CLinkElement::Create(    // [static]
    DUI::Element **ppElement
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CLinkElement *ple = DUI::HNewAndZero<CLinkElement>();
    if (NULL != ple)
    {
        hr = ple->_Initialize();
        if (FAILED(hr))
        {
            ple->Destroy();
            ple = NULL;
        }
    }
    *ppElement = ple;
    return THR(hr);
}


//
// This is called by the Control Panel UI code creating 
// the link element.
// 
HRESULT
CLinkElement::Initialize(
    IUICommand *pUiCommand,
    eCPIMGSIZE eIconSize
    )
{
    ASSERT(NULL == m_pUiCommand);
    ASSERT(NULL != pUiCommand);

    (m_pUiCommand = pUiCommand)->AddRef();

    m_eIconSize = eIconSize;

    HRESULT hr = _CreateElementTitle();
    if (SUCCEEDED(hr))
    {
        //
        // We don't fail element creation if the icon
        // cannot be created.  We want to display the
        // title without an icon so that we know there's 
        // a problem retrieving the icon.
        //
        THR(_CreateElementIcon());
    }

    //
    // Note that we don't fail element creation if accessibility
    // initialization fails.
    //
    THR(_InitializeAccessibility());

    if (FAILED(hr))
    {
        ATOMICRELEASE(m_pUiCommand);
    }
    return THR(hr);
}


HRESULT
CLinkElement::_InitializeAccessibility(
    void
    )
{
    HRESULT hr = THR(SetAccessible(true));
    if (SUCCEEDED(hr))
    {
        hr = THR(SetAccRole(ROLE_SYSTEM_LINK));
        if (SUCCEEDED(hr))
        {
            LPWSTR pszTitle;
            hr = THR(_GetTitleText(&pszTitle));
            if (SUCCEEDED(hr))
            {
                hr = THR(SetAccName(pszTitle));
                CoTaskMemFree(pszTitle);
                pszTitle = NULL;
                
                if (SUCCEEDED(hr))
                {
                    LPWSTR pszInfotip;
                    hr = THR(_GetInfotipText(&pszInfotip));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(SetAccDesc(pszInfotip));
                        CoTaskMemFree(pszInfotip);
                        pszInfotip = NULL;
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szDefAction[80];
                            if (0 < LoadString(HINST_THISDLL, 
                                               IDS_CP_LINK_ACCDEFACTION, 
                                               szDefAction, 
                                               ARRAYSIZE(szDefAction)))
                            {
                                hr = THR(SetAccDefAction(szDefAction));
                            }
                            else
                            {
                                hr = THR(ResultFromLastError());
                            }
                        }
                    }
                }
            }
        }
    }
    return THR(hr);
}


void
CLinkElement::OnDestroy(
    void
    )
{
    _Destroy();
    DUI::Button::OnDestroy();
}


void
CLinkElement::OnInput(
    DUI::InputEvent *pev
    )
{
    if (GINPUT_MOUSE == pev->nDevice)
    {
        //
        // Use a set of states to control our handling of 
        // the mouse inputs for drag/drop.
        // 
        // DRAG_IDLE        - We have not yet detected any drag activity.
        // DRAG_HITTESTING  - Waiting to see if user drags cursor a minimum distance.
        // DRAG_DRAGGING    - User did drag cursor a minimum distance and we're now
        //                    inside the drag loop.
        //
        //
        //  START -+-> DRAG_IDLE --> [ GMOUSE_DRAG ] --> DRAG_HITTESTING --+
        //         |                                                       |
        //         |                                    [ GMOUSE_DRAG +    |
        //         |                                      moved SM_CXDRAG  |
        //         |                                      or SM_CYDRAG ]   |
        //         |                                                       |
        //         +-<--------------- [ GMOUSE_UP ] <--- DRAG_DRAGGING <---+
        //                                          
        DUI::MouseEvent *pmev = (DUI::MouseEvent *)pev;
        switch(pev->nCode)
        {
            case GMOUSE_UP:
                m_iDragState = DRAG_IDLE;
                break;

            case GMOUSE_DRAG:
                switch(m_iDragState)
                {
                    case DRAG_IDLE:
                    {
                        //
                        // This is the same way comctl's listview calculates
                        // the begin-drag rect.
                        //
                        int dxClickRect = GetSystemMetrics(SM_CXDRAG);
                        int dyClickRect = GetSystemMetrics(SM_CYDRAG);

                        if (4 > dxClickRect)
                        {
                            dxClickRect = dyClickRect = 4;
                        }

                        //
                        // Remember where the mouse pointer is on our first
                        // indication that a drag operation is starting.
                        //
                        SetRect(&m_rcDragBegin, 
                                 pmev->ptClientPxl.x - dxClickRect,
                                 pmev->ptClientPxl.y - dyClickRect,
                                 pmev->ptClientPxl.x + dxClickRect,
                                 pmev->ptClientPxl.y + dyClickRect);

                        m_iDragState = DRAG_HITTESTING;
                        break;
                    }

                    case DRAG_HITTESTING:
                        if (!PtInRect(&m_rcDragBegin, pmev->ptClientPxl))
                        {
                            //
                            // Begin the drag/drop operation only if we've moved the mouse
                            // outside the "drag begin" rectangle.  This prevents us from 
                            // confusing a normal click with a drag/drop operation.
                            //
                            m_iDragState = DRAG_DRAGGING;
                            //
                            // Position the drag point at the middle of the item's image.
                            //
                            UINT cxIcon = 32;
                            UINT cyIcon = 32;
                            CPL::ImageDimensionsFromDesiredSize(m_eIconSize, &cxIcon, &cyIcon);
                            
                            _BeginDrag(cxIcon / 2, cyIcon / 2);
                        }
                        break;

                    case DRAG_DRAGGING:
                        break;
                }
                break;
                
            default:
                break;
        }
    }
    Button::OnInput(pev);
}


void
CLinkElement::OnEvent(
    DUI::Event *pev
    )
{
    if (DUI::Button::Click == pev->uidType)
    {
        pev->fHandled = true;

        DUI::ButtonClickEvent * pbe = (DUI::ButtonClickEvent *) pev;
        if (1 != pbe->nCount)   
        {
            return; // ingore additional clicks - don't forward.
        }
        _OnSelected();
    }
    else if (DUI::Button::Context == pev->uidType)
    {
        DUI::ButtonContextEvent *peButton = reinterpret_cast<DUI::ButtonContextEvent *>(pev);
        _OnContextMenu(peButton);
        pev->fHandled = true;
    }
    Button::OnEvent(pev);
}


void 
CLinkElement::OnPropertyChanged(
    DUI::PropertyInfo *ppi, 
    int iIndex, 
    DUI::Value *pvOld, 
    DUI::Value *pvNew
    )
{
    //
    // Don't trace this function.  It's called very often.
    //
    // Perform default processing.
    //
    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(MouseWithin))
    {
        _OnMouseOver(pvNew);
    }
}



//
// Called to begin a drag-drop operation from the control panel.
// This is used for dragging CPL applet icons to shell folders
// for shortcut creation.
//
HRESULT
CLinkElement::_BeginDrag(
    int iClickPosX,
    int iClickPosY
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_BeginDrag");

    HRESULT hr = E_FAIL;
    HRESULT hrCoInit = SHCoInitialize();
    if (SUCCEEDED(hrCoInit))
    {
        hr = hrCoInit;
        
        IDataObject *pdtobj;
        hr = _GetDragDropData(&pdtobj);
        if (SUCCEEDED(hr))
        {
            //
            // Ignore any failure to set the drag image.  Drag images
            // are not supported on some video configurations.
            // In these cases, we still want to be able to create a shortcut.
            //
            THR(_SetDragImage(pdtobj, iClickPosX, iClickPosY));

            HWND hwndRoot;
            hr = THR(Dui_GetElementRootHWND(this, &hwndRoot));
            if (SUCCEEDED(hr))
            {
                DWORD dwEffect = DROPEFFECT_LINK;
                hr = THR(SHDoDragDrop(hwndRoot, pdtobj, NULL, dwEffect, &dwEffect));
            }
            pdtobj->Release();
        }
        SHCoUninitialize(hrCoInit);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_BeginDrag", hr);
    return THR(hr);
}


//
// Get and prepare the data object used in a drag-drop operation.
// The returned data object is suitable for use by SHDoDragDrop.
//
HRESULT
CLinkElement::_GetDragDropData(
    IDataObject **ppdtobj
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_GetDragDropData");
    ASSERT(NULL != ppdtobj);
    ASSERT(!IsBadWritePtr(ppdtobj, sizeof(*ppdtobj)));
    ASSERT(NULL != m_pUiCommand);
    
    *ppdtobj = NULL;
    
    ICpUiCommand *puic;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiCommand, &puic));
    if (SUCCEEDED(hr))
    {
        //
        // Note that this call will fail with E_NOTIMPL for links that don't
        // provide drag-drop data.  Only CPL applet links provide data.
        // This is how we limit drag-drop to only CPL applets.
        //
        IDataObject *pdtobj;
        hr = THR(puic->GetDataObject(&pdtobj));
        if (SUCCEEDED(hr))
        {
            hr = _SetPreferredDropEffect(pdtobj, DROPEFFECT_LINK);
            if (SUCCEEDED(hr))
            {
                (*ppdtobj = pdtobj)->AddRef();
            }
            pdtobj->Release();
        }
        puic->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_GetDragDropData", hr);
    return THR(hr);
}


HRESULT
CLinkElement::_SetPreferredDropEffect(
    IDataObject *pdtobj,
    DWORD dwEffect
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_SetPreferredDropEffect");

    HRESULT hr = S_OK;
    static CLIPFORMAT cf;
    if ((CLIPFORMAT)0 == cf)
    {
        cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        if ((CLIPFORMAT)0 == cf)
        {
            hr = THR(ResultFromLastError());
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = THR(DataObj_SetDWORD(pdtobj, cf, dwEffect));
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_SetPreferredDropEffect", hr);
    return THR(hr);
}


//
// Set up the drag image in the data object so that our icon is
// displayed during the drag operation.
//
// I took this code from the old webvw project's fldricon.cpp 
// implementation (shell\ext\webvw\fldricon.cpp).  It seems to
// work just fine.
//
HRESULT 
CLinkElement::_SetDragImage(
    IDataObject *pdtobj,
    int iClickPosX, 
    int iClickPosY
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_SetDragImage");

    ASSERT(NULL != pdtobj);

    HRESULT hr = S_OK;
    HDC hdc = CreateCompatibleDC(NULL);
    if (NULL == hdc)
    {
        hr = THR(ResultFromLastError());
    }
    else
    {
        HBITMAP hbm;
        LONG lBitmapWidth;
        LONG lBitmapHeight;
        hr = _GetDragImageBitmap(&hbm, &lBitmapWidth, &lBitmapHeight);
        if (SUCCEEDED(hr))
        {
            IDragSourceHelper *pdsh;
            hr = CoCreateInstance(CLSID_DragDropHelper, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_PPV_ARG(IDragSourceHelper, &pdsh));
            if (SUCCEEDED(hr))
            {
                BITMAPINFOHEADER bmi = {0};
                BITMAP           bm  = {0};
                UINT uBufferOffset   = 0;
                //
                // This is a screwy procedure to use GetDIBits.  
                // See knowledge base Q80080
                //
                if (GetObject(hbm, sizeof(BITMAP), &bm))
                {
                    bmi.biSize     = sizeof(BITMAPINFOHEADER);
                    bmi.biWidth    = bm.bmWidth;
                    bmi.biHeight   = bm.bmHeight;
                    bmi.biPlanes   = 1;
                    bmi.biBitCount = bm.bmPlanes * bm.bmBitsPixel;
                    //
                    // This needs to be one of these 4 values
                    //
                    if (bmi.biBitCount <= 1)
                        bmi.biBitCount = 1;
                    else if (bmi.biBitCount <= 4)
                        bmi.biBitCount = 4;
                    else if (bmi.biBitCount <= 8)
                        bmi.biBitCount = 8;
                    else
                        bmi.biBitCount = 24;
                    
                    bmi.biCompression = BI_RGB;
                    //
                    // Total size of buffer for info struct and color table
                    //
                    uBufferOffset = sizeof(BITMAPINFOHEADER) + 
                                    ((bmi.biBitCount == 24) ? 0 : ((1 << bmi.biBitCount) * sizeof(RGBQUAD)));
                    //
                    // Buffer for bitmap bits, so we can copy them.
                    //
                    BYTE *psBits = (BYTE *)SHAlloc(uBufferOffset);

                    if (NULL == psBits)
                    {
                        hr = THR(E_OUTOFMEMORY);
                    }
                    else
                    {
                        //
                        // Put bmi into the memory block
                        //
                        CopyMemory(psBits, &bmi, sizeof(BITMAPINFOHEADER));
                        //
                        // Get the size of the buffer needed for bitmap bits
                        //
                        if (!GetDIBits(hdc, hbm, 0, 0, NULL, (BITMAPINFO *) psBits, DIB_RGB_COLORS))
                        {
                            hr = THR(ResultFromLastError());
                        }
                        else
                        {
                            //
                            // Realloc our buffer to be big enough
                            //
                            psBits = (BYTE *)SHRealloc(psBits, uBufferOffset + ((BITMAPINFOHEADER *) psBits)->biSizeImage);

                            if (NULL == psBits)
                            {
                                hr = THR(E_OUTOFMEMORY);
                            }
                            else
                            {
                                //
                                // Fill the buffer
                                //
                                if (!GetDIBits(hdc, 
                                               hbm, 
                                               0, 
                                               bmi.biHeight, 
                                               (void *)(psBits + uBufferOffset), 
                                               (BITMAPINFO *)psBits, 
                                               DIB_RGB_COLORS))
                                {
                                    hr = THR(ResultFromLastError());
                                }
                                else
                                {
                                    SHDRAGIMAGE shdi;  // Drag images struct
                                    
                                    shdi.hbmpDragImage = CreateBitmapIndirect(&bm);
                                    if (NULL == shdi.hbmpDragImage)
                                    {
                                        hr = THR(ResultFromLastError());
                                    }
                                    else
                                    {
                                        //
                                        // Set the drag image bitmap
                                        //
                                        if (SetDIBits(hdc, 
                                                      shdi.hbmpDragImage, 
                                                      0, 
                                                      lBitmapHeight, 
                                                      (void *)(psBits + uBufferOffset), 
                                                      (BITMAPINFO *)psBits, 
                                                      DIB_RGB_COLORS))
                                        {
                                            //
                                            // Populate the drag image structure
                                            //
                                            shdi.sizeDragImage.cx = lBitmapWidth;
                                            shdi.sizeDragImage.cy = lBitmapHeight;
                                            shdi.ptOffset.x       = iClickPosX;
                                            shdi.ptOffset.y       = iClickPosY;
                                            shdi.crColorKey       = 0;
                                            //
                                            // Set the drag image
                                            //
                                            hr = pdsh->InitializeFromBitmap(&shdi, pdtobj); 
                                        }
                                        else
                                        {
                                            hr = THR(ResultFromLastError());
                                        }
                                        if (FAILED(hr))
                                        {
                                            DeleteObject(shdi.hbmpDragImage);
                                        }
                                    }
                                }
                            }
                        }
                        if (NULL != psBits)
                        {
                            SHFree(psBits);
                        }
                    }
                }
                pdsh->Release();
            }
            DeleteObject(hbm);
        }
        DeleteDC(hdc);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_SetDragImage", hr);
    return THR(hr);
}


HRESULT
CLinkElement::_GetDragImageBitmap(
    HBITMAP *phbm,
    LONG *plWidth,
    LONG *plHeight
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_GetDragImageBitmap");

    ASSERT(NULL != phbm);
    ASSERT(!IsBadWritePtr(phbm, sizeof(*phbm)));
    ASSERT(NULL != plWidth);
    ASSERT(!IsBadWritePtr(plWidth, sizeof(*plWidth)));
    ASSERT(NULL != plHeight);
    ASSERT(!IsBadWritePtr(plHeight, sizeof(*plHeight)));
    
    *phbm     = NULL;
    *plWidth  = 0;
    *plHeight = 0;

    HICON hIcon;
    HRESULT hr = _GetElementIcon(&hIcon);
    if (SUCCEEDED(hr))
    {
        ICONINFO iconinfo;

        if (GetIconInfo(hIcon, &iconinfo))
        {
            BITMAP bm;
            if (GetObject(iconinfo.hbmColor, sizeof(bm), &bm))
            {
                *plWidth  = bm.bmWidth;
                *plHeight = bm.bmHeight;
                *phbm     = iconinfo.hbmColor;
            }
            else
            {
                DeleteObject(iconinfo.hbmColor);
                hr = THR(ResultFromLastError());
            }
            DeleteObject(iconinfo.hbmMask);
        }
        else
        {
            hr = THR(ResultFromLastError());
        }
        DestroyIcon(hIcon);
    }    
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_GetDragImageBitmap", hr);
    return THR(hr);
}



HRESULT
CLinkElement::_Initialize(
    void
    )
{
    HRESULT hr = Button::Initialize(AE_Mouse | AE_Keyboard);
    if (SUCCEEDED(hr))
    {
        hr = _AddOrDeleteAtoms(true);
    }
    return THR(hr);
}


void
CLinkElement::_Destroy(
    void
    )
{
    if (NULL != m_hwndInfotip && IsWindow(m_hwndInfotip))
    {
        SHDestroyInfotipWindow(&m_hwndInfotip);
    }

    ATOMICRELEASE(m_pUiCommand);

    _AddOrDeleteAtoms(false);
}


HRESULT
CLinkElement::_AddOrDeleteAtoms(
    bool bAdd
    )
{
    struct CPL::ATOMINFO rgAtomInfo[] = {
        { L"title", &m_idTitle },
        { L"icon",  &m_idIcon  },
        };

    HRESULT hr = Dui_AddOrDeleteAtoms(rgAtomInfo, ARRAYSIZE(rgAtomInfo), bAdd);
    return THR(hr);
}



HRESULT
CLinkElement::_CreateElementTitle(
    void
    )
{
    LPWSTR pszTitle;
    HRESULT hr = _GetTitleText(&pszTitle);
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementText(this, L"title", pszTitle);
        CoTaskMemFree(pszTitle);
    }
    return THR(hr);
}
    


HRESULT
CLinkElement::_CreateElementIcon(
    void
    )
{
    HICON hIcon;
    HRESULT hr = _GetElementIcon(&hIcon);
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementIcon(this, L"icon", hIcon);
        if (FAILED(hr))
        {
            DestroyIcon(hIcon);
        }
    }
    return THR(hr);
}


HRESULT
CLinkElement::_GetElementIcon(
    HICON *phIcon
    )
{
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));
    ASSERT(NULL != m_pUiCommand);

    *phIcon = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadIcon(m_eIconSize, phIcon);
        pei->Release();
    }
    return THR(hr);
}


HRESULT
CLinkElement::_OnContextMenu(
    DUI::ButtonContextEvent *peButton
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_OnContextMenu");

    ICpUiCommand *pcmd;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiCommand, &pcmd));
    if (SUCCEEDED(hr))
    {
        HWND hwndRoot;
        hr = Dui_GetElementRootHWND(this, &hwndRoot);
        if (SUCCEEDED(hr))
        {
            if (-1 == peButton->pt.x)
            {
                //
                // Keyboard context menu.
                //
                SIZE size;
                hr = Dui_GetElementExtent(this, &size);
                if (SUCCEEDED(hr))
                {
                    peButton->pt.x = size.cx / 2;
                    peButton->pt.y = size.cy / 2;
                }
            }
            POINT pt;
            hr = Dui_MapElementPointToRootHWND(this, peButton->pt, &pt);
            if (SUCCEEDED(hr))
            {
                if (ClientToScreen(hwndRoot, &pt))
                {
                    //
                    // InvokeContextMenu returns S_FALSE if the command doesn't 
                    // provide a context menu.
                    //
                    hr = pcmd->InvokeContextMenu(hwndRoot, &pt);
                }
                else
                {
                    hr = CPL::ResultFromLastError();
                }
            }
        }
        pcmd->Release();
    }
    else if (E_NOINTERFACE == hr)
    {
        hr = S_FALSE;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_OnContextMenu", hr);
    return THR(hr);
}



HRESULT
CLinkElement::_OnSelected(
    void
    )
{
    ASSERT(NULL != m_pUiCommand);

    //
    //  Delay navigation until double-click time times out occurs. 
    //
    //  KB: gpease  05-APR-2001     Fix for Whistler Bug #338552 (and others)
    //
    //      Delaying this prevents the "second click" from being applied
    //      to the newly navigated frame. Previously, if there happen to 
    //      be a new link in the new frame at the same mouse point at 
    //      which the previous navigation occured, the new link would have
    //      received the 2nd click and we'd navigate that link as well. This
    //      causes the current frame to get the 2nd click which we ignore
    //      since we only care about the single click (see OnEvent above).
    //

    HWND hwndRoot;
    HRESULT hr = Dui_GetElementRootHWND(this, &hwndRoot);
    if (SUCCEEDED(hr))
    {
        SendMessage(hwndRoot, WM_USER_DELAY_NAVIGATION, (WPARAM) NULL, (LPARAM) m_pUiCommand);
    }

    return THR(hr);
}



void
CLinkElement::_OnMouseOver(
    DUI::Value *pvNewMouseWithin
    )
{
    _ShowInfotipWindow(pvNewMouseWithin->GetBool());
}
    


//
// Retrieve the title text for the element.
// Caller must free returned buffer using CoTaskMemFree.
//
HRESULT
CLinkElement::_GetTitleText(
    LPWSTR *ppszTitle
    )
{
    ASSERT(NULL != m_pUiCommand);
    ASSERT(NULL != ppszTitle);
    ASSERT(!IsBadWritePtr(ppszTitle, sizeof(*ppszTitle)));

    *ppszTitle = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadName(ppszTitle);
        pei->Release();
    }
    return THR(hr);
}


//
// Retrieve the infotip text for the element.
// Caller must free returned buffer using CoTaskMemFree.
//
HRESULT
CLinkElement::_GetInfotipText(
    LPWSTR *ppszInfotip
    )
{
    ASSERT(NULL != m_pUiCommand);
    ASSERT(NULL != ppszInfotip);
    ASSERT(!IsBadWritePtr(ppszInfotip, sizeof(*ppszInfotip)));

    *ppszInfotip = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadTooltip(ppszInfotip);
        pei->Release();
    }
    return THR(hr);
}
    


HRESULT
CLinkElement::_ShowInfotipWindow(
    bool bShow
    )
{
    HRESULT hr = S_OK;
    if (bShow)
    {
        if (NULL == m_hwndInfotip)
        {
            HWND hwndRoot;
            hr = THR(Dui_GetElementRootHWND(this, &hwndRoot));
            if (SUCCEEDED(hr))
            {
                LPWSTR pszInfotip;
                hr = THR(_GetInfotipText(&pszInfotip));
                if (SUCCEEDED(hr))
                {
                    hr = THR(SHCreateInfotipWindow(hwndRoot, pszInfotip, &m_hwndInfotip));
                    CoTaskMemFree(pszInfotip);
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = THR(SHShowInfotipWindow(m_hwndInfotip, TRUE));
        }
    }
    else
    {
        if (NULL != m_hwndInfotip)
        {
            hr = THR(SHDestroyInfotipWindow(&m_hwndInfotip));
        }
    }
    return THR(hr);
}



//
// ClassInfo (must appear after property definitions).
//
DUI::IClassInfo *CLinkElement::Class = NULL;
HRESULT CLinkElement::Register()
{
    return DUI::ClassInfo<CLinkElement,DUI::Button>::Register(L"linkelement", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cplobj.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "control.h"
#include "uemapp.h"

#include <limits.h>

#define TF_CPL TF_CUSTOM2

typedef struct
{
    ATOM aCPL;     // CPL name atom (so we can match requests)
    ATOM aApplet;  // applet name atom (so we can match requests, may be zero)
    HWND hwndStub; // window for this dude (so we can switch to it)
    UINT flags;    // see PCPLIF_ flags below
} CPLAPPLETID;

//
// PCPLIF_DEFAULT_APPLET
// There are two ways of getting the default applet, asking for it my name
// and passing an empty applet name.  This flag should be set regardless,
// so that the code which switches to an already-active applet can always
// find a previous instance if it exists.
//

#define PCPLIF_DEFAULT_APPLET   (0x1)

typedef struct
{
    int icon;
    TCHAR cpl[ CCHPATHMAX ];
    TCHAR applet[ MAX_CCH_CPLNAME ];
    TCHAR *params;
} CPLEXECINFO;

ATOM aCPLName = (ATOM)0;
ATOM aCPLFlags = (ATOM)0;

void CPL_ParseCommandLine (CPLEXECINFO *info, LPTSTR pszCmdLine, BOOL extract_icon);
BOOL CPL_LoadAndFindApplet (LPCPLMODULE *pcplm, HICON *phIcon, UINT *puControl, CPLEXECINFO *info);

BOOL CPL_FindCPLInfo(LPTSTR pszCmdLine, HICON *phIcon, UINT *ppapl, LPTSTR *pparm)
{
    LPCPLMODULE pmod;
    CPLEXECINFO info;

    CPL_ParseCommandLine(&info, pszCmdLine, TRUE);

    if (CPL_LoadAndFindApplet(&pmod, phIcon, ppapl, &info))
    {
        *pparm = info.params;
        CPL_FreeCPLModule(pmod);
        return TRUE;
    }

    *pparm = NULL;
    return FALSE;
}

typedef struct _fcc {
    LPTSTR      lpszClassStub;
    CPLAPPLETID *target;
    HWND        hwndMatch;
} FCC, *LPFCC;


BOOL _FindCPLCallback(HWND hwnd, LPARAM lParam)
{
    LPFCC lpfcc = (LPFCC)lParam;
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

    if (lstrcmp(szClass, lpfcc->lpszClassStub) == 0)    // Must be same class...
    {
        // Found a stub window
        if (lpfcc->target->aCPL != 0)
        {
            HANDLE hHandle;

            ATOM aCPL;
            hHandle = GetProp(hwnd, (LPCTSTR)(DWORD_PTR)aCPLName);

            ASSERT((DWORD_PTR) hHandle < USHRT_MAX);
            aCPL = (ATOM)(DWORD_PTR) hHandle;

            if (aCPL != 0 && aCPL == lpfcc->target->aCPL)
            {
                ATOM aApplet;
                hHandle = GetProp(hwnd, (LPCTSTR)(DWORD_PTR)aCPL);
                aApplet = (ATOM)(DWORD_PTR) hHandle;
                ASSERT((DWORD_PTR) hHandle < USHRT_MAX);

                // users may request any applet by name
                if (aApplet != 0 && aApplet == lpfcc->target->aApplet)
                {
                    lpfcc->hwndMatch = hwnd;
                    return FALSE;
                }
                //
                // Users may request the default w/o specifying a name
                //
                if (lpfcc->target->flags & PCPLIF_DEFAULT_APPLET)
                {
                    UINT flags = HandleToUlong(GetProp(hwnd, MAKEINTATOM(aCPLFlags)));

                    if (flags & PCPLIF_DEFAULT_APPLET)
                    {
                        lpfcc->hwndMatch = hwnd;
                        return FALSE;
                    }
                }
            }
        }
    }
    return TRUE;
}

HWND FindCPL(HWND hwndStub, CPLAPPLETID *target)
{
    FCC fcc;
    TCHAR szClassStub[32];

    if (aCPLName == (ATOM)0)
    {
        aCPLName = GlobalAddAtom(TEXT("CPLName"));
        aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));

        if (aCPLName == (ATOM)0 || aCPLFlags == (ATOM)0)
            return NULL;        // This should never happen... didn't find hwnd
    }

    szClassStub[0] = '\0'; // a NULL hwnd has no class
    if (hwndStub)
    {
        GetClassName(hwndStub, szClassStub, ARRAYSIZE(szClassStub));
    }
    fcc.lpszClassStub = szClassStub;
    fcc.target = target;
    fcc.hwndMatch = (HWND)0;

    EnumWindows(_FindCPLCallback, (LPARAM)&fcc);

    return fcc.hwndMatch;
}

//----------------------------------------------------------------------------
// parsing helper for comma lists
//

TCHAR *CPL_ParseToSeparator(TCHAR *dst, TCHAR *psrc, size_t dstmax, BOOL spacedelimits)
{
    if (psrc)
    {
        TCHAR source[CCHPATHMAX], *src;
        TCHAR *delimiter, *closingquote = NULL;

        lstrcpyn(source, psrc, (int)((dstmax < ARRAYSIZE(source)) ? dstmax : ARRAYSIZE(source)));
        src = source;

        //
        // eat whitespace
        //

        while(*src == TEXT(' '))
            src++;

        delimiter = src;

        //
        // ignore stuff inside quoted strings
        //

        if (*src == TEXT('"'))
        {
            //
            // start after first quote, advance src past quote
            //

            closingquote = ++src;

            while(*closingquote && *closingquote != TEXT('"'))
                closingquote++;

            //
            // see if loop above ended on a quote
            //

            if (*closingquote)
            {
                //
                // temporary NULL termination
                //

                *closingquote = 0;

                //
                // start looking for delimiter again after quotes
                //

                delimiter = closingquote + 1;
            }
            else
                closingquote = NULL;
        }

        if (spacedelimits)
        {
            delimiter += StrCSpn(delimiter, TEXT(", "));

            if (!*delimiter)
                delimiter = NULL;
        }
        else
            delimiter = StrChr(delimiter, TEXT(','));

        //
        // temporary NULL termination
        //

        if (delimiter)
            *delimiter = 0;

        if (dst)
        {
            lstrcpyn(dst, src, (int)dstmax);
            dst[ dstmax - 1 ] = 0;
        }

        //
        // put back stuff we terminated above
        //

        if (delimiter)
            *delimiter = TEXT(',');

        if (closingquote)
            *closingquote = TEXT('"');

        //
        // return start of next string
        //

        psrc = (delimiter ? (psrc + ((delimiter + 1) - source)) : NULL);
    }
    else if (dst)
    {
        *dst = 0;
    }

    //
    // new source location
    //

    return psrc;
}


// parse the Control_RunDLL command line
// format: "CPL name, applet name, extra params"
// format: "CPL name, icon index, applet name, extra params"
//
//  NOTE: [stevecat]  3/10/95
//
//         The 'extra params' do not have to be delimited by a ","
//         in NT for the case "CPL name applet name extra params"
//
//         A workaround for applet names that include a space
//         in their name would be to enclose that value in
//         double quotes (see the CPL_ParseToSeparator routine.)
//

void CPL_ParseCommandLine(CPLEXECINFO *info, LPTSTR pszCmdLine, BOOL extract_icon)
{
    //
    // parse out the CPL name, spaces are valid separators
    //

    pszCmdLine = CPL_ParseToSeparator(info->cpl, pszCmdLine, CCHPATHMAX, TRUE);

    if (extract_icon)
    {
        TCHAR icon[ 8 ];

        //
        // parse out the icon id/index, spaces are not valid separators
        //

        pszCmdLine = CPL_ParseToSeparator(icon, pszCmdLine, ARRAYSIZE(icon), FALSE);

        info->icon = StrToInt(icon);
    }
    else
        info->icon = 0;

    //
    // parse out the applet name, spaces are not valid separators
    //

    info->params = CPL_ParseToSeparator(info->applet, pszCmdLine,
                                         MAX_CCH_CPLNAME, FALSE);

    CPL_StripAmpersand(info->applet);
}

BOOL CPL_LoadAndFindApplet(LPCPLMODULE *ppcplm, HICON *phIcon, UINT *puControl, CPLEXECINFO *info)
{
    TCHAR szControl[MAX_CCH_CPLNAME];
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    int nControl = 0;   // fall thru to default
    int NumControls;

    ENTERCRITICAL;

    pcplm = CPL_LoadCPLModule(info->cpl);

    if (!pcplm || !pcplm->hacpli)
    {
        DebugMsg(DM_ERROR, TEXT("Control_RunDLL: ") TEXT("CPL_LoadCPLModule failed \"%s\""), info->cpl);
        LEAVECRITICAL;
        goto Error0;
    }

    //
    // Look for the specified applet
    // no applet specified selects applet 0
    //

    if (*info->applet)
    {
        NumControls = DSA_GetItemCount(pcplm->hacpli);

        if (info->applet[0] == TEXT('@'))
        {
            nControl = StrToLong(info->applet+1);

            if (nControl >= 0 && nControl < NumControls)
            {
                goto GotControl;
            }
        }

        //
        //  Check for the "Setup" argument and send the special CPL_SETUP
        //  message to the applet to tell it we are running under Setup.
        //

        if (!lstrcmpi (TEXT("Setup"), info->params))
            CPL_CallEntry(pcplm, NULL, CPL_SETUP, 0L, 0L);

        for (nControl=0; nControl < NumControls; nControl++)
        {
            pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
            lstrcpyn(szControl, pcpli->pszName, ARRAYSIZE(szControl));
            CPL_StripAmpersand(szControl);

            // if there is only one control, then use it.  This solves
            // some compat issues with CP names changing.
            if (lstrcmpi(info->applet, szControl) == 0 || 1 == NumControls)
                break;
        }

        //
        // If we get to the end of the list, bail out
        //

        // LEGACY WARNING: It might be necessary to handle some old applet names in a special
        // way.  This would be bad because the names are localized.  We would need to somehow
        // call into the CPL's to ask them if they support the given name.  Only the CPL
        // itself would know the correct legacy name mapping.  Adding a new CPL message might
        // cause as many legacy CPL problems as it solves so we would need to do something tricky
        // like adding an exported function.  We could then GetProcAddress on this exported function.
        // If the export exists, we would pass it the legacy name and it would return a number.
        //
        // Example: "control mmsys.cpl,Sounds" must work even though mmsys.cpl no longer contains
        //      an applet called "Sounds".  "control mmsys.cpl,Multimedia" must work even though
        //      mmsys.cpl no longer contains an applet called "Multimedia".  You can't simply
        //      rename the applet becuase these two CPL's were both merged into one CPL.  Renaming
        //      could never solve more than half the problem.

        if (nControl >= NumControls)
        {
            DebugMsg(DM_ERROR, TEXT("Control_RunDLL: ") TEXT("Cannot find specified applet"));
            LEAVECRITICAL;
            goto Error1;
        }
    }

GotControl:
    if (phIcon != NULL)
    {
        pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
        *phIcon = CopyIcon(pcpli->hIcon);
    }

    LEAVECRITICAL;
    //
    // yes, we really do want to pass negative indices through...
    //

    *puControl = (UINT)nControl;
    *ppcplm = pcplm;

    return TRUE;

Error1:
    CPL_FreeCPLModule(pcplm);
Error0:
    return FALSE;
}

BOOL CPL_Identify(CPLAPPLETID *identity, CPLEXECINFO *info, HWND stub)
{
    identity->aApplet = (ATOM)0;
    identity->hwndStub = stub;
    identity->flags = 0;

    if ((identity->aCPL = GlobalAddAtom(info->cpl)) == (ATOM)0)
        return FALSE;

    if (*info->applet)
    {
        if ((identity->aApplet = GlobalAddAtom(info->applet)) == (ATOM)0)
            return FALSE;
    }
    else
    {
        //
        // no applet name means use the default
        //

        identity->flags = PCPLIF_DEFAULT_APPLET;
    }

    return TRUE;
}


void CPL_UnIdentify(CPLAPPLETID *identity)
{
    if (identity->aCPL)
    {
        GlobalDeleteAtom(identity->aCPL);
        identity->aCPL = (ATOM)0;
    }

    if (identity->aApplet)
    {
        GlobalDeleteAtom(identity->aApplet);
        identity->aApplet = (ATOM)0;
    }

    identity->hwndStub = NULL;
    identity->flags = 0;
}


// It's time for Legacy Mode!!!  In NT5 we removed a bunch of CPL files
// from the product.  These files are used by name by many programs.  As a result,
// the old names need to keep working even though the files no longer exist.
// We handle this by checking if the file exists.  If it does not exist, we run
// the cpl name through a mapping table and then try again.  The mapping table can
// potentially change the CPL name, the applet number, and the params.
typedef struct
{
    LPTSTR oldInfo_cpl;
    LPTSTR oldInfo_applet;
    LPTSTR oldInfo_params;
    LPTSTR newInfo_cpl;
    LPTSTR newInfo_applet;
    LPTSTR newInfo_params;
} RUNDLLCPLMAPPING;

// For the oldInfo member, a NULL means to match any value from the pinfo structure.
// If the oldInfo structure mathces the pinfo structure then it will be updated using
// the data from newInfo structure. For the newInfo member, a NULL means to leave the
// corresponding pinfo member unchanged.
const RUNDLLCPLMAPPING g_rgRunDllCPLMapping[] = 
{
    { TEXT("MODEM.CPL"),    NULL, NULL,    TEXT("TELEPHON.CPL"), TEXT("@0"), TEXT("1") },
    { TEXT("UPS.CPL"),      NULL, NULL,    TEXT("POWERCFG.CPL"), NULL, NULL }
};

BOOL CPL_CheckLegacyMappings(CPLEXECINFO * pinfo)
{
    LPTSTR p;
    int i;

    TraceMsg(TF_CPL, "Attmepting Legacy CPL conversion on %s", pinfo->cpl);

    // we want only the filename, strip off any path information
    p = PathFindFileName(pinfo->cpl);
    StrCpyN(pinfo->cpl, p, CCHPATHMAX);

    for (i = 0; i < ARRAYSIZE(g_rgRunDllCPLMapping); i++)
    {
        if (0 == StrCmpI(pinfo->cpl, g_rgRunDllCPLMapping[i].oldInfo_cpl))
        {
            if (!g_rgRunDllCPLMapping[i].oldInfo_applet ||
                 0 == StrCmpI(pinfo->applet, g_rgRunDllCPLMapping[i].oldInfo_applet))
            {
                if (!g_rgRunDllCPLMapping[i].oldInfo_params ||
                     (pinfo->params &&
                       0 == StrCmpI(pinfo->params, g_rgRunDllCPLMapping[i].oldInfo_params)
                    )
                  )
                {
                    if (pinfo->params)
                    {
                        TraceMsg(TF_CPL, "%s,%s,%s matches item %d", pinfo->cpl, pinfo->applet, pinfo->params, i);
                    }
                    else
                    {
                        TraceMsg(TF_CPL, "%s,%s matches item %d", pinfo->cpl, pinfo->applet, i);
                    }

                    // The current entry matches the request.  Map to the new info and then
                    // ensure the new CPL exists.
                    StrCpyN(pinfo->cpl, g_rgRunDllCPLMapping[i].newInfo_cpl, CCHPATHMAX);

                    if (g_rgRunDllCPLMapping[i].newInfo_applet)
                    {
                        StrCpyN(pinfo->applet, g_rgRunDllCPLMapping[i].newInfo_applet, MAX_CCH_CPLNAME);
                    }

                    if (g_rgRunDllCPLMapping[i].newInfo_params)
                    {
                        // the params pointer is normally a pointer into the remaining chunk of a string
                        // buffer.  As such, we don't need to delete the memory it points to.  Also, this
                        // argument is read only so it should be safe for us to point it at our constant
                        // data.
                        pinfo->params = g_rgRunDllCPLMapping[i].newInfo_params;
                    }

                    if (pinfo->params)
                    {
                        TraceMsg(TF_CPL, "CPL mapped to %s,%s,%s", pinfo->cpl, pinfo->applet, pinfo->params);
                    }
                    else
                    {
                        TraceMsg(TF_CPL, "CPL mapped to %s,%s", pinfo->cpl, pinfo->applet);
                    }

                    return PathFindOnPath(pinfo->cpl, NULL);
                }
            }
        }
    }

    return FALSE;
}

// Goes through all of the work of identifying and starting a control
// applet.  Accepts a flag specifying whether or not to load a new DLL if it
// is not already present.  This code will ALLWAYS switch to an existing
// instance of the applet if bFindExisting is specified.
//
// WARNING: this function butchers the command line you pass in!

BOOL CPL_RunMeBaby(HWND hwndStub, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow, BOOL bAllowLoad, BOOL bFindExisting)
{
    int nApplet;
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    CPLEXECINFO info;
    CPLAPPLETID identity;
    TCHAR szApplet[ MAX_CCH_CPLNAME ];
    BOOL bResult = FALSE;
    HWND hwndOtherStub;
    HRESULT hrInit;

    if (SHRestricted(REST_NOCONTROLPANEL))
    {
        ShellMessageBox(HINST_THISDLL, hwndStub, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                        MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
        return FALSE;
    }

    hrInit = SHCoInitialize();

    //
    // parse the command line we got
    //

    CPL_ParseCommandLine(&info, pszCmdLine, FALSE);

    //
    // no applet to run means open the controls folder
    //

    if (!*info.cpl)
    {
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_CONTROLS), nCmdShow);
        bResult = TRUE;
        goto Error0;
    }

    // expand CPL name to a full path if it isn't already
    if (PathIsFileSpec(info.cpl))
    {
        if (!PathFindOnPath(info.cpl, NULL))
        {
            if (!CPL_CheckLegacyMappings(&info))
                goto Error0;
        }
    }
    else if (!PathFileExists(info.cpl))
    {
        if (!CPL_CheckLegacyMappings(&info))
            goto Error0;
    }

    if (!CPL_Identify(&identity, &info, hwndStub))
        goto Error0;

    //
    // If we have already loaded this CPL, then jump to the existing window
    //
    
    hwndOtherStub = FindCPL(hwndStub, &identity);

    //
    // If we found a window and the caller says its ok to find an existing
    // window then set the focus to it
    //
    if (bFindExisting && hwndOtherStub)
    {
        //
        // try to find a CPL window on top of it
        //

        HWND hwndTarget = GetLastActivePopup(hwndOtherStub);

        if (hwndTarget && IsWindow(hwndTarget))
        {

            DebugMsg(DM_WARNING, TEXT("Control_RunDLL: ") TEXT("Switching to already loaded CPL applet"));
            SetForegroundWindow(hwndTarget);
            bResult = TRUE;
            goto Error1;
        }

        //
        // couldn't find it, must be exiting or some sort of error...
        // so ignore it.
        //

        DebugMsg(DM_WARNING, TEXT("Control_RunDLL: ") TEXT("Bogus CPL identity in array; purging after (presumed) RunDLL crash"));
    }

    //
    // stop here if we're not allowed to load the cpl
    //

    if (!bAllowLoad)
        goto Error1;

    //
    // i guess we didn't stop up there
    //

    if (!CPL_LoadAndFindApplet(&pcplm, NULL, &nApplet, &info))
        goto Error1;

    //
    // get the name that the applet thinks it should have
    //

    pcpli = DSA_GetItemPtr(pcplm->hacpli, nApplet);

    lstrcpyn(szApplet, pcpli->pszName, ARRAYSIZE(szApplet));

    CPL_StripAmpersand(szApplet);

    // handle "default applet" cases before running anything
    if (identity.aApplet)
    {
        // we were started with an explicitly named applet
        if (!nApplet)
        {
            // we were started with the name of the default applet
            identity.flags |= PCPLIF_DEFAULT_APPLET;
        }
    }
    else
    {
        // we were started without a name, assume the default applet
        identity.flags |= PCPLIF_DEFAULT_APPLET;

        // get the applet's name (now that we've loaded it's CPL)
        if ((identity.aApplet = GlobalAddAtom(szApplet)) == (ATOM)0)
        {
            // bail 'cause we could nuke a CPL if we don't have this
            goto Error2;
        }
    }

    // mark the window so we'll be able to verify that it's really ours
    if (aCPLName == (ATOM)0)
    {
        aCPLName = GlobalAddAtom(TEXT("CPLName"));
        aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));

        if (aCPLName == (ATOM)0 || aCPLFlags == (ATOM)0)
            goto Error2;        // This should never happen... blow off applet
    }

    if (!SetProp(hwndStub,                 // Mark its name
        MAKEINTATOM(aCPLName), (HANDLE)(DWORD_PTR)identity.aCPL))
    {
        goto Error2;
    }

    if (!SetProp(hwndStub,                 // Mark its applet
        MAKEINTATOM(identity.aCPL), (HANDLE)(DWORD_PTR)identity.aApplet))
    {
        goto Error2;
    }
    if (identity.flags)
    {
        if (aCPLFlags == (ATOM)0)
            aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));
                                            // Mark its flags
        SetProp(hwndStub, MAKEINTATOM(aCPLFlags), (HANDLE)UIntToPtr(identity.flags));
    }

    //
    // Send the stub window a message so it will have the correct title and
    // icon in the alt-tab window, etc...
    //

    if (hwndStub) {
        DWORD dwPID;
        SendMessage(hwndStub, STUBM_SETICONTITLE, (WPARAM)pcpli->hIcon, (LPARAM)szApplet);
        GetWindowThreadProcessId(hwndStub, &dwPID);
        if (dwPID == GetCurrentProcessId()) {
            RUNDLL_NOTIFY sNotify;

            sNotify.hIcon = pcpli->hIcon;
            sNotify.lpszTitle = szApplet;

            // HACK: It will look like the stub window is sending itself
            // a WM_NOTIFY message.  Oh well.
            //
            SendNotify(hwndStub, hwndStub, RDN_TASKINFO, (NMHDR FAR*)&sNotify);
        }
    }

    if (info.params)
    {
        DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_STARTWPARAMS to applet with: %s"), info.params);

        bResult = BOOLFROMPTR(CPL_CallEntry(pcplm, hwndStub, CPL_STARTWPARMS, (LONG)nApplet, (LPARAM)info.params));
    }

    // Check whether we need to run as a different windows version
    {
        PPEB Peb = NtCurrentPeb();
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pcplm->minst.hinst;
        PIMAGE_NT_HEADERS pHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pcplm->minst.hinst + pDosHeader->e_lfanew);

        if (pHeader->FileHeader.SizeOfOptionalHeader != 0 &&
            pHeader->OptionalHeader.Win32VersionValue != 0)
        {
            //
            // Stolen from ntos\mm\procsup.c
            //
            Peb->OSMajorVersion = pHeader->OptionalHeader.Win32VersionValue & 0xFF;
            Peb->OSMinorVersion = (pHeader->OptionalHeader.Win32VersionValue >> 8) & 0xFF;
            Peb->OSBuildNumber  = (USHORT) ((pHeader->OptionalHeader.Win32VersionValue >> 16) & 0x3FFF);
            Peb->OSPlatformId   = (pHeader->OptionalHeader.Win32VersionValue >> 30) ^ 0x2;
        }
    }

#ifdef UNICODE
    //
    // If the cpl didn't respond to CPL_STARTWPARMSW (unicode version),
    // maybe it is an ANSI only CPL
    //
    if (info.params && (!bResult))
    {
        int cchParams = WideCharToMultiByte(CP_ACP, 0, info.params, -1, NULL, 0, NULL, NULL);
        LPSTR lpstrParams = LocalAlloc(LMEM_FIXED, sizeof(char) * cchParams);
        if (lpstrParams != NULL) 
        {
            WideCharToMultiByte(CP_ACP, 0, info.params, -1, lpstrParams, cchParams, NULL, NULL);

            DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_STARTWPARAMSA to applet with: %hs"), lpstrParams);

            bResult = BOOLFROMPTR(CPL_CallEntry(pcplm, hwndStub, CPL_STARTWPARMSA, (LONG)nApplet, (LPARAM)lpstrParams));

            LocalFree(lpstrParams);
        }
    }
#endif

    if (!bResult)
    {
        DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_DBLCLK to applet"));

        CPL_CallEntry(pcplm, hwndStub, CPL_DBLCLK, (LONG)nApplet, pcpli->lData);

        // some 3x applets return the wrong value so we can't fail here
        bResult = TRUE;
    }

    bResult = TRUE; // make it!

    RemoveProp(hwndStub, (LPCTSTR)(UINT_PTR)identity.aCPL);
Error2:
    CPL_FreeCPLModule(pcplm);
Error1:
    CPL_UnIdentify(&identity);
Error0:

    SHCoUninitialize(hrInit);

    return bResult;
}

//
// Check the following reg location and see if this CPL is registered to run in proc:
// HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\InProcCPLs
//
STDAPI_(BOOL) CPL_IsInProc(LPCTSTR pszCmdLine)
{
    BOOL bInProcCPL = FALSE;
    TCHAR szTempCmdLine[2 * MAX_PATH];
    CPLEXECINFO info = {0};
    LPTSTR pszCPLFile = NULL;
    
    ASSERT(pszCmdLine);

    // Make a copy of the command line
    lstrcpyn(szTempCmdLine, pszCmdLine, ARRAYSIZE(szTempCmdLine));

    // Parse the command line using standard parsing function
    CPL_ParseCommandLine(&info, szTempCmdLine, FALSE);

    // Find the file name of this cpl
    pszCPLFile = PathFindFileName(info.cpl);
    if (pszCPLFile)
    {
        // Open the reg key
        HKEY hkeyInProcCPL = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\InProcCPLs"), 0, KEY_READ, &hkeyInProcCPL))
        {
            // Look up in the registry for this cpl name
            LONG cbData;
            if (ERROR_SUCCESS == SHQueryValueEx(hkeyInProcCPL, pszCPLFile, NULL, NULL, NULL, &cbData))
                bInProcCPL = TRUE;

            RegCloseKey(hkeyInProcCPL);
        }
    }
    return bInProcCPL;
}


BOOL UsePCHealthFaultUploading(LPCTSTR pszCmdLine)
{
    // Do we want exceptions to go unhandled so PCHealth will upload the faults?
    BOOL fUsePCHealth = FALSE;      // By default no, because
    LPCTSTR pszFilename = PathFindFileName(pszCmdLine);

    if (pszFilename)
    {
        DWORD dwType;
        DWORD dwFlags;
        DWORD cbSize = sizeof(dwFlags);

        DWORD dwError = SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\Flags"), 
                        pszFilename, &dwType, (void *)&dwFlags, &cbSize);
        if ((ERROR_SUCCESS == dwError) && (REG_DWORD == dwType))
        {
            // The 0x00000001 bit will indicate if they want to not have exceptions caught for them.
            if (0x00000001 & dwFlags)
            {
                fUsePCHealth = TRUE;
            }
        }
    }

    return fUsePCHealth;
}


//
// Starts a remote control applet on a new RunDLL process
// Or on another thread InProcess 
//
STDAPI_(BOOL) CPL_RunRemote(LPCTSTR pszCmdLine, HWND hwnd, BOOL fRunAsNewUser)
{
    BOOL bRet = FALSE;
    TCHAR szRunParams[2 * MAX_PATH];
    BOOL fUsePCHealth = UsePCHealthFaultUploading(pszCmdLine);

    if (fRunAsNewUser)
    {
        wnsprintf(szRunParams, ARRAYSIZE(szRunParams), TEXT("%sshell32.dll,Control_RunDLLAsUser %s"), (fUsePCHealth ? TEXT("/d ") : TEXT("")), pszCmdLine);
    }
    else
    {
        wnsprintf(szRunParams, ARRAYSIZE(szRunParams), TEXT("%sshell32.dll,Control_RunDLL %s"), (fUsePCHealth ? TEXT("/d ") : TEXT("")), pszCmdLine);
    }

    if (!fRunAsNewUser && CPL_IsInProc(pszCmdLine))
    {
        // lanuch this cpl in process from another thread
        bRet = SHRunDLLThread(hwnd, szRunParams, SW_SHOWNORMAL);
    }
    else
    {
        // lanuch this cpl on another thread
        bRet = SHRunDLLProcess(hwnd, szRunParams, SW_SHOWNORMAL, IDS_CONTROLPANEL, fRunAsNewUser);
    }

    return bRet;
}

//
// Attempts to open the specified control applet.
// Tries to switch to an existing instance before starting a new one, unless the user 
// specifies the fRunAsNewUser in which case we always launch a new process.
//
STDAPI_(BOOL) SHRunControlPanelEx(LPCTSTR pszOrigCmdLine, HWND hwnd, BOOL fRunAsNewUser)
{
    BOOL bRes = FALSE;
    LPTSTR pszCmdLine = NULL;

    // check to see if the caller passed a resource id instead of a string

    if (!IS_INTRESOURCE(pszOrigCmdLine))
    {
        pszCmdLine = StrDup(pszOrigCmdLine);
    }
    else
    {
        TCHAR szCmdLine[MAX_PATH];

        if (LoadString(HINST_THISDLL, PtrToUlong((void *)pszOrigCmdLine), szCmdLine, ARRAYSIZE(szCmdLine)))
            pszCmdLine = StrDup(szCmdLine);
    }

    //
    // CPL_RunMeBaby whacks on the command line while parsing...use a dup
    //
    if (pszCmdLine)
    {

        if (!fRunAsNewUser)
        {
            // if fRunAsNewUser is NOT specified, then try to switch to an active CPL 
            // which matches our pszCmdLine
            bRes = CPL_RunMeBaby(NULL, NULL, pszCmdLine, SW_SHOWNORMAL, FALSE, TRUE);
        }

        if (!bRes)
        {
            // launch a new cpl in a separate process
            bRes = CPL_RunRemote(pszCmdLine, hwnd, fRunAsNewUser);
        }
        LocalFree(pszCmdLine);
    }

    if (bRes && UEMIsLoaded() && !IS_INTRESOURCE(pszOrigCmdLine)) 
    {
        UEMFireEvent(&UEMIID_SHELL, UEME_RUNCPL, UEMF_XEVENT, -1, (LPARAM)pszOrigCmdLine);
    }

    return bRes;
}

// This function is a TCHAR export from shell32 (header defn is in shsemip.h)
//
// UNDOCUMENTED: You may pass a shell32 resource ID in place of a pszCmdLine
//
STDAPI_(BOOL) SHRunControlPanel(LPCTSTR pszOrigCmdLine, HWND hwnd)
{
    return SHRunControlPanelEx(pszOrigCmdLine, hwnd, FALSE);
}


//
// Attempts to open the specified control applet.
// This function is intended to be called by RunDLL for isolating applets.
// Tries to switch to an existing instance before starting a new one.
//
// The command lines for Control_RunDLL are as follows:
//
//  1)      rundll32 shell32.dll,Control_RunDLL fred.cpl,@n,arguments
//
//  This launches the (n+1)th applet in fred.cpl.
//
//  If "@n" is not supplied, the default is @0.
//
//  2)      rundll32 shell32.dll,Control_RunDLL fred.cpl,Ba&rney,arguments
//
//  This launches the applet in fred.cpl named "Barney".  Ampersands are
//  stripped from the name.
//
//  3)      rundll32 shell32.dll,Control_RunDLL fred.cpl,Setup
//
//  This loads fred.cpl and sends it a CPL_SETUP message.
//
//  In cases (1) and (2), the "arguments" are passed to the applet via
//  the CPL_STARTWPARAMS (start with parameters) message.  It is the
//  applet's job to parse the arguments and do something interesting.
//
//  It is traditional for the command line of a cpl to be the index of
//  the page that should initially be shown to the user, but that's just
//  tradition.
//

STDAPI_(void) Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH * 2];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));

    CPL_RunMeBaby(hwndStub, hAppInstance, szCmdLine, nCmdShow, TRUE, TRUE);
}

STDAPI_(void) Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH * 2];
    SHUnicodeToTChar(lpwszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));

    CPL_RunMeBaby(hwndStub, hAppInstance, szCmdLine, nCmdShow, TRUE, TRUE);
}

// This is the entry that gets called when we run a cpl as a new user. 
//
STDAPI_(void) Control_RunDLLAsUserW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    CPL_RunMeBaby(hwndStub, hAppInstance, lpwszCmdLine, nCmdShow, TRUE, FALSE);
}

// data passed around dialog and worker thread for Control_FillCache_RunDLL

typedef struct
{
    IShellFolder *  psfControl;
    IEnumIDList *   penumControl;
    HWND            dialog;
} FillCacheData;


//
// important work of Control_FillCache_RunDLL
// jogs the control panel enumerator so it will fill the presentation cache
// also forces the applet icons to be extracted into the shell icon cache
//

DWORD CALLBACK Control_FillCacheThreadProc(void *pv)
{
    FillCacheData *data = (FillCacheData *)pv;
    LPITEMIDLIST pidlApplet;
    ULONG dummy;

    while(data->penumControl->lpVtbl->Next(data->penumControl, 1, &pidlApplet, &dummy) == NOERROR)
    {
        SHMapPIDLToSystemImageListIndex(data->psfControl, pidlApplet, NULL);
        ILFree(pidlApplet);
    }

    if (data->dialog)
        EndDialog(data->dialog, 0);

    return 0;
}


//
// dlgproc for Control_FillCache_RunDLL UI
// just something to keep the user entertained while we load a billion DLLs
//

BOOL_PTR CALLBACK _Control_FillCacheDlg(HWND dialog, UINT message, WPARAM wparam, LPARAM lparam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            DWORD dummy;
            HANDLE thread;
            
            ((FillCacheData *)lparam)->dialog = dialog;
            
            thread = CreateThread(NULL, 0, Control_FillCacheThreadProc, (void*)lparam, 0, &dummy);
            if (thread)
                CloseHandle(thread);
            else
                EndDialog(dialog, -1);
        }
        break;
        
    case WM_COMMAND:
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}


//
// enumerates control applets in a manner that fills the presentation cache
// this is so the first time a user opens the control panel it comes up fast
// intended to be called at final setup on first boot
//
// FUNCTION WORKS FOR BOTH ANSI/UNICODE, it never uses pszCmdLine
//

STDAPI_(void) Control_FillCache_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    IShellFolder *psfDesktop;
    HKEY hk;
    
    // nuke the old data so that any bogus cached info from a beta goes away
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, TEXT("Presentation Cache"));
        RegCloseKey(hk);
    }
    
    SHGetDesktopFolder(&psfDesktop);
    Shell_GetImageLists(NULL, NULL); // make sure icon cache is around
    
    if (psfDesktop)
    {
        LPITEMIDLIST pidlControl = SHCloneSpecialIDList(hwndStub, CSIDL_CONTROLS, FALSE);
        if (pidlControl)
        {
            FillCacheData data = {0};
            
            if (SUCCEEDED(psfDesktop->lpVtbl->BindToObject(psfDesktop,
                pidlControl, NULL, &IID_IShellFolder, &data.psfControl)))
            {
                if (S_OK == data.psfControl->lpVtbl->EnumObjects(
                    data.psfControl, NULL, SHCONTF_NONFOLDERS, &data.penumControl))
                {
                    if (nCmdShow == SW_HIDE || DialogBoxParam(HINST_THISDLL,
                        MAKEINTRESOURCE(DLG_CPL_FILLCACHE), hwndStub,
                        _Control_FillCacheDlg, (LPARAM)&data) == -1)
                    {
                        Control_FillCacheThreadProc(&data);
                    }
                    
                    data.penumControl->lpVtbl->Release(data.penumControl);
                }
                
                data.psfControl->lpVtbl->Release(data.psfControl);
            }
            
            ILFree(pidlControl);
        }
    }
}

STDAPI_(void) Control_FillCache_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    Control_FillCache_RunDLL(hwndStub,hAppInstance,NULL,nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpnamespc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpnamespc.cpp
//
//  This is a rather large module but it's not all that difficult.  The 
//  primary purpose is to provide the 'data' associated with the new
//  'categorized' Control Panel user interface.  Therefore, the visual
//  work is done in cpview.cpp and the data is provided by cpnamespc.cpp.
//  Through the implementation of ICplNamespace, the 'view' object obtains 
//  it's display information.  All of this 'namespace' information is 
//  defined and made accessible through this module.  
//
//  The 'namespace' can be broken down into these concepts:
//
//     1. Links - title, icon & infotip
//     2. Actions
//     3. Restrictions
//
//  Each link has a title, icon, infotip and an associated action.  The
//  action is 'invoked' when the user selects the link in the user interface.
//  Actions may optionally be associated with a 'restriction'.  If a 
//  restriction is enforced (usually based on some system state) the 
//  link associated with the action that is associated with the restriction
//  is not made available to the user interface.  Using this indirection
//  mechanism, any link related to a restricted action is not displayed.
//
//  At first glance one might be concerned with the amount of global data
//  used (and being initialized).  Note however that all of the information 
//  is defined as constant such that it can be resolved at compile and link 
//  time.  Several goals drove the design of this module:
//
//     1. Easy maintenance of Control Panel content.  It must be easy
//        to add/remove/modify links in the UI.
//
//     2. Fast initialization.  Everything is defined as constant data.
//
//     3. Logical separation of links, actions and restrictions
//        to facilitate the one-to-many and many-to-many relationships
//        that might occur in the namespace.
//
//  Following the namespace initialization code, the remainder of the 
//  module implements ICplNamespace to make the data available to the view
//  in a COM-friendly way.
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <cowsite.h>
#include <startids.h>

#include "cpviewp.h"
#include "cpaction.h"
#include "cpguids.h"
#include "cpnamespc.h"
#include "cpuiele.h"
#include "cputil.h"
#include "ids.h"
#include "securent.h"
#include "prop.h"


//
// These icons are currently all the same image.  
// Use separate macro names in the code in case the designers 
// decide to use different icons for one or more.
// 
#define IDI_CPTASK_SEEALSO        IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_TROUBLESHOOTER IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_HELPANDSUPPORT IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_LEARNABOUT     IDI_CPTASK_ASSISTANCE


namespace CPL {


typedef CDpa<UNALIGNED ITEMIDLIST, CDpaDestroyer_ILFree<UNALIGNED ITEMIDLIST> >  CDpaItemIDList;
typedef CDpa<IUICommand, CDpaDestroyer_Release<IUICommand> >  CDpaUiCommand;


//
// WebView info type enumeration.
//
enum eCPWVTYPE
{
    eCPWVTYPE_CPANEL,       // The 'Control Panel' item.
    eCPWVTYPE_SEEALSO,      // The 'See Also' list.
    eCPWVTYPE_TROUBLESHOOT, // The 'Troubleshooters' list.
    eCPWVTYPE_LEARNABOUT,   // The 'Learn About' list.
    eCPWVTYPE_NUMTYPES
};


//
// Define the SCID identifying the control panel category.
//

DEFINE_SCID(SCID_CONTROLPANELCATEGORY, PSGUID_CONTROLPANEL, PID_CONTROLPANEL_CATEGORY);

//-----------------------------------------------------------------------------
// Resource source classes
//
// The purpose of this trivial class is to abstract away the implementation
// of obtaining a resource identifier.  The reason for this comes from needing
// different text resources (i.e. infotips) for different retail SKUs.  
// For example, on Personal SKU, the Users & Passwords applet provides the 
// ability to associate a picture with a user's account.  On Server, it 
// does not.  Therefore, the infotip on Personal can include text about 
// the user's picture while on Server it cannot.  By introducing this level
// of abstraction, we can provide resource information through a resource
// function that can select the appropriate resource at runtime.  Most 
// links will still use fixed resources but with this abstraction, the calling
// code is none the wiser.
//-----------------------------------------------------------------------------

//
// Resource source function must return an LPCWSTR for the resource.
//
typedef LPCWSTR (*PFNRESOURCE)(ICplNamespace *pns);


class IResSrc
{
    public:
        virtual LPCWSTR GetResource(ICplNamespace *pns) const = 0;
};


class CResSrcStatic : public IResSrc
{
    public:
        CResSrcStatic(LPCWSTR pszResource)
            : m_pszResource(pszResource) { }

        LPCWSTR GetResource(ICplNamespace *pns) const
            {   UNREFERENCED_PARAMETER(pns);
                TraceMsg(TF_CPANEL, "CResSrc::GetResource - m_pszResource = 0x%08X", m_pszResource);
                return m_pszResource; }

    private:
        const LPCWSTR m_pszResource;
};


class CResSrcFunc : public IResSrc
{
    public:
        CResSrcFunc(PFNRESOURCE pfnResource)
            : m_pfnResource(pfnResource) { }


        LPCWSTR GetResource(ICplNamespace *pns) const
            {   TraceMsg(TF_CPANEL, "CResSrcFunc::GetResource - m_pfnResource = 0x%08X", m_pfnResource);
                return (*m_pfnResource)(pns); }

    private:
        const PFNRESOURCE m_pfnResource;
};


//
// This resource type represents "no resource".  It simply 
// returns a NULL value when the resource is requested.  Clients
// that call this must be ready to handle this NULL pointer 
// value.  It was originally created to handle the no-tooltip
// behavior of Learn-About links.
//
class CResSrcNone : public IResSrc
{
    public:
        CResSrcNone(void) { }

        LPCWSTR GetResource(ICplNamespace *pns) const
        { UNREFERENCED_PARAMETER(pns);
          return NULL; }
};
           


// ----------------------------------------------------------------------------
// Information describing links.
// ----------------------------------------------------------------------------
//
//
// 'Link' descriptor.
//
struct CPLINK_DESC
{
    const IResSrc *prsrcIcon;     // Icon resource identifier
    const IResSrc *prsrcName;     // The link's title resource ID.
    const IResSrc *prsrcInfotip;  // The link's infotip resource ID.
    const IAction *pAction;       // The link's action when clicked.
};

//
// Set of 'support' links.
//
struct CPLINK_SUPPORT
{
    const CPLINK_DESC  **ppSeeAlsoLinks;      // 'See Also' links for the category.
    const CPLINK_DESC  **ppTroubleshootLinks; // 'Troubleshoot' links for the category.
    const CPLINK_DESC  **ppLearnAboutLinks;   // 'Learn About' links for the category.
};

//
// 'Category' descriptor.  One defined for each category.
//
struct CPCAT_DESC
{
    eCPCAT              idCategory;         // The category's ID.
    LPCWSTR             pszHelpSelection;   // Selection part of HSS help URL.
    const CPLINK_DESC  *pLink;              // The category's display info and action
    const CPLINK_DESC **ppTaskLinks;        // The category's task list.
    CPLINK_SUPPORT      slinks;             // Support links.
};


// ----------------------------------------------------------------------------
// Restrictions
//
// Restrictions are an important part of the control panel display logic.
// Each link element in the UI can be restricted from view based on one or
// more system conditions at the time of display.  To ensure the correct
// logic is used, it is critical to have a method of describing these restrictions
// that is easily readable and verifiable against a specification.  Testing
// all of the possible scenarios is a difficult task, therefore the code must
// be written in a manner conducive to finding errors by inspection as well.
// This means, keep it simple.  Each link action object can be optionally associated 
// with a 'restriction' object.  Restriction objects implement CPL::IRestrict.
// The most common restriction object CRestrictFunc simply calls a function
// provided to the object's constructor.  The function is called when the
// restriction status (restricted/allowed) is desired.  There is also 
// class CRestrictApplet for tasks who's presence is directly linked to 
// the presence/restriction of a particular CPL applet based on policy alone.
//
// Since there may be many task links on a given Control Panel page that
// means there will be multiple restriction expressions evaluated each 
// time the page is displayed.  Often the expressions across a set of 
// actions are evaluating many of the same terms.  Some of these terms require
// registry lookups.  To help performance, a simple caching mechanism 
// has been introduced into the 'namespace' object.  Each restriction function
// is passed a pointer to the current 'namespace' object.  As the namespace
// object remains alive the entire time the page is being constructed, it
// is an appropriate place to cache frequently used data.  You'll see
// many instances below where the namespace object is queried for restriction
// data.  The members of the namespace object associated with this restriction
// data are of type CTriState.  This simple class implements the concept of 
// an 'uninitialized boolean' value, allowing the code to determine if a given
// boolean member has yet to be initialized with a valid boolean value.  If
// the namespace is asked for the value of one of these tri-state booleans
// and that member has not yet been initialized, the namespace calls the 
// appropriate system functions and initializes the boolean value.  From that
// time forward, the member's value is returned immediately.  This ensures that
// for any given restriction term, we do the expensive stuff only once.
// Being an on-demand mechanism, we also gather only the information that is 
// needed.
//
// [brianau - 03/18/01]
//


HRESULT Restrict32CtrlPanel(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
#if defined(WX86) || !defined(_WIN64)
    hr = S_OK; // restricted.
#endif
    return hr;
}


HRESULT RestrictAlways(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    return S_OK;  // Always restricted.
}

HRESULT RestrictDisplayCpl(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl())
    {
        hr = S_OK;
    }
    return hr;
}    

HRESULT RestrictThemes(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() || 
        SHRestricted(REST_NOTHEMESTAB) ||
        SHRestricted(REST_NODISPLAYAPPEARANCEPAGE))
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictWallpaper(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        SHRestricted(REST_NOCHANGINGWALLPAPER) ||
        !pns->AllowDeskCplTab_Background())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictScreenSaver(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        !pns->AllowDeskCplTab_Screensaver())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictResolution(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        !pns->AllowDeskCplTab_Settings())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}
    

HRESULT RestrictAddPrinter(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    if (SHRestricted(REST_NOPRINTERADD) ||
        !IsAppletEnabled(NULL, MAKEINTRESOURCEW(IDS_PRNANDFAXFOLDER)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictRemoteDesktop(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() ||     // Admins only.
         pns->IsPersonal() ||      // Not available on personal.
        !IsAppletEnabled(L"sysdm.cpl", MAKEINTRESOURCEW(IDS_CPL_SYSTEM)))   // Respect sysdm.cpl policy.
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictHomeNetwork(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;

    if (!pns->IsX86() ||           // x86 only.
         pns->IsOnDomain() ||      // Not available on domains.
         pns->IsServer() ||        // Not available on server.
        !pns->IsUserAdmin() ||     // Admins only.
        !IsAppletEnabled(L"hnetwiz.dll", NULL)) // Respect hnetwiz.dll policy.
    {
        hr = S_OK; // restricted.
    }
    return hr;
}
                

HRESULT RestrictTsNetworking(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on personal and professional only.
    //
    if (!(pns->IsPersonal() || pns->IsProfessional()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsInetExplorer(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on personal and professional only.
    //
    if (!(pns->IsPersonal() || pns->IsProfessional()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsModem(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on server only.
    //
    if (!pns->IsServer())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsSharing(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on server only.
    //
    if (!pns->IsServer())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


bool ShellKeyExists(SHELLKEY skey, LPCWSTR pszRegName)
{
    TCHAR szValue[MAX_PATH];

    DWORD cbValue = sizeof(szValue);
    return SUCCEEDED(SKGetValue(skey, 
                                pszRegName, 
                                NULL, 
                                NULL, 
                                szValue, 
                                &cbValue));
}    


HRESULT RestrictBackupData(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'backuppath' shell key is missing.
    //    This logic is the same as that used by the "Tools" page
    //    in a volume property sheet.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\BackupPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictDefrag(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'defragpath' shell key is missing.
    //    This logic is the same as that used by the "Tools" page
    //    in a volume property sheet.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\DefragPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictCleanUpDisk(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'cleanuppath' shell key is missing.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\CleanupPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictSystemRestore(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available only on x86.
    //
    if (!pns->IsX86() ||
        pns->IsServer() ||
        CPL::IsSystemRestoreRestricted())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictPersonalUserManager(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager())
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictServerUserManager(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
         pns->UsePersonalUserManager())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictFolderOptions(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    if (SHRestricted(REST_NOFOLDEROPTIONS) ||
        !IsAppletEnabled(NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_FOLDEROPTIONS)))
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictIfNoAppletsInCplCategory(ICplNamespace *pns, eCPCAT eCategory)
{
    int cCplApplets = 0;
    HRESULT hr = THR(CplNamespace_GetCategoryAppletCount(pns, eCategory, &cCplApplets));
    if (SUCCEEDED(hr))
    {
        if (0 == cCplApplets)
        {
            hr = S_OK; // 0 applets means we don't show the link.
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

//
// If there are no CPL applets categorized under "Other",
// we hide the "Other CPL Options" link in the UI.
//
HRESULT RestrictOtherCplOptions(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!CPL::CategoryViewIsActive() ||
        S_OK == RestrictIfNoAppletsInCplCategory(pns, eCPCAT_OTHER))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictWindowsUpdate(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    //
    // First check the shell's restriction for the "Windows Update"
    // item in the start menu.  If the admin doesn't want access from
    // the start menu, they most likely don't want it from Control Panel either.
    //
    if (SHRestricted(REST_NOUPDATEWINDOWS))
    {
        hr = S_OK;
    }
    if (S_FALSE == hr)
    {
        //
        // Not restricted in start menu.
        // How about the global "Disable Windows Update" policy?
        //
        DWORD dwType;
        DWORD dwData;
        DWORD cbData = sizeof(dwData);
        
        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER,
                                         L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate",
                                         L"DisableWindowsUpdateAccess",
                                         &dwType,
                                         &dwData,
                                         &cbData))
        {
            if (REG_DWORD == dwType && 1 == dwData)
            {
                hr = S_OK; // restricted.
            }
        }
    }
    return hr;
}


HRESULT RestrictAddLanguage(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() || !IsAppletEnabled(L"intl.cpl", MAKEINTRESOURCEW(IDS_CPL_REGIONALOPTIONS)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}

//
// Don't show any of the tasks on the "User Accounts" category page if
// our default user accounts manager applet (nusrmgr.cpl) is disabled by
// policy.
//
HRESULT RestrictAccountsCategoryTasks(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsCreate(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsCreate2(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
         pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsChange(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsPicture(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutAccounts(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictLearnAboutAccountTypes(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || 
        !pns->UsePersonalUserManager() ||
        !IsUserAdmin())               // topic is for non-admins only.
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutChangeName(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserLimited() || pns->IsUserGuest()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutCreateAccount(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserLimited() || pns->IsUserGuest()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutFUS(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictHardwareWizard(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() ||
        !IsAppletEnabled(L"hdwwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDHARDWARE)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}

HRESULT RestrictVpnConnections(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictArp(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    //
    // Why we don't check SHRestricted(REST_ARP_NOARP)?
    //
    // 1. We don't hide category links for any reason.
    // 2. If that policy is enabled and appwiz.cpl is allowed,
    //    (remember, those are different policies)
    //    we'll display the ARP category page and it will still
    //    show the ARP applet icon.  Since there is at least one
    //    task link or icon, we don't display the "content disabled
    //    by your admin" barricade.  Then the user will click on the
    //    applet icon and get ARP's "I've been disabled" messagebox.
    // 
    // By not checking this policy, clicking on the category link
    // will invoke ARP and ARP will display it's message.
    // I think this is a better user experience.
    //
    if (!IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}


//
// The ARP category (and it's tasks) are displayed only when there
// are 2+ applets registered for that category (ARP and one or more
// other applets).  Unlike RestrictArp() above, we DO want to consider
// SHRestricted(REST_ARP_NOARP).  This way if ARP is restricted in 
// ANY way, it's related tasks will not appear.  
//
HRESULT RestrictArpAddProgram(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    if (SHRestricted(REST_ARP_NOARP) ||
        SHRestricted(REST_ARP_NOADDPAGE) ||
        !IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}

HRESULT RestrictArpRemoveProgram(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    if (SHRestricted(REST_ARP_NOARP) ||
        SHRestricted(REST_ARP_NOREMOVEPAGE) ||
        !IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}



//-----------------------------------------------------------------------------
// Restriction objects (alphabetical order please)
//-----------------------------------------------------------------------------
//
// To restrict an action, create a restriction object and associate it with the
// action in the Action object declarations below.
//
const CRestrictFunc   g_Restrict32CtrlPanel      (Restrict32CtrlPanel);
const CRestrictApplet g_RestrictAccessibility    (L"access.cpl", MAKEINTRESOURCEW(IDS_CPL_ACCESSIBILITYOPTIONS));
const CRestrictApplet g_RestrictAccessWizard     (L"accwiz.exe", NULL);
const CRestrictFunc   g_RestrictAccountsCreate   (RestrictAccountsCreate);
const CRestrictFunc   g_RestrictAccountsCreate2  (RestrictAccountsCreate2);
const CRestrictFunc   g_RestrictAccountsChange   (RestrictAccountsChange);
const CRestrictFunc   g_RestrictAccountsPicture  (RestrictAccountsPicture);
const CRestrictFunc   g_RestrictAccountsServer   (RestrictServerUserManager);
const CRestrictFunc   g_RestrictAddLanguage      (RestrictAddLanguage);
const CRestrictFunc   g_RestrictAddPrinter       (RestrictAddPrinter);
const CRestrictApplet g_RestrictAdminTools       (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_ADMIN_TOOLS));
const CRestrictFunc   g_RestrictAlways           (RestrictAlways);
const CRestrictFunc   g_RestrictArp              (RestrictArp);
const CRestrictFunc   g_RestrictArpAddProgram    (RestrictArpAddProgram);
const CRestrictFunc   g_RestrictArpRemoveProgram (RestrictArpRemoveProgram);
const CRestrictFunc   g_RestrictBackupData       (RestrictBackupData);
const CRestrictFunc   g_RestrictCleanUpDisk      (RestrictCleanUpDisk);
const CRestrictApplet g_RestrictDateTime         (L"timedate.cpl", MAKEINTRESOURCEW(IDS_CPL_DATETIME));
const CRestrictFunc   g_RestrictDefrag           (RestrictDefrag);
const CRestrictFunc   g_RestrictDisplayCpl       (RestrictDisplayCpl);
const CRestrictFunc   g_RestrictFolderOptions    (RestrictFolderOptions);
const CRestrictApplet g_RestrictFontsFolder      (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_FONTS));
const CRestrictFunc   g_RestrictHomeNetwork      (RestrictHomeNetwork);
const CRestrictFunc   g_RestrictHardwareWizard   (RestrictHardwareWizard);
const CRestrictApplet g_RestrictInternational    (L"intl.cpl", MAKEINTRESOURCEW(IDS_CPL_REGIONALOPTIONS));
const CRestrictFunc   g_RestrictLearnAboutAccounts     (RestrictLearnAboutAccounts);
const CRestrictFunc   g_RestrictLearnAboutAccountTypes (RestrictLearnAboutAccountTypes);
const CRestrictFunc   g_RestrictLearnAboutChangeName   (RestrictLearnAboutChangeName);
const CRestrictFunc   g_RestrictLearnAboutCreateAccount(RestrictLearnAboutCreateAccount);
const CRestrictFunc   g_RestrictLearnAboutFUS          (RestrictLearnAboutFUS);
const CRestrictApplet g_RestrictMousePointers    (L"main.cpl", MAKEINTRESOURCEW(IDS_CPL_MOUSE));
const CRestrictApplet g_RestrictNetConnections   (L"inetcpl.cpl", MAKEINTRESOURCEW(IDS_CPL_INTERNETOPTIONS));
const CRestrictFunc   g_RestrictOtherCplOptions  (RestrictOtherCplOptions);
const CRestrictApplet g_RestrictPhoneModemCpl    (L"telephon.cpl", MAKEINTRESOURCEW(IDS_CPL_PHONEANDMODEMOPTIONS));
const CRestrictApplet g_RestrictPowerOptions     (L"powercfg.cpl", MAKEINTRESOURCEW(IDS_CPL_POWEROPTIONS));
const CRestrictApplet g_RestrictPrinters         (NULL, MAKEINTRESOURCEW(IDS_PRNANDFAXFOLDER));
const CRestrictFunc   g_RestrictRemoteDesktop    (RestrictRemoteDesktop);
const CRestrictFunc   g_RestrictResolution       (RestrictResolution);
const CRestrictApplet g_RestrictScannersCameras  (NULL, MAKEINTRESOURCEW(IDS_CPL_SCANNERSANDCAMERAS));
const CRestrictFunc   g_RestrictScreenSaver      (RestrictScreenSaver);
const CRestrictApplet g_RestrictScheduledTasks   (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_LNK_SCHEDULED_TASKS));
const CRestrictApplet g_RestrictSounds           (L"mmsys.cpl", MAKEINTRESOURCEW(IDS_CPL_SOUNDSANDAUDIO));
const CRestrictApplet g_RestrictSystemCpl        (L"sysdm.cpl", MAKEINTRESOURCEW(IDS_CPL_SYSTEM));
const CRestrictFunc   g_RestrictSystemRestore    (RestrictSystemRestore);
const CRestrictApplet g_RestrictTaskbarProps     (NULL, MAKEINTRESOURCEW(IDS_CP_TASKBARANDSTARTMENU));
const CRestrictFunc   g_RestrictThemes           (RestrictThemes);
const CRestrictFunc   g_RestrictTsModem          (RestrictTsModem);
const CRestrictFunc   g_RestrictTsInetExplorer   (RestrictTsInetExplorer);
const CRestrictFunc   g_RestrictTsNetworking     (RestrictTsNetworking);
const CRestrictFunc   g_RestrictTsSharing        (RestrictTsSharing);
const CRestrictApplet g_RestrictUserManager      (L"nusrmgr.cpl", MAKEINTRESOURCEW(IDS_CPL_USERACCOUNTS));
const CRestrictFunc   g_RestrictVpnConnections   (RestrictVpnConnections);
const CRestrictFunc   g_RestrictWallpaper        (RestrictWallpaper);
const CRestrictFunc   g_RestrictWindowsUpdate    (RestrictWindowsUpdate);


//-----------------------------------------------------------------------------
// Resource functions
//-----------------------------------------------------------------------------

//
// The tooltip for the accounts manager varies based upon the capabilities
// of the application used.  On Personal we provide the ability to associate
// a user's picture with their account.  The tooltip mentions this.  On server
// this capability is not present.  Therefore, the tooltip must not mention
// this.
//
LPCWSTR GetCatAccountsInfotip(ICplNamespace *pns)
{
    if (pns->AllowUserManager() && pns->UsePersonalUserManager())
    {
        return MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_INFOTIP);
    }
    else
    {
        //
        // Personal user manager is restricted.  Display the 
        // infotip without the term "picture".
        //
        return MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_INFOTIP2);
    }
}


LPCWSTR GetAccountsInfotip(ICplNamespace *pns)
{
    if (pns->AllowUserManager() && pns->UsePersonalUserManager()) 
    {
        return MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP);
    }
    else
    {
        //
        // Personal user manager is restricted.  Display the 
        // infotip without the term "picture".
        //
        return MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP2);
    }
}


LPCWSTR GetTsNetworkTitle(ICplNamespace *pns)
{
    if ((pns->IsPersonal() || pns->IsProfessional()) && !pns->IsOnDomain())
    {
        return MAKEINTRESOURCE(IDS_CPTASK_TSHOMENETWORKING_TITLE);
    }
    else
    {
        return MAKEINTRESOURCE(IDS_CPTASK_TSNETWORK_TITLE);
    }
}


//-----------------------------------------------------------------------------
// Action objects (alphabetical order please)
//-----------------------------------------------------------------------------
//
// Each object represents some action taken when a link in Control Panel is 
// selected.  Actions are associated with links in the g_Link_XXXX declarations below.
//
//
// NTRAID#NTBUG9-277853-2001/1/18-brianau   Action disabled
//
//  The "utility manager" task has been removed from the Control Panel UI.
//  I'm leaving the code in place in case the accessibility folks change their
//  minds.  If by RC1 they haven't, remove this as well as the associated
//  text resources from shell32.rc
//
const CShellExecute       g_LinkAction_32CtrlPanel       (L"%SystemRoot%\\SysWOW64\\explorer.exe", L"/N,/SEPARATE,\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\"", &g_Restrict32CtrlPanel);
//const CShellExecute       g_LinkAction_AccessUtilityMgr  (L"utilman.exe", L"/start");
const CShellExecute       g_LinkAction_AccessWizard      (L"%SystemRoot%\\System32\\accwiz.exe", NULL, &g_RestrictAccessWizard);
const COpenUserMgrApplet  g_LinkAction_Accounts          (&g_RestrictUserManager);
const COpenCplApplet      g_LinkAction_AccountsChange    (L"nusrmgr.cpl ,initialTask=ChangeAccount", &g_RestrictAccountsChange);
const COpenCplApplet      g_LinkAction_AccountsCreate    (L"nusrmgr.cpl ,initialTask=CreateAccount", &g_RestrictAccountsCreate);
const COpenCplApplet      g_LinkAction_AccountsCreate2   (L"nusrmgr.cpl", &g_RestrictAccountsCreate2);
const COpenCplApplet      g_LinkAction_AccountsPict      (L"nusrmgr.cpl ,initialTask=ChangePicture", &g_RestrictAccountsPicture);
const CAddPrinter         g_LinkAction_AddPrinter        (&g_RestrictAddPrinter);
const COpenCplApplet      g_LinkAction_AddProgram        (L"appwiz.cpl ,1", &g_RestrictArpAddProgram);
const COpenCplApplet      g_LinkAction_Arp               (L"appwiz.cpl", &g_RestrictArp);
const COpenCplApplet      g_LinkAction_AutoUpdate        (L"sysdm.cpl ,@wuaueng.dll,10000", &g_RestrictSystemCpl);
const CExecDiskUtil       g_LinkAction_BackupData        (eDISKUTIL_BACKUP, &g_RestrictBackupData);
const COpenCplCategory    g_LinkAction_CatAccessibility  (eCPCAT_ACCESSIBILITY);
const COpenCplCategory2   g_LinkAction_CatAccounts       (eCPCAT_ACCOUNTS, &g_LinkAction_Accounts);
const COpenCplCategory    g_LinkAction_CatAppearance     (eCPCAT_APPEARANCE);
const COpenCplCategory2   g_LinkAction_CatArp            (eCPCAT_ARP, &g_LinkAction_Arp);
const COpenCplCategory    g_LinkAction_CatHardware       (eCPCAT_HARDWARE);
const COpenCplCategory    g_LinkAction_CatNetwork        (eCPCAT_NETWORK);
const COpenCplCategory    g_LinkAction_CatOther          (eCPCAT_OTHER, &g_RestrictAlways);
const COpenCplCategory    g_LinkAction_CatPerfMaint      (eCPCAT_PERFMAINT);
const COpenCplCategory    g_LinkAction_CatRegional       (eCPCAT_REGIONAL);
const COpenCplCategory    g_LinkAction_CatSound          (eCPCAT_SOUND);
const CExecDiskUtil       g_LinkAction_CleanUpDisk       (eDISKUTIL_CLEANUP, &g_RestrictCleanUpDisk);
const COpenCplApplet      g_LinkAction_DateTime          (L"timedate.cpl", &g_RestrictDateTime);
const CExecDiskUtil       g_LinkAction_Defrag            (eDISKUTIL_DEFRAG, &g_RestrictDefrag);
const COpenCplApplet      g_LinkAction_DisplayCpl        (L"desk.cpl", &g_RestrictDisplayCpl);
const COpenDeskCpl        g_LinkAction_DisplayRes        (CPLTAB_DESK_SETTINGS, &g_RestrictResolution);
const COpenCplApplet      g_LinkAction_DisplayTheme      (L"desk.cpl", &g_RestrictThemes);
const CRunDll32           g_LinkAction_FolderOptions     (L"shell32.dll,Options_RunDLL 0", &g_RestrictFolderOptions);
const CNavigateURL        g_LinkAction_FontsFolder       (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524152}", &g_RestrictFontsFolder);
const COpenCplApplet      g_LinkAction_HardwareWizard    (L"hdwwiz.cpl", &g_RestrictHardwareWizard);
const CTrayCommand        g_LinkAction_HelpAndSupport    (IDM_HELPSEARCH);
const COpenCplApplet      g_LinkAction_HighContrast      (L"access.cpl ,3", &g_RestrictAccessibility);
const CRunDll32           g_LinkAction_HomeNetWizard     (L"hnetwiz.dll,HomeNetWizardRunDll", &g_RestrictHomeNetwork);
const CShellExecute       g_LinkAction_Magnifier         (L"%SystemRoot%\\System32\\magnify.exe");
const COpenCplApplet      g_LinkAction_Language          (L"intl.cpl ,1", &g_RestrictAddLanguage);
const CNavigateURL        g_LinkAction_LearnAccounts            (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpWindowsAccounts.htm", &g_RestrictLearnAboutAccounts);
const CNavigateURL        g_LinkAction_LearnAccountsTypes       (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpAccountTypes.htm", &g_RestrictLearnAboutAccountTypes);
const CNavigateURL        g_LinkAction_LearnAccountsChangeName  (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpChangeNonAdmin.htm", &g_RestrictLearnAboutChangeName);
const CNavigateURL        g_LinkAction_LearnAccountsCreate      (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpCreateAccount.htm", &g_RestrictLearnAboutCreateAccount);
const CNavigateURL        g_LinkAction_LearnSwitchUsers         (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpFUS.htm", &g_RestrictLearnAboutFUS);
const COpenCplApplet      g_LinkAction_MousePointers     (L"main.cpl ,2", &g_RestrictMousePointers);
const CNavigateURL        g_LinkAction_MyComputer        (L"shell:DriveFolder");
const CNavigateURL        g_LinkAction_MyNetPlaces       (L"shell:::{208D2C60-3AEA-1069-A2D7-08002B30309D}");
const COpenCplApplet      g_LinkAction_NetConnections    (L"inetcpl.cpl ,4", &g_RestrictNetConnections);
const CActionNYI          g_LinkAction_NotYetImpl        (L"Under construction");
const CShellExecute       g_LinkAction_OnScreenKbd       (L"%SystemRoot%\\System32\\osk.exe");
const COpenCplCategory    g_LinkAction_OtherCplOptions   (eCPCAT_OTHER, &g_RestrictOtherCplOptions);
const COpenCplApplet      g_LinkAction_PhoneModemCpl     (L"telephon.cpl", &g_RestrictPhoneModemCpl);
const COpenCplApplet      g_LinkAction_PowerCpl          (L"powercfg.cpl", &g_RestrictPowerOptions);
const COpenCplApplet      g_LinkAction_Region            (L"intl.cpl", &g_RestrictInternational);
const COpenCplApplet      g_LinkAction_RemoteDesktop     (L"sysdm.cpl ,@remotepg.dll,10000", &g_RestrictRemoteDesktop);
const COpenCplApplet      g_LinkAction_RemoveProgram     (L"appwiz.cpl ,0", &g_RestrictArpRemoveProgram);
const CNavigateURL        g_LinkAction_ScheduledTasks    (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D6277990-4C6A-11CF-8D87-00AA0060F5BF}", &g_RestrictScheduledTasks);
const COpenDeskCpl        g_LinkAction_ScreenSaver       (CPLTAB_DESK_SCREENSAVER, &g_RestrictScreenSaver);
const COpenCplApplet      g_LinkAction_SoundAccessibility(L"access.cpl ,2", &g_RestrictAccessibility);
const COpenCplCategory    g_LinkAction_Sounds            (eCPCAT_SOUND);
const COpenCplApplet      g_LinkAction_SoundSchemes      (L"mmsys.cpl ,1", &g_RestrictSounds);
const COpenCplApplet      g_LinkAction_SoundVolume       (L"mmsys.cpl ,0", &g_RestrictSounds);
const CShellExecute       g_LinkAction_SoundVolumeAdv    (L"%SystemRoot%\\System32\\sndvol32.exe", NULL, &g_RestrictSounds);
const COpenCplView        g_LinkAction_SwToClassicView   (eCPVIEWTYPE_CLASSIC);
const COpenCplView        g_LinkAction_SwToCategoryView  (eCPVIEWTYPE_CATEGORY);
const COpenCplApplet      g_LinkAction_SystemCpl         (L"sysdm.cpl ,@sysdm.cpl,10000", &g_RestrictSystemCpl);
const CShellExecute       g_LinkAction_SystemRestore     (L"%SystemRoot%\\system32\\restore\\rstrui.exe", NULL, &g_RestrictSystemRestore);
const COpenTroubleshooter g_LinkAction_TsDisplay         (L"tsdisp.htm");
const COpenTroubleshooter g_LinkAction_TsDvd             (L"ts_dvd.htm");
const COpenTroubleshooter g_LinkAction_TsHardware        (L"tshardw.htm");
const COpenTroubleshooter g_LinkAction_TsInetExplorer    (L"tsie.htm", &g_RestrictTsInetExplorer);
const COpenTroubleshooter g_LinkAction_TsModem           (L"tsmodem.htm", &g_RestrictTsModem);
const COpenTroubleshooter g_LinkAction_TsNetwork         (L"tshomenet.htm", &g_RestrictTsNetworking);
const CNavigateURL        g_LinkAction_TsNetDiags        (L"hcp://system/netdiag/dglogs.htm");
const COpenTroubleshooter g_LinkAction_TsPrinting        (L"tsprint.htm");
const COpenTroubleshooter g_LinkAction_TsSharing         (L"tssharing.htm", &g_RestrictTsSharing);
const COpenTroubleshooter g_LinkAction_TsStartup         (L"tsstartup.htm");
const COpenTroubleshooter g_LinkAction_TsSound           (L"tssound.htm");
const CNavigateURL        g_LinkAction_ViewPrinters      (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}", &g_RestrictPrinters);
const COpenCplApplet      g_LinkAction_VisualPerf        (L"sysdm.cpl ,-1", &g_RestrictSystemCpl);
const CRunDll32           g_LinkAction_VpnConnections    (L"netshell.dll,StartNCW 21010", &g_RestrictVpnConnections);
const COpenDeskCpl        g_LinkAction_Wallpaper         (CPLTAB_DESK_BACKGROUND, &g_RestrictWallpaper);
const CNavigateURL        g_LinkAction_WindowsUpdate     (L"http://www.microsoft.com/isapi/redir.dll?prd=Win2000&ar=WinUpdate", &g_RestrictWindowsUpdate);


//-----------------------------------------------------------------------------
// Link object initialization data (alphabetical order please)
//-----------------------------------------------------------------------------
//
// Each g_Link_XXXX variable represents a link in the Control Panel namespace.
// Note that if a particular link is displayed in multiple places in the Control Panel,
// only one instance of a g_Link_XXXX variable is required.
//
// The 'S' and 'T' in g_SLink and g_TLink mean "Support" and "Task" respectively.
// I've used the generic term "support" to refer to items that appear in one
// of the webview lists in the left-hand pane.
// We may have a link in a support list and in a category task list that essentially
// do the same thing but they have different icons and titles.  The 'S' and 'T'
// help differentiate.
//

const CResSrcStatic g_SLinkRes_32CtrlPanel_Icon(MAKEINTRESOURCEW(IDI_CPTASK_32CPLS));
const CResSrcStatic g_SLinkRes_32CtrlPanel_Title(MAKEINTRESOURCEW(IDS_CPTASK_32CPLS_TITLE));
const CResSrcStatic g_SLinkRes_32CtrlPanel_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_32CPLS_INFOTIP));
const CPLINK_DESC g_SLink_32CtrlPanel = {
    &g_SLinkRes_32CtrlPanel_Icon,
    &g_SLinkRes_32CtrlPanel_Title,
    &g_SLinkRes_32CtrlPanel_Infotip,
    &g_LinkAction_32CtrlPanel
    };

//
// NTRAID#NTBUG9-277853-2001/1/18-brianau   Action disabled
//
//  The "utility manager" task has been removed from the Control Panel UI.
//  I'm leaving the code in place in case the accessibility folks change their
//  minds.  If by RC1 they haven't, remove this as well as the associated
//  text resources from shell32.rc
//
#ifdef NEVER
const CResSrcStatic g_SLinkRes_AccessUtilityMgr_Icon(MAKEINTRESOURCEW(IDI_CPTASK_ACCESSUTILITYMGR));
const CResSrcStatic g_SLinkRes_AccessUtilityMgr_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSUTILITYMGR_TITLE));
const CResSrcStatic g_SLinkRes_AccessUtilityMgr_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSUTILITYMGR_INFOTIP));
const CPLINK_DESC g_SLink_AccessUtilityMgr = {
    &g_SLinkRes_AccessUtilityMgr_Icon,
    &g_SLinkRes_AccessUtilityMgr_Title,
    &g_SLinkRes_AccessUtilityMgr_Infotip,
    &g_LinkAction_AccessUtilityMgr
    };
#endif

const CResSrcStatic g_TLinkRes_AccessWizard_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccessWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSWIZARD_TITLE));
const CResSrcStatic g_TLinkRes_AccessWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSWIZARD_INFOTIP));
const CPLINK_DESC g_TLink_AccessWizard = {
    &g_TLinkRes_AccessWizard_Icon,
    &g_TLinkRes_AccessWizard_Title,
    &g_TLinkRes_AccessWizard_Infotip,
    &g_LinkAction_AccessWizard
    };   

const CResSrcStatic g_TLinkRes_AccountsChange_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsChange_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_TITLE));
const CResSrcFunc   g_TLinkRes_AccountsChange_Infotip(GetAccountsInfotip);
const CPLINK_DESC g_TLink_AccountsChange = {
    &g_TLinkRes_AccountsChange_Icon,
    &g_TLinkRes_AccountsChange_Title,
    &g_TLinkRes_AccountsChange_Infotip,
    &g_LinkAction_AccountsChange
    };

const CResSrcStatic g_TLinkRes_AccountsCreate_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsCreate_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSCREATE_TITLE));
const CResSrcStatic g_TLinkRes_AccountsCreate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSCREATE_INFOTIP));
const CPLINK_DESC g_TLink_AccountsCreate = {
    &g_TLinkRes_AccountsCreate_Icon,
    &g_TLinkRes_AccountsCreate_Title,
    &g_TLinkRes_AccountsCreate_Infotip,
    &g_LinkAction_AccountsCreate
    };

//
// This link uses the same visual information as g_TLink_AccountsCreate above.
// The difference is in the action performed on selection.
//
const CPLINK_DESC g_TLink_AccountsCreate2 = {
    &g_TLinkRes_AccountsCreate_Icon,
    &g_TLinkRes_AccountsCreate_Title,
    &g_TLinkRes_AccountsCreate_Infotip,
    &g_LinkAction_AccountsCreate2
    };

const CResSrcStatic g_SLinkRes_AccountsPict_Icon(L"nusrmgr.cpl,-205");
const CResSrcStatic g_SLinkRes_AccountsPict_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT_TITLE));
const CResSrcStatic g_SLinkRes_AccountsPict_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT_INFOTIP));
const CPLINK_DESC g_SLink_AccountsPict = {
    &g_SLinkRes_AccountsPict_Icon,
    &g_SLinkRes_AccountsPict_Title,
    &g_SLinkRes_AccountsPict_Infotip,
    &g_LinkAction_AccountsPict
    };

const CResSrcStatic g_TLinkRes_AccountsPict_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsPict_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT2_TITLE));
const CResSrcStatic g_TLinkRes_AccountsPict_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT2_INFOTIP));
const CPLINK_DESC g_TLink_AccountsPict = {
    &g_TLinkRes_AccountsPict_Icon,
    &g_TLinkRes_AccountsPict_Title,
    &g_TLinkRes_AccountsPict_Infotip,
    &g_LinkAction_AccountsPict
    };

const CResSrcStatic g_TLinkRes_Accounts_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Accounts_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_TITLE));
const CResSrcFunc   g_TLinkRes_Accounts_Infotip(GetAccountsInfotip);
const CPLINK_DESC g_TLink_Accounts = {
    &g_TLinkRes_Accounts_Icon,
    &g_TLinkRes_Accounts_Title,
    &g_TLinkRes_Accounts_Infotip,
    &g_LinkAction_Accounts
    };

const CResSrcStatic g_TLinkRes_AddPrinter_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AddPrinter_Title(MAKEINTRESOURCEW(IDS_CPTASK_ADDPRINTER_TITLE));
const CResSrcStatic g_TLinkRes_AddPrinter_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ADDPRINTER_INFOTIP));
const CPLINK_DESC g_TLink_AddPrinter = {
    &g_TLinkRes_AddPrinter_Icon,
    &g_TLinkRes_AddPrinter_Title,
    &g_TLinkRes_AddPrinter_Infotip,
    &g_LinkAction_AddPrinter
    };

const CResSrcStatic g_TLinkRes_AddProgram_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AddProgram_Title(MAKEINTRESOURCEW(IDS_CPTASK_ADDPROGRAM_TITLE));
const CResSrcStatic g_TLinkRes_AddProgram_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ADDPROGRAM_INFOTIP));
const CPLINK_DESC g_TLink_AddProgram = {
    &g_TLinkRes_AddProgram_Icon,
    &g_TLinkRes_AddProgram_Title,
    &g_TLinkRes_AddProgram_Infotip,
    &g_LinkAction_AddProgram
    };

//
// Note that the "Auto Updates" icon is the same as the "Windows Update" icon.
// This is the way the Windows Update folks want it.
//
const CResSrcStatic g_SLinkRes_AutoUpdate_Icon(MAKEINTRESOURCEW(IDI_WINUPDATE));
const CResSrcStatic g_SLinkRes_AutoUpdate_Title(MAKEINTRESOURCEW(IDS_CPTASK_AUTOUPDATE_TITLE));
const CResSrcStatic g_SLinkRes_AutoUpdate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_AUTOUPDATE_INFOTIP));
const CPLINK_DESC g_SLink_AutoUpdate = {
    &g_SLinkRes_AutoUpdate_Icon,
    &g_SLinkRes_AutoUpdate_Title,
    &g_SLinkRes_AutoUpdate_Infotip,
    &g_LinkAction_AutoUpdate
    };

const CResSrcStatic g_TLinkRes_BackupData_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_BackupData_Title(MAKEINTRESOURCEW(IDS_CPTASK_BACKUPDATA_TITLE));
const CResSrcStatic g_TLinkRes_BackupData_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_BACKUPDATA_INFOTIP));
const CPLINK_DESC g_TLink_BackupData = {
    &g_TLinkRes_BackupData_Icon,
    &g_TLinkRes_BackupData_Title,
    &g_TLinkRes_BackupData_Infotip,
    &g_LinkAction_BackupData
    };

const CResSrcStatic g_TLinkRes_CatAccessibility_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ACCESSIBILITY));
const CResSrcStatic g_TLinkRes_CatAccessibility_Title(MAKEINTRESOURCEW(IDS_CPCAT_ACCESSIBILITY_TITLE));
const CResSrcStatic g_TLinkRes_CatAccessibility_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_ACCESSIBILITY_INFOTIP));
const CPLINK_DESC g_TLink_CatAccessibility = { 
    &g_TLinkRes_CatAccessibility_Icon,
    &g_TLinkRes_CatAccessibility_Title,
    &g_TLinkRes_CatAccessibility_Infotip,
    &g_LinkAction_CatAccessibility
    };

const CResSrcStatic g_TLinkRes_CatAccounts_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ACCOUNTS));
const CResSrcStatic g_TLinkRes_CatAccounts_Title(MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_TITLE));
const CResSrcFunc   g_TLinkRes_CatAccounts_Infotip(GetCatAccountsInfotip);
const CPLINK_DESC g_TLink_CatAccounts = {
    &g_TLinkRes_CatAccounts_Icon,
    &g_TLinkRes_CatAccounts_Title,
    &g_TLinkRes_CatAccounts_Infotip,
    &g_LinkAction_CatAccounts
    };

const CResSrcStatic g_TLinkRes_CatAppearance_Icon(MAKEINTRESOURCEW(IDI_CPCAT_APPEARANCE));
const CResSrcStatic g_TLinkRes_CatAppearance_Title(MAKEINTRESOURCEW(IDS_CPCAT_APPEARANCE_TITLE));
const CResSrcStatic g_TLinkRes_CatAppearance_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_APPEARANCE_INFOTIP));
const CPLINK_DESC g_TLink_CatAppearance = {
    &g_TLinkRes_CatAppearance_Icon,
    &g_TLinkRes_CatAppearance_Title,
    &g_TLinkRes_CatAppearance_Infotip,
    &g_LinkAction_CatAppearance
    };

const CResSrcStatic g_TLinkRes_CatArp_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ARP));
const CResSrcStatic g_TLinkRes_CatArp_Title(MAKEINTRESOURCEW(IDS_CPCAT_ARP_TITLE));
const CResSrcStatic g_TLinkRes_CatArp_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_ARP_INFOTIP));
const CPLINK_DESC g_TLink_CatArp = {
    &g_TLinkRes_CatArp_Icon,
    &g_TLinkRes_CatArp_Title,
    &g_TLinkRes_CatArp_Infotip,
    &g_LinkAction_CatArp
    };

const CResSrcStatic g_TLinkRes_CatHardware_Icon(MAKEINTRESOURCEW(IDI_CPCAT_HARDWARE));
const CResSrcStatic g_TLinkRes_CatHardware_Title(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_TITLE));
const CResSrcStatic g_TLinkRes_CatHardware_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_INFOTIP));
const CPLINK_DESC g_TLink_CatHardware = {
    &g_TLinkRes_CatHardware_Icon,
    &g_TLinkRes_CatHardware_Title,
    &g_TLinkRes_CatHardware_Infotip,
    &g_LinkAction_CatHardware
    };

const CResSrcStatic g_TLinkRes_CatNetwork_Icon(MAKEINTRESOURCEW(IDI_CPCAT_NETWORK));
const CResSrcStatic g_TLinkRes_CatNetwork_Title(MAKEINTRESOURCEW(IDS_CPCAT_NETWORK_TITLE));
const CResSrcStatic g_TLinkRes_CatNetwork_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_NETWORK_INFOTIP));
const CPLINK_DESC g_TLink_CatNetwork = {
    &g_TLinkRes_CatNetwork_Icon,
    &g_TLinkRes_CatNetwork_Title,
    &g_TLinkRes_CatNetwork_Infotip,
    &g_LinkAction_CatNetwork
    };

const CResSrcStatic g_TLinkRes_CatOther_Icon(MAKEINTRESOURCEW(IDI_CPCAT_OTHERCPLS));
const CResSrcStatic g_TLinkRes_CatOther_Title(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_TITLE));
const CResSrcStatic g_TLinkRes_CatOther_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_INFOTIP));
const CPLINK_DESC g_TLink_CatOther = {
    &g_TLinkRes_CatOther_Icon,
    &g_TLinkRes_CatOther_Title,
    &g_TLinkRes_CatOther_Infotip,
    &g_LinkAction_CatOther
    };

const CResSrcStatic g_TLinkRes_CatPerfMaint_Icon(MAKEINTRESOURCEW(IDI_CPCAT_PERFMAINT));
const CResSrcStatic g_TLinkRes_CatPerfMaint_Title(MAKEINTRESOURCEW(IDS_CPCAT_PERFMAINT_TITLE));
const CResSrcStatic g_TLinkRes_CatPerfMaint_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_PERFMAINT_INFOTIP));
const CPLINK_DESC g_TLink_CatPerfMaint = {
    &g_TLinkRes_CatPerfMaint_Icon,
    &g_TLinkRes_CatPerfMaint_Title,
    &g_TLinkRes_CatPerfMaint_Infotip,
    &g_LinkAction_CatPerfMaint
    };

const CResSrcStatic g_TLinkRes_CatRegional_Icon(MAKEINTRESOURCEW(IDI_CPCAT_REGIONAL));
const CResSrcStatic g_TLinkRes_CatRegional_Title(MAKEINTRESOURCEW(IDS_CPCAT_REGIONAL_TITLE));
const CResSrcStatic g_TLinkRes_CatRegional_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_REGIONAL_INFOTIP));
const CPLINK_DESC g_TLink_CatRegional = {
    &g_TLinkRes_CatRegional_Icon,
    &g_TLinkRes_CatRegional_Title,
    &g_TLinkRes_CatRegional_Infotip,
    &g_LinkAction_CatRegional
    };

const CResSrcStatic g_TLinkRes_CatSound_Icon(MAKEINTRESOURCEW(IDI_CPCAT_SOUNDS));
const CResSrcStatic g_TLinkRes_CatSound_Title(MAKEINTRESOURCEW(IDS_CPCAT_SOUNDS_TITLE));
const CResSrcStatic g_TLinkRes_CatSound_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_SOUNDS_INFOTIP));
const CPLINK_DESC g_TLink_CatSound = {
    &g_TLinkRes_CatSound_Icon,
    &g_TLinkRes_CatSound_Title,
    &g_TLinkRes_CatSound_Infotip,
    &g_LinkAction_CatSound
    };

const CResSrcStatic g_TLinkRes_CleanUpDisk_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_CleanUpDisk_Title(MAKEINTRESOURCEW(IDS_CPTASK_CLEANUPDISK_TITLE));
const CResSrcStatic g_TLinkRes_CleanUpDisk_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_CLEANUPDISK_INFOTIP));
const CPLINK_DESC g_TLink_CleanUpDisk = {
    &g_TLinkRes_CleanUpDisk_Icon,
    &g_TLinkRes_CleanUpDisk_Title,
    &g_TLinkRes_CleanUpDisk_Infotip,
    &g_LinkAction_CleanUpDisk
    };

const CResSrcStatic g_TLinkRes_DateTime_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DateTime_Title(MAKEINTRESOURCEW(IDS_CPTASK_DATETIME_TITLE));
const CResSrcStatic g_TLinkRes_DateTime_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DATETIME_INFOTIP));
const CPLINK_DESC g_TLink_DateTime = {
    &g_TLinkRes_DateTime_Icon,
    &g_TLinkRes_DateTime_Title,
    &g_TLinkRes_DateTime_Infotip,
    &g_LinkAction_DateTime
    };

const CResSrcStatic g_TLinkRes_Defrag_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Defrag_Title(MAKEINTRESOURCEW(IDS_CPTASK_DEFRAG_TITLE));
const CResSrcStatic g_TLinkRes_Defrag_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DEFRAG_INFOTIP));
const CPLINK_DESC g_TLink_Defrag = {
    &g_TLinkRes_Defrag_Icon,
    &g_TLinkRes_Defrag_Title,
    &g_TLinkRes_Defrag_Infotip,
    &g_LinkAction_Defrag
    };

const CResSrcStatic g_SLinkRes_DisplayCpl_Icon(L"desk.cpl,0");
const CResSrcStatic g_SLinkRes_DisplayCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_DISPLAYCPL_TITLE));
const CResSrcStatic g_SLinkRes_DisplayCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DISPLAYCPL_INFOTIP));
const CPLINK_DESC g_SLink_DisplayCpl = {
    &g_SLinkRes_DisplayCpl_Icon,
    &g_SLinkRes_DisplayCpl_Title,
    &g_SLinkRes_DisplayCpl_Infotip,
    &g_LinkAction_DisplayCpl
    };

const CResSrcStatic g_TLinkRes_DisplayRes_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DisplayRes_Title(MAKEINTRESOURCEW(IDS_CPTASK_RESOLUTION_TITLE));
const CResSrcStatic g_TLinkRes_DisplayRes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_RESOLUTION_INFOTIP));
const CPLINK_DESC g_TLink_DisplayRes = {
    &g_TLinkRes_DisplayRes_Icon,
    &g_TLinkRes_DisplayRes_Title,
    &g_TLinkRes_DisplayRes_Infotip,
    &g_LinkAction_DisplayRes
    };

const CResSrcStatic g_TLinkRes_DisplayTheme_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DisplayTheme_Title(MAKEINTRESOURCEW(IDS_CPTASK_THEME_TITLE));
const CResSrcStatic g_TLinkRes_DisplayTheme_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_THEME_INFOTIP));
const CPLINK_DESC g_TLink_DisplayTheme = {
    &g_TLinkRes_DisplayTheme_Icon,
    &g_TLinkRes_DisplayTheme_Title,
    &g_TLinkRes_DisplayTheme_Infotip,
    &g_LinkAction_DisplayTheme
    };

const CResSrcStatic g_SLinkRes_FileTypes_Icon(MAKEINTRESOURCEW(IDI_FOLDEROPTIONS));
const CResSrcStatic g_SLinkRes_FileTypes_Title(MAKEINTRESOURCEW(IDS_CPTASK_FILETYPES_TITLE));
const CResSrcStatic g_SLinkRes_FileTypes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FILETYPES_INFOTIP));
const CPLINK_DESC g_SLink_FileTypes = {
    &g_SLinkRes_FileTypes_Icon,
    &g_SLinkRes_FileTypes_Title,
    &g_SLinkRes_FileTypes_Infotip,
    &g_LinkAction_FolderOptions
    };

const CResSrcStatic g_TLinkRes_FolderOptions_Icon(MAKEINTRESOURCEW(IDI_FOLDEROPTIONS));
const CResSrcStatic g_TLinkRes_FolderOptions_Title(MAKEINTRESOURCEW(IDS_CPTASK_FOLDEROPTIONS_TITLE));
const CResSrcStatic g_TLinkRes_FolderOptions_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FOLDEROPTIONS_INFOTIP));
const CPLINK_DESC g_SLink_FolderOptions = {
    &g_TLinkRes_FolderOptions_Icon,
    &g_TLinkRes_FolderOptions_Title,
    &g_TLinkRes_FolderOptions_Infotip,
    &g_LinkAction_FolderOptions
    };

const CResSrcStatic g_SLinkRes_FontsFolder_Icon(MAKEINTRESOURCEW(IDI_STFONTS));
const CResSrcStatic g_SLinkRes_FontsFolder_Title(MAKEINTRESOURCEW(IDS_CPTASK_FONTS_TITLE));
const CResSrcStatic g_SLinkRes_FontsFolder_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FONTS_INFOTIP));
const CPLINK_DESC g_SLink_FontsFolder = {
    &g_SLinkRes_FontsFolder_Icon,
    &g_SLinkRes_FontsFolder_Title,
    &g_SLinkRes_FontsFolder_Infotip,
    &g_LinkAction_FontsFolder
    };

const CResSrcStatic g_SLinkRes_Hardware_Icon(MAKEINTRESOURCEW(IDI_CPCAT_HARDWARE));
const CResSrcStatic g_SLinkRes_Hardware_Title(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_TITLE));
const CResSrcStatic g_SLinkRes_Hardware_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_INFOTIP));
const CPLINK_DESC g_SLink_Hardware = {
    &g_SLinkRes_Hardware_Icon,
    &g_SLinkRes_Hardware_Title,
    &g_SLinkRes_Hardware_Infotip,
    &g_LinkAction_CatHardware
    };

const CResSrcStatic g_SLinkRes_HardwareWizard_Icon(L"hdwwiz.cpl,0");
const CResSrcStatic g_SLinkRes_HardwareWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_HARDWAREWIZ_TITLE));
const CResSrcStatic g_SLinkRes_HardwareWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HARDWAREWIZ_INFOTIP));
const CPLINK_DESC g_SLink_HardwareWizard = {
    &g_SLinkRes_HardwareWizard_Icon,
    &g_SLinkRes_HardwareWizard_Title,
    &g_SLinkRes_HardwareWizard_Infotip,
    &g_LinkAction_HardwareWizard
    };

const CResSrcStatic g_SLinkRes_HelpAndSupport_Icon(MAKEINTRESOURCEW(IDI_STHELP));
const CResSrcStatic g_SLinkRes_HelpAndSupport_Title(MAKEINTRESOURCEW(IDS_CPTASK_HELPANDSUPPORT_TITLE));
const CResSrcStatic g_SLinkRes_HelpAndSupport_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HELPANDSUPPORT_INFOTIP));
const CPLINK_DESC g_SLink_HelpAndSupport = {
    &g_SLinkRes_HelpAndSupport_Icon,
    &g_SLinkRes_HelpAndSupport_Title,
    &g_SLinkRes_HelpAndSupport_Infotip,
    &g_LinkAction_HelpAndSupport
    };

const CResSrcStatic g_SLinkRes_HighContrast_Icon(MAKEINTRESOURCEW(IDI_CPTASK_HIGHCONTRAST));
const CResSrcStatic g_SLinkRes_HighContrast_Title(MAKEINTRESOURCEW(IDS_CPTASK_HIGHCONTRAST_TITLE));
const CResSrcStatic g_SLinkRes_HighContrast_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HIGHCONTRAST_INFOTIP));
const CPLINK_DESC g_SLink_HighContrast = {
    &g_SLinkRes_HighContrast_Icon,
    &g_SLinkRes_HighContrast_Title,
    &g_SLinkRes_HighContrast_Infotip,
    &g_LinkAction_HighContrast
    };

const CResSrcStatic g_TLinkRes_HighContrast_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_HighContrast_Title(MAKEINTRESOURCEW(IDS_CPTASK_TURNONHIGHCONTRAST_TITLE));
const CResSrcStatic g_TLinkRes_HighContrast_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TURNONHIGHCONTRAST_INFOTIP));
const CPLINK_DESC g_TLink_HighContrast = {
    &g_TLinkRes_HighContrast_Icon,
    &g_TLinkRes_HighContrast_Title,
    &g_TLinkRes_HighContrast_Infotip,
    &g_LinkAction_HighContrast
    };

const CResSrcStatic g_TLinkRes_HomeNetWizard_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_HomeNetWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_HOMENETWORK_TITLE));
const CResSrcStatic g_TLinkRes_HomeNetWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HOMENETWORK_INFOTIP));
const CPLINK_DESC g_TLink_HomeNetWizard = {
    &g_TLinkRes_HomeNetWizard_Icon,
    &g_TLinkRes_HomeNetWizard_Title,
    &g_TLinkRes_HomeNetWizard_Infotip,
    &g_LinkAction_HomeNetWizard
    };

const CResSrcStatic g_TLinkRes_Language_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Language_Title(MAKEINTRESOURCEW(IDS_CPTASK_LANGUAGE_TITLE));
const CResSrcStatic g_TLinkRes_Language_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_LANGUAGE_INFOTIP));
const CPLINK_DESC g_TLink_Language = {
    &g_TLinkRes_Language_Icon,
    &g_TLinkRes_Language_Title,
    &g_TLinkRes_Language_Infotip,
    &g_LinkAction_Language
    };

//
// Learn-about topics use a standard icon and have no infotip.
//
const CResSrcStatic g_SLinkRes_LearnAbout_Icon(MAKEINTRESOURCE(IDI_CPTASK_LEARNABOUT));
const CResSrcNone g_SLinkRes_LearnAbout_Infotip;

const CResSrcStatic g_SLinkRes_LearnAccounts_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTS_TITLE));
const CPLINK_DESC g_SLink_LearnAccounts = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccounts_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccounts
    };

const CResSrcStatic g_SLinkRes_LearnAccountsTypes_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSTYPES_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsTypes = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsTypes_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsTypes
    };

const CResSrcStatic g_SLinkRes_LearnAccountsChangeName_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSCHANGENAME_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsChangeName = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsChangeName_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsChangeName
    };

const CResSrcStatic g_SLinkRes_LearnAccountsCreate_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSCREATE_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsCreate = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsCreate_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsCreate
    };

const CResSrcStatic g_SLinkRes_LearnSwitchUsers_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNSWITCHUSERS_TITLE));
const CPLINK_DESC g_SLink_LearnSwitchUsers = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnSwitchUsers_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnSwitchUsers
    };

const CResSrcStatic g_SLinkRes_Magnifier_Icon(MAKEINTRESOURCEW(IDI_CPTASK_MAGNIFIER));
const CResSrcStatic g_SLinkRes_Magnifier_Title(MAKEINTRESOURCEW(IDS_CPTASK_MAGNIFIER_TITLE));
const CResSrcStatic g_SLinkRes_Magnifier_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MAGNIFIER_INFOTIP));
const CPLINK_DESC g_SLink_Magnifier = {
    &g_SLinkRes_Magnifier_Icon,
    &g_SLinkRes_Magnifier_Title,
    &g_SLinkRes_Magnifier_Infotip,
    &g_LinkAction_Magnifier
    };

const CResSrcStatic g_SLinkRes_MousePointers_Icon(L"main.cpl,0");
const CResSrcStatic g_SLinkRes_MousePointers_Title(MAKEINTRESOURCEW(IDS_CPTASK_MOUSEPOINTERS_TITLE));
const CResSrcStatic g_SLinkRes_MousePointers_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MOUSEPOINTERS_INFOTIP));
const CPLINK_DESC g_SLink_MousePointers = {
    &g_SLinkRes_MousePointers_Icon,
    &g_SLinkRes_MousePointers_Title,
    &g_SLinkRes_MousePointers_Infotip,
    &g_LinkAction_MousePointers
    };

const CResSrcStatic g_SLinkRes_MyComputer_Icon(L"explorer.exe,0");
const CResSrcStatic g_SLinkRes_MyComputer_Title(MAKEINTRESOURCEW(IDS_CPTASK_MYCOMPUTER_TITLE));
const CResSrcStatic g_SLinkRes_MyComputer_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MYCOMPUTER_INFOTIP));
const CPLINK_DESC g_SLink_MyComputer = {
    &g_SLinkRes_MyComputer_Icon,
    &g_SLinkRes_MyComputer_Title,
    &g_SLinkRes_MyComputer_Infotip,
    &g_LinkAction_MyComputer
    };

const CResSrcStatic g_SLinkRes_MyNetPlaces_Icon(MAKEINTRESOURCEW(IDI_NETCONNECT));
const CResSrcStatic g_SLinkRes_MyNetPlaces_Title(MAKEINTRESOURCEW(IDS_CPTASK_MYNETPLACES_TITLE));
const CResSrcStatic g_SLinkRes_MyNetPlaces_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MYNETPLACES_INFOTIP));
const CPLINK_DESC g_SLink_MyNetPlaces = {
    &g_SLinkRes_MyNetPlaces_Icon,
    &g_SLinkRes_MyNetPlaces_Title,
    &g_SLinkRes_MyNetPlaces_Infotip,
    &g_LinkAction_MyNetPlaces
    };

const CResSrcStatic g_TLinkRes_NetConnections_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_NetConnections_Title(MAKEINTRESOURCEW(IDS_CPTASK_NETCONNECTION_TITLE));
const CResSrcStatic g_TLinkRes_NetConnections_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_NETCONNECTION_INFOTIP));
const CPLINK_DESC g_TLink_NetConnections = {
    &g_TLinkRes_NetConnections_Icon,
    &g_TLinkRes_NetConnections_Title,
    &g_TLinkRes_NetConnections_Infotip,
    &g_LinkAction_NetConnections
    };

const CResSrcStatic g_SLinkRes_OnScreenKbd_Icon(MAKEINTRESOURCEW(IDI_CPTASK_ONSCREENKBD));
const CResSrcStatic g_SLinkRes_OnScreenKbd_Title(MAKEINTRESOURCEW(IDS_CPTASK_ONSCREENKBD_TITLE));
const CResSrcStatic g_SLinkRes_OnScreenKbd_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ONSCREENKBD_INFOTIP));
const CPLINK_DESC g_SLink_OnScreenKbd = {
    &g_SLinkRes_OnScreenKbd_Icon,
    &g_SLinkRes_OnScreenKbd_Title,
    &g_SLinkRes_OnScreenKbd_Infotip,
    &g_LinkAction_OnScreenKbd
    };

const CResSrcStatic g_SLinkRes_OtherCplOptions_Icon(MAKEINTRESOURCEW(IDI_CPCAT_OTHERCPLS));
const CResSrcStatic g_SLinkRes_OtherCplOptions_Title(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_TITLE));
const CResSrcStatic g_SLinkRes_OtherCplOptions_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_INFOTIP));
const CPLINK_DESC g_SLink_OtherCplOptions = {
    &g_SLinkRes_OtherCplOptions_Icon,
    &g_SLinkRes_OtherCplOptions_Title,
    &g_SLinkRes_OtherCplOptions_Infotip,
    &g_LinkAction_OtherCplOptions
    };

const CResSrcStatic g_SLinkRes_PhoneModemCpl_Icon(L"telephon.cpl,0");
const CResSrcStatic g_SLinkRes_PhoneModemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_PHONEMODEMCPL_TITLE));
const CResSrcStatic g_SLinkRes_PhoneModemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_PHONEMODEMCPL_INFOTIP));
const CPLINK_DESC g_SLink_PhoneModemCpl = {
    &g_SLinkRes_PhoneModemCpl_Icon,
    &g_SLinkRes_PhoneModemCpl_Title,
    &g_SLinkRes_PhoneModemCpl_Infotip,
    &g_LinkAction_PhoneModemCpl
    };

const CResSrcStatic g_SLinkRes_PowerCpl_Icon(L"powercfg.cpl,-202");
const CResSrcStatic g_SLinkRes_PowerCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_POWERCPL_TITLE));
const CResSrcStatic g_SLinkRes_PowerCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_POWERCPL_INFOTIP));
const CPLINK_DESC g_SLink_PowerCpl = {
    &g_SLinkRes_PowerCpl_Icon,
    &g_SLinkRes_PowerCpl_Title,
    &g_SLinkRes_PowerCpl_Infotip,
    &g_LinkAction_PowerCpl
    };

const CResSrcStatic g_TLinkRes_Region_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Region_Title(MAKEINTRESOURCEW(IDS_CPTASK_CHANGEREGION_TITLE));
const CResSrcStatic g_TLinkRes_Region_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_CHANGEREGION_INFOTIP));
const CPLINK_DESC g_TLink_Region = {
    &g_TLinkRes_Region_Icon,
    &g_TLinkRes_Region_Title,
    &g_TLinkRes_Region_Infotip,
    &g_LinkAction_Region
    };

const CResSrcStatic g_SLinkRes_RemoteDesktop_Icon(L"remotepg.dll,0");
const CResSrcStatic g_SLinkRes_RemoteDesktop_Title(MAKEINTRESOURCEW(IDS_CPTASK_REMOTEDESKTOP_TITLE));
const CResSrcStatic g_SLinkRes_RemoteDesktop_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_REMOTEDESKTOP_INFOTIP));
const CPLINK_DESC g_SLink_RemoteDesktop = {
    &g_SLinkRes_RemoteDesktop_Icon,
    &g_SLinkRes_RemoteDesktop_Title,
    &g_SLinkRes_RemoteDesktop_Infotip,
    &g_LinkAction_RemoteDesktop
    };

const CResSrcStatic g_TLinkRes_RemoveProgram_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_RemoveProgram_Title(MAKEINTRESOURCEW(IDS_CPTASK_REMOVEPROGRAM_TITLE));
const CResSrcStatic g_TLinkRes_RemoveProgram_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_REMOVEPROGRAM_INFOTIP));
const CPLINK_DESC g_TLink_RemoveProgram = {
    &g_TLinkRes_RemoveProgram_Icon,
    &g_TLinkRes_RemoveProgram_Title,
    &g_TLinkRes_RemoveProgram_Infotip,
    &g_LinkAction_RemoveProgram
    };

const CResSrcStatic g_TLinkRes_ScreenSaver_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_ScreenSaver_Title(MAKEINTRESOURCE(IDS_CPTASK_SCREENSAVER_TITLE));
const CResSrcStatic g_TLinkRes_ScreenSaver_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SCREENSAVER_INFOTIP));
const CPLINK_DESC g_TLink_ScreenSaver = {
    &g_TLinkRes_ScreenSaver_Icon,
    &g_TLinkRes_ScreenSaver_Title,
    &g_TLinkRes_ScreenSaver_Infotip,
    &g_LinkAction_ScreenSaver
    };

const CResSrcStatic g_SLinkRes_ScheduledTasks_Icon(L"mstask.dll,-100");
const CResSrcStatic g_SLinkRes_ScheduledTasks_Title(MAKEINTRESOURCEW(IDS_CPTASK_SCHEDULEDTASKS_TITLE));
const CResSrcStatic g_SLinkRes_ScheduledTasks_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SCHEDULEDTASKS_INFOTIP));
const CPLINK_DESC g_SLink_ScheduledTasks = {
    &g_SLinkRes_ScheduledTasks_Icon,
    &g_SLinkRes_ScheduledTasks_Title,
    &g_SLinkRes_ScheduledTasks_Infotip,
    &g_LinkAction_ScheduledTasks
    };

const CResSrcStatic g_SLinkRes_Sounds_Icon(L"mmsys.cpl,0");
const CResSrcStatic g_SLinkRes_Sounds_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCPL_TITLE));
const CResSrcStatic g_SLinkRes_Sounds_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCPL_INFOTIP));
const CPLINK_DESC g_SLink_Sounds = {
    &g_SLinkRes_Sounds_Icon,
    &g_SLinkRes_Sounds_Title,
    &g_SLinkRes_Sounds_Infotip,
    &g_LinkAction_Sounds
    };

const CResSrcStatic g_SLinkRes_SoundAccessibility_Icon(L"mmsys.cpl,0");
const CResSrcStatic g_SLinkRes_SoundAccessibility_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDACCESSIBILITY_TITLE));
const CResSrcStatic g_SLinkRes_SoundAccessibility_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDACCESSIBILITY_INFOTIP));
const CPLINK_DESC g_SLink_SoundAccessibility = {
    &g_SLinkRes_SoundAccessibility_Icon,
    &g_SLinkRes_SoundAccessibility_Title,
    &g_SLinkRes_SoundAccessibility_Infotip,
    &g_LinkAction_SoundAccessibility
    };

const CResSrcStatic g_TLinkRes_SoundSchemes_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SoundSchemes_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCHEMES_TITLE));
const CResSrcStatic g_TLinkRes_SoundSchemes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCHEMES_INFOTIP));
const CPLINK_DESC g_TLink_SoundSchemes = {
    &g_TLinkRes_SoundSchemes_Icon,
    &g_TLinkRes_SoundSchemes_Title,
    &g_TLinkRes_SoundSchemes_Infotip,
    &g_LinkAction_SoundSchemes
    };

const CResSrcStatic g_TLinkRes_SoundVolume_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SoundVolume_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUME_TITLE));
const CResSrcStatic g_TLinkRes_SoundVolume_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUME_INFOTIP));
const CPLINK_DESC g_TLink_SoundVolume = {
    &g_TLinkRes_SoundVolume_Icon,
    &g_TLinkRes_SoundVolume_Title,
    &g_TLinkRes_SoundVolume_Infotip,
    &g_LinkAction_SoundVolume
    };

const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Icon(L"sndvol32.exe,-300");
const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUMEADV_TITLE));
const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUMEADV_INFOTIP));
const CPLINK_DESC g_SLink_SoundVolumeAdv = {
    &g_SLinkRes_SoundVolumeAdv_Icon,
    &g_SLinkRes_SoundVolumeAdv_Title,
    &g_SLinkRes_SoundVolumeAdv_Infotip,
    &g_LinkAction_SoundVolumeAdv
    };

const CResSrcStatic g_TLinkRes_SpeakerSettings_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SpeakerSettings_Title(MAKEINTRESOURCEW(IDS_CPTASK_SPEAKERSETTINGS_TITLE));
const CResSrcStatic g_TLinkRes_SpeakerSettings_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SPEAKERSETTINGS_INFOTIP));
const CPLINK_DESC g_TLink_SpeakerSettings = {
    &g_TLinkRes_SpeakerSettings_Icon,
    &g_TLinkRes_SpeakerSettings_Title,
    &g_TLinkRes_SpeakerSettings_Infotip,
    &g_LinkAction_SoundVolume
    };

const CResSrcStatic g_SLinkRes_SystemCpl_Icon(L"sysdm.cpl,0");
const CResSrcStatic g_SLinkRes_SystemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_TITLE));
const CResSrcStatic g_SLinkRes_SystemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_INFOTIP));
const CPLINK_DESC g_SLink_SystemCpl = {
    &g_SLinkRes_SystemCpl_Icon,
    &g_SLinkRes_SystemCpl_Title,
    &g_SLinkRes_SystemCpl_Infotip,
    &g_LinkAction_SystemCpl
    };

const CResSrcStatic g_TLinkRes_SystemCpl_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SystemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_TITLE2));
const CResSrcStatic g_TLinkRes_SystemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_INFOTIP2));
const CPLINK_DESC g_TLink_SystemCpl = {
    &g_TLinkRes_SystemCpl_Icon,
    &g_TLinkRes_SystemCpl_Title,
    &g_TLinkRes_SystemCpl_Infotip,
    &g_LinkAction_SystemCpl
    };

const CResSrcStatic g_SLinkRes_SystemRestore_Icon(L"%systemroot%\\system32\\restore\\rstrui.exe,0");
const CResSrcStatic g_SLinkRes_SystemRestore_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMRESTORE_TITLE));
const CResSrcStatic g_SLinkRes_SystemRestore_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMRESTORE_INFOTIP));
const CPLINK_DESC g_SLink_SystemRestore = {
    &g_SLinkRes_SystemRestore_Icon,
    &g_SLinkRes_SystemRestore_Title,
    &g_SLinkRes_SystemRestore_Infotip,
    &g_LinkAction_SystemRestore
    };

const CResSrcStatic g_SLinkRes_SwToCategoryView_Icon(MAKEINTRESOURCEW(IDI_CPLFLD));
const CResSrcStatic g_SLinkRes_SwToCategoryView_Title(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCATEGORYVIEW_TITLE));
const CResSrcStatic g_SLinkRes_SwToCategoryView_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCATEGORYVIEW_INFOTIP));
const CPLINK_DESC g_SLink_SwToCategoryView = {
    &g_SLinkRes_SwToCategoryView_Icon,
    &g_SLinkRes_SwToCategoryView_Title,
    &g_SLinkRes_SwToCategoryView_Infotip,
    &g_LinkAction_SwToCategoryView
    };

const CResSrcStatic g_SLinkRes_SwToClassicView_Icon(MAKEINTRESOURCEW(IDI_CPLFLD));
const CResSrcStatic g_SLinkRes_SwToClassicView_Title(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCLASSICVIEW_TITLE));
const CResSrcStatic g_SLinkRes_SwToClassicView_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCLASSICVIEW_INFOTIP));
const CPLINK_DESC g_SLink_SwToClassicView = {
    &g_SLinkRes_SwToClassicView_Icon,
    &g_SLinkRes_SwToClassicView_Title,
    &g_SLinkRes_SwToClassicView_Infotip,
    &g_LinkAction_SwToClassicView
    };

const CResSrcStatic g_SLinkRes_TsDisplay_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsDisplay_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSDISPLAY_TITLE));
const CResSrcStatic g_SLinkRes_TsDisplay_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSDISPLAY_INFOTIP));
const CPLINK_DESC g_SLink_TsDisplay = {
    &g_SLinkRes_TsDisplay_Icon,
    &g_SLinkRes_TsDisplay_Title,
    &g_SLinkRes_TsDisplay_Infotip,
    &g_LinkAction_TsDisplay
    };

const CResSrcStatic g_SLinkRes_TsDvd_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsDvd_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSDVD_TITLE));
const CResSrcStatic g_SLinkRes_TsDvd_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSDVD_INFOTIP));
const CPLINK_DESC g_SLink_TsDvd = {
    &g_SLinkRes_TsDvd_Icon,
    &g_SLinkRes_TsDvd_Title,
    &g_SLinkRes_TsDvd_Infotip,
    &g_LinkAction_TsDvd
    };

const CResSrcStatic g_SLinkRes_TsHardware_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsHardware_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSHARDWARE_TITLE));
const CResSrcStatic g_SLinkRes_TsHardware_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSHARDWARE_INFOTIP));
const CPLINK_DESC g_SLink_TsHardware = {
    &g_SLinkRes_TsHardware_Icon,
    &g_SLinkRes_TsHardware_Title,
    &g_SLinkRes_TsHardware_Infotip,
    &g_LinkAction_TsHardware
    };

const CResSrcStatic g_SLinkRes_TsInetExplorer_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsInetExplorer_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSINETEXPLORER_TITLE));
const CResSrcStatic g_SLinkRes_TsInetExplorer_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSINETEXPLORER_INFOTIP));
const CPLINK_DESC g_SLink_TsInetExplorer = {
    &g_SLinkRes_TsInetExplorer_Icon,
    &g_SLinkRes_TsInetExplorer_Title,
    &g_SLinkRes_TsInetExplorer_Infotip,
    &g_LinkAction_TsInetExplorer
    };

const CResSrcStatic g_SLinkRes_TsModem_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsModem_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSMODEM_TITLE));
const CResSrcStatic g_SLinkRes_TsModem_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSMODEM_INFOTIP));
const CPLINK_DESC g_SLink_TsModem = {
    &g_SLinkRes_TsModem_Icon,
    &g_SLinkRes_TsModem_Title,
    &g_SLinkRes_TsModem_Infotip,
    &g_LinkAction_TsModem
    };

const CResSrcStatic g_SLinkRes_TsNetDiags_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsNetDiags_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSNETDIAGS_TITLE));
const CResSrcStatic g_SLinkRes_TsNetDiags_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSNETDIAGS_INFOTIP));
const CPLINK_DESC g_SLink_TsNetDiags = {
    &g_SLinkRes_TsNetDiags_Icon,
    &g_SLinkRes_TsNetDiags_Title,
    &g_SLinkRes_TsNetDiags_Infotip,
    &g_LinkAction_TsNetDiags
    };

const CResSrcStatic g_SLinkRes_TsNetwork_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcFunc   g_SLinkRes_TsNetwork_Title(GetTsNetworkTitle);
const CResSrcStatic g_SLinkRes_TsNetwork_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSNETWORK_INFOTIP));
const CPLINK_DESC g_SLink_TsNetwork = {
    &g_SLinkRes_TsNetwork_Icon,
    &g_SLinkRes_TsNetwork_Title,
    &g_SLinkRes_TsNetwork_Infotip,
    &g_LinkAction_TsNetwork
    };

const CResSrcStatic g_SLinkRes_TsPrinting_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsPrinting_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSPRINTING_TITLE));
const CResSrcStatic g_SLinkRes_TsPrinting_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSPRINTING_INFOTIP));
const CPLINK_DESC g_SLink_TsPrinting = {
    &g_SLinkRes_TsPrinting_Icon,
    &g_SLinkRes_TsPrinting_Title,
    &g_SLinkRes_TsPrinting_Infotip,
    &g_LinkAction_TsPrinting
    };

const CResSrcStatic g_SLinkRes_TsSharing_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsSharing_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSFILESHARING_TITLE));
const CResSrcStatic g_SLinkRes_TsSharing_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSFILESHARING_INFOTIP));
const CPLINK_DESC g_SLink_TsSharing = {
    &g_SLinkRes_TsSharing_Icon,
    &g_SLinkRes_TsSharing_Title,
    &g_SLinkRes_TsSharing_Infotip,
    &g_LinkAction_TsSharing
    };

const CResSrcStatic g_SLinkRes_TsSound_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsSound_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSSOUND_TITLE));
const CResSrcStatic g_SLinkRes_TsSound_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSSOUND_INFOTIP));
const CPLINK_DESC g_SLink_TsSound = {
    &g_SLinkRes_TsSound_Icon,
    &g_SLinkRes_TsSound_Title,
    &g_SLinkRes_TsSound_Infotip,
    &g_LinkAction_TsSound
    };

const CResSrcStatic g_SLinkRes_TsStartup_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsStartup_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSSTARTUP_TITLE));
const CResSrcStatic g_SLinkRes_TsStartup_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSSTARTUP_INFOTIP));
const CPLINK_DESC g_SLink_TsStartup = {
    &g_SLinkRes_TsStartup_Icon,
    &g_SLinkRes_TsStartup_Title,
    &g_SLinkRes_TsStartup_Infotip,
    &g_LinkAction_TsStartup
    };

const CResSrcStatic g_TLinkRes_ViewPrinters_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_ViewPrinters_Title(MAKEINTRESOURCEW(IDS_CPTASK_VIEWPRINTERS_TITLE));
const CResSrcStatic g_TLinkRes_ViewPrinters_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VIEWPRINTERS_INFOTIP));
const CPLINK_DESC g_TLink_ViewPrinters = {
    &g_TLinkRes_ViewPrinters_Icon,
    &g_TLinkRes_ViewPrinters_Title,
    &g_TLinkRes_ViewPrinters_Infotip,
    &g_LinkAction_ViewPrinters
    };



const CResSrcStatic g_TLinkRes_VisualPerf_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_VisualPerf_Title(MAKEINTRESOURCEW(IDS_CPTASK_VISUALPERF_TITLE));
const CResSrcStatic g_TLinkRes_VisualPerf_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VISUALPERF_INFOTIP));
const CPLINK_DESC g_TLink_VisualPerf = {
    &g_TLinkRes_VisualPerf_Icon,
    &g_TLinkRes_VisualPerf_Title,
    &g_TLinkRes_VisualPerf_Infotip,
    &g_LinkAction_VisualPerf
    };

const CResSrcStatic g_TLinkRes_VpnConnections_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_VpnConnections_Title(MAKEINTRESOURCEW(IDS_CPTASK_VPNCONNECTION_TITLE));
const CResSrcStatic g_TLinkRes_VpnConnections_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VPNCONNECTION_INFOTIP));
const CPLINK_DESC g_TLink_VpnConnections = {
    &g_TLinkRes_VpnConnections_Icon,
    &g_TLinkRes_VpnConnections_Title,
    &g_TLinkRes_VpnConnections_Infotip,
    &g_LinkAction_VpnConnections
    };

const CResSrcStatic g_TLinkRes_Wallpaper_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Wallpaper_Title(MAKEINTRESOURCEW(IDS_CPTASK_WALLPAPER_TITLE));
const CResSrcStatic g_TLinkRes_Wallpaper_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_WALLPAPER_INFOTIP));
const CPLINK_DESC g_TLink_Wallpaper = {
    &g_TLinkRes_Wallpaper_Icon,
    &g_TLinkRes_Wallpaper_Title,
    &g_TLinkRes_Wallpaper_Infotip,
    &g_LinkAction_Wallpaper
    };

const CResSrcStatic g_SLinkRes_WindowsUpdate_Icon(MAKEINTRESOURCEW(IDI_WINUPDATE));
const CResSrcStatic g_SLinkRes_WindowsUpdate_Title(MAKEINTRESOURCEW(IDS_CPTASK_WINDOWSUPDATE_TITLE));
const CResSrcStatic g_SLinkRes_WindowsUpdate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_WINDOWSUPDATE_INFOTIP));
const CPLINK_DESC g_SLink_WindowsUpdate = {
    &g_SLinkRes_WindowsUpdate_Icon,
    &g_SLinkRes_WindowsUpdate_Title,
    &g_SLinkRes_WindowsUpdate_Infotip,
    &g_LinkAction_WindowsUpdate
    };



//-----------------------------------------------------------------------------
// View page definitions.
//-----------------------------------------------------------------------------

//
// Main Control Panel page.
//

const CPLINK_DESC *g_rgpLink_Cpl_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_HelpAndSupport,
    &g_SLink_32CtrlPanel,
    &g_SLink_OtherCplOptions,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Cpl_SwToClassicView[] = {
    &g_SLink_SwToClassicView,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Cpl_SwToCategoryView[] = {
    &g_SLink_SwToCategoryView,
    NULL
    };


//
// Accounts category
//

const CPLINK_DESC *g_rgpLink_Accounts_Tasks[] = {
    &g_TLink_AccountsChange,
    &g_TLink_AccountsCreate,  // Active on non-server SKU
    &g_TLink_AccountsCreate2, // Active on server SKU
    &g_TLink_AccountsPict,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accounts_SeeAlso[] = {
    &g_TLink_CatAppearance,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accounts_LearnAbout[] = {
    &g_SLink_LearnAccounts,
    &g_SLink_LearnAccountsTypes,
    &g_SLink_LearnAccountsChangeName,
    &g_SLink_LearnAccountsCreate,
    &g_SLink_LearnSwitchUsers,
    NULL
    };

const CPCAT_DESC g_Category_Accounts = {
    eCPCAT_ACCOUNTS,
    L"Security_and_User_Accounts",
    &g_TLink_CatAccounts,
    g_rgpLink_Accounts_Tasks,
    { g_rgpLink_Accounts_SeeAlso, NULL, g_rgpLink_Accounts_LearnAbout }
    };



//
// Accessibility category
//

const CPLINK_DESC *g_rgpLink_Accessibility_Tasks[] = {
    &g_TLink_HighContrast,
    &g_TLink_AccessWizard,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accessibility_SeeAlso[] = {
    &g_SLink_Magnifier,
    &g_SLink_OnScreenKbd,
    NULL
    };

const CPCAT_DESC g_Category_Accessibility = {
    eCPCAT_ACCESSIBILITY,
    L"Accessibility",
    &g_TLink_CatAccessibility,
    g_rgpLink_Accessibility_Tasks,
    { g_rgpLink_Accessibility_SeeAlso, NULL, NULL },
    };


//
// Appearance category
//

const CPLINK_DESC *g_rgpLink_Appearance_Tasks[] = {
    &g_TLink_DisplayTheme,
    &g_TLink_Wallpaper,
    &g_TLink_ScreenSaver,
    &g_TLink_DisplayRes,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Appearance_SeeAlso[] = {
    &g_SLink_FontsFolder,
    &g_SLink_MousePointers,
    &g_SLink_HighContrast,
    &g_SLink_AccountsPict,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Appearance_Troubleshoot[] = {
    &g_SLink_TsDisplay,
    &g_SLink_TsSound,
    NULL
    };

const CPCAT_DESC g_Category_Appearance = {
    eCPCAT_APPEARANCE,
    L"Appearance_and_Themes",
    &g_TLink_CatAppearance,
    g_rgpLink_Appearance_Tasks,
    { g_rgpLink_Appearance_SeeAlso, g_rgpLink_Appearance_Troubleshoot, NULL }
    };


//
// Add/Remove Programs (aka ARP) category
//

const CPLINK_DESC *g_rgpLink_Arp_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_AutoUpdate,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Arp_Tasks[] = {
    &g_TLink_AddProgram,
    &g_TLink_RemoveProgram,
    NULL
    };

const CPCAT_DESC g_Category_Arp = {
    eCPCAT_ARP,
    L"Add_or_Remove_Programs",
    &g_TLink_CatArp,
    g_rgpLink_Arp_Tasks,
    { g_rgpLink_Arp_SeeAlso, NULL, NULL },
    };


//
// Hardware category
//

const CPLINK_DESC *g_rgpLink_Hardware_Tasks[] = {
    &g_TLink_ViewPrinters,
    &g_TLink_AddPrinter,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Hardware_SeeAlso[] = {
    &g_SLink_HardwareWizard,
    &g_SLink_DisplayCpl,
    &g_SLink_Sounds,
    &g_SLink_PowerCpl,
    &g_SLink_SystemCpl,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Hardware_Troubleshoot[] = {
    &g_SLink_TsHardware,
    &g_SLink_TsPrinting,
    &g_SLink_TsNetwork,
    NULL
    };

const CPCAT_DESC g_Category_Hardware = {
    eCPCAT_HARDWARE,
    L"Printers_and_Other_Hardware",
    &g_TLink_CatHardware,
    g_rgpLink_Hardware_Tasks,
    { g_rgpLink_Hardware_SeeAlso, g_rgpLink_Hardware_Troubleshoot, NULL }
    };


//
// Network category
//

const CPLINK_DESC *g_rgpLink_Network_Tasks[] = {
    &g_TLink_NetConnections,
    &g_TLink_VpnConnections,
    &g_TLink_HomeNetWizard,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Network_SeeAlso[] = {
    &g_SLink_MyNetPlaces,
    &g_SLink_Hardware,
    &g_SLink_RemoteDesktop,
    &g_SLink_PhoneModemCpl,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Network_Troubleshoot[] = {
    &g_SLink_TsNetwork,       // Pro/Personal only.
    &g_SLink_TsInetExplorer,  // Pro/Personal only.
    &g_SLink_TsSharing,       // Server only.
    &g_SLink_TsModem,         // Server only.
    &g_SLink_TsNetDiags,      // All SKUs.
    NULL
    };

const CPCAT_DESC g_Category_Network = {
    eCPCAT_NETWORK,
    L"Network_Connections",
    &g_TLink_CatNetwork,
    g_rgpLink_Network_Tasks,
    { g_rgpLink_Network_SeeAlso, g_rgpLink_Network_Troubleshoot, NULL }
    };


//
// Other CPLs category
//

const CPLINK_DESC *g_rgpLink_Other_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_HelpAndSupport,
    NULL
    };

const CPCAT_DESC g_Category_Other = {
    eCPCAT_OTHER,
    NULL,   // "Other" uses std Control Panel help topic.
    &g_TLink_CatOther,
    NULL,
    { g_rgpLink_Other_SeeAlso, NULL, NULL }
    };

//
// PerfMaint category
//

const CPLINK_DESC *g_rgpLink_PerfMaint_Tasks[] = {
    &g_TLink_SystemCpl,
    &g_TLink_VisualPerf,
    &g_TLink_CleanUpDisk,
    &g_TLink_BackupData,
    &g_TLink_Defrag,
    NULL
    };

const CPLINK_DESC *g_rgpLink_PerfMaint_SeeAlso[] = {
    &g_SLink_FileTypes,
    &g_SLink_SystemRestore,
    NULL
    };

const CPLINK_DESC *g_rgpLink_PerfMaint_Troubleshoot[] = {
    &g_SLink_TsStartup,
    NULL
    };

const CPCAT_DESC g_Category_PerfMaint = {
    eCPCAT_PERFMAINT,
    L"Performance_and_Maintenance",
    &g_TLink_CatPerfMaint, 
    g_rgpLink_PerfMaint_Tasks,
    { g_rgpLink_PerfMaint_SeeAlso, g_rgpLink_PerfMaint_Troubleshoot, NULL },
    };


//
// Regional category
//

const CPLINK_DESC *g_rgpLink_Regional_Tasks[] = {
    &g_TLink_DateTime,
    &g_TLink_Region,
    &g_TLink_Language,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Regional_SeeAlso[] = {
    &g_SLink_ScheduledTasks,
    NULL
    };

const CPCAT_DESC g_Category_Regional = {
    eCPCAT_REGIONAL,
    L"Date__Time__Language_and_Regional_Settings",
    &g_TLink_CatRegional,
    g_rgpLink_Regional_Tasks,
    { g_rgpLink_Regional_SeeAlso, NULL, NULL },
    };


//
// Sound category
//

const CPLINK_DESC *g_rgpLink_Sound_Tasks[] = {
    &g_TLink_SoundVolume,
    &g_TLink_SoundSchemes,
    &g_TLink_SpeakerSettings,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Sound_SeeAlso[] = {
    &g_SLink_SoundAccessibility,
    &g_SLink_SoundVolumeAdv,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Sound_Troubleshoot[] = {
    &g_SLink_TsSound,
    &g_SLink_TsDvd,
    NULL
    };

const CPCAT_DESC g_Category_Sound = {
    eCPCAT_SOUND,
    L"Sounds__Speech_and_Audio_Devices",
    &g_TLink_CatSound,
    g_rgpLink_Sound_Tasks,
    { g_rgpLink_Sound_SeeAlso, g_rgpLink_Sound_Troubleshoot, NULL }
    };



//
//              ********* IMPORTANT **********
//
// The order of these entries MUST match up with the category ID
// values in the cCPCAT enumeration.  These IDs also map directly
// to the SCID_CONTROLPANELCATEGORY value stored for each CPL
// applet in the registry.
//
// Code using a category ID will map directly to this array.
// Order of display in the Category selection view is handled 
// by the function CCplView::_DisplayIndexToCategoryIndex in
// cpview.cpp.
//
const CPCAT_DESC *g_rgpCplCatInfo[] = {
    &g_Category_Other,
    &g_Category_Appearance,
    &g_Category_Hardware,
    &g_Category_Network,
    &g_Category_Sound,
    &g_Category_PerfMaint,
    &g_Category_Regional,
    &g_Category_Accessibility,
    &g_Category_Arp,
    &g_Category_Accounts,
    NULL,
    };



//-----------------------------------------------------------------------------
// Helper functions used in support of the namespace.
//-----------------------------------------------------------------------------

//
// Copy one DPA of IUICommand ptrs to another.
// Returns:
//      S_OK   - All items copied.
//      Error  - Something failed.
//
HRESULT
CplNamespace_CopyCommandArray(
    const CDpaUiCommand& rgFrom,
    CDpaUiCommand *prgTo
    )
{
    ASSERT(NULL != prgTo);
    ASSERT(0 == prgTo->Count());

    HRESULT hr = S_OK;
    const int cCommands = rgFrom.Count();
    for (int i = 0; i < cCommands && SUCCEEDED(hr); i++)
    {
        IUICommand *pc = const_cast<IUICommand *>(rgFrom.Get(i));
        ASSERT(NULL != pc);

        if (-1 != prgTo->Append(pc))
        {
            pc->AddRef();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return THR(hr);
}


//
// Create a new IUICommand object from a CPLINK_DESC structure.
//
HRESULT
CplNamespace_CreateUiCommand(
    IUnknown *punkSite,
    const CPLINK_DESC& ld,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    *ppc = NULL;

    ICplNamespace *pns;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Create_CplUiCommand(ld.prsrcName->GetResource(pns),
                                      ld.prsrcInfotip->GetResource(pns),
                                      ld.prsrcIcon->GetResource(pns),
                                      ld.pAction,
                                      IID_IUICommand,
                                      (void **)ppc);
        pns->Release();
    }
    return THR(hr);
}


//
// Create a new IUIElement object for a given webview type.
// The returned IUIElement object represents the header for
// the requested webview menu.
//
HRESULT
CplNamespace_CreateWebViewHeaderElement(
    eCPWVTYPE eType, 
    IUIElement **ppele
    )
{
    ASSERT(0 <= eType && eCPWVTYPE_NUMTYPES > eType);
    ASSERT(NULL != ppele);
    ASSERT(!IsBadWritePtr(ppele, sizeof(*ppele)));

    static const struct
    {
        LPCWSTR pszName;
        LPCWSTR pszInfotip;
        LPCWSTR pszIcon;

    } rgHeaderInfo[] = {
        //
        // eCPWVTYPE_CPANEL
        //
        {
            MAKEINTRESOURCEW(IDS_CONTROLPANEL),
            MAKEINTRESOURCEW(IDS_CPTASK_CONTROLPANEL_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPLFLD)
        },
        //
        // eCPWVTYPE_SEEALSO
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_SEEALSO_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_SEEALSO_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_SEEALSO)
        },   
        //
        // eCPWVTYPE_TROUBLESHOOTER
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_TROUBLESHOOTER_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_TROUBLESHOOTER_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER)
        },
        //
        // eCPWVTYPE_LEARNABOUT
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_LEARNABOUT_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_LEARNABOUT_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_LEARNABOUT)
        }
    };

    *ppele = NULL;

    HRESULT hr = Create_CplUiElement(rgHeaderInfo[eType].pszName,
                                     rgHeaderInfo[eType].pszInfotip,
                                     rgHeaderInfo[eType].pszIcon,
                                     IID_IUIElement,
                                     (void **)ppele);
    
    return THR(hr);
}



//-----------------------------------------------------------------------------
// UI Command Enumeration
//-----------------------------------------------------------------------------

class IEnumCommandBase
{
    public:
        virtual ~IEnumCommandBase() { }
        virtual HRESULT Next(IUnknown *punkSite, IUICommand **ppc) = 0;
        virtual HRESULT Skip(ULONG n) = 0;
        virtual HRESULT Reset(void) = 0;
        virtual HRESULT Clone(IEnumCommandBase **ppEnum) = 0;
};

//
// Used to enumerate UI Command objects that originate from static
// initialization information in the CPL namespace.
//
class CEnumCommand_LinkDesc : public IEnumCommandBase
{
    public:
        CEnumCommand_LinkDesc(const CPLINK_DESC **ppld);
        ~CEnumCommand_LinkDesc(void);

        HRESULT Next(IUnknown *punkSite, IUICommand **ppc);
        HRESULT Skip(ULONG n);
        HRESULT Reset(void);
        HRESULT Clone(IEnumCommandBase **ppEnum);

    private:
        const CPLINK_DESC ** const m_ppldFirst;  // First item in descriptor array.
        const CPLINK_DESC **m_ppldCurrent;       // 'Current' item referenced.
};


//
// Used to enumerate UI Command objects that already exist in
// a DPA of IUICommand pointers.  In particular, this is used
// to enumerate the UICommand objects that represent CPL applets
// in the user interface.
//
class CEnumCommand_Array : public IEnumCommandBase
{
    public:
        CEnumCommand_Array(void);
        ~CEnumCommand_Array(void);

        HRESULT Next(IUnknown *punkSite, IUICommand **ppc);
        HRESULT Skip(ULONG n);
        HRESULT Reset(void);
        HRESULT Clone(IEnumCommandBase **ppEnum);
        HRESULT Initialize(const CDpaUiCommand& rgCommands);

    private:
        CDpaUiCommand  m_rgCommands; // DPA of IUICommand ptrs.
        int            m_iCurrent;   // 'Current' item in enumeration.

        //
        // Prevent copy.
        //
        CEnumCommand_Array(const CEnumCommand_Array& rhs);              // not implemented.
        CEnumCommand_Array& operator = (const CEnumCommand_Array& rhs); // not implemented.
};




//-----------------------------------------------------------------------------
// CEnumCommand_LinkDesc implementation.
//-----------------------------------------------------------------------------

CEnumCommand_LinkDesc::CEnumCommand_LinkDesc(
    const CPLINK_DESC **ppld
    ) : m_ppldFirst(ppld),
        m_ppldCurrent(ppld)
{
    TraceMsg(TF_LIFE, "CEnumCommand_LinkDesc::CEnumCommand_LinkDesc, this = 0x%x", this);
}


CEnumCommand_LinkDesc::~CEnumCommand_LinkDesc(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand_LinkDesc::~CEnumCommand_LinkDesc, this = 0x%x", this);
}


HRESULT
CEnumCommand_LinkDesc::Next(
    IUnknown *punkSite,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    HRESULT hr = S_FALSE;
    if (NULL != m_ppldCurrent && NULL != *m_ppldCurrent)
    {
        hr = CplNamespace_CreateUiCommand(punkSite, **m_ppldCurrent, ppc);
        m_ppldCurrent++;
    }
    return THR(hr);
}


HRESULT
CEnumCommand_LinkDesc::Reset(
    void
    )
{
    m_ppldCurrent = m_ppldFirst;
    return S_OK;
}


HRESULT
CEnumCommand_LinkDesc::Skip(
    ULONG n
    )
{
    if (NULL != m_ppldCurrent)
    {
        while(0 < n-- && NULL != *m_ppldCurrent)
        {
            m_ppldCurrent++;
        }
    }
    return 0 == n ? S_OK : S_FALSE;
}


HRESULT
CEnumCommand_LinkDesc::Clone(
    IEnumCommandBase **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = new CEnumCommand_LinkDesc(m_ppldFirst);
    if (NULL != *ppenum)
    {
        hr = S_OK;
    }
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CEnumCommand_Array implementation.
//-----------------------------------------------------------------------------

CEnumCommand_Array::CEnumCommand_Array(
    void
    ) : m_iCurrent(0)
{
    TraceMsg(TF_LIFE, "CEnumCommand_Array::CEnumCommand_Array, this = 0x%x", this);
}

CEnumCommand_Array::~CEnumCommand_Array(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand_Array::~CEnumCommand_Array, this = 0x%x", this);
}


HRESULT
CEnumCommand_Array::Initialize(
    const CDpaUiCommand& rgCommands
    )
{
    ASSERT(0 == m_rgCommands.Count());
    ASSERT(0 == m_iCurrent);
 
    HRESULT hr = CplNamespace_CopyCommandArray(rgCommands, &m_rgCommands);
    return THR(hr);
}
 
 
HRESULT
CEnumCommand_Array::Next(
    IUnknown *punkSite,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    UNREFERENCED_PARAMETER(punkSite);
    
    HRESULT hr = S_FALSE;
    if (m_iCurrent < m_rgCommands.Count())
    {
        *ppc = m_rgCommands.Get(m_iCurrent++);
        ASSERT(NULL != *ppc);

        (*ppc)->AddRef();
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT
CEnumCommand_Array::Reset(
    void
    )
{
    m_iCurrent = 0;
    return S_OK;
}


HRESULT
CEnumCommand_Array::Skip(
    ULONG n
    )
{
    while(0 < n-- && m_iCurrent < m_rgCommands.Count())
    {
        m_iCurrent++;
    }
    return 0 == n ? S_OK : S_FALSE;
}


HRESULT
CEnumCommand_Array::Clone(
    IEnumCommandBase **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = new CEnumCommand_Array();
    if (NULL != *ppenum)
    {
        hr = static_cast<CEnumCommand_Array *>(*ppenum)->Initialize(m_rgCommands);
        if (FAILED(hr))
        {
            delete *ppenum;
            *ppenum = NULL;
        }
    }
    return THR(hr);
}



//-----------------------------------------------------------------------------
// CEnumCommand
//-----------------------------------------------------------------------------
//
// Enumerates IUICommand pointers for UICommand objects in the
// Control Panel namespace.
//
class CEnumCommand : public CObjectWithSite,
                     public IEnumUICommand
{
    public:
        ~CEnumCommand(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumUICommand
        //
        STDMETHOD(Next)(ULONG celt, IUICommand **pUICommand, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumUICommand **ppenum);

        static HRESULT CreateInstance(IUnknown *punkSite, const CPLINK_DESC **ppld, REFIID riid, void **ppvEnum);
        static HRESULT CreateInstance(IUnknown *punkSite, const CDpaUiCommand& rgCommands, REFIID riid, void **ppvEnum);

    private:
        LONG              m_cRef;
        IEnumCommandBase *m_pImpl; // Ptr to actual implementation.

        CEnumCommand(void);
        //
        // Prevent copy.
        //
        CEnumCommand(const CEnumCommand& rhs);              // not implemented.
        CEnumCommand& operator = (const CEnumCommand& rhs); // not implemented.

        bool _IsRestricted(IUICommand *puic);
};


CEnumCommand::CEnumCommand(
    void
    ) : m_cRef(1),
        m_pImpl(NULL)
{
    TraceMsg(TF_LIFE, "CEnumCommand::CEnumCommand, this = 0x%x", this);
}

CEnumCommand::~CEnumCommand(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand::~CEnumCommand, this = 0x%x", this);
    delete m_pImpl;
}


//
// Creates a command enumerator from an array of link descriptions
// in the CPL namespace.
//
HRESULT
CEnumCommand::CreateInstance(
    IUnknown *punkSite,
    const CPLINK_DESC **ppld,
    REFIID riid,
    void **ppvOut
    )
{
    //
    // Note that ppld can be NULL.  It simply results in an 
    // empty enumerator.
    //
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pec = new CEnumCommand();
    if (NULL != pec)
    {
        pec->m_pImpl = new CEnumCommand_LinkDesc(ppld);
        if (NULL != pec->m_pImpl)
        {
            hr = pec->QueryInterface(riid, ppvOut);
            if (SUCCEEDED(hr))
            {
                hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
            }
        }
        pec->Release();
    }
    return THR(hr);
}



//
// Creates a command enumerator from a DPA of IUICommand ptrs.
//
HRESULT
CEnumCommand::CreateInstance(
    IUnknown *punkSite,
    const CDpaUiCommand& rgCommands,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pec = new CEnumCommand();
    if (NULL != pec)
    {
        pec->m_pImpl = new CEnumCommand_Array();
        if (NULL != pec->m_pImpl)
        {
            hr = static_cast<CEnumCommand_Array *>(pec->m_pImpl)->Initialize(rgCommands);
            if (SUCCEEDED(hr))
            {
                hr = pec->QueryInterface(riid, ppvOut);
                if (SUCCEEDED(hr))
                {
                    hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
                }
            }
        }
        pec->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CEnumCommand::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CEnumCommand, IEnumUICommand),
        QITABENT(CEnumCommand, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CEnumCommand::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CEnumCommand::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CEnumCommand::Next(
    ULONG celt,
    IUICommand **ppUICommand,
    ULONG *pceltFetched
    )
{   
    ASSERT(NULL != ppUICommand);
    ASSERT(!IsBadWritePtr(ppUICommand, sizeof(*ppUICommand) * celt));
    ASSERT(NULL != m_pImpl);

    HRESULT hr = S_OK;

    ULONG celtFetched = 0;
    while(S_OK == hr && 0 < celt)
    {
        ASSERT(NULL != CObjectWithSite::_punkSite);
        
        IUICommand *puic;
        //
        // This is a little weird.  I pass the site ptr to the 
        // Next() method but then also set the returned object's
        // site when it's returned by Next().  Why not just set
        // the site in the Next() implementation?  Next() needs the site
        // ptr to pass through to any IResSrc::GetResource implementation
        // when retrieving the resources for any given UI command object.
        // This is because the resource used can vary depending upon state
        // information stored in the namespace.  However, to simplify 
        // lifetime management, I want to 'set' the site on the returned
        // objects in only one place; this place.  That way, the derived
        // enumerator instance attached to m_pImpl doesn't need to worry 
        // about setting the site.  We do it in one place for all 
        // implementations.  [brianau - 3/16/01]
        //
        hr = m_pImpl->Next(CObjectWithSite::_punkSite, &puic);
        if (S_OK == hr)
        {
            //
            // It's important that we set the object's 'site' before
            // checking the restriction.  The restriction checking
            // code requires access to the CplNamespace which is obtained
            // through the site.
            //
            hr = IUnknown_SetSite(puic, CObjectWithSite::_punkSite);
            if (SUCCEEDED(hr))
            {
                if (!_IsRestricted(puic))
                {
                    celt--;
                    celtFetched++;
                    (*ppUICommand++ = puic)->AddRef();  
                }
            }
            puic->Release();
        }
    }
    if (NULL != pceltFetched)
    {
        *pceltFetched = celtFetched;
    }
    return THR(hr);
}


STDMETHODIMP
CEnumCommand::Skip(
    ULONG celt
    )
{
    ASSERT(NULL != m_pImpl);

    HRESULT hr = m_pImpl->Skip(celt);
    return THR(hr);
}
    

STDMETHODIMP
CEnumCommand::Reset(
    void
    )
{
    ASSERT(NULL != m_pImpl);

    HRESULT hr = m_pImpl->Reset();
    return THR(hr);
}


STDMETHODIMP
CEnumCommand::Clone(
    IEnumUICommand **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pImpl);

    *ppenum = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pe = new CEnumCommand();
    if (NULL != pe)
    {
        hr = m_pImpl->Clone(&(pe->m_pImpl));
        if (SUCCEEDED(hr))
        {
            hr = pe->QueryInterface(IID_IEnumUICommand, (void **)ppenum);
        }
        pe->Release();
    }
    return THR(hr);
}


bool
CEnumCommand::_IsRestricted(
    IUICommand *puic
    )
{
    ASSERT(NULL != puic);

    bool bRestricted = false;

    UISTATE uis;
    HRESULT hr = puic->get_State(NULL, TRUE, &uis);
    if (SUCCEEDED(hr))
    {
        if (UIS_HIDDEN == uis)
        {
            bRestricted = true;
        }
    }
    return bRestricted;
}


//-----------------------------------------------------------------------------
// CCplWebViewInfo
//-----------------------------------------------------------------------------

class CCplWebViewInfo : public ICplWebViewInfo
{
    public:
        ~CCplWebViewInfo(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumCplWebViewInfo
        //
        STDMETHOD(get_Header)(IUIElement **ppele);
        STDMETHOD(get_Style)(DWORD *pdwFlags);
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum);

        static HRESULT CreateInstance(IUIElement *peHeader, IEnumUICommand *penum, DWORD dwStyle, REFIID riid, void **ppvOut);

    private:
        LONG            m_cRef;
        IUIElement     *m_peHeader;        // The webview menu header.
        IEnumUICommand *m_penumUiCommand;  // The webview menu tasks.
        DWORD           m_dwStyle;         // Style flags.

        CCplWebViewInfo(void);
};


CCplWebViewInfo::CCplWebViewInfo(
    void
    ) : m_cRef(1),
        m_peHeader(NULL),
        m_penumUiCommand(NULL),
        m_dwStyle(0)
{
    TraceMsg(TF_LIFE, "CCplWebViewInfo::CCplWebViewInfo, this = 0x%x", this);
}


CCplWebViewInfo::~CCplWebViewInfo(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplWebViewInfo::~CCplWebViewInfo, this = 0x%x", this);
    ATOMICRELEASE(m_peHeader);
    ATOMICRELEASE(m_penumUiCommand);
}


HRESULT 
CCplWebViewInfo::CreateInstance( // [static]
    IUIElement *peHeader, 
    IEnumUICommand *penum, 
    DWORD dwStyle,
    REFIID riid, 
    void **ppvOut
    )
{
    ASSERT(NULL != peHeader);
    ASSERT(NULL != penum);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplWebViewInfo *pwvi = new CCplWebViewInfo();
    if (NULL != pwvi)
    {
        hr = pwvi->QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hr))
        {
            (pwvi->m_peHeader = peHeader)->AddRef();
            (pwvi->m_penumUiCommand = penum)->AddRef();

            pwvi->m_dwStyle = dwStyle;
        }
        pwvi->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplWebViewInfo::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplWebViewInfo, ICplWebViewInfo),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplWebViewInfo::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplWebViewInfo::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CCplWebViewInfo::get_Header(
    IUIElement **ppele
    )
{
    ASSERT(NULL != ppele);
    ASSERT(!IsBadWritePtr(ppele, sizeof(*ppele)));

    HRESULT hr = S_OK;

    (*ppele = m_peHeader)->AddRef();

    return THR(hr);
}



STDMETHODIMP
CCplWebViewInfo::get_Style(
    DWORD *pdwStyle
    )
{
    ASSERT(NULL != pdwStyle);
    ASSERT(!IsBadWritePtr(pdwStyle, sizeof(*pdwStyle)));

    *pdwStyle = m_dwStyle;
    return S_OK;
}


STDMETHODIMP
CCplWebViewInfo::EnumTasks(
    IEnumUICommand **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = S_OK;

    (*ppenum = m_penumUiCommand)->AddRef();

    return THR(hr);
}



//-----------------------------------------------------------------------------
// CEnumCplWebViewInfo
//-----------------------------------------------------------------------------

struct ECWVI_ITEM
{
    eCPWVTYPE           eType;
    const CPLINK_DESC **rgpDesc;         // Ptr to nul-term array of link desc ptrs.
    bool                bRestricted;     // Is item restricted from usage?
    bool                bEnhancedMenu;   // Render as a 'special' list in webview?
};



class CEnumCplWebViewInfo : public CObjectWithSite,
                            public IEnumCplWebViewInfo
{
    public:
        ~CEnumCplWebViewInfo(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumCplWebViewInfo
        //
        STDMETHOD(Next)(ULONG celt, ICplWebViewInfo **ppwvi, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumCplWebViewInfo **ppenum);

        static HRESULT CreateInstance(IUnknown *punkSite, const ECWVI_ITEM *prgwvi, UINT cItems, REFIID riid, void **ppvOut);

    private:
        LONG m_cRef;
        int  m_iCurrent;
        CDpa<ICplWebViewInfo, CDpaDestroyer_Release<ICplWebViewInfo> > m_rgwvi;

        CEnumCplWebViewInfo(void);
        HRESULT _Initialize(IUnknown *punkSite, const ECWVI_ITEM *prgwvi, UINT cItems);

        //
        // Prevent copy.
        //
        CEnumCplWebViewInfo(const CEnumCplWebViewInfo& rhs);              // not implemented.
        CEnumCplWebViewInfo& operator = (const CEnumCplWebViewInfo& rhs); // not implemented.
};



CEnumCplWebViewInfo::CEnumCplWebViewInfo(
    void
    ) : m_cRef(1),
        m_iCurrent(0)
{
    TraceMsg(TF_LIFE, "CEnumCplWebViewInfo::CEnumCplWebViewInfo, this = 0x%x", this);
}

CEnumCplWebViewInfo::~CEnumCplWebViewInfo(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCplWebViewInfo::~CEnumCplWebViewInfo, this = 0x%x", this);
}



HRESULT 
CEnumCplWebViewInfo::CreateInstance(
    IUnknown *punkSite,
    const ECWVI_ITEM *prgwvi,
    UINT cItems,
    REFIID riid, 
    void **ppvOut
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != prgwvi);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCplWebViewInfo *pewvi = new CEnumCplWebViewInfo();
    if (NULL != pewvi)
    {
        hr = pewvi->_Initialize(punkSite, prgwvi, cItems);
        if (SUCCEEDED(hr))
        {
            hr = pewvi->QueryInterface(riid, ppvOut);
        }
        pewvi->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CEnumCplWebViewInfo::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CEnumCplWebViewInfo, IEnumCplWebViewInfo),
        QITABENT(CEnumCplWebViewInfo, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CEnumCplWebViewInfo::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CEnumCplWebViewInfo::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CEnumCplWebViewInfo::Next(
    ULONG celt, 
    ICplWebViewInfo **ppwvi, 
    ULONG *pceltFetched
    )
{
    ASSERT(NULL != ppwvi);
    ASSERT(!IsBadWritePtr(ppwvi, sizeof(*ppwvi) * celt));

    ULONG celtFetched = 0;
    while(m_iCurrent < m_rgwvi.Count() && 0 < celt)
    {
        *ppwvi = m_rgwvi.Get(m_iCurrent++);

        ASSERT(NULL != *ppwvi);
        (*ppwvi)->AddRef();

        celt--;
        celtFetched++;
        ppwvi++;
    }
    if (NULL != pceltFetched)
    {
        *pceltFetched = celtFetched;
    }
    return 0 == celt ? S_OK : S_FALSE;
}



STDMETHODIMP
CEnumCplWebViewInfo::Reset(
    void
    )
{
    m_iCurrent = 0;
    return S_OK;
}


STDMETHODIMP
CEnumCplWebViewInfo::Skip(
    ULONG n
    )
{
    while(0 < n-- && m_iCurrent < m_rgwvi.Count())
    {
        m_iCurrent++;
    }
    return 0 == n ? S_OK : S_FALSE;
}


STDMETHODIMP
CEnumCplWebViewInfo::Clone(
    IEnumCplWebViewInfo **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    *ppenum = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCplWebViewInfo *penum = new CEnumCplWebViewInfo();
    if (NULL != *ppenum)
    {
        for (int i = 0; SUCCEEDED(hr) && i < m_rgwvi.Count(); i++)
        {
            ICplWebViewInfo *pwvi = m_rgwvi.Get(i);
            ASSERT(NULL != pwvi);

            if (-1 != penum->m_rgwvi.Append(pwvi))
            {
                pwvi->AddRef();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = penum->QueryInterface(IID_IEnumCplWebViewInfo, (void **)ppenum);
        }
        penum->Release();
    }
    return THR(hr);
}



HRESULT
CEnumCplWebViewInfo::_Initialize(
    IUnknown *punkSite,
    const ECWVI_ITEM *prgwvi,
    UINT cItems
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != prgwvi);

    IUnknown *punk;
    HRESULT hr = QueryInterface(IID_IUnknown, (void **)&punk);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(punk, punkSite);
        if (SUCCEEDED(hr))
        {
            for (UINT i = 0; i < cItems; i++)
            {
                if (!prgwvi[i].bRestricted)
                {
                    IEnumUICommand *penum;

                    hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                                      prgwvi[i].rgpDesc, 
                                                      IID_IEnumUICommand, 
                                                      (void **)&penum);
                    if (SUCCEEDED(hr))
                    {
                        IUIElement *peHeader;
                        hr = CplNamespace_CreateWebViewHeaderElement(prgwvi[i].eType, &peHeader);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwStyle = 0;
                            if (prgwvi[i].bEnhancedMenu)
                            {
                                dwStyle |= SFVMWVF_SPECIALTASK;
                            }
                            ICplWebViewInfo *pwvi;
                            hr = CCplWebViewInfo::CreateInstance(peHeader, penum, dwStyle, IID_ICplWebViewInfo, (void **)&pwvi);
                            if (SUCCEEDED(hr))
                            {
                                if (-1 == m_rgwvi.Append(pwvi))
                                {
                                    pwvi->Release();
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            peHeader->Release();
                        }
                        penum->Release();
                    }
                }
            }
        }
        punk->Release();
    }
    return THR(hr);
}





//-----------------------------------------------------------------------------
// CCplCategory
//-----------------------------------------------------------------------------

class CCplCategory : public CObjectWithSite,
                     public ICplCategory
{
    public:
        ~CCplCategory(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplCategory
        //
        STDMETHOD(GetCategoryID)(eCPCAT *pID);
        STDMETHOD(GetUiCommand)(IUICommand **ppele);
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum);
        STDMETHOD(EnumCplApplets)(IEnumUICommand **ppenum);
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(GetHelpURL)(LPWSTR pszURL, UINT cchURL);

        static HRESULT CreateInstance(const CPCAT_DESC *pDesc, const CDpaUiCommand& rgCplApplets, REFIID riid, void **ppvOut);

    private:
        LONG              m_cRef;
        const CPCAT_DESC *m_pDesc;        // Initialization data.
        CDpaUiCommand     m_rgCplApplets; // Cached list of CPL applet links.

        CCplCategory(void);
        //
        // Prevent copy.
        //
        CCplCategory(const CCplCategory& rhs);              // not implemented.
        CCplCategory& operator = (const CCplCategory& rhs); // not implemented.

        HRESULT _Initialize(const CPCAT_DESC *pDesc, const CDpaUiCommand& rgCplApplets);
        bool _CplAppletsLoaded(void) const;
};



CCplCategory::CCplCategory(
    void
    ) : m_cRef(1),
        m_pDesc(NULL)
{    
    TraceMsg(TF_LIFE, "CCplCategory::CCplCategory, this = 0x%x", this);
}


CCplCategory::~CCplCategory(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplCategory::~CCplCategory, this = 0x%x", this);
}


HRESULT
CCplCategory::CreateInstance(
    const CPCAT_DESC *pDesc,
    const CDpaUiCommand& rgCplApplets,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != pDesc);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplCategory *pc = new CCplCategory();
    if (NULL != pc)
    {
        hr = pc->_Initialize(pDesc, rgCplApplets);
        if (SUCCEEDED(hr))
        {
            hr = pc->QueryInterface(riid, ppvOut);
        }
        pc->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplCategory::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplCategory, ICplCategory),
        QITABENT(CCplCategory, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplCategory::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplCategory::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CCplCategory::GetUiCommand(
    IUICommand **ppc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::GetUiCommand");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != m_pDesc->pLink);
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    HRESULT hr = CplNamespace_CreateUiCommand(CObjectWithSite::_punkSite, 
                                              *(m_pDesc->pLink), 
                                              ppc);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(*ppc, CObjectWithSite::_punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::GetUiCommand", hr);
    return THR(hr);
}


STDMETHODIMP
CCplCategory::EnumWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumWebViewInfo");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    UNREFERENCED_PARAMETER(dwFlags);

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_SEEALSO,      m_pDesc->slinks.ppSeeAlsoLinks,      false, false },
        { eCPWVTYPE_TROUBLESHOOT, m_pDesc->slinks.ppTroubleshootLinks, false, false },
        { eCPWVTYPE_LEARNABOUT,   m_pDesc->slinks.ppLearnAboutLinks,   false, false }
        };

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite,
                                                     rgItems, 
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumWebViewInfo", hr);
    return THR(hr);
}



STDMETHODIMP
CCplCategory::EnumTasks(
    IEnumUICommand **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumTasks");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                              m_pDesc->ppTaskLinks, 
                                              IID_IEnumUICommand, 
                                              (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumTasks", hr);
    return THR(hr);
}


STDMETHODIMP
CCplCategory::EnumCplApplets(
    IEnumUICommand **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumCplApplets");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                              m_rgCplApplets, 
                                              IID_IEnumUICommand, 
                                              (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumCplApplets", hr);
    return THR(hr);
}



STDMETHODIMP
CCplCategory::GetCategoryID(
    eCPCAT *pID
    )
{
    ASSERT(NULL != pID);
    ASSERT(!IsBadWritePtr(pID, sizeof(*pID)));

    *pID = m_pDesc->idCategory;
    return S_OK;
}


STDMETHODIMP
CCplCategory::GetHelpURL(
    LPWSTR pszURL, 
    UINT cchURL
    )
{
    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    
    return CPL::BuildHssHelpURL(m_pDesc->pszHelpSelection, pszURL, cchURL);
}



HRESULT
CCplCategory::_Initialize(
    const CPCAT_DESC *pDesc,
    const CDpaUiCommand& rgCplApplets
    )
{
    ASSERT(NULL != pDesc);
    ASSERT(NULL == m_pDesc);

    m_pDesc = pDesc;
    HRESULT hr = CplNamespace_CopyCommandArray(rgCplApplets, &m_rgCplApplets);

    return THR(hr);
}


//-----------------------------------------------------------------------------
// CTriState
// This is a trivial class to allow representation of a uninitialized boolean
// value.  Used by CCplNamespace for it's storage of cached 'restriction'
// values.  Internally, -1 == 'uninitialized, 0 == false and 1 == true.
//-----------------------------------------------------------------------------

class CTriState
{
    public:
        CTriState(void)
            : m_iVal(-1) { }

        operator bool() const
            { ASSERT(!_Invalid()); return (!_Invalid() ? !!m_iVal : false); }

        CTriState& operator = (bool bValue)
            { m_iVal = bValue ? 1 : 0; return *this; }

        bool IsInvalid(void) const
            { return _Invalid(); }
            
    private:
        int m_iVal;

        void _Set(bool bValue)
            { m_iVal = bValue ? 1 : 0; }

        bool _Invalid(void) const
            { return (-1 == m_iVal); }
};



//-----------------------------------------------------------------------------
// CCplNamespace
//-----------------------------------------------------------------------------

class CCplNamespace : public CObjectWithSite,
                      public ICplNamespace
                      
{
    public:
        ~CCplNamespace(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplNamespace
        //
        STDMETHOD(GetCategory)(eCPCAT eCategory, ICplCategory **ppcat);
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs);
        STDMETHOD_(BOOL, IsServer)(void);
        STDMETHOD_(BOOL, IsProfessional)(void);
        STDMETHOD_(BOOL, IsPersonal)(void);
        STDMETHOD_(BOOL, IsUserAdmin)(void);
        STDMETHOD_(BOOL, IsUserOwner)(void);
        STDMETHOD_(BOOL, IsUserStandard)(void);
        STDMETHOD_(BOOL, IsUserLimited)(void);
        STDMETHOD_(BOOL, IsUserGuest)(void);
        STDMETHOD_(BOOL, IsOnDomain)(void);
        STDMETHOD_(BOOL, IsX86)(void);
        STDMETHOD_(BOOL, AllowUserManager)(void);
        STDMETHOD_(BOOL, UsePersonalUserManager)(void);
        STDMETHOD_(BOOL, AllowDeskCpl)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Background)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Screensaver)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Appearance)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Settings)(void);

        static HRESULT CreateInstance(IEnumIDList *penumIDs, REFIID riid, void **ppvOut);

    private:
        LONG           m_cRef;
        ICplCategory  *m_rgpCategories[eCPCAT_NUMCATEGORIES];
        CDpaUiCommand  m_rgCplApplets[eCPCAT_NUMCATEGORIES];
        IEnumIDList   *m_penumIDs;
        CTriState      m_SkuSvr;
        CTriState      m_SkuPro;
        CTriState      m_SkuPer;
        CTriState      m_Admin;
        CTriState      m_UserOwner;
        CTriState      m_UserStandard;
        CTriState      m_UserLimited;
        CTriState      m_UserGuest;
        CTriState      m_Domain;
        CTriState      m_AllowUserManager;
        CTriState      m_PersonalUserManager;
        CTriState      m_AllowDeskCpl;
        CTriState      m_rgAllowDeskCplTabs[CPLTAB_DESK_MAX];

        CCplNamespace(void);
        //
        // Prevent copy.
        //
        CCplNamespace(const CCplNamespace& rhs);              // not implemented.
        CCplNamespace& operator = (const CCplNamespace& rhs); // not implemented.

        HRESULT _Initialize(IEnumIDList *penumIDs);
        HRESULT _SetIDList(IEnumIDList *penumIDs);
        HRESULT _IsValidCategoryID(int iCategory) const;
        HRESULT _CategorizeCplApplets(void);
        HRESULT _LoadSeeAlsoLinks(void);
        HRESULT _AddSeeAlso(IUICommand *pc);
        HRESULT _CategorizeCplApplet(IShellFolder2 *psf2Cpanel, LPCITEMIDLIST pidlItem);
        BOOL  _UserAcctType(CTriState *pts);
        void  _GetUserAccountType(void);
        BOOL _AllowDeskCplTab(eDESKCPLTAB eTab);
        void _DestroyCategories(void);
        void _ClearCplApplets(void);
};


CCplNamespace::CCplNamespace(
    void
    ) : m_cRef(1),
        m_penumIDs(NULL)
{
    TraceMsg(TF_LIFE, "CCplNamespace::CCplNamespace, this = 0x%x", this);
    ZeroMemory(m_rgpCategories, ARRAYSIZE(m_rgpCategories) * sizeof(m_rgpCategories[0]));
}

CCplNamespace::~CCplNamespace(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplNamespace::~CCplNamespace, this = 0x%x", this);
    _DestroyCategories();
    ATOMICRELEASE(m_penumIDs);
}


HRESULT
CCplNamespace::CreateInstance(
    IEnumIDList *penumIDs,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplNamespace *pns = new CCplNamespace();
    if (NULL != pns)
    {
        hr = pns->_Initialize(penumIDs);
        if (SUCCEEDED(hr))
        {
            hr = pns->QueryInterface(riid, ppvOut);
        }
        pns->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplNamespace::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplNamespace, ICplNamespace),
        QITABENT(CCplNamespace, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplNamespace::AddRef(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplNamespace::AddRef %d->%d", m_cRef, m_cRef+1);
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplNamespace::Release(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplNamespace::Release %d<-%d", m_cRef-1, m_cRef);
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CCplNamespace::EnumWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::EnumWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    const bool bNoViewSwitch = (0 != (CPVIEW_EF_NOVIEWSWITCH & dwFlags));

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_CPANEL,  g_rgpLink_Cpl_SwToClassicView, bNoViewSwitch, true  },
        { eCPWVTYPE_SEEALSO, g_rgpLink_Cpl_SeeAlso,         false,         false }
        }; 

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite,
                                                     rgItems,
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::EnumWebViewInfo", hr);
    return THR(hr);
}


STDMETHODIMP
CCplNamespace::EnumClassicWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::EnumClassicWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    const bool bNoViewSwitch = (0 != (CPVIEW_EF_NOVIEWSWITCH & dwFlags));

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_CPANEL,  g_rgpLink_Cpl_SwToCategoryView, bNoViewSwitch, true  },
        { eCPWVTYPE_SEEALSO, g_rgpLink_Cpl_SeeAlso,          false,         false }
        }; 

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite, 
                                                     rgItems, 
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::EnumClassicWebViewInfo", hr);
    return THR(hr);
}
    

STDMETHODIMP
CCplNamespace::GetCategory(
    eCPCAT eCategory, 
    ICplCategory **ppcat
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::GetCategory");
    TraceMsg(FTF_CPANEL, "Category ID = %d", eCategory);

    ASSERT(S_OK == _IsValidCategoryID(eCategory));
    ASSERT(NULL != ppcat);
    ASSERT(!IsBadWritePtr(ppcat, sizeof(*ppcat)));

    HRESULT hr = S_OK;

    *ppcat = NULL;

    if (NULL == m_rgpCategories[eCategory])
    {
        hr = CCplCategory::CreateInstance(g_rgpCplCatInfo[eCategory], 
                                          m_rgCplApplets[eCategory], 
                                          IID_ICplCategory, 
                                          (void **)&m_rgpCategories[eCategory]);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != CObjectWithSite::_punkSite);
            hr = IUnknown_SetSite(m_rgpCategories[eCategory], CObjectWithSite::_punkSite);
        }
    }
    if (SUCCEEDED(hr))
    {
        *ppcat = m_rgpCategories[eCategory];
        (*ppcat)->AddRef();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::GetCategory", hr);
    return THR(hr);
}


STDMETHODIMP
CCplNamespace::RefreshIDs(
    IEnumIDList *penumIDs
    )
{
    return _SetIDList(penumIDs);
}


BOOL CCplNamespace::IsX86(void)
{
#ifdef _X86_
    return true;
#else
    return false;
#endif
}


BOOL CCplNamespace::IsServer(void)
{
    if (m_SkuSvr.IsInvalid())
    {
        m_SkuSvr = !!IsOsServer();
    }
    return m_SkuSvr;
}

BOOL CCplNamespace::IsPersonal(void)
{
    if (m_SkuPer.IsInvalid())
    {
        m_SkuPer = !!IsOsPersonal();
    }
    return m_SkuPer;
}

BOOL CCplNamespace::IsProfessional(void)
{
    if (m_SkuPro.IsInvalid())
    {
        m_SkuPro = !!IsOsProfessional();
    }
    return m_SkuPro;
}

BOOL CCplNamespace::IsOnDomain(void)
{
    if (m_Domain.IsInvalid())
    {
        m_Domain = !!IsConnectedToDomain();
    }
    return m_Domain;
}

BOOL CCplNamespace::IsUserAdmin(void)
{
    if (m_Admin.IsInvalid())
    {
        m_Admin = !!CPL::IsUserAdmin();
    }
    return m_Admin;
}

BOOL CCplNamespace::IsUserOwner(void)
{
    return _UserAcctType(&m_UserOwner);
}

BOOL CCplNamespace::IsUserStandard(void)
{
    return _UserAcctType(&m_UserStandard);
}

BOOL CCplNamespace::IsUserLimited(void)
{
    return _UserAcctType(&m_UserLimited);
}

BOOL CCplNamespace::IsUserGuest(void)
{
    return _UserAcctType(&m_UserGuest);
}

BOOL CCplNamespace::UsePersonalUserManager(void)
{
    if (m_PersonalUserManager.IsInvalid())
    {
        m_PersonalUserManager = (IsX86() && (IsPersonal() || (IsProfessional() && !IsOnDomain())));
    }
    return m_PersonalUserManager;
}

BOOL CCplNamespace::AllowUserManager(void)
{
    if (m_AllowUserManager.IsInvalid())
    {
        m_AllowUserManager = IsAppletEnabled(L"nusrmgr.cpl", MAKEINTRESOURCEW(IDS_CPL_USERACCOUNTS));
    }
    return m_AllowUserManager;
}


BOOL CCplNamespace::_AllowDeskCplTab(eDESKCPLTAB eTab)
{
    if (m_rgAllowDeskCplTabs[eTab].IsInvalid())
    {
        m_rgAllowDeskCplTabs[eTab] = DeskCPL_IsTabPresent(eTab);
    }
    return m_rgAllowDeskCplTabs[eTab];
}

BOOL CCplNamespace::AllowDeskCplTab_Background(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_BACKGROUND);
}

BOOL CCplNamespace::AllowDeskCplTab_Screensaver(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_SCREENSAVER);
}

BOOL CCplNamespace::AllowDeskCplTab_Appearance(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_APPEARANCE);
}

BOOL CCplNamespace::AllowDeskCplTab_Settings(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_SETTINGS);
}


BOOL CCplNamespace::AllowDeskCpl(void)
{
    if (m_AllowDeskCpl.IsInvalid())
    {
        m_AllowDeskCpl = IsAppletEnabled(L"desk.cpl", MAKEINTRESOURCEW(IDS_CPL_DISPLAY));
    }
    return m_AllowDeskCpl;
}

//
// Retrieves the account type for the current user and updates
// the cached account type members accordingly.
//
void 
CCplNamespace::_GetUserAccountType(void)
{
    eACCOUNTTYPE eType;
    if (SUCCEEDED(THR(CPL::GetUserAccountType(&eType))))
    {
        m_UserLimited  = (eACCOUNTTYPE_LIMITED == eType);
        m_UserStandard = (eACCOUNTTYPE_STANDARD == eType);
        m_UserGuest    = (eACCOUNTTYPE_GUEST == eType);
        m_UserOwner    = (eACCOUNTTYPE_OWNER == eType);
    }
}

//
// Determins the state of a given account type member.
//
BOOL 
CCplNamespace::_UserAcctType(CTriState *pts)
{
    if (pts->IsInvalid())
    {
        _GetUserAccountType();
    }
    return *pts;
}


HRESULT
CCplNamespace::_IsValidCategoryID(
    int iCategory
    ) const
{
    HRESULT hr = E_FAIL;
    if (0 <= iCategory && ARRAYSIZE(m_rgpCategories) > iCategory)
    {
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT
CCplNamespace::_Initialize(
    IEnumIDList *penumIDs
    )
{
    ASSERT(NULL != penumIDs);

    HRESULT hr = _SetIDList(penumIDs);
    return THR(hr);
}


HRESULT
CCplNamespace::_SetIDList(
    IEnumIDList *penumIDs
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_SetIDList");

    ASSERT(NULL != penumIDs);
    
    ATOMICRELEASE(m_penumIDs);
    (m_penumIDs = penumIDs)->AddRef();
    //
    // We have a new set of IDs so we need to re-categorize them.
    //
    HRESULT hr = _CategorizeCplApplets();

    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_SetIDList");
    return THR(hr);
}    


//
// Destroy all category objects in our array of categories.
//
void
CCplNamespace::_DestroyCategories(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_DestroyCategories");

    for (int i = 0; i < ARRAYSIZE(m_rgpCategories); i++)
    {
        ATOMICRELEASE(m_rgpCategories[i]);
    }
    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_DestroyCategories");
}


void
CCplNamespace::_ClearCplApplets(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_ClearCplApplets");

    for (int i = 0; i < ARRAYSIZE(m_rgCplApplets); i++)
    {
        m_rgCplApplets[i].Clear();
    }
    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_ClearCplApplets");
}

//
// Load and categorize all of the CPL applets in the Control Panel folder.
//
HRESULT 
CCplNamespace::_CategorizeCplApplets(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_CategorizeCplApplets");
    //
    // Destroy any existing categories and CPL applets that we have
    // already categorized.
    //
    _DestroyCategories();
    _ClearCplApplets();
    
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2Cpanel;
            hr = psfDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder2, (void **)&psf2Cpanel);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlItem;
                ULONG celt = 0;
                while(S_OK == (hr = m_penumIDs->Next(1, &pidlItem, &celt)))
                {
                    //
                    // Note that we continue the enumeration if loading a 
                    // particular applet fails.
                    //
                    _CategorizeCplApplet(psf2Cpanel, pidlItem);
                    ILFree(pidlItem);
                }
                psf2Cpanel->Release();
            }
            psfDesktop->Release();
        }
        ILFree(pidlFolder);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::_CategorizeCplApplets", hr);
    return THR(hr);
}



//
// Load one CPL applet into the category's DPA of associated CPL applets.
//
HRESULT
CCplNamespace::_CategorizeCplApplet(
    IShellFolder2 *psf2Cpanel,
    LPCITEMIDLIST pidlItem
    )
{
    ASSERT(NULL != psf2Cpanel);
    ASSERT(NULL != pidlItem);

    SHCOLUMNID scid = SCID_CONTROLPANELCATEGORY;
    VARIANT var;
    VariantInit(&var);
    DWORD dwCategoryID = 0;  // The default. 0 == "other CPLs" category

    HRESULT hr = psf2Cpanel->GetDetailsEx(pidlItem, &scid, &var);
    if (SUCCEEDED(hr))
    {
        dwCategoryID = var.lVal;
    }
    //
    // -1 is a special category ID meaning "don't categorize".
    //
    if (DWORD(-1) != dwCategoryID)
    {
        IUICommand *pc;
        hr = Create_CplUiCommandOnPidl(pidlItem, IID_IUICommand, (void **)&pc);
        if (SUCCEEDED(hr))
        {
            if (-1 == m_rgCplApplets[dwCategoryID].Append(pc))
            {
                pc->Release();
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return THR(hr);
}



HRESULT
CPL::CplNamespace_CreateInstance(
    IEnumIDList *penumIDs,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    HRESULT hr = CCplNamespace::CreateInstance(penumIDs, riid, ppvOut);
    return THR(hr);
}


HRESULT
CPL::CplNamespace_GetCategoryAppletCount(
    ICplNamespace *pns,
    eCPCAT eCategory,
    int *pcApplets
    )
{
    ASSERT(NULL != pns);
    ASSERT(NULL != pcApplets);
    ASSERT(!IsBadWritePtr(pcApplets, sizeof(*pcApplets)));

    *pcApplets = 0;

    ICplCategory *pCategory;
    HRESULT hr = pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        IEnumUICommand *peuic;
        hr = pCategory->EnumCplApplets(&peuic);
        if (SUCCEEDED(hr))
        {
            IUICommand *puic;
            while(S_OK == (hr = peuic->Next(1, &puic, NULL)))
            {
                puic->Release();
                (*pcApplets)++;
            }
            peuic->Release();
        }
        pCategory->Release();
    }
    return hr;
}



} // namespace CPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpuiele.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpuiele.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_UIELEMENT_H
#define __CONTROLPANEL_UIELEMENT_H


#include <cowsite.h>
#include "cpaction.h"


namespace CPL {

//
// Extension of IUICommand to include the activation of a context menu and
// passing of an IShellBrowser ptr for command invocation.
//
class ICpUiCommand : public IUnknown
{
    public:
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt) PURE;
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite) PURE;
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj) PURE;
};


//
// Internal interface for obtaining element information.
// Very similar to IUIElementInfo but returns the actual display 
// information rather than a resource identifier string.  Used internally
// only by the Control Panel code.
//
class ICpUiElementInfo : public IUnknown
{
    public:
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon) PURE;
        STDMETHOD(LoadName)(LPWSTR *ppszName) PURE;
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip) PURE;
};



HRESULT 
Create_CplUiElement(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    REFIID riid,
    void **ppvOut);


HRESULT
Create_CplUiCommand(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    const IAction *pAction,
    REFIID riid,
    void **ppvOut);


HRESULT 
Create_CplUiCommandOnPidl(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut);


} // namespace CPL

#endif //__CONTROLPANEL_UIELEMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cputil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cputil.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cputil.h"

    

HRESULT 
CPL::ResultFromLastError(
    void
    )
{
    const DWORD dwError = GetLastError();
    return HRESULT_FROM_WIN32(dwError);
}


//
//  Loads a string based upon the description.
//    Example:  shell32,42
//
//  lpStrDesc - contains the string description
//
HRESULT
CPL::LoadStringFromResource(
    LPCWSTR pszStrDesc,
    LPWSTR *ppszOut
    )
{
    ASSERT(NULL != pszStrDesc);
    ASSERT(NULL != ppszOut);
    ASSERT(!IsBadWritePtr(ppszOut, sizeof(*ppszOut)));

    *ppszOut = NULL;
    
    WCHAR szFile[MAX_PATH];
    lstrcpynW(szFile, pszStrDesc, ARRAYSIZE(szFile)); // the below writes this buffer

    int iStrID = PathParseIconLocationW(szFile);
    if (iStrID < 0)
    {
        iStrID = -iStrID; // support ",-id" syntax
    }

    HRESULT hr;
    HMODULE hLib = LoadLibraryExW(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hLib)
    {
        WCHAR szTemp[INFOTIPSIZE]; // INFOTIPSIZE is the largest string type we're expected to load
        if (0 < LoadStringW(hLib, (UINT)iStrID, szTemp, ARRAYSIZE(szTemp)))
        {
            hr = SHStrDup(szTemp, ppszOut);
        }
        else
        {
            hr = CPL::ResultFromLastError();
        }
        FreeLibrary(hLib);
    }
    else
    {
        hr = CPL::ResultFromLastError();
    }

    return THR(hr);
}




//
//  Loads a bitmap based upon the description.
//    Example:  shell32,-42
//
//  lpBitmapDesc - contains the bitmap description
//  hInstTheme   - instance handle of theme dll
//
HRESULT
CPL::LoadBitmapFromResource(
    LPCWSTR pszBitmapDesc, 
    HINSTANCE hInstTheme, 
    UINT uiLoadFlags,
    HBITMAP *phBitmapOut
    )
{
    ASSERT(NULL != pszBitmapDesc);
    ASSERT(NULL != phBitmapOut);
    ASSERT(!IsBadWritePtr(phBitmapOut, sizeof(*phBitmapOut)));

    HRESULT hr = E_FAIL;
    HBITMAP hBitmap = NULL;

    WCHAR szFile[MAX_PATH];
    lstrcpynW(szFile, pszBitmapDesc, ARRAYSIZE(szFile)); // the below writes this buffer

    int iBitmapID = PathParseIconLocationW(szFile);
    if (iBitmapID < 0)
    {
        iBitmapID = -iBitmapID; // support ",-id" syntax
    }

    // Load the module to get the bitmap from
    HMODULE hLib = LoadLibraryExW(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hLib)
    {
        hBitmap = (HBITMAP)LoadImage(hLib, MAKEINTRESOURCE(iBitmapID), IMAGE_BITMAP, 0, 0, uiLoadFlags);
        if (NULL != hBitmap)
        {
            hr = S_OK;
        }
        else
        {
            hr = CPL::ResultFromLastError();
        }
        FreeLibrary(hLib);
    }
    else
    {
        // if loadlibrary failed to find the dll, try loading the bitmap from the
        // theme dll
        hBitmap = (HBITMAP)LoadImage(hInstTheme, MAKEINTRESOURCE(iBitmapID), IMAGE_BITMAP, 0, 0, uiLoadFlags);
        if (NULL != hBitmap)
        {
            hr = S_OK;
        }
        else
        {
            hr = CPL::ResultFromLastError();
        }
    }
    *phBitmapOut = hBitmap;

    return THR(hr);
}


//
// Shell icon functions deal in terms of "small" and "large" icons.  
// This function determines which should be used for a 
// given eCPIMGSIZE value.
//
bool
CPL::ShouldUseSmallIconForDesiredSize(
    eCPIMGSIZE eSize
    )
{
    UINT cx;
    UINT cy;
    ImageDimensionsFromDesiredSize(eSize, &cx, &cy);

    if (int(cx) <= GetSystemMetrics(SM_CXSMICON))
    {
        return true;
    }
    return false;
}


//
// This function returns a eCPIMGSIZE value to pixel dimensions.
// This indirection lets us specify image sizes in abstract terms
// then convert to physical pixel dimensions when required.  If 
// you want to change the size of images used for a particular 
// Control Panel UI item type, this is where you change it.
//
void
CPL::ImageDimensionsFromDesiredSize(
    eCPIMGSIZE eSize,
    UINT *pcx,
    UINT *pcy
    )
{
    ASSERT(NULL != pcx);
    ASSERT(!IsBadWritePtr(pcx, sizeof(*pcx)));
    ASSERT(NULL != pcy);
    ASSERT(!IsBadWritePtr(pcy, sizeof(*pcy)));
    
    *pcx = *pcy = 0;

    //
    // This table converts eCPIMGSIZE values into actual
    // image size values.  A couple of things to note:
    //
    // 1. If you want to change the image size associated with
    //    an eIMGSIZE value, simply change these numbers.
    //
    // 2. If actual image size is dependent upon some system
    //    configuration parameter, do the interpretation of
    //    that parameter here making the size a function
    //    of that parameter.
    //
    static const SIZE rgSize[] = {
        { 16, 16 },          // eCPIMGSIZE_WEBVIEW
        { 16, 16 },          // eCPIMGSIZE_TASK
        { 48, 48 },          // eCPIMGSIZE_CATEGORY
        { 32, 32 },          // eCPIMGSIZE_BANNER
        { 32, 32 }           // eCPIMGSIZE_APPLET
        };

    ASSERT(int(eSize) >= 0 && int(eSize) < ARRAYSIZE(rgSize));
    
    *pcx = rgSize[eSize].cx;
    *pcy = rgSize[eSize].cy;
}
    


HRESULT
CPL::LoadIconFromResourceID(
    LPCWSTR pszModule,
    int idIcon,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszModule);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));
    ASSERT(0 < idIcon);

    HRESULT hr      = E_FAIL;
    HICON hIcon     = NULL;
    HMODULE hModule = LoadLibraryExW(pszModule, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hModule)
    {
        UINT cxIcon;
        UINT cyIcon;

        ImageDimensionsFromDesiredSize(eSize, &cxIcon, &cyIcon);

        hIcon = (HICON)LoadImage(hModule,
                                 MAKEINTRESOURCE(idIcon),
                                 IMAGE_ICON,
                                 cxIcon,
                                 cyIcon,
                                 0);

        if (NULL != hIcon)
        {
            hr = S_OK;
        }
        else
        {
            hr = CPL::ResultFromLastError();
        }
        FreeLibrary(hModule);
    }
    else
    {
        hr = CPL::ResultFromLastError();
    }

    *phIcon = hIcon;
    return THR(hr);
}



HRESULT
CPL::LoadIconFromResourceIndex(
    LPCWSTR pszModule,
    int iIcon,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszModule);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    if (-1 == iIcon)
    {
        //
        // Special case.  -1 is an invalid icon index/id.
        //
        iIcon = 0;
    }

    HICON hIcon = NULL;
    HRESULT hr = E_FAIL;
    if (CPL::ShouldUseSmallIconForDesiredSize(eSize))
    {
        if (0 < ExtractIconExW(pszModule, iIcon, NULL, &hIcon, 1))
        {
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ERROR, "ExtractIconEx failed for small icon (index %d) in module \"%s\"", iIcon, pszModule);
        }
    }
    else
    {
        if (0 < ExtractIconExW(pszModule, iIcon, &hIcon, NULL, 1))
        {
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ERROR, "ExtractIconEx failed for large icon (index %d) in module \"%s\"", iIcon, pszModule);
        }
    }
    *phIcon = hIcon;
    return THR(hr);
}



HRESULT
CPL::LoadIconFromResource(
    LPCWSTR pszResource,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszResource);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    *phIcon = NULL;

    //
    // PathParseIconLocation modifies it's input string.
    //
    WCHAR szResource[MAX_PATH];
    lstrcpynW(szResource, pszResource, ARRAYSIZE(szResource));

    HRESULT hr = E_FAIL;
    int idIcon = PathParseIconLocationW(szResource);
    if (-1 == idIcon)
    {
        //
        // Special case.  -1 is an invalid icon ID.
        //
        idIcon = 0;
    }

    if (0 > idIcon)
    {
        hr = CPL::LoadIconFromResourceID(szResource, -idIcon, eSize, phIcon);
    }
    else
    {
        hr = CPL::LoadIconFromResourceIndex(szResource, idIcon, eSize, phIcon);
    }
    return THR(hr);
}



HRESULT
CPL::ExtractIconFromPidl(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != psf);
    ASSERT(NULL != pidl);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    *phIcon = NULL;

    IExtractIcon *pei;
    HRESULT hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_IExtractIcon, NULL, (void **)&pei);
    if (SUCCEEDED(hr))
    {
        TCHAR szFile[MAX_PATH];
        INT iIcon;
        UINT uFlags = 0;
        hr = pei->GetIconLocation(GIL_FORSHELL, 
                                  szFile, 
                                  ARRAYSIZE(szFile), 
                                  &iIcon, 
                                  &uFlags);
        if (SUCCEEDED(hr))
        {
            if (0 == (GIL_NOTFILENAME & uFlags))
            {
                hr = CPL::LoadIconFromResourceIndex(szFile, iIcon, eSize, phIcon);
            }
            else
            {
                HICON hIconLarge = NULL;
                HICON hIconSmall = NULL;

                const int cxIcon   = GetSystemMetrics(SM_CXICON);
                const int cxSmIcon = GetSystemMetrics(SM_CXSMICON);
                
                hr = pei->Extract(szFile, 
                                  iIcon, 
                                  &hIconLarge, 
                                  &hIconSmall, 
                                  MAKELONG(cxIcon, cxSmIcon));
                if (SUCCEEDED(hr))
                {
                    if (CPL::ShouldUseSmallIconForDesiredSize(eSize))
                    {
                        *phIcon = hIconSmall;
                        hIconSmall = NULL;
                    }
                    else
                    {
                        *phIcon = hIconLarge;
                        hIconLarge = NULL;
                    }
                }
                //
                // Destroy any icons not being returned.
                //
                if (NULL != hIconSmall)
                {
                    DestroyIcon(hIconSmall);
                }
                if (NULL != hIconLarge)
                {
                    DestroyIcon(hIconLarge);
                }
            }
        }
        pei->Release();
    }
    ASSERT(FAILED(hr) || NULL != *phIcon);
    if (NULL == *phIcon)
    {
        //
        // If by-chance a NULL icon handle is retrieved, we don't
        // want to return a success code.
        //
        hr = E_FAIL;
    }
    return THR(hr);
}




//  Checks the given restriction.  Returns TRUE (restricted) if the
//  specified key/value exists and is non-zero, false otherwise
BOOL
DeskCPL_CheckRestriction(
    HKEY hKey,
    LPCWSTR lpszValueName
    )
{
    ASSERT(NULL != lpszValueName);

    DWORD dwData;
    DWORD dwSize = sizeof(dwData);
    
    if ((ERROR_SUCCESS == RegQueryValueExW(hKey,
                                           lpszValueName,
                                           NULL,
                                           NULL,
                                           (BYTE *)&dwData,
                                           &dwSize))
          && dwData)
    {        
        return TRUE;
    }
    return FALSE;
}


//
// Function returns the actual tab index given the default tab index.
// The actual tab index will be different than the default value if there are
// various system policies in effect which disable some tabs
//
// 
// To add further restrictions, modify the aTabMap to include the default tab
// index and the corresponding policy. Also, you should keep the eDESKCPLTAB enum
// in sync with the aTabMap array.
//
//
int
CPL::DeskCPL_GetTabIndex(
    CPL::eDESKCPLTAB iTab,
    OPTIONAL LPWSTR pszCanonicalName,
    OPTIONAL DWORD cchSize
    )
{
    HKEY hKey;
    int iTabActual = CPL::CPLTAB_ABSENT;

    if (iTab >= 0 && iTab < CPL::CPLTAB_DESK_MAX)
    {
        //
        // While adding more tabs, make sure that it is entered in the right position in the
        // the array below. So, for example, if the default tab index of the new tab is 2, it 
        // should be the aTabMap[2] entry (Currently CPLTAB_DESK_APPEARANCE is 
        // the one with tab index = 2). You will have to modify eDESKCPLTAB accordingly too.
        //
        struct 
        {
            int nIndex; // the canonical name of the tab (don't use indexes because they change with policies or revs)
            LPCWSTR pszCanoncialTabName; // the canonical name of the tab (don't use indexes because they change with policies or revs)
            LPCWSTR pszRestriction; // corresponding restriction
        } aTabMap[CPL::CPLTAB_DESK_MAX] = { 
            { 0, SZ_DISPLAYCPL_OPENTO_DESKTOP, REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE },   // CPLTAB_DESK_BACKGROUND == 0
            { 1, SZ_DISPLAYCPL_OPENTO_SCREENSAVER, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE     },   // CPLTAB_DESK_SCREENSAVER == 1
            { 2, SZ_DISPLAYCPL_OPENTO_APPEARANCE, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE },   // CPLTAB_DESK_APPEARANCE == 2
            { 3, SZ_DISPLAYCPL_OPENTO_SETTINGS, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE   }    // CPLTAB_DESK_SETTINGS == 3
            };

#ifdef DEBUG
        //
        // Verify proper initialization of the nIndex member of aTabMap[]
        //
        for (int k=0; k < ARRAYSIZE(aTabMap); k++)
        {
            ASSERT(aTabMap[k].nIndex == k);
        }
#endif

        iTabActual = aTabMap[iTab].nIndex;

        //
        // Note, if no policy is configured, the RegOpenKey call below will fail,
        // in that case we return the default tab value, as entered in the 
        // map above.
        //
        if ((ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER,
                                            REGSTR_PATH_POLICIES L"\\" REGSTR_KEY_SYSTEM,
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKey)))
        {
            //
            // check all tabs to see if there is restriction
            //
            if (DeskCPL_CheckRestriction(hKey, aTabMap[iTab].pszRestriction))
            {
                // this tab does not exist, mark it as such
                iTabActual = CPL::CPLTAB_ABSENT;
            }

            RegCloseKey(hKey);
        }

        if (pszCanonicalName &&
            (iTab >= 0) && (iTab < ARRAYSIZE(aTabMap)))
        {
            StrCpyN(pszCanonicalName, aTabMap[iTab].pszCanoncialTabName, cchSize);
        }
    }
    return iTabActual;
}


bool 
CPL::DeskCPL_IsTabPresent(
    eDESKCPLTAB iTab
    )
{
    return CPLTAB_ABSENT != DeskCPL_GetTabIndex(iTab, NULL, 0);
}




//////////////////////////////////////////////////////////////
//
//  Policy checking routines
//
//////////////////////////////////////////////////////////////

#define REGSTR_POLICIES_RESTRICTCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictCpl")
#define REGSTR_POLICIES_DISALLOWCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowCpl")


//
// Returns true if the specified app is listed under the specified key
//
// pszFileName can be a string resource ID in shell32 for things
// like "Fonts", "Printers and Faxes" etc.
//
//   i.e. IsNameListedUnderKey(MAKEINTRESOURCE(IDS_MY_APPLET_TITLE), hkey);
//
// In this case, if the resource string cannot be loaded, the function
// returns 'false'.
//
bool
IsNameListedUnderKey(
    LPCWSTR pszFileName, 
    LPCWSTR pszKey
    )
{
    bool bResult = FALSE;
    HKEY hkey;
    TCHAR szName[MAX_PATH];

    if (IS_INTRESOURCE(pszFileName))
    {
        //
        // The name is localized so we specify it as a string resource ID.
        // Load it from shell32.dll.
        //
        if (0 < LoadString(HINST_THISDLL, PtrToUint(pszFileName), szName, ARRAYSIZE(szName)))
        {
            pszFileName = szName;
        }
        else
        {
            //
            // If the load fails spit out a debug squirty and return false.
            //
            TW32(GetLastError());
            return false;
        }
    }
    
    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, 
                                       pszKey,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hkey))
    {
        int iValue = 0;
        WCHAR szValue[MAX_PATH];
        WCHAR szData[MAX_PATH];
        DWORD dwType, cbData, cchValue;

        while (cbData = sizeof(szData),
               cchValue = ARRAYSIZE(szValue),
               ERROR_SUCCESS == RegEnumValue(hkey, 
                                             iValue, 
                                             szValue, 
                                             &cchValue, 
                                             NULL, 
                                             &dwType,
                                             (LPBYTE) szData, 
                                             &cbData))
        {
            if (0 == lstrcmpiW(szData, pszFileName))
            {
                bResult = true;
                break;
            }
            iValue++;
        }
        RegCloseKey(hkey);
    }
    return bResult;
}


//
// Method cloned from shell32\ctrlfldr.cpp (DoesCplPolicyAllow)
//
// pszName can be a string resource ID in shell32 for things
// like "Fonts", "Printers and Faxes" etc.
//
//   i.e. IsAppletEnabled(NULL, MAKEINTRESOURCE(IDS_MY_APPLET_TITLE));
//
bool
CPL::IsAppletEnabled(
    LPCWSTR pszFileName,
    LPCWSTR pszName
    )
{
    bool bEnabled = true;
    //
    // It's illegal (and meaningless) for both to be NULL.
    // Trap both with an assert and runtime check.  I don't want any
    // code to erroneously think an applet is enabled when it's not.
    //
    ASSERT(NULL != pszName || NULL != pszFileName);
    if (NULL == pszName && NULL == pszFileName)
    {
        bEnabled = false;
    }
    else
    {
        if (SHRestricted(REST_RESTRICTCPL) && 
            ((NULL == pszName || !IsNameListedUnderKey(pszName, REGSTR_POLICIES_RESTRICTCPL)) &&
             (NULL == pszFileName || !IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_RESTRICTCPL))))
        {
            bEnabled = false;
        }
        if (bEnabled)
        {
            if (SHRestricted(REST_DISALLOWCPL) && 
               ((NULL == pszName || IsNameListedUnderKey(pszName, REGSTR_POLICIES_DISALLOWCPL)) ||
                (NULL == pszFileName || IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_DISALLOWCPL))))
            {
                bEnabled = false;
            }    
        }
    }
    return bEnabled;
}    



HRESULT 
CPL::ControlPanelViewFromSite(
    IUnknown *punkSite, 
    ICplView **ppview
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppview);
    ASSERT(!IsBadWritePtr(ppview, sizeof(*ppview)));

    *ppview = NULL;

    HRESULT hr = IUnknown_QueryService(punkSite, SID_SControlPanelView, IID_ICplView, (void **)ppview);
    return THR(hr);
}



HRESULT
CPL::ShellBrowserFromSite(
    IUnknown *punkSite,
    IShellBrowser **ppsb
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppsb);
    ASSERT(!IsBadWritePtr(ppsb, sizeof(*ppsb)));

    *ppsb = NULL;

    HRESULT hr = IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, ppsb));
    return THR(hr);
}



HRESULT
CPL::BrowseIDListInPlace(
    LPCITEMIDLIST pidl,
    IShellBrowser *psb
    )
{
    ASSERT(NULL != pidl);
    ASSERT(NULL != psb);
    
    const UINT uFlags = SBSP_SAMEBROWSER | SBSP_OPENMODE | SBSP_ABSOLUTE;
    HRESULT hr = psb->BrowseObject(pidl, uFlags);            
    return THR(hr);
}


HRESULT
CPL::BrowsePathInPlace(
    LPCWSTR pszPath,
    IShellBrowser *psb
    )
{
    ASSERT(NULL != pszPath);
    ASSERT(NULL != psb);

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl = ILCreateFromPath(pszPath);
    if (NULL != pidl)
    {
        hr = CPL::BrowseIDListInPlace(pidl, psb);
        ILFree(pidl);
    }
    return THR(hr);
}


//
// System Restore is allowed only for admins/owners.
// Also must check policy.
//
bool
CPL::IsSystemRestoreRestricted(
    void
    )
{
    bool bRestricted = false;

    //
    // First check policy.
    //
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);

    DWORD dwResult = SHGetValueW(HKEY_LOCAL_MACHINE,
                                 L"Software\\Policies\\Microsoft\\Windows NT\\SystemRestore",
                                 L"DisableSR",
                                 &dwType,
                                 &dwValue,
                                 &cbValue);

    if (ERROR_SUCCESS == dwResult && REG_DWORD == dwType)
    {
        if (1 == dwValue)
        {
            //
            // Sytem Restore is disabled by policy.
            //
            bRestricted = true;
        }
    }

    if (!bRestricted)
    {
        //
        // Not restricted by policy.  Check for admin/owner.
        //
        if (!CPL::IsUserAdmin())
        {
            //
            // User is not an admin.
            //
            bRestricted = true;
        }
    }
    return bRestricted;
}


#ifdef DEBUG

HRESULT
ReadTestConfigurationFlag(
    LPCWSTR pszValue,
    BOOL *pbFlag
    )
{
    HRESULT hr    = S_OK;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType;

    DWORD dwResult = SHGetValueW(HKEY_CURRENT_USER, 
                                 REGSTR_PATH_CONTROLPANEL,
                                 pszValue,
                                 &dwType,
                                 &dwValue,
                                 &cbValue);

    if (ERROR_SUCCESS != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else if (REG_DWORD != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    if (SUCCEEDED(hr) && NULL != pbFlag)
    {
        if (0 == dwValue)
        {
            *pbFlag = FALSE;
        }
        else 
        {
            *pbFlag = TRUE;
        }
    }
    return hr;
}

enum eSKU
{
    eSKU_SERVER,
    eSKU_PROFESSIONAL,
    eSKU_PERSONAL,
    eSKU_NUMSKUS
};


HRESULT
ReadTestConfigurationSku(
    eSKU *peSku
    )
{
    HRESULT hr = S_OK;
    WCHAR szValue[MAX_PATH];
    DWORD cbValue = sizeof(szValue);
    DWORD dwType;

    DWORD dwResult = SHGetValueW(HKEY_CURRENT_USER, 
                                 REGSTR_PATH_CONTROLPANEL,
                                 L"SKU",
                                 &dwType,
                                 szValue,
                                 &cbValue);

    if (ERROR_SUCCESS != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else if (REG_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    if (SUCCEEDED(hr) && NULL != peSku)
    {
        static const struct
        {
            LPCWSTR pszValue;
            eSKU    sku;

        } rgMap[] = {
            { L"personal",     eSKU_PERSONAL     },
            { L"professional", eSKU_PROFESSIONAL },
            { L"pro",          eSKU_PROFESSIONAL },
            { L"server",       eSKU_SERVER       }
            };

        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(rgMap); i++)
        {
            if (0 == lstrcmpiW(rgMap[i].pszValue, szValue))
            {
                *peSku = rgMap[i].sku;
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}


#endif



BOOL
CPL::IsOsServer(
    void
    )
{
    BOOL bServer = IsOS(OS_ANYSERVER);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bServer = (eSKU_SERVER == sku);
    }
#endif

    return bServer;
}



BOOL
CPL::IsOsPersonal(
    void
    )
{
    BOOL bPersonal = IsOS(OS_PERSONAL);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bPersonal = (eSKU_PERSONAL == sku);
    }
#endif

    return bPersonal;
}


BOOL 
CPL::IsOsProfessional(
    void
    )
{
    BOOL bProfessional = IsOS(OS_PROFESSIONAL);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bProfessional = (eSKU_PROFESSIONAL == sku);
    }
#endif

    return bProfessional;
}



BOOL 
CPL::IsConnectedToDomain(
    void
    )
{
    BOOL bDomain = IsOS(OS_DOMAINMEMBER);

#ifdef DEBUG
    ReadTestConfigurationFlag(L"Domain", &bDomain);
#endif

    return bDomain;
}



BOOL 
CPL::IsUserAdmin(
    void
    )
{
    BOOL bAdmin = ::IsUserAnAdmin();

#ifdef DEBUG
    ReadTestConfigurationFlag(L"Admin", &bAdmin);
#endif

    return bAdmin;
}


HRESULT
CPL::GetUserAccountType(
    eACCOUNTTYPE *pType
    )
{
    ASSERT(NULL != pType);
    ASSERT(!IsBadWritePtr(pType, sizeof(*pType)));

    HRESULT hr = E_FAIL;
    eACCOUNTTYPE acctype = eACCOUNTTYPE_UNKNOWN;

    static const struct
    {
        DWORD        rid;    // Account relative ID.
        eACCOUNTTYPE eType;  // Type code to return.

    } rgMap[] = {
        { DOMAIN_ALIAS_RID_ADMINS,      eACCOUNTTYPE_OWNER    },
        { DOMAIN_ALIAS_RID_POWER_USERS, eACCOUNTTYPE_STANDARD },
        { DOMAIN_ALIAS_RID_USERS,       eACCOUNTTYPE_LIMITED  },
        { DOMAIN_ALIAS_RID_GUESTS,      eACCOUNTTYPE_GUEST    }
        };

    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        if (SHTestTokenMembership(NULL, rgMap[i].rid))
        {
            acctype = rgMap[i].eType;
            hr = S_OK;
            break;
        }
    }
    ASSERT(eACCOUNTTYPE_UNKNOWN != acctype);
    *pType = acctype;
    return THR(hr);
}

    
//
// Create a URL to pass to HSS help.
// The URL created references the Control_Panel help topic.
//
HRESULT
CPL::BuildHssHelpURL(
    LPCWSTR pszSelect,  // Optional.  NULL == base CP help.
    LPWSTR pszURL,
    UINT cchURL
    )
{
    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    ASSERT(NULL == pszSelect || !IsBadStringPtr(pszSelect, UINT(-1)));

    //
    // HSS has specific help content for 'limited' users.
    // Default to a non-limited user.
    //
    bool bLimitedUser = false;
    CPL::eACCOUNTTYPE accType;
    if (SUCCEEDED(CPL::GetUserAccountType(&accType)))
    {
        bLimitedUser = (eACCOUNTTYPE_LIMITED == accType);
    }
   
    WCHAR szSelect[160];
    szSelect[0] = L'\0';
    if (NULL != pszSelect)
    {
        wnsprintf(szSelect, ARRAYSIZE(szSelect), L"&select=Unmapped/Control_Panel/%s", pszSelect);
    }
    
    //
    // The URL can take one of 4 forms depending upon the category and account type.
    //
    // User Account     CP View          Help Content Displayed
    // ---------------- ---------------- -----------------------
    // Non-limited      Category choice  General CP help
    // Non-limited      Category         Category-specific help
    // Limited          Category choice  General CP help
    // Limited          Category         Category-specific help
    //
    wnsprintf(pszURL, 
              cchURL, 
              L"hcp://services/subsite?node=Unmapped/%sControl_Panel&topic=MS-ITS%%3A%%25HELP_LOCATION%%25%%5Chs.chm%%3A%%3A/hs_control_panel.htm%s", 
              bLimitedUser ? L"L/" : L"",
              szSelect);

    return S_OK;
}



HRESULT 
CPL::GetControlPanelFolder(
    IShellFolder **ppsf
    )
{
    ASSERT(NULL != ppsf);
    ASSERT(!IsBadWritePtr(ppsf, sizeof(*ppsf)));

    *ppsf = NULL;
    
    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            hr = psfDesktop->BindToObject(pidlCpanel, NULL, IID_IShellFolder, (void **)ppsf);
            ATOMICRELEASE(psfDesktop);
        }
        ILFree(pidlCpanel);
    }
    return THR(hr);
}


//
// On successful return, caller is responsible for freeing 
// returned buffer using LocalFree.
//
HRESULT 
CPL::ExpandEnvironmentVars(
    LPCTSTR psz, 
    LPTSTR *ppszOut
    )
{
    ASSERT(NULL != psz);
    ASSERT(NULL != ppszOut);
    ASSERT(!IsBadWritePtr(ppszOut, sizeof(*ppszOut)));

    HRESULT hr = E_FAIL;
    
    *ppszOut = NULL;

    TCHAR szDummy[1];
    DWORD dwResult = ExpandEnvironmentStrings(psz, szDummy, 0);
    if (0 < dwResult)
    {
        const DWORD cchRequired = dwResult;
        *ppszOut = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR));
        if (NULL != *ppszOut)
        {
            dwResult = ExpandEnvironmentStrings(psz, *ppszOut, cchRequired);
            if (0 < dwResult)
            {
                ASSERT(dwResult <= cchRequired);
                hr = S_OK;
            }
            else
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (0 == dwResult)
    {
        hr = CPL::ResultFromLastError();
    }
    return THR(hr);
}


//// from sdfolder.cpp
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);


#define REGSTR_POLICIES_EXPLORER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

bool 
CPL::CategoryViewIsActive(
    bool *pbBarricadeFixedByPolicy
    )
{
    DBG_ENTER(FTF_CPANEL, "CPL::CategoryViewIsActive");
    
    bool bActive = false;
    bool bBarricadeFixedByPolicy = false;

    //
    // We don't provide category view when running WOW64.
    //
    if (!IsOS(OS_WOW6432))
    {
        SHELLSTATE ss;
        const DWORD dwMask = SSF_WEBVIEW | SSF_WIN95CLASSIC;
        SHGetSetSettings(&ss, dwMask, FALSE);

        //
        // WebView?     Barricade status   View type
        // -----------  ----------------   ------------------------------
        // Off          On                 Classic view
        // Off          Off                Classic view
        // On           On                 Category view (aka 'simple')
        // On           Off                Classic view
        //
        // Note that these two shellstate settings encompass and are set
        // by the shell restrictions REST_CLASSICSHELL and REST_NOWEBVIEW.
        // Therefore, there is no reason to explicitely check those two restrictions.
        //
        if (ss.fWebView && !ss.fWin95Classic)
        {
            if (VARIANT_TRUE == CPL::GetBarricadeStatus(&bBarricadeFixedByPolicy))
            {
                bActive = true;
            }
        }
    }
    if (NULL != pbBarricadeFixedByPolicy)
    {
        *pbBarricadeFixedByPolicy = bBarricadeFixedByPolicy;
    }
    TraceMsg(TF_CPANEL, "Category view is %s.", bActive ? TEXT("ACTIVE") : TEXT("INACTIVE"));
    DBG_EXIT(FTF_CPANEL, "CPL::CategoryViewIsActive");
    return bActive;
}
    

//
// Control Panel uses the 'barricade status' to determine which view
// 'classic' or 'category' to display.  Yes, this is overloading the
// meaning of 'barricade' as used in the shell.  However, since the
// Control Panel does not use a barricade in it's usual sense, this
// is a reasonable application of the feature.
//
VARIANT_BOOL
CPL::GetBarricadeStatus(
    bool *pbFixedByPolicy    // Optional.  May be NULL.
    )
{
    DBG_ENTER(FTF_CPANEL, "CPL::GetBarricadeStatus");

    VARIANT_BOOL vtb;
    DWORD dwType;
    DWORD dwData;
    DWORD cbData = sizeof(dwData);
    bool bFixedByPolicy = false;
    bool bSetBarricade  = false;
        
    //
    // First handle any OOBE issues.
    //
    if (CPL::IsFirstRunForThisUser())
    {
        TraceMsg(TF_CPANEL, "First time this user has opened Control Panel");
        //
        // Determine the default view to display out-of-box.
        //
        //      Server gets 'classic'.
        //      Non-servers get 'category'.
        //
        if (IsOS(OS_ANYSERVER))
        {
            //
            // Default is 'classic'.
            //
            vtb = VARIANT_FALSE;
            TraceMsg(TF_CPANEL, "Running on server.  Default to 'classic' view Control Panel.");
        }
        else
        {
            //
            // Default is 'category'.
            //
            vtb = VARIANT_TRUE;
            TraceMsg(TF_CPANEL, "Running on non-server.  Default to 'category' view Control Panel.");
        }
        bSetBarricade = true;
    }

    //
    // Apply any 'force view type' policy.  This will override
    // the default out-of-box setting obtained above.
    // 
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_POLICIES_EXPLORER,
                                         TEXT("ForceClassicControlPanel"),
                                         &dwType,
                                         &dwData,
                                         &cbData,
                                         FALSE,
                                         NULL,
                                         0)) 
    {
        //
        // policy exists
        //
        bFixedByPolicy = true;
        if (0 == dwData)
        {
            //
            // force the simple (category) view, ie, show barricade
            //
            vtb = VARIANT_TRUE;
            TraceMsg(TF_CPANEL, "Policy forcing use of 'category' view Control Panel.");
        }
        else
        {
            //
            // force the classic (icon) view, ie, no barricade
            //
            vtb = VARIANT_FALSE;
            TraceMsg(TF_CPANEL, "Policy forcing use of 'classic' view Control Panel.");
        }   
        bSetBarricade = true; 
    }

    if (bSetBarricade)
    {
        THR(CPL::SetControlPanelBarricadeStatus(vtb));
    }

    vtb = ::GetBarricadeStatus(TEXT("shell:ControlPanelFolder"));
    if (NULL != pbFixedByPolicy)
    {
        *pbFixedByPolicy = bFixedByPolicy;
    }

    TraceMsg(TF_CPANEL, "Barricade is %s", VARIANT_TRUE == vtb ? TEXT("ON") : TEXT("OFF"));
    DBG_EXIT(FTF_CPANEL, "CPL::GetBarricadeStatus");
    return vtb;
}


//
// Checks for the existance of the "HKCU\Control Panel\Opened" reg value.
// If this value does not exist or it contains a number less than what
// is expected, we assume the control panel has not been opened by this
// user.  The 'expected' value is then written at this location in the
// registry to indicate to subsequent calls that the user has indeed
// already opened Control Panel.  If future versions of the OS need
// to again trigger this "first run" behavior following upgrades,
// simply increment this expected value in the code below.
//
bool
CPL::IsFirstRunForThisUser(
    void
    )
{
    bool bFirstRun = true; // Assume first run.
    HKEY hkey;
    DWORD dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                                  REGSTR_PATH_CONTROLPANEL,
                                  0,
                                  KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  &hkey);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD dwType;
        DWORD dwData;
        DWORD cbData = sizeof(dwData);

        const TCHAR szValueName[] = TEXT("Opened");
        //
        // Increment this value if you want to re-trigger
        // this 'first run' state on future versions.
        //
        const DWORD dwTestValue = 1;

        dwResult = RegQueryValueEx(hkey, 
                                   szValueName,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwData,
                                   &cbData);

        if (ERROR_SUCCESS == dwResult)
        {
            if (REG_DWORD == dwType && dwData >= dwTestValue)
            {
                bFirstRun = false;
            }
        }
        else if (ERROR_FILE_NOT_FOUND != dwResult)
        {
            TraceMsg(TF_ERROR, "Error %d reading Control Panel 'first run' value from registry", dwResult);
        }

        if (bFirstRun)
        {
            //
            // Write our value so we know user has opened
            // Control Panel.
            //
            dwResult = RegSetValueEx(hkey,
                                     szValueName,
                                     0,
                                     REG_DWORD,
                                     (CONST BYTE *)&dwTestValue,
                                     sizeof(dwTestValue));

            if (ERROR_SUCCESS != dwResult)
            {
                TraceMsg(TF_ERROR, "Error %d writing Control Panel 'first run' value to registry", dwResult);
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error %d opening 'HKCU\\Control Panel' reg key", dwResult);
    }
    return bFirstRun;
}


//
// Use a private version of SetBarricadeStatus so that we don't
// clear the global barricade status whenever we turn on 'category' view
// (i.e. enable our barricade).
//
#define REGSTR_WEBVIEW_BARRICADEDFOLDERS (REGSTR_PATH_EXPLORER TEXT("\\WebView\\BarricadedFolders"))

HRESULT 
CPL::SetControlPanelBarricadeStatus(
    VARIANT_BOOL vtb
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwBarricade = (VARIANT_FALSE == vtb) ? 0 : 1;
  
    if (SHRegSetUSValue(REGSTR_WEBVIEW_BARRICADEDFOLDERS,
                        TEXT("shell:ControlPanelFolder"), 
                        REG_DWORD, 
                        (void *)&dwBarricade, 
                        sizeof(dwBarricade), 
                        SHREGSET_FORCE_HKCU) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    return THR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpuiele.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpuiele.cpp
//
//  This module contains the following classes:
//
//    CCplUiElement
//    CCplUiCommand
//    CCplUiCommandOnPidl
//
//    CCplUiElement is an implementation of IUIElement.  This provides
//    the necessary display information for use in the shell's webview
//    implementation.  The class also implements ICpUiElementInfo which
//    is similar to IUIElement but provides the display information in
//    a more 'final' form than a "<module>,<resource>" format.  
//    The ICpUiElementInfo interface is used internally by the Control Panel
//    implementation.
//
//    CCplUiCommand is an implementation of IUICommand.  As with IUIElement,
//    this provides the necessary functions for communicating with webview
//    as a 'command' object (i.e. selectable 'link').  Also as with the
//    previous class, CCplUiCommand implements an internal version of
//    the public interface.  ICplUiCommand provides two things:
//      1. A method to invoke a context menu.
//      2. An invocation method that accepts a site pointer.  This site
//         pointer is passed along to an 'action' object that may need
//         access to the shell browser to perform it's function.  It
//         obtains access to the shell browser through this site ptr.
//
//    CCplUiCommandOnPidl is another implementation of IUICommand that
//    wraps a shell item ID list.  It is used to represent the CPL
//    applet items in a category view.
//    
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cputil.h"
#include "contextmenu.h"
#include "prop.h"

namespace CPL {


//-----------------------------------------------------------------------------
// CCplUiElement
//-----------------------------------------------------------------------------

class CCplUiElement : public IUIElement,
                      public ICpUiElementInfo
{
    public:
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IUIElement (used by shell webview)
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName);
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);        
        //
        // ICpUiElementInfo (used internally by Control Panel)
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon);
        STDMETHOD(LoadName)(LPWSTR *ppszName);
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip);

        static HRESULT CreateInstance(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, REFIID riid, void **ppvOut);


    protected:
        CCplUiElement(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon);
        CCplUiElement(void);
        virtual CCplUiElement::~CCplUiElement(void);

    private:
        LONG    m_cRef;
        LPCWSTR m_pszName;
        LPCWSTR m_pszInfotip;
        LPCWSTR m_pszIcon;

        HRESULT _GetResourceString(LPCWSTR pszItem, LPWSTR *ppsz);
        HRESULT _GetIconResource(LPWSTR *ppsz);
        HRESULT _GetNameResource(LPWSTR *ppsz);
        HRESULT _GetInfotipResource(LPWSTR *ppsz);
};


CCplUiElement::CCplUiElement(
    LPCWSTR pszName, 
    LPCWSTR pszInfotip,   // NULL == No Info Tip
    LPCWSTR pszIcon
    ) : m_cRef(1),
        m_pszName(pszName),
        m_pszInfotip(pszInfotip),
        m_pszIcon(pszIcon)
{
    ASSERT(IS_INTRESOURCE(m_pszName)    || !IsBadStringPtr(m_pszName, UINT_PTR(-1)));
    ASSERT((NULL == pszInfotip) || IS_INTRESOURCE(m_pszInfotip) || !IsBadStringPtr(m_pszInfotip, UINT_PTR(-1)));
    ASSERT(IS_INTRESOURCE(m_pszIcon)    || !IsBadStringPtr(m_pszIcon, UINT_PTR(-1)));
}


CCplUiElement::CCplUiElement(
    void
    ) : m_cRef(1),
        m_pszName(NULL),
        m_pszInfotip(NULL),
        m_pszIcon(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiElement::CCplUiElement, this = 0x%x", this);
}


CCplUiElement::~CCplUiElement(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiElement::~CCplUiElement, this = 0x%x", this);
    //
    // Note that the member string pointers contain either a resource ID
    // or a pointer to constant memory.
    // Therefore, we do not try to free them.
    //
}


HRESULT 
CCplUiElement::CreateInstance(  // [static]
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiElement *pe = new CCplUiElement(pszName, pszInfotip, pszIcon);
    if (NULL != pe)
    {
        hr = pe->QueryInterface(riid, ppvOut);
        pe->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiElement::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiElement, IUIElement),
        QITABENT(CCplUiElement, ICpUiElementInfo),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplUiElement::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CCplUiElement::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}



STDMETHODIMP
CCplUiElement::get_Name(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszName
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = LoadName(ppszName);
    return THR(hr);
}



STDMETHODIMP
CCplUiElement::get_Icon(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszIcon
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetIconResource(ppszIcon);
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::get_Tooltip(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszInfotip
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);
    HRESULT hr = THR(LoadTooltip(ppszInfotip));
    if (S_FALSE == hr)
    {
        //
        // Tooltips are optional but we need to return a failure
        // code to tell webview that we don't have one.
        //
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP
CCplUiElement::LoadIcon(
    eCPIMGSIZE eSize, 
    HICON *phIcon
    )
{
    *phIcon = NULL;

    LPWSTR pszResource;
    HRESULT hr = _GetIconResource(&pszResource);
    if (SUCCEEDED(hr))
    {
        hr = CPL::LoadIconFromResource(pszResource, eSize, phIcon);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::LoadName(
    LPWSTR *ppszName
    )
{
    LPWSTR pszResource;
    HRESULT hr = _GetNameResource(&pszResource);
    if (SUCCEEDED(hr))
    {
        hr = CPL::LoadStringFromResource(pszResource, ppszName);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::LoadTooltip(
    LPWSTR *ppszTooltip
    )
{
    LPWSTR pszResource;
    HRESULT hr = _GetInfotipResource(&pszResource);
    if (S_OK == hr)
    {
        hr = CPL::LoadStringFromResource(pszResource, ppszTooltip);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


HRESULT 
CCplUiElement::_GetIconResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = _GetResourceString(m_pszIcon, ppsz);
    return THR(hr);
}


HRESULT 
CCplUiElement::_GetNameResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = _GetResourceString(m_pszName, ppsz);
    return THR(hr);
}


//
// Returns S_FALSE if tooltip text is not provided.
// Tooltips are optional.  For example, the "learn about"
// tasks in Control Panel's web view pane do not have tooltip
// text.
//
HRESULT 
CCplUiElement::_GetInfotipResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = S_FALSE;
    if (NULL != m_pszInfotip)
    {
        hr = _GetResourceString(m_pszInfotip, ppsz);
    }
    return THR(hr);
}


//
// On successful return, caller must free returned string using
// CoTaskMemFree.
//
HRESULT
CCplUiElement::_GetResourceString(
    LPCWSTR pszItem,
    LPWSTR *ppsz
    )
{
    ASSERT(NULL != ppsz);
    ASSERT(!IsBadWritePtr(ppsz, sizeof(*ppsz)));

    *ppsz = NULL;
    HRESULT hr = E_FAIL;

    if (IS_INTRESOURCE(pszItem))
    {
        //
        // pszItem is a resource identifier integer.  Create a resource
        // ID string "<module>,<-i>" for the resource.
        //
        WCHAR szModule[MAX_PATH];
        if (GetModuleFileNameW(HINST_THISDLL, szModule, ARRAYSIZE(szModule)))
        {
            *ppsz = (LPWSTR)CoTaskMemAlloc((lstrlenW(szModule) + 15) * sizeof(WCHAR));
            if (NULL != *ppsz)
            {
                //
                // Precede the resource ID with a minus sign so that it will be
                // treated as a resource ID and not an index.
                //
                wsprintfW(*ppsz, L"%s,-%u", szModule, PtrToUint(pszItem));
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = CPL::ResultFromLastError();
        }
    }
    else
    {
        //
        // pszItem is a text string. Assume it's in the form of
        // "<module>,<-i>".  Simply duplicate it.
        //
        ASSERT(!IsBadStringPtr(pszItem, UINT_PTR(-1)));

        hr = SHStrDup(pszItem, ppsz);
    }
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CCplUiCommand
//-----------------------------------------------------------------------------

class CCplUiCommand : public CObjectWithSite,
                      public CCplUiElement,
                      public IUICommand,
                      public ICpUiCommand
                      
{
    public:
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void)
            { return CCplUiElement::AddRef(); }
        STDMETHOD_(ULONG, Release)(void)
            { return CCplUiElement::Release(); }
        //
        // IUICommand
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName)
            { return CCplUiElement::get_Name(psiItemArray, ppszName); }
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
            { return CCplUiElement::get_Icon(psiItemArray, ppszIcon); }
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
            { return CCplUiElement::get_Tooltip(psiItemArray, ppszInfotip); }
        STDMETHOD(get_CanonicalName)(GUID *pguidCommandName);
        STDMETHOD(get_State)(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puisState);
        STDMETHOD(Invoke)(IShellItemArray *psiItemArray, IBindCtx *pbc);       
        //
        // ICpUiCommand
        //
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt);
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite);
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj);
        //
        // ICpUiElementInfo
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon)
            { return CCplUiElement::LoadIcon(eSize, phIcon); }
        STDMETHOD(LoadName)(LPWSTR *ppszName)
            { return CCplUiElement::LoadName(ppszName); }
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip)
            { return CCplUiElement::LoadTooltip(ppszTooltip); }

        static HRESULT CreateInstance(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, const IAction *pAction, REFIID riid, void **ppvOut);

    protected:
        CCplUiCommand(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, const IAction *pAction);
        CCplUiCommand(void);
        ~CCplUiCommand(void);

    private:
        const IAction *m_pAction;

        HRESULT _IsCommandRestricted(void);
};


CCplUiCommand::CCplUiCommand(
    void
    ) : m_pAction(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiCommand::CCplUiCommand, this = 0x%x", this);
}



CCplUiCommand::CCplUiCommand(
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    const IAction *pAction
    ) : CCplUiElement(pszName, pszInfotip, pszIcon),
        m_pAction(pAction)
{
    TraceMsg(TF_LIFE, "CCplUiCommand::CCplUiCommand, this = 0x%x", this);
}


CCplUiCommand::~CCplUiCommand(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiCommand::~CCplUiCommand, this = 0x%x", this);
    //
    // Note that m_pAction is a pointer to a const object.
    // Therefore, we don't try to free it.
    //
}



HRESULT
CCplUiCommand::CreateInstance(  // [static]
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    const IAction *pAction,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiCommand *pc = new CCplUiCommand(pszName, pszInfotip, pszIcon, pAction);
    if (NULL != pc)
    {
        hr = pc->QueryInterface(riid, ppvOut);
        pc->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiCommand::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiCommand, IUICommand),
        QITABENT(CCplUiCommand, ICpUiElementInfo),
        QITABENT(CCplUiCommand, ICpUiCommand),
        QITABENT(CCplUiCommand, IObjectWithSite),
        QITABENTMULTI(CCplUiCommand, IUIElement, IUICommand),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP
CCplUiCommand::get_CanonicalName(
    GUID *pguidCommandName
    )
{
    UNREFERENCED_PARAMETER(pguidCommandName);
    //
    // This function is unimplemented.  It is in IUICommand to
    // support generic functionality in the shell.  This functionality
    // is not applicable to the use of IUICommand in the Control
    // Panel.
    //
    return E_NOTIMPL;
}



STDMETHODIMP
CCplUiCommand::get_State(
    IShellItemArray *psiItemArray, 
    BOOL fOkToBeSlow, 
    UISTATE *puisState
    )
{
    ASSERT(NULL != m_pAction);
    ASSERT(NULL != puisState);
    ASSERT(!IsBadWritePtr(puisState, sizeof(*puisState)));

    UNREFERENCED_PARAMETER(psiItemArray);

    *puisState = UIS_DISABLED; // default;

    //
    // If an action is restricted, we hide it's corresponding
    // UI element in the user interface.
    //
    HRESULT hr = _IsCommandRestricted();
    if (SUCCEEDED(hr))
    {
        switch(hr)
        {
            case S_OK:
                *puisState = UIS_HIDDEN;
                break;

            case S_FALSE:
                *puisState = UIS_ENABLED;

            default:
                break;
        }
        //
        // Don't propagate S_FALSE to caller.
        //
        hr = S_OK;
    }
    return THR(hr);
}



//
// IUICommand::Invoke
// This version is called by webview when the user selects an 
// item from a webview menu.
//
STDMETHODIMP
CCplUiCommand::Invoke(
    IShellItemArray *psiItemArray, 
    IBindCtx *pbc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommand::Invoke");

    ASSERT(NULL != m_pAction);

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(pbc);

    HRESULT hr = m_pAction->Execute(NULL, _punkSite);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommand::Invoke", hr);
    return THR(hr);
}     


//
// ICpUiCommand::Invoke
// This version is called by CLinkElement::_OnSelected when
// the user selects either a category task or a category item
// in the category choice view.
//
STDMETHODIMP
CCplUiCommand::Invoke(
    HWND hwndParent, 
    IUnknown *punkSite
    )
{
    ASSERT(NULL != m_pAction);

    HRESULT hr = m_pAction->Execute(hwndParent, punkSite);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommand::InvokeContextMenu(
    HWND hwndParent, 
    const POINT *ppt
    )
{
    //
    // Only commands on pidls provide a context menu.
    //
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(ppt);
    return E_NOTIMPL;
}


STDMETHODIMP
CCplUiCommand::GetDataObject(
    IDataObject **ppdtobj
    )
{
    //
    // Simple UI commands don't provide a data object.
    //
    return E_NOTIMPL;
}


//
// Returns:
//   S_OK    = Command is restricted.
//   S_FALSE = Command is not restricted.
//
HRESULT
CCplUiCommand::_IsCommandRestricted(
    void
    )
{
    //
    // The ICplNamespace ptr is passed to IsRestricted in case the restriction
    // code needs to inspect contents of the namespace.  The "Other Cpl Options"
    // link command uses this to determine if the "OTHER" category contains any
    // CPL applets or not.  If it contains no applets, the link is hidden (restricted).
    //
    ICplNamespace *pns;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
    if (SUCCEEDED(hr))
    {
        hr = m_pAction->IsRestricted(pns);
        pns->Release();
    }
    return THR(hr);
}


//-----------------------------------------------------------------------------
// CCplUiCommandOnPidl
//-----------------------------------------------------------------------------

class CCplUiCommandOnPidl : public CObjectWithSite,
                            public IUICommand,
                            public ICpUiCommand,
                            public ICpUiElementInfo,
                            public IDataObject
                            
{
    public:
        ~CCplUiCommandOnPidl(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IUICommand
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName);
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
        STDMETHOD(get_CanonicalName)(GUID *pguidCommandName);
        STDMETHOD(get_State)(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puisState);
        STDMETHOD(Invoke)(IShellItemArray *psiItemArray, IBindCtx *pbc);       
        //
        // ICpUiCommand
        //
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt);
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite);
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj);
        //
        // ICpUiElementInfo
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon);
        STDMETHOD(LoadName)(LPWSTR *ppszName);
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip);
        //
        // IDataObject
        //
        STDMETHOD(GetData)(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHOD(GetDataHere)(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHOD(QueryGetData)(FORMATETC *pFmtEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFmtEtcIn, FORMATETC *pFmtEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFmtEtc, STGMEDIUM *pstm, BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
        STDMETHOD(DAdvise)(FORMATETC *pFmtEtc, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnum);        

        static HRESULT CreateInstance(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut);

    private:
        LONG          m_cRef;
        IShellFolder *m_psf;     // Cached Control Panel IShellFolder ptr.
        LPITEMIDLIST  m_pidl;    // Assumed to be relative to Control Panel.
        IDataObject  *m_pdtobj;

        CCplUiCommandOnPidl(void);

        HRESULT _GetControlPanelFolder(IShellFolder **ppsf);
        HRESULT _Initialize(LPCITEMIDLIST pidl);
        HRESULT _GetName(LPWSTR *ppszName);
        HRESULT _GetInfotip(LPWSTR *ppszInfotip);
        HRESULT _GetIconResource(LPWSTR *ppszIcon);
        HRESULT _Invoke(HWND hwndParent, IUnknown *punkSite);
        HRESULT _GetDataObject(IDataObject **ppdtobj);
};


CCplUiCommandOnPidl::CCplUiCommandOnPidl(
    void
    ) : m_cRef(1),
        m_psf(NULL),
        m_pidl(NULL),
        m_pdtobj(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiCommandOnPidl::CCplUiCommandOnPidl, this = 0x%x", this);
}


CCplUiCommandOnPidl::~CCplUiCommandOnPidl(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiCommandOnPidl::~CCplUiCommandOnPidl, this = 0x%x", this);
    ATOMICRELEASE(m_psf);
    ATOMICRELEASE(m_pdtobj);
    if (NULL != m_pidl)
    {
        ILFree(m_pidl);
    }
}


HRESULT 
CCplUiCommandOnPidl::CreateInstance(  // [static]
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));
    ASSERT(NULL != pidl);

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiCommandOnPidl *pc = new CCplUiCommandOnPidl();
    if (NULL != pc)
    {
        hr = pc->_Initialize(pidl);
        if (SUCCEEDED(hr))
        {
            hr = pc->QueryInterface(riid, ppvOut);
        }
        pc->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiCommandOnPidl, IUICommand),
        QITABENT(CCplUiCommandOnPidl, ICpUiCommand),
        QITABENT(CCplUiCommandOnPidl, ICpUiElementInfo),
        QITABENT(CCplUiCommandOnPidl, IObjectWithSite),
        QITABENT(CCplUiCommandOnPidl, IDataObject),
        QITABENTMULTI(CCplUiCommandOnPidl, IUIElement, IUICommand),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}


STDMETHODIMP_(ULONG)
CCplUiCommandOnPidl::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CCplUiCommandOnPidl::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP
CCplUiCommandOnPidl::get_Name(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszName
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetName(ppszName);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::get_Icon(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszIcon
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetIconResource(ppszIcon);
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::get_Tooltip(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszInfotip
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetInfotip(ppszInfotip);
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::get_CanonicalName(
    GUID *pguidCommandName
    )
{
    UNREFERENCED_PARAMETER(pguidCommandName);
    return E_NOTIMPL;
}



STDMETHODIMP
CCplUiCommandOnPidl::get_State(
    IShellItemArray *psiItemArray, 
    BOOL fOkToBeSlow, 
    UISTATE *puisState
    )
{
    ASSERT(NULL != puisState);
    ASSERT(!IsBadWritePtr(puisState, sizeof(*puisState)));

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(fOkToBeSlow);

    HRESULT hr = S_OK;
    *puisState = UIS_ENABLED; // default;

    //
    // We do not handle restrictions on CPL applets in the same
    // sense as other 'tasks' in this architecture.
    // CPL applets are restricted by the Control Panel folder's
    // item enumerator.  If the folder enumerates a CPL applet
    // then we assume it's valid to present that applet in the
    // UI.
    //
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::Invoke(
    IShellItemArray *psiItemArray, 
    IBindCtx *pbc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke");

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(pbc);

    HRESULT hr = _Invoke(NULL, NULL);
    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke", hr);
    return THR(hr);
}     


//
// ICpUiCommand::Invoke
//
STDMETHODIMP
CCplUiCommandOnPidl::Invoke(
    HWND hwndParent, 
    IUnknown *punkSite
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke");

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = _Invoke(hwndParent, punkSite);
    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke", hr);
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_Invoke(
    HWND hwndParent,
    IUnknown *punkSite
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::_Invoke");

    UNREFERENCED_PARAMETER(hwndParent);

    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = ILCombine(pidlCpanel, m_pidl);
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            bool bItemIsBrowsable = false;
            IUnknown *punkSiteToRelease = NULL;
            if (NULL == punkSite)
            {
                //
                // No site provided.  Let's use our site.
                //
                ASSERT(NULL != _punkSite);
                (punkSite = punkSiteToRelease = _punkSite)->AddRef();
            }
            if (NULL != punkSite)
            {
                //
                // If we have a site pointer, try to browse the object in-place
                // if it is indeed browsable.
                //
                WCHAR szName[MAX_PATH];
                ULONG rgfAttrs = SFGAO_BROWSABLE | SFGAO_FOLDER;
                hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName), &rgfAttrs);
                if (SUCCEEDED(hr))
                {
                    if ((SFGAO_BROWSABLE | SFGAO_FOLDER) & rgfAttrs)
                    {
                        //
                        // Browse the object in-place.  This is the path taken
                        // by things like the "Printers" folder, "Scheduled Tasks" etc.
                        //
                        bItemIsBrowsable = true;
                        IShellBrowser *psb;
                        hr = CPL::ShellBrowserFromSite(punkSite, &psb);
                        if (SUCCEEDED(hr))
                        {
                            hr = CPL::BrowseIDListInPlace(pidl, psb);
                            psb->Release();
                        }
                    }
                }
            } 

            if (NULL == punkSite || !bItemIsBrowsable)
            {
                //
                // Either we don't have a site ptr (can't get to the browser)
                // or the item is not browsable.  Simply execute it.
                // This is the path taken by conventional CPL applets like
                // Mouse, Power Options, Display etc.
                //
                SHELLEXECUTEINFOW sei = {
                    sizeof(sei),           // cbSize;
                    SEE_MASK_INVOKEIDLIST, // fMask
                    NULL,                  // hwnd
                    NULL,                  // lpVerb
                    NULL,                  // lpFile
                    NULL,                  // lpParameters
                    NULL,                  // lpDirectory
                    SW_SHOWNORMAL,         // nShow
                    0,                     // hInstApp
                    pidl,                  // lpIDList
                    NULL,                  // lpClass
                    NULL,                  // hkeyClass
                    0,                     // dwHotKey
                    NULL,                  // hIcon
                    NULL                   // hProcess
                };
                if (!ShellExecuteExW(&sei))
                {
                    hr = CPL::ResultFromLastError();
                }
            }
            ATOMICRELEASE(punkSiteToRelease);
            ILFree(pidl);
        }
        ILFree(pidlCpanel);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::_Invoke", hr);
    return THR(hr);
}     



HRESULT 
CCplUiCommandOnPidl::InvokeContextMenu(
    HWND hwndParent, 
    const POINT *ppt
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::InvokeContextMenu");

    ASSERT(NULL != ppt);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    //
    // First build a full pidl to the item.
    //
    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(hwndParent, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFull = ILCombine(pidlCpanel, m_pidl);
        if (NULL == pidlFull)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // Get the item's context menu interface from the shell.
            //
            IContextMenu *pcm;
            hr = SHGetUIObjectFromFullPIDL(pidlFull, hwndParent, IID_PPV_ARG(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                ASSERT(NULL != _punkSite);
                IContextMenu *pcmNoDelete;
                hr = Create_ContextMenuWithoutVerbs(pcm, L"cut;delete", IID_PPV_ARG(IContextMenu, &pcmNoDelete));
                if (SUCCEEDED(hr))
                {
                    hr = IUnknown_DoContextMenuPopup(_punkSite, pcmNoDelete, CMF_NORMAL, *ppt);
                    pcmNoDelete->Release();
                }
                pcm->Release();
            }
            else
            {
                TraceMsg(TF_ERROR, "Shell item does not provide a context menu");
            }
            ILFree(pidlFull);
        }
        ILFree(pidlCpanel);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::InvokeContextMenu", hr);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetDataObject(
    IDataObject **ppdtobj
    )
{
    return _GetDataObject(ppdtobj);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadIcon(
    eCPIMGSIZE eSize, 
    HICON *phIcon
    )
{
    IShellFolder *psf;
    HRESULT hr = CPL::GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        hr = CPL::ExtractIconFromPidl(psf, m_pidl, eSize, phIcon);
        psf->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadName(
    LPWSTR *ppszName
    )
{
    HRESULT hr = _GetName(ppszName);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadTooltip(
    LPWSTR *ppszTooltip
    )
{
    HRESULT hr = _GetInfotip(ppszTooltip);
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_Initialize(
    LPCITEMIDLIST pidl
    )
{
    ASSERT(NULL == m_pidl);
    ASSERT(NULL != pidl);

    HRESULT hr = E_OUTOFMEMORY;

    m_pidl = ILClone(pidl);
    if (NULL != m_pidl)
    {
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_GetControlPanelFolder(
    IShellFolder **ppsf
    )
{
    ASSERT(NULL != ppsf);
    ASSERT(!IsBadWritePtr(ppsf, sizeof(*ppsf)));

    HRESULT hr = S_OK;

    if (NULL == m_psf)
    {
        hr = CPL::GetControlPanelFolder(&m_psf);
    }
    *ppsf = m_psf;
    if (NULL != *ppsf)
    {
        (*ppsf)->AddRef();
    }
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_GetName(
    LPWSTR *ppszName
    )
{
    ASSERT(NULL != m_pidl);
    ASSERT(NULL != ppszName);
    ASSERT(!IsBadWritePtr(ppszName, sizeof(*ppszName)));

    *ppszName = NULL;

    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        STRRET strret;
        hr = psf->GetDisplayNameOf(m_pidl, SHGDN_INFOLDER, &strret);
        if (SUCCEEDED(hr))
        {
            hr = StrRetToStrW(&strret, m_pidl, ppszName);
        }
        psf->Release();
    }
    return THR(hr);
}



HRESULT 
CCplUiCommandOnPidl::_GetInfotip(
    LPWSTR *ppszInfotip
    )
{
    ASSERT(NULL != ppszInfotip);
    ASSERT(!IsBadWritePtr(ppszInfotip, sizeof(*ppszInfotip)));
    ASSERT(NULL != m_pidl);

    *ppszInfotip = NULL;

    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IShellFolder2 *psf2;
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
        if (SUCCEEDED(hr))
        {
            TCHAR szBuf[256];
            hr = GetStringProperty(psf2, m_pidl, &SCID_Comment, szBuf, ARRAYSIZE(szBuf));
            if (SUCCEEDED(hr))
            {
                hr = SHStrDup(szBuf, ppszInfotip);
            }
            psf2->Release();
        }
        psf->Release();
    }
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_GetIconResource(
    LPWSTR *ppszIcon
    )
{
    ASSERT(NULL != ppszIcon);
    ASSERT(!IsBadWritePtr(ppszIcon, sizeof(*ppszIcon)));
    ASSERT(NULL != m_pidl);

    LPWSTR pszIconPath = NULL;
    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IExtractIconW* pxi;
        hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&m_pidl, IID_PPV_ARG_NULL(IExtractIconW, &pxi));
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            int iIndex;
            UINT wFlags = 0;

            hr = pxi->GetIconLocation(GIL_FORSHELL, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
            if (SUCCEEDED(hr))
            {
                pszIconPath = (LPWSTR)SHAlloc(sizeof(WCHAR)*(lstrlenW(szPath) + 12));
                if (pszIconPath)
                {
                    wsprintfW(pszIconPath,L"%s,%d", szPath, iIndex);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            pxi->Release();
        }
        psf->Release();
    }
    *ppszIcon = pszIconPath;
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_GetDataObject(
    IDataObject **ppdtobj
    )
{
    ASSERT(NULL != ppdtobj);
    ASSERT(!IsBadWritePtr(ppdtobj, sizeof(*ppdtobj)));
    
    HRESULT hr = S_OK;
    if (NULL == m_pdtobj)
    {
        IShellFolder *psf;
        hr = _GetControlPanelFolder(&psf);
        if (SUCCEEDED(hr))
        {
            hr = THR(psf->GetUIObjectOf(NULL, 
                                        1, 
                                        (LPCITEMIDLIST *)&m_pidl, 
                                        IID_PPV_ARG_NULL(IDataObject, &m_pdtobj)));
            psf->Release();
        }
    }
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != m_pdtobj);
        (*ppdtobj = m_pdtobj)->AddRef();
    }
    return THR(hr);
}
      

STDMETHODIMP
CCplUiCommandOnPidl::GetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetData(pFmtEtc, pstm);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetDataHere(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetDataHere(pFmtEtc, pstm);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::QueryGetData(
    FORMATETC *pFmtEtc
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->QueryGetData(pFmtEtc);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetCanonicalFormatEtc(
    FORMATETC *pFmtEtcIn, 
    FORMATETC *pFmtEtcOut
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetCanonicalFormatEtc(pFmtEtcIn, pFmtEtcOut);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::SetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm, 
    BOOL fRelease
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->SetData(pFmtEtc, pstm, fRelease);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::EnumFormatEtc(
    DWORD dwDirection, 
    LPENUMFORMATETC *ppEnum
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->EnumFormatEtc(dwDirection, ppEnum);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::DAdvise(
    FORMATETC *pFmtEtc, 
    DWORD grfAdv, 
    LPADVISESINK pAdvSink, 
    DWORD *pdwConnection
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->DAdvise(pFmtEtc, grfAdv, pAdvSink, pdwConnection);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::DUnadvise(
    DWORD dwConnection
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->DUnadvise(dwConnection);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::EnumDAdvise(
    LPENUMSTATDATA *ppEnum
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->EnumDAdvise(ppEnum);
        pdtobj->Release();
    }
    return THR(hr);
}


//-----------------------------------------------------------------------------
// Public instance generators.
//-----------------------------------------------------------------------------

HRESULT
Create_CplUiElement(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    return CCplUiElement::CreateInstance(pszName, pszInfotip, pszIcon, riid, ppvOut);
}


HRESULT
Create_CplUiCommand(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    const IAction *pAction,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    return CCplUiCommand::CreateInstance(pszName, pszInfotip, pszIcon, pAction, riid, ppvOut);
}

HRESULT 
Create_CplUiCommandOnPidl(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));
    ASSERT(NULL != pidl);

    HRESULT hr = CCplUiCommandOnPidl::CreateInstance(pidl, riid, ppvOut);
    return THR(hr);
}



} // namespace CPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpview.cpp
//
//  This module provides the Control Panel user interface information 
//  to the shell through the ICplView interface.  The ICplView implementation
//  instantiates a CCplNamespace object through which it obtains the
//  display information on demand.  CCplView then takes that information 
//  and either makes it available to the shell for display in the webview 
//  left-hand pane or generates a DUI element hierarchy for display in the 
//  right-hand pane.
//
//  The majority of the code is associated with building Direct UI content.
// 
//--------------------------------------------------------------------------
#include "shellprv.h"
#include "cpviewp.h"
#include "cpduihlp.h"
#include "cpguids.h"
#include "cplnkele.h"
#include "cpnamespc.h"
#include "cputil.h"
#include "ids.h"
#include "shstyle.h"
#include <uxtheme.h>

namespace CPL {


class CCplView : public CObjectWithSite,
                 public ICplView,
                 public IServiceProvider
{
    public:
        ~CCplView(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplView
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumCategoryChoiceWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumCategoryWebViewInfo)(DWORD dwFlags, eCPCAT eCategory, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(CreateCategoryChoiceElement)(DUI::Element **ppe);
        STDMETHOD(CreateCategoryElement)(eCPCAT eCategory, DUI::Element **ppe);
        STDMETHOD(GetCategoryHelpURL)(eCPCAT eCategory, LPWSTR pszURL, UINT cchURL);
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs);
        //
        // IServiceProvider
        //
        STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

        static HRESULT CreateInstance(IEnumIDList *penumIDs, IUnknown *punkSite, REFIID riid, void **ppvOut);

    private:
        LONG              m_cRef;
        ICplNamespace    *m_pns;
        CSafeServiceSite *m_psss;
        ATOM              m_idDirective;
        ATOM              m_idDirective2;
        ATOM              m_idTitle;
        ATOM              m_idIcon;
        ATOM              m_idCategoryList;
        ATOM              m_idCategoryTaskList;
        ATOM              m_idAppletList;
        ATOM              m_idBanner;
        ATOM              m_idBarricadeTitle;
        ATOM              m_idBarricadeMsg;
        ATOM              m_idContainer;

        CCplView::CCplView(void);

        HRESULT _Initialize(IEnumIDList *penumIDs, IUnknown *punkSite);
        HRESULT _CreateCategoryChoiceElement(DUI::Element **ppe);
        HRESULT _CreateCategoryElement(ICplCategory *pCategory, DUI::Element **ppe);
        HRESULT _BuildCategoryBanner(ICplCategory *pCategory, DUI::Element *pePrimaryPane);
        HRESULT _BuildCategoryBarricade(DUI::Element *peRoot);
        HRESULT _BuildCategoryTaskList(DUI::Parser *pParser, ICplCategory *pCategory, DUI::Element *pePrimaryPane, int *pcTasks);
        HRESULT _BuildCategoryAppletList(DUI::Parser *pParser, ICplCategory *pCategory, DUI::Element *pePrimaryPane, int *pcApplets);
        HRESULT _CreateWatermark(DUI::Element *peRoot);
        HRESULT _CreateAndAddListItem(DUI::Parser *pParser, DUI::Element *peList, LPCWSTR pszItemTemplate, DUI::Value *pvSsListItem, IUICommand *puic, eCPIMGSIZE eIconSize);
        HRESULT _IncludeCategory(ICplCategory *pCategory) const;
        HRESULT _AddOrDeleteAtoms(bool bAdd);
        HRESULT _GetStyleModuleAndResId(HINSTANCE *phInstance, UINT *pidStyle);
        HRESULT _LoadUiFileFromResources(HINSTANCE hInstance, int idResource, char **ppUIFile);
        HRESULT _BuildUiFile(char **ppUIFile, int *piCharCount, HINSTANCE *phInstance);
        HRESULT _CreateUiFileParser(DUI::Parser **ppParser);
        eCPCAT _DisplayIndexToCategoryIndex(int iCategory) const;

        //
        // Prevent copy.
        //
        CCplView(const CCplView& rhs);
        CCplView& operator = (const CCplView& rhs);
};



CCplView::CCplView(
    void
    ) : m_cRef(1),
        m_pns(NULL),
        m_idDirective(0),
        m_idDirective2(0),
        m_idTitle(0),
        m_idIcon(0),
        m_idCategoryList(0),
        m_idCategoryTaskList(0),
        m_idAppletList(0),
        m_idBanner(0),
        m_idBarricadeTitle(0),
        m_idBarricadeMsg(0),
        m_idContainer(0),
        m_psss(NULL)
{
    TraceMsg(TF_LIFE, "CCplView::CCplView, this = 0x%x", this);
}


CCplView::~CCplView(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplView::~CCplView, this = 0x%x", this);

    if (NULL != m_psss)
    {
        m_psss->SetProviderWeakRef(NULL);
        m_psss->Release();
    }

    if (NULL != m_pns)
    {
        IUnknown_SetSite(m_pns, NULL);
        m_pns->Release();
    }
    _AddOrDeleteAtoms(false);
}



HRESULT
CCplView::CreateInstance( // [static]
    IEnumIDList *penumIDs, 
    IUnknown *punkSite,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplView* pv = new CCplView();
    if (NULL != pv)
    {
        hr = pv->_Initialize(penumIDs, punkSite);
        if (SUCCEEDED(hr))
        {
            hr = pv->QueryInterface(riid, ppvOut);
            if (SUCCEEDED(hr))
            {
                //
                // Set the site of the view to the site passed into the
                // instance generator.  This is most likely the site of
                // the Control Panel folder view callback.
                //
                hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
            }
        }
        pv->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplView::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplView, ICplView),
        QITABENT(CCplView, IObjectWithSite),
        QITABENT(CCplView, IServiceProvider),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplView::AddRef(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplView::AddRef %d->%d", m_cRef, m_cRef+1);
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplView::Release(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplView::Release %d<-%d", m_cRef-1, m_cRef);
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}



STDMETHODIMP
CCplView::QueryService(
    REFGUID guidService, 
    REFIID riid, 
    void **ppv
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::QueryService");

    HRESULT hr = E_NOINTERFACE;
    if (SID_SControlPanelView == guidService)
    {
        TraceMsg(TF_CPANEL, "SID_SControlPanelView service requested");
        if (IID_ICplNamespace == riid)
        {
            TraceMsg(TF_CPANEL, "SID_SControlPanelView::IID_ICplNamespace requested");
            ASSERT(NULL != m_pns);
            hr = m_pns->QueryInterface(IID_ICplNamespace, ppv);
        }
        else if (IID_ICplView == riid)
        {
            TraceMsg(TF_CPANEL, "SID_SControlPanelView::IID_ICplView requested");
            ASSERT(NULL != m_pns);
            hr = this->QueryInterface(IID_ICplView, ppv);
        }
    }
    else
    {
        //
        // Most likely a command object requesting SID_STopLevelBrowser.
        //
        TraceMsg(TF_CPANEL, "Handing service request to view's site.");
        ASSERT(NULL != _punkSite);
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::QueryService", hr);
    return THR(hr);
}



STDMETHODIMP
CCplView::EnumClassicWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumClassicWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    HRESULT hr = m_pns->EnumClassicWebViewInfo(dwFlags, ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumClassicWebViewInfo", hr);
    return THR(hr);
}


//
// Returns an enumerator for webview info associated with
// the category 'choice' page.
//
STDMETHODIMP
CCplView::EnumCategoryChoiceWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumCategoryChoiceWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    HRESULT hr = m_pns->EnumWebViewInfo(dwFlags, ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumCategoryChoiceWebViewInfo", hr);
    return THR(hr);
}


//
// Returns an enumerator for webview info associated with
// a given category page.
//
STDMETHODIMP
CCplView::EnumCategoryWebViewInfo(
    DWORD dwFlags,
    eCPCAT eCategory, 
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumCategoryWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = pCategory->EnumWebViewInfo(dwFlags, ppenum);
        ATOMICRELEASE(pCategory);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumCategoryWebViewInfo", hr);
    return THR(hr);
}


//
// Creates the DUI element tree for the category 'choice'
// page.  Returns the root of the tree.
//
STDMETHODIMP
CCplView::CreateCategoryChoiceElement(
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::CreateCategoryChoiceElement");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));

    HRESULT hr = _CreateCategoryChoiceElement(ppe);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::CreateCategoryChoiceElement", hr);
    return THR(hr);
}



//
// Creates the DUI element tree for a given category page.
// Returns the root of the tree.
//
STDMETHODIMP
CCplView::CreateCategoryElement(
    eCPCAT eCategory, 
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::CreateCategoryElement");
    TraceMsg(TF_CPANEL, "Category ID = %d", eCategory);

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = _CreateCategoryElement(pCategory, ppe);
        ATOMICRELEASE(pCategory);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::CreateCategoryElement", hr);
    return THR(hr);
}


STDMETHODIMP
CCplView::GetCategoryHelpURL(
    CPL::eCPCAT eCategory,
    LPWSTR pszURL,
    UINT cchURL
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::GetCategoryHelpURL");

    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    
    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = pCategory->GetHelpURL(pszURL, cchURL);
        ATOMICRELEASE(pCategory);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::GetCategoryHelpURL", hr);
    return THR(hr);
}


STDMETHODIMP
CCplView::RefreshIDs(
    IEnumIDList *penumIDs
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::RefreshIDs");

    ASSERT(NULL != m_pns);
    //
    // This will cause the namespace object to reset it's internal
    // list of item IDs.  This results in a re-categorization of 
    // applets such that all information returned by the namespace
    // will now reflect the new set of folder items.
    //
    HRESULT hr = m_pns->RefreshIDs(penumIDs);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::RefreshIDs", hr);
    return THR(hr);
}


HRESULT
CCplView::_Initialize(
    IEnumIDList *penumIDs,
    IUnknown *punkSite
    )
{
    ASSERT(NULL == m_pns);
    ASSERT(NULL != penumIDs);

    HRESULT hr = E_OUTOFMEMORY;

    //
    // We use this weak-reference implementation of IServiceProvider
    // as described by ZekeL in shell\inc\cowsite.h.  A strong reference
    // would create a circular reference cycle between children of the
    // view and the view itself, preventing the view's destruction.
    // This weak-reference implementation is designed specifically
    // for this case.
    //
    ASSERT(NULL == m_psss);
    m_psss = new CSafeServiceSite();
    if (NULL != m_psss)
    {
        hr = m_psss->SetProviderWeakRef(this);
        if (SUCCEEDED(hr))
        {
            hr = CplNamespace_CreateInstance(penumIDs, CPL::IID_ICplNamespace, (void **)&m_pns);
            if (SUCCEEDED(hr))
            {
                IUnknown *punkSafeSite;
                hr = m_psss->QueryInterface(IID_IUnknown, (void **)&punkSafeSite);
                if (SUCCEEDED(hr))
                {
                    //
                    // Site the namespace object to the view.
                    // By doing this, all command objects created by the namespace will
                    // QueryService on the view object.  If the view doesn't support
                    // the requested service, it will query it's site.
                    // We use this so that command objects can query the view for
                    // IID_ICplNamespace and gather information on the namespace
                    // if necessary.  
                    //
                    hr = IUnknown_SetSite(m_pns, punkSafeSite);
                    if (SUCCEEDED(hr))
                    {
                        hr = _AddOrDeleteAtoms(true);
                    }
                    punkSafeSite->Release();
                }
            }
        }
    }
    return THR(hr);
}



HRESULT
CCplView::_AddOrDeleteAtoms(
    bool bAdd
    )
{
    struct CPL::ATOMINFO rgAtomInfo[] = {
        { L"directive",        &m_idDirective        },
        { L"directive2",       &m_idDirective2       },
        { L"title",            &m_idTitle            },
        { L"icon",             &m_idIcon             },
        { L"categorylist",     &m_idCategoryList     },
        { L"categorytasklist", &m_idCategoryTaskList },
        { L"appletlist",       &m_idAppletList       },
        { L"banner",           &m_idBanner           },
        { L"barricadetitle",   &m_idBarricadeTitle   },
        { L"barricademsg",     &m_idBarricadeMsg     },
        { L"container",        &m_idContainer        }
        };

    HRESULT hr = Dui_AddOrDeleteAtoms(rgAtomInfo, ARRAYSIZE(rgAtomInfo), bAdd);
    return THR(hr);
}


//
// Creates the DUI element tree for the category 'choice' page.
// Returns the root element.
//
HRESULT
CCplView::_CreateCategoryChoiceElement(
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateCategoryChoiceElement");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    DUI::Element *peRoot = NULL;
    DUI::Parser *pParser;
    HRESULT hr = _CreateUiFileParser(&pParser);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateElement(pParser, L"CategoryList", NULL, &peRoot);
        if (SUCCEEDED(hr))
        {
            hr = _CreateWatermark(peRoot);
            if (SUCCEEDED(hr))
            {
                CDuiValuePtr pvSsCategoryListItem;
                hr = Dui_GetStyleSheet(pParser, L"CategoryListItemSS", &pvSsCategoryListItem);
                if (SUCCEEDED(hr))
                {
                    //
                    // Set the "Pick a category..." title.
                    //
                    hr = Dui_SetDescendentElementText(peRoot,
                                                      L"directive",
                                                      MAKEINTRESOURCEW(IDS_CP_PICKCATEGORY));
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Build the list of categories.
                        //
                        DUI::Element *peCategoryList;
                        hr = Dui_FindDescendent(peRoot, L"categorylist", &peCategoryList);
                        if (SUCCEEDED(hr))
                        {
                            for (int i = 0; SUCCEEDED(hr) && i < int(eCPCAT_NUMCATEGORIES); i++)
                            {
                                ICplCategory *pCategory;
                                hr = m_pns->GetCategory(_DisplayIndexToCategoryIndex(i), &pCategory);
                                if (SUCCEEDED(hr))
                                {
                                    if (S_OK == _IncludeCategory(pCategory))
                                    {
                                        IUICommand *puic;
                                        hr = pCategory->GetUiCommand(&puic);
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = _CreateAndAddListItem(pParser,
                                                                       peCategoryList, 
                                                                       L"CategoryLink", 
                                                                       pvSsCategoryListItem, 
                                                                       puic,
                                                                       eCPIMGSIZE_CATEGORY);
                                            ATOMICRELEASE(puic);
                                        }
                                    }
                                    ATOMICRELEASE(pCategory);
                                }
                            }
                        }
                    }
                }
            }
        }
        pParser->Destroy();
    }
    *ppe = peRoot;

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateCategoryChoiceElement", hr);
    return THR(hr);
}


//
// Creates the DUI element tree for a given category page.
// Returns the root element.
//
HRESULT
CCplView::_CreateCategoryElement(
    ICplCategory *pCategory,
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateCategoryElement");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    DUI::Element *peRoot = NULL;
    DUI::Parser *pParser;
    HRESULT hr = _CreateUiFileParser(&pParser);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateElement(pParser, L"CategoryView", NULL, &peRoot);
        if (SUCCEEDED(hr))
        {
            hr = _CreateWatermark(peRoot);
            if (SUCCEEDED(hr))
            {
                int cTasks   = 0;
                int cApplets = 0;
                hr = _BuildCategoryBanner(pCategory, peRoot);
                if (SUCCEEDED(hr))
                {
                    hr = _BuildCategoryTaskList(pParser, pCategory, peRoot, &cTasks);
                    if (SUCCEEDED(hr))
                    {
                        hr = _BuildCategoryAppletList(pParser, pCategory, peRoot, &cApplets);
                    }
                }
                if (SUCCEEDED(hr))
                {
                    if (0 == cTasks && 0 == cApplets)
                    {
                        //
                        // No tasks or applets.  Display a message explaining
                        // that the content has been made unavailable by the system
                        // administrator.
                        //
                        hr = _BuildCategoryBarricade(peRoot);
                    }
                    else
                    {
                        //
                        // Delete the barricade DUI elements.  They're unused.
                        //
                        THR(Dui_DestroyDescendentElement(peRoot, L"barricadetitle"));
                        THR(Dui_DestroyDescendentElement(peRoot, L"barricademsg"));
                        //
                        // Set the text in the 'directive' text elements.
                        //
                        if (0 < cTasks)
                        {
                            //
                            // We've displayed a list of tasks.
                            // Set the "Pick a task..." title.
                            //
                            hr = Dui_SetDescendentElementText(peRoot,
                                                              L"directive",
                                                              MAKEINTRESOURCEW(IDS_CP_PICKTASK));
                        }

                        if (SUCCEEDED(hr))
                        {
                            if (0 < cApplets)
                            {
                                //
                                // We've displayed a list of applets.  Display one of the
                                // following directives based on the existance of a task 
                                // list above.
                                //
                                // Task list?    Directive
                                // ------------- ---------------------------
                                // Yes           "or pick a Control Panel icon"
                                // No            "Pick a Control Panel icon"
                                //
                                UINT idsDirective2 = IDS_CP_PICKICON;
                                if (0 < cTasks)
                                {
                                    idsDirective2 = IDS_CP_ORPICKICON;
                                }
                                hr = Dui_SetDescendentElementText(peRoot,
                                                                  L"directive2",
                                                                  MAKEINTRESOURCEW(idsDirective2));
                            }
                        }
                    }
                }
            }
        }
        pParser->Destroy();
    }
    *ppe = peRoot;

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateCategoryElement", hr);
    return THR(hr);
}


//
// Builds the 'barricade' that is displayed when a category has no
// tasks or CPL applets to show.
//
HRESULT
CCplView::_BuildCategoryBarricade(
    DUI::Element *peRoot
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryBarricade");
    HRESULT hr = Dui_SetDescendentElementText(peRoot,
                                              L"barricadetitle",
                                              MAKEINTRESOURCE(IDS_CP_CATEGORY_BARRICADE_TITLE));
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementText(peRoot, 
                                          L"barricademsg",
                                          MAKEINTRESOURCE(IDS_CP_CATEGORY_BARRICADE_MSG));
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryBarricade", hr);
    return THR(hr);
}


//
// Add the background watermark to the view if user is using a non-classic
// theme.
//
HRESULT
CCplView::_CreateWatermark(
    DUI::Element *peRoot
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateWatermark");

    ASSERT(NULL != peRoot);

    HINSTANCE hStyleModule;
    UINT idStyle;
    HRESULT hr = _GetStyleModuleAndResId(&hStyleModule, &idStyle);
    if (SUCCEEDED(hr))
    {
        HBITMAP hWatermark = (HBITMAP) LoadImage (hStyleModule, MAKEINTRESOURCE(IDB_CPANEL_WATERMARK),
                                                  IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        if (NULL != hWatermark)
        {
            //
            // Set watermark only on non-classic themes.
            //
            DUI::Element *peWatermark;
            hr = Dui_FindDescendent(peRoot, L"watermark", &peWatermark);
            if (SUCCEEDED(hr))
            {
                CDuiValuePtr ptrValue = DUI::Value::CreateGraphic(hWatermark,
                                                                  GRAPHIC_TransColor,
                                                                  255);

                if (!ptrValue.IsNULL())
                {
                    hr = Dui_SetElementProperty(peWatermark, ContentProp, ptrValue);
                         peWatermark->SetContentAlign(CA_BottomRight);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    DeleteObject (hWatermark);
                }
            }
            else
            {
                DeleteObject (hWatermark);
            }

            FreeLibrary(hStyleModule);
        }
        else
        {
            //
            // If 'classic' theme, do nothing.
            //
            hr = S_FALSE;
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateWatermark", hr);
    return THR(hr);
}



//
// Builds the banner for a category page.
//
HRESULT
CCplView::_BuildCategoryBanner(
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryBanner");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);

    IUICommand *puic;
    HRESULT hr = pCategory->GetUiCommand(&puic);
    if (SUCCEEDED(hr))
    {
        ICpUiElementInfo *pei;
        hr = puic->QueryInterface(IID_ICpUiElementInfo, (void **)&pei);
        if (SUCCEEDED(hr))
        {
            DUI::Element *peBanner;
            hr = Dui_FindDescendent(pePrimaryPane, L"banner", &peBanner);
            if (SUCCEEDED(hr))
            {
                //
                // Create the title text.
                //
                LPWSTR pszTitle;
                hr = pei->LoadName(&pszTitle);
                if (SUCCEEDED(hr))
                {
                    hr = Dui_SetDescendentElementText(peBanner, L"title", pszTitle);
                    CoTaskMemFree(pszTitle);
                }
                if (SUCCEEDED(hr))
                {
                    //
                    // Create the icon.
                    //
                    HICON hIcon;
                    hr = pei->LoadIcon(eCPIMGSIZE_BANNER, &hIcon);
                    if (SUCCEEDED(hr))
                    {
                        hr = Dui_SetDescendentElementIcon(peBanner, L"icon", hIcon);
                        if (FAILED(hr))
                        {
                            DestroyIcon(hIcon);
                        }
                    }
                }
            }
            ATOMICRELEASE(pei);
        }
        ATOMICRELEASE(puic);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryBanner", hr);
    return THR(hr);
}



//
// Builds the list of tasks for a category page.
//
HRESULT
CCplView::_BuildCategoryTaskList(
    DUI::Parser *pParser,
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane,
    int *pcTasks
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryTaskList");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);
    ASSERT(NULL != m_pns);
    ASSERT(NULL != pParser);

    int cTasks = 0;
    DUI::Element *peCategoryTaskList;
    HRESULT hr = Dui_FindDescendent(pePrimaryPane, L"categorytasklist", &peCategoryTaskList);
    if (SUCCEEDED(hr))
    {
        CDuiValuePtr pvStyleSheet;
        hr = Dui_GetStyleSheet(pParser, L"CategoryTaskListItemSS", &pvStyleSheet);
        if (SUCCEEDED(hr))
        {
            IEnumUICommand *peuic;
            hr = pCategory->EnumTasks(&peuic);
            if (SUCCEEDED(hr))
            {
                IUICommand *puic;
                while(S_OK == (hr = peuic->Next(1, &puic, NULL)))
                {
                    hr = _CreateAndAddListItem(pParser,
                                               peCategoryTaskList, 
                                               L"TaskLink", 
                                               pvStyleSheet, 
                                               puic,
                                               eCPIMGSIZE_TASK);
                    if (SUCCEEDED(hr))
                    {
                        cTasks++;
                    }
                    ATOMICRELEASE(puic);
                }
                ATOMICRELEASE(peuic);
            }
        }
    }
    if (NULL != pcTasks)
    {
        ASSERT(!IsBadWritePtr(pcTasks, sizeof(*pcTasks)));
        *pcTasks = cTasks;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryTaskList", hr);
    return THR(hr);
}


//
// Builds the list of CPL applets for a category page.
//
HRESULT
CCplView::_BuildCategoryAppletList(
    DUI::Parser *pParser,
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane,
    int *pcApplets
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryAppletList");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);
    ASSERT(NULL != pParser);

    int cApplets = 0;

    DUI::Element *peAppletList;
    HRESULT hr = Dui_FindDescendent(pePrimaryPane, L"appletlist", &peAppletList);
    if (SUCCEEDED(hr))
    {
        CDuiValuePtr pvStyleSheet;
        hr = Dui_GetStyleSheet(pParser, L"CategoryTaskListItemSS", &pvStyleSheet);
        if (SUCCEEDED(hr))
        {
            IEnumUICommand *peuicApplets;
            hr = pCategory->EnumCplApplets(&peuicApplets);
            if (SUCCEEDED(hr))
            {
                IUICommand *puicApplet;
                while(S_OK == (hr = peuicApplets->Next(1, &puicApplet, NULL)))
                {
                    hr = _CreateAndAddListItem(pParser,
                                               peAppletList, 
                                               L"AppletLink", 
                                               pvStyleSheet, 
                                               puicApplet,
                                               eCPIMGSIZE_APPLET);
                    if (SUCCEEDED(hr))
                    {
                        cApplets++;
                    }
                    ATOMICRELEASE(puicApplet);
                }
                ATOMICRELEASE(peuicApplets);
            }
        }
    }
    if (NULL != pcApplets)
    {
        ASSERT(!IsBadWritePtr(pcApplets, sizeof(*pcApplets)));
        *pcApplets = cApplets;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryAppletList", hr);
    return THR(hr);
}


//
// Helper for adding link element to the view.
//
HRESULT
CCplView::_CreateAndAddListItem(
    DUI::Parser *pParser,
    DUI::Element *peList,     // List inserting into.
    LPCWSTR pszItemTemplate,  // Name of template in UI file.
    DUI::Value *pvSsListItem, // Style sheet for new list item
    IUICommand *puic,         // The new item's link object.
    eCPIMGSIZE eIconSize      // Desired size of item icon.
    )
{    
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateAndAddListItem");

    ASSERT(NULL != pParser);
    ASSERT(NULL != peList);
    ASSERT(NULL != pvSsListItem);
    ASSERT(NULL != puic);
    ASSERT(NULL != pszItemTemplate);

    DUI::Element *peListItem;
    HRESULT hr = Dui_CreateElement(pParser, pszItemTemplate, NULL, &peListItem);
    if (SUCCEEDED(hr))
    {
        if (NULL != pvSsListItem)
        {
            hr = Dui_SetElementStyleSheet(peListItem, pvSsListItem);
        }
        if (SUCCEEDED(hr))
        {
            ASSERTMSG(peListItem->GetClassInfo() == CLinkElement::Class, "CCplView::_CreateAndAddListItem didn't get a CLinkElement::Class object (%s)", peListItem->GetClassInfo()->GetName());
            CLinkElement *pLinkEle = static_cast<CLinkElement *>(peListItem);
            hr = pLinkEle->Initialize(puic, eIconSize);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(hr))
                {
                    hr = peList->Add(peListItem);
                    if (SUCCEEDED(hr))
                    {
                        peListItem = NULL;
                    }
                }
            }
            if (NULL != peListItem)
            {
                peListItem->Destroy();
            }
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateAndAddListItem", hr);
    return THR(hr);
}



//
// Determine if a given category item should be shown in the UI.
//
// Returns:
//      S_OK    - Include the item.
//      S_FALSE - Do not include the item.
//      Error   - Cannot determine.
//
HRESULT
CCplView::_IncludeCategory(
    ICplCategory *pCategory
    ) const
{
    HRESULT hr = S_OK;  // Assume it's included.
    
    //
    // If a category link invokes a restricted operation,
    // hide it from the UI.
    //
    IUICommand *puic;
    hr = pCategory->GetUiCommand(&puic);
    if (SUCCEEDED(hr))
    {
        UISTATE uis;
        hr = puic->get_State(NULL, TRUE, &uis);
        if (SUCCEEDED(hr))
        {
            if (UIS_HIDDEN == uis)
            {
                hr = S_FALSE;
            }
        }
        ATOMICRELEASE(puic);
    }
    return THR(hr);
}


//
// Map a category display index to a category index in the
// namespace.  Categories in the namespace are ordered to match up 
// with the various category IDs.  The view may be (and is) ordered
// differently and is subject to change based on usability feedback.
//
eCPCAT
CCplView::_DisplayIndexToCategoryIndex(
    int iCategory
    ) const
{
    //
    // This array determins the order the categories are displayed
    // in the category selection view.  To change the display order,
    // simply reorder these entries.
    //
    static const eCPCAT rgMap[] = { // Position in DUI grid control
        eCPCAT_APPEARANCE,          // Row 0, Col 0
        eCPCAT_HARDWARE,            // Row 0, Col 1
        eCPCAT_NETWORK,             // Row 1, Col 0
        eCPCAT_ACCOUNTS,            // Row 1, Col 1
        eCPCAT_ARP,                 // Row 2, Col 0
        eCPCAT_REGIONAL,            // Row 2, Col 1
        eCPCAT_SOUND,               // Row 3, Col 0
        eCPCAT_ACCESSIBILITY,       // Row 3, Col 1
        eCPCAT_PERFMAINT,           // Row 4, Col 0
        eCPCAT_OTHER                // Row 4, Col 1
        };

    ASSERT(ARRAYSIZE(rgMap) == eCPCAT_NUMCATEGORIES);
    ASSERT(iCategory >= 0 && iCategory < ARRAYSIZE(rgMap));
    return rgMap[iCategory];
}


HRESULT
CCplView::_CreateUiFileParser(
    DUI::Parser **ppParser
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateUiFileParser");

    ASSERT(NULL != ppParser);
    ASSERT(!IsBadWritePtr(ppParser, sizeof(*ppParser)));

    char *pszUiFile;
    int cchUiFile;
    HINSTANCE hInstance; // Instance containing resources referenced in UI file.

    HRESULT hr = _BuildUiFile(&pszUiFile, &cchUiFile, &hInstance);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateParser(pszUiFile, cchUiFile, hInstance, ppParser);   
        LocalFree(pszUiFile);
        if (HINST_THISDLL != hInstance)
        {
            ASSERT(NULL != hInstance);
            FreeLibrary(hInstance);
        }
    }

    DBG_EXIT(FTF_CPANEL, "CCplView::_CreateUiFileParser");
    return THR(hr);
}


//
//  Builds the UI file for this view from the
//  appropriate base template + style sheet
//
//  pUIFile receives a pointer to the ui file in memory
//  piCharCount receives the size of the file
//
HRESULT 
CCplView::_BuildUiFile(
    char **ppUIFile, 
    int *piCharCount,
    HINSTANCE *phInstance
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildUiFile");

    ASSERT(NULL != ppUIFile);
    ASSERT(!IsBadWritePtr(ppUIFile, sizeof(*ppUIFile)));
    ASSERT(NULL != phInstance);
    ASSERT(!IsBadWritePtr(phInstance, sizeof(*phInstance)));

    *phInstance = NULL;

    //
    // Load the 'structure' UI file
    //
    char *pStructure;
    HRESULT hr = _LoadUiFileFromResources(HINST_THISDLL, IDR_DUI_CPVIEW, &pStructure);
    if (SUCCEEDED(hr))
    {
        HINSTANCE hStyleModule;
        UINT idStyle;
        hr = _GetStyleModuleAndResId(&hStyleModule, &idStyle);
        if (SUCCEEDED(hr))
        {
            //
            // Load the style sheet.  First, check if the current theme has a style sheet,
            // if not, use the default style sheet in the resources.
            //
            char *pStyle;
            hr = _LoadUiFileFromResources(hStyleModule, idStyle, &pStyle);
            if (SUCCEEDED(hr))
            {
                const int cbStyle      = lstrlenA(pStyle);
                const int cbStructure  = lstrlenA(pStructure);
                char *pResult = (char *)LocalAlloc(LPTR, cbStyle + cbStructure + 1);
                if (pResult)
                {
                    //
                    // Put the resouces together (style + structure)
                    //
                    CopyMemory(pResult, pStyle, cbStyle);
                    CopyMemory(pResult + cbStyle, pStructure, cbStructure);

                    ASSERT(cbStructure + cbStyle == lstrlenA(pResult));
                    *ppUIFile = pResult;
                    //
                    // This count is ANSI chars so we can use byte counts
                    // directly.
                    //
                    *piCharCount = cbStructure + cbStyle;
                    *phInstance  = hStyleModule;
                    //
                    // Indicate that HINSTANCE is being returned to caller.
                    //
                    hStyleModule = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                LocalFree(pStyle);
            }
            if (NULL != hStyleModule && HINST_THISDLL != hStyleModule)
            {
                //
                // Something failed.  Need to free style module
                // if it's not shell32.dll.
                //
                FreeLibrary(hStyleModule);
            }
        }
        LocalFree(pStructure);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildUiFile", hr);
    return THR(hr);
}



HRESULT
CCplView::_GetStyleModuleAndResId(
    HINSTANCE *phInstance,
    UINT *pidStyle
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_GetStyleModuleAndResId");

    ASSERT(NULL != phInstance);
    ASSERT(!IsBadWritePtr(phInstance, sizeof(*phInstance)));
    ASSERT(NULL != pidStyle);
    ASSERT(!IsBadWritePtr(pidStyle, sizeof(*pidStyle)));

    HRESULT hr = S_OK;
    *phInstance = NULL;
    
    HINSTANCE hThemeModule = SHGetShellStyleHInstance();
    if (NULL != hThemeModule)
    {
        *pidStyle = IDR_DUI_CPSTYLE;
        *phInstance = hThemeModule;
    }
    else
    {
        TraceMsg(TF_CPANEL, "Error %d loading theme file", GetLastError());
        hr = ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_GetStyleModuleAndResId", hr);
    return THR(hr);
}



//
//  Loads the requested UI file from a module's resources.
//
//  iID         - UI file id
//  pUIFile     - receives a pointer to the UI file
//
HRESULT 
CCplView::_LoadUiFileFromResources(
    HINSTANCE hInstance, 
    int idResource, 
    char **ppUIFile
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_LoadUiFileFromResources");

    ASSERT(NULL != ppUIFile);
    ASSERT(!IsBadWritePtr(ppUIFile, sizeof(*ppUIFile)));

    HRESULT hr = E_FAIL;

    *ppUIFile = NULL;

    HRSRC hFile = FindResourceW(hInstance, MAKEINTRESOURCEW(idResource), L"UIFILE");
    if (hFile)
    {
        HGLOBAL hResource = LoadResource(hInstance, hFile);
        if (hResource)
        {
            char *pFile = (char *)LockResource(hResource);
            if (pFile)
            {
                DWORD dwSize = SizeofResource(hInstance, hFile);
                //
                // Include one extra byte for a terminating nul character.
                // We're loading text and want it to be nul-terminated.
                //
                *ppUIFile = (char *)LocalAlloc(LPTR, dwSize + 1);
                if (NULL != *ppUIFile)
                {
                    CopyMemory(*ppUIFile, pFile, dwSize);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = ResultFromLastError();
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_LoadUiFileFromResources", hr);
    return THR(hr);
}




HRESULT 
CPL::CplView_CreateInstance(
    IEnumIDList *penumIDs, 
    IUnknown *punkSite,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CCplView::CreateInstance(penumIDs, punkSite, riid, ppvOut);
    return THR(hr);
}


HRESULT 
CplView_GetCategoryTitle(
    eCPCAT eCategory, 
    LPWSTR pszTitle, 
    UINT cchTitle
    )
{
    ASSERT(NULL != pszTitle);
    ASSERT(!IsBadWritePtr(pszTitle, cchTitle * sizeof(*pszTitle)));

    //
    // These must remain in the same order as the eCPCAT_XXXXX enumeration.
    //
    static const UINT rgid[] = {
        IDS_CPCAT_OTHERCPLS_TITLE,
        IDS_CPCAT_APPEARANCE_TITLE,
        IDS_CPCAT_HARDWARE_TITLE,
        IDS_CPCAT_NETWORK_TITLE,
        IDS_CPCAT_SOUNDS_TITLE,
        IDS_CPCAT_PERFMAINT_TITLE,
        IDS_CPCAT_REGIONAL_TITLE,
        IDS_CPCAT_ACCESSIBILITY_TITLE,
        IDS_CPCAT_ARP_TITLE,
        IDS_CPCAT_ACCOUNTS_TITLE
        };

    HRESULT hr = S_OK;
    ASSERT(eCategory >= 0 && eCategory < eCPCAT_NUMCATEGORIES);
    if (0 == LoadString(HINST_THISDLL, rgid[int(eCategory)], pszTitle, cchTitle))
    {
        hr = ResultFromLastError();
    }
    return THR(hr);
}

} // namespace CPL

HRESULT InitializeCPClasses()
{
    HRESULT hr;

    hr = CPL::CLinkElement::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cputil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cputil.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_UTIL_H
#define __CONTROLPANEL_UTIL_H



namespace CPL {


enum eCPIMGSIZE
{
    eCPIMGSIZE_WEBVIEW,
    eCPIMGSIZE_TASK,
    eCPIMGSIZE_CATEGORY,
    eCPIMGSIZE_BANNER,
    eCPIMGSIZE_APPLET,
    eCPIMGSIZE_NUMSIZES
};

class ICplView; // fwd decl.

void ImageDimensionsFromDesiredSize(eCPIMGSIZE eSize, UINT *pcx, UINT *pcy);
bool ShouldUseSmallIconForDesiredSize(eCPIMGSIZE eSize);

HRESULT LoadBitmapFromResource(LPCWSTR pszBitmapDesc, HINSTANCE hInstTheme, UINT uiLoadFlags, HBITMAP *phBitmapOut);
HRESULT LoadIconFromResource(LPCWSTR pszResource, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadIconFromResourceID(LPCWSTR pszModule, int idIcon, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadIconFromResourceIndex(LPCWSTR pszModule, int iIcon, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT ExtractIconFromPidl(IShellFolder *psf, LPCITEMIDLIST pidl, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadStringFromResource(LPCWSTR pszStrDesc, LPWSTR *ppszOut);
HRESULT ResultFromLastError(void);
HRESULT ShellBrowserFromSite(IUnknown *punkSite, IShellBrowser **ppsb);
HRESULT ControlPanelViewFromSite(IUnknown *punkSite, ICplView **ppview);
HRESULT BrowseIDListInPlace(LPCITEMIDLIST pidl, IShellBrowser *psb);
HRESULT BrowsePathInPlace(LPCWSTR pszPath, IShellBrowser *psb);
HRESULT BuildHssHelpURL(LPCWSTR pszSelect, LPWSTR pszURL, UINT cchURL);
HRESULT GetControlPanelFolder(IShellFolder **ppsf);
HRESULT ExpandEnvironmentVars(LPCTSTR psz, LPTSTR *ppszOut);
HRESULT SetControlPanelBarricadeStatus(VARIANT_BOOL vtb);

bool IsAppletEnabled(LPCWSTR pszFilename, LPCWSTR pszName);
bool IsSystemRestoreRestricted(void);

BOOL IsConnectedToDomain(void);
BOOL IsOsServer(void);
BOOL IsOsPersonal(void);
BOOL IsOsProfessional(void);
BOOL IsUserAdmin(void);

VARIANT_BOOL GetBarricadeStatus(bool *pbFixedByPolicy = NULL);
bool IsFirstRunForThisUser(void);
bool CategoryViewIsActive(bool *pbBarricadeFixedByPolicy = NULL);


//
// The default tab indices of the various tabs
// if you add another tab, make sure its in the right position.
// Note that desk.cpl respects these indices. The new themes tab
// does not have an associated index, it is the default tab if
// no index is specified.
//
enum eDESKCPLTAB {  
    CPLTAB_ABSENT = -1,
    CPLTAB_DESK_BACKGROUND,
    CPLTAB_DESK_SCREENSAVER,
    CPLTAB_DESK_APPEARANCE,
    CPLTAB_DESK_SETTINGS,
    CPLTAB_DESK_MAX
    };

int DeskCPL_GetTabIndex(eDESKCPLTAB eTab, OPTIONAL LPWSTR pszCanonicalName, OPTIONAL DWORD cchSize);
bool DeskCPL_IsTabPresent(eDESKCPLTAB eTab);


enum eACCOUNTTYPE
{
    eACCOUNTTYPE_UNKNOWN = -1,
    eACCOUNTTYPE_OWNER,
    eACCOUNTTYPE_STANDARD,
    eACCOUNTTYPE_LIMITED,
    eACCOUNTTYPE_GUEST,
    eACCOUNTTYPE_NUMTYPES
};

HRESULT GetUserAccountType(eACCOUNTTYPE *pType);

//
// Each one of these "CpaDestroyer_XXXX" classes implements a single 
// "Destroy" function to free one item held in a DPA.  Currently there
// are only two flavors, one that calls "delete" and one that calls
// "LocalFree".  By default the CDpa class uses the CDpaDestoyer_Delete
// class as that is the most commont form of freeing required.  To use
// another type, just specify another similar class as the 'D' template
// argument to CDpa.
//
template <typename T>
class CDpaDestroyer_Delete
{
    public:
        static void Destroy(T* p)
            { delete p; }
};

template <typename T>
class CDpaDestroyer_Free
{
    public:
        static void Destroy(T* p)
            { if (p) LocalFree(p); }
};

template <typename T>
class CDpaDestroyer_ILFree
{
    public:
        static void Destroy(T* p)
            { if (p) ILFree(p); }
};

template <typename T>
class CDpaDestroyer_Release
{
    public:
        static void Destroy(T* p)
            { if (p) p->Release(); }
};

class CDpaDestroyer_None
{
    public:
        static void Destroy(void*)
            { }
};



//-----------------------------------------------------------------------------
// CDpa  - Template class.
//
// Simplifies working with a DPA.
//-----------------------------------------------------------------------------

template <typename T, typename D = CDpaDestroyer_Delete<T> >
class CDpa
{
public:
    explicit CDpa(int cGrow = 4)
        : m_hdpa(DPA_Create(cGrow)) { }

    ~CDpa(void) { _Destroy(); }

    bool IsValid(void) const { return NULL != m_hdpa; }

    int Count(void) const
    { 
        return IsValid() ? DPA_GetPtrCount(m_hdpa) : 0;
    }

    const T* Get(int i) const
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (const T*)DPA_GetPtr(m_hdpa, i);
    }

    T* Get(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_GetPtr(m_hdpa, i);
    }

    const T* operator [](int i) const
    {
        return Get(i);
    }

    T* operator [](int i)
    {
        return Get(i);
    }

    void Set(int i, T* p)
    {
        ASSERT(IsValid());
        ASSERT(i < Count());
        DPA_SetPtr(m_hdpa, i, p);
    }

    int Append(T* p)
    { 
        ASSERT(IsValid());
        return DPA_AppendPtr(m_hdpa, p);
    }

    T* Remove(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_DeletePtr(m_hdpa, i);
    }

    void Clear(void)
    { 

        _DestroyItems(); 
    }

private:
    HDPA m_hdpa;

    void _DestroyItems(void)
    {
        if (NULL != m_hdpa)
        {
            while(0 < Count())
            {
                D::Destroy(Remove(0));
            }
        }
    }

    void _Destroy(void)
    {
        if (NULL != m_hdpa)
        {
            _DestroyItems();
            DPA_Destroy(m_hdpa);
            m_hdpa = NULL;
        }
    }

    //
    // Prevent copy.
    //
    CDpa(const CDpa& rhs);
    CDpa& operator = (const CDpa& rhs);
};
                

} // namespace CPL

#endif // __CONTROLPANEL_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpview.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_VIEW_H
#define __CONTROLPANEL_VIEW_H


#include "cpguids.h"
#include "cputil.h"

namespace DUI = DirectUI;

namespace CPL {

//
// Control Panel category enumeration.
//
// These values MUST remain unchanged.
// They correspond directly to the values stored for the SCID_CONTROLPANELCATEGORY
// value associated with each CPL in the registry.
//
enum eCPCAT
{
    eCPCAT_OTHER,
    eCPCAT_APPEARANCE,
    eCPCAT_HARDWARE,
    eCPCAT_NETWORK,
    eCPCAT_SOUND,
    eCPCAT_PERFMAINT,
    eCPCAT_REGIONAL,
    eCPCAT_ACCESSIBILITY,
    eCPCAT_ARP,
    eCPCAT_ACCOUNTS,
    eCPCAT_NUMCATEGORIES
};


//
// ICplWebViewInfo represents a single menu displayed in the 
// webview left pane.
//
class ICplWebViewInfo : public IUnknown
{
    public:
        //
        // Returns the menu's header.
        //
        STDMETHOD(get_Header)(IUIElement **ppele) PURE;
        //
        // Returns flags governing web view's presentation
        // of the information.
        //
        STDMETHOD(get_Style)(DWORD *pdwStyle) PURE;
        //
        // Returns enumerator representing the menu's items.
        //
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum) PURE;
};


//
// IEnumCplWebViewInfo represents an enumeration of webview information.
// Each element consists of a header and a list of task command objects.
//
class IEnumCplWebViewInfo : public IUnknown
{
    public:
        STDMETHOD(Next)(ULONG celt, ICplWebViewInfo **ppwvi, ULONG *pceltFetched) PURE;
        STDMETHOD(Skip)(ULONG celt) PURE;
        STDMETHOD(Reset)(void) PURE;
        STDMETHOD(Clone)(IEnumCplWebViewInfo **ppenum) PURE;
};


//
// ICplView represents the view 'factory' for the Control Panel.
// The Control Panel's folder view callback implementation instantiates
// a CplView object and through it's methods obtains the necessary
// display information to drive the Control Panel display.
//
// CPVIEW_EF_XXXX = Enumeration flags.
//
#define CPVIEW_EF_DEFAULT      0x00000000
#define CPVIEW_EF_NOVIEWSWITCH 0x00000001


class ICplView : public IUnknown
{
    public:
        //
        // Get the webview information associated with the 'classic'
        // Control Panel view.
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Get the webview information associated with the 'choice' page.
        //
        STDMETHOD(EnumCategoryChoiceWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Get the webview information associated with a particular category.
        //
        STDMETHOD(EnumCategoryWebViewInfo)(DWORD dwFlags, eCPCAT eCategory, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Creates a DUI element containing the category choice page.
        //
        STDMETHOD(CreateCategoryChoiceElement)(DirectUI::Element **ppe) PURE;
        //
        // Creates a DUI element containing the tasks and CPL applets
        // for a particular category.
        //
        STDMETHOD(CreateCategoryElement)(eCPCAT eCategory, DirectUI::Element **ppe) PURE;
        //
        // Launch help for a given category.
        //
        STDMETHOD(GetCategoryHelpURL)(eCPCAT eCategory, LPWSTR pszURL, UINT cchURL) PURE;
        //
        // Refresh the view object with a new set of item IDs.
        //
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs) PURE;
};


HRESULT CplView_CreateInstance(IEnumIDList *penumIDs, IUnknown *punkSite, REFIID riid, void **ppvOut);
HRESULT CplView_GetCategoryTitle(eCPCAT eCategory, LPWSTR pszTitle, UINT cchTitle);


} // namespace CPL

#endif //__CONTROLPANEL_VIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cpviewp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpviewp.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_VIEW_PRIVATE_H
#define __CONTROLPANEL_VIEW_PRIVATE_H

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>
#include <dusercore.h>

namespace DUI = DirectUI;


#include "cpview.h"


namespace CPL {


enum eCPVIEWTYPE
{
    eCPVIEWTYPE_CLASSIC,
    eCPVIEWTYPE_CATEGORY,
    eCPVIEWTYPE_NUMTYPES
};


//
// ICplCategory represents a single category withing the cateorized
// Control Panel namespace.
//
extern const GUID IID_ICplCategory;

class ICplCategory : public IUnknown
{
    public:
        //
        // Returns the category's ID number from the eCPCAT enumeration.
        //
        STDMETHOD(GetCategoryID)(eCPCAT *pID) PURE;
        //
        // Returns the command object associated with the category's
        // link.  Used by the category selection page.
        //
        STDMETHOD(GetUiCommand)(IUICommand **ppele) PURE;
        //
        // Returns an enumerator for the task commands associated with
        // the category.
        //
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum) PURE;
        //
        // Returns an enumerator for the CPL applet links associated
        // with the category.
        //
        STDMETHOD(EnumCplApplets)(IEnumUICommand **ppenum) PURE;
        //
        // Returns an enumerator for the webview information associated
        // with the category.
        //
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Invoke help for the category.
        //
        STDMETHOD(GetHelpURL)(LPWSTR pszURL, UINT cchURL) PURE;
};


//
// ICplNamespace represents the entire Control Panel namespace for the
// new "Categorized" view introduced in Whistler.
//
extern const GUID IID_ICplNamespace;

class ICplNamespace : public IUnknown
{
    public:
        //
        // Returns a specified category.
        //
        STDMETHOD(GetCategory)(eCPCAT eCategory, ICplCategory **ppcat) PURE;
        //
        // Returns an enumerator for the information displayed
        // in webview on the category selection page.
        //
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Returns an enumerator for the information displayed
        // in webview on the classic page.
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Refresh namespace with new set of item IDs.
        //
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs) PURE;
        //
        // Cached system configuration information.  Used by 
        // restriction code in cpnamespc.cpp
        //
        STDMETHOD_(BOOL, IsServer)(void) PURE;
        STDMETHOD_(BOOL, IsProfessional)(void) PURE;
        STDMETHOD_(BOOL, IsPersonal)(void) PURE;
        STDMETHOD_(BOOL, IsUserAdmin)(void) PURE;
        STDMETHOD_(BOOL, IsUserOwner)(void) PURE;
        STDMETHOD_(BOOL, IsUserStandard)(void) PURE;
        STDMETHOD_(BOOL, IsUserLimited)(void) PURE;
        STDMETHOD_(BOOL, IsUserGuest)(void) PURE;
        STDMETHOD_(BOOL, IsOnDomain)(void) PURE;
        STDMETHOD_(BOOL, IsX86)(void) PURE;
        STDMETHOD_(BOOL, AllowUserManager)(void) PURE;
        STDMETHOD_(BOOL, UsePersonalUserManager)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCpl)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Background)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Screensaver)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Appearance)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Settings)(void) PURE;
        
};


} // namespace CPL

#endif //__CONTROLPANEL_VIEW_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ctllogic.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ctllogic.h"

BOOL _GetListViewSelectedLVITEM(HWND hwndList, LVITEM* plvitem)
{
    BOOL fFound = FALSE;
    int iCount = ListView_GetItemCount(hwndList);

    plvitem->mask |= LVIF_STATE;
    plvitem->stateMask = LVIS_SELECTED;

    for (int j = 0; j < iCount; ++j)
    {
        plvitem->iItem = j;

        ListView_GetItem(hwndList, plvitem);

        if (plvitem->state & LVIS_SELECTED)
        {
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

HRESULT _GetListViewSelectedLPARAM(HWND hwndList, LPARAM* plparam)
{
    HRESULT hr;
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_PARAM;

    if (_GetListViewSelectedLVITEM(hwndList, &lvitem))
    {
        hr = S_OK;
        *plparam = lvitem.lParam;
    }
    else
    {
        hr = S_FALSE;
        *plparam = NULL;
    }

    return hr;
}

// ComboBox

HRESULT _GetComboBoxSelectedLRESULT(HWND hwndComboBox, LRESULT* plr)
{
    HRESULT hr;

    int iCurSel = ComboBox_GetCurSel(hwndComboBox);

    LRESULT lr = ComboBox_GetItemData(hwndComboBox, iCurSel);

    if (CB_ERR != lr)
    {
        hr = S_OK;
        *plr = lr;
    }
    else
    {
        hr = S_FALSE;
        *plr = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dataprv.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "dataprv.h"

// TODO: use IShellDetails instead
const LPCWSTR c_awszColumns[] = 
{
    L"Title",
    L"URL",
};

CSimpleData::~CSimpleData() 
{
    ATOMICRELEASE(_psf);
    DPA_FreeIDArray(_hdpa); // accpets NULL
}

STDMETHODIMP CSimpleData::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = 0;

    HRESULT hr = _DoEnum();
    if (SUCCEEDED(hr)) 
        *pcRows = DPA_GetPtrCount(_hdpa);

    return S_OK;
}

STDMETHODIMP CSimpleData::getColumnCount(DB_LORDINAL *pcColumns)
{
    *pcColumns = ARRAYSIZE(c_awszColumns);
    return S_OK;
}

STDMETHODIMP CSimpleData::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY; 
    return S_OK;
}

STDMETHODIMP CSimpleData::getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar)
{
    VariantInit(pVar);
    HRESULT hr = _DoEnum();
    if (FAILED(hr)) 
        return hr;

    hr = E_FAIL;
    if (iColumn > 0 && iColumn <= ARRAYSIZE(c_awszColumns)) 
    {
        if (iRow == 0) 
        {
            pVar->bstrVal = SysAllocString(c_awszColumns[iColumn - 1]);
            pVar->vt = VT_BSTR;
            hr = S_OK;        
        } 
        else if (iRow > 0) 
        {
            if (_psf && _hdpa && ((iRow-1) < DPA_GetPtrCount(_hdpa)))
            {
                LPCITEMIDLIST pidl = (LPCITEMIDLIST)DPA_GetPtr(_hdpa, iRow - 1);
                WCHAR szValue[MAX_PATH];

                switch (iColumn) 
                {
                case 1:
                    hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER, szValue, ARRAYSIZE(szValue));
                    break;

                case 2:
                    hr = DisplayNameOf(_psf, pidl, SHGDN_FORPARSING, szValue, ARRAYSIZE(szValue));
                    break;
                }

                if (SUCCEEDED(hr))
                {
                    pVar->vt = VT_BSTR;
                    pVar->bstrVal = SysAllocString(szValue);
                }
            }
        }    
    } 

    return hr;
}

STDMETHODIMP CSimpleData::setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var)
{
    return E_NOTIMPL; 
}

STDMETHODIMP CSimpleData::getLocale(BSTR *pbstrLocale)
{
    return E_NOTIMPL;
    
}

STDMETHODIMP CSimpleData::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val,
        OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    IUnknown_Set((IUnknown **)_ppListener, pospIListener);
    return S_OK;    
}

STDMETHODIMP CSimpleData::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    IUnknown_Set((IUnknown **)_ppListener, NULL);
    return S_OK;
}

STDMETHODIMP CSimpleData::getEstimatedRows(DBROWCOUNT *pcRows)
{
    *pcRows = -1;
    return S_OK;
}

STDMETHODIMP CSimpleData::isAsync(BOOL *pbAsync)
{
    *pbAsync = TRUE;
    return S_OK;
}

STDMETHODIMP CSimpleData::stopTransfer()
{
    return E_NOTIMPL;    
}

HRESULT CSimpleData::_DoEnum(void)
{
    HRESULT hr = S_OK;

    if (_hdpa) 
    {
        DPA_FreeIDArray(_hdpa);
        _hdpa = NULL;
    }

    if (_psf) 
    {
        _hdpa = DPA_Create(4);
        if (_hdpa) 
        {
            IEnumIDList* penum;
            hr = _psf->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum);
            if (S_OK == hr) 
            {
                LPITEMIDLIST pidl;
                while (S_OK == penum->Next(1, &pidl, NULL)) 
                {
                    DPA_AppendPtr(_hdpa, pidl);
                }
                penum->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    } 
    else 
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CSimpleData::SetShellFolder(IShellFolder *psf)
{
    IUnknown_Set((IUnknown **)&_psf, psf);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ctllogic.h ===
#ifndef CTLLOGIC_H
#define CTLLOGIC_H

#include "dlglogic.h"

#define MAX_ITEMTEXTLEN   50
#define MAX_TILETEXT      50

HRESULT _GetListViewSelectedLPARAM(HWND hwndList, LPARAM* plparam);
HRESULT _GetComboBoxSelectedLRESULT(HWND hwndComboBox, LRESULT* plr);

// ListView

template<typename TData>
class CDLUIDataLVItem : public CDLUIData<TData>
{
public:
    virtual ~CDLUIDataLVItem() {}

    virtual HRESULT GetText(LPWSTR pszText, DWORD cchText) PURE;
    virtual HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation) PURE;
    virtual HRESULT GetTileText(int i, LPWSTR pszTileText,
        DWORD cchTileText)
    {
        return E_NOTIMPL;
    }
};

template<typename TData>
class CUILListView
{
public:
    ~CUILListView();
    CUILListView();

    HRESULT Init(HWND hwndListView);
    HRESULT InitTileInfo(const UINT auTileSubItems[], DWORD cTileSubItems);

    HRESULT AddItem(CDLUIDataLVItem<TData>* plvitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    // Assume Single select listview.  Also assume that no other item is selected
    HRESULT SelectFirstItem();

    HRESULT ResetContent();

protected:
    HWND        _hwndList;

private:    
    const UINT* _auTileSubItems;
    int         _cTileSubItems;
};

template<typename TData, typename TCompareData>
class CUILListViewSelect : public CUILListView<TData>
{
public:
    HRESULT SelectItem(TCompareData comparedata)
    {
        HRESULT hr = E_FAIL;
        LVITEM lvitem = {0};
        int iCount = 0;
        lvitem.mask = LVIF_PARAM;

        iCount = ListView_GetItemCount(_hwndList);

        for (lvitem.iItem = 0; lvitem.iItem < iCount; ++lvitem.iItem)
        {
            if (ListView_GetItem(_hwndList, &lvitem))
            {
                CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)lvitem.lParam;

                TData* pdata = plvitem->GetData();

                if (pdata)
                {
                    int iResult;
                    hr = pdata->Compare(comparedata, &iResult);

                    pdata->Release();

                    if (SUCCEEDED(hr) && !iResult)
                    {
                        break;
                    }
                }
            }
        }

        if (lvitem.iItem == iCount)
        {
            //No Match found, Select first item anyway
            lvitem.iItem = 0;
            hr = S_FALSE;
        }

        lvitem.mask = LVIF_STATE;
        lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

        ListView_SetItem(_hwndList, &lvitem);
        ListView_EnsureVisible(_hwndList, lvitem.iItem, FALSE);

        return hr;
    }
};

// ComboBox
template<typename TData>
class CDLUIDataCBItem : public CDLUIData<TData>
{
public:
    virtual ~CDLUIDataCBItem() {}

    virtual HRESULT GetText(LPWSTR pszText, DWORD cchText) PURE;
    virtual HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation) PURE;
};

template<typename TData>
class CUILComboBox
{
public:
    ~CUILComboBox();

    HRESULT Init(HWND hwndComboBox);

    HRESULT AddItem(CDLUIDataCBItem<TData>* pcbitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    HRESULT SelectFirstItem();

    HRESULT ResetContent();

private:
    HWND _hwndCombo;
};

template<typename TData>
class CUILComboBoxEx
{
public:
    ~CUILComboBoxEx();

    HRESULT Init(HWND hwndComboBox);

    HRESULT AddItem(CDLUIDataCBItem<TData>* pcbitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    HRESULT SelectFirstItem();

    HRESULT ResetContent();

private:
    HWND _hwndCombo;
};

// Implementations

template<typename TData>
CUILListView<TData>::CUILListView() : _cTileSubItems(0)
{}

template<typename TData>
CUILListView<TData>::~CUILListView()
{
    ResetContent();
}

template<typename TData>
inline HRESULT CUILListView<TData>::Init(HWND hwndListView)
{
    _hwndList = hwndListView;

    return S_OK;
}

template<typename TData>
inline HRESULT CUILListView<TData>::InitTileInfo(const UINT auTileSubItems[],
    DWORD cTileSubItems)
{
    _auTileSubItems = auTileSubItems;
    _cTileSubItems = cTileSubItems;

    return S_OK;
}

template<typename TData>
inline HRESULT CUILListView<TData>::AddItem(CDLUIDataLVItem<TData>* plvitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];
    int iImage;
    LVITEM lvitem = {0};

    HRESULT hr = plvitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        WCHAR szIconLocation[MAX_PATH + 12];

        hr = plvitem->GetIconLocation(szIconLocation,
            ARRAYSIZE(szIconLocation));

        if (SUCCEEDED(hr))
        {
            int iIcon = PathParseIconLocation(szIconLocation);

            iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);
        }
    }

    if (SUCCEEDED(hr))
    {
        int iItem;

        lvitem.mask = LVIF_IMAGE | LVIF_TEXT | LVIF_PARAM;
        lvitem.pszText = szText;
        lvitem.iItem = ListView_GetItemCount(_hwndList);
        lvitem.iImage = iImage;
        lvitem.lParam = (LPARAM)plvitem;

        iItem = ListView_InsertItem(_hwndList, &lvitem);

        if (-1 != iItem)
        {
            if (_cTileSubItems)
            {
                LVTILEINFO lvti = {0};
                lvti.cbSize = sizeof(LVTILEINFO);
                lvti.iItem = iItem;
                lvti.cColumns = ARRAYSIZE(_auTileSubItems);
                lvti.puColumns = (UINT*)_auTileSubItems;
                ListView_SetTileInfo(_hwndList, &lvti);

                for (int i = 0; i < _cTileSubItems; ++i)
                {
                    WCHAR szTileText[MAX_TILETEXT];

                    hr = plvitem->GetTileText(i, szTileText,
                        ARRAYSIZE(szTileText));

                    // 1 based
                    ListView_SetItemText(_hwndList, iItem, i + 1, szTileText);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
inline HRESULT CUILListView<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;
    BOOL fFound = FALSE;
    int iCount = ListView_GetItemCount(_hwndList);
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    for (int j = 0; !fFound && (j < iCount); ++j)
    {
        lvitem.iItem = j;

        ListView_GetItem(_hwndList, &lvitem);

        if (lvitem.state & (LVIS_SELECTED | LVIS_FOCUSED))
        {
            fFound = TRUE;
        }
    }

    if (fFound)
    {
        CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)lvitem.lParam;

        *ppdata = plvitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;

        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
inline HRESULT CUILListView<TData>::SelectFirstItem()
{
    LVITEM lvitem = {0};

    lvitem.iItem = 0;
    lvitem.mask = LVIF_STATE;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_hwndList, &lvitem);
    ListView_EnsureVisible(_hwndList, lvitem.iItem, FALSE);

    return S_OK;
}

template<typename TData>
HRESULT CUILListView<TData>::ResetContent()
{
    int iCount = 0;
    LVITEM lvitem = {0};

    // go through all the items in the listview and delete the strings
    // dynamically allocated
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = 0;

    iCount = ListView_GetItemCount(_hwndList);

    for (lvitem.iItem = 0; lvitem.iItem < iCount; ++lvitem.iItem)
    {
        ListView_GetItem(_hwndList, &lvitem);

        CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)
            lvitem.lParam;

        if (plvitem)
        {
            delete plvitem;
        }
    }

    ListView_DeleteAllItems(_hwndList);

    return S_OK;
}

// CUILComboBox
template<typename TData>
CUILComboBox<TData>::~CUILComboBox()
{
    ResetContent();
}

template<typename TData>
HRESULT CUILComboBox<TData>::Init(HWND hwndComboBox)
{
    _hwndCombo = hwndComboBox;

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBox<TData>::AddItem(CDLUIDataCBItem<TData>* pcbitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];

    HRESULT hr = pcbitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        int i = ComboBox_AddString(_hwndCombo, szText);

        if (CB_ERR != i)
        {
            ComboBox_SetItemData(_hwndCombo, i, pcbitem);
        }
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBox<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;

    int iCurSel = ComboBox_GetCurSel(_hwndCombo);

    LRESULT lr = ComboBox_GetItemData(_hwndCombo, iCurSel);

    if (CB_ERR != lr)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)lr;

        *ppdata = pcbitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;
        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBox<TData>::ResetContent()
{
    int c = ComboBox_GetCount(_hwndCombo);

    for (int i = 0; i < c; ++i)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)
            ComboBox_GetItemData(_hwndCombo, i);
       
        if (pcbitem)
        {
            delete pcbitem;
        }
    }

    ComboBox_ResetContent(_hwndCombo);

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBox<TData>::SelectFirstItem()
{
    ComboBox_SetCurSel(_hwndCombo, 0);

    return S_OK;
}

// CUILComboBoxEx
template<typename TData>
CUILComboBoxEx<TData>::~CUILComboBoxEx()
{
    ResetContent();
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::Init(HWND hwndComboBox)
{
    _hwndCombo = hwndComboBox;

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::AddItem(CDLUIDataCBItem<TData>* pcbitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];
    int iImage;
    HRESULT hr = pcbitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        WCHAR szIconLocation[MAX_PATH + 12];

        hr = pcbitem->GetIconLocation(szIconLocation,
            ARRAYSIZE(szIconLocation));

        if (SUCCEEDED(hr))
        {
            int iIcon = PathParseIconLocation(szIconLocation);

            iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);
        }
    }

    if (SUCCEEDED(hr))
    {
        int iItem;
        COMBOBOXEXITEM cbitem = {0};

        cbitem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_LPARAM;
        cbitem.pszText = szText;
        cbitem.iItem = ComboBox_GetCount(_hwndCombo);
        cbitem.iImage = iImage;
        cbitem.iSelectedImage = iImage;
        cbitem.lParam = (LPARAM)pcbitem;

        iItem = SendMessage(_hwndCombo, CBEM_INSERTITEM, 0, (LPARAM)&cbitem);

        if (-1 != iItem)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;
    COMBOBOXEXITEM cbitem = {0};

    cbitem.mask = CBEIF_LPARAM;
    cbitem.iItem = ComboBox_GetCurSel(_hwndCombo);

    if (SendMessage(_hwndCombo, CBEM_GETITEM, 0, (LPARAM)&cbitem))
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)cbitem.lParam;

        *ppdata = pcbitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;
        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::ResetContent()
{
    int c = ComboBox_GetCount(_hwndCombo);

    for (int i = 0; i < c; ++i)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)
            ComboBox_GetItemData(_hwndCombo, i);
       
        if (pcbitem)
        {
            delete pcbitem;
        }
    }

    ComboBox_ResetContent(_hwndCombo);

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::SelectFirstItem()
{
    ComboBox_SetCurSel(_hwndCombo, 0);

    return S_OK;
}

#endif // CTLLOGIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cstrings.c ===
#include "shellprv.h"
#pragma  hdrstop

const TCHAR c_szShell32Dll[] = TEXT("shell32.dll");
const TCHAR c_szShell16Dll[] = TEXT("shell.dll");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szStar[] = TEXT("*");
const TCHAR c_szStarDotStar[] = TEXT("*.*");
const TCHAR c_szFolderClass[] = TEXT("Folder");
const TCHAR c_szStubWindowClass[] = TEXT("StubWindow32");

const TCHAR c_szExplore[]  = TEXT("Explore");
const TCHAR c_szBaseClass[] = TEXT("*");
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szPATH[] = TEXT("PATH");
const TCHAR c_szDotExe[] = TEXT(".exe");
const TCHAR c_szOpen[]         = TEXT("open");
const TCHAR c_szEdit[]         = TEXT("edit");
const TCHAR c_szFind[]         = TEXT("find");
const TCHAR c_szPrint[]        = TEXT("print");
const TCHAR c_szPrintTo[]      = TEXT("printto");
const TCHAR c_szOpenAs[]       = TEXT("openas");
const TCHAR c_szDesktopIni[] = STR_DESKTOPINI;   // "desktop.ini"
const TCHAR c_szShell[] = STRREG_SHELL;          // "shell"
const TCHAR c_szDesktop[] = TEXT("Desktop");

// strings for filetypes
const TCHAR c_szCommand[] = TEXT("command");
const TCHAR c_szDefaultIcon[] = TEXT("DefaultIcon");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ctrlxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

// From cplobj.c
EXTERN_C BOOL CPL_FindCPLInfo(LPTSTR pszCmdLine, HICON *phIcon, UINT *ppapl, LPTSTR *pparm);

class CCtrlExtIconBase : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    CCtrlExtIconBase(LPCWSTR pszSubObject);

protected:
    ~CCtrlExtIconBase();

private:
    TCHAR _szSubObject[MAX_PATH];
    HICON _hIcon;
    UINT  _nControl;
};

CCtrlExtIconBase::CCtrlExtIconBase(LPCWSTR pszSubObject) : CExtractIconBase(), _hIcon(NULL), _nControl(-1) 
{
    lstrcpyn(_szSubObject, pszSubObject, ARRAYSIZE(_szSubObject));
}


CCtrlExtIconBase::~CCtrlExtIconBase()
{
    if (_hIcon)
        DestroyIcon(_hIcon);
}


STDAPI ControlExtractIcon_CreateInstance(LPCTSTR pszSubObject, REFIID riid, void** ppv)
{
    HRESULT hr;
    CCtrlExtIconBase* pceib = new CCtrlExtIconBase(pszSubObject);
    if (pceib)
    {
        hr = pceib->QueryInterface(riid, ppv);
        pceib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CCtrlExtIconBase::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
    UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_FALSE;

    if (!(uFlags & GIL_OPENICON))
    {
        lstrcpyn(pszIconFile, _szSubObject, cchMax);
        LPTSTR pszComma = StrChr(pszIconFile, TEXT(','));
        if (pszComma)
        {
            *pszComma ++= 0;
            *piIndex = StrToInt(pszComma);
            *pwFlags = GIL_PERINSTANCE;

            //
            // normally the index will be negative (a resource id)
            // check for some special cases like dynamic icons and bogus ids
            //
            if (*piIndex == 0)
            {
                LPTSTR lpExtraParms = NULL;

                // this is a dynamic applet icon
                *pwFlags |= GIL_DONTCACHE | GIL_NOTFILENAME;

                // use the applet index in case there's more than one
                if ((_hIcon != NULL) || CPL_FindCPLInfo(_szSubObject, &_hIcon,
                    &_nControl, &lpExtraParms))
                {
                    *piIndex = _nControl;
                }
                else
                {
                    // we failed to load the applet all of the sudden
                    // use the first icon in the cpl file (*piIndex == 0)
                    //
                    // Assert(FALSE);
                    DebugMsg(DM_ERROR,
                        TEXT("Control Panel CCEIGIL: ") TEXT("Enumeration failed \"%s\""),
                        _szSubObject);
                }
            }
            else if (*piIndex > 0)
            {
                // this is an invalid icon for a control panel
                // use the first icon in the file
                // this may be wrong but it's better than a generic doc icon
                // this fixes ODBC32 which is NOT dynamic but returns bogus ids
                *piIndex = 0;
            }

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CCtrlExtIconBase::_ExtractW(LPCWSTR pszFile, UINT nIconIndex,
    HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    LPTSTR lpExtraParms = NULL;
    HRESULT hr = S_FALSE;

    //-------------------------------------------------------------------
    // if there is no icon index then we must extract by loading the dude
    // if we have an icon index then it can be extracted with ExtractIcon
    // (which is much faster)
    // only perform a custom extract if we have a dynamic icon
    // otherwise just return S_FALSE and let our caller call ExtractIcon.
    //-------------------------------------------------------------------

    LPCTSTR p = StrChr(_szSubObject, TEXT(','));

    if ((!p || !StrToInt(p+1)) &&
        ((_hIcon != NULL) || CPL_FindCPLInfo(_szSubObject, &_hIcon,
        &_nControl, &lpExtraParms)))
    {
        if (_hIcon)
        {
            *phiconLarge = CopyIcon(_hIcon);
            *phiconSmall = NULL;

            if( *phiconLarge )
                hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ctrlfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "datautil.h"
#include "clsobj.h"
#include "control.h"
#include "drives.h"
#include "infotip.h"
#include "prop.h"           // COLUMN_INFO
#include "basefvcb.h"
#include "fstreex.h"
#include "idhidden.h"
#include "shstyle.h"
#include "util.h" // GetVariantFromRegistryValue

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#define GADGET_ENABLE_OLE
#include <duser.h>
#include <directui.h>
#include <duserctrl.h>

#include "cpview.h"
#include "cputil.h"
//
// An array of pidls
//
typedef CPL::CDpa<UNALIGNED ITEMIDLIST, CPL::CDpaDestroyer_ILFree<UNALIGNED ITEMIDLIST> >  CDpaItemIDList;


#define MAX_CPL_EXEC_NAME (1 + MAX_PATH + 2 + MAX_CCH_CPLNAME) //See wnsprintf in GetExecName        

STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey);

#pragma pack(1)
// our pidc type:
typedef struct _IDCONTROL
{
    USHORT  cb;
    USHORT  wDummy;             //  DONT REUSE - was stack garbage pre-XP
    int     idIcon;
    USHORT  oName;              // cBuf[oName] is start of NAME
    USHORT  oInfo;              // cBuf[oInfo] is start of DESCRIPTION
    CHAR    cBuf[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBuf[0] is the start of FILENAME
} IDCONTROL;
typedef UNALIGNED struct _IDCONTROL *LPIDCONTROL;

typedef struct _IDCONTROLW
{
    USHORT  cb;
    USHORT  wDummy;             //  DONT REUSE - was stack garbage pre-XP
    int     idIcon;
    USHORT  oName;              // if Unicode .cpl, this will be 0
    USHORT  oInfo;              // if Unicode .cpl, this will be 0
    CHAR    cBuf[2];            // if Unicode .cpl, cBuf[0] = '\0', cBuf[1] = magic byte
    USHORT  wDummy2;            //  DONT REUSE - was stack garbage pre-XP
    DWORD   dwFlags;            // Unused; for future expansion
    USHORT  oNameW;             // cBufW[oNameW] is start of NAME
    USHORT  oInfoW;             // cBufW[oInfoW] is start of DESCRIPTION
    WCHAR   cBufW[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBufW[0] is the start of FILENAME
} IDCONTROLW;
typedef UNALIGNED struct _IDCONTROLW *LPIDCONTROLW;
#pragma pack()

#ifdef DEBUG
// our pidc type:
typedef struct _IDCONTROLDEBUG
{
    USHORT  cb;
    int     idIcon;
    USHORT  oName;              // cBuf[oName] is start of NAME
    USHORT  oInfo;              // cBuf[oInfo] is start of DESCRIPTION
    CHAR    cBuf[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBuf[0] is the start of FILENAME
} IDCONTROLDEBUG;

typedef struct _IDCONTROLWDEBUG
{
    USHORT  cb;
    int     idIcon;
    USHORT  oName;              // if Unicode .cpl, this will be 0
    USHORT  oInfo;              // if Unicode .cpl, this will be 0
    CHAR    cBuf[2];            // if Unicode .cpl, cBuf[0] = '\0', cBuf[1] = magic byte
    DWORD   dwFlags;            // Unused; for future expansion
    USHORT  oNameW;             // cBufW[oNameW] is start of NAME
    USHORT  oInfoW;             // cBufW[oInfoW] is start of DESCRIPTION
    WCHAR   cBufW[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBufW[0] is the start of FILENAME
} IDCONTROLWDEBUG;

void ValidateControlIDStructs()
{
    COMPILETIME_ASSERT(sizeof(IDCONTROL) == sizeof(IDCONTROLDEBUG));
    COMPILETIME_ASSERT(sizeof(IDCONTROLW) == sizeof(IDCONTROLWDEBUG));
}
#endif DEBUG
// Unicode IDCONTROLs will be flagged by having oName = 0, oInfo = 0, 
// cBuf[0] = '\0', and cBuf[1] = UNICODE_CPL_SIGNATURE_BYTE

STDAPI ControlExtractIcon_CreateInstance(LPCTSTR pszSubObject, REFIID riid, void **ppv);

class CControlPanelViewCallback;

class CControlPanelFolder : public CAggregatedUnknown, public IShellFolder2, IPersistFolder2
{
    friend CControlPanelViewCallback;

public:
    // IUknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CAggregatedUnknown::QueryInterface(riid, ppv); };
    STDMETHODIMP_(ULONG) AddRef(void)  { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)  { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, LPENUMIDLIST* ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void** ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void** ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

protected:
    CControlPanelFolder(IUnknown* punkOuter);
    ~CControlPanelFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void** ppv);

    static void GetExecName(LPIDCONTROL pidc, LPTSTR pszParseName, UINT cchParseName);
    static HRESULT GetModuleMapped(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule,
                                   UINT* pidNewIcon, LPTSTR pszApplet, UINT cchApplet);
    static void GetDisplayName(LPIDCONTROL pidc, LPTSTR pszName, UINT cchName);
    static void GetModule(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule);
    static void _GetDescription(LPIDCONTROL pidc, LPTSTR pszDesc, UINT cchDesc);
    static void _GetFullCPLName(LPIDCONTROL pidc, LPTSTR achKeyValName, UINT cchSize);
    BOOL _GetExtPropRegValName(HKEY hkey, LPTSTR pszExpandedName, LPTSTR pszRegValName, UINT cch);
    static BOOL _GetExtPropsKey(HKEY hkeyParent, HKEY * pHkey, const SHCOLUMNID * pscid);
    static LPIDCONTROL _IsValid(LPCITEMIDLIST pidl);
    static LPIDCONTROLW _IsUnicodeCPL(LPIDCONTROL pidc);
    LPCITEMIDLIST GetIDList() { return _pidl; }
    
private:
    friend HRESULT CControlPanel_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

    static HRESULT CALLBACK DFMCallBack(IShellFolder *psf, HWND hwndView,
                                             IDataObject *pdtobj, UINT uMsg,
                                             WPARAM wParam, LPARAM lParam);

    HRESULT _GetDisplayNameForSelf(DWORD dwFlags, STRRET* pstrret);

    LPITEMIDLIST    _pidl;
    IUnknown*       _punkReg;
    HDSA            _hdsaExtPropRegVals; // Array of EPRV_CACHE_ENTRY.

    //
    // An entry in the Extended Property Reg Values cache.
    // This cache is used to minimize the amount of path 'normalization'
    // done when comparing CPL applet paths with the corresponding paths
    // stored for categorization.  
    //
    struct EPRV_CACHE_ENTRY
    {
        LPTSTR pszRegValName;
        LPTSTR pszRegValNameNormalized;
    };

    DWORD _InitExtPropRegValNameCache(HKEY hkey);
    BOOL _LookupExtPropRegValName(HKEY hkey, LPTSTR pszSearchKeyNormalized, LPTSTR pszRegValName, UINT cch);
    DWORD _CacheExtPropRegValName(LPCTSTR pszRegValNameNormalized, LPCTSTR pszRegValName);
    static int CALLBACK _DestroyExtPropsRegValEntry(void *p, void *pData);
    static INT _FilterStackOverflow(INT nException);
    DWORD _NormalizeCplSpec(LPTSTR pszSpecIn, LPTSTR pszSpecOut, UINT cchSpecOut);
    DWORD _NormalizePath(LPCTSTR pszPathIn, LPTSTR pszPathOut, UINT cchPathOut);
    DWORD  _NormalizePathWorker(LPCTSTR pszPathIn, LPTSTR pszPathOut, UINT cchPathOut);
    void _TrimSpaces(LPTSTR psz);

};  

class CControlPanelEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; };
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum) { return E_NOTIMPL; };

    CControlPanelEnum(UINT uFlags);

    HRESULT Init();

private:
    ~CControlPanelEnum();
    BOOL _DoesPolicyAllow(LPCTSTR pszName, LPCTSTR pszFileName);

    LONG _cRef;
    ULONG _uFlags;

    int _iModuleCur;
    int _cControlsOfCurrentModule;
    int _iControlCur;
    int _cControlsTotal;
    int _iRegControls;

    MINST _minstCur;

    ControlData _cplData;
};


//
// This handler isn't defined in shlobjp.h.  
// The only reason I can see is that it references DUI::Element.
//
#define HANDLE_SFVM_GETWEBVIEWBARRICADE(pv, wP, lP, fn) \
    ((fn)((pv), (DUI::Element**)(lP)))

class CControlPanelViewCallback : public CBaseShellFolderViewCB
{
public:
    CControlPanelViewCallback(CControlPanelFolder *pcpf) 
        : _pcpf(pcpf), 
          CBaseShellFolderViewCB(pcpf->GetIDList(), SHCNE_UPDATEITEM),
          _pCplView(NULL),
          _penumWvInfo(NULL)
    { 
        TraceMsg(TF_LIFE, "CControlPanelViewCallback::CControlPanelViewCallback, this = 0x%x", this);
        _pcpf->AddRef();
    }

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CControlPanelViewCallback()
    {
        TraceMsg(TF_LIFE, "CControlPanelViewCallback::~CControlPanelViewCallback, this = 0x%x", this);
        _pcpf->Release();
        ATOMICRELEASE(_penumWvInfo);
        ATOMICRELEASE(_pCplView);
    }

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP)
    {
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
    {
        if (PANE_ZONE == dwPaneID)
            *pdwPane = 2;
        return S_OK;
    }

    HRESULT _OnSFVMGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd);
    HRESULT _OnSFVMForceWebView(DWORD pv, PBOOL bForceWebView);
    HRESULT _OnSFVMGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT _OnSFVMGetWebViewBarricade(DWORD pv, DUI::Element **ppe);
    HRESULT _OnSFVMGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA *pData);
    HRESULT _OnSFVMEnumWebViewTasks(DWORD pv, SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData);
    HRESULT _OnSFVMWindowDestroy(DWORD pv, HWND hwnd);
    HRESULT _OnSFVMUpdateStatusBar(DWORD pv, BOOL bInitialize);

    HRESULT _GetCplView(CPL::ICplView **ppView, bool bInitialize = false);
    HRESULT _GetCplCategoryFromFolderIDList(CPL::eCPCAT *peCategory);
    HRESULT _GetWebViewInfoEnumerator(CPL::IEnumCplWebViewInfo **ppewvi);
    HRESULT _EnumFolderViewIDs(IEnumIDList **ppenumIDs);
    
    CControlPanelFolder      *_pcpf;
    CPL::ICplView            *_pCplView;    // The 'categorized' view content
    CPL::IEnumCplWebViewInfo *_penumWvInfo; 
};


STDMETHODIMP CControlPanelViewCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, _OnSFVMGetHelpTopic);
    HANDLE_MSG(0, SFVM_FORCEWEBVIEW, _OnSFVMForceWebView);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, _OnSFVMGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWBARRICADE, _OnSFVMGetWebViewBarricade);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, _OnSFVMGetWebViewContent);
    HANDLE_MSG(0, SFVM_ENUMWEBVIEWTASKS, _OnSFVMEnumWebViewTasks);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, _OnSFVMWindowDestroy);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, _OnSFVMUpdateStatusBar);
    
    default:
        return E_FAIL;
    }

    return S_OK;
}



HRESULT
CControlPanelViewCallback::_OnSFVMGetHelpTopic(
    DWORD pv,
    SFVM_HELPTOPIC_DATA *phtd
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetHelpTopic");

    ASSERT(NULL != phtd);
    ASSERT(!IsBadWritePtr(phtd, sizeof(*phtd)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = E_FAIL;
    
    phtd->wszHelpFile[0]  = L'\0';
    phtd->wszHelpTopic[0] = L'\0';

    if (IsOS(OS_ANYSERVER))
    {
        //
        // Server has a fixed help URL so we can simply
        // copy it.
        //
        lstrcpynW(phtd->wszHelpTopic,
                  L"hcp://services/centers/homepage",
                  ARRAYSIZE(phtd->wszHelpTopic));
        hr = S_OK;
    }
    else
    {
        if (CPL::CategoryViewIsActive(NULL))
        {
            //
            // Category view is active.
            // Retrieve help URL from the view object.
            //
            CPL::ICplView *pView;
            hr = _GetCplView(&pView);
            if (SUCCEEDED(hr))
            {
                CPL::eCPCAT eCategory;
                hr = _GetCplCategoryFromFolderIDList(&eCategory);
                if (S_OK == hr)
                {
                    //
                    // We're viewing a Control Panel category page.
                    // Ask the view for the help URL for this category.
                    //
                    hr = pView->GetCategoryHelpURL(eCategory, 
                                                   phtd->wszHelpTopic,
                                                   ARRAYSIZE(phtd->wszHelpTopic));
                }
                ATOMICRELEASE(pView);
            }
        }

        if (L'\0' == phtd->wszHelpTopic[0])
        {
            //
            // Either we're in 'classic' view, the 'category choice' page
            // or something failed above.  Return the URL for the basic
            // Control Panel help.
            //
            hr = CPL::BuildHssHelpURL(NULL, phtd->wszHelpTopic, ARRAYSIZE(phtd->wszHelpTopic));
        }
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetHelpTopic", hr);
    return THR(hr);
}


//
// Defview sends SFVM_ENUMWEBVIEWTASKS repeatedly until
// we set the SFVMWVF_NOMORETASKS flag in the data.  With each call we
// return data describing a single menu (caption and items) in the 
// webview pane.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMEnumWebViewTasks(
    DWORD pv, 
    SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMEnumWebViewTasks");

    ASSERT(NULL != pData);
    ASSERT(!IsBadWritePtr(pData, sizeof(*pData)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = S_OK;
    if (NULL == _penumWvInfo)
    {
        hr = _GetWebViewInfoEnumerator(&_penumWvInfo);
    }
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != _penumWvInfo);

        CPL::ICplWebViewInfo *pwvi;
        hr = _penumWvInfo->Next(1, &pwvi, NULL);
        if (S_OK == hr)
        {
            ASSERT(NULL == pData->pHeader);
            hr = pwvi->get_Header(&(pData->pHeader));
            if (SUCCEEDED(hr))
            {
                ASSERT(NULL == pData->penumTasks);
                hr = pwvi->EnumTasks(&(pData->penumTasks));
                if (SUCCEEDED(hr))
                {
                    DWORD dwStyle = 0;
                    hr = pwvi->get_Style(&dwStyle);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // ISSUE-2001/01/02-BrianAu  Revisit this.
                        //   I don't like using an SFVMWVF_XXXXXX flag in the 
                        //   dwStyle returned by get_Style.  That style should
                        //   be defined independently of any SFVMWVF_XXXXX
                        //   flags then translated appropriately here.
                        //
                        pData->idBitmap    = 0; // Default is no bitmap.
                        pData->idWatermark = 0; // No watermark used.
                        if (SFVMWVF_SPECIALTASK & dwStyle)
                        {
                            pData->dwFlags |= SFVMWVF_SPECIALTASK;
                            pData->idBitmap = IDB_CPANEL_ICON_BMP;
                        }
                    }
                }
            }

            ATOMICRELEASE(pwvi);
        }
        else if (S_FALSE == hr)
        {
            //
            // Tell defview the enumeration is complete.
            // Release the info enumerator.
            //
            pData->dwFlags = SFVMWVF_NOMORETASKS;
            ATOMICRELEASE(_penumWvInfo);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMEnumWebViewTasks", hr);
    return THR(hr);
}


//
// Retrieves the proper enumerator of webview information.
//
HRESULT
CControlPanelViewCallback::_GetWebViewInfoEnumerator(
    CPL::IEnumCplWebViewInfo **ppewvi
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_GetWebViewInfoEnumerator");

    ASSERT(NULL != ppewvi);
    ASSERT(!IsBadWritePtr(ppewvi, sizeof(*ppewvi)));

    CPL::ICplView *pView;
    HRESULT hr = _GetCplView(&pView);
    if (SUCCEEDED(hr))
    {
        DWORD dwFlags = 0;
        bool bBarricadeFixedByPolicy;
        bool bCategoryViewActive = CPL::CategoryViewIsActive(&bBarricadeFixedByPolicy);

        if (bBarricadeFixedByPolicy)
        {
            //
            // If the view type is fixed by policy, we don't present
            // controls that allow the user to switch view types.
            //
            dwFlags |= CPVIEW_EF_NOVIEWSWITCH;
        }
        if (bCategoryViewActive)
        {
            CPL::eCPCAT eCategory;
            hr = _GetCplCategoryFromFolderIDList(&eCategory);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    //
                    // Displaying a category page.
                    //
                    hr = pView->EnumCategoryWebViewInfo(dwFlags, eCategory, ppewvi);
                }
                else
                {
                    //
                    // Displaying category choice page.
                    //
                    hr = pView->EnumCategoryChoiceWebViewInfo(dwFlags, ppewvi);
                }
            }
        }
        else
        {
            //
            // Displaying classic view.
            //
            hr = pView->EnumClassicWebViewInfo(dwFlags, ppewvi);
        }
        ATOMICRELEASE(pView);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_GetWebViewInfoEnumerator", hr);
    return THR(hr);
}



//
// Get a pointer to the CCplView object.  If the object is not yet created,
// create one.
//
HRESULT
CControlPanelViewCallback::_GetCplView(
    CPL::ICplView **ppView,
    bool bInitialize
    )
{
    HRESULT hr = S_OK;

    *ppView = NULL;

    IEnumIDList *penumIDs = NULL;
    if (NULL == _pCplView || bInitialize)
    {
        //
        // If creating a new view object or reinitializing an 
        // existing view object, we'll need the most recent list of
        // folder item IDs.
        //
        hr = _EnumFolderViewIDs(&penumIDs);
    }
    if (SUCCEEDED(hr))
    {
        if (NULL == _pCplView)
        {
            //
            // Create a new view object.
            // Give the view CB's site pointer to the CplView object.
            // This is then used to initialize the various command objects
            // contained in the CCplNamespace object.  Some of these command objects
            // need access to the shell browser.  The most generic method of
            // providing this access was to use the site mechanism.
            //
            IUnknown *punkSite;
            hr = GetSite(IID_IUnknown, (void **)&punkSite);
            if (SUCCEEDED(hr))
            {
                hr = CPL::CplView_CreateInstance(penumIDs, punkSite, CPL::IID_ICplView, (void **)&_pCplView);
                ATOMICRELEASE(punkSite);
            }
        }
        else if (bInitialize)
        {
            //
            // Reinitialize the existing view object.
            //
            hr = _pCplView->RefreshIDs(penumIDs);
        }
    }
    if (SUCCEEDED(hr))
    {
        //
        // Create a reference for the caller.
        //
        (*ppView = _pCplView)->AddRef();
    }
    
    ATOMICRELEASE(penumIDs);
    return THR(hr);
}


//
// Get a Category ID number based on the folder's current ID list.
// The Control Panel ID list uses a hidden part to store the
// 'category' ID.  The ID is simply one of the eCPCAT enumeration.
// It is added to the ID list in CPL::COpenCplCategory::Execute().
// This function returns:
//
//     S_OK     - *peCategory contains a valid category ID.
//     S_FALSE  - folder ID list did not contain a category ID.
//     E_FAIL   - folder ID list contains an invalid category ID.
//
HRESULT
CControlPanelViewCallback::_GetCplCategoryFromFolderIDList(
    CPL::eCPCAT *peCategory
    )
{
    ASSERT(NULL != peCategory);
    ASSERT(!IsBadWritePtr(peCategory, sizeof(*peCategory)));

    HRESULT hr = S_FALSE;

    CPL::eCPCAT eCategory = CPL::eCPCAT(-1);
    WCHAR szHidden[10];
    szHidden[0] = L'\0';

    ILGetHiddenStringW(_pcpf->GetIDList(), IDLHID_NAVIGATEMARKER, szHidden, ARRAYSIZE(szHidden));
    if (L'\0' != szHidden[0])
    {
        eCategory = CPL::eCPCAT(StrToInt(szHidden));
        if (CPL::eCPCAT_NUMCATEGORIES > eCategory)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    *peCategory = eCategory;
    return THR(hr);
}


HRESULT
CControlPanelViewCallback::_EnumFolderViewIDs(
    IEnumIDList **ppenumIDs
    )
{
    IUnknown *punkSite;
    HRESULT hr = THR(GetSite(IID_IUnknown, (void **)&punkSite));
    if (SUCCEEDED(hr))
    {
        IDVGetEnum *pdvge;  // private defview interface
        hr = THR(IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge)));
        if (SUCCEEDED(hr))
        {
            const DWORD dwEnumFlags = SHCONTF_NONFOLDERS | SHCONTF_FOLDERS;
            hr = THR(pdvge->CreateEnumIDListFromContents(_pidl, dwEnumFlags, ppenumIDs));
            pdvge->Release();
        }
        punkSite->Release();
    }
    return THR(hr);
}



//
// DefView calls this to obtain information about the view CB's webview
// content.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMGetWebViewContent(
    DWORD pv, 
    SFVM_WEBVIEW_CONTENT_DATA *pData
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewContent");

    ASSERT(NULL != pData);
    ASSERT(!IsBadWritePtr(pData, sizeof(*pData)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = S_OK;
    //
    // Tell defview...
    //
    //   1. We'll provide a 'barricade' if we're in 'category' view mode.
    //      Our 'barricade' is 'category' view.
    //   2. We'll enumerate a set of non-standard webview tasks regardless
    //      of the view mode.  One of these tasks is to switch between 'classic'
    //      view and 'category' view.
    //
    ZeroMemory(pData, sizeof(*pData));
    pData->dwFlags = SFVMWVF_ENUMTASKS | SFVMWVF_CONTENTSCHANGE;

    if (CPL::CategoryViewIsActive(NULL))
    {
        pData->dwFlags |= SFVMWVF_BARRICADE;
    }
    
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewContent", hr);
    return THR(hr);
}


//
// SFVM_UPDATESTATUSBAR handler.
// In 'Category' view, we want no status bar content.
// In 'Classic' view, we want the standard content produced by defview.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMUpdateStatusBar(
    DWORD pv, 
    BOOL bInitialize
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMUpdateStatusBar");

    HRESULT hr;
    if (CPL::CategoryViewIsActive(NULL))
    {
        //
        // 'Category' view.
        // Simply return S_OK.  DefView has already cleared the statusbar.
        // Returning S_OK tells DefView that we'll set the status text ourselves.
        // Therefore, by not setting anything, the statusbar remains empty.
        //
        hr = S_OK;
    }
    else
    {
        //
        // 'Classic' view.  Returning an error code tells defview
        // to handle all the status bar content.
        //
        hr = E_NOTIMPL;
    }
    ASSERT(S_OK == hr || E_NOTIMPL == hr);
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMUpdateStatusBar", hr);
    return hr;
}


//
// Selectively disable web view for this folder (WOW64 thing for the 32-bit
// control panel.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMForceWebView(
    DWORD pv, 
    PBOOL pfForce
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMForceWebView");

    ASSERT(NULL != pfForce);
    ASSERT(!IsBadWritePtr(pfForce, sizeof(*pfForce)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr;

    if (IsOS(OS_WOW6432))
    {
        *pfForce = FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMForceWebView", hr);
    return hr;
}


//
// Tell defview we're DUI (avoids extra legacy work on defview side)
//
HRESULT
CControlPanelViewCallback::_OnSFVMGetWebViewLayout(
    DWORD pv,
    UINT uViewMode,
    SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    pData->dwLayout = SFVMWVL_NORMAL;

    return S_OK;
}


//
// Provide the barricade DUI element.  In Control Panel, our 'barricade'
// is simply our 'Category' view.  We inspect the folder's pidl to determine
// if we display the 'category choice' view or a view for a specific 
// category.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMGetWebViewBarricade(
    DWORD pv, 
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewBarricade");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));

    UNREFERENCED_PARAMETER(pv);

    *ppe = NULL;

    CPL::ICplView *pView;
    HRESULT hr = _GetCplView(&pView, true);
    if (SUCCEEDED(hr))
    {
        CPL::eCPCAT eCategory;
        hr = _GetCplCategoryFromFolderIDList(&eCategory);
        if (SUCCEEDED(hr))
        {
            if (S_OK == hr)
            {
                hr = pView->CreateCategoryElement(eCategory, ppe);
            }
            else
            {
                hr = pView->CreateCategoryChoiceElement(ppe);
            }
        }
        ATOMICRELEASE(pView);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewBarricade", hr);
    return THR(hr);
}


HRESULT 
CControlPanelViewCallback::_OnSFVMWindowDestroy(
    DWORD pv, 
    HWND hwnd
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMWindowDestroy");

    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(hwnd);

    HRESULT hr = S_OK;
    //
    // Need to destroy these in response to window destruction so
    // we break the site chains.  If we don't do this, the 
    // CDefView dtor is never called because our namespace
    // objects have outstanding references to CDefView.
    //
    ATOMICRELEASE(_penumWvInfo);
    ATOMICRELEASE(_pCplView);
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMWindowDestroy", hr);
    return THR(hr);
}

   
// column IDs
typedef enum
{
    CPL_ICOL_NAME = 0,
    CPL_ICOL_COMMENT,
};

const COLUMN_INFO c_cpl_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,     20, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_Comment,  20, IDS_EXCOL_COMMENT),
};

#define PRINTERS_SORT_INDEX 45

const REQREGITEM c_asControlPanelReqItems[] =
{
    { &CLSID_Printers, IDS_PRNANDFAXFOLDER, c_szShell32Dll, -IDI_PRNFLD, PRINTERS_SORT_INDEX, SFGAO_DROPTARGET | SFGAO_FOLDER, NULL},
};

CControlPanelFolder::CControlPanelFolder(IUnknown* punkOuter) :
    CAggregatedUnknown  (punkOuter),
    _pidl               (NULL),
    _punkReg            (NULL),
    _hdsaExtPropRegVals (NULL)
{

}

CControlPanelFolder::~CControlPanelFolder()
{
    if (NULL != _hdsaExtPropRegVals)
    {
        DSA_DestroyCallback(_hdsaExtPropRegVals, 
                            _DestroyExtPropsRegValEntry,
                            NULL);
    }
    if (NULL != _pidl)
    {
        ILFree(_pidl);
    }    
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
}

#define REGSTR_POLICIES_RESTRICTCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictCpl")
#define REGSTR_POLICIES_DISALLOWCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowCpl")

HRESULT CControlPanel_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppvOut)
{
    CControlPanelFolder* pcpf = new CControlPanelFolder(punkOuter);
    if (NULL != pcpf)
    {
        static REGITEMSPOLICY ripControlPanel =
        {
            REGSTR_POLICIES_RESTRICTCPL,
            REST_RESTRICTCPL,
            REGSTR_POLICIES_DISALLOWCPL,
            REST_DISALLOWCPL
        };
        REGITEMSINFO riiControlPanel =
        {
            REGSTR_PATH_EXPLORER TEXT("\\ControlPanel\\NameSpace"),
            &ripControlPanel,
            TEXT(':'),
            SHID_CONTROLPANEL_REGITEM_EX,  // note, we don't really have a sig
            1,
            SFGAO_CANLINK,
            ARRAYSIZE(c_asControlPanelReqItems),
            c_asControlPanelReqItems,
            RIISA_ALPHABETICAL,
            NULL,
            // we want everything from after IDREGITEM.bOrder to the first 2 cBuf bytes to be filled with 0's
            (FIELD_OFFSET(IDCONTROL, cBuf) + 2) - (FIELD_OFFSET(IDREGITEM, bOrder) + 1),
            SHID_CONTROLPANEL_REGITEM,
        };

        if (IsOS(OS_WOW6432))
        {
            // The crippled 32-bit control panel on IA64 should show less/other stuff
            riiControlPanel.pszRegKey = REGSTR_PATH_EXPLORER TEXT("\\ControlPanelWOW64\\NameSpace");
            riiControlPanel.iReqItems = 0;
        }

        //
        //  we dont want to return a naked 
        //  control panel folder.  this should
        //  only fail with memory probs.
        //
        HRESULT hr = CRegFolder_CreateInstance(&riiControlPanel, (IUnknown*) (IShellFolder2*) pcpf,
                                  IID_IUnknown, (void **) &(pcpf->_punkReg));
        if (SUCCEEDED(hr))                                  
        {                                  
            hr = pcpf->QueryInterface(riid, ppvOut);
        }
        
        pcpf->Release();
        return hr;
    }
    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CControlPanelFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CControlPanelFolder, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CControlPanelFolder, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CControlPanelFolder, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CControlPanelFolder, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENTMULTI(CControlPanelFolder, IPersist, IPersistFolder2),       // IID_IPersist
        { 0 },
    };

    if (_punkReg && RegGetsFirstShot(riid))
    {
        return _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        return QISearch(this, qit, riid, ppv);
    }
}

// Unicode .cpl's will be flagged by having oName = 0, oInfo = 0,
// cBuf[0] = '\0', and cBuf[1] = UNICODE_CPL_SIGNATURE_BYTE

#define UNICODE_CPL_SIGNATURE_BYTE   (BYTE)0x6a

LPIDCONTROLW CControlPanelFolder::_IsUnicodeCPL(LPIDCONTROL pidc)
{
    ASSERT(_IsValid((LPCITEMIDLIST)pidc));
    
    if ((pidc->oName == 0) && (pidc->oInfo == 0) && (pidc->cBuf[0] == '\0') && (pidc->cBuf[1] == UNICODE_CPL_SIGNATURE_BYTE))
        return (LPIDCONTROLW)pidc;
    return NULL;
}

HRESULT _IDControlCreateW(PCWSTR pszModule, int idIcon, PCWSTR pszName, PCWSTR pszInfo, LPITEMIDLIST *ppidl)
{
    UINT cbModule = CbFromCchW(lstrlen(pszModule) + 1);
    UINT cbName = CbFromCchW(lstrlen(pszName) + 1);
    UINT cbInfo = CbFromCchW(lstrlen(pszInfo) + 1);
    UINT cbIDC = FIELD_OFFSET(IDCONTROLW, cBufW) + cbModule + cbName + cbInfo;

    *ppidl = _ILCreate(cbIDC + sizeof(USHORT));

    if (*ppidl)
    {
        IDCONTROLW *pidc = (IDCONTROLW *) *ppidl;
        //  init the static bits (ILCreate() zero inits)
        pidc->idIcon = idIcon;
        //  pidc->oName = 0;
        //  pidc->oInfo = 0;
        //  pidc->cBuf[0] = '\0';
        pidc->cBuf[1] = UNICODE_CPL_SIGNATURE_BYTE;
        //  pidc->dwFlags = 0;

        //  copy module
        ualstrcpy(pidc->cBufW, pszModule);

        //  copy name
        pidc->oNameW = (USHORT)(cbModule / sizeof(pszModule[0]));
        ualstrcpy(pidc->cBufW + pidc->oNameW, pszName);

        //  copy info
        pidc->oInfoW = pidc->oNameW + (USHORT)(cbName / sizeof(pszName[0]));
        ualstrcpy(pidc->cBufW + pidc->oInfoW, pszInfo);

        pidc->cb = (USHORT)cbIDC;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT _IDControlCreateA(PCSTR pszModule, int idIcon, PCSTR pszName, PCSTR pszInfo, LPITEMIDLIST *ppidl)
{
    UINT cbModule = CbFromCchA(lstrlenA(pszModule) + 1);
    UINT cbName = CbFromCchA(lstrlenA(pszName) + 1);
    UINT cbInfo = CbFromCchA(lstrlenA(pszInfo) + 1);
    UINT cbIDC = FIELD_OFFSET(IDCONTROL, cBuf) + cbModule + cbName + cbInfo;

    *ppidl = _ILCreate(cbIDC + sizeof(USHORT));

    if (*ppidl)
    {
        IDCONTROL *pidc = (IDCONTROL *) *ppidl;
        //  init the static bits (ILCreate() zero inits)
        pidc->idIcon = idIcon;

        //  copy module
        lstrcpyA(pidc->cBuf, pszModule);

        //  copy name
        pidc->oName = (USHORT)(cbModule / sizeof(pszModule[0]));
        lstrcpyA(pidc->cBuf + pidc->oName, pszName);

        //  copy info
        pidc->oInfo = pidc->oName + (USHORT)(cbName / sizeof(pszName[0]));
        lstrcpyA(pidc->cBuf + pidc->oInfo, pszInfo);

        pidc->cb = (USHORT)cbIDC;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT IDControlCreate(LPTSTR pszModule, int idIcon, LPTSTR pszName, LPTSTR pszInfo, LPITEMIDLIST *ppidc)
{
    CHAR    szModuleA[MAX_PATH];
    CHAR    szNameA[MAX_CCH_CPLNAME];
    CHAR    szInfoA[MAX_CCH_CPLINFO];

    ASSERT(lstrlen(pszModule) < MAX_PATH);
    ASSERT(lstrlen(pszName) < MAX_CCH_CPLNAME);
    ASSERT(lstrlen(pszInfo) < MAX_CCH_CPLINFO);

    // See if any of the three string inputs cannot be represented as ANSI
    if (DoesStringRoundTrip(pszModule, szModuleA, ARRAYSIZE(szModuleA))
    && DoesStringRoundTrip(pszName, szNameA, ARRAYSIZE(szNameA))
    && DoesStringRoundTrip(pszInfo, szInfoA, ARRAYSIZE(szInfoA)))
    {
        return _IDControlCreateA(szModuleA, idIcon, szNameA, szInfoA, ppidc);
    }
    else
    {
        // Must create a full Unicode IDL
        return _IDControlCreateW(pszModule, idIcon, pszName, pszInfo, ppidc);
    }
}

LPIDCONTROL CControlPanelFolder::_IsValid(LPCITEMIDLIST pidl)
{
    //
    // the original design had no signature
    // so we are left just trying to filter out the regitems that might
    // somehow get to us.  we used to SIL_GetType(pidl) != SHID_CONTROLPANEL_REGITEM)
    // but if somehow we had an icon index that had the low byte equal
    // to SHID_CONTROLPANEL_REGITEM (0x70) we would invalidate it. DUMB!
    //
    // so we will complicate the heuristics a little bit.  lets assume that
    // all icon indeces will range between 0xFF000000 and 0x00FFFFFF
    // (or -16777214 and 16777215, 16 million each way should be plenty).
    // of course this could easily get false positives, but there really 
    // isnt anything else that we can check against.
    //
    // we will also check a minimum size.
    //
    if (pidl && pidl->mkid.cb > FIELD_OFFSET(IDCONTROL, cBuf))
    {
        LPIDCONTROL pidc = (LPIDCONTROL)pidl;
        int i = pidc->idIcon & 0xFF000000;
        if (i == 0 || i == 0xFF000000)
            return pidc;
    }
    return NULL;
}

#define REGVAL_CTRLFLDRITEM_MODULE      TEXT("Module")
#define REGVAL_CTRLFLDRITEM_ICONINDEX   TEXT("IconIndex")
#define REGVAL_CTRLFLDRITEM_NAME        TEXT("Name")
#define REGVAL_CTRLFLDRITEM_INFO        TEXT("Info")

HRESULT GetPidlFromCanonicalName(LPCTSTR pszCanonicalName, LPITEMIDLIST* ppidl)
{
    HRESULT hr = E_FAIL;
    *ppidl = NULL;
    
    TCHAR szRegPath[MAX_PATH] = REGSTR_PATH_EXPLORER TEXT("\\ControlPanel\\NameSpace\\");
    StrCatBuff(szRegPath, pszCanonicalName, ARRAYSIZE(szRegPath));
    
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME], szInfo[MAX_CCH_CPLINFO];
        DWORD dwIconIndex = 0, dwType, cbSize = sizeof(szModule);

        if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_MODULE, NULL, &dwType, (LPBYTE)szModule, &cbSize) == ERROR_SUCCESS)
        {
            cbSize = sizeof(dwIconIndex);
            if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_ICONINDEX, NULL, &dwType, (LPBYTE)&dwIconIndex, &cbSize) != ERROR_SUCCESS)
            {
                dwIconIndex = 0;
            }
            cbSize = sizeof(szName);
            if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_NAME, NULL, &dwType, (LPBYTE)szName, &cbSize) != ERROR_SUCCESS)
            {
                szName[0] = TEXT('\0');
            }
            cbSize = sizeof(szInfo);
            if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_INFO, NULL, &dwType, (LPBYTE)szInfo, &cbSize) != ERROR_SUCCESS)
            {
                szInfo[0] = TEXT('\0');
            }

            hr = IDControlCreate(szModule, EIRESID(dwIconIndex), szName, szInfo, ppidl);
        }
        RegCloseKey(hKey);
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::ParseDisplayName(HWND hwnd, LPBC pbc,  WCHAR* pszName, 
                                                   ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttrib)
{
    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;
    if (!pszName)
        return E_INVALIDARG;

    TCHAR szCanonicalName[MAX_PATH];
    SHUnicodeToTChar(pszName, szCanonicalName, ARRAYSIZE(szCanonicalName));

    HRESULT hr = GetPidlFromCanonicalName(szCanonicalName, ppidl);
    if (SUCCEEDED(hr))
    {
        // First, make sure that the pidl we obtained is valid
        DWORD dwAttrib = SFGAO_VALIDATE;
        hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, &dwAttrib);
        // Now, get the other attributes if they were requested
        if (SUCCEEDED(hr) && pdwAttrib && *pdwAttrib)
        {
            hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttrib);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    if ((*prgfInOut & SFGAO_VALIDATE) && cidl)
    {
        HRESULT hr = E_INVALIDARG;

        LPIDCONTROL pidc = _IsValid(*apidl);
        if (pidc)
        {
            TCHAR szModule[MAX_PATH];
            GetModuleMapped((LPIDCONTROL)*apidl, szModule, ARRAYSIZE(szModule), 
                NULL, NULL, 0);
            if (PathFileExists(szModule))
                hr = S_OK;
            else
                hr = E_FAIL;
        }

        return hr;
    }

    *prgfInOut &= SFGAO_CANLINK;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                                REFIID riid, UINT *pres, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPIDCONTROL pidc = cidl && apidl ? _IsValid(apidl[0]) : NULL;

    *ppv = NULL;

    if (pidc && (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
    {
        TCHAR achParams[MAX_PATH+1+32+1+MAX_CCH_CPLNAME]; // See wsprintf below
        TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME];
        UINT idIcon;

        // Map the icon ID for upgraded win95 shortcuts to CPLs
        GetModuleMapped(pidc, szModule, ARRAYSIZE(szModule), &idIcon, szName, ARRAYSIZE(szName));

        // Use the applet name in the pid if we didn't override the name in GetModuleMapped
        if (*szName == 0)
            GetDisplayName(pidc, szName, ARRAYSIZE(szName));

        wsprintf(achParams, TEXT("%s,%d,%s"), szModule, idIcon, szName);

        hr = ControlExtractIcon_CreateInstance(achParams, riid, ppv);
    }
    else if (pidc && IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(_pidl, hwnd, cidl, apidl, 
            SAFECAST(this, IShellFolder*), DFMCallBack, NULL, NULL, (IContextMenu**) ppv);
    }
    else if (pidc && IsEqualIID(riid, IID_IDataObject))
    {
        hr = CIDLData_CreateFromIDArray(_pidl, cidl, apidl, (IDataObject**) ppv);
    }
    else if (pidc && IsEqualIID(riid, IID_IQueryInfo))
    {
        TCHAR szTemp[MAX_CCH_CPLINFO];
        _GetDescription(pidc, szTemp, ARRAYSIZE(szTemp));
        hr = CreateInfoTipFromText(szTemp, riid, ppv);
    }

    return hr;
}

STDMETHODIMP CControlPanelFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    *pGuid = SRCID_SFileSearch;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    if (!(grfFlags & SHCONTF_NONFOLDERS))
        return S_FALSE;

    HRESULT hr;
    CControlPanelEnum* pesf = new CControlPanelEnum(grfFlags);
    if (pesf)
    {
        // get list of module names
        hr = pesf->Init();
        if (SUCCEEDED(hr))
            pesf->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
            
        pesf->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CControlPanelFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPIDCONTROL pidc1 = _IsValid(pidl1);
    LPIDCONTROL pidc2 = _IsValid(pidl2);

    if (pidc1 && pidc2)
    {
        TCHAR szName1[max(MAX_CCH_CPLNAME, MAX_CCH_CPLINFO)];
        TCHAR szName2[max(MAX_CCH_CPLNAME, MAX_CCH_CPLINFO)];
        int iCmp;

        switch (iCol)
        {
        case CPL_ICOL_COMMENT:
            _GetDescription(pidc1, szName1, ARRAYSIZE(szName1));
            _GetDescription(pidc2, szName2, ARRAYSIZE(szName2));
                // They're both ANSI, so we can compare directly
            iCmp = StrCmpLogicalRestricted(szName1, szName2);
            if (iCmp != 0)
                return ResultFromShort(iCmp);
            // Fall through if the help field compares the same...
              
        case CPL_ICOL_NAME:
        default:
            GetDisplayName(pidc1, szName1, ARRAYSIZE(szName1));
            GetDisplayName(pidc2, szName2, ARRAYSIZE(szName2));
            return ResultFromShort(StrCmpLogicalRestricted(szName1, szName2));
        }
    }
    
    return E_INVALIDARG;
}

//
// background (no items) context menu callback
//

HRESULT CALLBACK CControls_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMAND:
        hr = S_FALSE;   // view menu items, use the default code.
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

STDMETHODIMP CControlPanelFolder::CreateViewObject(HWND hwnd, REFIID riid, void** ppv)
{
    HRESULT hr;
    if (IsEqualIID(riid, IID_IShellView))
    {
        if (SHRestricted(REST_NOCONTROLPANEL))
        {
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                            MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
            hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        }
        else
        {
            SFV_CREATE sSFV;

            sSFV.cbSize   = sizeof(sSFV);
            sSFV.psvOuter = NULL;
            sSFV.psfvcb   = new CControlPanelViewCallback(this);

            QueryInterface(IID_IShellFolder, (void**) &sSFV.pshf);   // in case we are agregated

            hr = SHCreateShellFolderView(&sSFV, (IShellView**) ppv);

            if (sSFV.pshf)
                sSFV.pshf->Release();

            if (sSFV.psfvcb)
                sSFV.psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(NULL, hwnd, 0, NULL, 
            SAFECAST(this, IShellFolder*), CControls_DFMCallBackBG, NULL, NULL, (IContextMenu**) ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pstrret)
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelFolder::GetDisplayNameOf");
    HRESULT hr = E_INVALIDARG;
    
    LPIDCONTROL pidc = _IsValid(pidl);
    if (pidc)
    {
        TCHAR szName[max(MAX_PATH, MAX_CCH_CPLNAME)];
        if ((dwFlags & (SHGDN_FORPARSING | SHGDN_INFOLDER | SHGDN_FORADDRESSBAR)) == ((SHGDN_FORPARSING | SHGDN_INFOLDER)))
        {
            GetModule(pidc, szName, ARRAYSIZE(szName));
        }
        else
        {
            GetDisplayName(pidc, szName, ARRAYSIZE(szName));
        }
        hr = StringToStrRet(szName, pstrret);
    }
    else if (IsSelf(1, &pidl))
    {
        //
        // Control Panel is registered with "WantsFORDISPLAY".
        //
        hr = _GetDisplayNameForSelf(dwFlags, pstrret);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelFolder::GetDisplayNameOf", hr);
    return THR(hr);
}


HRESULT
CControlPanelFolder::_GetDisplayNameForSelf(
    DWORD dwFlags, 
    STRRET* pstrret
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelFolder::_GetDisplayNameForSelf");
    //
    // This code only formats the folder name for display purposes.
    //
    const bool bForParsing    = (0 != (SHGDN_FORPARSING & dwFlags));
    const bool bForAddressBar = (0 != (SHGDN_FORADDRESSBAR & dwFlags));
    
    ASSERT(!bForParsing || bForAddressBar);

    HRESULT hr = S_FALSE;
    if (CPL::CategoryViewIsActive(NULL))
    {
        WCHAR szHidden[10];
        szHidden[0] = L'\0';

        ILGetHiddenStringW(_pidl, IDLHID_NAVIGATEMARKER, szHidden, ARRAYSIZE(szHidden));
        if (L'\0' != szHidden[0])
        {
            //
            // The folder pidl has a hidden navigation marker.  For Control Panel,
            // this is a category number.  Translate the category number to
            // the category title and use that in the display name for the folder.
            //
            WCHAR szCategory[MAX_PATH];
            szCategory[0] = L'\0';
            const CPL::eCPCAT eCategory = CPL::eCPCAT(StrToInt(szHidden));
            hr = CPL::CplView_GetCategoryTitle(eCategory, szCategory, ARRAYSIZE(szCategory));
            if (SUCCEEDED(hr))
            {
                //
                // Ex: "Appearance and Themes"
                //
                hr = StringToStrRet(szCategory, pstrret);
            }
        }
    }
    
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelFolder::_GetDisplayNameForSelf", hr);
    return THR(hr);
}
    

STDMETHODIMP CControlPanelFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName,
                                            DWORD dwReserved, LPITEMIDLIST* ppidlOut)
{
    return E_FAIL;
}

STDMETHODIMP CControlPanelFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    return E_NOTIMPL;
}

//
// Implementing this to handle Categorization of CPL applets.
//

STDMETHODIMP CControlPanelFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_FAIL;

    LPIDCONTROL pidc = _IsValid(pidl);
    if (pidc)
    {
        if (IsEqualSCID(*pscid, SCID_CONTROLPANELCATEGORY))
        {
            HKEY hkey;
            TCHAR achCPLName[MAX_CPL_EXEC_NAME], achRegName[MAX_CPL_EXEC_NAME];      
            _GetFullCPLName(pidc, achCPLName, ARRAYSIZE(achCPLName));

            if (_GetExtPropsKey(HKEY_LOCAL_MACHINE, &hkey, pscid))
            {
                if (_GetExtPropRegValName(hkey, achCPLName, achRegName, ARRAYSIZE(achRegName)))
                {
                    hr = GetVariantFromRegistryValue(hkey, achRegName, pv);
                }            
                RegCloseKey(hkey);            
            }
            if (FAILED(hr)) // maybe it exists under HKCU
            {
                if (_GetExtPropsKey(HKEY_CURRENT_USER, &hkey, pscid))
                {
                    if (_GetExtPropRegValName(hkey, achCPLName, achRegName, ARRAYSIZE(achRegName)))
                    {
                        hr = GetVariantFromRegistryValue(hkey, achRegName, pv);
                    }
                    RegCloseKey(hkey);            
                }
           } 
        }            
        else if (IsEqualSCID(*pscid, SCID_Comment))
        {
            TCHAR szDesc[MAX_PATH] = {0};
            _GetDescription(pidc, szDesc, ARRAYSIZE(szDesc));

            hr = InitVariantFromStr(pv, szDesc);
        }
    }
    return hr;
}



//
// This function takes a registry key (hkey) and goes through all the value names under that key. 
// It expands any environment variables in the value names and then compares them to the input value 
// (pszFullName). On finding a match it returns the (unexpanded) key name in pszRegValName. 
//  
// pszFullName is of the form = C:\WINNT\System32\main.cpl,keyboard
//
// The corresponding registry value name would be   = %SystemRoot%\System32\main.cpl,keyboard
// or it could only be the filepath portion         = %SystemRoot%\System32\main.cpl 
// if all the applets in that .cpl file belong to the same category.
//
BOOL 
CControlPanelFolder::_GetExtPropRegValName(
    HKEY hkey, 
    LPTSTR pszFullName,    // This is modified only temporarily.
    LPTSTR pszRegValName, 
    UINT cch
    )
{                
    ASSERT(NULL != hkey);
    ASSERT(NULL != pszFullName);
    ASSERT(NULL != pszRegValName);
    ASSERT(!IsBadWritePtr(pszRegValName, cch * sizeof(*pszRegValName)));
    
    TCHAR szSearchKeyNormalized[MAX_CPL_EXEC_NAME];
    //
    // Normalize the CPL spec we're comparing with.
    //
    DWORD dwResult = TW32(_NormalizeCplSpec(pszFullName, 
                                            szSearchKeyNormalized, 
                                            ARRAYSIZE(szSearchKeyNormalized)));
    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Look it up in the cache.
        //
        if (_LookupExtPropRegValName(hkey, szSearchKeyNormalized, pszRegValName, cch))
        {
            return TRUE;
        }
    }
    *pszRegValName = 0;
    return FALSE;  
}

//
// ----------------------------------------------------------------------------
// What is 'normalization' and why do we need this caching?
//
// Starting with Windows XP, CPL applets can be categorized so that they
// appear in one of the several Control Panel categories.  The 'category'
// of an applet is stored in the registry as an 'extended property' value.
// The categorization data in the registry is stored in name-value pairs.
// The 'name' is the CPL's filesystem path with an optional applet name
// appended.  The 'value' is the CPL's category.
//
// When looking up the category for an applet, we build the CPL's 'name'
// from the path and applet name.  See _GetFullCPLName().
// This string is then used as a 'key' to locate the associated category
// 'extended property' value in the registry.
//
// The problem is that it's possible for two filesystem paths to refer
// to the same file yet be lexically different from one another.  Issues
// such as embedded environment variables and long (LFN) vs. short (SFN)
// file names can create these lexical differences.  In order to properly
// compare paths, each path must be 'normalized'.  This is done by expanding
// environment variables, converting any LFN paths to their SFN counterpart
// and removing any leading and trailing spaces.  Only then can the paths
// be correctly compared.  Windows XP bug 328304 illuminated this requirement.
//
// Normalizing a name is a bit expensive, especially the LFN->SFN conversion
// which must hit the filesystem. To minimize the number of normalizations,
// I've added a simple cache.  Nothing fancy.  It's unsorted and lookup
// is linear.  The cache is initialized the first time it is needed and
// it remains available until the CControlPanelFolder object is destroyed.
//
// brianau - 03/08/01
// 
// ----------------------------------------------------------------------------
//
// Retrieve the name of the 'extended property' reg value
// corresponding to a particular CPL.  The 'key' is a 'normalized'
// CPL name string.
//
// Assume a search key: 
//
//      "C:\WINNT\System32\main.cpl,keyboard"
//
// If an 'extended property' reg value with this name is found...
//
//      "C:\WINNT\System32\main.cpl,keyboard"
//
// ...then it is considered a match.  This means that only the "keyboard"
// applet provided by main.cpl is in the category associated with this
// entry.
//
// If an 'extended property' reg value with this name is found...
//
//      "C:\WINNT\System32\main.cpl"
//
// ...then it is also considered a match.  This means that ALL applets
// provided by main.cpl are in the category associated with this
// entry.
//
BOOL
CControlPanelFolder::_LookupExtPropRegValName(
    HKEY hkey,
    LPTSTR pszSearchKeyNormalized,
    LPTSTR pszRegValName,
    UINT cch
    )
{
    ASSERT(NULL != hkey);
    ASSERT(NULL != pszSearchKeyNormalized);
    ASSERT(NULL != pszRegValName);
    ASSERT(!IsBadWritePtr(pszRegValName, cch * sizeof(*pszRegValName)));

    BOOL bFound = FALSE;
    
    if (NULL == _hdsaExtPropRegVals)
    {
        //
        // Create and initialize (fill) the cache.
        //
        TW32(_InitExtPropRegValNameCache(hkey));
    }
    if (NULL != _hdsaExtPropRegVals)
    {
        //
        // Search is simply linear.
        //
        int const cEntries = DSA_GetItemCount(_hdsaExtPropRegVals);
        for (int i = 0; i < cEntries && !bFound; i++)
        {
            EPRV_CACHE_ENTRY *pEntry = (EPRV_CACHE_ENTRY *)DSA_GetItemPtr(_hdsaExtPropRegVals, i);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                //
                // Compare the normalized values.  First do a complete
                // comparison of the entire string.
                //
                if (0 == StrCmpI(pEntry->pszRegValNameNormalized, pszSearchKeyNormalized))
                {
                    bFound = TRUE;
                }
                else
                {
                    LPTSTR pszComma = StrChr(pszSearchKeyNormalized, TEXT(','));
                    if (NULL != pszComma)
                    {
                        //
                        // Compare only the path parts.
                        //
                        const DWORD cchPath = pszComma - pszSearchKeyNormalized;
                        if (0 == StrCmpNI(pEntry->pszRegValNameNormalized, 
                                          pszSearchKeyNormalized, 
                                          cchPath))
                        {
                            bFound = TRUE;
                        }
                    }
                }
                if (bFound)
                {
                    lstrcpyn(pszRegValName, pEntry->pszRegValName, cch);
                }
            }
        }
    }
    return bFound;
}


//
// Create and initialize the 'extended properties' value name
// cache.  The cache is simply a DSA of type EPRV_CACHE_ENTRY.
// Each entry contains the normalized form of the reg value
// name paired with the reg value name as read from the registry
// (not normalized).  The normalized value is the 'key'.
//
DWORD
CControlPanelFolder::_InitExtPropRegValNameCache(
    HKEY hkey
    )
{
    ASSERT(NULL != hkey);
    ASSERT(NULL == _hdsaExtPropRegVals);

    DWORD dwResult = ERROR_SUCCESS;
    _hdsaExtPropRegVals = DSA_Create(sizeof(EPRV_CACHE_ENTRY), 32);
    if (NULL == _hdsaExtPropRegVals)
    {
        dwResult = TW32(ERROR_OUTOFMEMORY);
    }
    else
    {
        TCHAR szRegValName[MAX_CPL_EXEC_NAME];
        DWORD dwIndex = 0;
        while (ERROR_SUCCESS == dwResult)
        {
            DWORD dwType;    
            DWORD dwSize = ARRAYSIZE(szRegValName);
            dwResult = RegEnumValue(hkey, 
                                    dwIndex++, 
                                    szRegValName, 
                                    &dwSize, 
                                    NULL, 
                                    &dwType, 
                                    NULL, 
                                    NULL);
            
            if (ERROR_SUCCESS == dwResult)
            {
                //
                // We are interested in DWORD values only.
                //
                if (REG_DWORD == dwType)
                {
                    //
                    // Normalize the value name to create the 'key'
                    // string then cache the pair.
                    //
                    TCHAR szRegValueNameNormalized[MAX_CPL_EXEC_NAME];
                    dwResult = TW32(_NormalizeCplSpec(szRegValName, 
                                                      szRegValueNameNormalized, 
                                                      ARRAYSIZE(szRegValueNameNormalized)));
                    
                    if (ERROR_SUCCESS == dwResult)
                    {
                        dwResult = TW32(_CacheExtPropRegValName(szRegValueNameNormalized,
                                                                szRegValName));
                    }
                    else if (ERROR_INVALID_NAME == dwResult)
                    {
                        //
                        // If the path read from the registry is invalid,
                        // _NormalizeCplSpec will return ERROR_INVALID_NAME.
                        // This value is originally returned by GetShortPathName().
                        // We don't want an invalid path in one reg entry
                        // to prevent the caching of subsequent valid paths so
                        // we convert this error value to ERROR_SUCCESS.
                        //
                        dwResult = ERROR_SUCCESS;
                    }
                }
            }
        }
        if (ERROR_NO_MORE_ITEMS == dwResult)
        {
            dwResult = ERROR_SUCCESS;
        }
    }
    return TW32(dwResult);
}


//
// Insert an entry into the 'extended properties' reg value name
// cache.
//
DWORD
CControlPanelFolder::_CacheExtPropRegValName(
    LPCTSTR pszRegValNameNormalized,
    LPCTSTR pszRegValName
    )
{
    ASSERT(NULL != _hdsaExtPropRegVals);
    ASSERT(NULL != pszRegValNameNormalized);
    ASSERT(NULL != pszRegValName);

    DWORD dwResult = ERROR_SUCCESS;
    EPRV_CACHE_ENTRY entry = { NULL, NULL };
    
    if (FAILED(SHStrDup(pszRegValNameNormalized, &entry.pszRegValNameNormalized)) ||
        FAILED(SHStrDup(pszRegValName, &entry.pszRegValName)) ||
        (-1 == DSA_AppendItem(_hdsaExtPropRegVals, &entry)))
    {
        _DestroyExtPropsRegValEntry(&entry, NULL);
        dwResult = ERROR_OUTOFMEMORY;
    }
    return TW32(dwResult);
}


//
// Destroy the contents of a EPRV_CACHE_ENTRY structure.
// This is used by DSA_DestroyCallback when the cache is 
// destroyed.
//
int CALLBACK
CControlPanelFolder::_DestroyExtPropsRegValEntry(  // [static]
    void *p,
    void *pData
    )
{
    EPRV_CACHE_ENTRY *pEntry = (EPRV_CACHE_ENTRY *)p;
    ASSERT(NULL != pEntry);
    //
    // Checks for NULL are necessary as we also call this directly
    // from _CacheExtPropRegValName in the case of a failure to
    // add the entry to the cache.
    //
    if (NULL != pEntry->pszRegValName)
    {
        SHFree(pEntry->pszRegValName);
        pEntry->pszRegValName = NULL;
    }
    if (NULL != pEntry->pszRegValNameNormalized)
    {
        SHFree(pEntry->pszRegValNameNormalized);
        pEntry->pszRegValNameNormalized = NULL;
    }
    return 1;
}


//
// Given a CPL applet spec consisting of a path and an optional
// argument, this function returns the spec with the following:
//
//  1. Expands all embedded environment variables.
//  2. Shortens all LFN path strings to their SFN equivalents.
//  3. Removes leading and trailing whitespace from the path.
//  4. Removes leading and trailing whitespace from the arguments.
//
DWORD
CControlPanelFolder::_NormalizeCplSpec(
    LPTSTR pszSpecIn,
    LPTSTR pszSpecOut,
    UINT cchSpecOut
    )
{
    ASSERT(NULL != pszSpecIn);
    ASSERT(!IsBadWritePtr(pszSpecIn, sizeof(*pszSpecIn) * lstrlen(pszSpecIn) + 1));
    ASSERT(NULL != pszSpecOut);
    ASSERT(!IsBadWritePtr(pszSpecOut, cchSpecOut * sizeof(*pszSpecOut)));
    
    //
    // Temporarily truncate the spec at the end of the path part
    // if the spec contains trialing arguments (i.e. an applet name in
    // a multi-applet CPL).  This is why the pszSpecIn argument can't be
    // constant.  I don't want to create a temporary buffer just for this
    // so we modify the input string.  
    //
    LPTSTR pszArgs = StrChr(pszSpecIn, TEXT(','));
    if (NULL != pszArgs)
    {
        *pszArgs = 0;
    }
    DWORD dwResult = TW32(_NormalizePath(pszSpecIn, pszSpecOut, cchSpecOut));
    if (NULL != pszArgs)
    {
        //
        // Quick, put the comma back before anyone notices.
        //
        *pszArgs = TEXT(',');
    }
    if (ERROR_SUCCESS == dwResult)
    {
        //
        // The name contained a comma so we need to copy it and the 
        // trailing argument to the output buffer.
        //
        if (NULL != pszArgs)
        {
            const UINT cchPath = lstrlen(pszSpecOut);
            const UINT cchArgs = lstrlen(pszArgs);
            if (cchArgs < (cchSpecOut - cchPath))
            {
                lstrcpy(pszSpecOut + cchPath, pszArgs);
                //
                // Trim leading and trailing whitespace around the argument(s).
                // This will convert ", keyboard " to ",keyboard".
                //
                _TrimSpaces(pszSpecOut + cchPath + 1);
            }
            else
            {
                dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }
    return TW32(dwResult);
}
   

//
// Wraps _NormalizePathWorker to handle the possible stack overflow
// exception generated by the use of _alloca().
//
DWORD
CControlPanelFolder::_NormalizePath(
    LPCTSTR pszPathIn,
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    //
    // NormalizePathWorker uses _alloca() to allocate a stack buffer.
    // Need to handle the case where the stack is all used up.  Unlikely
    // but it could happen.
    //
    DWORD dwResult;
    __try
    {
        dwResult = TW32(_NormalizePathWorker(pszPathIn, pszPathOut, cchPathOut));
    }
    __except(_FilterStackOverflow(GetExceptionCode()))
    {
        dwResult = TW32(ERROR_STACK_OVERFLOW);
    }
    return TW32(dwResult);
}


INT
CControlPanelFolder::_FilterStackOverflow(  // [static]
    INT nException
    )
{
    if (STATUS_STACK_OVERFLOW == nException)
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }
    return EXCEPTION_CONTINUE_SEARCH;
}
        

//
// Given a path string, this function expands all environment variables and
// converts all LFN strings to SFN strings.  This looks like a large function.
// It's really just one call to ExpandEnvironmentStrings() and one call to
// GetShortPathName() wrapped with some extra housekeeping.
//
DWORD 
CControlPanelFolder::_NormalizePathWorker(
    LPCTSTR pszPathIn,
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    ASSERT(NULL != pszPathIn);
    ASSERT(NULL != pszPathOut);
    ASSERT(!IsBadWritePtr(pszPathOut, cchPathOut * sizeof(*pszPathOut)));

    DWORD dwResult = ERROR_SUCCESS;
    //
    // _alloca generates a stack fault exception if insufficient stack space
    // is available.  It is not appropriate to check the return value.
    // This function is wrapped by _NormalizePath to handle the exception.
    //
    const DWORD cchTemp = cchPathOut;
    LPTSTR pszTemp = (LPTSTR)_alloca(cchPathOut * sizeof(*pszPathOut));
    
    //
    // Expand the entire string once to catch any env vars in either the path
    // or in any arguments.
    //
    const DWORD cchExpanded = ExpandEnvironmentStrings(pszPathIn, pszTemp, cchTemp);
    if (0 == cchExpanded)
    {
        dwResult = TW32(GetLastError());
    }
    else if (cchExpanded > cchTemp)
    {
        dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Trim any leading and trailing spaces.
        //
        _TrimSpaces(pszTemp);
        //
        // Convert the path part to it's short-name equivalent.  This allows
        // us to compare a LFN and a SFN that resolve to the same actual file.
        // Note that this will fail if the file doesn't exist.
        // GetShortPath supports the src and dest ptrs referencing the same memory.
        //
        const DWORD cchShort = GetShortPathName(pszTemp, pszPathOut, cchPathOut);
        if (0 == cchShort)
        {
            dwResult = GetLastError();
            if (ERROR_FILE_NOT_FOUND == dwResult || 
                ERROR_PATH_NOT_FOUND == dwResult ||
                ERROR_ACCESS_DENIED == dwResult)
            {
                //
                // File doesn't exist or we don't have access.
                // We can't get the SFN so simply return the path 
                // with env vars expanded.
                //
                if (cchExpanded < cchPathOut)
                {
                    lstrcpy(pszPathOut, pszTemp);
                    dwResult = ERROR_SUCCESS;
                }
                else
                {
                    //
                    // Output buffer is too small to hold expanded string.
                    //
                    dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
                }
            }
        }
        else if (cchShort > cchPathOut)
        {
            //
            // Output buffer is too small to hold expanded SFN string.
            // 
            dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    return TW32(dwResult);
}


//
// Remove leading and trailing spaces from a text string.
// Modifies the string in-place.
//
void
CControlPanelFolder::_TrimSpaces(
    LPTSTR psz
    )
{
    ASSERT(NULL != psz);
    ASSERT(!IsBadWritePtr(psz, sizeof(*psz) * (lstrlen(psz) + 1)));
    
    LPTSTR pszRead  = psz;
    LPTSTR pszWrite = psz;
    //
    // Skip leading spaces.
    //
    while(0 != *pszRead && TEXT(' ') == *pszRead)
    {
        ++pszRead;
    }

    //
    // Copy remainder up to the terminating nul.
    //
    LPTSTR pszLastNonSpaceChar = NULL;
    while(0 != *pszRead)
    {
        if (TEXT(' ') != *pszRead)
        {
            pszLastNonSpaceChar = pszWrite;
        }
        *pszWrite++ = *pszRead++;
    }
    if (NULL != pszLastNonSpaceChar)
    {
        //
        // The string contained at least one non-space character.
        // Adjust the 'write' ptr so that we terminate the string
        // immediately after the last one found.
        // This trims trailing spaces.
        //
        ASSERT(TEXT(' ') != *pszLastNonSpaceChar && 0 != *pszLastNonSpaceChar);
        pszWrite = pszLastNonSpaceChar + 1;
    }
    *pszWrite = 0;
}


//
// Method returns a string corresponding to what the registry value name should be 
// for this CPL pidl (pidc). This string format is basically the same as the GetExecName
// format with the quotation marks stripped, so all we do is skip the first
// two " marks in the GetExecName string
//
// String in GetExecName format:  "C:\WINNT\System32\main.cpl",keyboard
// String in registry format   :  C:\WINNT\System32\main.cpl,keyboard
//
// 
void CControlPanelFolder::_GetFullCPLName(LPIDCONTROL pidc, LPTSTR achFullCPLName, UINT cchSize)
{    
    const TCHAR QUOTE = TEXT('\"');

    GetExecName(pidc, achFullCPLName,cchSize);

    // first char must be a quote
    ASSERTMSG ((QUOTE == *achFullCPLName), "CControlPanelFolder::_GetFullCPLName() GetExecName returned an invalid value");

    if (QUOTE == *achFullCPLName) // I know we asserted, just being super paranoid
    {
        LPTSTR pszWrite = achFullCPLName;
        LPCTSTR pszRead = achFullCPLName;
        int cQuotes     = 2;  // we want to skip the first two quotes only
        
        while(*pszRead)
        {
            if (0 < cQuotes && QUOTE == *pszRead)
            {
                --cQuotes;
                ++pszRead;
            }
            else
            {
                *pszWrite++ = *pszRead++;
            }
        }
        *pszWrite = TEXT('\0');
    }        
}


STDMETHODIMP CControlPanelFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl == NULL)
    {
        hr = GetDetailsOfInfo(c_cpl_cols, ARRAYSIZE(c_cpl_cols), iColumn, pDetails);
    }
    else
    {
        LPIDCONTROL pidc = _IsValid(pidl);
        if (pidc)
        {
            TCHAR szTemp[max(max(MAX_PATH, MAX_CCH_CPLNAME), MAX_CCH_CPLINFO)];

            pDetails->str.uType = STRRET_CSTR;
            pDetails->str.cStr[0] = 0;

            switch (iColumn)
            {
            case CPL_ICOL_NAME:
                GetDisplayName(pidc, szTemp, ARRAYSIZE(szTemp));
                break;

            case CPL_ICOL_COMMENT:
                _GetDescription(pidc, szTemp, ARRAYSIZE(szTemp));
                break;
                               
            default:
                szTemp[0] = 0;
                break;
            }
            hr = StringToStrRet(szTemp, &pDetails->str);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_cpl_cols, ARRAYSIZE(c_cpl_cols), iColumn, pscid);
}

STDMETHODIMP CControlPanelFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_ControlPanel;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (NULL != _pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CControlPanelFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

//
// list of item context menu callback
//

HRESULT CALLBACK CControlPanelFolder::DFMCallBack(IShellFolder *psf, HWND hwndView,
                                                  IDataObject *pdtobj, UINT uMsg,
                                                  WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;

    if (pdtobj)
    {
        STGMEDIUM medium;

        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            hr = S_OK;

            switch(uMsg)
            {
            case DFM_MERGECONTEXTMENU:
            {
                LPQCMINFO pqcm = (LPQCMINFO)lParam;
                int idCmdFirst = pqcm->idCmdFirst;

                if (wParam & CMF_EXTENDEDVERBS)
                {
                    // If the user is holding down shift, on NT5 we load the menu with both "Open" and "Run as..."
                    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_GENERIC_CONTROLPANEL_VERBS, 0, pqcm);
                }
                else
                {
                    // Just load the "Open" menu
                    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_GENERIC_OPEN_VERBS, 0, pqcm);
                }

                SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);

                //
                //  Returning S_FALSE indicates no need to get verbs from
                // extensions.
                //

                hr = S_FALSE;

                break;
            } // case DFM_MERGECONTEXTMENU

            case DFM_GETHELPTEXT:
                LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
                break;

            case DFM_GETHELPTEXTW:
                LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
                break;

            case DFM_INVOKECOMMAND:
                {
                    for (int i = pida->cidl - 1; i >= 0; i--)
                    {
                        LPIDCONTROL pidc = _IsValid(IDA_GetIDListPtr(pida, i));

                        if (pidc)
                        {
                            switch(wParam)
                            {
                            case FSIDM_OPENPRN:
                            case FSIDM_RUNAS:
                            {
                                TCHAR achParam[MAX_CPL_EXEC_NAME]; // See wnsprintf in GetExecName
                                GetExecName(pidc, achParam, ARRAYSIZE(achParam));

                                SHRunControlPanelEx(achParam, hwndView, (wParam == FSIDM_RUNAS));
                                hr = S_OK;
                                break;
                            }

                            default:
                                hr = S_FALSE;
                            } // switch(wParam)
                        }
                        else
                            hr = E_FAIL;
                    }
                }
                break;

            case DFM_MAPCOMMANDNAME:
                if (lstrcmpi((LPCTSTR)lParam, c_szOpen) == 0)
                {
                    *(UINT_PTR *)wParam = FSIDM_OPENPRN;
                }
                else
                {
                    // command not found
                    hr = E_FAIL;
                }
                break;

            default:
                hr = E_NOTIMPL;
                break;
            } // switch (uMsg)

            HIDA_ReleaseStgMedium(pida, &medium);

        } // if (pida)

    } // if (pdtobj)
    return hr;
}

int MakeCPLCommandLine(LPCTSTR pszModule, LPCTSTR pszName, LPTSTR pszCommandLine, DWORD cchCommandLine)
{
    RIP(pszCommandLine);
    RIP(pszModule);
    RIP(pszName);
    
    return wnsprintf(pszCommandLine, cchCommandLine, TEXT("\"%s\",%s"), pszModule, pszName);
}

void CControlPanelFolder::GetExecName(LPIDCONTROL pidc, LPTSTR pszParseName, UINT cchParseName)
{
    TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME];
    
    GetModuleMapped(pidc, szModule, ARRAYSIZE(szModule), NULL, szName, ARRAYSIZE(szName));

    // If our GetModuleMapped call didn't override the applet name, get it the old fashioned way
    if (*szName == 0)
        GetDisplayName(pidc, szName, ARRAYSIZE(szName));

    MakeCPLCommandLine(szModule, szName, pszParseName, cchParseName);
}

typedef struct _OLDCPLMAPPING
{
    LPCTSTR szOldModule;
    UINT    idOldIcon;
    LPCTSTR szNewModule;
    UINT    idNewIcon;
    LPCTSTR szApplet;
    // Put TEXT("") in szApplet to use the applet name stored in the cpl shortcut
} OLDCPLMAPPING, *LPOLDCPLMAPPING;

const OLDCPLMAPPING g_rgOldCPLMapping[] = 
{
    // Win95 shortcuts that don't work correctly
    // -----------------------------------------

    // Add New Hardware
    {TEXT("SYSDM.CPL"), 0xfffffda6, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},       
    // ODBC 32 bit
    {TEXT("ODBCCP32.CPL"), 0xfffffa61, TEXT("ODBCCP32.CPL"), 0xfffffa61, TEXT("@0")},
    // Mail
    {TEXT("MLCFG32.CPL"), 0xffffff7f, TEXT("MLCFG32.CPL"), 0xffffff7f, TEXT("@0")},
    // Modem
    {TEXT("MODEM.CPL"), 0xfffffc18, TEXT("TELEPHON.CPL"), (UINT) -100, TEXT("")},
    // Multimedia
    {TEXT("MMSYS.CPL"), 0xffffff9d, TEXT("MMSYS.CPL"), (UINT) -110, TEXT("")},
    // Network
    {TEXT("NETCPL.CPL"), 0xffffff9c, TEXT("NCPA.CPL"), 0xfffffc17, TEXT("@0")},
    // Password
    {TEXT("PASSWORD.CPL"), 0xfffffc18, TEXT("PASSWORD.CPL"), 0xfffffc18, TEXT("@0")},
    // Regional Settings
    {TEXT("INTL.CPL"), 0xffffff9b, TEXT("INTL.CPL"), (UINT) -200, TEXT("@0")},
    // System
    {TEXT("SYSDM.CPL"), 0xfffffda8, TEXT("SYSDM.CPL"), (UINT) -6, TEXT("")},
    // Users
    {TEXT("INETCPL.CPL"), 0xfffffad5, TEXT("INETCPL.CPL"), 0xfffffad5, TEXT("@0")},

    // NT4 Shortcuts that don't work
    // -----------------------------

    // Multimedia
    {TEXT("MMSYS.CPL"), 0xfffff444, TEXT("MMSYS.CPL"), 0xfffff444, TEXT("@0")},
    // Network
    {TEXT("NCPA.CPL"), 0xfffffc17, TEXT("NCPA.CPL"), 0xfffffc17, TEXT("@0")},
    // UPS
    {TEXT("UPS.CPL"), 0xffffff9c, TEXT("POWERCFG.CPL"), (UINT) -202, TEXT("@0")},

    // Synonyms for hardware management
    // Devices
    {TEXT("SRVMGR.CPL"), 0xffffff67, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // Ports
    {TEXT("PORTS.CPL"), 0xfffffffe,  TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // SCSI Adapters
    {TEXT("DEVAPPS.CPL"), 0xffffff52, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // Tape Devices
    {TEXT("DEVAPPS.CPL"), 0xffffff97, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
};

HRESULT CControlPanelFolder::GetModuleMapped(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule,
                                             UINT* pidNewIcon, LPTSTR pszApplet, UINT cchApplet)
{
    HRESULT hr = S_FALSE;

    GetModule(pidc, pszModule, cchModule);

    // Compare just the .cpl file name, not the full path: Get this file name from the full path
    LPTSTR pszFilename = PathFindFileName(pszModule);

    // Calculate the size of the buffer available for the filename
    UINT cchFilenameBuffer = cchModule - (UINT)(pszFilename - pszModule);

    if (((int) pidc->idIcon <= 0) && (pszFilename))
    {
        for (int i = 0; i < ARRAYSIZE(g_rgOldCPLMapping); i++)
        {
            // See if the module names and old icon IDs match those in this
            // entry of our mapping
            if (((UINT) pidc->idIcon == g_rgOldCPLMapping[i].idOldIcon) &&
                (lstrcmpi(pszFilename, g_rgOldCPLMapping[i].szOldModule) == 0))
            {
                hr = S_OK;
                
                // Set the return values to those of the found item
                if (pidNewIcon != NULL)
                    *pidNewIcon = g_rgOldCPLMapping[i].idNewIcon;

                lstrcpyn(pszFilename, g_rgOldCPLMapping[i].szNewModule, cchFilenameBuffer);
                
                if (pszApplet != NULL)
                    lstrcpyn(pszApplet, g_rgOldCPLMapping[i].szApplet, cchApplet);


                break;
            }
        }
    }

    // Return old values if we didn't require a translation
    if (hr == S_FALSE)
    {
        if (pidNewIcon != NULL)
            *pidNewIcon = pidc->idIcon;

        if (pszApplet != NULL)
            *pszApplet = 0; //NULL String
    }

    //  If the .cpl file can't be found, this may be a Win95 shortcut specifying
    //  the old system directory - possibly an upgraded system.  We try to make
    //  this work by changing the directory specified to the actual system
    //  directory.  For example c:\windows\system\foo.cpl will become
    //  c:\winnt\system32\foo.cpl.
    //
    //  Note:   The path substitution is done unconditionally because if we
    //          can't find the file it doesn't matter where we can't find it...

    if (!PathFileExists(pszModule))
    {
        TCHAR szNew[MAX_PATH], szSystem[MAX_PATH];

        GetSystemDirectory(szSystem, ARRAYSIZE(szSystem));
        PathCombine(szNew, szSystem, pszFilename);
    
        lstrcpyn(pszModule, szNew, cchModule);
    }

    return hr;
}

//
//  SHualUnicodeToTChar is like SHUnicodeToTChar except that it accepts
//  an unaligned input string parameter.
//
#ifdef UNICODE
#define SHualUnicodeToTChar(src, dst, cch) ualstrcpyn(dst, src, cch)
#else   // No ANSI platforms require alignment
#define SHualUnicodeToTChar                SHUnicodeToTChar
#endif

void CControlPanelFolder::GetDisplayName(LPIDCONTROL pidc, LPTSTR pszName, UINT cchName)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
        SHualUnicodeToTChar(pidcW->cBufW + pidcW->oNameW, pszName, cchName);
    else
        SHAnsiToTChar(pidc->cBuf + pidc->oName, pszName, cchName);
}

void CControlPanelFolder::GetModule(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
    {
        if (!SHualUnicodeToTChar(pidcW->cBufW, pszModule, cchModule))
        {
            *pszModule = TEXT('\0');
        }
    }
    else
    {
        if (!SHAnsiToTChar(pidc->cBuf, pszModule, cchModule))
        {
            *pszModule = TEXT('\0');
        }
    }
}

void CControlPanelFolder::_GetDescription(LPIDCONTROL pidc, LPTSTR pszDesc, UINT cchDesc)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
        SHualUnicodeToTChar(pidcW->cBufW + pidcW->oInfoW, pszDesc, cchDesc);
    else
        SHAnsiToTChar(pidc->cBuf + pidc->oInfo, pszDesc, cchDesc);
}

//
// Method opens a subkey corresponding to a SCID under ExtendedPoperties for control panel 
//
BOOL CControlPanelFolder::_GetExtPropsKey(HKEY hkeyParent, HKEY * pHkey, const SHCOLUMNID * pscid)
{
    const TCHAR c_szRegPath[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Extended Properties\\");
    const UINT cchRegPath = ARRAYSIZE (c_szRegPath);

    TCHAR achPath[cchRegPath + SCIDSTR_MAX];
    lstrcpy(achPath, c_szRegPath);

    ASSERT (hkeyParent);
    
    if (0 < StringFromSCID(pscid, achPath + cchRegPath - 1, ARRAYSIZE(achPath) - cchRegPath))
    {
        return (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, 
                                            achPath,
                                            0,
                                            KEY_QUERY_VALUE,
                                            pHkey));
    }
    return FALSE;    
}   

#undef SHualUnicodeToTChar

CControlPanelEnum::CControlPanelEnum(UINT uFlags) :
    _cRef                       (1),
    _uFlags                     (uFlags),
    _iModuleCur                 (0),
    _cControlsOfCurrentModule   (0),
    _iControlCur                (0),
    _cControlsTotal             (0),
    _iRegControls               (0)
{
    ZeroMemory(&_minstCur, sizeof(_minstCur));
    ZeroMemory(&_cplData, sizeof(_cplData));
}

CControlPanelEnum::~CControlPanelEnum()
{
    CPLD_Destroy(&_cplData);
}

HRESULT CControlPanelEnum::Init()
{
    HRESULT hr;
    if (CPLD_GetModules(&_cplData))
    {
        CPLD_GetRegModules(&_cplData);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CControlPanelEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENT(CControlPanelEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CControlPanelEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CControlPanelEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// for other ways to hide CPLs see control1.c, DontLoadCPL()
BOOL CControlPanelEnum::_DoesPolicyAllow(LPCTSTR pszName, LPCTSTR pszFileName)
{
    BOOL bAllow = TRUE;
    if (SHRestricted(REST_RESTRICTCPL) && 
        !IsNameListedUnderKey(pszName, REGSTR_POLICIES_RESTRICTCPL) &&
        !IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_RESTRICTCPL))
    {
        bAllow = FALSE;
    }
    if (bAllow)
    {
        if (SHRestricted(REST_DISALLOWCPL) && 
            (IsNameListedUnderKey(pszName, REGSTR_POLICIES_DISALLOWCPL) ||
             IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_DISALLOWCPL)))
        {
            bAllow = FALSE;
        }
    }
    return bAllow;
}

STDMETHODIMP CControlPanelEnum::Next(ULONG celt, LPITEMIDLIST* ppidlOut, ULONG* pceltFetched)
{
    ZeroMemory(ppidlOut, sizeof(ppidlOut[0])*celt);
    if (pceltFetched)
        *pceltFetched = 0;

    if (!(_uFlags & SHCONTF_NONFOLDERS))
        return S_FALSE;

    // Loop through lpData->pRegCPLs and use what cached information we can.

    while (_iRegControls < _cplData.cRegCPLs)
    {
        REG_CPL_INFO *pRegCPL = (REG_CPL_INFO *) DPA_GetPtr(_cplData.hRegCPLs, _iRegControls);
        PMODULEINFO pmi;
        TCHAR szFilePath[MAX_PATH];

        lstrcpyn(szFilePath, REGCPL_FILENAME(pRegCPL), ARRAYSIZE(szFilePath));
        LPTSTR pszFileName = PathFindFileName(szFilePath);

        // find this module in the hamiModule list

        for (int i = 0; i < _cplData.cModules; i++)
        {
            pmi = (PMODULEINFO) DSA_GetItemPtr(_cplData.hamiModule, i);

            if (!lstrcmpi(pszFileName, pmi->pszModuleName))
                break;
        }

        if (i < _cplData.cModules)
        {
            LPCTSTR pszDisplayName = REGCPL_CPLNAME(pRegCPL);
            // If this cpl is not supposed to be displayed let's bail
            if (!_DoesPolicyAllow(pszDisplayName, pszFileName))
            {
                _iRegControls++;
                // we have to set this bit, so that the cpl doesn't get reregistered
                pmi->flags |= MI_REG_ENUM;
                continue;
            }

            // Get the module's creation time & size
            if (!(pmi->flags & MI_FIND_FILE))
            {
                WIN32_FIND_DATA findData;
                HANDLE hFindFile = FindFirstFile(pmi->pszModule, &findData);
                if (hFindFile != INVALID_HANDLE_VALUE)
                {
                    pmi->flags |= MI_FIND_FILE;
                    pmi->ftCreationTime = findData.ftCreationTime;
                    pmi->nFileSizeHigh = findData.nFileSizeHigh;
                    pmi->nFileSizeLow = findData.nFileSizeLow;
                    FindClose(hFindFile);
                }
                else
                {
                    // this module no longer exists...  Blow it away.
                    DebugMsg(DM_TRACE,TEXT("sh CPLS: very stange, couldn't get timestamps for %s"), REGCPL_FILENAME(pRegCPL));
                    goto RemoveRegCPL;
                }
            }

            if (0 != CompareFileTime(&pmi->ftCreationTime, &pRegCPL->ftCreationTime) || 
                pmi->nFileSizeHigh != pRegCPL->nFileSizeHigh || 
                pmi->nFileSizeLow != pRegCPL->nFileSizeLow)
            {
                // this doesn't match -- remove it from pRegCPLs; it will
                // get enumerated below.
                DebugMsg(DM_TRACE,TEXT("sh CPLS: timestamps don't match for %s"), REGCPL_FILENAME(pRegCPL));
                goto RemoveRegCPL;
            }

            // we have a match: mark this module so we skip it below
            // and enumerate this cpl now
            pmi->flags |= MI_REG_ENUM;

            IDControlCreate(pmi->pszModule, EIRESID(pRegCPL->idIcon), REGCPL_CPLNAME(pRegCPL), REGCPL_CPLINFO(pRegCPL), ppidlOut);

            _iRegControls++;
            goto return_item;
        }
        else
        {
            DebugMsg(DM_TRACE,TEXT("sh CPLS: %s not in module list!"), REGCPL_FILENAME(pRegCPL));
        }

RemoveRegCPL:
        // Nuke this cpl entry from the registry

        if (!(pRegCPL->flags & REGCPL_FROMREG))
            LocalFree(pRegCPL);

        DPA_DeletePtr(_cplData.hRegCPLs, _iRegControls);

        _cplData.cRegCPLs--;
        _cplData.fRegCPLChanged = TRUE;
    }

    // Have we enumerated all the cpls in this module?
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    do
    {
        while (_iControlCur >= _cControlsOfCurrentModule || // no more
               _cControlsOfCurrentModule < 0) // error getting modules
        {

            // Have we enumerated all the modules?
            if (_iModuleCur >= _cplData.cModules)
            {
                CPLD_FlushRegModules(&_cplData); // flush changes for next guy
                return S_FALSE;
            }

            // Was this module enumerated from the registry?
            PMODULEINFO pmi = (PMODULEINFO) DSA_GetItemPtr(_cplData.hamiModule, _iModuleCur);
            if (!(pmi->flags & MI_REG_ENUM))
            {
                // No. Load and init the module, set up counters.

                pmi->flags |= MI_CPL_LOADED;
                _cControlsOfCurrentModule = CPLD_InitModule(&_cplData, _iModuleCur, &_minstCur);
                _iControlCur = 0;
            }

            ++_iModuleCur;  // Point to next module
        }

        // We're enumerating the next control in this module
        // Add the control to the registry

        EVAL(CPLD_AddControlToReg(&_cplData, &_minstCur, _iControlCur));
        // This shouldn't fail at all; that would mean that DSA_GetItemPtr() failed, 
        // and we've already called that successfully.

        // Get the control's pidl name

        pcplm = FindCPLModule(&_minstCur);
        pcpli = (LPCPLITEM) DSA_GetItemPtr(pcplm->hacpli, _iControlCur);

        ++_iControlCur;
    } while (!_DoesPolicyAllow(pcpli->pszName, PathFindFileName(pcplm->szModule)));

    IDControlCreate(pcplm->szModule, EIRESID(pcpli->idIcon), pcpli->pszName, pcpli->pszInfo, ppidlOut);
    
return_item:
    HRESULT hr = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        ++_cControlsTotal;

        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

STDMETHODIMP CControlPanelEnum::Reset()
{
    _iModuleCur  = 0;
    _cControlsOfCurrentModule = 0;
    _iControlCur = 0;
    _cControlsTotal = 0;
    _iRegControls = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cstrings.h ===
// all of the stuf here should go away, use inline strings, the compiler merges them
#include <regstr.h>

extern const TCHAR c_szShell32Dll[];
extern const TCHAR c_szBaseClass[];
extern const TCHAR c_szBriefcase[];
extern const TCHAR c_szStubWindowClass[];
extern const TCHAR c_szConnect[];
extern const TCHAR c_szConv[];
extern const TCHAR c_szDesktopIni[];
extern const TCHAR c_szDotDir[];
extern const TCHAR c_szDotDot[];
extern const TCHAR c_szDotExe[];
extern const TCHAR c_szEllipses[];
extern const TCHAR c_szExplore[];
extern const TCHAR c_szFILEOKSTRING[];
extern const TCHAR c_szFileCabinet[];
extern const TCHAR c_szFolderClass[];
extern const TCHAR c_szHeaderClass[];
extern const TCHAR c_szListViewClass[];
extern const TCHAR c_szMenuHandler[];
extern const TCHAR c_szNetRoot[];
extern const TCHAR c_szNetworkClass[];
extern const TCHAR c_szOpen[];
extern const TCHAR c_szOpenAs[];
extern const TCHAR c_szEdit[];
extern const TCHAR c_szOptions[];
extern const TCHAR c_szPATH[];
extern const TCHAR c_szPrint[];
extern const TCHAR c_szPrintTo[];
extern const TCHAR c_szQuote[];
extern const TCHAR c_szRunConnect[];
extern const TCHAR c_szRunDll[];
extern const TCHAR c_szRunDll16[];
extern const TCHAR c_szRecentDocs[];
extern const TCHAR c_szShellUIHandler[];
extern const TCHAR c_szSlashCommand[];
extern const TCHAR c_szSlashDDEExec[];
extern const TCHAR c_szSpace[];
extern const TCHAR c_szStar[];
extern const TCHAR c_szStarDotStar[];
extern const TCHAR c_szTrayClass[];
extern const TCHAR c_szViewState[];
extern const TCHAR c_szNULL[];
#define szNULL c_szNULL
extern const  CHAR c_szNULLA[];
extern const TCHAR c_szDefaultIcon[];
extern const TCHAR c_szShell[];
extern const TCHAR c_szDesktop[];
extern const TCHAR c_szShellOpenCmd[];

extern const TCHAR c_szShellNew[];
extern const TCHAR c_szData[];
extern const TCHAR c_szFile[];

#define CCHELLIPSES 3

extern const TCHAR c_szSetDefault[];
extern const TCHAR c_szNewObject[];
extern const TCHAR c_szPause[];
extern const TCHAR c_szResume[];
extern const TCHAR c_szPurge[];
extern const TCHAR c_szListView[];
extern const TCHAR c_szPositions[];
extern const TCHAR c_szPrinterIni[];
extern const TCHAR c_szFileColon[];
extern const TCHAR c_szPrinters[];

extern const TCHAR c_szCut[];
extern const TCHAR c_szCopy[];
extern const TCHAR c_szLink[];
extern const TCHAR c_szProperties[];
extern const TCHAR c_szPaste[];
extern const TCHAR c_szPasteLink[];
extern const TCHAR c_szRename[];

extern const TCHAR c_szFind[];
extern const TCHAR c_szNoRun[];
extern const TCHAR c_szNoClose[];
extern const TCHAR c_szNoSaveSettings[];
extern const TCHAR c_szNoFileMenu[];
extern const TCHAR c_szNoSetFolders[];
extern const TCHAR c_szNoSetTaskbar[];
extern const TCHAR c_szNoDesktop[];
extern const TCHAR c_szNoFind[];
extern const TCHAR c_szNoDrives[];
extern const TCHAR c_szNoDriveAutoRun[];
extern const TCHAR c_szNoDriveTypeAutoRun[];
extern const TCHAR c_szNoNetHood[];
extern const TCHAR c_szFontExtDll[];

extern const TCHAR c_szCommand[];

#define SHELL_HLP "shell.hlp" // What help file the shell uses.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dataprv.h ===
#ifndef _DATAPRV_H_
#define _DATAPRV_H_
#include "simpdata.h"

// This is the data source object that works from any  IShellFolder.

class CSimpleData : public OLEDBSimpleProvider
{
public:
    CSimpleData(OLEDBSimpleProviderListener **pplisener) : _ppListener(pplisener) { }
    ~CSimpleData();
    
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID, LPVOID FAR*) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // OLEDBSimpleProvider
    STDMETHOD(getRowCount)(DBROWCOUNT *pcRows);
    STDMETHOD(getColumnCount)(DB_LORDINAL *pcColumns);
    STDMETHOD(getRWStatus)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus);
    STDMETHOD(getVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT fmt, VARIANT *pVar);
    STDMETHOD(setVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT fmt, VARIANT Var);
    STDMETHOD(getLocale)(BSTR *pbstrLocale);
    STDMETHOD(deleteRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    STDMETHOD(insertRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    STDMETHOD(find)(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(getEstimatedRows)(DBROWCOUNT *pcRows);
    STDMETHOD(isAsync)(BOOL *pbAsync);
    STDMETHOD(stopTransfer)();

public:
    HRESULT SetShellFolder(IShellFolder *psf);

private:
    HRESULT _DoEnum();

    OLEDBSimpleProviderListener  **_ppListener;
    IShellFolder                 *_psf;
    HDPA                        _hdpa;
};


#endif _DATAPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dbcs.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

    This module contains the code for console DBCS font dialog

Author:

    kazum Feb-27-1995

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

#ifdef DBCS

// This definition shares in windows\inc\wincon.w file
//
#define MACHINE_REGISTRY_CONSOLE_TTFONT (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont")

#define MACHINE_REGISTRY_CONSOLE_NLS    (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\Nls")


NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      KeyValueInformation->NameLength);
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type == REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}





WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val * 10) + (ch - L'0');
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val << 4) + (ch - L'0');
        else if (L'A' <= ch && ch <= L'F')
            val = (val << 4) + (ch - L'A' + 10);
        else if (L'a' <= ch && ch <= L'f')
            val = (val << 4) + (ch - L'a' + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}


NTSTATUS
MakeAltRasterFont(
    CONSOLEPROP_DATA * pcpd,
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = pcpd->FontInfo[pcpd->DefaultFontIndex].Size;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < pcpd->NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - pcpd->FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - pcpd->FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    lstrcpy(AltFaceName, pcpd->FontInfo[*AltFontIndex].FaceName);
    *AltFontSize = pcpd->FontInfo[*AltFontIndex].Size;
    *AltFontFamily = pcpd->FontInfo[*AltFontIndex].Family;

    return STATUS_SUCCESS;
}

NTSTATUS
InitializeDbcsMisc(
    CONSOLEPROP_DATA * pcpd
    )
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    LPWSTR pwsz;

    pcpd->gTTFontList.Next = NULL;

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (NT_SUCCESS( Status )) {
        TTFONTLIST *pTTFontList;

        for( dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status )) {
                break;
            }

            pTTFontList = LocalAlloc(LPTR, sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            else
                pTTFontList->fDisableBold = FALSE;
#ifdef UNICODE
            lstrcpyW(pTTFontList->FaceName1, pwsz);

            pwsz += lstrlenW(pwsz) + 1;
            if (*pwsz == BOLD_MARK)
            {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            lstrcpyW(pTTFontList->FaceName2, pwsz);
#else
            // if we're the ANSI shell, we need to convert FACENAME
            // over to ASCII before saving...
            {
                CHAR szFaceName[LF_FACESIZE];
                SHUnicodeToAnsi(pwsz, szFaceName, ARRAYSIZE(szFaceName));
                lstrcpyA(pTTFontList->FaceName1, szFaceName);

                pwsz += lstrlenW(pwsz) + 1;
                if (*pwsz == BOLD_MARK)
                {
                    pTTFontList->fDisableBold = TRUE;
                    pwsz++;
                }
                SHUnicodeToAnsi(pwsz, szFaceName, ARRAYSIZE(szFaceName));
                lstrcpyA(pTTFontList->FaceName2, szFaceName);
            }
#endif

            PushEntryList(&pcpd->gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    pcpd->fChangeCodePage = FALSE;
    pcpd->uOEMCP = GetOEMCP();

    return STATUS_SUCCESS;
}

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo((DWORD *)UIntToPtr( CodePage ), &csi, TCI_SRCCODEPAGE)) // Sundown: valid zero-extension of CodePage for TCI_SRCCOPAGE.
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}

TTFONTLIST *SearchTTFont(CONSOLEPROP_DATA * pcpd, LPTSTR ptszFace, BOOL fCodePage, UINT CodePage)
{
    PSINGLE_LIST_ENTRY pTemp = pcpd->gTTFontList.Next;

    if (ptszFace) {
        while (pTemp != NULL) {
            TTFONTLIST *pTTFontList = (TTFONTLIST *)pTemp;

            if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(ptszFace, pTTFontList->FaceName2) == 0    ) {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage )
                        return pTTFontList;
                    else
                        return NULL;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    if (SearchTTFont(pcpd, ptszFace, FALSE, 0))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsAvailableTTFontCP(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(pcpd, ptszFace, TRUE, CodePage))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsDisableBoldTTFont(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    TTFONTLIST *pTTFontList;

    pTTFontList = SearchTTFont(pcpd, ptszFace, FALSE, 0);
    if (pTTFontList != NULL)
        return pTTFontList->fDisableBold;
    else
        return FALSE;
}

LPTSTR
GetAltFaceName(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    TTFONTLIST *pTTFontList;

    pTTFontList = SearchTTFont(pcpd, ptszFace, FALSE, 0);
    if (pTTFontList) {
        if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }
        if (wcscmp(ptszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    }
    else
        return NULL;
}

NTSTATUS DestroyDbcsMisc(CONSOLEPROP_DATA * pcpd)
{
    while (pcpd->gTTFontList.Next != NULL) 
    {
        TTFONTLIST *pTTFontList = (TTFONTLIST *)PopEntryList(&pcpd->gTTFontList);

        if (pTTFontList != NULL)
            LocalFree(pTTFontList);
    }

    return STATUS_SUCCESS;
}

typedef struct _LC_List {
    struct _LC_List* Next;
    BOOL   FindFlag;
    WCHAR  LC_String[9];
} LC_List, *PLC_List;

static PLC_List LocaleList;

BOOL CALLBACK
EnumProc(
    LPWSTR LC_String
    )
{
    PLC_List TmpList;

    if (lstrlenW(LC_String) <= (sizeof(LocaleList->LC_String)/sizeof(WCHAR))-1)
    {
        TmpList = (PLC_List)&LocaleList;

        while(TmpList->Next != NULL)
            TmpList = TmpList->Next;

        TmpList->Next = LocalAlloc(LPTR, sizeof(LC_List));
        if (TmpList->Next != NULL)
        {
            TmpList = TmpList->Next;
            lstrcpyW(TmpList->LC_String, LC_String);
        }
    }
    return TRUE;
}


int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Initializes the Language list by enumerating all Locale Information.

    Returns
--*/

{
    HWND hWndLanguageCombo;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;

    ENTERCRITICAL;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocalesW( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (NT_SUCCESS( Status )) {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (lstrcmpW(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Create ComboBox items
     */
    hWndLanguageCombo = GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST);
    SendMessage(hWndLanguageCombo, CB_RESETCONTENT, 0, 0L);

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            awchValue[0] = L'\0';
            cp = 0;

            {
                #define KERNEL32    _T("KERNEL32.DLL")

                #ifdef UNICODE
                #define GETCPINFOEX "GetCPInfoExW"
                #else
                #define GETCPINFOEX "GetCPInfoExA"
                #endif

                typedef BOOL (CALLBACK *LPFNGETCPINFOEX)(UINT, DWORD, LPCPINFOEX);
                LPFNGETCPINFOEX lpfnGetCPInfoEx;

                BOOL fRet = FALSE;
                CPINFOEX cpinfo;

                HMODULE hMod;

                cchData = GetLocaleInfoW(Locale, LOCALE_IDEFAULTCODEPAGE,
                                         awchData, sizeof(awchData)/sizeof(TCHAR));
                if (cchData)
                {
                    cp = ConvertStringToDec(awchData, NULL);

                    hMod = GetModuleHandle(KERNEL32);
                    if (hMod) {
                        lpfnGetCPInfoEx = (LPFNGETCPINFOEX)GetProcAddress(hMod,GETCPINFOEX);
                        if (lpfnGetCPInfoEx)
                            fRet = (*lpfnGetCPInfoEx)(cp, 0, &cpinfo);
                    }
                    if (fRet) {
                        lListIndex = (LONG) SendMessageW(hWndLanguageCombo, CB_ADDSTRING, 0, (LPARAM)cpinfo.CodePageName);
                        SendMessage(hWndLanguageCombo, CB_SETITEMDATA, (DWORD)lListIndex, cp);

                        if (CodePage == cp) {
                            SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
                        }
                    }
                }
            }

            if (CodePage == cp) {
                SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
            }

        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }

    LEAVECRITICAL;

    /*
     * Get the LocaleIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG) SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
    return (int) SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
}
#endif // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\datautil.cpp ===
#include "shellprv.h"
#include "datautil.h"

#include "idlcomm.h"

STDAPI DataObj_SetDropTarget(IDataObject *pdtobj, const CLSID *pclsid)
{
    return DataObj_SetBlob(pdtobj, g_cfTargetCLSID, pclsid, sizeof(*pclsid));
}

STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid)
{
    return DataObj_GetBlob(pdtobj, g_cfTargetCLSID, pclsid, sizeof(*pclsid));
}

STDAPI_(UINT) DataObj_GetHIDACount(IDataObject *pdtobj)
{
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        UINT count = pida->cidl;

        ASSERT(pida->cidl == HIDA_GetCount(medium.hGlobal));

        HIDA_ReleaseStgMedium(pida, &medium);
        return count;
    }
    return 0;
}

// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hr = S_OK;
    ULARGE_INTEGER uliNewCompleted;
    DWORD dwLastTickCount = 0;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            DWORD dwTickCount = GetTickCount();
            
            if ((dwTickCount - dwLastTickCount) > 1000)
            {
                EVAL(SUCCEEDED(ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart)));

                if (ppi->ppd->HasUserCancelled())
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
    
                dwLastTickCount = dwTickCount;
            }
        }

        hr = pstmFrom->Read(buf, min(cb.LowPart, sizeof(buf)), &cbRead);
        if (FAILED(hr) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hr))
                hr = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hr = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hr) || (cbRead == 0))
            break;
    }

    return hr;
}

//
//  APP COMPAT!  Prior versions of the shell used IStream::CopyTo to copy
//  the stream.  New versions of the shell use IStream::Read to copy the
//  stream so we can put up progress UI.  WebFerret 3.0000 implements both
//  IStream::Read and IStream::CopyTo, but their implementation of
//  IStream::Read hangs the system.  So we need to sniff at the data object
//  and stream to see if it is WebFerret.
//
//  WebFerret doesn't implement IPersist (so IPersist::GetClassID won't
//  help) and they don't fill in the CLSID in the FILEDESCRIPTOR
//  and it's an out-of-proc data object, so we have to go completely
//  on circumstantial evidence.
//

STDAPI_(BOOL) IUnknown_SupportsInterface(IUnknown *punk, REFIID riid)
{
    IUnknown *punkOut;
    if (SUCCEEDED(punk->QueryInterface(riid, (void **)&punkOut))) 
    {
        punkOut->Release();
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) DataObj_ShouldCopyWithProgress(IDataObject *pdtobj, IStream *pstm, PROGRESSINFO * ppi)
{
    //
    //  Optimization:  If there is no progress info, then don't waste your
    //  time with progress UI.
    //
    if (!ppi) return FALSE;

    //
    //  How to detect a WebFerret IDataObject:
    //
    //  The filegroup descriptor gives all objects as size zero.
    //      (Check this first since it is cheap and usually false)
    //  WebFerret app is running (look for their tooltip window).
    //  Their IDataObject doesn't support anything other than IUnknown
    //      (so we use IID_IAsyncOperation to detect shell data objects
    //       and IPersist to allow ISVs to override).
    //  Their IStream doesn't support IStream::Stat.
    //

    STATSTG stat;

    if (ppi->uliBytesTotal.QuadPart == 0 &&
        FindWindow(TEXT("VslToolTipWindow"), NULL) &&
        !IUnknown_SupportsInterface(pdtobj, IID_IAsyncOperation) &&
        !IUnknown_SupportsInterface(pdtobj, IID_IPersist) &&
        pstm->Stat(&stat, STATFLAG_NONAME) == E_NOTIMPL)
    {
        return FALSE;           // WebFerret!
    }

    //  All test passed; go ahead and copy with progress UI

    return TRUE;
}

STDAPI DataObj_SaveToFile(IDataObject *pdtobj, UINT cf, LONG lindex, LPCTSTR pszFile, FILEDESCRIPTOR *pfd, PROGRESSINFO * ppi)
{
    STGMEDIUM medium = {0};
    FORMATETC fmte;
    HRESULT hr;

    fmte.cfFormat = (CLIPFORMAT) cf;
    fmte.ptd = NULL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex = lindex;
    fmte.tymed = TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE;

    hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //
        // if the destination file is system or read-only,
        // clear those bits out so we can write anew.
        //
        DWORD dwTargetFileAttributes = GetFileAttributes(pszFile);
        if (dwTargetFileAttributes != -1)
        {
            if (dwTargetFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
            {
                SetFileAttributes(pszFile, dwTargetFileAttributes & ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
            }
        }

        DWORD dwSrcFileAttributes = 0;
        if (pfd->dwFlags & FD_ATTRIBUTES)
        {
            // store the rest of the attributes if passed...
            dwSrcFileAttributes = (pfd->dwFileAttributes & ~FILE_ATTRIBUTE_DIRECTORY);
        }

        switch (medium.tymed) {
        case TYMED_HGLOBAL:
        {
            HANDLE hfile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE,
                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, dwSrcFileAttributes, NULL);

            if (hfile != INVALID_HANDLE_VALUE)
            {
                DWORD dwWrite;
                // NTRAID89561-2000/02/25-raymondc: what about writes greater than 4 GB?
                if (!WriteFile(hfile, GlobalLock(medium.hGlobal), (pfd->dwFlags & FD_FILESIZE) ? pfd->nFileSizeLow : (DWORD) GlobalSize(medium.hGlobal), &dwWrite, NULL))
                    hr = HRESULT_FROM_WIN32(GetLastError());

                GlobalUnlock(medium.hGlobal);

                if (pfd->dwFlags & (FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME))
                {
                    SetFileTime(hfile,
                                pfd->dwFlags & FD_CREATETIME ? &pfd->ftCreationTime : NULL,
                                pfd->dwFlags & FD_ACCESSTIME ? &pfd->ftLastAccessTime : NULL,
                                pfd->dwFlags & FD_WRITESTIME ? &pfd->ftLastWriteTime : NULL);
                }

                CloseHandle(hfile);

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }

        case TYMED_ISTREAM:
        {
            IStream *pstm;
            hr = SHCreateStreamOnFile(pszFile, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm);
            if (SUCCEEDED(hr))
            {
                //
                // Per the SDK, IDataObject::GetData leaves the stream ptr at 
                // the end of the data in the stream.  To copy the stream we 
                // first must reposition the stream ptr to the begining.  
                // We restore the stream ptr to it's original location when we're done.
                //
                // NOTE:  In case the source stream doesn't support Seek(), 
                //        attempt the copy even if the seek operation fails.
                //
                const LARGE_INTEGER ofsBegin = {0, 0};
                ULARGE_INTEGER ofsOriginal   = {0, 0};
                HRESULT hrSeek = medium.pstm->Seek(ofsBegin, STREAM_SEEK_CUR, &ofsOriginal);
                if (SUCCEEDED(hrSeek))
                {
                    hrSeek = medium.pstm->Seek(ofsBegin, STREAM_SEEK_SET, NULL);
                }
                
                const ULARGE_INTEGER ul = {(UINT)-1, (UINT)-1};    // the whole thing

                if (DataObj_ShouldCopyWithProgress(pdtobj, medium.pstm, ppi))
                {
                    hr = StreamCopyWithProgress(medium.pstm, pstm, ul, ppi);
                }
                else
                {
                    hr = medium.pstm->CopyTo(pstm, ul, NULL, NULL);
                }
                if (SUCCEEDED(hrSeek))
                {
                    //
                    // Restore stream ptr in source to it's original location.
                    //
                    const LARGE_INTEGER ofs = { ofsOriginal.LowPart, (LONG)ofsOriginal.HighPart };
                    medium.pstm->Seek(ofs, STREAM_SEEK_SET, NULL);
                }
                
                pstm->Release();

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));

                DebugMsg(TF_FSTREE, TEXT("IStream::CopyTo() -> %x"), hr);
            }
            break;
        }

        case TYMED_ISTORAGE:
        {
            WCHAR wszNewFile[MAX_PATH];
            IStorage *pstg;

            DebugMsg(TF_FSTREE, TEXT("got IStorage"));

            SHTCharToUnicode(pszFile, wszNewFile, ARRAYSIZE(wszNewFile));
            hr = StgCreateDocfile(wszNewFile,
                            STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                            0, &pstg);

            if (SUCCEEDED(hr))
            {
                hr = medium.pstg->CopyTo(0, NULL, NULL, pstg);

                DebugMsg(TF_FSTREE, TEXT("IStorage::CopyTo() -> %x"), hr);

                pstg->Commit(STGC_OVERWRITE);
                pstg->Release();

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));
            }
        }
            break;

        default:
            AssertMsg(FALSE, TEXT("got tymed that I didn't ask for %d"), medium.tymed);
        }

        if (SUCCEEDED(hr))
        {
            // in the HGLOBAL case we could take some shortcuts, so the attributes and
            // file times were set earlier in the case statement.
            // otherwise, we need to set the file times and attributes now.
            if (medium.tymed != TYMED_HGLOBAL)
            {
                if (pfd->dwFlags & (FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME))
                {
                    // open with GENERIC_WRITE to let us set the file times,
                    // everybody else can open with SHARE_READ.
                    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                    if (hFile != INVALID_HANDLE_VALUE)
                    {
                        SetFileTime(hFile,
                                    pfd->dwFlags & FD_CREATETIME ? &pfd->ftCreationTime : NULL,
                                    pfd->dwFlags & FD_ACCESSTIME ? &pfd->ftLastAccessTime : NULL,
                                    pfd->dwFlags & FD_WRITESTIME ? &pfd->ftLastWriteTime : NULL);
                        CloseHandle(hFile);
                    }
                }

                if (dwSrcFileAttributes)
                {
                    SetFileAttributes(pszFile, dwSrcFileAttributes);
                }
            }

            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFile, NULL);
            SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, pszFile, NULL);
        }

        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI DataObj_GetShellURL(IDataObject *pdtobj, STGMEDIUM *pmedium, LPCSTR *ppszURL)
{
    FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr;

    if (pmedium)
    {
        hr = pdtobj->GetData(&fmte, pmedium);
        if (SUCCEEDED(hr))
            *ppszURL = (LPCSTR)GlobalLock(pmedium->hGlobal);
    }
    else
        hr = pdtobj->QueryGetData(&fmte); // query only

    return hr;
}

STDAPI DataObj_GetOFFSETs(IDataObject *pdtobj, POINT *ppt)
{
    STGMEDIUM medium = {0};

    IDLData_InitializeClipboardFormats( );
    ASSERT(g_cfOFFSETS);

    FORMATETC fmt = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    ASSERT(ppt);
    ppt->x = ppt->y = 0;
    HRESULT hr = pdtobj->GetData(&fmt, &medium);
    if (SUCCEEDED(hr))
    {
        POINT * pptTemp = (POINT *)GlobalLock(medium.hGlobal);
        if (pptTemp)
        {
            *ppt = *pptTemp;
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_UNEXPECTED;
        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI_(BOOL) DataObj_CanGoAsync(IDataObject *pdtobj)
{
    BOOL fDoOpAsynch = FALSE;
    IAsyncOperation * pao;

    if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pao))))
    {
        BOOL fIsOpAsync;
        if (SUCCEEDED(pao->GetAsyncMode(&fIsOpAsync)) && fIsOpAsync)
        {
            fDoOpAsynch = SUCCEEDED(pao->StartOperation(NULL));
        }
        pao->Release();
    }
    return fDoOpAsynch;
}

//
// HACKHACK: (reinerf) - We used to always do async drag/drop operations on NT4 by cloning the
// dataobject. Some apps (WS_FTP 6.0) rely on the async nature in order for drag/drop to work since
// they stash the return value from DoDragDrop and look at it later when their copy hook is invoked 
// by SHFileOperation(). So, we sniff the HDROP and if it has one path that contains "WS_FTPE\Notify"
// in it, then we do the operation async. 
//
STDAPI_(BOOL) DataObj_GoAsyncForCompat(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        // is there only one path in the hdrop?
        if (DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0) == 1)
        {
            TCHAR szPath[MAX_PATH];

            // is it the magical WS_FTP path ("%temp%\WS_FTPE\Notify") that WS_FTP sniffs
            // for in their copy hook?
            if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)) &&
                StrStrI(szPath, TEXT("WS_FTPE\\Notify")))
            {
                // yes, we have to do an async operation for app compat
                TraceMsg(TF_WARNING, "DataObj_GoAsyncForCompat: found WS_FTP HDROP, doing async drag-drop");
                bRet = TRUE;
            }
        }

        ReleaseStgMedium(&medium);
    }

    return bRet;
}

// use GlobalFree() to free the handle returned here
STDAPI DataObj_CopyHIDA(IDataObject *pdtobj, HIDA *phida)
{
    *phida = NULL;

    IDLData_InitializeClipboardFormats();

    STGMEDIUM medium;
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        SIZE_T cb = GlobalSize(medium.hGlobal);
        *phida = (HIDA)GlobalAlloc(GPTR, cb);
        if (*phida)
        {
            void *pv = GlobalLock(medium.hGlobal);
            CopyMemory((void *)*phida, pv, cb);
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_OUTOFMEMORY;
        ReleaseStgMedium(&medium);
    }
    return hr;
}

// Returns an IShellItem for the FIRST item in the data object
HRESULT DataObj_GetIShellItem(IDataObject *pdtobj, IShellItem** ppsi)
{
    LPITEMIDLIST pidl;
    HRESULT hr = PidlFromDataObject(pdtobj, &pidl);
    if (SUCCEEDED(hr))
    {
        // at shome point should find out who is calling this
        // can see if caller already as the info to create the ShellItem
        hr = SHCreateShellItem(NULL, NULL, pidl, ppsi);
        ILFree(pidl);
    }
    return hr;
}

STDAPI PathFromDataObject(IDataObject *pdtobj, LPTSTR pszPath, UINT cchPath)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    HRESULT hr = pdtobj->GetData(&fmte, &medium);

    if (SUCCEEDED(hr))
    {
        if (DragQueryFile((HDROP)medium.hGlobal, 0, pszPath, cchPath))
            hr = S_OK;
        else
            hr = E_FAIL;

        ReleaseStgMedium(&medium);
    }

    return hr;
}

STDAPI PidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidlTarget)
{
    HRESULT hr;

    *ppidlTarget = NULL;

    // If the data object has a HIDA, then use it.  This allows us to
    // access pidls inside data objects that aren't filesystem objects.
    // (It's also faster than extracting the path and converting it back
    // to a pidl.  Difference:  pidls for files on the desktop
    // are returned in original form instead of being converted to
    // a CSIDL_DESKTOPDIRECTORY-relative pidl.  I think this is a good thing.)

    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    if (pida)
    {
        *ppidlTarget = HIDA_ILClone(pida, 0);
        HIDA_ReleaseStgMedium(pida, &medium);
        hr = *ppidlTarget ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        // No HIDA available; go for a filename

        // This string is also used to store an URL in case it's an URL file
        TCHAR szPath[MAX_URL_STRING];

        hr = PathFromDataObject(pdtobj, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            *ppidlTarget = ILCreateFromPath(szPath);
            hr = *ppidlTarget ? S_OK : E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\debug.c ===
#include "shellprv.h"
#pragma  hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shell32"
#define SZ_MODULE           "SHELL32"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs
#include "..\inc\dump.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\datautil.h ===
#include <dobjutil.h>  // shell\inc (shared stuff)
#include "idlcomm.h"

// helper functions for people working with data objects

typedef struct
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO;

STDAPI_(UINT)   DataObj_GetHIDACount(IDataObject *pdtobj);
STDAPI          DataObj_SetDropTarget(IDataObject *pdtobj, const CLSID *pclsid);
STDAPI          DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid);
STDAPI_(void *) DataObj_SaveShellData(IDataObject *pdtobj, BOOL fShared);
STDAPI          DataObj_GetShellURL(IDataObject *pdtobj, STGMEDIUM *pmedium, LPCSTR *ppszURL);
STDAPI_(void)   ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium);
STDAPI          DataObj_SaveToFile(IDataObject *pdtobj, UINT cf, LONG lindex, LPCTSTR pszFile, FILEDESCRIPTOR *pfd, PROGRESSINFO * ppi);
STDAPI          DataObj_GetOFFSETs(IDataObject *pdtobj, POINT * ppt);
STDAPI_(BOOL)   DataObj_CanGoAsync(IDataObject *pdtobj);
STDAPI_(BOOL)   DataObj_GoAsyncForCompat(IDataObject *pdtobj);
STDAPI          DataObj_CopyHIDA(IDataObject * pdtobj, HIDA *phida);    // use GlobalFree() to free it
STDAPI          DataObj_GetIShellItem(IDataObject *pdtobj, IShellItem** ppsi);

STDAPI PathFromDataObject(IDataObject *pdtobj, LPTSTR pszPath, UINT cchPath);
STDAPI PidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidlTarget);

#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defclsf.c ===
//
// This file contains the implementation of SHCreateDefClassObject
//

#include "shellprv.h"
#pragma  hdrstop

typedef struct
{
    IClassFactory      cf;
    UINT               cRef;            // Reference count
    DWORD              dwFlags;         // Flags to control creation...
    LPFNCREATEINSTANCE pfnCreateInstance;          // CreateInstance callback entry
    UINT *        pcRefDll;     // Reference count of the DLL
} CClassFactory;

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        InterlockedIncrement(&this->cRef);
        *ppvObj = (LPVOID) (IClassFactory *) &this->cf;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    return this->cRef;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (--this->cRef > 0)
	return this->cRef;

    LocalFree((HLOCAL)this);

    return 0;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);

    *ppvObject = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    return this->pfnCreateInstance(pUnkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (this->pcRefDll)
    {
        if (fLock)
	    this->pcRefDll++;
        else
	    this->pcRefDll--;
    }
    return S_OK;
}

const IClassFactoryVtbl c_vtblAppUIClassFactory = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

//
// creates a simple default implementation of IClassFactory
//
// Parameters:
//  riid     -- Specifies the interface to the class object
//  ppv      -- Specifies the pointer to LPVOID where the class object pointer
//               will be returned.
//  pfnCreateInstance   -- Specifies the callback entry for instanciation.
//  pcRefDll -- Specifies the address to the DLL reference count (optional)
//
// Notes:
//   The riidInst will be specified only if the instance of the class
//  support only one interface.
//
// we would like to get rid of this
// this API called by MMSYS.CPL, RNAUI.DLL, SYNCUI.DLL

STDAPI SHCreateDefClassObject(REFIID riid, void **ppv, LPFNCREATEINSTANCE pfnCreateInstance, UINT *pcRefDll, REFIID riidInst)
{
    *ppv = NULL;

    if (IsEqualIID(riid, &IID_IClassFactory))
    {
        CClassFactory *pacf = (CClassFactory *)LocalAlloc(LPTR, SIZEOF(CClassFactory));
        if (pacf)
        {
            pacf->cf.lpVtbl = &c_vtblAppUIClassFactory;
            pacf->cRef++;  // pacf->cRef=0; (generates smaller code)
            pacf->pcRefDll = pcRefDll;
            pacf->pfnCreateInstance = pfnCreateInstance;

            (IClassFactory *)*ppv = &pacf->cf;
            return NOERROR;
        }
        return E_OUTOFMEMORY;
    }
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defcm.cpp ===
#include "shellprv.h"

#include "ids.h"
#include "pidl.h"
#include "fstreex.h"
#include "views.h"
#include "shlwapip.h"
#include "ole2dup.h"
#include "filetbl.h"
#include "datautil.h"
#include "undo.h"
#include "defview.h"
#include "cowsite.h"
#include "defcm.h"
#include "rpctimeout.h"

#define DEF_FOLDERMENU_MAXHKEYS 16

// used with static defcm elements (pointer from mii.dwItemData)
// and find extensions
typedef struct
{
    WCHAR wszMenuText[MAX_PATH];
    WCHAR wszHelpText[MAX_PATH];
    int   iIcon;
} SEARCHEXTDATA;

typedef struct
{
    SEARCHEXTDATA* psed;
    UINT           idCmd;
} SEARCHINFO;

// Defined in fsmenu.obj
BOOL _MenuCharMatch(LPCTSTR psz, TCHAR ch, BOOL fIgnoreAmpersand);

const ICIVERBTOIDMAP c_sDFMCmdInfo[] = {
    { L"delete",        "delete",       DFM_CMD_DELETE,         DCMIDM_DELETE },
    { c_szCut,          "cut",          DFM_CMD_MOVE,           DCMIDM_CUT },
    { c_szCopy,         "copy",         DFM_CMD_COPY,           DCMIDM_COPY },
    { c_szPaste,        "paste",        DFM_CMD_PASTE,          DCMIDM_PASTE },
    { c_szPaste,        "paste",        DFM_CMD_PASTE,          0 },
    { c_szLink,         "link",         DFM_CMD_LINK,           DCMIDM_LINK },
    { c_szProperties,   "properties",   DFM_CMD_PROPERTIES,     DCMIDM_PROPERTIES },
    { c_szPasteLink,    "pastelink",    DFM_CMD_PASTELINK,      0 },
    { c_szRename,       "rename",       DFM_CMD_RENAME,         DCMIDM_RENAME },
};


CDefBackgroundMenuCB::CDefBackgroundMenuCB(LPCITEMIDLIST pidlFolder) : _cRef(1)
{
    _pidlFolder = ILClone(pidlFolder);  // failure handled in the code 
}

CDefBackgroundMenuCB::~CDefBackgroundMenuCB()
{
    ILFree(_pidlFolder);
}

STDMETHODIMP CDefBackgroundMenuCB::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefBackgroundMenuCB, IContextMenuCB), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefBackgroundMenuCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDefBackgroundMenuCB::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDefBackgroundMenuCB::CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            DWORD dwAttr = SFGAO_HASPROPSHEET;
            if ((NULL == _pidlFolder) ||
                FAILED(SHGetAttributesOf(_pidlFolder, &dwAttr)) ||
                (SFGAO_HASPROPSHEET & dwAttr))
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_VALIDATECMD:
        switch (wParam)
        {
        case DFM_CMD_NEWFOLDER:
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = SHPropertiesForUnk(hwndOwner, psf, (LPCTSTR)lParam);
            break;

        default:
            hr = S_FALSE;   // view menu items, use the default
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

class CDefFolderMenu : public CObjectWithSite,
                       public IContextMenu3, 
                       public IServiceProvider,
                       public ISearchProvider,
                       public IShellExtInit
{
    friend HRESULT CDefFolderMenu_CreateHKeyMenu(HWND hwnd, HKEY hkey, IContextMenu **ppcm);
    friend HRESULT CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                             UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, IContextMenuCB *pcmcb, 
                             UINT nKeys, const HKEY *ahkeys, 
                             IContextMenu **ppcm);

public:
    CDefFolderMenu(BOOL fUnderKey);
    HRESULT Init(DEFCONTEXTMENU *pdcm);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType,
                                UINT *pwRes, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppvObj);

    // ISearchProvider
    STDMETHOD(GetSearchGUID)(GUID *pGuid);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

private:
    ~CDefFolderMenu();

    DWORD   _AttributesOfItems(DWORD dwAttrMask);
    UINT    _AddStatic(HMENU hmenu, UINT idCmd, UINT idCmdLast, HKEY hkey);
    void    _InvokeStatic(UINT iCmd);
    HRESULT _InitDropTarget();
    HRESULT _GetMenuVerb(HMENU hmenu, int idFirst, int idMax, int item, LPWSTR psz, DWORD cch);
    void _UnduplicateVerbs(HMENU hmenu, int idFirst, int idMax);
    void _SetMenuDefault(HMENU hmenu, UINT idCmdFirst, UINT idMax);
    HRESULT _ProcessEditPaste(BOOL fPasteLink);
    HRESULT _ProcessRename();
    void    _DrawItem(DRAWITEMSTRUCT *pdi);
    LRESULT _MeasureItem(MEASUREITEMSTRUCT *pmi);

private:
    LONG            _cRef;           // Reference count
    IDropTarget     *_pdtgt;         // Drop target of selected item
    IContextMenuCB  *_pcmcb;         // Callback object
    IDataObject     *_pdtobj;        // Data object
    IShellFolder    *_psf;           // Shell folder
    HWND            _hwnd;           // Owner window
    UINT            _idCmdFirst;     // base id
    UINT            _idStdMax;       // standard commands (cut/copy/delete/properties) ID MAX
    UINT            _idFolderMax;    // Folder command ID MAX
    UINT            _idVerbMax;      // Add-in command (verbs) ID MAX
    UINT            _idDelayInvokeMax;// extensiosn loaded at invoke time
    UINT            _idFld2Max;      // 2nd range of Folder command ID MAX
    HDSA            _hdsaStatics;    // For static menu items.
    HDXA            _hdxa;           // Dynamic menu array
    HDSA            _hdsaCustomInfo; // array of SEARCHINFO's
    LPITEMIDLIST    _pidlFolder;
    LPITEMIDLIST    *_apidl;
    UINT             _cidl;
    IAssociationArray *_paa;
    
    CSafeServiceSite *_psss;
    
    BOOL            _bUnderKeys;        // Data is directly under key, not
                                        // shellex\ContextMenuHandlers
    UINT            _nKeys;             // Number of class keys
    HKEY            _hkeyClsKeys[DEF_FOLDERMENU_MAXHKEYS];  // Class keys

    HMENU           _hmenu;
    UINT            _uFlags;
    BOOL            _bInitMenuPopup; // true if we received WM_INITMENUPOPUP and _uFlags & CMF_FINDHACK
    int             _iStaticInvoked; // index of the invoked static item

    IDMAPFORQCMINFO _idMap;         // our named separator mapping table
};

#define GetFldFirst(this) (_idStdMax + _idCmdFirst)

HRESULT HDXA_FindByCommand(HDXA hdxa, UINT idCmd, REFIID riid, void **ppv);

STDMETHODIMP CDefFolderMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDefFolderMenu, IContextMenu, IContextMenu3),
        QITABENTMULTI(CDefFolderMenu, IContextMenu2, IContextMenu3),
        QITABENT(CDefFolderMenu, IContextMenu3), 
        QITABENT(CDefFolderMenu, IObjectWithSite), 
        QITABENT(CDefFolderMenu, IServiceProvider),
        QITABENT(CDefFolderMenu, ISearchProvider),
        QITABENT(CDefFolderMenu, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefFolderMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

CDefFolderMenu::CDefFolderMenu(BOOL fUnderKey)
{
    _cRef = 1;
    _iStaticInvoked = -1;

    _bUnderKeys = fUnderKey;

    _psss = new CSafeServiceSite;
    if (_psss)
        _psss->SetProviderWeakRef(SAFECAST(this, IServiceProvider *));
        
    
    IDLData_InitializeClipboardFormats();

    ASSERT(_pidlFolder == NULL);
    ASSERT(_punkSite == NULL);
}

HRESULT CDefFolderMenu::Init(DEFCONTEXTMENU *pdcm)
{
    _hwnd = pdcm->hwnd;

    _psf = pdcm->psf;
    if (_psf)
        _psf->AddRef();

    _pcmcb = pdcm->pcmcb;
    if (_pcmcb)
    {
        IUnknown_SetSite(_pcmcb, _psss);
        _pcmcb->AddRef();
        _pcmcb->CallBack(_psf, _hwnd, NULL, DFM_ADDREF, 0, 0);
    }

    _paa = pdcm->paa;
    if (_paa)
        _paa->AddRef();
        
    HRESULT hr = CloneIDListArray(pdcm->cidl, pdcm->apidl, &_cidl, &_apidl);
    if (SUCCEEDED(hr) && pdcm->pidlFolder)
    {
        hr = SHILClone(pdcm->pidlFolder, &_pidlFolder);
    }

    if (SUCCEEDED(hr) && _cidl && _psf)
    {
        hr = _psf->GetUIObjectOf(_hwnd, _cidl, (LPCITEMIDLIST *)_apidl, IID_PPV_ARG_NULL(IDataObject, &_pdtobj));
    }

    if (SUCCEEDED(hr))
    {
        _hdxa = HDXA_Create();
        if (NULL == _hdxa)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        if (pdcm->aKeys)
        {
            ASSERT(pdcm->cKeys <= ARRAYSIZE(_hkeyClsKeys));
            for (UINT i = 0; i < pdcm->cKeys; ++i)
            {
                if (pdcm->aKeys[i])
                {
                    // Make a copy of the key for menu's use
                    _hkeyClsKeys[_nKeys] = SHRegDuplicateHKey(pdcm->aKeys[i]);
                    if (_hkeyClsKeys[_nKeys])
                    {
                        _nKeys++;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }
        }
        else if (_paa)
        {
            //  we can get it from the _paa
            _nKeys = SHGetAssocKeysEx(_paa, ASSOCELEM_MASK_ENUMCONTEXTMENU, _hkeyClsKeys, ARRAYSIZE(_hkeyClsKeys));
        }
    }
    return hr;
}

void ContextMenuInfo_SetSite(ContextMenuInfo *pcmi, IUnknown *pSite)
{
    // APPCOMPAT: PGP50 can only be QIed for IContextMenu, IShellExtInit, and IUnknown.
    if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_LIMITEDQI))
        IUnknown_SetSite((IUnknown*)pcmi->pcm, pSite);
}

CDefFolderMenu::~CDefFolderMenu()
{
    if (_psss)
    {
        _psss->SetProviderWeakRef(NULL);
        _psss->Release();
    }
    
    if (_pcmcb) 
    {
        IUnknown_SetSite(_pcmcb, NULL);
        _pcmcb->CallBack(_psf, _hwnd, NULL, DFM_RELEASE, _idStdMax, 0);
        _pcmcb->Release();
    }

    if (_hdxa) 
    {
        for (int i = 0; i < DSA_GetItemCount(_hdxa); i++)
        {
            ContextMenuInfo_SetSite((ContextMenuInfo *)DSA_GetItemPtr(_hdxa, i), NULL);
        }

        HDXA_Destroy(_hdxa);
    }

    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_pdtgt);
    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(_paa);

    for (UINT i = 0; i < _nKeys; i++)
    {
        RegCloseKey(_hkeyClsKeys[i]);
    }

    FreeIDListArray(_apidl, _cidl);
    _cidl = 0;
    _apidl = NULL;

    // if _bInitMenuPopup = true then we changed the dwItemData of the non static items
    // so we have to free them. otherwise don't touch them
    if (_hdsaCustomInfo)
    {
        // remove the custom data structures hanging off mii.dwItemData of static menu items
        // or all items if _uFlags & CMF_FINDHACK
        int cItems = DSA_GetItemCount(_hdsaCustomInfo);

        for (int i = 0; i < cItems; i++)
        {
            SEARCHINFO* psinfo = (SEARCHINFO*)DSA_GetItemPtr(_hdsaCustomInfo, i);
            ASSERT(psinfo);
            SEARCHEXTDATA* psed = psinfo->psed;

            if (psed)
                LocalFree(psed);
        }
        DSA_Destroy(_hdsaCustomInfo);
    }

    if (_hdsaStatics)
        DSA_Destroy(_hdsaStatics);

    ILFree(_pidlFolder);
}

STDMETHODIMP_(ULONG) CDefFolderMenu::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

int _SHMergePopupMenus(HMENU hmMain, HMENU hmMerge, int idCmdFirst, int idCmdLast)
{
    int i, idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     // just in case

        if (GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            int idTemp = Shell_MergeMenus(_GetMenuFromID(hmMain, mii.wID),
                mii.hSubMenu, (UINT)0, idCmdFirst, idCmdLast,
                MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            if (idMax < idTemp)
                idMax = idTemp;
        }
    }

    return idMax;
}


void CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge, QCMINFO *pqcm)
{
    UINT idMax = pqcm->idCmdFirst;

    if (idMainMerge)
    {
        HMENU hmMerge = SHLoadPopupMenu(hinst, idMainMerge);
        if (hmMerge)
        {
            idMax = Shell_MergeMenus(
                    pqcm->hmenu, hmMerge, pqcm->indexMenu,
                    pqcm->idCmdFirst, pqcm->idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);
                
            DestroyMenu(hmMerge);
        }
    }

    if (idPopupMerge)
    {
        HMENU hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge));
        if (hmMerge)
        {
            UINT idTemp = _SHMergePopupMenus(pqcm->hmenu, hmMerge,
                    pqcm->idCmdFirst, pqcm->idCmdLast);
            if (idMax < idTemp)
                idMax = idTemp;

            DestroyMenu(hmMerge);
        }
    }

    pqcm->idCmdFirst = idMax;
}

BOOL _IsDesktop(IShellFolder *psf, UINT cidl, LPCITEMIDLIST *apidl)
{
    CLSID clsid;
    return IsSelf(cidl, apidl) && 
           SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) && 
           IsEqualGUID(clsid, CLSID_ShellDesktop);
}

DWORD CDefFolderMenu::_AttributesOfItems(DWORD dwAttrMask)
{
    if (!_psf || !_cidl || FAILED(_psf->GetAttributesOf(_cidl, (LPCITEMIDLIST *)_apidl, &dwAttrMask)))
        dwAttrMask = 0;
        
    return dwAttrMask;
}

void _DisableRemoveMenuItem(HMENU hmInit, UINT uID, BOOL bAvail, BOOL bRemoveUnavail)
{
    if (bAvail)
    {
        EnableMenuItem(hmInit, uID, MF_ENABLED|MF_BYCOMMAND);
    }
    else if (bRemoveUnavail)
    {
        DeleteMenu(hmInit, uID, MF_BYCOMMAND);
    }
    else
    {
        EnableMenuItem(hmInit, uID, MF_GRAYED|MF_BYCOMMAND);
    }
}

// Enable/disable menuitems in the "File" & popup context menu

void Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst, BOOL bContext)
{
    idCmdFirst -= SFVIDM_FIRST;

    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_RENAME     + idCmdFirst, dwAttr & SFGAO_CANRENAME, bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_DELETE     + idCmdFirst, dwAttr & SFGAO_CANDELETE, bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_LINK       + idCmdFirst, dwAttr & SFGAO_CANLINK,   bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_PROPERTIES + idCmdFirst, dwAttr & SFGAO_HASPROPSHEET, bContext);
}

STDAPI_(BOOL) IsClipboardOwnerHung(DWORD dwTimeout)
{
    HWND hwnd = GetClipboardOwner();
    if (!hwnd)
        return FALSE;

    DWORD_PTR dwResult;
    return !SendMessageTimeout(hwnd, WM_NULL, 0, 0, SMTO_ABORTIFHUNG, dwTimeout, &dwResult);
}

STDAPI_(BOOL) Def_IsPasteAvailable(IDropTarget *pdtgt, DWORD *pdwEffect)
{
    BOOL fRet = FALSE;

    *pdwEffect = 0;     // assume none

    // Count the number of clipboard formats available, if there are none then there
    // is no point making the clipboard available.
    
    if (pdtgt && (CountClipboardFormats() > 0))
    {
        DECLAREWAITCURSOR;

        SetWaitCursor();

        // The clipboard owner might be hung, so time him out if he takes too long.
        // We don't want context menus to hang just because some app is hung.
        CRPCTimeout rpctimeout;

        IDataObject *pdtobj;
        if (!IsClipboardOwnerHung(1000) && SUCCEEDED(OleGetClipboard(&pdtobj)))
        {
            POINTL pt = {0, 0};
            DWORD dwEffectOffered = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY | DROPEFFECT_LINK);

            // Unfortunately, OLE turns RPC errors into generic errors
            // so we can't use the HRESULT from IDataObject::GetData
            // to tell whether the object is alive and doesn't support
            // PreferredDropEffect or is hung and OLE turned the
            // error code into DV_E_FORMATETC.  So see if our timeout fired.
            // This is not foolproof because OLE sometimes caches the "is
            // the data object hung" state and returns error immediately
            // instead of timing out.  But it's better than nothing.
            if (rpctimeout.TimedOut())
            {
                dwEffectOffered = 0;
            }

            // Check if we can paste.
            DWORD dwEffect = (dwEffectOffered & (DROPEFFECT_MOVE | DROPEFFECT_COPY));
            if (dwEffect)
            {
                if (SUCCEEDED(pdtgt->DragEnter(pdtobj, MK_RBUTTON, pt, &dwEffect)))
                {
                    pdtgt->DragLeave();
                }
                else
                {
                    dwEffect = 0;
                }
            }

            // Check if we can past-link.
            DWORD dwEffectLink = (dwEffectOffered & DROPEFFECT_LINK);
            if (dwEffectLink)
            {
                if (SUCCEEDED(pdtgt->DragEnter(pdtobj, MK_RBUTTON, pt, &dwEffectLink)))
                {
                    pdtgt->DragLeave();
                    dwEffect |= dwEffectLink;
                }
            }

            fRet = (dwEffect & (DROPEFFECT_MOVE | DROPEFFECT_COPY));
            *pdwEffect = dwEffect;

            pdtobj->Release();
        }
        ResetWaitCursor();
    }

    return fRet;
}

void Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst, IDropTarget *pdtgt, UINT fContext)
{
    DWORD dwEffect = 0;
    TCHAR szMenuText[80];

    idCmdFirst -= SFVIDM_FIRST;

    // Do the UNDO stuff only if the menu has an Undo option
    if (GetMenuState(hmInit, SFVIDM_EDIT_UNDO + idCmdFirst, MF_BYCOMMAND) != 0xFFFFFFFF)
    {
        // enable undo if there's an undo history
        BOOL bEnableUndo = IsUndoAvailable();
        if (bEnableUndo)
        {
            GetUndoText(szMenuText, ARRAYSIZE(szMenuText), UNDO_MENUTEXT);
        }
        else
        {
            szMenuText[0] = 0;
            LoadString(HINST_THISDLL, IDS_UNDOMENU, szMenuText, ARRAYSIZE(szMenuText));
        }

        if (szMenuText[0])
        {
            ModifyMenu(hmInit, SFVIDM_EDIT_UNDO + idCmdFirst, MF_BYCOMMAND | MF_STRING,
                       SFVIDM_EDIT_UNDO + idCmdFirst, szMenuText);
        }
        _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_UNDO  + idCmdFirst, bEnableUndo, fContext);
    }

    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_CUT   + idCmdFirst,  dwAttr & SFGAO_CANMOVE, fContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_COPY  + idCmdFirst, dwAttr & SFGAO_CANCOPY, fContext);

    // Never remove the "Paste" command
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_PASTE + idCmdFirst, Def_IsPasteAvailable(pdtgt, &dwEffect), fContext & DIEC_SELECTIONCONTEXT);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_PASTELINK + idCmdFirst, dwEffect & DROPEFFECT_LINK, fContext & DIEC_SELECTIONCONTEXT);

    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_MOVETO + idCmdFirst, dwAttr & SFGAO_CANMOVE, fContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_COPYTO + idCmdFirst, dwAttr & SFGAO_CANCOPY, fContext);
}

int Static_ExtractIcon(HKEY hkeyMenuItem)
{
    HKEY hkeyDefIcon;
    int iImage = -1;

    if (RegOpenKey(hkeyMenuItem, c_szDefaultIcon, &hkeyDefIcon) == ERROR_SUCCESS)
    {
        TCHAR szDefIcon[MAX_PATH];
        DWORD cb = sizeof(szDefIcon);

        if (SHQueryValueEx(hkeyDefIcon, NULL, NULL, NULL, (BYTE*)szDefIcon, &cb) == ERROR_SUCCESS)
        {
            iImage = Shell_GetCachedImageIndex(szDefIcon, PathParseIconLocation(szDefIcon), 0);
        }
        RegCloseKey(hkeyDefIcon);
    }
    return iImage;
}

typedef struct
{
    CLSID clsid;
    UINT idCmd;
    UINT idMenu;        // used in cleanup
    GUID  guidSearch;   //used with search extensions only
} STATICITEMINFO;

#define LAST_ITEM  (int)0x7FFFFFFF

UINT CDefFolderMenu::_AddStatic(HMENU hmenu, UINT idCmd, UINT idCmdLast, HKEY hkey)
{
    if (idCmd > idCmdLast)
    {
        DebugMsg(DM_ERROR, TEXT("si_a: Out of command ids!"));
        return idCmd;
    }

    ASSERT(!_hdsaStatics);
    ASSERT(!_hdsaCustomInfo);

    HDSA hdsaCustomInfo = DSA_Create(sizeof(SEARCHINFO), 1);
    // Create a hdsaStatics.
    HDSA hdsaStatics = DSA_Create(sizeof(STATICITEMINFO), 1);
    if (hdsaStatics && hdsaCustomInfo)
    {
        HKEY hkeyStatic;
        // Try to open the "Static" subkey.
        if (RegOpenKey(hkey, TEXT("Static"), &hkeyStatic) == ERROR_SUCCESS)
        {
            TCHAR szClass[MAX_PATH];
            BOOL bFindFilesInserted = FALSE;

            // For each subkey of static.
            for (int i = 0; RegEnumKey(hkeyStatic, i, szClass, ARRAYSIZE(szClass)) == ERROR_SUCCESS; i++)
            {
                HKEY hkeyClass;

                // Record the GUID.
                if (RegOpenKey(hkeyStatic, szClass, &hkeyClass) == ERROR_SUCCESS)
                {
                    TCHAR szCLSID[MAX_PATH];
                    DWORD cb = sizeof(szCLSID);
                    // HACKHACK: (together with bWebSearchInserted above
                    // we need to have On the Internet as the first menu item
                    // and Find Files or Folders as second
                    BOOL bWebSearch = lstrcmp(szClass, TEXT("WebSearch")) == 0;
                    BOOL bFindFiles = FALSE;

                    if (SHQueryValueEx(hkeyClass, NULL, NULL, NULL, (BYTE*)szCLSID, &cb) == ERROR_SUCCESS)
                    {
                        HKEY hkeyMenuItem;
                        TCHAR szSubKey[32];

                        // enum the sub keys 0..N
                        for (int iMenuItem = 0; wsprintf(szSubKey, TEXT("%d"), iMenuItem),
                             RegOpenKey(hkeyClass, szSubKey, &hkeyMenuItem) == ERROR_SUCCESS; 
                             iMenuItem++)
                        {
                            TCHAR szMenuText[MAX_PATH];
                            if (SUCCEEDED(SHLoadLegacyRegUIString(hkeyMenuItem, NULL, szMenuText, ARRAYSIZE(szMenuText))))
                            {
                                STATICITEMINFO sii;
                                SEARCHINFO sinfo;
                                
                                TCHAR szHelpText[MAX_PATH];
                                SHLoadLegacyRegUIString(hkeyMenuItem, TEXT("HelpText"), szHelpText, ARRAYSIZE(szHelpText));

                                SHCLSIDFromString(szCLSID, &sii.clsid); // store it
                                sii.idCmd = iMenuItem;
                                sii.idMenu = idCmd;

                                // get the search guid if any...
                                TCHAR szSearchGUID[MAX_PATH];
                                cb = sizeof(szSearchGUID);
                                if (SHGetValue(hkeyMenuItem, TEXT("SearchGUID"), NULL, NULL, (BYTE*)szSearchGUID, &cb) == ERROR_SUCCESS)
                                    SHCLSIDFromString(szSearchGUID, &sii.guidSearch);
                                else
                                    sii.guidSearch = GUID_NULL;

                                // cleanup -- allow non-static
                                // find extensions to specify a search guid and then we can
                                // remove this static "Find Computer" business...
                                //
                                // if this is FindComputer item and the restriction is not set 
                                // don't add it to the menu
                                if (IsEqualGUID(sii.guidSearch, SRCID_SFindComputer) &&
                                    !SHRestricted(REST_HASFINDCOMPUTERS))
                                    continue;

                                bFindFiles = IsEqualGUID(sii.guidSearch, SRCID_SFileSearch);
                                if (bFindFiles && SHRestricted(REST_NOFIND))
                                    continue;

                                if (IsEqualGUID(sii.guidSearch, SRCID_SFindPrinter))
                                    continue;
                                    
                                DSA_AppendItem(hdsaStatics, &sii);

                                SEARCHEXTDATA *psed = (SEARCHEXTDATA *)LocalAlloc(LPTR, sizeof(*psed));
                                if (psed)
                                {
                                    psed->iIcon = Static_ExtractIcon(hkeyMenuItem);
                                    SHTCharToUnicode(szHelpText, psed->wszHelpText, ARRAYSIZE(psed->wszHelpText));
                                    SHTCharToUnicode(szMenuText, psed->wszMenuText, ARRAYSIZE(psed->wszMenuText));
                                }

                                MENUITEMINFO mii;
                                mii.cbSize = sizeof(mii);
                                mii.fMask  = MIIM_DATA | MIIM_TYPE | MIIM_ID;
                                mii.fType  = MFT_OWNERDRAW;
                                mii.wID    = idCmd;
                                mii.dwItemData = (DWORD_PTR)psed;

                                sinfo.psed = psed;
                                sinfo.idCmd = idCmd;
                                if (DSA_AppendItem(hdsaCustomInfo, &sinfo) != -1)
                                {      
                                    // insert Files or Folders in the first place (see HACKHACK above)
                                    if (!bFindFilesInserted && bFindFiles)
                                        bFindFilesInserted = InsertMenuItem(hmenu, 0, TRUE, &mii);
                                    else
                                    {
                                        UINT uiPos = LAST_ITEM;

                                        // if this is Find Files or Folders insert it after
                                        // On the Internet or in the first place if OtI is
                                        // not inserted yet
                                        if (bWebSearch)
                                            uiPos = bFindFilesInserted ? 1 : 0;
                                        // we don't free psed if Insert fails because it's 
                                        // in dsa and it's going to be freed on destroy
                                        InsertMenuItem(hmenu, uiPos, TRUE, &mii);
                                    }
                                }

                                // Next command.
                                idCmd++;
                                if (idCmd > idCmdLast)
                                {
                                    DebugMsg(DM_ERROR, TEXT("si_a: Out of command ids!"));
                                    break;
                                }
                            }
                            RegCloseKey(hkeyMenuItem);
                        }
                    }
                    RegCloseKey(hkeyClass);
                }
            }
            RegCloseKey(hkeyStatic);
        }
        _hdsaStatics = hdsaStatics;
        _hdsaCustomInfo = hdsaCustomInfo;
    }
    return idCmd;
}


void CDefFolderMenu::_InvokeStatic(UINT iCmd)
{
    if (_hdsaStatics)
    {
        STATICITEMINFO *psii = (STATICITEMINFO *)DSA_GetItemPtr(_hdsaStatics, iCmd);
        if (psii)
        {
            IContextMenu *pcm;
            if (SUCCEEDED(SHExtCoCreateInstance(NULL, &psii->clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm))))
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    CMINVOKECOMMANDINFO ici;
                    CHAR szSearchGUID[GUIDSTR_MAX];
                    LPSTR psz = NULL;

                    _iStaticInvoked = iCmd;
                    IUnknown_SetSite(pcm, _psss);

                    pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, CMF_NORMAL);
                    ici.cbSize = sizeof(ici);
                    ici.fMask = 0;
                    ici.hwnd = NULL;
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(psii->idCmd);
                    if (!IsEqualGUID(psii->guidSearch, GUID_NULL))
                    {
                        SHStringFromGUIDA(psii->guidSearch, szSearchGUID, ARRAYSIZE(szSearchGUID));
                        psz = szSearchGUID;
                    }
                    ici.lpParameters = psz;
                    ici.lpDirectory = NULL;
                    ici.nShow = SW_NORMAL;
                    pcm->InvokeCommand(&ici);
                    DestroyMenu(hmenu);
                    IUnknown_SetSite(pcm, NULL);
                }
                pcm->Release();
            }
        }
    }
}

HRESULT CDefFolderMenu::_InitDropTarget()
{
    HRESULT hr;
    if (_pdtgt)
        hr = S_OK;  // have cached version
    else
    {
        // try to create _pdtgt
        if (_cidl)
        {
            ASSERT(NULL != _psf); // _pdtobj came from _psf
            hr = _psf->GetUIObjectOf(_hwnd, 1, (LPCITEMIDLIST *)_apidl, IID_PPV_ARG_NULL(IDropTarget, &_pdtgt));
        } 
        else if (_psf)
        {
            hr = _psf->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdtgt));
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM
//  Separator
//  ("File" menu, if applicable)
//
// Defcm uses names separators to do this magic.  Unfortunately _SHPrettyMenu
// removes duplicate separators and we don't always control when that happens.
// So we build up the above empty menu first, and then insert into appropriate ranges.
//
// If you call SHPrepareMenuForDefcm, you must call SHPrettyMenuForDefcm before you return/TrackPopupMenu
//
#define DEFCM_RANGE                 5 // the number of FSIDMs belor
#define IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast) (((idCmdLast)-(DEFCM_RANGE))>(idCmdFirst))
#define FSIDM_FOLDER_SEP(idCmdLast) ((idCmdLast)-1)
#define FSIDM_VIEW_SEP(idCmdLast)   ((idCmdLast)-2)
#define FSIDM_PLACE_SEP(idCmdLast)  ((idCmdLast)-3)
#define FSIDM_PLACE_VAL(idCmdLast)  ((idCmdLast)-4)
HRESULT SHPrepareMenuForDefcm(HMENU hmenu, UINT indexMenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast)
{
    HRESULT hr = S_OK;

    if (!(uFlags & CMF_DEFAULTONLY) && IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        UINT uPosView = GetMenuPosFromID(hmenu, FSIDM_VIEW_SEP(idCmdLast));
        UINT uPosFolder = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));

        if (-1 != uPosView && -1 != uPosFolder)
        {
            // Menu is already set up correctly
        }
        else if (-1 == uPosView && -1 == uPosFolder)
        {
            // Insert everything backwords at position indexMenu
            //
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_FOLDER_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_VIEW_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));

            hr = S_FALSE;
        }
        else
        {
            TraceMsg(TF_ERROR, "Some context menu removed a single named separator, we're in a screwy state");

            if (-1 == uPosFolder)
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_FOLDER_SEP(idCmdLast), TEXT(""));
            if (-1 == uPosView)
            {
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_VIEW_SEP(idCmdLast), TEXT(""));
            }
        }
    }

    return hr;
}

HRESULT SHPrettyMenuForDefcm(HMENU hmenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast, HRESULT hrPrepare)
{
    if (!(uFlags & CMF_DEFAULTONLY) && IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        if (S_FALSE == hrPrepare)
        {
            while (DeleteMenu(hmenu, FSIDM_PLACE_VAL(idCmdLast), MF_BYCOMMAND))
            {
                // Remove all our non-separator menu items
            }
        }
    }

    _SHPrettyMenu(hmenu);

    return S_OK;
}

HRESULT SHUnprepareMenuForDefcm(HMENU hmenu, UINT idCmdFirst, UINT idCmdLast)
{
    if (IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        // Remove all the named separators we may have added
        DeleteMenu(hmenu, FSIDM_VIEW_SEP(idCmdLast), MF_BYCOMMAND);
        DeleteMenu(hmenu, FSIDM_FOLDER_SEP(idCmdLast), MF_BYCOMMAND);
        while (DeleteMenu(hmenu, FSIDM_PLACE_SEP(idCmdLast), MF_BYCOMMAND))
        {
            // Remove all our placeholder separators
        }
    }

    return S_OK;
}

void CDefFolderMenu::_SetMenuDefault(HMENU hmenu, UINT idCmdFirst, UINT idMax)
{
    // we are about to set the default menu id, give the callback a chance
    // to override and set one of the static entries instead of the
    // first entry in the menu.

    WPARAM idStatic;
    if (_pcmcb && SUCCEEDED(_pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                                             DFM_GETDEFSTATICID, 
                                             0, (LPARAM)&idStatic)))
    {
        for (int i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (idStatic == c_sDFMCmdInfo[i].idDFMCmd)
            {
                SetMenuDefaultItem(hmenu, idCmdFirst + c_sDFMCmdInfo[i].idDefCmd, MF_BYCOMMAND);
                break;
            }
        }
    }

    if (GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1)
    {
        int i = 0;
        int cMenu = GetMenuItemCount(hmenu);
        for (; i < cMenu; i++)
        {
            //  fallback to openas so that files that have progids
            //  dont endup using AFSO or * for their default verbs
            WCHAR szi[CCH_KEYMAX];
            HRESULT hr = _GetMenuVerb(hmenu, idCmdFirst, idMax, i, szi, ARRAYSIZE(szi));
            if (hr == S_OK && *szi && 0 == StrCmpI(szi, TEXT("openas")))
            {
                SetMenuDefaultItem(hmenu, i, MF_BYPOSITION);
                break;
            }
        }

        if (i == cMenu)
        {
            ASSERT(GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1);
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
        }
    }
}

STDMETHODIMP CDefFolderMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
    DECLAREWAITCURSOR;
    BOOL fUseDefExt;

    SetWaitCursor();

    _idCmdFirst = idCmdFirst;
    _hmenu = hmenu;
    _uFlags = uFlags;
    _bInitMenuPopup = FALSE;

    // Set up the menu for defcm
    HRESULT hrPrepare = SHPrepareMenuForDefcm(hmenu, indexMenu, uFlags, idCmdFirst, idCmdLast);

    if (IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        _idMap.max = 2;
        _idMap.list[0].id = FSIDM_FOLDER_SEP(idCmdLast);
        _idMap.list[0].fFlags = QCMINFO_PLACE_BEFORE;
        _idMap.list[1].id = FSIDM_VIEW_SEP(idCmdLast);
        _idMap.list[1].fFlags = QCMINFO_PLACE_AFTER;

        qcm.pIdMap = (const QCMINFO_IDMAP *)&_idMap;

        qcm.idCmdLast = idCmdLast - DEFCM_RANGE;
    }

    // first add in the folder commands like cut/copy/paste
    if (_pdtobj && !(uFlags & (CMF_VERBSONLY | CMF_DVFILE)))
    {
        if (!(CMF_DEFAULTONLY & uFlags))
        {
            ATOMICRELEASE(_pdtgt);  // If we previously got the drop target, release it.
            _InitDropTarget();      // ignore failure, NULL _pdtgt is handled below
        }

        // We're going to merge two HMENUs into the context menu,
        // but we want only one id range for them...  Remember the idCmdFirst.
        //
        UINT idCmdFirstTmp = qcm.idCmdFirst;

        UINT indexMenuTmp = qcm.indexMenu;

        UINT uPos = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));

        // POPUP_DCM_ITEM2 goes after FSIDM_FOLDER_SEP(idCmdLast)
        if (-1 != uPos)
            qcm.indexMenu = uPos + 1;
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DCM_ITEM2, 0, &qcm);

        UINT idCmdFirstMax = qcm.idCmdFirst;
        qcm.idCmdFirst = idCmdFirstTmp;

        // POPUP_DCM_ITEM goes TWO before FSIDM_FOLDER_SEP(idCmdLast)
        if (-1 != uPos)
            qcm.indexMenu = uPos - 1;
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DCM_ITEM, 0, &qcm);

        qcm.indexMenu = indexMenuTmp;

        qcm.idCmdFirst = max(idCmdFirstTmp, qcm.idCmdFirst);

        ULONG dwAttr = _AttributesOfItems(
                    SFGAO_CANRENAME | SFGAO_CANDELETE |
                    SFGAO_CANLINK   | SFGAO_HASPROPSHEET |
                    SFGAO_CANCOPY   | SFGAO_CANMOVE);

        if (!(uFlags & CMF_CANRENAME))
            dwAttr &= ~SFGAO_CANRENAME;

        Def_InitFileCommands(dwAttr, hmenu, idCmdFirst, TRUE);

        // Don't try to figure out paste if we're just going to invoke the default
        // (Figuring out paste is expensive)
        if (CMF_DEFAULTONLY & uFlags)
        {
            ASSERT(_pdtgt == NULL);
        }

        Def_InitEditCommands(dwAttr, hmenu, idCmdFirst, _pdtgt, DIEC_SELECTIONCONTEXT);
    }

    _idStdMax = qcm.idCmdFirst - idCmdFirst;

    // DFM_MERGECONTEXTMENU returns S_FALSE if we should not add any verbs.
    if (_pcmcb) 
    {
        HRESULT hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU, uFlags, (LPARAM)&qcm);
        fUseDefExt = (hr == S_OK);
        UINT indexMenuTmp = qcm.indexMenu;
        UINT uPos = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));
        if (-1 != uPos)
            qcm.indexMenu = uPos + 1;
        hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU_BOTTOM, uFlags, (LPARAM)&qcm);
        if (!fUseDefExt)
            fUseDefExt = (hr == S_OK);
        qcm.indexMenu = indexMenuTmp;
    }
    else 
    {
        fUseDefExt = FALSE;
    }

    _idFolderMax = qcm.idCmdFirst - idCmdFirst;
    // add registry verbs
    if ((!(uFlags & CMF_NOVERBS)) ||
        (!_pdtobj && !_psf && _nKeys)) // this second case is for find extensions
    {
        // HACK: Default Extenstions EXPECT a selection, Let's hope all don't
        if (!_pdtobj)
            fUseDefExt = FALSE;

        // Put the separator between container menuitems and object menuitems
        // only if we don't have the separator at the insertion point.
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;              // to avoid ramdom result.
        if (GetMenuItemInfo(hmenu, indexMenu, TRUE, &mii) && !(mii.fType & MFT_SEPARATOR))
        {
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, (UINT)-1, NULL);
        }

        HDCA hdca = DCA_Create();
        if (hdca)
        {
            // Add default extensions, only if the folder callback returned
            // S_OK. The Printer and Control folder returns S_FALSE
            // indicating that they don't need any default extension.

            if (fUseDefExt)
            {
                // Always add this default extention at the top.
                DCA_AddItem(hdca, CLSID_ShellFileDefExt);
            }

            // Append menus for all extensions
            for (UINT nKeys = 0; nKeys < _nKeys; ++nKeys)
            {
                DCA_AddItemsFromKey(hdca, _hkeyClsKeys[nKeys],
                        _bUnderKeys ? NULL : STRREG_SHEX_MENUHANDLER);
            }
            // Work Around:
            // first time we call this _hdxa is empty            
            // after that it has the same items as before but will not add any new ones
            // if user keeps right clicking we will eventually run out of menu item ids
            // read comment in HDXA_AppendMenuItems2. to prevent it we empty _hdxa
            HDXA_DeleteAll(_hdxa);

            // (lamadio) For background context menu handlers, the pidlFolder 
            // should be a valid pidl, but, for backwards compatilility, this 
            // parameter should be NULL, if the Dataobject is NOT NULL.

            qcm.idCmdFirst = HDXA_AppendMenuItems2(_hdxa, _pdtobj,
                            _nKeys, _hkeyClsKeys,
                            !_pdtobj ? _pidlFolder : NULL, 
                            &qcm, uFlags, hdca, _psss);

            DCA_Destroy(hdca);
        }

        _idVerbMax = qcm.idCmdFirst - idCmdFirst;

        // menu extensions that are loaded at invoke time
        if (uFlags & CMF_INCLUDESTATIC)
        {
            qcm.idCmdFirst = _AddStatic(hmenu, qcm.idCmdFirst, qcm.idCmdLast, _hkeyClsKeys[0]);
        }
        _idDelayInvokeMax = qcm.idCmdFirst - idCmdFirst;

        // Remove the separator if we did not add any.
        if (_idDelayInvokeMax == _idFolderMax)
        {
            if (GetMenuState(hmenu, 0, MF_BYPOSITION) & MF_SEPARATOR)
                DeleteMenu(hmenu, 0, MF_BYPOSITION);
        }
    }

    // if no default menu got set, choose the first one.
    if (_pdtobj && !(uFlags & CMF_NODEFAULT) &&
        GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1)
    {
        _SetMenuDefault(hmenu, idCmdFirst, qcm.idCmdFirst);
    }

    // And now we give the callback the option to put (more) commands on top
    // of everything else
    if (_pcmcb)
        _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU_TOP, uFlags, (LPARAM)&qcm);

    _idFld2Max = qcm.idCmdFirst - idCmdFirst;

    SHPrettyMenuForDefcm(hmenu, uFlags, idCmdFirst, idCmdLast, hrPrepare);

    _UnduplicateVerbs(hmenu, idCmdFirst, qcm.idCmdFirst);
    
    ResetWaitCursor();

    return ResultFromShort(_idFld2Max);
}

HRESULT CDefFolderMenu::_GetMenuVerb(HMENU hmenu, int idFirst, int idMax, int item, LPWSTR psz, DWORD cch)
{
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    *psz = 0;
    if (GetMenuItemInfo(hmenu, item, TRUE, &mii)
    && ((int)mii.wID >= idFirst && (int)mii.wID < idMax))
    {
        if (mii.fType & MFT_SEPARATOR)
            return S_FALSE;
        else
            return GetCommandString(mii.wID - idFirst, GCS_VERBW, NULL, (LPSTR)psz, cch);
    }
    return E_FAIL;
}

void CDefFolderMenu::_UnduplicateVerbs(HMENU hmenu, int idFirst, int idMax)
{
    HRESULT hr = S_OK;
    int iDefault = GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0);
    for (int i = 0; i < GetMenuItemCount(hmenu); i++)
    {
        WCHAR szi[CCH_KEYMAX];
        hr = _GetMenuVerb(hmenu, idFirst, idMax, i, szi, ARRAYSIZE(szi));
        if (hr == S_OK && *szi)
        {
            for (int j = i + 1; j < GetMenuItemCount(hmenu); j++)
            {
                WCHAR szj[CCH_KEYMAX];
                hr = _GetMenuVerb(hmenu, idFirst, idMax, j, szj, ARRAYSIZE(szj));
                if (hr == S_OK && *szj)
                {
                    if (0 == StrCmpIW(szj, szi))
                    {
                        if (j != iDefault)
                        {
                            DeleteMenu(hmenu, j, MF_BYPOSITION);
                            j--;
                        }
                    }
                }
            }
        }
    }
}

HRESULT CDefFolderMenu::_ProcessEditPaste(BOOL fPasteLink)
{
    DECLAREWAITCURSOR;

    SetWaitCursor();

    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        IDataObject *pdtobj;
        hr = OleGetClipboard(&pdtobj);
        if (SUCCEEDED(hr))
        {
            DWORD grfKeyState;
            DWORD dwEffect = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY | DROPEFFECT_LINK);

            if (fPasteLink) 
            {
                // MK_FAKEDROP to avoid drag/drop pop up menu
                grfKeyState = MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_FAKEDROP;
                dwEffect &= DROPEFFECT_LINK;
            } 
            else
            {
                grfKeyState = MK_LBUTTON;
                dwEffect &= ~DROPEFFECT_LINK;
            }

            hr = SimulateDropWithPasteSucceeded(_pdtgt, pdtobj, grfKeyState, NULL, dwEffect, _psss, TRUE);

            pdtobj->Release();
        }
    }
    ResetWaitCursor();

    if (FAILED(hr))
        MessageBeep(0);

    return hr;
}

HRESULT CDefFolderMenu::_ProcessRename()
{
    IDefViewFrame3 *dvf3;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_DefView, IID_PPV_ARG(IDefViewFrame3, &dvf3));
    if (SUCCEEDED(hr))
    {
        hr = dvf3->DoRename();
        dvf3->Release();
    }
    return hr;
}

// deal with the versioning of this structure...

void CopyInvokeInfo(CMINVOKECOMMANDINFOEX *pici, const CMINVOKECOMMANDINFO *piciIn)
{
    ASSERT(piciIn->cbSize >= sizeof(*piciIn));

    ZeroMemory(pici, sizeof(*pici));
    memcpy(pici, piciIn, min(sizeof(*pici), piciIn->cbSize));
    pici->cbSize = sizeof(*pici);
}

#ifdef UNICODE        
#define IS_UNICODE_ICI(pici) ((pici->cbSize >= CMICEXSIZE_NT4) && ((pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE))
#else
#define IS_UNICODE_ICI(pici) (FALSE)
#endif

typedef int (WINAPI * PFN_LSTRCMPIW)(LPCWSTR, LPCWSTR);
HRESULT SHMapICIVerbToCmdID(LPCMINVOKECOMMANDINFO pici, const ICIVERBTOIDMAP* pmap, UINT cmap, UINT* pid)
{
    HRESULT hr = E_FAIL;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        PFN_LSTRCMPIW pfnCompare;
        LPCWSTR pszVerb;
        BOOL fUnicode;

        if (IS_UNICODE_ICI(pici) && ((LPCMINVOKECOMMANDINFOEX)pici)->lpVerbW)
        {
            pszVerb = ((LPCMINVOKECOMMANDINFOEX)pici)->lpVerbW;
            pfnCompare = lstrcmpiW;
            fUnicode = TRUE;
        }
        else
        {
            pszVerb = (LPCWSTR)(pici->lpVerb);
            pfnCompare = (PFN_LSTRCMPIW)lstrcmpiA;
            fUnicode = FALSE;
        }
            
        for (UINT i = 0; i < cmap ; i++)
        {
            LPCWSTR pszCompare = (fUnicode) ? pmap[i].pszCmd : (LPCWSTR)(pmap[i].pszCmdA);
            if (!pfnCompare(pszVerb, pszCompare))
            {
                *pid = pmap[i].idDFMCmd;
                hr = S_OK;
                break;
            }
        }
    }
    else
    {
        *pid = LOWORD((UINT_PTR)pici->lpVerb);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT SHMapCmdIDToVerb(UINT_PTR idCmd, const ICIVERBTOIDMAP* pmap, UINT cmap, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    LPCWSTR pszNull = L"";
    LPCSTR pszVerb = (LPCSTR)pszNull;

    for (UINT i = 0 ; i < cmap ; i++)
    {
        if (pmap[i].idDefCmd == idCmd)
        {
            pszVerb = (bUnicode) ? (LPCSTR)pmap[i].pszCmd : pmap[i].pszCmdA;
            break;
        }
    }

    if (bUnicode)
        StrCpyNW((LPWSTR)pszName, (LPWSTR)pszVerb, cchMax);
    else
        StrCpyNA(pszName, pszVerb, cchMax);

    return (pszVerb == (LPCSTR)pszNull) ? E_NOTIMPL : S_OK;
}


STDMETHODIMP CDefFolderMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;
    UINT idCmd = (UINT)-1;
    UINT idCmdLocal;  // this is used within each if block for the local idCmd value
    LPCMINVOKECOMMANDINFOEX picix = (LPCMINVOKECOMMANDINFOEX)pici; // This value is only usable when fCmdInfoEx is true

    BOOL fUnicode = IS_UNICODE_ICI(pici);

    if (pici->cbSize < sizeof(CMINVOKECOMMANDINFO))
        return E_INVALIDARG;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        if (SUCCEEDED(SHMapICIVerbToCmdID(pici, c_sDFMCmdInfo, ARRAYSIZE(c_sDFMCmdInfo), &idCmdLocal)))
        {
            // We need to use goto because idFolderMax might not be initialized
            // yet (QueryContextMenu might have not been called).
            goto ProcessCommand;
        }

        // see if this is a command provided by name by the callback
        LPCTSTR pszVerb;
        WCHAR szVerb[MAX_PATH];
        if (!fUnicode || picix->lpVerbW == NULL)
        {
            SHAnsiToUnicode(picix->lpVerb, szVerb, ARRAYSIZE(szVerb));
            pszVerb = szVerb;
        }
        else
            pszVerb = picix->lpVerbW;
        idCmdLocal = idCmd;

        if (*pszVerb && SUCCEEDED(_pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MAPCOMMANDNAME, (WPARAM)&idCmdLocal, (LPARAM)pszVerb)))
        {
            goto ProcessCommand;
        }

        // we need to give the verbs a chance in case they asked for it by string
        goto ProcessVerb;
    }
    else
    {
        idCmd = LOWORD((UINT_PTR)pici->lpVerb);
    }

    if (idCmd < _idStdMax)
    {
        idCmdLocal = idCmd;

        for (int i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (idCmdLocal == c_sDFMCmdInfo[i].idDefCmd)
            {
                idCmdLocal = c_sDFMCmdInfo[i].idDFMCmd;
                goto ProcessCommand;
            }
        }

        hr = E_INVALIDARG;
    }
    else if (idCmd < _idFolderMax)
    {
        DFMICS dfmics;
        LPARAM lParam;
        WCHAR szLParamBuffer[MAX_PATH];

        idCmdLocal = idCmd - _idStdMax;
ProcessCommand:

        if (!fUnicode || picix->lpParametersW == NULL)
        {
            if (pici->lpParameters == NULL)
            {
                lParam = (LPARAM)NULL;
            }
            else
            {
                SHAnsiToUnicode(pici->lpParameters, szLParamBuffer, ARRAYSIZE(szLParamBuffer));
                lParam = (LPARAM)szLParamBuffer;
            }
        }
        else
            lParam = (LPARAM)picix->lpParametersW;

        switch (idCmdLocal) 
        {
        case DFM_CMD_LINK:
            if (!fUnicode || picix->lpDirectoryW == NULL)
            {
                if (pici->lpDirectory == NULL)
                {
                    lParam = (LPARAM)NULL;
                }
                else
                {
                    SHAnsiToUnicode(pici->lpDirectory, szLParamBuffer, ARRAYSIZE(szLParamBuffer));
                    lParam = (LPARAM)szLParamBuffer;
                }
            }
            else
                lParam = (LPARAM)picix->lpDirectoryW;
            break;

        case DFM_CMD_PROPERTIES:
             if (SHRestricted(REST_NOVIEWCONTEXTMENU))
             {
                // This is what the NT4 QFE returned, but I wonder
                // if HRESULT_FROM_WIN32(E_ACCESSDENIED) would be better?
                return hr;
             }
             break;
        }

        // try to use a DFM_INVOKECOMMANDEX first so the callback can see
        // the INVOKECOMMANDINFO struct (for stuff like the 'no ui' flag)
        dfmics.cbSize = sizeof(dfmics);
        dfmics.fMask = pici->fMask;
        dfmics.lParam = lParam;
        dfmics.idCmdFirst = _idCmdFirst;
        dfmics.idDefMax = _idStdMax;
        dfmics.pici = pici;

        // this for the property pages to show up right at
        // the POINT where they were activated. 
        if ((idCmdLocal == DFM_CMD_PROPERTIES) && (pici->fMask & CMIC_MASK_PTINVOKE) && _pdtobj)
        {
            ASSERT(pici->cbSize >= sizeof(CMINVOKECOMMANDINFOEX));
            POINT *ppt = (POINT *)GlobalAlloc(GPTR, sizeof(*ppt));
            if (ppt)
            {
                *ppt = picix->ptInvoke;
                if (FAILED(DataObj_SetGlobal(_pdtobj, g_cfOFFSETS, ppt)))
                    GlobalFree(ppt);
            }
        }

        hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_INVOKECOMMANDEX, idCmdLocal, (LPARAM)&dfmics);
        if (hr == E_NOTIMPL)
        {
            // the callback didn't understand the DFM_INVOKECOMMANDEX
            // fall back to a regular DFM_INVOKECOMMAND instead
            hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_INVOKECOMMAND, idCmdLocal, lParam);
        }

        // Check if we need to execute the default code.
        if (hr == S_FALSE)
        {
            hr = S_OK;     // assume no error

            if (_pdtobj)
            {
                switch (idCmdLocal) 
                {
                case DFM_CMD_MOVE:
                case DFM_CMD_COPY:
                    DataObj_SetDWORD(_pdtobj, g_cfPreferredDropEffect, 
                        (idCmdLocal == DFM_CMD_MOVE) ?
                        DROPEFFECT_MOVE : (DROPEFFECT_COPY | DROPEFFECT_LINK));

                    IShellFolderView *psfv;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
                        psfv->SetPoints(_pdtobj);

                    OleSetClipboard(_pdtobj);

                    if (psfv)
                    {
                        // notify view so it can setup itself in the
                        // clipboard viewer chain
                        psfv->SetClipboard(DFM_CMD_MOVE == idCmdLocal);
                        psfv->Release();
                    }
                    break;

                case DFM_CMD_LINK:
                    SHCreateLinks(pici->hwnd, NULL, _pdtobj, lParam ? SHCL_USETEMPLATE | SHCL_USEDESKTOP : SHCL_USETEMPLATE, NULL);
                    break;

                case DFM_CMD_PASTE:
                case DFM_CMD_PASTELINK:
                    hr = _ProcessEditPaste(idCmdLocal == DFM_CMD_PASTELINK);
                    break;

                case DFM_CMD_RENAME:
                    hr = _ProcessRename();
                    break;

                default:
                    DebugMsg(TF_WARNING, TEXT("DefCM item command not processed in %s at %d (%x)"),
                                    __FILE__, __LINE__, idCmdLocal);
                    break;
                }
            }
            else
            {
                // This is a background menu. Process common command ids.
                switch(idCmdLocal)
                {
                case DFM_CMD_PASTE:
                case DFM_CMD_PASTELINK:
                    hr = _ProcessEditPaste(idCmdLocal == DFM_CMD_PASTELINK);
                    break;

                default:
                    // Only our commands should come here
                    DebugMsg(TF_WARNING, TEXT("DefCM background command not processed in %s at %d (%x)"),
                                    __FILE__, __LINE__, idCmdLocal);
                    break;
                }
            }
        }
    }
    else if (idCmd < _idVerbMax)
    {
        idCmdLocal = idCmd - _idFolderMax;
ProcessVerb:
        {
            CMINVOKECOMMANDINFOEX ici;
            UINT_PTR idCmdSave;

            CopyInvokeInfo(&ici, pici);

            if (IS_INTRESOURCE(pici->lpVerb))
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmdLocal);

            // One of extension menu is selected.
            idCmdSave = (UINT_PTR)ici.lpVerb;
            UINT_PTR idCmd = 0;

            hr = HDXA_LetHandlerProcessCommandEx(_hdxa, &ici, &idCmd);
            if (SUCCEEDED(hr) && (idCmd == idCmdSave))
            {
                // hdxa failed to handle it
                hr = E_INVALIDARG;
            }
        }
    }
    else if (idCmd < _idDelayInvokeMax)
    {
        _InvokeStatic((UINT)(idCmd-_idVerbMax));
    }
    else if (idCmd < _idFld2Max)
    {
        idCmdLocal = idCmd - _idDelayInvokeMax;
        goto ProcessCommand;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_INVALIDARG;
    UINT_PTR idCmdLocal;
    int i;

    if (!IS_INTRESOURCE(idCmd))
    {
        // This must be a string

        if (HDXA_GetCommandString(_hdxa, idCmd, uType, pwReserved, pszName, cchMax) == S_OK)
        {
            return S_OK;
        }

        // String can either be Ansi or Unicode. Since shell32 is built unicode, we need to compare 
        // idCmd against the ansi version of the verb string.
        LPTSTR pCmd;
        LPSTR  pCmdA;
        pCmd = (LPTSTR)idCmd;
        pCmdA = (LPSTR)idCmd;

        // Convert the string into an ID
        for (i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (!lstrcmpi(pCmd, c_sDFMCmdInfo[i].pszCmd) || !StrCmpIA(pCmdA, c_sDFMCmdInfo[i].pszCmdA))
            {
                idCmdLocal = (UINT) c_sDFMCmdInfo[i].idDFMCmd;
                goto ProcessCommand;
            }
        }
        return E_INVALIDARG;
    }

    if (idCmd < _idStdMax)
    {
        idCmdLocal = idCmd;

        switch (uType)
        {
        case GCS_HELPTEXTA:
            // HACK: DCM commands are in the same order as SFV commands
            return(LoadStringA(HINST_THISDLL,
                (UINT) idCmdLocal + (UINT)(SFVIDM_FIRST + SFVIDS_MH_FIRST),
                (LPSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY);
            break;

        case GCS_HELPTEXTW:
            // HACK: DCM commands are in the same order as SFV commands
            return(LoadStringW(HINST_THISDLL,
                (UINT) idCmdLocal + (UINT)(SFVIDM_FIRST + SFVIDS_MH_FIRST),
                (LPWSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY);
            break;

        case GCS_VERBA:
        case GCS_VERBW:
            return SHMapCmdIDToVerb(idCmdLocal, c_sDFMCmdInfo, ARRAYSIZE(c_sDFMCmdInfo), pszName, cchMax, uType == GCS_VERBW);

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            
        default:
            return E_NOTIMPL;
        }
    } 
    else if (idCmd < _idFolderMax)
    {
        idCmdLocal = idCmd - _idStdMax;
ProcessCommand:
        if (!_pcmcb)
            return E_NOTIMPL;   // REVIEW: If no callback, how can idFolderMax be > 0?

        // This is a folder menu
        switch (uType)
        {
        case GCS_HELPTEXTA:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_GETHELPTEXT,
                      (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_HELPTEXTW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_GETHELPTEXTW,
                      (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_VALIDATECMD, idCmdLocal, 0);

        case GCS_VERBA:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_GETVERBA, (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_VERBW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_GETVERBW, (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        default:
            return E_NOTIMPL;
        }
    }
    else if (idCmd < _idVerbMax)
    {
        idCmdLocal = idCmd - _idFolderMax;
        // One of extension menu is selected.
        hr = HDXA_GetCommandString(_hdxa, idCmdLocal, uType, pwReserved, pszName, cchMax);
    }
    else if (idCmd < _idDelayInvokeMax)
    {
        // menu extensions that are loaded at invoke time don't support this
    }
    else if (idCmd < _idFld2Max)
    {
        idCmdLocal = idCmd - _idDelayInvokeMax;
        goto ProcessCommand;
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam,LRESULT* plResult)
{
    UINT uMsgFld;
    WPARAM wParamFld;       // map the folder call back params to these
    LPARAM lParamFld;
    UINT idCmd;
    UINT id; //temp var

    switch (uMsg) {
    case WM_MEASUREITEM:
        idCmd = GET_WM_COMMAND_ID(((MEASUREITEMSTRUCT *)lParam)->itemID, 0);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if ((_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)        
        {
            _MeasureItem((MEASUREITEMSTRUCT *)lParam);
            return S_OK;
        }
        
        uMsgFld = DFM_WM_MEASUREITEM;
        wParamFld = GetFldFirst(this);
        lParamFld = lParam;
        break;

    case WM_DRAWITEM:
        idCmd = GET_WM_COMMAND_ID(((LPDRAWITEMSTRUCT)lParam)->itemID, 0);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if ((_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)
        {
            _DrawItem((LPDRAWITEMSTRUCT)lParam);
            return S_OK;
        }

        uMsgFld = DFM_WM_DRAWITEM;
        wParamFld = GetFldFirst(this);
        lParamFld = lParam;
        break;

    case WM_INITMENUPOPUP:
        idCmd = GetMenuItemID((HMENU)wParam, 0);
        if (_uFlags & CMF_FINDHACK)
        {
            HMENU hmenu = (HMENU)wParam;
            int cItems = GetMenuItemCount(hmenu);
            
            _bInitMenuPopup = TRUE;
            if (!_hdsaCustomInfo)
                _hdsaCustomInfo = DSA_Create(sizeof(SEARCHINFO), 1);

            if (_hdsaCustomInfo && cItems > 0)
            {
                // need to go bottom up because we may delete some items
                for (int i = cItems - 1; i >= 0; i--)
                {
                    MENUITEMINFO mii = {0};
                    TCHAR szMenuText[MAX_PATH];

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID;
                    mii.dwTypeData = szMenuText;
                    mii.cch = ARRAYSIZE(szMenuText);
                    
                    if (GetMenuItemInfo(hmenu, i, TRUE, &mii) && (MFT_STRING == mii.fType))
                    {
                        SEARCHINFO sinfo;
                        // static items already have correct dwItemData (pointer to SEARCHEXTDATA added in _AddStatic)
                        // we now have to change other find extension's dwItemData from having an index into the icon
                        // cache to pointer to SEARCHEXTDATA
                        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
                        id = mii.wID - _idCmdFirst;
                        if (!(_hdsaStatics && _idVerbMax <= id && id < _idDelayInvokeMax))
                        {
                            UINT iIcon = (UINT) mii.dwItemData;
                            SEARCHEXTDATA *psed = (SEARCHEXTDATA *)LocalAlloc(LPTR, sizeof(*psed));
                            if (psed)
                            {
                                psed->iIcon = iIcon;
                                SHTCharToUnicode(szMenuText, psed->wszMenuText, ARRAYSIZE(psed->wszMenuText));
                            }
                            mii.fMask = MIIM_DATA | MIIM_TYPE;
                            mii.fType = MFT_OWNERDRAW;
                            mii.dwItemData = (DWORD_PTR)psed;

                            sinfo.psed = psed;
                            sinfo.idCmd = mii.wID;
                            if (DSA_AppendItem(_hdsaCustomInfo, &sinfo) == -1)
                            {
                                DeleteMenu(hmenu, i, MF_BYPOSITION);
                                if (psed)
                                    LocalFree(psed);
                            }
                            else
                                SetMenuItemInfo(hmenu, i, TRUE, &mii);
                        }
                    }
                }
            }
            else if (!_hdsaCustomInfo)
            {
                // we could not allocate space for _hdsaCustomInfo
                // delete all items because there will be no pointer hanging off dwItemData
                // so start | search will fault
                for (int i = 0; i < cItems; i++)
                    DeleteMenu(hmenu, i, MF_BYPOSITION);
            }
        }
        
        uMsgFld = DFM_WM_INITMENUPOPUP;
        wParamFld = wParam;
        lParamFld = GetFldFirst(this);
        break;

    case WM_MENUSELECT:
        idCmd = (UINT) LOWORD(wParam);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if (_punkSite && (_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)
        {
            IShellBrowser *psb;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_DATA;
                mii.cch = 0; //just in case
                if (GetMenuItemInfo(_hmenu, idCmd, FALSE, &mii))
                {
                    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)mii.dwItemData;
                    psb->SetStatusTextSB(psed->wszHelpText);
                }
                psb->Release();
            }
        }
        return S_OK;
        
      
    case WM_MENUCHAR:
        if ((_uFlags & CMF_FINDHACK) && _hdsaCustomInfo)
        {
            int cItems = DSA_GetItemCount(_hdsaCustomInfo);
            
            for (int i = 0; i < cItems; i++)
            {
                SEARCHINFO* psinfo = (SEARCHINFO*)DSA_GetItemPtr(_hdsaCustomInfo, i);
                ASSERT(psinfo);
                SEARCHEXTDATA* psed = psinfo->psed;
                
                if (psed)
                {
                    TCHAR szMenu[MAX_PATH];
                    SHUnicodeToTChar(psed->wszMenuText, szMenu, ARRAYSIZE(szMenu));
                
                    if (_MenuCharMatch(szMenu, (TCHAR)LOWORD(wParam), FALSE))
                    {
                        if (plResult) 
                            *plResult = MAKELONG(GetMenuPosFromID((HMENU)lParam, psinfo->idCmd), MNC_EXECUTE);
                        return S_OK;
                    }                            
                }
            }
            if (plResult) 
                *plResult = MAKELONG(0, MNC_IGNORE);
                
            return S_FALSE;
        }
        else
        {
            // TODO: this should probably get the idCmd of the MFS_HILITE item so we forward to the correct hdxa...
            idCmd = GetMenuItemID((HMENU)lParam, 0);
        }
        break;
        
    default:
        return E_FAIL;
    }

    // bias this down to the extension range (comes right after the folder range)

    idCmd -= _idCmdFirst + _idFolderMax;

    // Only forward along on IContextMenu3 as some shell extensions say they support
    // IContextMenu2, but fail and bring down the shell...
    IContextMenu3 *pcmItem;
    if (SUCCEEDED(HDXA_FindByCommand(_hdxa, idCmd, IID_PPV_ARG(IContextMenu3, &pcmItem))))
    {
        HRESULT hr = pcmItem->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
        pcmItem->Release();
        return hr;
    }

    // redirect to the folder callback
    if (_pcmcb)
        return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, uMsgFld, wParamFld, lParamFld);

    return E_FAIL;
}

STDMETHODIMP CDefFolderMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

STDMETHODIMP CDefFolderMenu::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_CtxQueryAssociations))
    {
        if (_paa)
            return _paa->QueryInterface(riid, ppvObj);
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    else
        return IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
}

STDMETHODIMP CDefFolderMenu::GetSearchGUID(GUID *pGuid)
{
    HRESULT hr = E_FAIL;
    
    if (_iStaticInvoked != -1)
    {
        STATICITEMINFO *psii = (STATICITEMINFO *)DSA_GetItemPtr(_hdsaStatics, _iStaticInvoked);
        if (psii)
        {
            *pGuid = psii->guidSearch;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);    // just grab this guy

    for (int i = 0; i < DSA_GetItemCount(_hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(_hdxa, i);
        IShellExtInit *psei;
        if (SUCCEEDED(pcmi->pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
        {
            psei->Initialize(pidlFolder, pdtobj, hkeyProgID);
            psei->Release();
        }
    }
    return S_OK;
}


//=============================================================================
// HDXA stuff
//=============================================================================
//
//  This function enumerate all the context menu handlers and let them
// append menuitems. Each context menu handler will create an object
// which support IContextMenu interface. We call QueryContextMenu()
// member function of all those IContextMenu object to let them append
// menuitems. For each IContextMenu object, we create ContextMenuInfo
// struct and append it to hdxa (which is a dynamic array of ContextMenuInfo).
//
//  The caller will release all those IContextMenu objects, by calling
// its Release() member function.
//
// Arguments:
//  hdxa            -- Handler of the dynamic ContextMenuInfo struct array
//  pdata           -- Specifies the selected items (files)
//  hkeyShellEx     -- Specifies the reg.dat class we should enumurate handlers
//  hkeyProgID      -- Specifies the program identifier of the selected file/directory
//  pszHandlerKey   -- Specifies the reg.dat key to the handler list
//  pidlFolder      -- Specifies the folder (drop target)
//  hmenu           -- Specifies the menu to be modified
//  uInsert         -- Specifies the position to be insert menuitems
//  idCmdFirst      -- Specifies the first menuitem ID to be used
//  idCmdLast       -- Specifies the last menuitem ID to be used
//
// Returns:
//  The first menuitem ID which is not used.
//
// History:
//  02-25-93 SatoNa     Created
//
//  06-30-97 lAmadio    Modified to add ID mapping support.

UINT HDXA_AppendMenuItems(HDXA hdxa, IDataObject *pdtobj,
                          UINT nKeys, HKEY *ahkeys, LPCITEMIDLIST pidlFolder,
                          HMENU hmenu, UINT uInsert, UINT idCmdFirst, UINT idCmdLast,
                          UINT fFlags, HDCA hdca)
{
    QCMINFO qcm = {hmenu, uInsert, idCmdFirst, idCmdLast, NULL};
    return HDXA_AppendMenuItems2(hdxa, pdtobj, nKeys, ahkeys, pidlFolder, &qcm, fFlags, hdca, NULL);
}

UINT HDXA_AppendMenuItems2(HDXA hdxa, IDataObject *pdtobj,
                           UINT nKeys, HKEY *ahkeys, LPCITEMIDLIST pidlFolder,
                           QCMINFO* pqcm, UINT fFlags, HDCA hdca, IUnknown* pSite)
{
    const UINT idCmdBase = pqcm->idCmdFirst;
    UINT idCmdFirst = pqcm->idCmdFirst;

    // Apparently, somebody has already called into here with this object.  We
    // need to keep the ID ranges separate, so we'll put the new ones at the
    // end.
    // If QueryContextMenu is called too many times, we will run out of
    // ID range and not add anything.  We could try storing the information
    // used to create each pcm (HKEY, GUID, and fFlags) and reuse some of them,
    // but then we would have to worry about what if the number of commands
    // grows and other details; this is just not worth the effort since
    // probably nobody will ever have a problem.  The rule of thumb is to
    // create an IContextMenu, do the QueryContextMenu and InvokeCommand, and
    // then Release it.
    int idca = DSA_GetItemCount(hdxa);
    if (idca > 0)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, idca-1);
        idCmdFirst += pcmi->idCmdMax;
    }

    // Note that we need to reverse the order because each extension
    // will insert menuitems "above" uInsert.
    UINT uInsertOffset = 0;
    for (idca = DCA_GetItemCount(hdca) - 1; idca >= 0; idca--)
    {
        TCHAR szCLSID[GUIDSTR_MAX];
        TCHAR szRegKey[GUIDSTR_MAX + 40];

        CLSID clsid = *DCA_GetItem(hdca, idca);
        SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

        // avoid creating an instance (loading the DLL) when:
        //  1. fFlags has CMF_DEFAULTONLY and
        //  2. CLSID\clsid\MayChangeDefault does not exist

        if ((fFlags & CMF_DEFAULTONLY) && (clsid != CLSID_ShellFileDefExt))
        {
            wsprintf(szRegKey, TEXT("CLSID\\%s\\shellex\\MayChangeDefaultMenu"), szCLSID);

            if (SHRegQueryValue(HKEY_CLASSES_ROOT, szRegKey, NULL, NULL) != ERROR_SUCCESS)
            {
                DebugMsg(TF_MENU, TEXT("HDXA_AppendMenuItems skipping %s"), szCLSID);
                continue;
            }
        }

        IShellExtInit *psei = NULL;
        IContextMenu *pcm = NULL;

        // Try all the class keys in order
        for (UINT nCurKey = 0; nCurKey < nKeys; nCurKey++)
        {
            // These cam from HKCR so need to go through administrator approval
            if (!psei && FAILED(DCA_ExtCreateInstance(hdca, idca, IID_PPV_ARG(IShellExtInit, &psei))))
                break;

            if (FAILED(psei->Initialize(pidlFolder, pdtobj, ahkeys[nCurKey])))
                continue;

            // Only get the pcm after initializing
            if (!pcm && FAILED(psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm))))
                continue;
            
            wsprintf(szRegKey, TEXT("CLSID\\%s"), szCLSID);

            // Webvw needs the site in order to do its QueryContextMenu
            ContextMenuInfo cmi;
            cmi.pcm = pcm;
            cmi.dwCompat = SHGetObjectCompatFlags(NULL, &clsid);
            ContextMenuInfo_SetSite(&cmi, pSite);

            HRESULT hr;
            int cMenuItemsLast = GetMenuItemCount(pqcm->hmenu);
            DWORD dwExtType, dwType, dwSize = sizeof(dwExtType);
            if (SHGetValue(HKEY_CLASSES_ROOT, szRegKey, TEXT("flags"), &dwType, (BYTE*)&dwExtType, &dwSize) == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                (NULL != pqcm->pIdMap) &&
                dwExtType < pqcm->pIdMap->nMaxIds)
            {
                //Explanation:
                //Here we are trying to add a context menu extension to an already 
                //existing menu, owned by the sister object of DefView. We used the callback
                //to get a list of extension "types" and their place within the menu, relative
                //to IDs that the sister object inserted already. That object also told us 
                //where to put extensions, before or after the ID. Since they are IDs and not
                //positions, we have to convert using GetMenuPosFromID.
                hr = pcm->QueryContextMenu(
                    pqcm->hmenu, 
                    GetMenuPosFromID(pqcm->hmenu, pqcm->pIdMap->pIdList[dwExtType].id) +
                    ((pqcm->pIdMap->pIdList[dwExtType].fFlags & QCMINFO_PLACE_AFTER) ? 1 : 0),  
                    idCmdFirst, 
                    pqcm->idCmdLast, fFlags);
            }
            else
                hr = pcm->QueryContextMenu(pqcm->hmenu, pqcm->indexMenu + uInsertOffset, idCmdFirst, pqcm->idCmdLast, fFlags);

            UINT citems = HRESULT_CODE(hr);

            if (SUCCEEDED(hr) && citems)
            {
                cmi.idCmdFirst = idCmdFirst - idCmdBase;
                cmi.idCmdMax = cmi.idCmdFirst + citems;
                cmi.clsid = clsid;    // for debugging

                if (DSA_AppendItem(hdxa, &cmi) == -1)
                {
                    // There is no "clean" way to remove menu items, so
                    // we should check the add to the DSA before adding the
                    // menu items
                    DebugMsg(DM_ERROR, TEXT("filemenu.c ERROR: DSA_GetItemPtr failed (memory overflow)"));
                }
                else
                {
                    pcm->AddRef();
                }
                idCmdFirst += citems;

                FullDebugMsg(TF_MENU, TEXT("HDXA_Append: %d, %d"), idCmdFirst, citems);

                // keep going if it is our internal handler
                if (clsid == CLSID_ShellFileDefExt)
                {
                    //
                    //  for static registry verbs, make sure that 
                    //  they are added in priority of their specificity.
                    //
                    //  the first key needs its verbs at the top 
                    //  unless it is not the default handler.
                    //  so if the default hasnt been set,
                    //  then we dont push down the insert position.
                    //  
                    //  like "Directory" is more specific than "Folder" 
                    //  but the default verb is on "Folder".  so "Directory"
                    //  wont set the default verb, but "Folder" will.
                    //
                    if (-1 != GetMenuDefaultItem(pqcm->hmenu, TRUE, 0))
                    {
                        //  a default has been set, so each subsequent 
                        //  key is less important.
                        uInsertOffset += GetMenuItemCount(pqcm->hmenu) - cMenuItemsLast;
                    }
                }
                else
                {
                    //  try to bubble up the default to the top if possible,
                    //  since some apps just invoke the 0th index on the menu
                    //  instead of querying the menu for the default
                    if (0 == uInsertOffset && (0 == GetMenuDefaultItem(pqcm->hmenu, TRUE, 0)))
                        uInsertOffset++;

                    //  only CLSID_ShellFileDefExt gets a shot
                    //  at every key.  the rest are assumed
                    //  to do most of their work from the IDataObject
                    break;
                }

                pcm->Release();
                pcm = NULL;

                psei->Release();
                psei = NULL;

                continue;       // next hkey
            }
        }

        if (pcm)
            pcm->Release();

        if (psei)
            psei->Release();
    }

    return idCmdFirst;
}

//  This function is called after the user select one of add-in menu items.
// This function calls IncokeCommand method of corresponding context menu
// object.
//
//  hdxa            -- Handler of the dynamic ContextMenuInfo struct array
//  idCmd           -- Specifies the menu item ID
//  hwndParent      -- Specifies the parent window.
//  pszWorkingDir   -- Specifies the working directory.
//
// Returns:
//  IDCMD_PROCESSED, if InvokeCommand method is called; idCmd, otherwise

HRESULT HDXA_LetHandlerProcessCommandEx(HDXA hdxa, LPCMINVOKECOMMANDINFOEX pici, UINT_PTR * pidCmd)
{
    HRESULT hr = S_OK;
    UINT_PTR idCmd;

    if (!pidCmd)
        pidCmd = &idCmd;
        
    *pidCmd = (UINT_PTR)pici->lpVerb;

    // try handlers in order, the first to take it wins
    for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);
        if (!IS_INTRESOURCE(pici->lpVerb))
        {
            // invoke by cannonical name case

            // app compat: some ctx menu extension always succeed regardless
            // if it is theirs or not.  better to never pass them a string
            if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_NOVERBS))
            {
                hr = pcmi->pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)pici);
                if (SUCCEEDED(hr))
                {
                    *pidCmd = IDCMD_PROCESSED;
                    break;
                }
            }
            else
                hr = E_FAIL;
        }
        else if ((*pidCmd >= pcmi->idCmdFirst) && (*pidCmd < pcmi->idCmdMax))
        {
            CMINVOKECOMMANDINFOEX ici;
            CopyInvokeInfo(&ici, (CMINVOKECOMMANDINFO *)pici);
            ici.lpVerb = (LPSTR)MAKEINTRESOURCE(*pidCmd - pcmi->idCmdFirst);

            hr = pcmi->pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
            if (SUCCEEDED(hr))
            {
                *pidCmd = IDCMD_PROCESSED;
            }
            break;
        }
    }

    // It's OK if (idCmd != IDCMD_PROCESSED) because some callers will try to use several
    // IContextMenu implementations in order to get the IContextMenu for the selected items,
    // the IContextMenu for the background, etc.  CBackgrndMenu::InvokeCommand() does this.
    // -BryanSt (04/29/1999)
    return hr;
}


HRESULT HDXA_GetCommandString(HDXA hdxa, UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_INVALIDARG;
    LPTSTR pCmd = (LPTSTR)idCmd;

    if (!hdxa)
        return E_INVALIDARG;

    //
    // One of add-in menuitems is selected. Let the context
    // menu handler process it.
    //
    for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);

        if (!IS_INTRESOURCE(idCmd))
        {
            // This must be a string command; see if this handler wants it
            if (pcmi->pcm->GetCommandString(idCmd, uType,
                                            pwReserved, pszName, cchMax) == S_OK)
            {
                return S_OK;
            }
        }
        //
        // Check if it is for this context menu handler.
        //
        // Notes: We can't use InRange macro because idCmdFirst might
        //  be equal to idCmdLast.
        // if (InRange(idCmd, pcmi->idCmdFirst, pcmi->idCmdMax-1))
        else if (idCmd >= pcmi->idCmdFirst && idCmd < pcmi->idCmdMax)
        {
            //
            // Yes, it is. Let it handle this menuitem.
            //
            hr = pcmi->pcm->GetCommandString(idCmd-pcmi->idCmdFirst, uType, pwReserved, pszName, cchMax);
            break;
        }
    }

    return hr;
}

HRESULT HDXA_FindByCommand(HDXA hdxa, UINT idCmd, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;    // bug nt power toy does not properly null out in error cases...

    if (hdxa)
    {
        for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
        {
            ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);

            if (idCmd >= pcmi->idCmdFirst && idCmd < pcmi->idCmdMax)
            {
                // APPCOMPAT: PGP50 can only be QIed for IContextMenu, IShellExtInit, and IUnknown.
                if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_LIMITEDQI))
                    hr = pcmi->pcm->QueryInterface(riid, ppv);
                else
                    hr = E_FAIL;
                break;
            }
        }
    }
    return hr;
}

//
// This function releases all the IContextMenu objects in the dynamic
// array of ContextMenuInfo,
//
void HDXA_DeleteAll(HDXA hdxa)
{
    if (hdxa)
    {
        //  Release all the IContextMenu objects, then destroy the DSA.
        for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
        {
            ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);
            if (pcmi->pcm)
            {
                pcmi->pcm->Release();
            }
        }
        DSA_DeleteAllItems(hdxa);
    }
}

// This function releases all the IContextMenu objects in the dynamic
// array of ContextMenuInfo, then destroys the dynamic array.

void HDXA_Destroy(HDXA hdxa)
{
    if (hdxa)
    {
        HDXA_DeleteAll(hdxa);
        DSA_Destroy(hdxa);
    }
}

class CContextMenuCBImpl : public IContextMenuCB 
{
public:
    CContextMenuCBImpl(LPFNDFMCALLBACK pfn) : _pfn(pfn), _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) 
    {
        static const QITAB qit[] = {
            QITABENT(CContextMenuCBImpl, IContextMenuCB), // IID_IContextMenuCB
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }

    STDMETHOD_(ULONG,AddRef)() 
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHOD_(ULONG,Release)() 
    {
        if (InterlockedDecrement(&_cRef)) 
            return _cRef;

        delete this;
        return 0;
    }

    // IContextMenuCB
    STDMETHOD(CallBack)(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return _pfn ? _pfn(psf, hwnd, pdtobj, uMsg, wParam, lParam) : E_FAIL;
    }

private:
    LONG _cRef;
    LPFNDFMCALLBACK _pfn;
};

STDAPI CreateDefaultContextMenu(DEFCONTEXTMENU *pdcm, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppcm = 0;
    CDefFolderMenu *pmenu = new CDefFolderMenu(FALSE);
    if (pmenu)
    {
        hr = pmenu->Init(pdcm);
        if (SUCCEEDED(hr))
            hr = pmenu->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        pmenu->Release();
    }
    return hr;
}    

STDAPI CDefFolderMenu_CreateHKeyMenu(HWND hwnd, HKEY hkey, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppcm = 0;
    CDefFolderMenu *pmenu = new CDefFolderMenu(TRUE);
    if (pmenu)
    {
        DEFCONTEXTMENU dcm = {0};
        dcm.hwnd = hwnd;
        dcm.aKeys = &hkey;
        dcm.cKeys = 1;
        hr = pmenu->Init(&dcm);
        if (SUCCEEDED(hr))
            hr = pmenu->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        pmenu->Release();
    }
    return hr;
}



STDAPI CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, IContextMenuCB *pcmcb, 
                                UINT nKeys, const HKEY *ahkeys, 
                                IContextMenu **ppcm)
{
    DEFCONTEXTMENU dcm = {
        hwnd,
        pcmcb,
        pidlFolder,
        psf,
        cidl,
        apidl,
        NULL,
        nKeys,
        ahkeys};

    return CreateDefaultContextMenu(&dcm, ppcm);
}

STDAPI CDefFolderMenu_CreateEx(LPCITEMIDLIST pidlFolder,
                               HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                               IShellFolder *psf, IContextMenuCB *pcmcb, 
                               HKEY hkeyProgID, HKEY hkeyBaseProgID,
                               IContextMenu **ppcm)
{
    HKEY aKeys[2] = { hkeyProgID, hkeyBaseProgID};
    DEFCONTEXTMENU dcm = {
        hwnd,
        pcmcb,
        pidlFolder,
        psf,
        cidl,
        apidl,
        NULL,
        2,
        aKeys};

    return CreateDefaultContextMenu(&dcm, ppcm);
}

//
// old style CDefFolderMenu_Create and CDefFolderMenu_Create2
//

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             IShellFolder *psf,
                             LPFNDFMCALLBACK pfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu **ppcm)
{
    HRESULT hr;
    IContextMenuCB *pcmcb = new CContextMenuCBImpl(pfn);
    if (pcmcb) 
    {
        HKEY aKeys[2] = { hkeyProgID, hkeyBaseProgID};
        DEFCONTEXTMENU dcm = {
            hwndOwner,
            pcmcb,
            pidlFolder,
            psf,
            cidl,
            apidl,
            NULL,
            2,
            aKeys};

        hr = CreateDefaultContextMenu(&dcm, ppcm);
        pcmcb->Release();
    }
    else
    {
        *ppcm = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CDefFolderMenu_Create2(LPCITEMIDLIST pidlFolder, HWND hwnd,
                             UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, LPFNDFMCALLBACK pfn,
                             UINT nKeys, const HKEY *ahkeys,
                             IContextMenu **ppcm)
{
    HRESULT hr;
    IContextMenuCB *pcmcb = new CContextMenuCBImpl(pfn);
    if (pcmcb) 
    {
        hr = CDefFolderMenu_Create2Ex(pidlFolder, hwnd, cidl, apidl, psf, pcmcb, 
                                      nKeys, ahkeys, ppcm);
        pcmcb->Release();
    }
    else
    {
        *ppcm = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#define CXIMAGEGAP      6

void DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR pszText, UINT iIcon)
{
    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        RECT rc;

        // Draw the image (if there is one).

        GetTextExtentPoint(pdi->hDC, pszText, lstrlen(pszText), &sz);
        
        if (pdi->itemState & ODS_SELECTED)
        {
            SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            FillRect(pdi->hDC,&pdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            SetTextColor(pdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(pdi->hDC,&pdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }
        
        rc = pdi->rcItem;
        rc.left += +2 * CXIMAGEGAP + g_cxSmIcon;
        
        DrawText(pdi->hDC,pszText,lstrlen(pszText), &rc, DT_SINGLELINE | DT_VCENTER);
        if (iIcon != -1)
        {
            x = pdi->rcItem.left + CXIMAGEGAP;
            y = (pdi->rcItem.bottom+pdi->rcItem.top-g_cySmIcon)/2;

            HIMAGELIST himlSmall;
            Shell_GetImageLists(NULL, &himlSmall);
            ImageList_Draw(himlSmall, iIcon, pdi->hDC, x, y, ILD_TRANSPARENT);
        } 
        else 
        {
            x = pdi->rcItem.left + CXIMAGEGAP;
            y = (pdi->rcItem.bottom+pdi->rcItem.top-g_cySmIcon)/2;
        }
    }
}

LRESULT MeasureMenuItem(MEASUREITEMSTRUCT *pmi, LPCTSTR pszText)
{
    LRESULT lres = FALSE;
            
    // Get the rough height of an item so we can work out when to break the
    // menu. User should really do this for us but that would be useful.
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        // REVIEW cache out the menu font?
        NONCLIENTMETRICS ncm;
        ncm.cbSize = sizeof(ncm);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
        {
            HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
            if (hfont)
            {
                SIZE sz;
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                GetTextExtentPoint(hdc, pszText, lstrlen(pszText), &sz);
                pmi->itemHeight = max (g_cySmIcon + CXIMAGEGAP / 2, ncm.iMenuHeight);
                pmi->itemWidth = g_cxSmIcon + 2 * CXIMAGEGAP + sz.cx;
                pmi->itemWidth = 2 * CXIMAGEGAP + sz.cx;
                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
                lres = TRUE;
            }
        }
        ReleaseDC(NULL, hdc);
    }   
    return lres;
}


void CDefFolderMenu::_DrawItem(DRAWITEMSTRUCT *pdi)
{
    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)pdi->itemData;
    if (psed)
    {
        TCHAR szMenuText[MAX_PATH];
        SHUnicodeToTChar(psed->wszMenuText, szMenuText, ARRAYSIZE(szMenuText));
        DrawMenuItem(pdi, szMenuText, psed->iIcon);
    }        
}

LRESULT CDefFolderMenu::_MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)pmi->itemData;
    if (psed)
    {
        TCHAR szMenuText[MAX_PATH];
        SHUnicodeToTChar(psed->wszMenuText, szMenuText, ARRAYSIZE(szMenuText));
        return MeasureMenuItem(pmi, szMenuText);
    }
    return FALSE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defcm.h ===
//
//  publics for defcm
//

// Some code that knows defcm will be used likes to prepare the menu first.
// If you do this, you must call SHPrettyMenuForDefcm instead of _SHPrettyMenu
HRESULT SHPrepareMenuForDefcm(HMENU hmenu, UINT indexMenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast); // sets things up
HRESULT SHPrettyMenuForDefcm(HMENU hmenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast, HRESULT hrPrepare); // cleans things up part way
HRESULT SHUnprepareMenuForDefcm(HMENU hmenu, UINT idCmdFirst, UINT idCmdLast); // cleans things up the rest of the way (not required if you're just destroying the menu)


STDAPI CDefFolderMenu_CreateHKeyMenu(HWND hwndOwner, HKEY hkey, IContextMenu **ppcm);
STDAPI CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, IContextMenuCB *pcmcb, 
                                UINT nKeys, const HKEY *ahkeyClsKeys, 
                                IContextMenu **ppcm);
STDAPI CDefFolderMenu_CreateEx(LPCITEMIDLIST pidlFolder,
                             HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, IContextMenuCB *pcmcb, 
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu **ppcm);

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR pszText, UINT iIcon);
STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *pmi, LPCTSTR pszText);

typedef struct {
    UINT max;
    struct {
        UINT id;
        UINT fFlags;
    } list[2];
} IDMAPFORQCMINFO;
extern const IDMAPFORQCMINFO g_idMap;

typedef struct {
    HWND hwnd;
    IContextMenuCB *pcmcb;
    LPCITEMIDLIST pidlFolder;
    IShellFolder *psf;
    UINT cidl;
    LPCITEMIDLIST *apidl;
    IAssociationArray *paa;
    UINT cKeys;
    const HKEY *aKeys;
} DEFCONTEXTMENU;

STDAPI CreateDefaultContextMenu(DEFCONTEXTMENU *pdcm, IContextMenu **ppcm);
    
class CDefBackgroundMenuCB : public IContextMenuCB
{
public:
    CDefBackgroundMenuCB(LPCITEMIDLIST pidlFolder);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    virtual ~CDefBackgroundMenuCB();

    LPITEMIDLIST _pidlFolder;
    LONG         _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defview.cpp ===
#include "shellprv.h"

#include <regstr.h>
#include <shellp.h>
#include <htmlhelp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "vdate.h"
#include "cnctnpt.h"
#include "ovrlaymn.h"
#include "_security.h"
#include "unicpp\dutil.h"
#include "uemapp.h"
#include "unicpp\deskhtm.h"
#include "unicpp\dcomp.h"
#include "datautil.h"
#include "defvphst.h"
#include <shdispid.h>
#include <limits.h>
#include "prop.h"
#include <mshtmcid.h>
#include "dvtasks.h"
#include "category.h"
#include "ViewState.h"
#include <initguid.h>
#include <guids.h>
#include <CommonControls.h>
#include "clsobj.h"
#include <sfview.h>
#include "defviewp.h"
#include "shellp.h"
#include "duiview.h"
#include "enumidlist.h"
#include "util.h"
#include "foldertypes.h"
#include <dpa.h>
#include "views.h"
#include "defcm.h"
#include "contextmenu.h"

// a "default" view to trick the browser into letting us delay viewmode selection
// {6C6720F7-4B22-4CAA-82D6-502BB6F85A9A}
DEFINE_GUID(VID_DefaultView, 0x6C6720F7L, 0x4B22, 0x4CAA, 0x82, 0xD6, 0x50, 0x2B, 0xB6, 0xF8, 0x5A, 0x9A);

void DisableActiveDesktop();
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);
STDAPI_(void) SetPositionItemsPoints(IFolderView* psfv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrag);
void UpdateGridSizes(BOOL fDesktop, HWND hwndListview, int nWorkAreas, LPRECT prcWork, BOOL fMinimizeGutterSpace);

#define ID_LISTVIEW     1
#define ID_STATIC       2

extern BOOL g_fDraggingOverSource;

#define IsDefaultState(_dvHead) ((_dvHead).dvState.lParamSort == 0 && \
                                 (_dvHead).dvState.iDirection == 1 && \
                                 (_dvHead).dvState.iLastColumnClick == -1 && \
                                 (_dvHead).ptScroll.x == 0 && (_dvHead).ptScroll.y == 0)

HMODULE g_hmodNTSHRUI = NULL;

typedef struct
{
    POINT pt;
    ITEMIDLIST idl;
} DVITEM;


//
// Note that it returns NULL, if iItem is -1.
//

// determine if color is light or dark
#define COLORISLIGHT(clr) ((5*GetGValue((clr)) + 2*GetRValue((clr)) + GetBValue((clr))) > 8*128)

void EnableCombinedView(CDefView *pdsv, BOOL fEnable);

BOOL IsBarricadeGloballyOff();
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);
BOOL GetBarricadeValueNameFromPidl(LPCITEMIDLIST pidl, LPTSTR pszValueName, UINT cch);
HRESULT SetBarricadeStatus(LPCTSTR pszValueName, VARIANT_BOOL bShowBarricade);


// Command Strings
// !! warning. Some ContextMenu handlers do not do a case-insensitive
// check of the command so keep the case the same everywhere

TCHAR const c_szCut[] = TEXT("cut");
TCHAR const c_szCopy[] = TEXT("copy");
TCHAR const c_szLink[] = TEXT("link");
TCHAR const c_szProperties[] = TEXT("properties");
TCHAR const c_szPaste[] = TEXT("paste");
TCHAR const c_szPasteLink[] = TEXT("pastelink");
TCHAR const c_szRename[] = TEXT("rename");
TCHAR const c_szDelete[] = TEXT("delete");
TCHAR const c_szNewFolder[] = TEXT(CMDSTR_NEWFOLDERA);

char const c_szDeleteA[] = "delete";
char const c_szNewFolderA[] = CMDSTR_NEWFOLDERA;
char const c_szPrintA[] = "print";

WCHAR const c_szPrintW[] = L"print";

DWORD CDefView::_Attributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    return SHGetAttributes(_pshf, pidl, dwAttribs);
}


// IDefViewSafety
HRESULT CDefView::IsSafePage()
{
    HRESULT hr = E_ACCESSDENIED;
    WCHAR wszCurrentMoniker[MAX_PATH];
    if (SUCCEEDED(_cFrame._GetCurrentWebViewMoniker(wszCurrentMoniker,
            ARRAYSIZE(wszCurrentMoniker))))
    {
        hr = SHRegisterValidateTemplate(wszCurrentMoniker,
                SHRVT_VALIDATE | SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK);
    }
    return hr;
}


// IDVGetEnum
HRESULT CDefView::SetEnumReadyCallback(PFDVENUMREADYBALLBACK pfn, void *pvData)
{
    _pfnEnumReadyCallback = pfn;
    _pvEnumCallbackData = pvData;
    return S_OK;
}

BOOL FilterOnAttributes(DWORD dwAttributes, DWORD grfEnumFlags)
{
    if (dwAttributes & SFGAO_FOLDER)
    {
        if (!(grfEnumFlags & SHCONTF_FOLDERS))
            return FALSE;   // item is folder but client does not want folders
    }
    else if (!(grfEnumFlags & SHCONTF_NONFOLDERS))
    {
        return FALSE;   // item is file, but client only wants folders
    }

    if (!(grfEnumFlags & SHCONTF_INCLUDEHIDDEN) &&
         (dwAttributes & SFGAO_HIDDEN))
         return FALSE;  // item is hidden by client wants non hidden

    return TRUE;
}

HRESULT CDefView::CreateEnumIDListFromContents(LPCITEMIDLIST pidlFolder, DWORD grfEnumFlags, IEnumIDList **ppenum)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlView = _GetViewPidl();
    if (pidlView)
    {
        if (ILIsEqual(pidlFolder, pidlView) && (grfEnumFlags & _GetEnumFlags()) == grfEnumFlags)
        {
            LPCITEMIDLIST *apidl;
            UINT cItems;
            hr = _GetItemObjects(&apidl, SVGIO_ALLVIEW, &cItems);
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; i < cItems; i++)
                {
                    if (!FilterOnAttributes(_Attributes(apidl[i], SFGAO_FOLDER | SFGAO_HIDDEN), grfEnumFlags))
                    {
                        apidl[i] = apidl[cItems - 1];
                        cItems--;
                        i--;
                    }
                }

                hr = CreateIEnumIDListOnIDLists(apidl, cItems, ppenum);
                LocalFree(apidl);
            }
        }
        ILFree(pidlView);
    }
    return hr;
}

HRESULT CDefView::_OnDefaultCommand()
{
    return _pcdb ? _pcdb->OnDefaultCommand(_psvOuter ? _psvOuter : this) : E_NOTIMPL;
}

HRESULT CDefView::_OnStateChange(UINT code)
{
    return _pcdb ? _pcdb->OnStateChange(_psvOuter ? _psvOuter : this, code) : E_NOTIMPL;
}

HRESULT CDefView::_IncludeObject(LPCITEMIDLIST pidl)
{
    if (_pcdb)
        return _pcdb->IncludeObject(_psvOuter ? _psvOuter : this, pidl);
    else
    {
        IFolderFilter *psff = _cCallback.GetISFF();
        return psff ? psff->ShouldShow(_pshf, NULL, pidl) : S_OK;
    }
}

HRESULT CDefView::CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _cCallback.CallCB(uMsg, wParam, lParam);
}

void CDefView::RegisterSFVEvents(IUnknown * pTarget, BOOL fConnect)
{
    ConnectToConnectionPoint(SAFECAST(this, IShellView2 *),
        DIID_DShellFolderViewEvents, fConnect, pTarget, &_dwConnectionCookie, NULL);
}

// fires dispatch events to clients (address bar, webview, etc).
// this translates return values of false into "ERROR_CANCELLED"

HRESULT CDefView::_FireEvent(DISPID dispid)
{
    HRESULT hr;
    VARIANT varResult = {0};
    SHINVOKEPARAMS inv = {0};

    inv.dispidMember = dispid;
    inv.piid = &IID_NULL;
    inv.wFlags = DISPATCH_METHOD;
    inv.pvarResult = &varResult;

    if (SUCCEEDED(IUnknown_CPContainerInvokeIndirect(_pauto, DIID_DShellFolderViewEvents, &inv)))
    {
        if ((VT_BOOL == varResult.vt) && (VARIANT_FALSE == varResult.boolVal))
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            hr = S_OK;
        }
        VariantClear(&varResult);
    }
    else
        hr = S_FALSE;

    return hr;
}

BOOL CDefView::_IsPositionedView()
{
    return !_fGroupView && ((_fs.ViewMode == FVM_ICON) || (_fs.ViewMode == FVM_SMALLICON) ||
                            (_fs.ViewMode == FVM_TILE) || (_fs.ViewMode == FVM_THUMBNAIL) ||
                            (_fs.ViewMode == FVM_THUMBSTRIP));
}

// reposition the selected items in a listview by dx, dy

void CDefView::_MoveSelectedItems(int dx, int dy, BOOL fAbsolute)
{
    SendMessage(_hwndListview, WM_SETREDRAW, FALSE, 0);
    for (int i = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
         i >= 0;
         i = ListView_GetNextItem(_hwndListview, i, LVNI_SELECTED))
    {
        if (fAbsolute)
        {
            _SetItemPosition(i, dx, dy);
        }
        else
        {
            POINT pt;
            ListView_GetItemPosition(_hwndListview, i, &pt);

            pt.x += dx;
            pt.y += dy;

            _SetItemPosition(i, pt.x, pt.y);
        }
    }
    SendMessage(_hwndListview, WM_SETREDRAW, TRUE, 0);
}

void CDefView::_SameViewMoveIcons()
{
    POINT ptDrop;
    BOOL fAbsolute = FALSE;

    // We'll use the insert mark rect (if available) to determine a drop point
    if (_GetInsertPoint(&ptDrop))
        fAbsolute = TRUE; // Move all items to this point.
    else
    {
        ptDrop = _ptDrop;
        ptDrop.x -= _ptDragAnchor.x;
        ptDrop.y -= _ptDragAnchor.y;
        LVUtil_ClientToLV(_hwndListview, &ptDrop);
    }

    ASSERT(_IsPositionedView());

    _MoveSelectedItems(ptDrop.x, ptDrop.y, fAbsolute);
}

BOOL _DoesRegkeyExist(HKEY hkRoot, LPCTSTR pszSubkey)
{
    LONG l = 0;
    return RegQueryValue(hkRoot, pszSubkey, NULL, &l) == ERROR_SUCCESS;
}

//
// This function checks if the current HTML wallpaper is the default
// wallpaper and returns TRUE if so. If the wallpaper is the default wallpaper,
// it reads the colors from the registry. If the colors are missing, then it
// supplies the default colors.
//
BOOL CDefView::_GetColorsFromHTMLdoc(COLORREF *pclrTextBk, COLORREF *pclrHotlight)
{
    // make sure the HTML document has reached ready-state interactive
    COLORREF clrBackground;
    BOOL bRet = SUCCEEDED(_cFrame._GetHTMLBackgroundColor(&clrBackground));
    if (bRet)
    {
        // The following are the standard colors supported on desktop
        const COLORREF  c_VgaColorTable[] =
        {
            0x000000,   // Black
            0x000080,
            0x0000FF,
            0x008000,
            0x008080,
            0x00FF00,   // Green
            0x00FFFF,   // Yellow
            0x800000,
            0x800080,
            0x808000,
            0x808080,
            0xF0CAA6,
            0xF0FBFF,
            0xFF0000,   // Blue
            0xFF00FF,   // Magenta
            0xFFFF00,   // cobalt
            0xFFFFFF    // White
        };

        // Check if the given background color is a standard color.
        // If not, use the system background (COLOR_BACKGROUND).

        *pclrTextBk = GetSysColor(COLOR_BACKGROUND);    // default

        for (int i = 0; i < ARRAYSIZE(c_VgaColorTable); i++)
        {
            if (c_VgaColorTable[i] == clrBackground)
            {
                *pclrTextBk = clrBackground;  // standard, so use it
                break;
            }
        }

        if (COLORISLIGHT(*pclrTextBk))
            *pclrHotlight = 0x000000;    //Black as hightlight color!
        else
            *pclrHotlight = 0xFFFFFF;    //White as highlight color!
    }
    return bRet;
}

// Set the colors for the folder - taking care if it's the desktop.
void CDefView::_SetFolderColors()
{
    COLORREF clrText, clrTextBk, clrWindow;

    // Is this view for the desktop?
    if (_IsDesktop())
    {
        COLORREF clrHotlight;

        Shell_SysColorChange();

        // If we show HTML wallpaper, then get the appropriate colors too!
        if (_fCombinedView && _GetColorsFromHTMLdoc(&clrTextBk, &clrHotlight))
        {
            // Set the Hotlight color!
            ListView_SetHotlightColor(_hwndListview, clrHotlight);
        }
        else
        {
            // Yep.
            // Clear the background color of the desktop to make it
            // properly handle transparency.
            clrTextBk = GetSysColor(COLOR_BACKGROUND);

            //Reset the Hotlight color sothat the system color can be used.
            ListView_SetHotlightColor(_hwndListview, CLR_DEFAULT);
        }
        // set a text color that will show up over desktop color
        if (COLORISLIGHT(clrTextBk))
            clrText = 0x000000; // black
        else
            clrText = 0xFFFFFF; // white

        clrWindow = CLR_NONE; // Assume transparent

        //
        //  if there is no wallpaper or pattern we can use
        //  a solid color for the ListView. otherwise we
        //  need to use a transparent ListView, this is much
        //  slower so dont do it unless we need to.
        //
        //  Don't do this optimization if USER is going to paint
        //  some magic text on the desktop, such as
        //
        //      "FailSafe" (SM_CLEANBOOT)
        //      "Debug" (SM_DEBUG)
        //      "Build ####" (REGSTR_PATH_DESKTOP\PaintDesktopVersion)
        //      "Evaluation Version"
        //
        //  too bad there is no SPI_GETWALLPAPER, we need to read
        //  from WIN.INI.
        //

        TCHAR szWallpaper[128], szPattern[128];
        DWORD dwPaintVersion = 0;
        szWallpaper[0] = 0;
        szPattern[0] = 0;

        HKEY hkey;
        if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, &hkey) == 0)
        {
            UINT cb = sizeof(szWallpaper);
            SHQueryValueEx(hkey, TEXT("Wallpaper"), NULL, NULL, (LPBYTE)szWallpaper, (ULONG*)&cb);
            cb = sizeof(szPattern);
            SHQueryValueEx(hkey, TEXT("Pattern"), NULL, NULL, (LPBYTE)szPattern, (ULONG*)&cb);
            cb = sizeof(dwPaintVersion);
            SHQueryValueEx(hkey, TEXT("PaintDesktopVersion"), NULL, NULL, (LPBYTE)&dwPaintVersion, (ULONG*)&cb);

            // Other external criteria for painting the version
            //
            //  -   This is a beta version (has an expiration date)
            //  -   A test certificate is installed
            //
            if (dwPaintVersion == 0 && IsOS(OS_WIN2000ORGREATER))
            {
#define REGSTR_PATH_LM_ROOTCERTIFICATES \
        TEXT("SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates")
#define REGSTR_PATH_GPO_ROOTCERTIFICATES \
        TEXT("SOFTWARE\\Policies\\Microsoft\\SystemCertificates\\Root\\Certificates")
#define REGSTR_KEY_TESTCERTIFICATE \
        TEXT("2BD63D28D7BCD0E251195AEB519243C13142EBC3")

                dwPaintVersion = (0 != USER_SHARED_DATA->SystemExpirationDate.QuadPart) ||
                                 _DoesRegkeyExist(HKEY_LOCAL_MACHINE, REGSTR_PATH_LM_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE) ||
                                 _DoesRegkeyExist(HKEY_LOCAL_MACHINE, REGSTR_PATH_GPO_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE) ||
                                 _DoesRegkeyExist(HKEY_CURRENT_USER, REGSTR_PATH_GPO_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE);
            }
            RegCloseKey(hkey);
        }

        if (_fCombinedView ||
            (GetSystemMetrics(SM_CLEANBOOT) == 0 &&
             GetSystemMetrics(SM_DEBUG) == 0 &&
             !dwPaintVersion &&
             (!_fHasDeskWallPaper) &&
             (szWallpaper[0] == 0 || szWallpaper[0] == TEXT('(')) &&
             (szPattern[0] == 0 || szPattern[0] == TEXT('('))))
        {
           clrWindow = GetSysColor(COLOR_BACKGROUND);
        }
    }
    else
    {
        // Nope.
        clrWindow = GetSysColor(COLOR_WINDOW);
        clrTextBk = clrWindow;
        clrText = GetSysColor(COLOR_WINDOWTEXT);

        if (_fs.fFlags & FWF_TRANSPARENT)
        {
            IWebBrowser2 *pwb;
            if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SContainerDispatch, IID_PPV_ARG(IWebBrowser2, &pwb))))
            {
                IDispatch *pdisp;
                if (SUCCEEDED(pwb->get_Parent(&pdisp)))
                {
                    IUnknown_HTMLBackgroundColor(pdisp, &clrWindow);
                    pdisp->Release();
                }
                pwb->Release();
            }
        }
    }

    if (!_fClassic && ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXTBACKGROUND]))
        clrTextBk = _crCustomColors[CRID_CUSTOMTEXTBACKGROUND];

    if (!_fClassic && ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXT]))
        clrText = _crCustomColors[CRID_CUSTOMTEXT];

    BOOL bChange = FALSE;

    if (clrWindow != ListView_GetBkColor(_hwndListview))
        bChange = ListView_SetBkColor(_hwndListview, clrWindow);

    if (clrTextBk != ListView_GetTextBkColor(_hwndListview))
        bChange = ListView_SetTextBkColor(_hwndListview, clrTextBk);

    if (clrText != ListView_GetTextColor(_hwndListview))
        bChange = ListView_SetTextColor(_hwndListview, clrText);

    if (bChange)
        InvalidateRect(_hwndListview, NULL, TRUE);
}

UINT CDefView::_UxGetView()
{
    UINT uView = LV_VIEW_ICON;
    if (!_IsDesktop())
    {
        switch (_fs.ViewMode)
        {
        case FVM_LIST:
            uView = LV_VIEW_LIST;
            break;

        case FVM_DETAILS:
            uView = LV_VIEW_DETAILS;
            break;

        case FVM_SMALLICON:
        case FVM_THUMBNAIL:
        case FVM_THUMBSTRIP:
        case FVM_ICON:
            uView = LV_VIEW_ICON;
            break;

        case FVM_TILE:
            uView = LV_VIEW_TILE;
            break;

        default:
            TraceMsg(TF_WARNING, "Unknown ViewMode value");
            break;
        }
    }
    return uView;
}

#define ViewRequiresColumns(x)  ((x) == FVM_DETAILS || (x) == FVM_TILE)

DWORD CDefView::_LVStyleFromView()
{
    DWORD dwStyle;

    if (_IsDesktop())
    {
        dwStyle = LVS_NOSCROLL | LVS_ALIGNLEFT;
    }
    else
    {
        dwStyle = LVS_SHOWSELALWAYS;   // make sure selection is visible
    }

    // dwStyle |= _UxGetView();
    // The listview view is no longer set using the window style, so the call to the
    // view mapping code has been commented out.
    // APPCOMPAT: This may be an issue, if apps are depending the exstyle bits on the listview hwnd
    // in defview. If so, we can set them, but we must take care to exclude any bits outside the 2bit
    // "view range" in the extended style (namely, tile view)

    if (_IsAutoArrange())
        dwStyle |= LVS_AUTOARRANGE;

    if (_fs.fFlags & FWF_SINGLESEL)
        dwStyle |= LVS_SINGLESEL;

    if (_fs.fFlags & FWF_ALIGNLEFT)
        dwStyle |= LVS_ALIGNLEFT;

    if (_fs.fFlags & FWF_NOSCROLL)
        dwStyle |= LVS_NOSCROLL;

    return dwStyle;
}

DWORD CDefView::_LVExStyleFromView()
{
    DWORD dwLVExStyle = 0;

    if (_fs.fFlags & FWF_SNAPTOGRID)
        dwLVExStyle |= LVS_EX_SNAPTOGRID;

    if (_fs.fFlags & FWF_CHECKSELECT)
        dwLVExStyle |= LVS_EX_CHECKBOXES|LVS_EX_SIMPLESELECT;

    return dwLVExStyle;
}

HRESULT CDefView::_GetDetailsHelper(int i, DETAILSINFO *pdi)
{
    HRESULT hr = E_NOTIMPL;

    if (_pshf2)
    {
        hr = _pshf2->GetDetailsOf(pdi->pidl, i, (SHELLDETAILS *)&pdi->fmt);
    }

    if (FAILED(hr))   // Don't make NSEs impl all of IShellFolder2
    {
        if (_psd)
        {
            // HACK: pdi->fmt is the same layout as SHELLDETAILS
            hr = _psd->GetDetailsOf(pdi->pidl, i, (SHELLDETAILS *)&pdi->fmt);
        }
        else if (HasCB())
        {
            hr = CallCB(SFVM_GETDETAILSOF, i, (LPARAM)pdi);
        }
    }

    return hr;
}


// Determine if the given defview state struct has valid
// state info.  If is doesn't, this function massages the
// values so it does.

UINT CDefView::_GetHeaderCount()
{
    UINT cCols = 0;
    HWND hwndHead = ListView_GetHeader(_hwndListview);
    if (hwndHead)
    {
        cCols = Header_GetItemCount(hwndHead);
    }
    return cCols;
}

void CDefView::AddColumns()
{
    // so we do this once
    if (_bLoadedColumns)
        return;

    _bLoadedColumns = TRUE;

    // I also use this as a flag for whether to free pColHdr
    //
    // Calculate a reasonable size to initialize the column width to.

    _cxChar = GetControlCharWidth(_hwndListview);

    // Check whether there is any column enumerator (ShellDetails or callback)
    if (_psd || _pshf2 || HasCB())
    {
        // Some shell extensions return S_OK and NULL pstmCols.
        IStream *pstmCols = NULL;
        if (SUCCEEDED(CallCB(SFVM_GETCOLSAVESTREAM, STGM_READ, (LPARAM)&pstmCols)) && pstmCols)
        {
            _vs.LoadColumns(this, pstmCols);
            pstmCols->Release();
        }

        // Verify that this has been initialized. This may not be if there was no state stream.
        _vs.InitializeColumns(this);

        for (UINT i = 0; i < _vs.GetColumnCount(); ++i)
        {
            if (_IsColumnInListView(i))
            {
                UINT iVisible = _RealToVisibleCol(i);

                LV_COLUMN col;
                col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                col.fmt = _vs.GetColumnFormat(i);

                // If column width is not specified in the desktop.ini.......
                col.cx = _vs.GetColumnWidth(iVisible, _vs.GetColumnCharCount(i) * _cxChar);
                col.pszText = _vs.GetColumnName(i);
                col.cchTextMax = MAX_COLUMN_NAME_LEN;
                col.iSubItem = i;

                if (col.fmt & LVCFMT_COL_HAS_IMAGES)
                {
                    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SUBITEMIMAGES, LVS_EX_SUBITEMIMAGES);
                    col.fmt &= ~LVCFMT_COL_HAS_IMAGES;
                }

                ListView_InsertColumn(_hwndListview, iVisible, &col);
            }
        }

        // Set the header control to have zero margin around bitmaps, for the sort arrows
        Header_SetBitmapMargin(ListView_GetHeader(_hwndListview), 0);

        ListView_SetExtendedListViewStyleEx(_hwndListview,
            LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP,
            LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP);

        //We added columns; so, just sync the Column order.
        _vs.SyncColumnOrder(this, TRUE);
    }

    // use real numbers, not visible
    int cCols = (int)_vs.GetColumnCount();
    if (_vs._iLastColumnClick >= cCols)
    {
        _vs.InitWithDefaults(this);

        if (_vs._iLastColumnClick >= cCols ||
            _vs._lParamSort >= cCols)
        {
            // our defaults won't work on this view....
            // hard code these defaults
            _vs._lParamSort = 0;
            _vs._iDirection = 1;
            _vs._iLastColumnClick = -1;
        }
    }
}

void CDefView::InitSelectionMode()
{
    _dwSelectionMode = 0;

    if (_fs.fFlags & FWF_SINGLECLICKACTIVATE)
    {
        _dwSelectionMode = LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE;
    }
    else if (!_fClassic)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_DOUBLECLICKINWEBVIEW, FALSE);

        if (!ss.fDoubleClickInWebView)
            _dwSelectionMode = LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE;
    }
}

void CDefView::_UpdateSelectionMode()
{
    InitSelectionMode();
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE, _dwSelectionMode);
}

DWORD _GetUnderlineStyles()
{
    DWORD dwUnderline = ICON_IE;

    // Read the icon underline settings.
    DWORD cb = sizeof(dwUnderline);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("IconUnderline"), NULL, &dwUnderline, &cb, FALSE, &dwUnderline, cb);

    // If it says to use the IE link settings, read them in.
    if (dwUnderline == ICON_IE)
    {
        dwUnderline = ICON_YES;

        TCHAR szUnderline[8];
        cb = sizeof(szUnderline);
        SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("Anchor Underline"), NULL, szUnderline, &cb, FALSE, szUnderline, cb);

        // Convert the string to an ICON_ value.
        if (!lstrcmpi(szUnderline, TEXT("hover")))
            dwUnderline = ICON_HOVER;
        else if (!lstrcmpi(szUnderline, TEXT("no")))
            dwUnderline = ICON_NO;
        else
            dwUnderline = ICON_YES;
    }

    // Convert the ICON_ value into an LVS_EX value.
    DWORD dwExStyle;

    switch (dwUnderline)
    {
    case ICON_NO:
        dwExStyle = 0;
        break;

    case ICON_HOVER:
        dwExStyle = LVS_EX_UNDERLINEHOT;
        break;

    case ICON_YES:
        dwExStyle = LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD;
        break;
    }
    return dwExStyle;
}

void CDefView::_UpdateUnderlines()
{
    // Set the new LVS_EX_UNDERLINE flags.
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD, _GetUnderlineStyles());
}

void CDefView::_SetSysImageList()
{
    HIMAGELIST himlLarge, himlSmall;

    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(_hwndListview, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(_hwndListview, himlSmall, LVSIL_SMALL);
}

void CDefView::_SetTileview()
{
    IImageList* piml;
    if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
    {
        ListView_SetImageList(_hwndListview, IImageListToHIMAGELIST(piml), LVSIL_NORMAL);
        piml->Release();
    }
}

BOOL CDefView::_IsUsingFullIconSelection()
{
    // This is a temporary method of turning on the new selection style.
    // We will enable this via Folder Options when the Touzts determines the string to use.
    BOOL fUseNewSelectionStyle = FALSE;
    SystemParametersInfo(SPI_GETFLATMENU, 0, (void *)&fUseNewSelectionStyle, 0);
    return fUseNewSelectionStyle;
}

LRESULT CDefView::_OnCreate(HWND hWnd)
{
    _hwndView = hWnd;
    _hmenuCur = NULL;
    _uState = SVUIA_DEACTIVATE;
    _hAccel = LoadAccelerators(HINST_THISDLL, MAKEINTRESOURCE(ACCEL_DEFVIEW));

    // Note that we are going to get a WM_SIZE message soon, which will
    // place this window correctly

    // Map the ViewMode to the proper listview style
    DWORD dwStyle = _LVStyleFromView() | LVS_EDITLABELS;
    DWORD dwExStyle = 0;

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.

    if (IS_WINDOW_RTL_MIRRORED(hWnd))
    {
        // This means left to right reading order because this window will be mirrored.
        dwExStyle |= WS_EX_RTLREADING;
    }

    // don't set this as in webview this is normally off, having this
    // set causes a 3d edge to flash on in a refresh
    if (!_ShouldShowWebView() && !_IsDesktop() && !(_fs.fFlags & FWF_NOCLIENTEDGE))
    {
        dwExStyle |= WS_EX_CLIENTEDGE;
    }

    if (_IsOwnerData())
        dwStyle |= LVS_OWNERDATA;

    _hwndListview = CreateWindowEx(dwExStyle, WC_LISTVIEW, TEXT("FolderView"),      // MSAA name
            dwStyle | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | LVS_SHAREIMAGELISTS,
            0, 0, 0, 0, hWnd, (HMENU)ID_LISTVIEW, HINST_THISDLL, NULL);
    if (_hwndListview)
    {
        // Set up non-viewmode-dependant listview information here.
        // Other flags are set up in _SwitchToViewFVM

        DWORD dwLVExStyle = _LVExStyleFromView() | LVS_EX_INFOTIP | LVS_EX_LABELTIP;

        if (_IsDesktop())
        {
            if (GetNumberOfMonitors() > 1)
                dwLVExStyle |= LVS_EX_MULTIWORKAREAS;
        }
        else
        {
            dwLVExStyle |= LVS_EX_DOUBLEBUFFER;  // Enable double buffering for all but desktop for affects
        }

        // turn on infotips -- window was just created, so all LVS_EX bits are off
        ListView_SetExtendedListViewStyle(_hwndListview, dwLVExStyle);

        // Get the proper RTL bits to pass on to our child windows
        _fmt = 0;
        // Be sure that the OS is supporting the flags DATE_LTRREADING and DATE_RTLREADING
        if (g_bBiDiPlatform)
        {
            // Get the date format reading order
            LCID locale = GetUserDefaultLCID();
            if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC))
            {
                // Get the real list view windows ExStyle.
                // [msadek]; we shouldn't check for either WS_EX_RTLREADING OR RTL_MIRRORED_WINDOW
                // on localized builds we have both of them to display dirve letters,..etc correctly
                // on enabled builds we have none of them. let's check on RTL_MIRRORED_WINDOW only

                if (GetWindowLong(_hwndListview, GWL_EXSTYLE) & RTL_MIRRORED_WINDOW)
                    _fmt = LVCFMT_RIGHT_TO_LEFT;
                else
                    _fmt = LVCFMT_LEFT_TO_RIGHT;
            }
        }

        // Get hwndInfotip (the control for all listview infotips).
        HWND hwndInfotip = ListView_GetToolTips(_hwndListview);
        if (hwndInfotip)
        {
            // make the tooltip window  to be topmost window (set the TTS_TOPMOST style bit for the tooltip)
            SetWindowPos(hwndInfotip, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            // Initialize hwndInfotip.
            _InitInfotipControl(hwndInfotip);
        }

        _UpdateUnderlines();

        // IShellDetails for old callers, new guys use IShellFolder2
        ASSERT(_psd == NULL);
        _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IShellDetails, &_psd));

        // App compat - some apps need columns loaded first thing
        if (SHGetAppCompatFlags(ACF_LOADCOLUMNHANDLER) & ACF_LOADCOLUMNHANDLER)
        {
            AddColumns();
        }

        _SetFolderColors();
    }

    // Create _hwndInfotip (the control for all non-listview infotips).
    _hwndInfotip = _CreateInfotipControl(hWnd);
    if (_hwndInfotip)
    {
        // Initialize _hwndInfotip.
        _InitInfotipControl(_hwndInfotip);
    }

    return _hwndListview ? 0 : -1;  // 0 is success, -1 is failure from WM_CREATE
}

HWND CDefView::_CreateInfotipControl(HWND hwndParent)
{
    // hwndInfotip is currently expected to be destroyed by destruction of
    // the parent hwnd (hwndParent).  Thus, hwndParent should not be NULL.
    ASSERT(hwndParent != NULL); // Sanity check.

    // Create hwndInfotip.
    return ::CreateWindowEx(
        IS_WINDOW_RTL_MIRRORED(hwndParent) || IS_BIDI_LOCALIZED_SYSTEM()
            ? WS_EX_LAYOUTRTL
            : 0,
        TOOLTIPS_CLASS,
        NULL,
        0,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        hwndParent,
        NULL,
        g_hinst,
        NULL);
}

void CDefView::_InitInfotipControl(HWND hwndInfotip)
{
    ASSERT(hwndInfotip);

    // Set the length of time the pointer must remain stationary within a tool's
    // bounding rectangle before the ToolTip window appears to 2 times the default.
    INT iTime = ::SendMessage(hwndInfotip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
    ::SendMessage(hwndInfotip, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)(INT)MAKELONG(iTime * 2, 0));

    // Set the length of time a ToolTip window remains visible if the pointer
    // is stationary within a tool's bounding rectangle to a very large value.
    ::SendMessage(hwndInfotip, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)(INT)MAKELONG(MAXSHORT, 0));
}

// "Auto" AutoArrange means re-position if we are in a positioned view
// and the listview is not in auto-arrange mode. we do this to re-layout
// the icons in cases where that makes sense

HRESULT CDefView::_AutoAutoArrange(DWORD dwReserved)
{
    if (!_fUserPositionedItems && _IsPositionedView() &&
        !(GetWindowStyle(_hwndListview) & LVS_AUTOARRANGE))
    {
        ListView_Arrange(_hwndListview, LVA_DEFAULT);
    }
    return S_OK;
}

LRESULT CDefView::WndSize(HWND hWnd)
{
    RECT rc;

    // We need to dismiss "name edit" mode, if we are in.
    _DismissEdit();

    // Get the client size.
    GetClientRect(hWnd, &rc);

    // Set the Static to be the Client size.
    if (_hwndStatic)
    {
        MoveWindow(_hwndStatic, rc.left, rc.top,
            rc.right-rc.left, rc.bottom-rc.top, TRUE);

        HWND hAnimate = ::GetWindow (_hwndStatic, GW_CHILD);

        if (hAnimate)
        {
            MoveWindow(hAnimate, rc.left, rc.top,
                rc.right-rc.left, rc.bottom-rc.top, TRUE);
        }

        RedrawWindow(_hwndStatic, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
    }

    // Set all windows to their new rectangles.

    _cFrame.SetRect(&rc);

    // Don't resize _hwndListview if a DefViewOC is using it.
    //
    // If we're waiting for a Web View (!_fCanActivateNow), then it
    // doesn't make sense to resize the _hwndListview -- just extra
    // work, right?  But in the non-WebView case, it's this first
    // resize which sets the listview size, and then there are no
    // more.  Unfortunately, the first resize comes in when the
    // _hwndListview is created, which is *before* _fCanActivateNow
    // can possibly be set.

    if (!_fGetWindowLV && !_pDUIView)
    {
        SetWindowPos(_hwndListview, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE);
        OnResizeListView();
    }

    if (_pDUIView)
    {
        _pDUIView->SetSize (&rc);
        _AutoAutoArrange(0);
    }

    CallCB(SFVM_SIZE, 0, 0);
    return 1;
}


UINT _GetMenuIDFromViewMode(UINT uViewMode)
{
    ASSERTMSG(FVM_FIRST <= uViewMode && uViewMode <= FVM_LAST, "_GetMenuIDFromViewMode received unknown uViewMode");
    return SFVIDM_VIEW_FIRSTVIEW + uViewMode - FVM_FIRST;
}

void CDefView::CheckToolbar()
{
    if (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)
    {
        int idCmdCurView = _GetMenuIDFromViewMode(_fs.ViewMode);

        // preserve win95 behavior for dumb corel apps
        for (int idCmd = SFVIDM_VIEW_ICON; idCmd <= SFVIDM_VIEW_DETAILS; idCmd++)
        {
            _psb->SendControlMsg(
                FCW_TOOLBAR, TB_CHECKBUTTON, idCmd, (LPARAM)(idCmd == idCmdCurView), NULL);
        }
    }
}

void CDefView::OnListViewDelete(int iItem, LPITEMIDLIST pidlToFree, BOOL fCallCB)
{
    LPCITEMIDLIST pidlReal = _GetPIDLParam((LPARAM)pidlToFree, iItem);

    if (fCallCB)
    {
        CallCB(SFVM_DELETEITEM, 0, (LPARAM)pidlReal);
    }

    ILFree(pidlToFree); // NULL in owner data case
}

// NOTE: many keys are handled as accelerators

void CDefView::HandleKeyDown(LV_KEYDOWN *pnmhdr)
{
    // REVIEW: these are things not handled by accelerators, see if we can
    // make them all based on accelerators

    switch (pnmhdr->wVKey)
    {
    case VK_ESCAPE:
        if (_bHaveCutStuff)
            OleSetClipboard(NULL);
        break;
    }
}

// This function checks to see if we are in virtual mode or not.  If we are in
// virtual mode, we always need to ask our folder we are viewing for the item and
// not the listview.

LPCITEMIDLIST CDefView::_GetPIDL(int i)
{
    if (_IsOwnerData())
    {
        LPCITEMIDLIST pidl = NULL;
        CallCB(SFVM_GETITEMIDLIST, i, (LPARAM)&pidl);
        return pidl;
    }

    return (LPCITEMIDLIST)LVUtil_GetLParam(_hwndListview, i);
}

LPCITEMIDLIST CDefView::_GetPIDLParam(LPARAM lParam, int i)
{
    return lParam ? (LPCITEMIDLIST)lParam : _GetPIDL(i);
}

// returns an array of LPCITEMIDLIST for objects in the view (selected or all)
// the "focused" item is always in array entry 0. this array contains poitners to pidls
// owned stored in the listview, so YOU SHOULD NOT FREE THEM OR MESS WITH THEM IN ANYWAY.
// this also implies the lifetime of this array must be shorter than the listview
// data it points to. that is if the view changes under you you are hosed.
//
// Notes: this function returns LP*C*ITEMIDLIST. The caller is not
//  supposed alter or delete them. Their lifetime are very short (until the
//  list view is modified).

typedef struct
{
    LPCITEMIDLIST pidl;
    POINT pt;
    int iItem;
} POS_SORT_INFO;

// standard compare returns
// -1 1 < 2
//  0 1 = 2
//  1 1 > 2
//
// NOTE: in the RTL_MIRRORED_WINDOW case the coords are reversed for us

int _CmpTopToBottomLeftToRight(POS_SORT_INFO *psi1, POS_SORT_INFO *psi2, LPARAM lParam)
{
    int iCmp = psi1->pt.y - psi2->pt.y;
    if (0 == iCmp)
    {
        iCmp = psi1->pt.x - psi2->pt.x;
    }
    return iCmp;
}

int _CmpLeftToRightTopToBottom(POS_SORT_INFO *psi1, POS_SORT_INFO *psi2, LPARAM lParam)
{
    int iCmp = psi1->pt.x - psi2->pt.x;
    if (0 == iCmp)
    {
        iCmp = psi1->pt.y - psi2->pt.y;
    }
    return iCmp;
}

CDPA<POS_SORT_INFO>::_PFNDPACOMPARE _GetSortFunction(HWND hwndListview)
{
    if (GetWindowStyle(hwndListview) & LVS_ALIGNLEFT)
    {
        return _CmpLeftToRightTopToBottom;  // desktop LV_VIEW_ICON case
    }
    else
    {
        UINT uViewMode = ListView_GetView(hwndListview);
        switch (uViewMode)
        {
        case LV_VIEW_DETAILS:
        case LV_VIEW_LIST:
            return _CmpLeftToRightTopToBottom;

        case LV_VIEW_TILE:
        case LV_VIEW_ICON:
        default:
            return _CmpTopToBottomLeftToRight;
        }
    }
}

UINT CDefView::_GetItemArray(LPCITEMIDLIST apidl[], UINT capidl, UINT uWhat)
{
    UINT cItems = 0;

    if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_SELECTION)
    {
        cItems = ListView_GetSelectedCount(_hwndListview);
    }
    else if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_CHECKED)
    {
        int iItem = ListView_GetItemCount(_hwndListview) - 1;
        for (; iItem >= 0; iItem--)
        {
            if (ListView_GetCheckState(_hwndListview, iItem))
                cItems++;
        }
    }
    else 
    {
        cItems = ListView_GetItemCount(_hwndListview);
    }

    if (apidl)
    {
        UINT uType = (SVGIO_SELECTION == (uWhat & SVGIO_TYPE_MASK)) ? LVNI_SELECTED : LVNI_ALL;
        BOOL bArrayFilled = FALSE;   // gets set on success of the sort code path

        // optimize the 1 case, the sort below is not needed
        if (!(SVGIO_FLAG_VIEWORDER & uWhat) && (capidl > 1))
        {
            CDPA<POS_SORT_INFO> dpaItemInfo;

            // pick a grow size of capidl so that we get a single alloc
            // when we add the first item to the array

            if (dpaItemInfo.Create(capidl))
            {
                POS_SORT_INFO *ppsi = new POS_SORT_INFO[capidl];
                if (ppsi)
                {
                    int iDPAIndex = 0;
                    for (int iListView = ListView_GetNextItem(_hwndListview, -1, uType);
                         iListView >= 0;
                         iListView = ListView_GetNextItem(_hwndListview, iListView, uType))
                    {
                        // if we want checked then it must be checked, otherwise just return (or skip)
                        if ((SVGIO_CHECKED != (uWhat & SVGIO_TYPE_MASK)) || ListView_GetCheckState(_hwndListview, iListView))
                        {
                            ppsi[iDPAIndex].pidl = _GetPIDL(iListView);
                            ppsi[iDPAIndex].iItem = iListView;
                            ListView_GetItemPosition(_hwndListview, iListView, &ppsi[iDPAIndex].pt);

                            // this may fail, but we catch that case below
                            dpaItemInfo.SetPtr(iDPAIndex, &ppsi[iDPAIndex]);
                            iDPAIndex++;
                        }
                    }

                    // make sure the DPA got all of the items, if not
                    // we fall through to the unsorted case

                    if (dpaItemInfo.GetPtrCount() == capidl)
                    {
                        dpaItemInfo.Sort(_GetSortFunction(_hwndListview), 0);

                        int iFirstItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);

                        // compute the start index in the dpa based on iFirstItem. this is to
                        // rotate the array so that iFirstItem is first in the list

                        for (iDPAIndex = 0; iDPAIndex < dpaItemInfo.GetPtrCount(); iDPAIndex++)
                        {
                            if (dpaItemInfo.FastGetPtr(iDPAIndex)->iItem == iFirstItem)
                            {
                                break;  // iDPAIndex setup for loop below
                            }
                        }

                        for (int i = 0; i < dpaItemInfo.GetPtrCount(); i++, iDPAIndex++)
                        {
                            if (iDPAIndex >= dpaItemInfo.GetPtrCount())
                                iDPAIndex = 0;  // wrap back to zero

                            apidl[i] = dpaItemInfo.FastGetPtr(iDPAIndex)->pidl;
                        }
                        bArrayFilled = TRUE; // we have the results we want

                        delete [] ppsi;
                    }
                }
                dpaItemInfo.Destroy();
            }
        }

        if (!bArrayFilled)
        {
            for (int i = 0, iListView = ListView_GetNextItem(_hwndListview, -1, uType);
                 iListView >= 0;
                 iListView = ListView_GetNextItem(_hwndListview, iListView, uType))
            {
                // if we want checked then it must be checked, otherwise just return (or skip)
                if ((SVGIO_CHECKED != (uWhat & SVGIO_TYPE_MASK)) || ListView_GetCheckState(_hwndListview, iListView))
                {
                    apidl[i++] = _GetPIDL(iListView);
                }
            }
        }
    }
    return cItems;
}

//
// get the array of IDList from the selection and calls
// IShellFolder::GetUIObjectOf member to get the specified UI object
// interface.
//
HRESULT CDefView::_GetUIObjectFromItem(REFIID riid, void **ppv, UINT uWhat, BOOL fSetPoints)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr;

    if (SVGIO_SELECTION == (uWhat & SVGIO_TYPE_MASK))
    {
        hr = GetSelectedObjects(&apidl, &cItems);
    }
    else
    {
        hr = _GetItemObjects(&apidl, uWhat, &cItems);
    }

    if (SUCCEEDED(hr))
    {
        if (cItems)
        {
            hr = _pshf->GetUIObjectOf(_hwndMain, cItems, apidl, riid, 0, ppv);
            if (SUCCEEDED(hr) && (IID_IDataObject == riid) && fSetPoints)
            {
                _SetPoints(cItems, apidl, (IDataObject *)*ppv);
            }
            LocalFree((HLOCAL)apidl);
        }
        else
            hr = E_INVALIDARG;
    }
    return hr;
}

// If the browser has a Tree then we want to use explore.
UINT CDefView::_GetExplorerFlag()
{
    return IsExplorerBrowser(_psb) ? CMF_EXPLORE : 0;
}

// creates a selection object out of the current selection.
IShellItemArray* CDefView::_CreateSelectionShellItemArray(void)
{
    IShellItemArray *pSelectionObj = NULL;
    LPCITEMIDLIST *apidl;
    UINT cItems;

    if (SUCCEEDED(_GetItemObjects(&apidl, SVGIO_SELECTION | SVGIO_FLAG_VIEWORDER, &cItems)) && cItems)
    {
        SHCreateShellItemArray(NULL, _pshf, cItems, apidl, &pSelectionObj);
        LocalFree(apidl);
    }
    return pSelectionObj;
}

DWORD CDefView::_AttributesFromSel(DWORD dwAttributesNeeded)
{
    // If this gets hit then chances are it's a performance problem...
    //
    if (_fSelectionChangePending)
    {
        TraceMsg(TF_WARNING, "Potential perf badness: may be asking for attributes during OnLVNUpdateItem!");
        if (_pSelectionShellItemArray)
            ATOMICRELEASE(_pSelectionShellItemArray);
       _pSelectionShellItemArray = _CreateSelectionShellItemArray();
    }

    DWORD dwAttributes = 0;
    if (_pSelectionShellItemArray)
    {
        _pSelectionShellItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, dwAttributesNeeded, &dwAttributes);
    }
    return dwAttributes;
}


// IContextMenuSite:
// Defview's context menu implementation isn't very clean.  As a temporary step towards
// cleaning it up (CONTEXT and BACK_CONTEXT are intermingled), use the new DOCONTEXTMENUPOPUP range
//
HRESULT CDefView::DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt)
{
    return _DoContextMenuPopup(punkCM, fFlags, pt, FALSE);
}

HRESULT CDefView::_DoContextMenuPopup(IUnknown* punk, UINT fFlags, POINT pt, BOOL fListviewItem)
{
    IContextMenu* pcm;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;

        HMENU hmContext = CreatePopupMenu();
        if (hmContext)
        {
            fFlags |= _GetExplorerFlag();

            if (0 > GetKeyState(VK_SHIFT))
                fFlags |= CMF_EXTENDEDVERBS;

            IContextMenu3* pcm3;
            if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3))))
            {
                fFlags |= CMF_ICM3;
                pcm3->Release();
            }

            // Give the context menu a site if it doesn't have one already
            IUnknown* punkSite;
            if (SUCCEEDED(IUnknown_GetSite(pcm, IID_PPV_ARG(IUnknown, &punkSite))))
            {
                punkSite->Release();
            }
            else
            {
                IUnknown_SetSite(pcm, SAFECAST(this, IShellView2*));
            }

            hr = pcm->QueryContextMenu(hmContext, 0, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST, fFlags);
            if (SUCCEEDED(hr))
            {
                // Must preinitialize to NULL; Adaptec Easy CD Creator 3.5 does not
                // null out the pointer on failure.
                ICommDlgBrowser2 *pcdb2 = NULL;
                _psb->QueryInterface(IID_PPV_ARG(ICommDlgBrowser2, &pcdb2));


                // If this is the common dialog browser, we need to make the
                // default command "Select" so that double-clicking (which is
                // open in common dialog) makes sense.
                if (_IsCommonDialog())
                {
                    // make sure this is an item
                    if (fListviewItem)
                    {
                        HMENU hmSelect = SHLoadPopupMenu(HINST_THISDLL, POPUP_COMMDLG_POPUPMERGE);

                        // If we have a pointer to the ICommDlgBrowser2 interface
                        // query if this interface wants to change the text of the
                        // default verb.  This interface is needed in the common print
                        // dialog to change the default text from 'Select' to 'Print'.
                        if (pcdb2)
                        {
                            WCHAR szTextW[MAX_PATH] = {0};

                            if (pcdb2->GetDefaultMenuText(this, szTextW, ARRAYSIZE(szTextW)) == S_OK)
                            {
                                MENUITEMINFO mi = {0};
                                mi.cbSize       = sizeof(mi);
                                mi.fMask        = MIIM_TYPE;
                                mi.fType        = MFT_STRING;
                                mi.dwTypeData   = szTextW;
                                SetMenuItemInfo(hmSelect, 0, MF_BYPOSITION, &mi);
                            }
                        }

                        // NOTE: Since commdlg always eats the default command,
                        // we don't care what id we assign hmSelect, as long as it
                        // doesn't conflict with any other context menu id.
                        // SFVIDM_CONTEXT_FIRST-1 won't conflict with anyone.
                        Shell_MergeMenus(hmContext, hmSelect, 0,
                                        (UINT)(SFVIDM_BACK_CONTEXT_FIRST-1), (UINT)-1,
                                        MM_ADDSEPARATOR);

                        SetMenuDefaultItem(hmContext, 0, MF_BYPOSITION);
                        DestroyMenu(hmSelect);
                    }
                }

                _SHPrettyMenu(hmContext);


                // If this is the common dialog browser 2, we need inform it
                // the context menu is has started.  This notifiction is use in
                // the common print dialog on NT which hosts the printers folder.
                // Common dialog want to relselect the printer object if the user
                // selected the context menu from the background.
                if (pcdb2)
                {
                    pcdb2->Notify(this, CDB2N_CONTEXTMENU_START);
                }

                // To reduce some menu message forwarding, throw away _pcmFile if we have one
                // (Since we can't have a TrackPopupMenu and a File menu open at the same time)
                IUnknown_SetSite(_pcmFile, NULL);
                ATOMICRELEASE(_pcmFile);

                // stash pcm in _pcmContextMenuPopup so we can forward menu messages
                ASSERT(NULL==_pcmContextMenuPopup);
                _pcmContextMenuPopup = pcm;
                _pcmContextMenuPopup->AddRef();

                int idDefault = GetMenuDefaultItem(hmContext, MF_BYCOMMAND, 0);
                int idCmd = TrackPopupMenu(hmContext,
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pt.x, pt.y, 0, _hwndView, NULL);

                ATOMICRELEASE(_pcmContextMenuPopup);

                if ((idCmd == idDefault) &&
                    _OnDefaultCommand() == S_OK)
                {
                    // commdlg browser ate the default command
                }
                else if (idCmd == 0)
                {
                    // No item selected
                }
                else if (idCmd >= SFVIDM_BACK_CONTEXT_FIRST && idCmd <= SFVIDM_BACK_CONTEXT_LAST)
                {
                    idCmd -= SFVIDM_BACK_CONTEXT_FIRST;

                    // We need to special case the rename command (just in case a legacy contextmenu impl relied on this behavior)
                    TCHAR szCommandString[64];
                    ContextMenu_GetCommandStringVerb(pcm, idCmd, szCommandString, ARRAYSIZE(szCommandString));
                    if (lstrcmpi(szCommandString, c_szRename) == 0)
                    {
                        DoRename();
                    }
                    else
                    {
                        CMINVOKECOMMANDINFOEX ici = { 0 };

                        ici.cbSize = sizeof(ici);
                        ici.hwnd = _hwndMain;
                        ici.lpVerb = IntToPtr_(LPCSTR, idCmd);
                        ici.nShow = SW_NORMAL;
                        ici.ptInvoke = pt;
                        ici.fMask |= CMIC_MASK_PTINVOKE | CMIC_MASK_FLAG_LOG_USAGE;

                        // record if shift or control was being held down
                        SetICIKeyModifiers(&ici.fMask);

                        _InvokeContextMenu(pcm, &ici);
                    }
                }
                else
                {
                    RIPMSG(FALSE, "CDefView::DoContextMenuPopup - Some IContextMenu inserted an ID out of our range.  Ignoring.");
                }

                // If this is the common dialog browser 2, we need inform it
                // the context menu is done.  This notifiction is use in
                // the common print dialog on NT which hosts the printers folder.
                // Common dialog want to relselect the printer object if the user
                // selected the context menu from the background.
                if (pcdb2)
                {
                    pcdb2->Notify(this, CDB2N_CONTEXTMENU_DONE);
                    pcdb2->Release();
                }
            }

            DestroyMenu(hmContext);
        }

        // Always remove the site even if we didn't set it -- once used, the IContextMenu is dead.
        IUnknown_SetSite(pcm, NULL);

        pcm->Release();
    }

    return hr;
}

void CDefView::ContextMenu(DWORD dwPos)
{
    int iItem;
    UINT fFlags = 0;
    POINT pt;

    if (SHRestricted(REST_NOVIEWCONTEXTMENU))
    {
        return;
    }

    // if shell32's global copy of the stopwatch mode is not init'd yet, init it now.
    if (g_dwStopWatchMode == 0xffffffff)
        g_dwStopWatchMode = StopWatchMode();

    if (g_dwStopWatchMode)
        StopWatch_Start(SWID_MENU, TEXT("Defview ContextMenu Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);

    if (IsWindowVisible(_hwndListview) && (IsChildOrSelf(_hwndListview, GetFocus()) == S_OK))
    {
        // Find the selected item
        iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
    }
    else
    {
        iItem = -1;
    }

    if (dwPos == (DWORD) -1)
    {
        if (iItem != -1)
        {
            RECT rc;
            int iItemFocus = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED|LVNI_SELECTED);
            if (iItemFocus == -1)
                iItemFocus = iItem;

            //
            // Note that LV_GetItemRect returns it in client coordinate!
            //
            ListView_GetItemRect(_hwndListview, iItemFocus, &rc, LVIR_ICON);
            pt.x = (rc.left + rc.right) / 2;
            pt.y = (rc.top + rc.bottom) / 2;
        }
        else
        {
            pt.x = pt.y = 0;
        }
        MapWindowPoints(_hwndListview, HWND_DESKTOP, &pt, 1);
    }
    else
    {
        pt.x = GET_X_LPARAM(dwPos);
        pt.y = GET_Y_LPARAM(dwPos);
    }

    IContextMenu* pcm;
    LPARAM uemEvent;
    if (iItem == -1)
    {
        DECLAREWAITCURSOR;
        SetWaitCursor();

        // use the background context menu wrapper
        GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm));

        ResetWaitCursor();

        // set the max range for these, so that they are unaffected...
        uemEvent = _IsDesktop() ? UIBL_CTXTDESKBKGND : UIBL_CTXTDEFBKGND;
    }
    else
    {
        fFlags |= CMF_CANRENAME;

        // One or more items are selected, let the folder add menuitems.
        _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcm));

        uemEvent = _IsDesktop() ? UIBL_CTXTDESKITEM : UIBL_CTXTDEFITEM;
    }

    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, uemEvent);

    if (g_dwStopWatchMode)
        StopWatch_Stop(SWID_MENU, TEXT("Defview ContextMenu Stop (!SafeToDefaultVerb)"), SPMODE_SHELL | SPMODE_DEBUGOUT);

    if (IsSafeToDefaultVerb() && pcm)
    {
        _DoContextMenuPopup(pcm, fFlags, pt, iItem != -1);
    }

    ATOMICRELEASE(pcm);
}

BOOL CDefView::_GetItemSpacing(ITEMSPACING *pis)
{
    DWORD dwSize = ListView_GetItemSpacing(_hwndListview, TRUE);
    pis->cxSmall = GET_X_LPARAM(dwSize);
    pis->cySmall = GET_Y_LPARAM(dwSize);
    dwSize = ListView_GetItemSpacing(_hwndListview, FALSE);
    pis->cxLarge = GET_X_LPARAM(dwSize);
    pis->cyLarge = GET_Y_LPARAM(dwSize);

    return _fs.ViewMode != FVM_ICON;
}

BOOL _DidDropOnRecycleBin(IDataObject *pdtobj)
{
    CLSID clsid;
    return SUCCEEDED(DataObj_GetDropTarget(pdtobj, &clsid)) &&
           IsEqualCLSID(clsid, CLSID_RecycleBin);
}

void CDefView::_SetPoints(UINT cidl, LPCITEMIDLIST *apidl, IDataObject *pdtobj)
{
    POINT pt;
    GetDragPoint(&pt);

    ::SetPositionItemsPoints(SAFECAST(this, IFolderView*), apidl, cidl, pdtobj, &pt);
}

LRESULT CDefView::_OnBeginDrag(NM_LISTVIEW * pnm)
{
    POINT ptOffset = pnm->ptAction;             // hwndLV client coords

    // This DefView is used as a drag source so we need to see if it's
    // is hosted by something that can disguise the action.
    if (S_OK != _ZoneCheck(PUAF_NOUI, URLACTION_SHELL_WEBVIEW_VERB))
    {
        // This DefView is hosted in HTML, so we need to turn off the
        // ability of this defview from being a drag source.
        return 0;
    }

    _OnDelayedSelectionChange();

    if (FAILED(_FireEvent(DISPID_BEGINDRAG)))   // script canceles dragging
        return 0;

    DWORD dwEffect = _AttributesFromSel(SFGAO_CANDELETE | DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY);

    // Turn on DROPEFFECT_MOVE for any deleteable item
    // (this is so the item can be dragged to the recycle bin)
    if (SFGAO_CANDELETE & dwEffect)
    {
        dwEffect |= DROPEFFECT_MOVE;
    }
    // Mask out all attribute bits that aren't also DROPEFFECT bits:
    dwEffect &= (DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY);

    // Somebody began dragging in our window, so store that fact
    _bDragSource = TRUE;

    // save away the anchor point
    _ptDragAnchor = pnm->ptAction;
    LVUtil_ClientToLV(_hwndListview, &_ptDragAnchor);

    ClientToScreen(_hwndListview, &ptOffset);     // now in screen

    // can't use _pdoSelection here since we need fSetPoints
    IDataObject *pdtobj;
    if (SUCCEEDED(_GetUIObjectFromItem(IID_PPV_ARG(IDataObject, &pdtobj), SVGIO_SELECTION, TRUE)))
    {
        // Give the source a chance to alter the drop effect.
        CallCB(SFVM_ALTERDROPEFFECT, (WPARAM)&dwEffect, (LPARAM)pdtobj);

        if (DAD_SetDragImageFromWindow(_hwndListview, &ptOffset, pdtobj))
        {
            if (DRAGDROP_S_DROP == SHDoDragDrop(_hwndMain, pdtobj, NULL, dwEffect, &dwEffect))
            {
                if (S_OK != CallCB(SFVM_DIDDRAGDROP, (WPARAM)dwEffect, (LPARAM)pdtobj))
                {
                    // the return of DROPEFFECT_MOVE tells us we need to delete the data
                    // see if we need to do that now...

                    // NOTE: we can't trust the dwEffect return result from DoDragDrop() because
                    // some apps (adobe photoshop) return this when you drag a file on them that
                    // they intend to open. so we invented the "PreformedEffect" as a way to
                    // know what the real value is, that is why we test both of these.

                    if ((DROPEFFECT_MOVE == dwEffect) &&
                        (DROPEFFECT_MOVE == DataObj_GetDWORD(pdtobj, g_cfPerformedDropEffect, DROPEFFECT_NONE)))
                    {
                        // enable UI for the recycle bin case (the data will be lost
                        // as the recycle bin really can't recycle stuff that is not files)

                        UINT uFlags = _DidDropOnRecycleBin(pdtobj) ? 0 : CMIC_MASK_FLAG_NO_UI;
                        SHInvokeCommandOnDataObject(_hwndMain, NULL, pdtobj, uFlags,c_szDeleteA);
                    }
                }
            }

            //
            // We need to clear the dragged image only if we still have the drag context.
            //
            DAD_SetDragImage((HIMAGELIST)-1, NULL);
        }
        pdtobj->Release();
    }
    _bDragSource = FALSE;  // All done dragging
    return 0;
}

void CDefView::_FocusOnSomething(void)
{
    int iFocus = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
    if (iFocus == -1)
    {
        if (ListView_GetItemCount(_hwndListview) > 0)
        {
            // set the focus on the first item.
            ListView_SetItemState(_hwndListview, 0, LVIS_FOCUSED, LVIS_FOCUSED);
        }
    }
}

HRESULT CDefView::_InvokeContextMenu(IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici)
{
    TCHAR szWorkingDir[MAX_PATH];
    CHAR szWorkingDirAnsi[MAX_PATH];

    if (SUCCEEDED(CallCB(SFVM_GETWORKINGDIR, ARRAYSIZE(szWorkingDir), (LPARAM)szWorkingDir)))
    {
        // Fill in both the ansi working dir and the unicode one
        // since we don't know who's gonna be processing this thing.
        SHUnicodeToAnsi(szWorkingDir, szWorkingDirAnsi, ARRAYSIZE(szWorkingDirAnsi));
        pici->lpDirectory  = szWorkingDirAnsi;
        pici->lpDirectoryW = szWorkingDir;
        pici->fMask |= CMIC_MASK_UNICODE;
    }

    // In case the ptInvoke field was not already set for us, guess where
    // that could be. (dli) maybe should let the caller set all points
    if (!(pici->fMask & CMIC_MASK_PTINVOKE))
    {
        if (GetCursorPos(&pici->ptInvoke))
            pici->fMask |= CMIC_MASK_PTINVOKE;
    }

    pici->fMask |= CMIC_MASK_ASYNCOK;

    _OnDelayedSelectionChange();

    HRESULT hr = _FireEvent(DISPID_VERBINVOKED);
    if (SUCCEEDED(hr))
        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)pici);
    return hr;
}

DWORD CDefView::_GetNeededSecurityAction(void)
{
    DWORD dwUrlAction = 0;

    if (!(SFGAO_FOLDER & _AttributesFromSel(SFGAO_FOLDER)))
    {
        // If we are hosted by Trident, Zone Check Action.
        IUnknown *punk;
        if (SUCCEEDED(_psb->QueryInterface(IID_IIsWebBrowserSB, (void **)&punk)))
        {
            dwUrlAction = URLACTION_SHELL_VERB;
            punk->Release();
        }
        else if (_fGetWindowLV)
        {
            // If we are using WebView, Zone Check Action.
            dwUrlAction = URLACTION_SHELL_WEBVIEW_VERB;
        }
    }

    return dwUrlAction;
}

HRESULT CDefView::_ZoneCheck(DWORD dwFlags, DWORD dwAllowAction)
{
    HRESULT hr = S_OK;
    DWORD dwUrlAction = _GetNeededSecurityAction();

    if (dwUrlAction && (dwUrlAction != dwAllowAction))
    {
        // First check if our parent wants to generate our context (Zone/URL).
        IInternetHostSecurityManager *pihsm;
        hr = IUnknown_QueryService(_psb, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsm));
        if (FAILED(hr) && _cFrame._pDocView)
        {
            // Yes, so if we are in WebView mode, check the instance of Trident that is
            // displaying the WebView content, because that content could discuise the DefView
            // and make the user unknowingly do something bad.
            hr = IUnknown_QueryService(_cFrame._pDocView, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsm));
        }

        if (SUCCEEDED(hr))
        {
            // This is the prefered way to do the zone check.
            hr = ZoneCheckHost(pihsm, dwUrlAction, dwFlags | PUAF_FORCEUI_FOREGROUND);
            pihsm->Release();
        }
        else
        {
            // No, we were not able to get the interface.  So fall back to zone checking the
            // URL that comes from the pidl we are at.

            TCHAR szPathSource[MAX_PATH];
            if (_GetPath(szPathSource))
            {
                // Try to get a IInternetSecurityMgrSite so our UI will be modal.
                IInternetSecurityMgrSite *pisms;
                if (SUCCEEDED(IUnknown_QueryService(_psb, SID_STopLevelBrowser, IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
                {
                    // TODO: Have this object support IInternetSecurityMgrSite in case our parent doesn't provide one.
                    //       Make that code support ::GetWindow() and ::EnableModless() or we won't get the modal behavior
                    //       needed for VB and AOL.

                    hr = ZoneCheckUrl(szPathSource, dwUrlAction, dwFlags | PUAF_ISFILE | PUAF_FORCEUI_FOREGROUND, pisms);
                    pisms->Release();
                }
            }
        }
    }

    return hr;
}

BOOL CDefView::IsSafeToDefaultVerb(void)
{
    return S_OK == _ZoneCheck(PUAF_WARN_IF_DENIED, 0);
}

HRESULT CDefView::_InvokeContextMenuVerb(IContextMenu* pcm, LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask)
{
    DECLAREWAITCURSOR;
    SetWaitCursor();

    CMINVOKECOMMANDINFOEX ici = {0};
    ici.cbSize = sizeof(ici);
    ici.hwnd = _hwndMain;
    ici.nShow = SW_NORMAL;
    ici.fMask = dwCMMask;

    // Get the point where the double click is invoked.
    GetMsgPos(&ici.ptInvoke);
    ici.fMask |= CMIC_MASK_PTINVOKE;

    // record if shift or control was being held down
    SetICIKeyModifiers(&ici.fMask);

    IUnknown_SetSite(pcm, SAFECAST(this, IOleCommandTarget *));

    // Security note: we assume all non default verbs safe
    HRESULT hr;
    if (pszVerb ||
        (IsSafeToDefaultVerb() && SUCCEEDED(_FireEvent(DISPID_DEFAULTVERBINVOKED))))
    {
        WCHAR szVerbW[128];
        if (pszVerb)
        {
            ici.lpVerb = pszVerb;
            SHAnsiToUnicode(pszVerb, szVerbW, ARRAYSIZE(szVerbW));
            ici.lpVerbW = szVerbW;
            ici.fMask |= CMIC_MASK_UNICODE;
        }

        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            UINT fFlags = _GetExplorerFlag();

            if (NULL == pszVerb)
                fFlags |= CMF_DEFAULTONLY;  // optmization

            // SHIFT + dbl click does a Explore by default
            if (uKeyFlags & LVKF_SHIFT)
                fFlags |= CMF_EXPLORE;

            pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);

            if (pszVerb)
                hr = S_OK;
            else
            {
                UINT idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, GMDI_GOINTOPOPUPS);
                if (idCmd == -1)
                {
                    hr = E_FAIL;
                }
                else
                {
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                    hr = S_OK;
                }
            }

            if (SUCCEEDED(hr))
            {
                // need to reset it so that user won't blow off the app starting  cursor
                // also so that if we won't leave the wait cursor up when we're not waiting
                // (like in a prop sheet or something that has a message loop
                ResetWaitCursor();
                hcursor_wait_cursor_save = NULL;

                hr = _InvokeContextMenu(pcm, &ici);
            }

            DestroyMenu(hmenu);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    IUnknown_SetSite(pcm, NULL);

    if (hcursor_wait_cursor_save)
        ResetWaitCursor();

    return hr;
}

HRESULT CDefView::_InvokeContextMenuVerbOnSelection(LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask)
{
    if (NULL == pszVerb)
    {
        if (_IsDesktop())
            UEMFireEvent(&UEMIID_SHELL, UEME_UISCUT, UEMF_XEVENT, -1, (LPARAM)-1);

        if (S_OK == _OnDefaultCommand())
        {
            return S_FALSE;         /* commdlg browser ate the message */
        }

        if (uKeyFlags & LVKF_ALT)
            pszVerb = "properties";
    }

    // Dealing with context menus can be slow
    DECLAREWAITCURSOR;
    SetWaitCursor();

    IContextMenu *pcmSel;
    HRESULT hr = _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcmSel));

    if (SUCCEEDED(hr))
        _LogDesktopLinksAndRegitems();

    ResetWaitCursor(); // undo the cursor since the below _Invoke needs to control cursor shape

    if (SUCCEEDED(hr))
    {
        hr = _InvokeContextMenuVerb(pcmSel, pszVerb, uKeyFlags, dwCMMask);

        pcmSel->Release();
    }

    return hr;
}

//
//  We want to keep track of which desktop regitems and links the user is using.
//  This lets the desktop cleaner app know which ones can safely be
//  cleaned up.
//
//  Be careful - there are many race conditions...  You have to do the
//  GetSelectedObjects before any InvokeCommands are done, because the
//  InvokeCommand calls might change the selection state.  But you also
//  have to use the result of GetSelectedObjects immediately, because
//  it returns pidls that are owned by the defview, and if a filesys
//  notify comes in, you might end up with pidls that have been freed.
//
//  So we just do all the work up front, before actually invoking anything.
//  This does mean that if the invoke fails, we still log the usage,
//  but that seems like a small price to pay.
//
void CDefView::_LogDesktopLinksAndRegitems()
{
    if (_IsDesktop())
    {
        LPCITEMIDLIST *apidl;
        UINT cItems;
        if (SUCCEEDED(GetSelectedObjects(&apidl, &cItems)) && apidl)
        {
            for (UINT i = 0; i < cItems; i++)
            {
                TCHAR szDisplayName[GUIDSTR_MAX+2]; // +2 for leading "::"
                if (SUCCEEDED(DisplayNameOf(_pshf, apidl[i], SHGDN_INFOLDER | SHGDN_FORPARSING,
                                szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    if (_Attributes(apidl[i], SFGAO_LINK))
                    {
                        // its a link
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szDisplayName);
                    }
                    else if (IsRegItemName(szDisplayName, NULL))
                    {
                        // it's a regitem
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szDisplayName);
                    }
                }
            }
            LocalFree((HLOCAL)apidl);
        }
    }
}

void CDefView::_UpdateColData(CBackgroundColInfo *pbgci)
{
    UINT iItem = ListView_MapIDToIndex(_hwndListview, pbgci->GetId());
    if (iItem != -1)
    {
        UINT uiCol = pbgci->GetColumn();

        if (_IsColumnInListView(uiCol))
        {
            UINT iVisCol = _RealToVisibleCol(uiCol);

            ListView_SetItemText(_hwndListview, iItem, iVisCol, (LPTSTR)pbgci->GetText());
        }
    }

    delete pbgci;
}

void CDefView::_UpdateIcon(LPITEMIDLIST pidl, UINT iIcon)
{
    int i = _FindItem(pidl, NULL, FALSE, FALSE);

    if (i >= 0)
    {
        LV_ITEM item = {0};

        item.mask = LVIF_IMAGE;
        item.iItem = i;
        item.iImage = iIcon;

        ListView_SetItem(_hwndListview, &item);
    }
    ILFree(pidl);
}

void CDefView::_UpdateGroup(CBackgroundGroupInfo* pbggi)
{
    if (pbggi->VerifyGroupExists(_hwndListview, _pcat))
    {
        int iItem = ListView_MapIDToIndex(_hwndListview, pbggi->GetId());

        if (iItem != -1)
        {
            LVITEM lvi = {0};
            lvi.mask = LVIF_GROUPID;
            lvi.iGroupId = pbggi->GetGroupId();
            lvi.iItem = iItem;
            ListView_SetItem(_hwndListview, &lvi);
        }

        delete pbggi;
    }
}


void CDefView::_UpdateOverlay(int iList, int iOverlay)
{
    ASSERT (iList >= 0);

    if (_IsOwnerData())
    {
        // In the ownerdata case, tell the owner that the overlay changed
        CallCB(SFVM_SETICONOVERLAY, iList, iOverlay);
        ListView_RedrawItems(_hwndListview, iList, iList);
    }
    else
    {
        ListView_SetItemState(_hwndListview, iList, INDEXTOOVERLAYMASK(iOverlay), LVIS_OVERLAYMASK);
    }
}

HRESULT CDefView::_GetIconAsync(LPCITEMIDLIST pidl, int *piIcon, BOOL fCanWait)
{
    HRESULT hr;

    // if we are not an owner-data view then try to extract asynchronously

    UINT flags = (_IsOwnerData() ? 0 : GIL_ASYNC);

    if (GIL_ASYNC & flags)
    {
        hr = SHMapIDListToImageListIndexAsync(_pScheduler, _pshf, pidl, flags, _AsyncIconTaskCallback, this, NULL, piIcon, NULL);

        if (SUCCEEDED(hr))
        {
            return S_OK;        // indicate that we got the real icon
        }
        else if (hr == E_PENDING)
        {
            hr = S_FALSE;     // the icon index we have is a placeholder
        }
    }
    else
    {
        hr = SHGetIconFromPIDL(_pshf, _psi, pidl,  flags, piIcon);
    }

    return hr;
}

void CDefView::_AsyncIconTaskCallback(LPCITEMIDLIST pidl, void *pvData, void *pvHint, INT iIconIndex, INT iOpenIconIndex)
{
    CDefView *pdv = (CDefView *)pvData;
    ASSERT(pdv);
    if (pdv)
    {
        LPITEMIDLIST pidlClone = ILClone(pidl);
        if (pidlClone && !PostMessage(pdv->_hwndView, WM_DSV_UPDATEICON, (WPARAM)pidlClone, (LPARAM)iIconIndex))
            ILFree(pidlClone);
    }
}

HRESULT CDefView::_GetOverlayIndexAsync(LPCITEMIDLIST pidl, int iList)
{
    IRunnableTask * pTask;

    HRESULT hr = CIconOverlayTask_CreateInstance(this, pidl, iList, &pTask);
    if (SUCCEEDED(hr))
    {
        _AddTask(pTask, TOID_DVIconOverlay, 0, TASK_PRIORITY_GET_ICON, ADDTASK_ATEND);
        pTask->Release();
    }

    return hr;
}

//
// Returns: if the cursor is over a listview item, its index; otherwise, -1.
//
int CDefView::_HitTest(const POINT *ppt, BOOL fIgnoreEdge)
{
    LV_HITTESTINFO info;

    if (!_IsListviewVisible())
        return -1;

    info.pt = *ppt;
    int iRet = ListView_HitTest(_hwndListview, &info);

    if (-1 != iRet && fIgnoreEdge)
    {
        // If we're in one of these large image area modes, and the caller says
        // it's okay to ignore "edge" hits, then pretend the user is over nothing.
        // Tile mode only ignores the left edge of the icon, since the right edge
        // is all text (and usually shorter than the tile width anyway).
        if (_IsTileMode() && (info.flags & LVHT_ONLEFTSIDEOFICON))
            iRet = -1;
        else if (_IsImageMode() && (info.flags & (LVHT_ONLEFTSIDEOFICON|LVHT_ONRIGHTSIDEOFICON)))
            iRet = -1;
    }

    return iRet;
}

void CDefView::_OnGetInfoTip(NMLVGETINFOTIP *plvn)
{
    if (!SHShowInfotips())
        return;

    LPCITEMIDLIST pidl = _GetPIDL(plvn->iItem);
    if (pidl)
    {
        ATOMICRELEASE(_pBackgroundInfoTip); // Release the previous value, if any

        HRESULT hr = E_FAIL;
        _pBackgroundInfoTip = new CBackgroundInfoTip(&hr, plvn);

        if (_pBackgroundInfoTip && SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder = _GetViewPidl();
            if (pidlFolder)
            {
                CStatusBarAndInfoTipTask *pTask;
                hr = CStatusBarAndInfoTipTask_CreateInstance(pidlFolder, pidl, 0, 0, _pBackgroundInfoTip, _hwndView, _pScheduler, &pTask);
                if (SUCCEEDED(hr))
                {
                    if (_pScheduler)
                    {
                        // make sure there are no other background infotip tasks going on...
                        _pScheduler->RemoveTasks(TOID_DVBackgroundInfoTip, ITSAT_DEFAULT_LPARAM, FALSE);
                    }

                    _AddTask(pTask, TOID_DVBackgroundInfoTip, 0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                    pTask->Release();
                }
                ILFree(pidlFolder);
            }
        }
    }
    // Do not show a tip while the processing is happening in the background
    plvn->pszText[0] = 0;
}

HRESULT CDefView::_OnViewWindowActive()
{
    IShellView *psv = _psvOuter ? _psvOuter : SAFECAST(this, IShellView*);

    return _psb->OnViewWindowActive(psv);
}

// CLR_NONE is a special value that never matches a valid RGB
COLORREF g_crAltColor = CLR_NONE;               // uninitialized magic value
COLORREF g_crAltEncryptedColor = CLR_NONE;      // uninitialized magic value

DWORD GetRegColor(COLORREF clrDefault, LPCTSTR pszName, COLORREF *pValue)
{
    // Fetch the alternate color (for compression) if supplied.
    if (*pValue == CLR_NONE)   // initialized yet?
    {
        DWORD cbData = sizeof(*pValue);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, pszName, NULL, pValue, &cbData)))
        {
            *pValue = clrDefault;  // default value
        }
    }
    return *pValue;
}

LRESULT CDefView::_GetDisplayInfo(LV_DISPINFO *plvdi)
{
    LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);
    if (pidl && (plvdi->item.mask & (DEFVIEW_LISTCALLBACK_FLAGS)))
    {
        ASSERT(IsValidPIDL(pidl));
        ASSERT(plvdi->item.iSubItem != 0 ? ViewRequiresColumns(_fs.ViewMode) : TRUE);

        LV_ITEM item = {0};
        item.mask = plvdi->item.mask & (DEFVIEW_LISTCALLBACK_FLAGS);
        item.iItem = plvdi->item.iItem;
        item.iImage = plvdi->item.iImage = -1; // for iSubItem != 0 case

        if ((plvdi->item.iSubItem == 0) && (item.mask & LVIF_IMAGE))
        {
            // If the folder supports IShellIconOverlay then only need to ask for ghosted, else
            // we need to do the old stuff...
            DWORD uFlags = _Attributes(pidl, _psio ? SFGAO_GHOSTED : SFGAO_LINK | SFGAO_SHARE | SFGAO_GHOSTED);

            // set the mask
            item.mask |= LVIF_STATE;
            plvdi->item.mask |= LVIF_STATE;
            item.stateMask = LVIS_OVERLAYMASK;

            // Pick the right overlay icon. The order is significant.
            item.state = 0;
            if (_psio)
            {
                int iOverlayIndex = SFV_ICONOVERLAY_UNSET;
                if (_IsOwnerData())
                {
                    // Note: we are passing SFV_ICONOVERLAY_DEFAULT here because
                    // some owners do not respond to SFVM_GETICONOVERLAY might return
                    // iOverlayIndex unchanged and it will get
                    iOverlayIndex = SFV_ICONOVERLAY_DEFAULT;
                    CallCB(SFVM_GETICONOVERLAY, plvdi->item.iItem, (LPARAM)&iOverlayIndex);
                    if (iOverlayIndex > 0)
                    {
                        item.stateMask |= LVIS_OVERLAYMASK;
                        item.state |= INDEXTOOVERLAYMASK(iOverlayIndex);
                    }
                }

                if (iOverlayIndex == SFV_ICONOVERLAY_UNSET)
                {
                    iOverlayIndex = OI_ASYNC;
                    HRESULT hr = _psio->GetOverlayIndex(pidl, &iOverlayIndex);
                    if (E_PENDING == hr)
                        _GetOverlayIndexAsync(pidl, item.iItem);
                    else if (S_OK == hr)
                    {
                        ASSERT(iOverlayIndex >= 0);
                        ASSERT(iOverlayIndex < MAX_OVERLAY_IMAGES);

                        // In the owner data case, tell the owner we got an Overlay index
                        if (_IsOwnerData())
                            CallCB(SFVM_SETICONOVERLAY, item.iItem, iOverlayIndex);

                        item.state = INDEXTOOVERLAYMASK(iOverlayIndex);
                    }
                }
            }
            else
            {
                if (uFlags & SFGAO_LINK)
                {
                    item.state = INDEXTOOVERLAYMASK(II_LINK - II_OVERLAYFIRST + 1);
                }
                else if (uFlags & SFGAO_SHARE)
                {
                    item.state = INDEXTOOVERLAYMASK(II_SHARE - II_OVERLAYFIRST + 1);
                }
            }

            if (uFlags & SFGAO_GHOSTED)
            {
                item.stateMask |= LVIS_CUT;
                item.state |= LVIS_CUT;
            }
            else
            {
                item.stateMask |= LVIS_CUT;
                item.state &= ~LVIS_CUT;
            }

            plvdi->item.stateMask = item.stateMask;
            plvdi->item.state = item.state;

            // Get the image
            if (_IsOwnerData() && !_IsImageMode())
            {
                CallCB(SFVM_GETITEMICONINDEX, plvdi->item.iItem, (LPARAM)&item.iImage);
            }

            if (item.iImage == -1)
            {
                if (_IsImageMode())
                {
                    // Check if the item is visible.  If it is not, then the image was
                    // probably asked for by the thumbnail read ahead task, in which case, we set a 
                    // different priority.
                    if (ListView_IsItemVisible(_hwndListview, item.iItem))
                    {
                        if (S_OK != ExtractItem((UINT*)&item.iImage, item.iItem, pidl, TRUE, FALSE, PRIORITY_P5))
                        {
                            _CacheDefaultThumbnail(pidl, &item.iImage);
                        }
                    }
                    else
                    {
                        // Likely from read ahead task.
                        ExtractItem((UINT*)&item.iImage, item.iItem, pidl, TRUE, FALSE, PRIORITY_READAHEAD_EXTRACT);
                    }
                }
                else
                    _GetIconAsync(pidl, &item.iImage, TRUE);
            }

            plvdi->item.iImage = item.iImage;
        }

        if (item.mask & LVIF_TEXT)
        {
            if (plvdi->item.cchTextMax)
                *plvdi->item.pszText = 0;

            // Note that we do something different for index 0 = NAME
            if (plvdi->item.iSubItem == 0)
            {
                DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER, plvdi->item.pszText, plvdi->item.cchTextMax);
            }
            else
            {
                // on the first slow column complete all of the other columns (assumed to be slow)
                // now so we get good caching from the col handlers

                UINT iReal = _VisibleToRealCol(plvdi->item.iSubItem);

                if (_vs.GetColumnState(iReal) & SHCOLSTATE_SLOW)
                {
                    UINT cCols = _vs.GetColumnCount();
                    for (UINT iVisCol = plvdi->item.iSubItem; iReal < cCols; iReal++)
                    {
                        if (_IsColumnInListView(iReal))
                        {
                            ASSERT(_vs.GetColumnState(iReal) & SHCOLSTATE_SLOW);

                            UINT uId = ListView_MapIndexToID(_hwndListview, plvdi->item.iItem);

                            // in the async case set the text to nothing (NULL). this will
                            // prevent another call to ListView_GetItemText() from invoking us
                            ListView_SetItemText(_hwndListview, plvdi->item.iItem, iVisCol++, NULL);

                            IRunnableTask *pTask;
                            if (SUCCEEDED(CExtendedColumnTask_CreateInstance(this, pidl, uId, _fmt, iReal, &pTask)))
                            {
                                _AddTask(pTask, TOID_DVBackgroundEnum, 0, TASK_PRIORITY_FILE_PROPS, ADDTASK_ATEND);
                                pTask->Release();
                            }
                        }
                    }
                    return 0;   // bail!
                }

                DETAILSINFO di;

                di.pidl = pidl;
                di.fmt  = _fmt;
                di.iImage = -1;     // Assume for now no image...

                if (SUCCEEDED(_GetDetailsHelper(iReal, &di)))
                {
                    StrRetToBuf(&di.str, pidl, plvdi->item.pszText, plvdi->item.cchTextMax);

                    if ((di.iImage != -1) && (plvdi->item.mask & LVIF_IMAGE))
                    {
                        plvdi->item.iImage = di.iImage;
                    }
                }
            }
        }

        if ((item.mask & LVIF_GROUPID) && _fGroupView)
        {
            plvdi->item.mask |= LVIF_GROUPID;
            plvdi->item.iGroupId = _GetGroupForItem(plvdi->item.iItem, pidl);
        }

        if (item.mask & LVIF_COLUMNS)
        {
            if (_fScrolling)
            {
                // Ignore any column requests if we're currently scrolling. However, don't
                // return zero for the number of columns, return I_COLUMNSCALLBACK instead, because
                // we do still want listview to call us back to ask for them if it is every displaying
                // this guy while we're not scrolling.
                plvdi->item.cColumns = I_COLUMNSCALLBACK;
                plvdi->item.puColumns = NULL;
                _fRequestedTileDuringScroll = TRUE;
            }
            else
            {
                if (_IsOwnerData())
                {
                    AddColumns();

                    if (plvdi->item.cColumns > 1)
                    {
                        // hack special case for the find folder
                        if (_MapSCIDToColumn(&SCID_DIRECTORY, &plvdi->item.puColumns[0]))
                            plvdi->item.cColumns = 1;
                    }
                }
                else
                {
                    BOOL fGotColumns = FALSE;
                    // Start a task to extract the important columns for this item.
                    LPCITEMIDLIST pidl = _GetPIDL(plvdi->item.iItem);
                    if (pidl)
                    {
                        plvdi->item.cColumns = TILEVIEWLINES;
                        if (SUCCEEDED(_PeekColumnsCache(NULL, pidl, plvdi->item.puColumns, &plvdi->item.cColumns)))
                        {
                            // Make sure columns are loaded
                            AddColumns();

                            _FixupColumnsForTileview(plvdi->item.puColumns, plvdi->item.cColumns);
                            fGotColumns = TRUE;
                        }
                        else
                        {
                            IRunnableTask *pTask;
                            UINT uId = ListView_MapIndexToID(_hwndListview, plvdi->item.iItem);

                            if (SUCCEEDED(CFileTypePropertiesTask_CreateInstance(this, pidl, TILEVIEWLINES, uId, &pTask))) //pidl gets cloned
                            {
                                _AddTask(pTask, TOID_DVFileTypeProperties, 0, TASK_PRIORITY_FILE_PROPS, ADDTASK_ATEND);
                                pTask->Release();
                            }
                        }
                    }

                    if (!fGotColumns)
                    {
                        plvdi->item.cColumns = 0;
                        plvdi->item.puColumns = NULL;
                    }
                }
            }

        }

        if (plvdi->item.iSubItem == 0)
            plvdi->item.mask |= LVIF_DI_SETITEM;    // always store the name
    }
    return 0;
}

int CALLBACK GroupCompare(int iGroup1, int iGroup2, void *pvData)
{
    ICategorizer* pcat = (ICategorizer*)pvData;

    HRESULT hr = pcat->CompareCategory(CATSORT_DEFAULT, (DWORD)iGroup1, (DWORD)iGroup2);

    return ShortFromResult(hr);
}

void CDefView::_OnCategoryTaskAdd()
{
    _fInBackgroundGrouping = TRUE;
    _GlobeAnimation(TRUE);
    _ShowSearchUI(TRUE);
}

void CDefView::_OnCategoryTaskDone()
{
    _fInBackgroundGrouping = FALSE;
    _GlobeAnimation(FALSE);
    _ShowSearchUI(FALSE);
    if (_pidlSelectAndPosition)
    {
        POINT pt = {0};     // Don't care: Groups don't have a position

        SelectAndPositionItem(_pidlSelectAndPosition, _uSelectAndPositionFlags, &pt);

        Pidl_Set(&_pidlSelectAndPosition, NULL);
        _uSelectAndPositionFlags = 0;
    }
}

DWORD CDefView::_GetGroupForItem(int iItem, LPCITEMIDLIST pidl)
{
    DWORD dwGroup = I_GROUPIDNONE;
    if (_fGroupView)
    {
        if (_fSlowGroup)
        {
            UINT uId = ListView_MapIndexToID(_hwndListview, iItem);
            IRunnableTask* pTask;
            if (SUCCEEDED(CCategoryTask_Create(this, pidl, uId, &pTask)))
            {
                // Need to get the globe/search stuff kicked off while within the CreateViewWindow2 call,
                // so do it here instead of a posted message in the above constructor
                _OnCategoryTaskAdd();

                _AddTask(pTask, TOID_DVBackgroundGroup, 0, TASK_PRIORITY_GROUP, ADDTASK_ATEND);
                pTask->Release();
            }
        }
        else
        {
            _pcat->GetCategory(1, (LPCITEMIDLIST*)&pidl, &dwGroup);
            if (!ListView_HasGroup(_hwndListview, dwGroup))
            {
                CATEGORY_INFO ci;
                _pcat->GetCategoryInfo(dwGroup, &ci);

                LVINSERTGROUPSORTED igrp;
                igrp.pfnGroupCompare = GroupCompare;
                igrp.pvData = (void *)_pcat;
                igrp.lvGroup.cbSize = sizeof(LVGROUP);
                igrp.lvGroup.mask = LVGF_HEADER | LVGF_GROUPID;
                igrp.lvGroup.pszHeader= ci.wszName;
                igrp.lvGroup.iGroupId = (int)dwGroup;

                ListView_InsertGroupSorted(_hwndListview, &igrp);
            }
        }
    }

    return dwGroup;
}

BOOL CDefView::_EnsureSCIDCache()
{
    BOOL bRet = FALSE;
    if (_hdsaSCIDCache)
    {
        bRet = TRUE;
    }
    else if (_pshf2)
    {
        _hdsaSCIDCache = DSA_Create(sizeof(SHCOLUMNID), 30);
        if (_hdsaSCIDCache)
        {
            SHCOLUMNID scid;

            for (UINT iCol = 0; SUCCEEDED(_pshf2->MapColumnToSCID(iCol, &scid)); iCol++)
            {
                // ignore failure, just means we can't find the thing
                DSA_AppendItem(_hdsaSCIDCache, &scid);
            }
            bRet = TRUE;
        }
    }
    return bRet;
}

BOOL CDefView::_MapSCIDToColumn(const SHCOLUMNID *pscid, UINT *pnColumn)
{
    BOOL bRet = FALSE;
    *pnColumn = 0;
    if (_EnsureSCIDCache())
    {
        UINT cCol = DSA_GetItemCount(_hdsaSCIDCache);

        for (UINT iCol = 0; iCol < cCol; iCol++)
        {
            SHCOLUMNID scid;
            DSA_GetItem(_hdsaSCIDCache, iCol, &scid);
            if (IsEqualSCID(*pscid, scid))
            {
                *pnColumn = iCol;
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

HRESULT CDefView::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

HRESULT CDefView::_PeekColumnsCache(PTSTR pszPath, LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns)
{
    TCHAR szPath[MAX_PATH];
    if (pszPath == NULL)
        pszPath = szPath;

    // NOTE - need to replace this with GetDetailsEx(SCID_CANONICALTYPE) to support
    // caching properly.  then we dont need to sniff attributes or the name in order to get
    // a nice caching index.
    HRESULT hr = DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, pszPath, MAX_PATH);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszExt = _Attributes(pidl, SFGAO_FOLDER) ? NULL : PathFindExtension(pszPath);

        hr = E_FAIL;

        // Check file table cache:
        ENTERCRITICAL;
        SHCOLUMNID *pscidCached;
        UINT cSCIDCached = pszExt ? LookupFileSCIDs(pszExt, &pscidCached) : 0; //Handle no extension case by not looking up in cache
        LEAVECRITICAL;

        if (cSCIDCached) // Found the SCIDs cache in the file table
        {
            UINT nFilled = 0;
            // Found it... we don't need to check the registry
            for (UINT nSCID = 0; nSCID < cSCIDCached && nFilled < *pcColumns; nSCID++)
            {
                if (_MapSCIDToColumn(&pscidCached[nSCID], &rguColumns[nFilled]))
                    nFilled++;
            }
            *pcColumns = nFilled;
            LocalFree(pscidCached);

            hr = S_OK;
        }
    }

    return hr;

}

// Get the important columns for this guy, based on file extension
// pidl:        The pidl of the item in question
// puColumns[]: The array which will get filled with important column indicies
// pcColumns    IN: specifies how big rguColumns[] is. OUT: specified how many slots got filled.
HRESULT CDefView::_GetImportantColumns(LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns)
{
    TCHAR szPath[MAX_PATH];

    // We need to ensure that the columns are loaded here
    if (!_bLoadedColumns)
    {
        DWORD_PTR lRes = 0;
        if (!SendMessageTimeout(_hwndView, WM_DSV_ENSURE_COLUMNS_LOADED, 0, 0, SMTO_NORMAL, 5000, &lRes) || lRes == 0)
            return E_FAIL;
    }

    HRESULT hr = _PeekColumnsCache(szPath, pidl, rguColumns, pcColumns);
    if (FAILED(hr))
    {
        IQueryAssociations *pqa;
        hr = _pshf->GetUIObjectOf(_hwndMain, 1, &pidl, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            IPropertyUI *ppui;
            hr = _GetPropertyUI(&ppui);
            if (SUCCEEDED(hr))
            {
                TCHAR szProps[INFOTIPSIZE];
                DWORD cchOut = ARRAYSIZE(szProps);
                hr = pqa->GetString(0, ASSOCSTR_TILEINFO, NULL, szProps, &cchOut);
                if (SUCCEEDED(hr))
                {
                    UINT cNumColumns = 0;       // # of items in rguColumns
                    UINT cSCID = 0;             // # of items in rgscid
                    SHCOLUMNID rgscid[64];      // reasonable upper bound

                    ULONG chEaten = 0;          // loop variable ParsePropertyName updates this
                    while ((cSCID < ARRAYSIZE(rgscid)) &&
                           SUCCEEDED(ppui->ParsePropertyName(szProps, &rgscid[cSCID].fmtid, &rgscid[cSCID].pid, &chEaten)))
                    {
                        // Map SCID to a column (while there are more column slots)
                        if ((cNumColumns < *pcColumns) &&
                            _MapSCIDToColumn(&rgscid[cSCID], &rguColumns[cNumColumns]))
                        {
                            cNumColumns++;
                            cSCID++;
                        }
                    }
                    *pcColumns = cNumColumns;

                    LPCWSTR pszExt = _Attributes(pidl, SFGAO_FOLDER) ? NULL : PathFindExtension(szPath);
                    if (pszExt)
                    {
                        // cache for future use, except if there's no extension (cache key)
                        ENTERCRITICAL;
                        AddFileSCIDs(pszExt, rgscid, cSCID);
                        LEAVECRITICAL;
                    }
                }
                ppui->Release();
            }
            pqa->Release();
        }
    }
    return hr;
}

void CDefView::_FixupColumnsForTileview(UINT *rguColumns, UINT cColumns)
{
    // Make sure these columns are added to listview (ie. visible).
    // And then map the columns in rguColumns from real columns to visible columns
    for (UINT i = 0; i < cColumns; i++)
    {
        _AddTileColumn(rguColumns[i]);
    }

    // Now, also add the sorted by column, if it hasn't been added yet.
    if (!_fSetTileViewSortedCol)
    {
        _fSetTileViewSortedCol = TRUE;
        // It's ok if we don't actually set it.  It's the thought that counts.

        if (_vs._lParamSort != -1)
        {
            _AddTileColumn(_vs._lParamSort);

            // And set it selected, if we're not in groupview
            if (!_fGroupView)
            {
                ListView_SetSelectedColumn(_hwndListview, _RealToVisibleCol(_vs._lParamSort));
            }
        }
    }

    // This must be done after all the _AddTileColumns, or else the visible col #'s will be off.
    for (UINT i = 0; i < cColumns; i++)
    {
        rguColumns[i] = _RealToVisibleCol(rguColumns[i]);
    }
}

void CDefView::_SetImportantColumns(CBackgroundTileInfo *pbgTileInfo)
{
    UINT cColumns = pbgTileInfo->GetColumnCount();
    UINT *rguColumns = pbgTileInfo->GetColumns();

    LVTILEINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.cColumns = cColumns;
    ti.puColumns = rguColumns;
    ti.iItem = ListView_MapIDToIndex(_hwndListview, pbgTileInfo->GetId());
    if (ti.iItem != -1)
    {
        _FixupColumnsForTileview(rguColumns, cColumns);
        // have the listview store the per item tile info that we have computed
        ListView_SetTileInfo(_hwndListview, &ti);
    }

    delete pbgTileInfo;
}

// Ensures if we're in tileview, that the tileviewinfo is set.
void CDefView::_SetView(UINT fvm)
{
    // Update our internal state
    _fs.ViewMode = fvm;

    // Map the ViewMode into a listview mode
    DWORD iView = LV_VIEW_ICON;
    // Now switch the listview
    switch (fvm)
    {
    case FVM_ICON:
    case FVM_SMALLICON:
    case FVM_THUMBNAIL:
    case FVM_THUMBSTRIP:
        iView = LV_VIEW_ICON;
        break;

    case FVM_LIST:
        iView = LV_VIEW_LIST;
        break;

    case FVM_TILE:
        iView = LV_VIEW_TILE;
        break;

    case FVM_DETAILS:
        iView = LV_VIEW_DETAILS;
        break;

    default:
        ASSERTMSG(FALSE, "_SetView got an invalid ViewMode!");
        break;
    }

    if (iView == LV_VIEW_TILE)
    {
        RECT rcLabelMargin = {1, 1, 1, 1}; // This gives us some room around the label, so the focus rect doesn't clip part of the text
        LVTILEVIEWINFO lvtvi = {0};
        lvtvi.cbSize = sizeof(lvtvi);
        lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS | LVTVIM_LABELMARGIN;
        lvtvi.dwFlags = LVTVIF_AUTOSIZE;
        lvtvi.cLines = TILEVIEWLINES;
        lvtvi.rcLabelMargin = rcLabelMargin;
        ListView_SetTileViewInfo(_hwndListview, &lvtvi);
    }
    ListView_SetView(_hwndListview, iView);
    _FireEvent(DISPID_VIEWMODECHANGED);
}

// rename the selection based on the new name for the renamed item
// this makes it easy to rename groups of files to a common base name
 
HRESULT CDefView::_DoBulkRename(LPCITEMIDLIST pidlNewName)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = _GetItemObjects(&apidl, SVGIO_SELECTION, &cItems);
    if (SUCCEEDED(hr))
    {
        if (cItems > 1)     // only interesting if more than 1
        {
            TCHAR szBase[MAX_PATH]; // seed file name used to generate other names
            hr = DisplayNameOf(_pshf, pidlNewName, SHGDN_INFOLDER | SHGDN_FORPARSING, szBase, ARRAYSIZE(szBase));
            if (SUCCEEDED(hr))
            {
                if (!SHGetAttributes(_pshf, pidlNewName, SFGAO_FOLDER))
                    PathRemoveExtension(szBase);    // remove the extension, if it is a file

                UINT cBase = 1;     // one based counter, start at "File (1)"

                // if input contains (#) use that as the sequence # base
                LPWSTR psz = StrChr(szBase, TEXT('('));
                if (psz)
                {
                    cBase = StrToInt(psz + 1) + 1;      // start at this in sequence
                    *psz = 0;                           // remove the (#) from the base name
                }

                PathRemoveBlanks(szBase);               // clean away leading/trailing blanks

                // start at 1, skipping the focused item, renaming all others in the array
                for (UINT i = 1; (i < cItems) && SUCCEEDED(hr); i++)
                {
                    TCHAR szOld[MAX_PATH];

                    hr = DisplayNameOf(_pshf, apidl[i], SHGDN_INFOLDER | SHGDN_FORPARSING, szOld, ARRAYSIZE(szOld));
                    if (SUCCEEDED(hr))
                    {
                        // Clone the pidl since isf->SetNameOf can result in synchronous update item
                        // that can free the ListView owned apidl[i].
                        LPITEMIDLIST pidlOldName = ILClone(apidl[i]);
                        if (pidlOldName)
                        {
                            // if the new name we produce conflicts with a name that
                            // already exists we will retry up to 100 times
                            for (UINT cRetry = 0; cRetry < 100; cRetry++)
                            {
                                WCHAR szName[MAX_PATH];
                                wnsprintf(szName, ARRAYSIZE(szName), TEXT("%s (%d)%s"), szBase, cBase, PathFindExtension(szOld));

                                hr = _pshf->SetNameOf(NULL, pidlOldName, szName, SHGDN_INFOLDER | SHGDN_FORPARSING, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    // force sync change notify update to make sure
                                    // all renames come through (avoid UPDATEDIR)
                                    SHChangeNotifyHandleEvents();
                                    cBase++;
                                    break;  // did this one successfully
                                }
                                else if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr ||
                                        HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
                                {
                                    cBase++;
                                    hr = S_OK;  // and keep trying
                                }
                                else
                                {
                                    break;      // other error, exit
                                }
                            }

                            ILFree(pidlOldName);
                        }
                    }
                }
            }
        }
        LocalFree(apidl);
    }
    return hr;
}


LRESULT CDefView::_OnLVNotify(NM_LISTVIEW *plvn)
{
    switch (plvn->hdr.code)
    {
    case NM_KILLFOCUS:
        // force update on inactive to not ruin save bits
        _OnStateChange(CDBOSC_KILLFOCUS);
        if (GetForegroundWindow() != _hwndMain)
            UpdateWindow(_hwndListview);
        _fHasListViewFocus = FALSE;
        _EnableDisableTBButtons();
        break;

    case NM_SETFOCUS:
    {
        if (!_fDestroying)
        {
            if (_cFrame.IsWebView())   // Do OLE stuff
            {
                UIActivate(SVUIA_ACTIVATE_FOCUS);
            }
            else
            {
                //  We should call IShellBrowser::OnViewWindowActive() before
                // calling its InsertMenus().
                _OnViewWindowActive();
                _OnStateChange(CDBOSC_SETFOCUS);
                OnActivate(SVUIA_ACTIVATE_FOCUS);
                _FocusOnSomething();
                _UpdateStatusBar(FALSE);
            }
            _fHasListViewFocus = TRUE;
            _EnableDisableTBButtons();
        }
        break;
    }

    case NM_RCLICK:
        // on the shift+right-click case we want to deselect everything and select just our item if it is
        // not already selected. if we dont do this, then listview gets confused (because he thinks
        // shift means extend selection, but in the right click case it dosent!) and will bring up the
        // context menu for whatever is currently selected instead of what the user just right clicked on.
        if ((GetKeyState(VK_SHIFT) < 0) &&
            (plvn->iItem >= 0)          &&
            !(ListView_GetItemState(_hwndListview, plvn->iItem, LVIS_SELECTED) & LVIS_SELECTED))
        {
            // clear any currently slected items
            ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);

            // select the guy that was just right-clicked on
            ListView_SetItemState(_hwndListview, plvn->iItem, LVIS_SELECTED, LVIS_SELECTED);
        }
        break;

    case LVN_ENDSCROLL:
        {
            // This means we're scrolling.  Ignore requests for LVIF_COLUMNS while we're
            // scrolling to speed things up.

            // We don't want to ignore requests for LVIF_COLUMNS when we're owner data, because
            // owner data listviews always callback for info on what to display.  (The result would
            // be already-present tileinfo vanishing while scrolling, since we'd be ignoring requests
            // for what to display)
            if ((_fs.ViewMode == FVM_TILE) && !_IsOwnerData())
            {
                SetTimer(_hwndView, DV_IDTIMER_SCROLL_TIMEOUT, 250, NULL);

                if (!_fScrolling)
                {
                    _fScrolling = TRUE;

                    // We don't reset this on every LVN_ENDSCROLL - only if this is the first time
                    // we've scrolled since a stable (non-scrolling) state
                    _fRequestedTileDuringScroll = FALSE;
                }
            }
        }
        break;

    case LVN_GETINFOTIP:
        _OnGetInfoTip((NMLVGETINFOTIP *)plvn);
        break;

    case LVN_ITEMACTIVATE:
        if (!_fDisabled)
        {
            //in win95 if user left clicks on one click activate icon and then right
            //clicks on it (within double click time interval), the icon is launched
            //and context menu appears on top of it -- it does not disappear.
            //furthermore the context menu cannot be destroyed but stays on top of
            //any window and items on it are not accessible. to avoid this
            //send cancel mode to itself to destroy context before the icon is
            //launched
            if (_hwndView)
                SendMessage(_hwndView, WM_CANCELMODE, 0, 0);

            _InvokeContextMenuVerbOnSelection(NULL, ((NMITEMACTIVATE *)plvn)->uKeyFlags, CMIC_MASK_FLAG_LOG_USAGE);
        }
        break;

    case NM_CUSTOMDRAW:
        {
            LPNMLVCUSTOMDRAW pcd = (LPNMLVCUSTOMDRAW)plvn;

            switch (pcd->nmcd.dwDrawStage)
            {
            case CDDS_PREPAINT:
                {
                    return _fShowCompColor ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;
                }
                
            case CDDS_ITEMPREPAINT:
                {
                    LRESULT lres = CDRF_DODEFAULT;
                    LPCITEMIDLIST pidl = _GetPIDLParam(pcd->nmcd.lItemlParam, (int)pcd->nmcd.dwItemSpec);
                    if (pidl)
                    {
                        DWORD dwAttribs = _Attributes(pidl, SFGAO_COMPRESSED | SFGAO_ENCRYPTED);

                        // only one or the other, can never be both
                        if (dwAttribs & SFGAO_COMPRESSED)
                        {
                            // default value of Blue
                            pcd->clrText = GetRegColor(RGB(0, 0, 255), TEXT("AltColor"), &g_crAltColor);
                        }
                        else if (dwAttribs & SFGAO_ENCRYPTED)
                        {
                            // default value Luna Mid Green
                            pcd->clrText = GetRegColor(RGB(19, 146, 13), TEXT("AltEncryptionColor"), &g_crAltEncryptedColor);
                        }
                    }
                    if (_IsImageMode() && pcd->nmcd.hdc && (_dwRecClrDepth <= 8))
                    {
                        HPALETTE hpal = NULL;
                        if (SUCCEEDED(_GetBrowserPalette(&hpal)))
                        {
                            // Since we are a child of the browser, we should always take a back seat to thier palette selection
                            _hpalOld = SelectPalette(pcd->nmcd.hdc, hpal, TRUE);
                            RealizePalette(pcd->nmcd.hdc);
                            lres |= CDRF_NOTIFYPOSTPAINT;
                        }
                    }
                    return lres;
                }

            case CDDS_ITEMPOSTPAINT:
                if (_IsImageMode() && _hpalOld && pcd->nmcd.hdc)
                {
                    SelectPalette(pcd->nmcd.hdc, _hpalOld, TRUE);
                    _hpalOld = NULL;
                }
                break;
            }
        }
        return CDRF_DODEFAULT;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        if (_fDisabled)
            return FALSE;   /* commdlg doesn't want user dragging */
        return _OnBeginDrag(plvn);

    case LVN_ITEMCHANGING:
        if (_fDisabled)
            return TRUE;
        break;

    // Something changed in the listview.  Delete any data that
    // we might have cached away.

    case LVN_ITEMCHANGED:
        if (plvn->uChanged & LVIF_STATE)
        {
            if (!_fIgnoreItemChanged)
            {
                // The rest only cares about SELCHANGE messages (avoid LVIS_DRAGSELECT, etc)
                if ((plvn->uNewState ^ plvn->uOldState) & (LVIS_SELECTED | LVIS_FOCUSED))
                {
                    //if we are the drag source then dont send selection change message
                    if (!_bDragSource)
                    {
                        _OnStateChange(CDBOSC_SELCHANGE);
                    }

                    OnLVSelectionChange(plvn);
                }
                else if ((plvn->uNewState ^ plvn->uOldState) & (LVIS_STATEIMAGEMASK))
                {
                    if (!_bDragSource)
                    {
                        _OnStateChange(CDBOSC_STATECHANGE);
                    }
                }
            }
        }
        break;


    // owner data state changed: e.g. search results
    case LVN_ODSTATECHANGED:
        {
            NM_ODSTATECHANGE *pnm = (NM_ODSTATECHANGE *)plvn;

            // for now handle only selection changes
            if ((pnm->uOldState ^ pnm->uNewState) & (LVIS_SELECTED | LVIS_FOCUSED))
            {
                _OnLVSelectionChange(-1, pnm->uOldState, pnm->uNewState, 0);
            }
        }
        break;

    case LVN_DELETEITEM:
        OnListViewDelete(plvn->iItem, (LPITEMIDLIST)plvn->lParam, TRUE);
        break;

    case LVN_COLUMNCLICK:
        // allow clicking on columns to set the sort order
        if (_fGroupView)
        {
            BOOL fAllowArrange = TRUE;
            UINT iRealColumn = _VisibleToRealCol(plvn->iSubItem);
            SHCOLUMNID scid;
            if (SUCCEEDED(_pshf2->MapColumnToSCID(iRealColumn, &scid)))
            {
                ICategoryProvider* pcp = NULL;
                if (SUCCEEDED(_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
                {
                    // returns S_FALSE to remove.
                    if (S_FALSE == pcp->CanCategorizeOnSCID(&scid))
                    {
                        fAllowArrange = FALSE;
                    }
                }
            }

            if (fAllowArrange)
                _ArrangeBy(iRealColumn + SFVIDM_GROUPSFIRST);
        }
        else if (_pshf2 || _psd || HasCB())
        {
            LPARAM lParamSort       = _vs._lParamSort;
            LONG iLastColumnClick   = _vs._iLastColumnClick,
                 iLastSortDirection = _vs._iDirection;  // push sort state

            // Folder doesn't know which columns are on or off, so communication with folder uses real col #s
            UINT iRealColumn = _VisibleToRealCol(plvn->iSubItem);

            // seeral ways to do this... each can defer to the
            // ultimate default that is defview calling itself.
            HRESULT hr = S_FALSE;
            if (_psd)
                hr = _psd->ColumnClick(iRealColumn);

            if (hr != S_OK)
                hr = CallCB(SFVM_COLUMNCLICK, iRealColumn, 0);

            if (hr != S_OK)
                hr = Rearrange(iRealColumn);

            // Allows iLastColumnClick to stay valid during the above calls
            if (SUCCEEDED(hr))
                _vs._iLastColumnClick = iRealColumn;
            else
            {
                //  We failed somewhere so pop the sort state.
                _vs._iDirection = iLastSortDirection;
                _vs._iLastColumnClick = (int)_vs._lParamSort;
                _vs._lParamSort = lParamSort ;
                _SetSortFeedback();
                _vs._iLastColumnClick = iLastColumnClick;
            }
        }
        break;

    case LVN_KEYDOWN:
        HandleKeyDown(((LV_KEYDOWN *)plvn));
        break;

#define plvdi ((LV_DISPINFO *)plvn)

    case LVN_BEGINLABELEDIT:
        {
            LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);

            if (!pidl || !_Attributes(pidl, SFGAO_CANRENAME))
            {
                MessageBeep(0);
                return TRUE;        // Don't allow label edit
            }

            _fInLabelEdit = TRUE;

            HWND hwndEdit = ListView_GetEditControl(_hwndListview);
            if (hwndEdit)
            {
                int cchMax = 0;

                CallCB(SFVM_GETCCHMAX, (WPARAM)pidl, (LPARAM)&cchMax);

                if (cchMax)
                {
                    ASSERT(cchMax < 1024);
                    SendMessage(hwndEdit, EM_LIMITTEXT, cchMax, 0);
                }

                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FOREDITING, szName, ARRAYSIZE(szName))))
                {
                    SetWindowText(hwndEdit, szName);
                }

                SHLimitInputEdit(hwndEdit, _pshf);
            }
        }
        break;

    case LVN_ENDLABELEDIT:

        _fInLabelEdit = FALSE;
        if (plvdi->item.pszText)
        {
            LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);
            if (pidl)
            {
                // this set site is questionable as folder should not have any state
                // associated with the view. but this is needed for FTP so it can
                // do an EnableModless for it's UI
                IUnknown_SetSite(_pshf, SAFECAST(this, IOleCommandTarget *));

                // Clone the pidl since isf->SetNameOf can result in a synchronous update item that
                // will free the listview owned pidl.
                LPITEMIDLIST pidlOldName = ILClone(pidl);
                if (pidlOldName)
                {
                    LPITEMIDLIST pidlNewName = NULL;    // paranoid about bad SetNameOf() impls
                    if (SUCCEEDED(_pshf->SetNameOf(_hwndMain, pidlOldName, plvdi->item.pszText, SHGDN_INFOLDER, &pidlNewName)))
                    {
                        ASSERT(NULL != pidlNewName);    // folders need to implement this
                        if (pidlNewName)
                        {
                            _DoBulkRename(pidlNewName);
                            ILFree(pidlNewName);
                        }

                        SHChangeNotifyHandleEvents();
                        _OnStateChange(CDBOSC_RENAME);
                    }
                    else
                    {
                        SendMessage(_hwndListview, LVM_EDITLABEL, plvdi->item.iItem, (LPARAM)plvdi->item.pszText);
                    }

                    ILFree(pidlOldName);
                }

                IUnknown_SetSite(_pshf, NULL);
            }
        }
        else
        {
            // The user canceled. so return TRUE to let things like the mouse
            // click be processed.
            return TRUE;
        }
        break;

    case LVN_GETDISPINFO:
        return _GetDisplayInfo(plvdi);

    case LVN_ODFINDITEM:
        // We are owner data so we need to find the item for the user...
        {
            int iItem = -1;
            if (SUCCEEDED(CallCB(SFVM_ODFINDITEM, (WPARAM)&iItem, (LPARAM)plvn)))
                return iItem;
            return -1;  // Not Found
        }

    case LVN_ODCACHEHINT:
        // Just a hint we don't care about return values
        CallCB(SFVM_ODCACHEHINT, 0, (LPARAM)plvn);
        break;

    case LVN_GETEMPTYTEXT:
        if (HasCB())
        {
            if ((plvdi->item.mask & LVIF_TEXT) &&
                SUCCEEDED(CallCB(SFVM_GETEMPTYTEXT, (WPARAM)(plvdi->item.cchTextMax), (LPARAM)(plvdi->item.pszText))))
                return TRUE;
        }
        break;

    }
#undef lpdi
#undef plvdi
    return 0;
}

// FEATURE -- implement enabling/disabling of other toolbar buttons.  We can enable/disable
// based on the current selection, but the problem is that some of the buttons work
// for other guys when defview doesn't have focus.  Specifically, cut/copy/paste work
// for the folders pane.  If we're going to enable/disable these buttons based on the
// selection, then we'll need to have a mechanism that lets the active band (such as
// folders) also have a say about the button state.  That is too much work right now.

static const UINT c_BtnCmds[] =
{
    SFVIDM_EDIT_COPYTO,
    SFVIDM_EDIT_MOVETO,
#ifdef ENABLEDISABLEBUTTONS
    SFVIDM_EDIT_COPY,
    SFVIDM_EDIT_CUT,
#endif
};

static const DWORD c_BtnAttr[] =
{
    SFGAO_CANCOPY,
    SFGAO_CANMOVE,
#ifdef ENABLEDISABLEBUTTONS
    SFGAO_CANCOPY,
    SFGAO_CANMOVE,
#endif
};

#define SFGAO_RELEVANT      (SFGAO_CANCOPY | SFGAO_CANMOVE)

// Description:
//  Called by toolbar infrastructure to determine whether to display a given
//  toolbar button in the "enabled" or "disabled" state.
//
// Return:
//  TRUE    display toolbar button in enabled state
//  FALSE   display toolbar button in disabled state
//
BOOL CDefView::_ShouldEnableToolbarButton(UINT uiCmd, DWORD dwAttr, int iIndex)
{
    COMPILETIME_ASSERT(sizeof(c_BtnCmds) == sizeof(c_BtnAttr));

    BOOL bEnable;

    switch (uiCmd)
    {
        case SFVIDM_VIEW_VIEWMENU:
            bEnable = !_fBarrierDisplayed;
            break;

        default:
        {
            DWORD dwBtnAttr;

            if (iIndex != -1)
            {
                // Caller was nice and figured out dest index for us
                dwBtnAttr = c_BtnAttr[iIndex];
            }
            else
            {
                // Look for the command ourselves
                dwBtnAttr = SHSearchMapInt((int*)c_BtnCmds, (int*)c_BtnAttr, ARRAYSIZE(c_BtnCmds), uiCmd);
                if (dwBtnAttr == -1)
                {
                    // We don't care about this button, just enable it.
                    return TRUE;
                }
            }

            // Disable any button we care about while listview is inactive.
            bEnable = BOOLIFY(dwAttr & dwBtnAttr) && _fHasListViewFocus;
            break;
        }
    }

    return bEnable;
}

// As a perf enhancement, we cache the attributes of the currently selected
// files/folders in a FS view only.  This is to avoid n^2 traversals of the
// selected items as we select/unselect them.  These cached attributes
// should not be used for anything other than determining toolbar button
// states and should be revisited if we add toolbar buttons that care about
// much more than the attributes used by Move to & Copy to.

BOOL CDefView::_GetCachedToolbarSelectionAttrs(ULONG *pdwAttr)
{
    BOOL fResult = FALSE;
    CLSID clsid;
    HRESULT hr = IUnknown_GetClassID(_pshf, &clsid);
    if (SUCCEEDED(hr) && IsEqualGUID(CLSID_ShellFSFolder, clsid))
    {
        UINT iCount;
        if (SUCCEEDED(GetSelectedCount(&iCount)) &&
            (iCount > 0) && (_uCachedSelCount > 0))
        {
            *pdwAttr = _uCachedSelAttrs;
            fResult = TRUE;
        }
    }
    return fResult;
}

void CDefView::_SetCachedToolbarSelectionAttrs(ULONG dwAttrs)
{
    if (SUCCEEDED(GetSelectedCount(&_uCachedSelCount)))
        _uCachedSelAttrs = dwAttrs;
    else
        _uCachedSelCount = 0;
}

void CDefView::_EnableDisableTBButtons()
{
    if (!IsEqualGUID(_clsid, GUID_NULL))
    {
        IExplorerToolbar *piet;
        if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            ULONG dwAttr;

            if (!_GetCachedToolbarSelectionAttrs(&dwAttr))
                dwAttr = _AttributesFromSel(SFGAO_RELEVANT);

            for (int i = 0; i < ARRAYSIZE(c_BtnCmds); i++)
                _EnableToolbarButton(piet, c_BtnCmds[i], _ShouldEnableToolbarButton(c_BtnCmds[i], dwAttr, i));

            _SetCachedToolbarSelectionAttrs(dwAttr);

            piet->Release();
        }
    }
}


// Description:
//  Enables or disables a specified button on the toolbar.
//
void CDefView::EnableToolbarButton(UINT uiCmd, BOOL bEnable)
{
    if (!IsEqualGUID(_clsid, GUID_NULL))
    {
        IExplorerToolbar *piet;

        if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            _EnableToolbarButton(piet, uiCmd, bEnable);
            piet->Release();
        }
    }
}


// Description:
//  Enables or disables a specified button on the toolbar.
//
// Note:
//  This is an _internal_ method only.
//  External calls should use EnableToolbarButton().
//  Caller is responsible for ensuring this object uses IExplorerToolbar mechanism.
//
void CDefView::_EnableToolbarButton(IExplorerToolbar *piet, UINT uiCmd, BOOL bEnable)
{
    ASSERT(!IsEqualGUID(_clsid, GUID_NULL));    // Required or piet cannot be valid.
    ASSERT(piet);                               // Required or we're not using IExplorerToolbar mechanism.

    UINT uiState;

    if (SUCCEEDED(piet->GetState(&_clsid, uiCmd, &uiState)))
    {
        if (bEnable)
            uiState |= TBSTATE_ENABLED;
        else
            uiState &= ~TBSTATE_ENABLED;

        piet->SetState(&_clsid, uiCmd, uiState);
    }
}


void CDefView::_OnContentsChanged()
{
    // use a timer to delay sending a gazillion content change messages to automation.
    // todo: see what duiview has to do with this stuff.

    // only fire event if someone is listening
    if (_pauto || _pDUIView)
    {
        // delay for 100ms
        SetTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED, 100, NULL);
    }
    if (!_pDUIView)
    {
        _fRcvdContentsChangeBeforeDuiViewCreated = TRUE;
    }
}

void CDefView::_OnDelayedContentsChanged()
{
    KillTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED);

    // update dui, would be better if there were different handlers in CDUIView
    // but go through selection changed for now.
    ATOMICRELEASE(_pSelectionShellItemArray);

    _pSelectionShellItemArray = _CreateSelectionShellItemArray();

    if (_pDUIView)
    {
        if (_fBarrierDisplayed != _QueryBarricadeState())
        {
            //
            // Yet another DUI special-case.
            // If the barrier state has changed, we need to 
            // tell DUIView about it so that the DUI right-pane
            // content is reconstructed.  This is required to make
            // Control Panel update it's right-pane content when
            // webview is turned on/off.
            //
            _fBarrierDisplayed = !_fBarrierDisplayed;
            _pDUIView->EnableBarrier (_fBarrierDisplayed);
        }
        _pDUIView->OnContentsChange(_pSelectionShellItemArray);
    }

    _FireEvent(DISPID_CONTENTSCHANGED);
}

// WARNING: don't add any code here that is expensive in anyway!
// we get many many of these notifies and if we slow this routine down
// we mess select all and large selection perf.
//
// you can add expensive code to the WM_DSV_SENDSELECTIONCHANGED handler _OnSelectionChanged,
// that happens after all of the sel change notifies go through.
//
// or you can add really expensive code to the double-click-timeout delayed _OnDelayedSelectionChange.
//
void CDefView::OnLVSelectionChange(NM_LISTVIEW *plvn)
{
    _OnLVSelectionChange(plvn->iItem, plvn->uOldState, plvn->uNewState, plvn->lParam);
}

void CDefView::_OnLVSelectionChange(int iItem, UINT uOldState, UINT uNewState, LPARAM lParam)
{
    // Do selection changed stuff on a selection change only
    if ((uOldState ^ uNewState) & LVIS_SELECTED)
    {
        // Tell the defview client that the selection may have changed
        SFVM_SELCHANGE_DATA dvsci;

        dvsci.uNewState = uNewState;
        dvsci.uOldState = uOldState;
        dvsci.lParamItem = lParam;

        CallCB(SFVM_SELCHANGE, MAKEWPARAM(SFVIDM_CLIENT_FIRST, iItem), (LPARAM)&dvsci);
    }

    // Notify the dispach that the focus changed..
    _PostSelectionChangedMessage(uOldState ^ uNewState);
}

void CDefView::_PostSelectionChangedMessage(UINT uSelectionStateChanged)
{
    if (!_fSelectionChangePending)
    {
        _uSelectionStateChanged = uSelectionStateChanged;

        // RACE CONDITION FIX (edwardp & buzzr)
        //  It is imperative to set _fSelectionChangePending _before_ posting
        //  WM_DSV_SENDSELECTIONCHANGED.  Otherwise, a race condition ensues
        //  whereby we could handle the message via _OnSelectionChanged()
        //  whose first line sets _fSelectionChangePending = FALSE before we
        //  have set it to TRUE here.  This means _fSelectionChangePending
        //  will never again be set to FALSE (since the this thread will be
        //  rescheduled, set it to TRUE, and the action of clearing it will
        //  already be past).  This was happening with 100% reproducability
        //  with our background CGetCommandStateTask for WIA devices.  The
        //  symptom most noticeable was that the DUI pane (task lists and
        //  details) no longer updated with each selection change.
        _fSelectionChangePending = TRUE;
        PostMessage(_hwndView, WM_DSV_SENDSELECTIONCHANGED, 0, 0);
    }
    else
    {
        _uSelectionStateChanged |= uSelectionStateChanged;
    }
}

void CDefView::_OnSelectionChanged() // handles WM_DSV_SENDSELECTIONCHANGED
{
    _fSelectionChangePending = FALSE; // release this first so code we call doesn't think we're "pending" any more

    if (_uSelectionStateChanged & LVIS_SELECTED)
    {
        // Get and cache the data object for the current selection
        ATOMICRELEASE(_pSelectionShellItemArray);
        _pSelectionShellItemArray = _CreateSelectionShellItemArray();

        // Update DUIView
        if (_pDUIView)
            _pDUIView->OnSelectionChange(_pSelectionShellItemArray);

        _UpdateStatusBar(FALSE);
        _EnableDisableTBButtons();
    }

    // Only fire selection change events if someone is listening
    // and if the selection changed event was not caused by going into Edit mode (why?)
    if (_pauto && !_fInLabelEdit)
    {
        // Send out the selection changed notification to the automation after a delay.
        if (!_bAutoSelChangeTimerSet)
        {
            _bAutoSelChangeTimerSet = TRUE;
            _uAutoSelChangeState = _uSelectionStateChanged;
        }
        else
        {
            _uAutoSelChangeState |= _uSelectionStateChanged;
        }

        // But not too long, since parts of our UI update when they receive this event.
        // (Update the timer every time to keep delaying it during rapid selection change events)
        SetTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE, GetDoubleClickTime()/2, NULL);
    }
}

void CDefView::_OnDelayedSelectionChange() // handles DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE
{
    if (_bAutoSelChangeTimerSet)
    {
        KillTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE);

        if (_uAutoSelChangeState & LVIS_SELECTED)
            _FireEvent(DISPID_SELECTIONCHANGED);

        if (_uAutoSelChangeState & LVIS_FOCUSED)
            _FireEvent(DISPID_FOCUSCHANGED);

        _bAutoSelChangeTimerSet = FALSE;
    }
}

void CDefView::_PostNoItemStateChangedMessage()
{
    if (_pauto && !_fNoItemStateChangePending)
    {
        PostMessage(_hwndView, WM_DSV_SENDNOITEMSTATECHANGED, 0, 0);
        _fNoItemStateChangePending = TRUE;
    }
}

void CDefView::_OnNoItemStateChanged()
{
    _FireEvent(DISPID_NOITEMSTATE_CHANGED);
    _fNoItemStateChangePending = FALSE;
}

void CDefView::_PostEnumDoneMessage()
{
    PostMessage(_hwndView, WM_DSV_FILELISTENUMDONE, 0, 0);
}

void CDefView::_PostFillDoneMessage()
{
    _ShowSearchUI(TRUE);
    PostMessage(_hwndView, WM_DSV_FILELISTFILLDONE, 0, 0);
}

void CDefView::_OnEnumDoneMessage()
{
    if (_pauto)
        _FireEvent(DISPID_FILELISTENUMDONE);

    if (_pfnEnumReadyCallback)
        _pfnEnumReadyCallback(_pvEnumCallbackData);
}



#define IN_VIEW_BMP     0x8000
#define EXT_VIEW_GOES_HERE 0x4000
#define PRIVATE_TB_FLAGS (IN_VIEW_BMP | EXT_VIEW_GOES_HERE)
#define IN_STD_BMP      0x0000


LRESULT CDefView::_OnNotify(NMHDR *pnm)
{
    switch (pnm->idFrom)
    {
    case ID_LISTVIEW:
        return _OnLVNotify((NM_LISTVIEW *)pnm);

    case FCIDM_TOOLBAR:
        return _TBNotify(pnm);

    default:

        switch (pnm->code)
        {
        case TTN_NEEDTEXT:
            #define ptt ((LPTOOLTIPTEXT)pnm)
            _GetToolTipText(ptt->hdr.idFrom, ptt->szText, ARRAYSIZE(ptt->szText));
            #undef ptt
            break;

        case NM_RCLICK:
            if (GetParent(pnm->hwndFrom) == _hwndListview)
            {
                POINT p;
                GetMsgPos(&p);
                _DoColumnsMenu(p.x, p.y);
                return 1;                           // To keep normal context menu from appearing
            }
        }
    }

    return 0;
}

// ask the folder for the default column state
DWORD CDefView::_DefaultColumnState(UINT iCol)
{
    DWORD dwState;
    if (_pshf2)
    {
        if (FAILED(_pshf2->GetDefaultColumnState(iCol, &dwState)))
        {
            dwState = SHCOLSTATE_ONBYDEFAULT;   // deal with E_NOTIMPL GetDefaultColumState implementations
        }
    }
    else
    {
        dwState = SHCOLSTATE_ONBYDEFAULT;
    }
    return dwState;
}

// SHCOLSTATE_ONBYDEFAULT
//
// columns that are turn on for this view (are displayed in the UI)

BOOL CDefView::_IsDetailsColumn(UINT iCol)
{
    return (_vs.GetColumnState(iCol) & SHCOLSTATE_ONBYDEFAULT) ? TRUE : FALSE;
}

BOOL CDefView::_IsColumnInListView(UINT iCol)
{
    return ((_vs.GetColumnState(iCol) & SHCOLSTATE_ONBYDEFAULT) ||
            (_vs.GetTransientColumnState(iCol) & SHTRANSCOLSTATE_TILEVIEWCOLUMN)) ? TRUE : FALSE;
}

BOOL CDefView::_IsTileViewColumn(UINT iCol)
{
    return (_vs.GetTransientColumnState(iCol) & SHTRANSCOLSTATE_TILEVIEWCOLUMN) ? TRUE : FALSE;
}



// SHCOLSTATE_HIDDEN
//
// columns that should not be displayed in the UI, but are exposed from
// the psf2->GetDetailsEx(). this is a way to have programtic access to properties
// that don't show up in details view

BOOL CDefView::_IsColumnHidden(UINT uCol)
{
    return (_vs.GetColumnState(uCol) & SHCOLSTATE_HIDDEN) ? TRUE : FALSE;
}

#define COL_CM_MAXITEMS     25    // how many item show up in context menu before more ... is inserted

HRESULT CDefView::AddColumnsToMenu(HMENU hm, DWORD dwBase)
{
    BOOL bNeedMoreMenu = FALSE;
    HRESULT hr = E_FAIL;

    if (_vs._hdsaColumns)
    {
        AppendMenu(hm, MF_STRING | MF_CHECKED | MF_GRAYED, dwBase, _vs.GetColumnName(0));
        for (UINT i = 1; i < min(COL_CM_MAXITEMS, _vs.GetColumnCount()); i++)
        {
            DWORD dwFlags = _vs.GetColumnState(i);
            if (!(dwFlags & SHCOLSTATE_HIDDEN))
            {
                if (dwFlags & SHCOLSTATE_SECONDARYUI)
                    bNeedMoreMenu = TRUE;
                else
                    AppendMenu(hm, MF_STRING | (dwFlags & SHCOLSTATE_ONBYDEFAULT) ? MF_CHECKED : 0,
                        dwBase + i, _vs.GetColumnName(i));
            }
        }

        if (bNeedMoreMenu || (_vs.GetColumnCount() > COL_CM_MAXITEMS))
        {
            TCHAR szMore[MAX_COLUMN_NAME_LEN];
            LoadString(HINST_THISDLL, IDS_COL_CM_MORE, szMore, ARRAYSIZE(szMore));
            AppendMenu(hm, MF_SEPARATOR, 0, NULL);
            AppendMenu(hm, MF_STRING, SFVIDM_VIEW_COLSETTINGS, szMore);
        }
        hr = S_OK;
    }

    return hr;
}

UINT CDefView::_RealToVisibleCol(UINT iReal)
{
    ASSERT(_bLoadedColumns && _vs.GetColumnCount());

    int iVisible = -1;  // start here to get zero based result
    int cMax = min(_vs.GetColumnCount() - 1, iReal);

    for (int i = 0; i <= cMax; i++)
    {
        if (_IsColumnInListView(i))
        {
            iVisible++;
        }
    }
    ASSERT(-1 != iVisible);
    return iVisible;
}

// map listview (zero based) column indexes
// indexs (zero based)

UINT CDefView::_VisibleToRealCol(UINT iVisible)
{
    ASSERT(_bLoadedColumns && _vs.GetColumnCount());

    for (UINT i = 0, cVisibleSeen = 0; i < _vs.GetColumnCount(); i++)
    {
        if (_IsColumnInListView(i))
        {
            if (cVisibleSeen == iVisible)
            {
                return i;
            }
            cVisibleSeen++;
        }
    }
     ASSERT(0);  // should never get a vis col not in the real
    return 0;
}

void CDefView::_AddTileColumn(UINT uCol)
{
    if (_IsColumnInListView(uCol))
    {
        // All we need to do is make sure it's marked as a tile column
        _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, SHTRANSCOLSTATE_TILEVIEWCOLUMN);
        return;
    }

    _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, SHTRANSCOLSTATE_TILEVIEWCOLUMN);

    // Now that we set the transient state, we can get the new visible column index
    // for this guy, and add it to the listview.
    UINT uColVis = _RealToVisibleCol(uCol);
    _AddColumnToListView(uCol, uColVis);

    // We now need to reset the tile info for each item. We can make an optimization:
    // if this column was added at the end (i.e. biggest visible column), it won't affect
    // any of the current tiles, so we don't need to do this. Passing -1 gives us the
    // largest visible index.
    if (_RealToVisibleCol(-1) != uColVis)
    {
        _ResetTileInfo(uColVis, TRUE);
    }
}

// Remove all columns that were added because of tileview (unless they were also
// added for other reasons).
// Note: This should only be called when leaving tileview, since we do not reset the
// items' tileinfo.
void CDefView::_RemoveTileColumns()
{
    for (UINT uCol = 0; uCol < _vs.GetColumnCount(); uCol++)
    {
        if (_IsTileViewColumn(uCol))
        {
            // First nuke the tile bit.
            UINT uColVis = _RealToVisibleCol(uCol);
            _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, 0);

            // Then go ahead and remove it from listview if it wasn't a details column
            if (!_IsDetailsColumn(uCol))
            {
                ListView_DeleteColumn(_hwndListview, uColVis);
            }
        }
    }
}

// This method resets the tileinfo for each item in the listview, based on which
// visible column we just added or removed.
// uColVis = the visible column that was added or removed.
// Note: This must be called prior to there being any tileinfo in the listview containing
// a reference to this new column.
void CDefView::_ResetTileInfo(UINT uColVis, BOOL bAdded)
{
    if (!_IsOwnerData())
    {
        UINT rguColumns[TILEVIEWLINES];

        for (int i = 0; i < ListView_GetItemCount(_hwndListview); i++)
        {
            UINT uColBoundary = uColVis;
            LVITEM lvi;
            lvi.mask = LVIF_COLUMNS | LVIF_NORECOMPUTE;
            lvi.iSubItem = 0;
            lvi.iItem = i;
            lvi.cColumns = ARRAYSIZE(rguColumns);
            lvi.puColumns = rguColumns;

            if (!ListView_GetItem(_hwndListview, &lvi))
                continue;

            if ((lvi.cColumns == 0) || (lvi.cColumns == I_COLUMNSCALLBACK))
            {
                continue;
            }

            ASSERT(lvi.cColumns <= ARRAYSIZE(rguColumns)); // If for some reason listview has more, there's a problem


            UINT *puColumn = lvi.puColumns;
            BOOL bChange = FALSE;

            // Adjust the column numbers as needed: up for added, down for removed.
            int iIncDec = bAdded ? 1 : -1;
            if (!bAdded)
            {
                // What is this doing? If we've added a column X, we need to adjust columns
                // from X on up. If we've removed a column X, we need to adjust columns from
                // X+1 on up. So basically, instead of doing (*puColumn > uColBoundary), we're
                // doing (*puColumn >= (uColBoundary+1)). So we can do the same ">=" expression
                // whether or not bAdded, avoiding an if check in the loop.
                uColBoundary++;
            }

            for (UINT uCol = 0; uCol < lvi.cColumns; uCol++, puColumn++)
            {
                if (*puColumn >= uColBoundary)
                {
                    (*puColumn) = (UINT)(iIncDec + (int)(*puColumn)); // Inc or dec.
                    bChange = TRUE;
                }
            }

            if (bChange) // If there were any changes, set the ti back.
            {
                LVTILEINFO ti;
                ti.cbSize = sizeof(ti);
                ti.iItem = lvi.iItem;
                ti.cColumns = lvi.cColumns;
                ti.puColumns = lvi.puColumns;
                ListView_SetTileInfo(_hwndListview, &ti);
            }
        }
    }
}

// Called when leaving tileview, this "cleans the slate" so that we reload the
// columns properly when re-entering tileview at a later time.
void CDefView::_RemoveTileInfo()
{
    if (!_IsOwnerData())
    {
        for (int i = 0; i < ListView_GetItemCount(_hwndListview); i++)
        {
            LVTILEINFO ti = {0};
            ti.cbSize = sizeof(ti);
            ti.iItem = i;
            ti.cColumns = I_COLUMNSCALLBACK;

            ListView_SetTileInfo(_hwndListview, &ti);
        }
    }
}


// uCol is a real column number, not visible column number
// This method toggles the SHCOLSTATE_ONBYDEFAULT bit of the column,
// and adds or removes the column as necessary.
BOOL CDefView::_HandleColumnToggle(UINT uCol, BOOL bRefresh)
{
    BOOL fWasOn = _IsColumnInListView(uCol); // if its off now, we are adding it
    BOOL fWasDetailsColumn = _IsDetailsColumn(uCol);

    UINT uColVisOld = _RealToVisibleCol(uCol);

    _vs.SetColumnState(uCol, SHCOLSTATE_ONBYDEFAULT, fWasDetailsColumn ? 0 : SHCOLSTATE_ONBYDEFAULT);

    BOOL fIsOn = _IsColumnInListView(uCol); // This could == fWasOn if it's a tileview column

    UINT uColVis = _RealToVisibleCol(uCol);

    if (fIsOn != fWasOn)
    {
        if (!fWasOn)
        {
            _AddColumnToListView(uCol, uColVis);

            if (_fs.ViewMode == FVM_TILE)
            {
                _ResetTileInfo(uColVis, TRUE);
            }
        }
        else
        {
            _vs.RemoveColumn(uColVisOld);
            ListView_DeleteColumn(_hwndListview, uColVisOld);

            if (_fs.ViewMode == FVM_TILE)
            {
                _ResetTileInfo(uColVisOld, FALSE);
            }

            if (_vs._lParamSort == (int) uCol)
            {
                UINT iNewVis = _VisibleToRealCol(0);
                Rearrange(iNewVis);
            }

            if (ListView_GetSelectedColumn(_hwndListview) == (UINT)uCol)
                ListView_SetSelectedColumn(_hwndListview, -1);
        }
    }

    if (bRefresh)
    {
        ListView_RedrawItems(_hwndListview, 0, 0x7fff);
        InvalidateRect(_hwndListview, NULL, TRUE);
        UpdateWindow(_hwndListview);
    }
    return TRUE;
}

// uCol = Real column number.   uColVis = add it as this visible column.
void CDefView::_AddColumnToListView(UINT uCol, UINT uColVis)
{
    LV_COLUMN col = {0};

    // Adding a column

    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = _vs.GetColumnFormat(uCol);
    col.cx = _vs.GetColumnCharCount(uCol) * _cxChar;  // Use default width
    col.pszText = _vs.GetColumnName(uCol);
    col.cchTextMax = MAX_COLUMN_NAME_LEN;
    col.iSubItem = uCol;                // not vis

    // This is all odd... Find Files uses this, but i think it should be LVCFMT_COL_IMAGE
    if (col.fmt & LVCFMT_COL_HAS_IMAGES)
    {
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SUBITEMIMAGES, LVS_EX_SUBITEMIMAGES);
        col.fmt &= ~LVCFMT_COL_HAS_IMAGES;
    }

    if (-1 != ListView_InsertColumn(_hwndListview, uColVis, &col))
    {
        // now add it to our DSA
        _vs.AppendColumn(uColVis, (USHORT) col.cx, uColVis);

        if (!_fGroupView && (_vs._lParamSort == (int)uCol))
        {
            ListView_SetSelectedColumn(_hwndListview, uColVis);
        }
    }
}



void SetHeaderSort(HWND hwndHead, int iCol, UINT sortFlags)
{
    HDITEM hdi = {HDI_FORMAT};
    Header_GetItem(hwndHead, iCol, &hdi);
    hdi.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
    hdi.fmt |= sortFlags;
    Header_SetItem(hwndHead, iCol, &hdi);
}

void CDefView::_SetSortFeedback()
{
    HWND hwndHead = ListView_GetHeader(_hwndListview);

    // the _IsOwnerData() is bad. this keeps search from getting sort UI feedback.
    // to fix this implement a mode where the sort has not been determined and thus we don't
    // display any sort feedback. regular folders could use this too as after items have
    // been added the view is not really sorted

    if (!hwndHead || _IsOwnerData())
        return;

    BOOL fRemoveBitmapFromLastHeader = TRUE;
    int iColLast = _RealToVisibleCol(_vs._iLastColumnClick);
    int iCol = _RealToVisibleCol((UINT)_vs._lParamSort);

    if (_fGroupView)
    {
        SetHeaderSort(hwndHead, iCol, 0);
    }
    else
    {
        ListView_SetSelectedColumn(_hwndListview, iCol);

        SetHeaderSort(hwndHead, iCol, _vs._iDirection > 0 ? HDF_SORTUP : HDF_SORTDOWN);

        // Only remove the bitmap if the last header is not the one we are currently sorting by
        if (iColLast == iCol)
            fRemoveBitmapFromLastHeader = FALSE;
    }

    if (fRemoveBitmapFromLastHeader && iColLast != -1)
    {
        SetHeaderSort(hwndHead, iColLast, 0);
    }
}

// use the folder to compare two items, falling back if the lParam is not understood by
// that folder.
// 99/05/18 #341468 vtan: If the first comparison fails it may be because
// lParamSort is not understood by IShellFolder::CompareIDs (perhaps it's
// an extended column that might not be installed any more)
// In this case get the default comparison method
// and use that. If that fails use 0 which should hopefully not fail. If
// the 0 case fails we are toast with an assert.

HRESULT CDefView::_CompareIDsFallback(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2)
{
    HRESULT hr = _pshf->CompareIDs(lParam, p1, p2);
    if (FAILED(hr))
    {
        LPARAM lParamSort;
        _vs.GetDefaults(this, &lParamSort, NULL, NULL);

        hr = _pshf->CompareIDs(lParamSort | (SHCIDS_ALLFIELDS & lParam), p1, p2);
        if (FAILED(hr))
        {
            // even that did not work, fall back to zero based compare (pluse the all fields flag)
            hr = _pshf->CompareIDs((SHCIDS_ALLFIELDS & lParam), p1, p2);
        }
    }
    ASSERT(SUCCEEDED(hr));
    return hr;
}

// compare two items, taking into account the sort direction
int CDefView::_CompareIDsDirection(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2)
{
    ASSERT(_vs._iDirection != 0);
    HRESULT hr = _CompareIDsFallback(lParam, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
    return ShortFromResult(hr) * _vs._iDirection;
}

// p1 and p2 are pointers to the lv_item's LPARAM, which is currently the pidl
int CALLBACK CDefView::_Compare(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = (CDefView *)lParam;
    return pdv->_CompareIDsDirection(pdv->_vs._lParamSort, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
}

typedef struct
{
    VARIANT var;
    BOOL    fIsFolder;
} VARIANT_AND_FOLDER;

typedef struct
{
    VARIANT_AND_FOLDER *pvars;
    SHCOLUMNID scid;
    CDefView *pdv;
} VARIANT_SORT_INFO;

int CALLBACK _CompareVariantCallback(LPARAM dw1, LPARAM dw2, LPARAM lParam)
{
    VARIANT_SORT_INFO *psi = (VARIANT_SORT_INFO *)lParam;

    int iRet = 0;

    // Always put the folders first
    if (psi->pvars[dw1].fIsFolder)
    {
        if (!psi->pvars[dw2].fIsFolder)
            iRet = -1;
    }
    else if (psi->pvars[dw2].fIsFolder)
    {
        iRet = 1;
    }

    if (0 == iRet)
    {
        iRet = CompareVariants(psi->pvars[dw1].var, psi->pvars[dw2].var);
    }

    return iRet * psi->pdv->_vs._iDirection;
}

#define LV_NOFROZENITEM         -1

HRESULT CDefView::_Sort(void)
{
    HRESULT hr = CallCB(SFVM_ARRANGE, 0, _vs._lParamSort);
    if (FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);

        int iIndexRecycleBin = LV_NOFROZENITEM;
        POINT ptRecycleBin;

        _SetSortFeedback();

        // For desktop, we need to freeze the recycle bin position before we arrage other icons.
        if (_fPositionRecycleBin)
        {
            iIndexRecycleBin = _FreezeRecycleBin(&ptRecycleBin);
            _fPositionRecycleBin = FALSE;
        }

        // This is semi-bogus for defview to care whether the column is extended or not.
        // We could have modified the ISF::CompareIDs() to handle extended columns, but
        // then it would only have the pidls, and would have to re-extract any data, so
        // its much faster if we separate out the extended columns, and take advantage
        // of listview's caching abilities.
        DWORD dwState = _DefaultColumnState((UINT)_vs._lParamSort);
        SHCOLUMNID scid;
        HRESULT hrMapColumn = E_FAIL;
        if (_pshf2)
            hrMapColumn = _pshf2->MapColumnToSCID((UINT)_vs._lParamSort, &scid);

        // SHCOLSTATE_PREFER_VARCMP tells us that the folder's CompareIDs()
        // produces the same result as comparing the variants. this is an optimization
        // for folders who's CompareIDs() are slow (bit bucket)

        if (_IsOwnerData() || (dwState & (SHCOLSTATE_EXTENDED | SHCOLSTATE_PREFER_VARCMP)))
        {
            if (_GetBackgroundTaskCount(TOID_DVBackgroundEnum) == 0)
            {
                int cItems = ListView_GetItemCount(_hwndListview);
                if (cItems)
                {
                    VARIANT_SORT_INFO vsi;
                    BOOL fOkToProceed = TRUE;
                    if ((UINT)_vs._lParamSort == 0)
                    {
                        vsi.scid = SCID_NAME;
                    }
                    else if (SUCCEEDED(hrMapColumn))
                    {
                        vsi.scid = scid;
                    }
                    else
                    {
                        fOkToProceed = FALSE;
                        hr = hrMapColumn;
                    }

                    if (fOkToProceed)
                    {
                        vsi.pvars = new VARIANT_AND_FOLDER[cItems];
                        if (vsi.pvars)
                        {
                            vsi.pdv = this;

                            for (int i = 0; i < cItems; i++)
                            {
                                LPCITEMIDLIST pidl = _GetPIDL(i);
                                if (pidl)
                                {
                                    DWORD dwAttrib = SHGetAttributes(_pshf, pidl, SFGAO_FOLDER);
                                    vsi.pvars[i].fIsFolder = dwAttrib & SFGAO_FOLDER;
                                    if ((UINT)_vs._lParamSort == 0)  // This is the NAME column
                                    {
                                        WCHAR szName[MAX_PATH];
                                        if (SUCCEEDED(DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
                                        {
                                            InitVariantFromStr(&vsi.pvars[i].var, szName);
                                        }
                                    }
                                    else
                                    {
                                        _pshf2->GetDetailsEx(pidl, &vsi.scid, &vsi.pvars[i].var);
                                    }
                                }
                            }

                            hr = CallCB(SFVM_SORTLISTDATA, (LPARAM)_CompareVariantCallback, (LPARAM)&vsi);

                            // dont send a LVM_SORTITEMS to an ownerdraw or comctl32 will rip
                            if (FAILED(hr) && !_IsOwnerData() && ListView_SortItemsEx(_hwndListview, _CompareVariantCallback, (LPARAM)&vsi))
                                hr = S_OK;

                            for (int i = 0; i < cItems; i++)
                            {
                                VariantClear(&vsi.pvars[i].var);
                            }

                            delete vsi.pvars;
                        }
                    }
                }
            }
        }
        else
        {
            ASSERT(!_IsOwnerData()) // dont send a LVM_SORTITEMS to an ownerdraw or comctl32 will rip

            if (ListView_SortItems(_hwndListview, _Compare, (LPARAM)this))
                hr = S_OK;
        }

        //If we froze recycle-bin earlier, now is the time to put it in it's default position.
        if (iIndexRecycleBin != LV_NOFROZENITEM)
            _SetRecycleBinInDefaultPosition(&ptRecycleBin);
    }
    return hr;
}

// this should NOT check for whether the item is already in the listview
// if it does, we'll have some serious performance problems

int CDefView::_AddObject(LPITEMIDLIST pidl)  // takes ownership of pidl.
{
    int iItem = -1;

    // Check the commdlg hook to see if we should include this
    // object.
    if ((S_OK == _IncludeObject(pidl)) &&
        (S_FALSE != CallCB(SFVM_INSERTITEM, 0, (LPARAM)pidl)))
    {
        LV_ITEM item = {0};

        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_COLUMNS;
        item.iItem = INT_MAX;     // add at end
        item.iImage = I_IMAGECALLBACK;
        item.pszText = LPSTR_TEXTCALLBACK;
        item.lParam = (LPARAM)pidl;        // Takes pidl ownership.
        item.cColumns = I_COLUMNSCALLBACK; // REVIEW: why not fill this in like the _UpdateObject call?  That would fix the problem where GroupBy doesn't keep the "Searching UI" going...

        iItem = ListView_InsertItem(_hwndListview, &item);

        if (iItem < 0)
        {
            ILFree(pidl);
        }
        else if (_bBkFilling)
        {
            _pEnumTask->_AddToPending(pidl);
        }

        _OnContentsChanged();
        if (iItem == 0)
        {
            _PostNoItemStateChangedMessage();
        }
    }
    else
    {
        ILFree(pidl);
    }

    return iItem;
}

// Find an item in the view

int CDefView::_FindItem(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFound, BOOL fSamePtr, BOOL fForwards)
{
    RIP(ILFindLastID(pidl) == pidl);

    int cItems = ListView_GetItemCount(_hwndListview);
    if (_iLastFind >= cItems)
        _iLastFind = 0;

    int iItem = _iLastFind;
    if (SUCCEEDED(CallCB(SFVM_INDEXOFITEMIDLIST, (WPARAM)&iItem, (LPARAM)pidl)))
    {
        if (ppidlFound)
            *ppidlFound = (LPITEMIDLIST)_GetPIDL(iItem);    // cast as caller knows how to free this
    }
    else
    {
        iItem = -1;     // assume failure
        for (int cCounter = 0, i = _iLastFind; cCounter < cItems; cCounter++)
        {
            LPCITEMIDLIST pidlT = _GetPIDL(i);
            ASSERT(pidlT);
            if (pidlT)
            {
                if ((pidlT == pidl) ||
                    (!fSamePtr && (0 == ResultFromShort(_pshf->CompareIDs(0, pidl, pidlT)))))
                {
                    if (ppidlFound)
                        *ppidlFound = (LPITEMIDLIST)pidlT;  // cast as callers know how to free

                    _iLastFind = iItem = i;     // success
                    // TraceMsg(TF_DEFVIEW, "####FIND CACHE RESULT --- %s by %d", cCounter < iItem ? TEXT("WIN") : TEXT("LOSE"), iItem - cCounter);
                    break;
                }
            }

            if (fForwards)
            {
                i = (i+1)%cItems;
            }
            else
            {
                i = (i > 0)?(i - 1):(cItems-1);
            }
        }

        if (-1 == iItem)
        {
            _iLastFind = 0;     // didn't find it, reset this for next time
        }
    }
    return iItem;
}

int CDefView::_FindItemHint(LPCITEMIDLIST pidl, int iItem)
{
    _iLastFind = iItem;
    return _FindItem(pidl, NULL, FALSE, FALSE);
}

// This is slightly different than the Above find item. This one
// uses some extra variables to keep track of previous group and
// "Wiggles". This "Wiggle" allows for effecient non-sequential
// application of group info
int CDefView::_FindGroupItem(LPITEMIDLIST pidl)
{
    int cItems = ListView_GetItemCount(_hwndListview);
    if (_iLastFoundCat >= cItems)
        _iLastFoundCat = 0;

    int iItem = -1;     // assume falure
    for (int cCounter = 0, i = _iLastFoundCat; cCounter < cItems; cCounter++)
    {
        LPCITEMIDLIST pidlT = _GetPIDL(i);
        ASSERT(pidlT);
        if (pidlT)
        {
            if (0 == ResultFromShort(_pshf->CompareIDs(0, pidl, pidlT)) )
            {
                if (_iLastFoundCat > i)
                    _iIncrementCat = -1;
                else
                    _iIncrementCat = 1;

                _iLastFoundCat = iItem = i;     // success
                break;
            }
        }

        i += _iIncrementCat;

        if (i < 0)
            i = cItems - 1;
        if (i >= cItems)
            i = 0;
    }

    if (-1 == iItem)
    {
        _iLastFoundCat = 0;     // didn't find it, reset this for next time
    }

    return iItem;
}


// Function to process the SFVM_REMOVEOBJECT message, by searching
// through the list for a match of the pidl.  If a match is found, the
// item is removed from the list and the index number is returned, else
// -1 is returned.

int CDefView::_RemoveObject(LPCITEMIDLIST pidl, BOOL fSamePtr)
{
    int i = 0;

    // Docfind will pass in a null pointer to tell us that it wants
    // to refresh the window by deleting all of the items from it.
    if (pidl == NULL)
    {
        CallCB(SFVM_DELETEITEM, 0, 0);  // view callback notify
        ListView_DeleteAllItems(_hwndListview);

        _PostNoItemStateChangedMessage();
        _OnContentsChanged();
    }
    else
    {
        // Non null go look for item.
        i = _FindItem(pidl, NULL, fSamePtr);
        if (i >= 0)
        {
            RECT rc;
            UINT uState = ListView_GetItemState(_hwndListview, i, LVIS_ALL);

            if (uState & LVIS_FOCUSED)
                ListView_GetItemRect(_hwndListview, i, &rc, LVIR_ICON);

            if (_bBkFilling)
                _pEnumTask->_DeleteFromPending(pidl);   // removes the pointer from  the pending list.

            ListView_DeleteItem(_hwndListview, i);

            // we deleted the focused item.. replace the focus to the nearest item.
            if (uState & LVIS_FOCUSED)
            {
                int iFocus = i;
                if (_IsPositionedView() || _fGroupView)
                {
                    LV_FINDINFO lvfi = {0};

                    lvfi.flags = LVFI_NEARESTXY;
                    lvfi.pt.x = rc.left;
                    lvfi.pt.y = rc.top;
                    iFocus = ListView_FindItem(_hwndListview, -1, &lvfi);
                }
                else
                {
                    if (ListView_GetItemCount(_hwndListview) >= iFocus)
                        iFocus--;
                }

                if (iFocus != -1)
                {
                    ListView_SetItemState(_hwndListview, iFocus, LVIS_FOCUSED, LVIS_FOCUSED);
                    ListView_EnsureVisible(_hwndListview, iFocus, FALSE);
                }
                else
                {
                    // RAID 372130
                    //  Notify image preview control to update its image (to
                    //  nothing).  The image preview control uses focus change
                    //  events to track when it should update the image it is
                    //  displaying.  When it receives a focus change event, it
                    //  queries the listview to see which item has focus, then
                    //  displays that item in the image preview window.  When
                    //  the last item in the listview is deleted, we need to
                    //  fire a focus change event to the image preview control
                    //  even though the focus has not changed to another item.
                    //  This way, the image preview control realizes there is
                    //  nothing with focus, and correctly displays as empty.
                    if (_fs.ViewMode == FVM_THUMBSTRIP)
                        _ThumbstripSendImagePreviewFocusChangeEvent();
                }
            }

            // Notify automation if the listview is now empty
            UINT uCount = 0;
            GetObjectCount(&uCount);
            if (!uCount)
            {
                _PostNoItemStateChangedMessage();
            }
            _OnContentsChanged();
        }
    }
    return i;
}

// search the list for a match of the first pidl.  If a match is found,
// the item is updated to the second pidl...

int CDefView::_UpdateObject(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew)
{
    LPITEMIDLIST pidlOldToFree;
    int i = _FindItem(pidlOld, &pidlOldToFree, FALSE);
    if (i >= 0)
    {
        if (_IsOwnerData())
        {
            if (SUCCEEDED(CallCB(SFVM_SETITEMIDLIST, i, (LPARAM)pidlNew)))
            {
                // Invalidate the rectangle so we update the item...
                RECT rc;
                ListView_GetItemRect(_hwndListview, i, &rc, LVIR_BOUNDS);
                InvalidateRect(_hwndListview, &rc, FALSE);

                ListView_Update(_hwndListview, i);
                _OnContentsChanged();
            }
            else
            {
                i = -1;  // we failed, try to cleanup and bail.
            }
        }
        else
        {
            LPITEMIDLIST pidlNewClone = ILClone(pidlNew);
            if (pidlNewClone)
            {
                LV_ITEM item = {0};

                // We found the item so lets now update it in the
                // the view.

                item.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
                item.iItem = i;
                item.pszText = LPSTR_TEXTCALLBACK;
                item.iImage = I_IMAGECALLBACK;
                item.lParam = (LPARAM)pidlNewClone;

                // if selected, deselect it
                UINT uState = ListView_GetItemState(_hwndListview, i, LVIS_FOCUSED|LVIS_SELECTED);
                if (uState & (LVIS_FOCUSED|LVIS_SELECTED))
                {
                    _OnLVSelectionChange(i, uState, 0, (LPARAM)pidlOldToFree);
                }

                // remove the item.
                CallCB(SFVM_DELETEITEM, 0, (LPARAM)pidlOldToFree);

                // now insert it with a new pidl
                CallCB(SFVM_INSERTITEM, 0, (LPARAM)pidlNewClone);

                // if it was selected, select it again
                if (uState & (LVIS_FOCUSED|LVIS_SELECTED))
                {
                    _OnLVSelectionChange(i, 0, uState, (LPARAM)pidlNewClone);
                }

                if (_fGroupView)
                {
                    item.mask |= LVIF_GROUPID;
                    item.iGroupId = (int)_GetGroupForItem(item.iItem, pidlNewClone);
                }

                ListView_SetItem(_hwndListview, &item);

                int cCols = _GetHeaderCount();
                for (item.iSubItem++; item.iSubItem < cCols; item.iSubItem++)
                {
                    ListView_SetItemText(_hwndListview, item.iItem, item.iSubItem,
                                          LPSTR_TEXTCALLBACK);
                }

                //
                // Warning!!! Only free pidlOldToFree *after* calling ListView_SetItem.  ListView_SetItem
                // can call back asking for image info on the old pidl!
                //
                // Now delete the item but don't call the callback since we did that already.
                OnListViewDelete(i, pidlOldToFree, FALSE);

                _OnContentsChanged();
            }
            else
            {
                i = -1;
            }
        }
    }
    return i;
}

//
//  invalidates all items with the given image index.
//
//  or update all items if iImage == -1
//
void CDefView::_UpdateImage(int iImage)
{
    //  -1 means update all
    //  reset the imagelists incase the size has changed, and do
    //  a full update.

    if (iImage == -1)
    {
        if (_IsImageMode())
        {
            _RemoveThumbviewTasks();
            _pImageCache->Flush(TRUE);
            _SetThumbview();
        }
        else if (_IsTileMode())
        {
            _SetTileview();
        }
        else
        {
            _SetSysImageList();
        }

        _ReloadContent();
    }
    else
    {
        // get a dc so we can optimize for visible/not visible cases
        HDC hdcLV = GetDC(_hwndListview);

        // scan the listview updating any items which match
        LV_ITEM item = {0};
        int cItems = ListView_GetItemCount(_hwndListview);
        for (item.iItem = 0; item.iItem < cItems; item.iItem++)
        {
            item.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_NORECOMPUTE;

            ListView_GetItem(_hwndListview, &item);
            int iImageOld = item.iImage;

            if (item.iImage == iImage)  // this filters I_IMAGECALLBACK for us
            {
                RECT rc;
                LPCITEMIDLIST pidl = _GetPIDLParam(item.lParam, item.iItem);

                CFSFolder_UpdateIcon(_pshf, pidl);

                //
                // if the item is visible then we don't want to flicker so just
                // kick off an async extract.  if the item is not visible then
                // leave it for later by slamming in I_IMAGECALLBACK.
                //
                item.iImage = I_IMAGECALLBACK;

                if (!_IsImageMode() && ListView_GetItemRect(_hwndListview, item.iItem, &rc, LVIR_ICON) &&
                    RectVisible(hdcLV, &rc))
                {
                    int iImageNew;
                    HRESULT hr = _GetIconAsync(pidl, &iImageNew, FALSE);

                    if (hr == S_FALSE)
                        continue;

                    if (SUCCEEDED(hr))
                    {
                        if (iImageNew == iImageOld)
                        {
                            ListView_RedrawItems(_hwndListview, item.iItem, item.iItem);
                            continue;
                        }

                        item.iImage = iImageNew;
                    }
                }

                item.mask = LVIF_IMAGE;
                item.iSubItem = 0;
                ListView_SetItem(_hwndListview, &item);
            }
        }

        ReleaseDC(_hwndListview, hdcLV);
    }
}

// Function to process the SFVM_REFRESHOBJECT message, by searching
// through the list for a match of the first pidl.  If a match is found,
// the item is redrawn.

int CDefView::_RefreshObject(LPITEMIDLIST *ppidl)
{
    int i = _FindItem(ppidl[0], NULL, FALSE);
    if (i >= 0)
        ListView_RedrawItems(_hwndListview, i, i);
    return i;
}

HRESULT CDefView::_GetItemObjects(LPCITEMIDLIST **ppidl, UINT uWhat, UINT *pcItems)
{
    *pcItems = _GetItemArray(NULL, 0, uWhat);
    if (ppidl)
    {
        *ppidl = NULL;
        if (*pcItems)
        {
            *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, sizeof(*ppidl) * (*pcItems));
            if (*ppidl)
                _GetItemArray(*ppidl, *pcItems, uWhat);
            else
                return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CDefView::_SetItemPosition(int i, int x, int y)
{
    ListView_SetItemPosition32(_hwndListview, i, x, y);
    _fUserPositionedItems = TRUE;
}

void CDefView::_SetItemPos(LPSFV_SETITEMPOS psip)
{
    int i = _FindItem(psip->pidl, NULL, FALSE);
    if (i >= 0)
    {
        _SetItemPosition(i, psip->pt.x, psip->pt.y);
    }
}

// "View State" here refers to column information and icon positions
BOOL CDefView::GetViewState()
{
    BOOL bRet = FALSE;

    IPropertyBag* ppb;
    if (SUCCEEDED(IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        DWORD dw;
        // Check if we've saved state before (first check) or if we may want to
        // try upgrading some settings if we haven't saved state before (second check)
        if (SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_MODE, &dw)) ||
            SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_FFLAGS, &dw)))
        {
            bRet = SUCCEEDED(_vs.LoadFromPropertyBag(this, ppb));
        }
        else
        {
            IStream* pstm;
            if (SUCCEEDED(_LoadGlobalViewState(&pstm)))
            {
                _vs.LoadFromStream(this, pstm);
                bRet = TRUE;
                pstm->Release();
            }
        }
        ppb->Release();
    }
    else
    {

        //  99/02/05 #226140 vtan: Try to get the view state stream
        //  from ShellBrowser. If that fails then look for a global
        //  view state stream that is stored when the user clicks on
        //  the "Like Current Folder" in the View tab of folder settings.

        //  IShellBrowser::GetViewStateStream() match the dwDefRevCount
        //  of the cabinet state to make sure that it's valid.

        IStream *pstm;
        if (SUCCEEDED(_psb->GetViewStateStream(STGM_READ, &pstm)) ||
            SUCCEEDED(_LoadGlobalViewState(&pstm)))
        {
            _vs.LoadFromStream(this, pstm);

            pstm->Release();
            bRet = TRUE;
        }
    }

    return bRet;
}

void CDefView::_UpdateEnumerationFlags()
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS | SSF_SHOWCOMPCOLOR, FALSE);
    _fShowAllObjects = ss.fShowAllObjects;

    // Don't allow compression coloring on the desktop proper
    _fShowCompColor  = _IsDesktop() ? FALSE : ss.fShowCompColor;
}

// starts and stops the spinning Globe animation
// indicating that we are in the process of navigating to
// a directory
void CDefView::_GlobeAnimation(BOOL fStartSpinning, BOOL fForceStop)
{
    if (_fGlobeCanSpin)
    {
        DWORD dwCmdID = 0;

        if (fStartSpinning)
        {
            if (_crefGlobeSpin++ == 0)
            {
                dwCmdID = CBRANDIDM_STARTGLOBEANIMATION;
            }
        }
        else
        {
            ASSERT(_crefGlobeSpin > 0);

            if (fForceStop || (--_crefGlobeSpin == 0))
            {
                dwCmdID = CBRANDIDM_STOPGLOBEANIMATION;

                // our navigation is over, never spin again
                _fGlobeCanSpin = FALSE;
            }
        }

        if (dwCmdID)
        {
            IUnknown_QueryServiceExec(_psb, SID_SBrandBand, &CGID_BrandCmdGroup, dwCmdID, 0, NULL, NULL);
        }
    }
}

LRESULT SearchingUIWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC):
            SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                    GetSysColor(COLOR_WINDOW));
            return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

void CDefView::_ShowSearchUI(BOOL fStartSearchWindow)
{
    if (_fAllowSearchingWindow || _crefSearchWindow) // once started, make sure our refcount finishes
    {
        if (fStartSearchWindow)
        {
            if (_crefSearchWindow++ == 0)
            {
                // The static window could already exist during a refresh
                if (!_hwndStatic)
                {
                    _hwndStatic = SHCreateWorkerWindowW((WNDPROC)SearchingUIWndProc, _hwndView, 0,
                                                        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                                                        NULL, NULL);

                    if (_hwndStatic)
                    {
                        HWND hAnimate = CreateWindowEx(0, ANIMATE_CLASS, c_szNULL,
                                WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | ACS_TRANSPARENT | ACS_AUTOPLAY | ACS_CENTER,
                                0, 0, 0, 0, _hwndStatic, (HMENU)ID_STATIC, HINST_THISDLL, NULL);
                        if (hAnimate)
                        {
                            RECT rc;
                            GetClientRect(_hwndView, &rc);
                            // Move this window to the top so the user sees the "looking" icon
                            // We are in a "normal" view.  We need to do this always or the
                            // Flashlight doesn't appear.  It tested safe with WebView on.
                            SetWindowPos(_hwndStatic, HWND_TOP, 0, 0, rc.right, rc.bottom, 0);
                            SetWindowPos(hAnimate, HWND_TOP, 0, 0, rc.right, rc.bottom, SWP_NOZORDER);
                            _OnMoveWindowToTop(_hwndStatic);

                            SetTimer(_hwndView, DV_IDTIMER_START_ANI, 2000, NULL);    // 2 second timer
                        }
                    }
                }

                ShowHideListView();
            }
        }
        else
        {
            if (0 == _crefSearchWindow)  // if _ShowSearchUI(FALSE) gets called before _ShowSearchUI(TRUE)
            {
                _fAllowSearchingWindow = FALSE;
            }
            else if (--_crefSearchWindow == 0)
            {
                _fAllowSearchingWindow = FALSE;

                ShowHideListView();
            }
        }
    }
}


// this is only called from within SHCNE_*  don't put up ui on the enum error.
void CDefView::_FullViewUpdate(BOOL fUpdateItem)
{
    if (fUpdateItem)
        _ReloadContent(); // the folder we're looking at has changed
    else
        FillObjectsShowHide(FALSE); // our contents have changed
}

void CDefView::_ShowControl(UINT idControl, int idCmd)
{
    IBrowserService *pbs;
    if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        pbs->ShowControlWindow(idControl, idCmd);
        pbs->Release();
    }
}

BOOL IsSingleWindowBrowsing(void)
{
    CABINETSTATE cs;

    TBOOL(ReadCabinetState(&cs, sizeof(cs)));
    return !BOOLIFY(cs.fNewWindowMode);
}

// This function does three things:
// 1 - Alter the size of the parent to best fit around the items we have.
// 2 - Set the default icon view mode
// 3 - Make sure the correct toolbars are showing
//
void CDefView::_BestFit()
{
    // Only bestfit once
    if (_fs.fFlags & FWF_BESTFITWINDOW)
    {
        _fs.fFlags &= ~FWF_BESTFITWINDOW;

        // Make sure the correct toolbars are showing the first time this folder is displayed
        //
        int iITbar = SBSC_HIDE;
        int iStdBar = SBSC_HIDE;
        switch (_uDefToolbar)
        {
        case HIWORD(TBIF_INTERNETBAR):
            iITbar = SBSC_SHOW;
            goto ShowToolbar;

        case HIWORD(TBIF_STANDARDTOOLBAR):
            iStdBar = SBSC_SHOW;
            goto ShowToolbar;

        case HIWORD(TBIF_NOTOOLBAR):
ShowToolbar:
            _ShowControl(FCW_INTERNETBAR, iITbar);
            _ShowControl(FCW_TOOLBAR, iStdBar);
            break;
        }

    }
}

void CDefView::_ClearPostedMsgs(HWND hwnd)
{
    MSG msg;

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATEICON, WM_DSV_UPDATEICON, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATEICON after WM_DESTROY!!!");
            LPITEMIDLIST pidl = (LPITEMIDLIST) msg.wParam;
            ILFree(pidl);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATECOLDATA, WM_DSV_UPDATECOLDATA, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATECOLDATA after WM_DESTROY!!!");
            delete (CBackgroundColInfo*)msg.lParam;
        }
    }
    while (PeekMessage(&msg, hwnd, WM_DSV_DELAYSTATUSBARUPDATE, WM_DSV_DELAYSTATUSBARUPDATE, PM_REMOVE))
    {
        if (msg.hwnd == hwnd)
        {
            LocalFree((void *)msg.lParam);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_SETIMPORTANTCOLUMNS, WM_DSV_SETIMPORTANTCOLUMNS, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_SETIMPORTANTCOLUMNS after WM_DESTROY!!!");
            delete (CBackgroundTileInfo*)msg.lParam;
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_SETITEMGROUP, WM_DSV_SETITEMGROUP, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_SETITEMGROUP after WM_DESTROY!!!");
            delete (CBackgroundGroupInfo*)msg.lParam;
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATETHUMBNAIL, WM_DSV_UPDATETHUMBNAIL, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATETHUMBNAIL after WM_DESTROY!!!");
            _CleanupUpdateThumbnail((DSV_UPDATETHUMBNAIL*)msg.lParam);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_POSTCREATEINFOTIP, WM_DSV_POSTCREATEINFOTIP, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_POSTCREATEINFOTIP after WM_DESTROY!!!");
            _OnPostCreateInfotipCleanup((TOOLINFO *)msg.wParam);
        }
    }
}

void CDefView::_CallRefresh(BOOL fPreRefresh)
{
    if (fPreRefresh)
    {
        IUnknown_Exec(_pshf, NULL, OLECMDID_REFRESH, 0, NULL, NULL);
    }

    CallCB(SFVM_REFRESH, fPreRefresh, 0);
}

void CDefView::FillDone()
{
    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)FALSE, 0);
    _fListviewRedraw = TRUE;

    AddRef(); // hold a ref to ourself while in this function.

    _fAllowSearchingWindow = FALSE;

    _PostFillDoneMessage();

    if (_bBkFilling)
        _OnStopBackgroundEnum();

    HRESULT hr = _pEnumTask->FillObjectsDoneToView();
    _pEnumTask->Release();
    _pEnumTask = NULL;

    if (SUCCEEDED(hr))
    {
        // Clear our error state, if we were in one
        _fEnumFailed = FALSE;

        if (_fSyncOnFillDone)
        {
            _vs.Sync(this, TRUE);
            _fSyncOnFillDone = FALSE;
        }

        ShowHideListView();

        // set the focus on the first item.
        _FocusOnSomething();

        _DoThumbnailReadAhead();
    }
    else
    {
        // The fill objects failed for some reason, go into error mode
        TraceMsg(TF_WARNING, "::FillObjects failed to enumerate for some reason");
        _fEnumFailed = TRUE;
        ShowHideListView();
    }

    // Tell the defview client that this window has been refreshed
    _CallRefresh(FALSE);
    _OnContentsChanged();

    _UpdateStatusBar(TRUE);
    _PostEnumDoneMessage();

    Release();

    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)TRUE, 0);
    _fListviewRedraw = FALSE;
}

HRESULT CDefView::_OnStartBackgroundEnum()
{
    _GlobeAnimation(TRUE);
    _ShowSearchUI(TRUE);
    _bBkFilling = TRUE;

    return S_OK;
}

HRESULT CDefView::_OnStopBackgroundEnum()
{
    _bBkFilling = FALSE;
    _GlobeAnimation(FALSE);
    _ShowSearchUI(FALSE);

    return S_OK;
}

HRESULT CDefView::_OnBackgroundEnumDone()
{
    FillDone();

    _UpdateStatusBar(FALSE);

    CallCB(SFVM_BACKGROUNDENUMDONE, 0, 0);

    return S_OK;
}

HRESULT EmptyBkgrndThread(IShellTaskScheduler *pScheduler)
{
    HRESULT hr = S_OK;

    if (pScheduler)
    {
        // empty the queue and wait until it is empty.....
        hr = pScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, TRUE);
    }
    return hr;
}

DWORD CDefView::_GetEnumFlags()
{
    // Setup the enum flags.
    DWORD grfEnumFlags = SHCONTF_NONFOLDERS;
    if (_fShowAllObjects)
        grfEnumFlags |= SHCONTF_INCLUDEHIDDEN;

    //Is this View in Common Dialog
    if (!(grfEnumFlags & SHCONTF_INCLUDEHIDDEN))
    {
        // Ask Common dialog if its wants to show all files
        ICommDlgBrowser2 *pcdb2;
        if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(ICommDlgBrowser2, &pcdb2))))
        {
            DWORD dwFlags = 0;
            pcdb2->GetViewFlags(&dwFlags);
            if (dwFlags & CDB2GVF_SHOWALLFILES)
                grfEnumFlags |= SHCONTF_INCLUDEHIDDEN;
            pcdb2->Release();
        }
    }

    if (!(_fs.fFlags & FWF_NOSUBFOLDERS))
        grfEnumFlags |= SHCONTF_FOLDERS;

    return grfEnumFlags;
}

HRESULT CDefView::FillObjectsShowHide(BOOL fInteractive)
{
    HRESULT hr = S_OK;

    DECLAREWAITCURSOR;
    SetWaitCursor();            // This is a potentially long operation

    // To get here we're either not enumerating at all,
    // or we are enumerating on the background thread,
    // or we got re-entered
    ASSERT((!_pEnumTask&&!_bBkFilling) || (_pEnumTask));
    if (_pEnumTask)
    {
        if (fInteractive)
        {
            // This is in response to the user pressing F5,
            // assume the current enumeration will be valid
            hr = S_FALSE;
        }
        else if (!_bBkFilling)
        {
            // We're not on the background but we have a _pEnumTask, this means
            // that we got re-entered during the below call to FillObjectsToDPA.
            // Assume the current enumeration attempt will be valid
            hr = S_FALSE;
        }
        else
        {
            if (_pScheduler)
            {
                // An UPDATEDIR or equivalent happened, anything already enumerated could be bad.
                // Tell the current enumeration task to give up
                _pScheduler->RemoveTasks(TOID_DVBackgroundEnum, ITSAT_DEFAULT_LPARAM, FALSE);
                _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);
            }

            ASSERT(_bBkFilling);
            _OnStopBackgroundEnum();

            _pEnumTask->Release();
            _pEnumTask = NULL;
        }
    }

    if (S_OK==hr)
    {
        _pEnumTask = new CDefviewEnumTask(this);
        if (_pEnumTask)
        {
            // Note: It is possible for us to get re-entered during FillObjectsToDPA,
            // since we pass our HWND to the enumerator.
            _pEnumTask->FillObjectsToDPA(fInteractive);
            hr = _pEnumTask->FillObjectsDPAToDone();
        }
        else
        {
            _fEnumFailed = TRUE;
            ShowHideListView();

            hr = E_OUTOFMEMORY;
        }
    }

    ResetWaitCursor();
    return hr;
}


//  This implementation uses following assumptions.
//  (1) The IShellFolder uses CDefFolderMenu.
//  (2) The CDefFolderMenu always add the folder at the top.

#define EC_SELECTION  0
#define EC_BACKGROUND 1
#define EC_EITHER     3

HRESULT CDefView::_ExplorerCommand(UINT idFCIDM)
{
    HRESULT hr = E_FAIL;

    static struct {
        UINT    idmFC;
        UINT    fBackground;
        LPCTSTR pszVerb;
    } const c_idMap[] = {
        { SFVIDM_FILE_RENAME,      EC_SELECTION,  c_szRename },
        { SFVIDM_FILE_DELETE,      EC_SELECTION,  c_szDelete },
        { SFVIDM_FILE_PROPERTIES,  EC_EITHER,     c_szProperties },
        { SFVIDM_EDIT_COPY,        EC_SELECTION,  c_szCopy },
        { SFVIDM_EDIT_CUT,         EC_SELECTION,  c_szCut },
        { SFVIDM_FILE_LINK,        EC_SELECTION,  c_szLink },
        { SFVIDM_EDIT_PASTE,       EC_BACKGROUND, c_szPaste },
        { SFVIDM_EDIT_PASTELINK,   EC_BACKGROUND, c_szPasteLink },
    };

    for (int i = 0; i < ARRAYSIZE(c_idMap); i++)
    {
        if (c_idMap[i].idmFC == idFCIDM)
        {
            IContextMenu *pcm;

            if (c_idMap[i].fBackground == EC_BACKGROUND)
            {
                hr = _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcm));
            }
            else
            {
                hr = _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcm));
                if (FAILED(hr) && (c_idMap[i].fBackground == EC_EITHER) && !ListView_GetSelectedCount(_hwndListview))
                {
                    hr = _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcm));
                }
            }

            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFOEX ici = {0};

                ici.cbSize = sizeof(ici);
                ici.hwnd = _hwndMain;
                ici.nShow = SW_NORMAL;

                // record if shift or control was being held down
                SetICIKeyModifiers(&ici.fMask);

                // Fill in both the ansi verb and the unicode verb since we
                // don't know who is going to be processing this thing.
                CHAR szVerbAnsi[40];
                SHUnicodeToAnsi(c_idMap[i].pszVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
                ici.lpVerb = szVerbAnsi;
                ici.lpVerbW = c_idMap[i].pszVerb;
                ici.fMask |= CMIC_MASK_UNICODE;

                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    IUnknown_SetSite(pcm, SAFECAST(this, IOleCommandTarget *));

                    pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, 0);

                    _bContextMenuMode = TRUE;

                    hr = _InvokeContextMenu(pcm, &ici);

                    _bContextMenuMode = FALSE;

                    DestroyMenu(hmenu);

                    IUnknown_SetSite(pcm, NULL);
                }

                pcm->Release();
            }
            else
            {
                // keys are pressed when there is no selection.
                MessageBeep(0);
            }
            break;
        }
        ASSERT(i < ARRAYSIZE(c_idMap));
    }

    return hr;
}

STDAPI_(BOOL) Def_IsPasteAvailable(IDropTarget *pdtgt, DWORD *pdwEffect);

BOOL CDefView::_AllowCommand(UINT uID)
{
    DWORD dwAttribsIn;
    DWORD dwEffect;

    switch (uID)
    {
    case SFVIDM_EDIT_PASTE:
        return Def_IsPasteAvailable(_pdtgtBack, &dwEffect);

    case SFVIDM_EDIT_PASTELINK:
        Def_IsPasteAvailable(_pdtgtBack, &dwEffect);
        return dwEffect & DROPEFFECT_LINK;

    case SFVIDM_EDIT_COPY:
        dwAttribsIn = SFGAO_CANCOPY;
        break;

    case SFVIDM_EDIT_CUT:
        dwAttribsIn = SFGAO_CANMOVE;
        break;

    case SFVIDM_FILE_DELETE:
        dwAttribsIn = SFGAO_CANDELETE;
        break;

    case SFVIDM_FILE_LINK:
        dwAttribsIn = SFGAO_CANLINK;
        break;

    case SFVIDM_FILE_PROPERTIES:
        dwAttribsIn = SFGAO_HASPROPSHEET;
        break;

    default:
        ASSERT(FALSE);
        return FALSE;
    }
    return _AttributesFromSel(dwAttribsIn) & dwAttribsIn;
}


// return copy of pidl of folder we're viewing
LPITEMIDLIST CDefView::_GetViewPidl()
{
    LPITEMIDLIST pidl;
    if (SHGetIDListFromUnk(_pshf, &pidl) != S_OK)    // S_FALSE is success by empty
    {
        if (SUCCEEDED(CallCB(SFVM_THISIDLIST, 0, (LPARAM)&pidl)))
        {
            ASSERT(pidl);
        }
        else if (_SetupNotifyData() && _pidlMonitor)
        {
            pidl = ILClone(_pidlMonitor);
        }
    }
    return pidl;
}

inline BOOL CDefView::_ItemsDeferred()
{
    return _hdsaSelect != NULL;
}

BOOL CDefView::_IsListviewVisible()
{
    return _fListViewShown;
}

inline BOOL CDefView::_IsOwnerData()
{
    return _fs.fFlags & FWF_OWNERDATA;
}

inline BOOL CDefView::_IsCommonDialog()
{
    return NULL != _pcdb;
}

BOOL CDefView::_IsDesktop()
{
    return _fs.fFlags & FWF_DESKTOP;
}

BOOL CDefView::_IsViewDesktop()
{
    BOOL bDesktop = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        bDesktop = ILIsEmpty(pidl);
        ILFree(pidl);
    }
    return bDesktop;
}

// access to the current views name ala IShellFolder::GetDisplayNameOf()

HRESULT CDefView::_GetNameAndFlags(UINT gdnFlags, LPTSTR pszPath, UINT cch, DWORD *pdwFlags)
{
    *pszPath = 0;

    HRESULT hr;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        hr = SHGetNameAndFlags(pidl, gdnFlags, pszPath, cch, pdwFlags);
        ILFree(pidl);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

// returns TRUE if the current view is a file system folder, returns the path

BOOL CDefView::_GetPath(LPTSTR pszPath)
{
    *pszPath = 0;

    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        SHGetPathFromIDList(pidl, pszPath);
        ILFree(pidl);
    }
    return *pszPath != 0;
}

EXTERN_C TCHAR const c_szHtmlWindowsHlp[] = TEXT("windows.chm");


// web view background colors, click mode, etc have changed
//
void CDefView::_UpdateListviewColors()
{
    // First clear out our state
    for (int i = 0; i < ARRAYSIZE(_crCustomColors); i++)
        _crCustomColors[i] = CLR_MYINVALID;

    // Then read the registry/desktop.ini
    LPCTSTR pszLegacyWatermark = NULL;
    SFVM_CUSTOMVIEWINFO_DATA cvi = {0};
    if (SUCCEEDED(CallCB(SFVM_GETCUSTOMVIEWINFO, (WPARAM)0, (LPARAM)&cvi)))
    {
        if (!_IsCommonDialog() && !_IsDesktop())
        {
            // Set up the listview image, if any
            if (*cvi.szIconAreaImage)
            {
                pszLegacyWatermark = cvi.szIconAreaImage;
            }

            // change the differing stuff
            //
            if (!_fClassic)
            {
                for (i = 0; i < ARRAYSIZE(_crCustomColors); i++)
                {
                    COLORREF cr = cvi.crCustomColors[i];
                    if (ISVALIDCOLOR(cr))
                    {
                        _crCustomColors[i] = PALETTERGB(0, 0, 0) | cr;
                    }
                }

                // if there was an image specified but no custom text background,
                // set to CLR_NONE so the listview text is transparent
                // get combined view custom colors
                if (!ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXTBACKGROUND]) && cvi.szIconAreaImage[0])
                {
                    _crCustomColors[CRID_CUSTOMTEXTBACKGROUND] = CLR_NONE;
                }
            }
        }
    }

    _SetLegacyWatermark(pszLegacyWatermark);

    _SetFolderColors();

    _UpdateSelectionMode();
}

BOOL CDefView::_IsReportView()
{
    return (_UxGetView() == LV_VIEW_DETAILS);
}

BOOL CDefView::HasCurrentViewWindowFocus()
{
    BOOL fRet = false;
    HWND hwndCurrentFocus = GetFocus();
    if (hwndCurrentFocus)
    {
        fRet = (SHIsChildOrSelf(_hwndListview, hwndCurrentFocus) == S_OK);
    }
    return fRet;
}

HWND CDefView::ViewWindowSetFocus()
{
    SetFocus(_hwndListview);
    if (!_IsDesktop())
    {
        _cFrame._uState = SVUIA_ACTIVATE_FOCUS;
    }
    return _hwndListview;
}

HRESULT CDefView::_GetSFVMViewState(UINT uViewMode, SFVM_VIEW_DATA* pvi)
{
    HRESULT hr = CallCB(SFVM_GETVIEWDATA, (WPARAM)uViewMode, (LPARAM)pvi);
    if (FAILED(hr))
    {
        pvi->dwOptions = SFVMQVI_NORMAL;
    }
    return hr;
}
HRESULT CDefView::_GetSFVMViewInfoTemplate(UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    return CallCB(SFVM_GETWEBVIEW_TEMPLATE, (WPARAM)uViewMode, (LPARAM)pvit);;
}


HRESULT CDefView::_GetWebViewMoniker(LPWSTR pszMoniker, DWORD cchMoniker)
{
    SFVM_WEBVIEW_TEMPLATE_DATA vit;
    if (SUCCEEDED(_GetSFVMViewInfoTemplate(_fs.ViewMode, &vit)))
    {
        StrCpyN(pszMoniker, vit.szWebView, cchMoniker);
    }
    else
    {
        pszMoniker[0] = L'\0';
    }
    return *pszMoniker ? S_OK : E_FAIL;
}

// Show or hide Web View content
//
// This does not affect the View Mode of the listview (it does tweak desktop listview for _fCombinedView stuff)
//
// fShow==TRUE -> hr is success/fail of showing web view
// fShow==FALSE -> hr is E_FAIL (nobody looks at return code of turning web view off)
//
HRESULT CDefView::_SwitchToWebView(BOOL fShow)
{
    HRESULT hr = E_FAIL;

    // Cache the focus/select state across this transition
    BOOL bSetFocusRequired = HasCurrentViewWindowFocus();

    if (fShow)
    {
        // For now, the desktop is always a combined view...
        if (_IsDesktop())
        {
            BOOL fCombinedViewOld = (BOOL)_fCombinedView;
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_HIDEICONS | SSF_DESKTOPHTML | SSF_STARTPANELON, FALSE);

            // Does the user want desktop in HyperText view?
            if (ss.fDesktopHTML)
                _fCombinedView = TRUE;

            if (ss.fHideIcons)
                _fs.fFlags |= FWF_NOICONS;
            else
                _fs.fFlags &= ~FWF_NOICONS;

            if (_fCombinedView && !fCombinedViewOld)
            {
                EnableCombinedView(this, TRUE);
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, LVS_EX_REGIONAL);
                _SetFolderColors();
            }
        }

        WCHAR wszMoniker[MAX_PATH];
        hr = _GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker));
        if (SUCCEEDED(hr))
        {
            if (_IsDesktop())
            {
                IActiveDesktopP *piadp;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktopP, &piadp))))
                {
                    piadp->EnsureUpdateHTML();
                    piadp->Release();
                }
                hr = _cFrame.ShowWebView(wszMoniker);
            }
            else if (SHRestricted(REST_REVERTWEBVIEWSECURITY))
            {
                hr = _cFrame.ShowWebView(wszMoniker);
            }
            else if (!_fUserRejectedWebViewTemplate)
            {
                WCHAR szTemplate[MAX_PATH];
                DWORD cchTemplate = ARRAYSIZE(szTemplate);
                
                if (PathIsURL(wszMoniker))
                {
                    hr = PathCreateFromUrl(wszMoniker, szTemplate, &cchTemplate, 0);
                }
                else
                {
                    StrCpyN(szTemplate, wszMoniker, ARRAYSIZE(szTemplate));
                    hr = S_OK;
                }

                if (SUCCEEDED(hr))
                {
                    DWORD dwFlags = SHRVT_VALIDATE | SHRVT_ALLOW_INTRANET;
                    if (SHRestricted(REST_ALLOWUNHASHEDWEBVIEW))
                    {
                        dwFlags |= SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK;
                    }
                    hr = SHRegisterValidateTemplate(szTemplate, dwFlags);
                    if (SUCCEEDED(hr))
                    {
                        hr = _cFrame.ShowWebView(wszMoniker);
                    }
                    else
                    {
                        _fUserRejectedWebViewTemplate = TRUE;
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            fShow = FALSE;
        }
        else
        {
            RECT rcClient;

            // Make sure the new view is the correct size
            GetClientRect(_hwndView, &rcClient);
            _cFrame.SetRect(&rcClient);

            ShowHideListView();
        }
    }

    if (!fShow)
    {
        _cFrame.HideWebView();

        // If we were combined, then get the listview out of region mode and
        // reset the color scheme.  Also, turn off the combined bit.
        if (_fCombinedView)
        {
            _fCombinedView = FALSE;
            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, 0);
            EnableCombinedView(this, FALSE);
            _SetFolderColors();
        }
    }

    // restore focus/select state -- if we switched to web view it will put much of
    // this into a "pending" state until the listview is re-shown inside the web content
    //
    if (bSetFocusRequired)
    {
        CallCB(SFVM_SETFOCUS, 0, 0);
        ViewWindowSetFocus();
    }

    CheckToolbar();
    _EnableDisableTBButtons();

    // make sure that the listview settings get refreshed anyway (back image)
    _UpdateListviewColors();

    return hr;
}

void CDefView::_RemoveThumbviewTasks()
{
    if (_pScheduler)
    {
        _pScheduler->RemoveTasks(TOID_ExtractImageTask, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->RemoveTasks(TOID_CheckCacheTask, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->RemoveTasks(TOID_ReadAheadHandler, ITSAT_DEFAULT_LPARAM, FALSE);
        _fReadAhead = FALSE;
    }
}

//
// This function checkes to see if the list view needs to be shown; then shows it.
// If it needs to be hidden, hides it!  You must call this function every time
// you change a bit of state that could change the show/hide state of listview.
//
// Let me repeat that: call this function EVERY TIME you change state that
// affects our show/hide.
//
HRESULT CDefView::ShowHideListView()
{
    // NOTE: this is where most of the flicker bugs come from -- showing the
    // listview too early.  This is touchy code, so be careful when you change it.
    // And plese document all changes for future generations.  Thanks.
    //
    // Standard "is listview shown" check
    //
    // If our view hasn't been UIActivate()d yet, then we are waiting until
    // the IShellBrowser selects us as the active view.
    //
    // App compat for above UIActivate() change:
    //    Adaptec Easy CD Creator never calls IShellView::UIActivate.
    // They got away with it because UIActivate didn't used to do much,
    // but now we use UIActivate to decide when to show our icons. They forget
    // to call it and the icons never show up.
    //    So if we are in Win95 Defview compatibility mode, then
    // go ahead and show the icons now.  The app gets flicker, but at least
    // the icons show up at all.
    //
    // Don't show the listview if we're told to not show it, or we see an error during enum.
    //
    // If we're enumerating in the background, don't show
    //
    // Potential problem: We used to defer SelectPendingSelectedItems until:
    // "_fListViewShown && (_cFrame._dwConnectionCookie /*&& !_cFrame._fReadyStateInteractiveProcessed*/)"
    // Selecting before readystatedone may pose a problem, but I don't see how it could
    // be a problem unless showing the view early is a problem as well, which this code didn't check.
    //

    if ((!_cFrame.IsWebView() || _fGetWindowLV || _fCombinedView) // we think icons should be visible
     && (_uState != SVUIA_DEACTIVATE || (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)) // async defview means we don't show before we transition out of DEACTIVE
     && !(BOOLIFY(_fs.fFlags & FWF_NOICONS)) // check if we've been told to not show icons
     && !_fEnumFailed // failed enumeration wants _hwndView to show through, not _hwndListview
     && !(_crefSearchWindow && _hwndStatic) // keep the listview hidden while we show the "searching" window
       )
    {
        // Make sure we do each transition only once - we do more than just show the window
        if (!_fListViewShown)
        {
            _fListViewShown = TRUE;

            // Bring this to the top while showing it to avoid a second paint when
            // _hwndStatic is destroyed (listview has optimizations when hidden,
            // and it will repaint when once shown even if though it may be obscured)
            //
            SetWindowPos(_hwndListview, HWND_TOP, 0, 0, 0, 0,
                SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
            _OnMoveWindowToTop(_hwndListview);

            // Remove _hwndStatic after listview is moved to top to avoid a re-paint
            if (_hwndStatic)
            {
                DestroyWindow(_hwndStatic);
                _hwndStatic = NULL;
            }

            // if we need to select items, do it now that the window is shown
            SelectPendingSelectedItems();
        }
    }
    else
    {
        if (_fListViewShown)
        {
            _fListViewShown = FALSE;
            ShowWindow(_hwndListview, SW_HIDE);
        }

        // If FWF_NOICONS is set and the enumertion went to the background thread we need
        // to make sure that we turn of the searchui.
        if (BOOLIFY(_fs.fFlags & FWF_NOICONS) && _hwndStatic && 0 == _crefSearchWindow)
        {
            DestroyWindow(_hwndStatic);
            _hwndStatic = NULL;
        }
    }

    return S_OK;
}

IShellItemArray* CDefView::_GetFolderAsShellItemArray()
{
    if (!_pFolderShellItemArray && _pshfParent && _pidlRelative)
    {
        SHCreateShellItemArray(NULL, _pshfParent, 1, (LPCITEMIDLIST *)&_pidlRelative, &_pFolderShellItemArray);
    }
    return _pFolderShellItemArray;
}

// if the attributes dwAttribMask for pdo exactly match dwAttribValue, this item should be enabled
HRESULT CDefView::_CheckAttribs(IShellItemArray *psiItemArray, DWORD dwAttribMask, DWORD dwAttribValue, UISTATE* puisState)
{
    DWORD dwAttrib = 0;
    HRESULT hr;

    if (NULL == psiItemArray)
    {
        psiItemArray = _GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
        hr = psiItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, dwAttribMask, &dwAttrib);
        if (FAILED(hr))
            dwAttrib = 0;
    }
    else
        hr = S_OK;

    *puisState = (dwAttribValue == dwAttrib) ? UIS_ENABLED : UIS_HIDDEN;

    return hr;
}

HRESULT CDefView::_CanWrite(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_READONLY|SFGAO_STORAGE, SFGAO_STORAGE, puisState);
}
HRESULT CDefView::_CanRename(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANRENAME, SFGAO_CANRENAME, puisState);
}
HRESULT CDefView::_CanMove(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANMOVE, SFGAO_CANMOVE, puisState);
}
HRESULT CDefView::_CanCopy(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray,SFGAO_CANCOPY, SFGAO_CANCOPY, puisState);
}

HRESULT CDefView::_CanPublish(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    *puisState = UIS_HIDDEN;

    if (pThis->_wvLayout.dwLayout & SFVMWVL_NOPUBLISH)
    {
        // bail out early with UIS_HIDDEN, we dont show the verb
        return S_OK;
    }

    // Iterate first 10 items because that is what old code did before
    // switching to IShellItemArray. Since the attribs that are
    // being requested for are already being cached in the ShellItemArray
    // may as well always ask for all.

    if (psiItemArray)
    {
        IEnumShellItems *pEnumShellItems;
        if (SUCCEEDED(psiItemArray->EnumItems(&pEnumShellItems)))
        {
            IShellItem *pShellItem;
            DWORD dwIterationCount = 0;
            BOOL fHide = FALSE, fHasStreams = FALSE, fHasStorages = FALSE;

            while (!fHide && (dwIterationCount < 10) && (S_OK == pEnumShellItems->Next(1, &pShellItem, NULL)))
            {
                SFGAOF dwAttribs = SFGAO_STORAGE | SFGAO_STREAM;
                HRESULT hrAttribs = pShellItem->GetAttributes(dwAttribs, &dwAttribs);

                pShellItem->Release();
                pShellItem = NULL; // null to catch if we use it again.

                if (SUCCEEDED(hrAttribs))
                {
                    if (!(dwAttribs & (SFGAO_STORAGE | SFGAO_STREAM)))
                    {
                        // if this item doesn't have either storage or stream, hide the task.
                        fHide = TRUE;
                    }
                    else if (dwAttribs & SFGAO_STREAM)
                    {
                        // if we have a folder and files, hide the task.
                        fHide = fHasStorages;
                        fHasStreams = TRUE;
                    }
                    else if (dwAttribs & SFGAO_STORAGE)
                    {
                        // if we have multiple folders or a folder and files, hide the task.
                        fHide = fHasStorages || fHasStreams;
                        fHasStorages = TRUE;
                    }
                }

                ++dwIterationCount;
            }

            if (!fHide)
                *puisState = UIS_ENABLED;

            pEnumShellItems->Release();
        }
    }
    else
    {
        // if nothing is selected, enable the task if the current folder is a storage.
        LPITEMIDLIST pidl = pThis->_GetViewPidl();
        if (pidl)
        {
            if (SHGetAttributes(NULL, pidl, SFGAO_STORAGE))
            {
                *puisState = UIS_ENABLED;
            }
            ILFree(pidl);
        }
    }

    return S_OK;
}


// Note - _DoesStaticMenuHaveVerb only checks the first pidl in the data object for now
// So only use it for single-selections
// -DSheldon
BOOL CDefView::_DoesStaticMenuHaveVerb(IShellItemArray *psiItemArray, LPCWSTR pszVerb)
{
    BOOL fHasVerb = FALSE;
    IShellItem *pshItem;

    // get first shellItem in the array.
    if (SUCCEEDED(psiItemArray->GetItemAt(0,&pshItem)))
    {
        IQueryAssociations* pqa;
        if (SUCCEEDED(pshItem->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IQueryAssociations, &pqa))))
        {
            DWORD cch = 0;
            fHasVerb = SUCCEEDED(pqa->GetString(0, ASSOCSTR_COMMAND, pszVerb, NULL, &cch));
            pqa->Release();
        }
        pshItem->Release();
    }
    return fHasVerb;
}

HRESULT CDefView::_GetFullPathNameAt(IShellItemArray *psiItemArray,DWORD dwIndex,LPOLESTR *pszPath)
{
    HRESULT hr = E_FAIL;
    IShellItem *pShellItem;

    if (NULL == psiItemArray || NULL == pszPath)
    {
        ASSERT(psiItemArray);
        ASSERT(pszPath);

        return E_INVALIDARG;
    }
    // get the path of the first item in the ShellArray.
    hr = psiItemArray->GetItemAt(dwIndex,&pShellItem);

    if (SUCCEEDED(hr))
    {
        hr = pShellItem->GetDisplayName(SIGDN_FILESYSPATH,pszPath);
        pShellItem->Release();
    }

    return hr;
}

HRESULT CDefView::_CanShare(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = E_FAIL;

    CDefView* pThis = (CDefView*)(void*)pv;
    *puisState = UIS_DISABLED;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
#ifdef DEBUG
        // Sanity check.
        DWORD dwNumItems;
        ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
        ASSERT(1 == dwNumItems);
#endif

        IShellItem *psi;
        hr = psiItemArray->GetItemAt(0, &psi);
        if (SUCCEEDED(hr))
        {
            // Retrieve pidl.
            LPITEMIDLIST pidl;
            hr = SHGetIDListFromUnk(psi, &pidl);
            if (SUCCEEDED(hr))
            {
                // Retrieve path and attributes.
                WCHAR szPath[MAX_PATH];
                DWORD dwAttributes = SFGAO_LINK;
                hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttributes);
                if (SUCCEEDED(hr) &&  !(dwAttributes & SFGAO_LINK) && !PathIsRemote(szPath))
                {
                    if (!g_hmodNTSHRUI)
                    {
                        g_hmodNTSHRUI = LoadLibrary(L"ntshrui.dll");
                    }

                    if (g_hmodNTSHRUI)
                    {
                        PFNCANSHAREFOLDERW pfnCanShareFolder = (PFNCANSHAREFOLDERW)GetProcAddress(g_hmodNTSHRUI, "CanShareFolderW");
                        if (pfnCanShareFolder)
                        {
                            *puisState = (S_OK == pfnCanShareFolder(szPath)) ? UIS_ENABLED : UIS_DISABLED;
                        }
                    }
                }
                ILFree(pidl);
            }
            psi->Release();
        }
    }

    return hr;
}

HRESULT CDefView::_CanEmail(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    DWORD dwAttributes = 0;

    // Prevent people from attempting to e-mail non-filesystem objects.
    // Attempting to attach such objects to an e-mail message fails.
    // An example of this type of failure is attempting to e-mail
    // connectoids in the "Network Connections" folder.

    if (psiItemArray)
    {
        psiItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, SFGAO_FILESYSTEM, &dwAttributes);
    }

    *puisState = dwAttributes & SFGAO_FILESYSTEM ? UIS_ENABLED : UIS_DISABLED;

    return S_OK;
}

HRESULT CDefView::_CanPrint(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (!(((CDefView*)(void*)pv)->_wvLayout.dwLayout & SFVMWVL_NOPRINT))
        return _HasPrintVerb(pv, psiItemArray, fOkToBeSlow, puisState);

    *puisState = UIS_HIDDEN;
    return S_OK;
}

HRESULT CDefView::_HasPrintVerb(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{

    CDefView* pThis = (CDefView*)(void*)pv;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    BOOL fHasPrint = _DoesStaticMenuHaveVerb(psiItemArray,c_szPrintW);

    *puisState = (fHasPrint) ? UIS_ENABLED : UIS_HIDDEN;

    return S_OK;
}
HRESULT CDefView::_CanDelete(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANDELETE, SFGAO_CANDELETE, puisState);
}
// determines if defview is hosted over the system drive root or not
BOOL CDefView::_IsSystemDrive(void)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szSystemDrive[4];
    BOOL bResult = FALSE;

    if (SUCCEEDED(_GetPath(szPath)))
    {
        SHExpandEnvironmentStrings (TEXT("%SystemDrive%\\"), szSystemDrive, ARRAYSIZE(szSystemDrive));

        if (!lstrcmpi(szPath, szSystemDrive))
        {
            bResult = TRUE;
        }
    }

    return bResult;
}
HRESULT CDefView::_CanViewDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (pThis->_fBarrierDisplayed)
        {
            if (pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanHideDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (!pThis->_fBarrierDisplayed)
        {
            if (pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanViewFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (pThis->_fBarrierDisplayed)
        {
            if (!pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanHideFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (!pThis->_fBarrierDisplayed)
        {
            if (!pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_DoVerb(IShellItemArray *psiItemArray, LPCSTR pszVerbA)
{
    HRESULT hr = E_FAIL;

    if (NULL== psiItemArray)
    {
        IContextMenu* pcm;
        hr = GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            hr = _InvokeContextMenuVerb(pcm, pszVerbA, 0, CMIC_MASK_FLAG_LOG_USAGE);
            pcm->Release();
        }
    }
    else
    {
        ASSERT(psiItemArray == _pSelectionShellItemArray);
        hr = _InvokeContextMenuVerbOnSelection(pszVerbA, 0, CMIC_MASK_FLAG_LOG_USAGE);
    }

    return hr;
}

HRESULT CDefView::_DoDropOnClsid(REFCLSID clsidDrop, IDataObject* pdo)
{
    HRESULT hr = E_FAIL;
    IDataObject *pdoFree = NULL;

    if (!pdo)
    {
        IShellItemArray *pFolder = _GetFolderAsShellItemArray();
        if (pFolder)
        {
            hr = pFolder->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdoFree));
            if (SUCCEEDED(hr))
            {
                pdo = pdoFree;
            }
            else
            {
                pdoFree = NULL;
            }
        }
    }

    if (pdo)
    {
        hr = SHSimulateDropOnClsid(clsidDrop, SAFECAST(this, IOleCommandTarget *), pdo);
    }

    ATOMICRELEASE(pdoFree); // may be NULL

    return hr;
}

HRESULT CDefView::_OnNewFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szNewFolderA);
}

HRESULT CDefView::_OnRename(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->DoRename();
}

HRESULT CDefView::_OnMove(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoMoveOrCopyTo(CLSID_MoveToMenu, psiItemArray);
}

HRESULT CDefView::_OnCopy(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoMoveOrCopyTo(CLSID_CopyToMenu, psiItemArray);
}

HRESULT CDefView::_OnPublish(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = S_OK;
    IDataObject *pdo = NULL;

    CDefView* pThis = (CDefView*)(void*)pv;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {
        hr = pThis->_DoDropOnClsid(CLSID_PublishDropTarget, pdo);
    }

    ATOMICRELEASE(pdo); // may be NULL

    return hr;
}

HRESULT CDefView::_OnShare(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;

    CDefView* pThis = (CDefView*)(void*)pv;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    if (NULL != psiItemArray)
    {
        LPOLESTR pszPath;

        hr = pThis->_GetFullPathNameAt(psiItemArray, 0, &pszPath);

        if (SUCCEEDED(hr))
        {
            if (!g_hmodNTSHRUI)
            {
                g_hmodNTSHRUI = LoadLibrary(L"ntshrui.dll");
            }

            if (g_hmodNTSHRUI)
            {
                PFNSHOWSHAREFOLDERUIW pfnShowShareFolderUI = (PFNSHOWSHAREFOLDERUIW) GetProcAddress(g_hmodNTSHRUI, "ShowShareFolderUIW");
                if (pfnShowShareFolderUI)
                {
                    pfnShowShareFolderUI(pThis->_hwndMain, pszPath);
                }
            }

            CoTaskMemFree(pszPath);
        }
    }

    return hr;
}

HRESULT CDefView::_OnEmail(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;
    IDataObject *pdo = NULL;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }

    if (SUCCEEDED(hr))
    {
        CDefView* pThis = (CDefView*)(void*)pv;
        BOOL bNoFilesFoundToEmail = TRUE;

        INamespaceWalk *pnsw;
        hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
        if (SUCCEEDED(hr))
        {
            // Note:
            //  To mirror the behaviour of the selection context menu's "Send To->
            //  Mail Recipient", don't traverse links, mail the link file itself.

            hr = pnsw->Walk(pdo, NSWF_DONT_TRAVERSE_LINKS, 0, NULL);
            if (SUCCEEDED(hr))
            {
                UINT cItems;
                LPITEMIDLIST *ppidls;
                hr = pnsw->GetIDArrayResult(&cItems, &ppidls);
                if (SUCCEEDED(hr))
                {
                    if (cItems)
                    {
                        IDataObject* pdoWalk;
                        hr = SHCreateFileDataObject(&c_idlDesktop, cItems, (LPCITEMIDLIST *)ppidls, NULL, (IDataObject **)&pdoWalk);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThis->_DoDropOnClsid(CLSID_MailRecipient, pdoWalk);
                            bNoFilesFoundToEmail = FALSE;
                            pdoWalk->Release();
                        }
                    }
                    FreeIDListArray(ppidls, cItems);
                }
            }
            pnsw->Release();
        }

        if (bNoFilesFoundToEmail)
        {
            // No items found to e-mail (selected folders contained no files).
            ShellMessageBox(
                HINST_THISDLL,
                pThis->_hwndMain,
                MAKEINTRESOURCE(IDS_NOFILESTOEMAIL),
                NULL,
                MB_OK | MB_ICONERROR);
        }

        pdo->Release();
    }
    return hr;
}

HRESULT CDefView::_OnPrint(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szPrintA);
}

HRESULT CDefView::_OnDelete(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szDeleteA);
}

HRESULT CDefView::RemoveBarricade (void)
{
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        TCHAR szValueName[MAX_PATH];
        if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
        {
            SetBarricadeStatus (szValueName, VARIANT_FALSE);
        }
        ILFree(pidl);
    }

    // Restore "View" menu commands which were stripped.
    RecreateMenus();
    // Enable "View Menu" button on the toolbar.
    EnableToolbarButton(SFVIDM_VIEW_VIEWMENU, TRUE);

    _fBarrierDisplayed = FALSE;

    return _pDUIView->EnableBarrier(FALSE);
}

HRESULT CDefView::_OnView(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    return pThis->RemoveBarricade();
}

HRESULT CDefView::_OnHide(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    LPITEMIDLIST pidl = pThis->_GetViewPidl();
    if (pidl)
    {
        TCHAR szValueName[MAX_PATH];
        if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
        {
            SetBarricadeStatus(szValueName, VARIANT_TRUE);
        }
        ILFree(pidl);
    }

    // Disable "View Menu" button on the toolbar.
    pThis->EnableToolbarButton(SFVIDM_VIEW_VIEWMENU, FALSE);

    pThis->_fBarrierDisplayed = TRUE;

    return pThis->_pDUIView->EnableBarrier(TRUE);
}

HRESULT CDefView::_OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HCURSOR hcOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    SHRunControlPanel(L"appwiz.cpl", NULL);

    SetCursor(hcOld);

    return S_OK;
}

HRESULT CDefView::_OnSearchFiles(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    return IUnknown_ShowBrowserBar (pThis->_psb, CLSID_FileSearchBand, TRUE);
}


const WVTASKITEM c_DefviewBlockadeTaskHeader = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE_TT);
const WVTASKITEM c_DefviewBlockadeTasks[] =
{
    WVTI_ENTRY_ALL(UICID_ViewContents,      L"shell32.dll", IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE,    IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE_TT, IDI_STSPROGS,   CDefView::_CanViewDrives, CDefView::_OnView),
    WVTI_ENTRY_ALL(UICID_HideContents,      L"shell32.dll", IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE,    IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE_TT, IDI_STSPROGS,   CDefView::_CanHideDrives, CDefView::_OnHide),
    WVTI_ENTRY_ALL(UICID_ViewContents,      L"shell32.dll", IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER,   IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER_TT,IDI_STSPROGS,   CDefView::_CanViewFolder, CDefView::_OnView),
    WVTI_ENTRY_ALL(UICID_HideContents,      L"shell32.dll", IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER,   IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER_TT,IDI_STSPROGS,   CDefView::_CanHideFolder, CDefView::_OnHide),
    WVTI_ENTRY_ALL(UICID_AddRemovePrograms, L"shell32.dll", IDS_TASK_ARP,                           IDS_TASK_ARP_TT,                        IDI_CPCAT_ARP,  NULL,                     CDefView::_OnAddRemovePrograms),
    WVTI_ENTRY_ALL(UICID_SearchFiles,       L"shell32.dll", IDS_TASK_SEARCHFORFILES,                IDS_TASK_SEARCHFORFILES_TT,             IDI_STFIND,     NULL,                     CDefView::_OnSearchFiles),
};


const WVTASKITEM c_DefviewFileFolderTasksHeaders = WVTI_HEADER(L"shell32.dll", IDS_HEADER_FILEFOLDER, IDS_HEADER_FILEFOLDER_TT);
const WVTASKITEM c_DefviewItemFolderTasksHeaders = WVTI_HEADER(L"shell32.dll", IDS_HEADER_ITEMFOLDER, IDS_HEADER_ITEMFOLDER_TT);

const WVTASKITEM c_DefviewFileFolderTasks[] =
{
    WVTI_ENTRY_NOSELECTION(UICID_NewFolder, L"shell32.dll", IDS_TASK_CURFOLDER_NEWFOLDER,                                                                           IDS_TASK_CURFOLDER_NEWFOLDER_TT, IDI_TASK_NEWFOLDER, CDefView::_CanWrite,
        CDefView::_OnNewFolder),
    WVTI_ENTRY_TITLE(UICID_Rename,          L"shell32.dll",                             IDS_TASK_RENAME_FILE, IDS_TASK_RENAME_FOLDER,       0,                      IDS_TASK_RENAME_FILE_TT,         IDI_TASK_RENAME,    CDefView::_CanRename,
        CDefView::_OnRename),
    WVTI_ENTRY_TITLE(UICID_Move,            L"shell32.dll",                             IDS_TASK_MOVE_FILE,   IDS_TASK_MOVE_FOLDER,         IDS_TASK_MOVE_ITEMS,    IDS_TASK_MOVE_TT,                IDI_TASK_MOVE,      CDefView::_CanMove,
        CDefView::_OnMove),
    WVTI_ENTRY_ALL_TITLE(UICID_Copy,        L"shell32.dll", 0,                          IDS_TASK_COPY_FILE,   IDS_TASK_COPY_FOLDER,         IDS_TASK_COPY_ITEMS,    IDS_TASK_COPY_TT,                IDI_TASK_COPY,      CDefView::_CanCopy,
        CDefView::_OnCopy),
    WVTI_ENTRY_ALL_TITLE(UICID_Publish,     L"shell32.dll", IDS_TASK_PUBLISH_FOLDER,    IDS_TASK_PUBLISH_FILE,IDS_TASK_PUBLISH_FOLDER,      IDS_TASK_PUBLISH_ITEMS, IDS_TASK_PUBLISH_TT,             IDI_TASK_PUBLISH,   CDefView::_CanPublish,
        CDefView::_OnPublish),
    WVTI_ENTRY_ALL_TITLE(UICID_Share,       L"shell32.dll", IDS_TASK_SHARE_FOLDER,      0,                    IDS_TASK_SHARE_FOLDER,        0,                      IDS_TASK_SHARE_TT,               IDI_TASK_SHARE,     CDefView::_CanShare,
        CDefView::_OnShare),
    WVTI_ENTRY_TITLE(UICID_Email,           L"shell32.dll",                             IDS_TASK_EMAIL_FILE,  IDS_TASK_EMAIL_FOLDER,        IDS_TASK_EMAIL_ITEMS,   IDS_TASK_EMAIL_TT,               IDI_TASK_EMAILFILE, CDefView::_CanEmail,
        CDefView::_OnEmail),
    WVTI_ENTRY_TITLE(UICID_Print,           L"shell32.dll",                             IDS_TASK_PRINT_FILE,  0,                            0,                      IDS_TASK_PRINT_TT,               IDI_TASK_PRINT,     CDefView::_CanPrint,
        CDefView::_OnPrint),
    WVTI_ENTRY_TITLE(UICID_Delete,          L"shell32.dll",                             IDS_TASK_DELETE_FILE, IDS_TASK_DELETE_FOLDER,       IDS_TASK_DELETE_ITEMS,  IDS_TASK_DELETE_TT,              IDI_TASK_DELETE,    CDefView::_CanDelete,
        CDefView::_OnDelete),
};
const size_t c_cDefviewFileFolderTasks = ARRAYSIZE(c_DefviewFileFolderTasks);

const WVTASKITEM c_DefviewItemFolderTasks[] =
{
    WVTI_ENTRY_NOSELECTION(UICID_NewFolder, L"shell32.dll", IDS_TASK_CURFOLDER_NEWFOLDER,                                                                           IDS_TASK_CURFOLDER_NEWFOLDER_TT, IDI_TASK_NEWFOLDER, CDefView::_CanWrite,
        CDefView::_OnNewFolder),
    WVTI_ENTRY_TITLE(UICID_Rename,          L"shell32.dll",                             IDS_TASK_RENAME_ITEM, IDS_TASK_RENAME_FOLDER,       0,                      IDS_TASK_RENAME_ITEM_TT,         IDI_TASK_RENAME,    CDefView::_CanRename,
        CDefView::_OnRename),
    WVTI_ENTRY_TITLE(UICID_Move,            L"shell32.dll",                             IDS_TASK_MOVE_ITEM,   IDS_TASK_MOVE_FOLDER,         IDS_TASK_MOVE_ITEMS,    IDS_TASK_MOVE_TT,                IDI_TASK_MOVE,      CDefView::_CanMove,
        CDefView::_OnMove),
    WVTI_ENTRY_ALL_TITLE(UICID_Copy,        L"shell32.dll", 0,                          IDS_TASK_COPY_ITEM,   IDS_TASK_COPY_FOLDER,         IDS_TASK_COPY_ITEMS,    IDS_TASK_COPY_TT,                IDI_TASK_COPY,      CDefView::_CanCopy,
        CDefView::_OnCopy),
    WVTI_ENTRY_ALL_TITLE(UICID_Share,       L"shell32.dll", IDS_TASK_SHARE_FOLDER,      0,                    IDS_TASK_SHARE_FOLDER,        0,                      IDS_TASK_SHARE_TT,               IDI_TASK_SHARE,     CDefView::_CanShare,
        CDefView::_OnShare),
    WVTI_ENTRY_TITLE(UICID_Delete,          L"shell32.dll",                             IDS_TASK_DELETE_ITEM, IDS_TASK_DELETE_FOLDER,       IDS_TASK_DELETE_ITEMS,  IDS_TASK_DELETE_TT,              IDI_TASK_DELETE,    CDefView::_CanDelete,
        CDefView::_OnDelete),
};
const size_t c_cDefviewItemFolderTasks = ARRAYSIZE(c_DefviewItemFolderTasks);

const WVTASKITEM c_DefviewOtherPlaces = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES_TT);
const WVTASKITEM c_DefviewDetails = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS_TT);


const WVTASKITEM* CDefView::_FindTaskItem(REFGUID guidCanonicalName)
{
    const BOOL bFileFolderTasks = _wvLayout.dwLayout & SFVMWVL_FILES;
    const WVTASKITEM *paTasks = bFileFolderTasks ? c_DefviewFileFolderTasks  : c_DefviewItemFolderTasks;
    const size_t cTasks =       bFileFolderTasks ? c_cDefviewFileFolderTasks : c_cDefviewItemFolderTasks;

    for (size_t i = 0; i < cTasks; i++)
        if (IsEqualGUID(*(paTasks[i].pguidCanonicalName), guidCanonicalName))
            return &paTasks[i];

    return NULL;
}

HRESULT CDefView::get_Name(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszName)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Name(pTask, psiItemArray, ppszName);
    return E_FAIL;
}

HRESULT CDefView::get_Icon(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Icon(pTask, psiItemArray, ppszIcon);
    return E_FAIL;
}

HRESULT CDefView::get_Tooltip(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Tooltip(pTask, psiItemArray, ppszInfotip);
    return E_FAIL;
}

HRESULT CDefView::get_State(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, UISTATE* puisState)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_State(pTask, SAFECAST(this, IShellView2*), psiItemArray, TRUE, puisState);
    return E_FAIL;
}

HRESULT CDefView::Invoke(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::Invoke(pTask, SAFECAST(this, IShellView2*), psiItemArray, pbc);
    return E_FAIL;
}

HRESULT CDefView::_GetDefaultWebviewContent(BOOL bFileFolderTasks)
{
    if (!_wvTasks.penumSpecialTasks)
    {
        if (_wvContent.dwFlags & SFVMWVF_BARRICADE)
        {
           // defview provides a default penumSpecialTasks for barricaded folders
           Create_IUIElement(&c_DefviewBlockadeTaskHeader, &(_wvContent.pSpecialTaskHeader));

           Create_IEnumUICommand((IUnknown*)(void*)this, c_DefviewBlockadeTasks, ARRAYSIZE(c_DefviewBlockadeTasks), &(_wvTasks.penumSpecialTasks));
        }
    }

    if (!_wvTasks.penumFolderTasks)
    {
        if (_wvContent.pFolderTaskHeader)
            _wvContent.pFolderTaskHeader->Release();
        Create_IUIElement(bFileFolderTasks ? &c_DefviewFileFolderTasksHeaders : &c_DefviewItemFolderTasksHeaders, &(_wvContent.pFolderTaskHeader));

        Create_IEnumUICommand(
            (IUnknown*)(void*)this,
            bFileFolderTasks ? c_DefviewFileFolderTasks  : c_DefviewItemFolderTasks,
            bFileFolderTasks ? c_cDefviewFileFolderTasks : c_cDefviewItemFolderTasks,
            &(_wvTasks.penumFolderTasks));
    }

    if (!_wvContent.penumOtherPlaces)
    {
        LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_NETWORK) };

        LPITEMIDLIST pidl = _GetViewPidl();

        CreateIEnumIDListOnCSIDLs(pidl, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &_wvContent.penumOtherPlaces);

        if (pidl)
            ILFree(pidl);
    }

    ASSERT(NULL==_pOtherPlacesHeader);
    Create_IUIElement(&c_DefviewOtherPlaces, &_pOtherPlacesHeader);

    ASSERT(NULL==_pDetailsHeader);
    Create_IUIElement(&c_DefviewDetails, &_pDetailsHeader);

    return S_OK;
}

void CDefView::_FreeWebViewContentData()
{
    ATOMICRELEASE(_wvContent.pSpecialTaskHeader);
    ATOMICRELEASE(_wvContent.pFolderTaskHeader);
    ATOMICRELEASE(_wvContent.penumOtherPlaces);
    ATOMICRELEASE(_wvTasks.penumSpecialTasks);
    ATOMICRELEASE(_wvTasks.penumFolderTasks);

    ATOMICRELEASE(_pOtherPlacesHeader);
    ATOMICRELEASE(_pDetailsHeader);

    _fQueryWebViewData = FALSE;
    _wvLayout.dwLayout = -1; // an invalid value
}

BOOL CDefView::_QueryBarricadeState()
{
    BOOL bResult = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        //
        // Control panel is a special case.
        // The barricade is used to represent 'category view' which can
        // be turned on/off by the user.  We must always ask control panel
        // if it's barricade is on or off.
        //
        BOOL bIsControlPanel = FALSE;
        LPITEMIDLIST pidlControlPanel;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlControlPanel)))
        {
            bIsControlPanel = ILIsEqual(pidl, pidlControlPanel);
            ILFree (pidlControlPanel);
        }
        if (bIsControlPanel)
        {
            SFVM_WEBVIEW_CONTENT_DATA wvc;
            if (SUCCEEDED(CallCB(SFVM_GETWEBVIEWCONTENT, 0, (LPARAM)&wvc)))
            {
                //
                // Control Panel doesn't provide all the standard
                // webview content so it's doing nothing more than setting
                // the dwFlags member.  Assert to ensure this doesn't
                // change in the future without us knowing about it.
                //
                ASSERT(NULL == wvc.pIntroText);
                ASSERT(NULL == wvc.pSpecialTaskHeader);
                ASSERT(NULL == wvc.pFolderTaskHeader);
                ASSERT(NULL == wvc.penumOtherPlaces);
                bResult = (0 != (SFVMWVF_BARRICADE & wvc.dwFlags));
            }
        }
        else if (_wvContent.dwFlags & SFVMWVF_BARRICADE)
        {
            if (!IsBarricadeGloballyOff())
            {
                TCHAR szValueName[MAX_PATH];
                if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
                {
                    if (VARIANT_TRUE == GetBarricadeStatus(szValueName))
                    {
                        bResult = TRUE;
                    }
                }
            }
        }
        ILFree(pidl);
    }
    return bResult;
}

void CDefView::_ShowLegacyWatermark()
{
    BOOL fShowLegacyWatermark = TRUE;
    LVBKIMAGE lvbki = {0};

    if (_pszLegacyWatermark)
    {
        lvbki.ulFlags = LVBKIF_SOURCE_URL | LVBKIF_STYLE_TILE;
        lvbki.pszImage = _pszLegacyWatermark;
    }
    else
    {
        // this code path is used to clear the watermark
        lvbki.ulFlags = LVBKIF_TYPE_WATERMARK;

        // if we're turning off the legacy watermark, we may have to turn on the theme one
        if (_idThemeWatermark && _pDUIView)
        {
            fShowLegacyWatermark = FALSE;
        }
    }

    if (fShowLegacyWatermark)
        ListView_SetBkImage(_hwndListview, &lvbki);
    else
        _ShowThemeWatermark();
}

void CDefView::_ShowThemeWatermark()
{
    BOOL fShowLegacyWatermark = TRUE;

    if (_idThemeWatermark && _pDUIView)
    {
        HINSTANCE hinstTheme = _pDUIView->_GetThemeHinst();

        LVBKIMAGE lvbki = {0};
        lvbki.ulFlags = LVBKIF_TYPE_WATERMARK;
        lvbki.hbm = DUILoadBitmap(hinstTheme, _idThemeWatermark, LR_DEFAULTCOLOR);
        if (lvbki.hbm)
        {
            // If the window color doesn't match the background color of the watermark,
            // then we'll hide the watermark.
            HDC hDC = CreateCompatibleDC(NULL);

            if (hDC)
            {
                HBITMAP hOldBitmap;

                hOldBitmap = (HBITMAP)SelectObject (hDC, lvbki.hbm);

                if (GetPixel(hDC, 0, 0) != GetSysColor(COLOR_WINDOW))
                {
                    _idThemeWatermark = 0;
                }

                SelectObject (hDC, hOldBitmap);
                DeleteDC (hDC);
            }

            if (_idThemeWatermark && ListView_SetBkImage(_hwndListview, &lvbki))
            {
                fShowLegacyWatermark = FALSE;
            }
            else
            {
                DeleteObject(lvbki.hbm);
            }
        }

        if (fShowLegacyWatermark)
            _idThemeWatermark = 0; // something failed, pretend we don't have one
    }

    // usually this will just hide the previous watermark
    if (fShowLegacyWatermark)
    {
        _ShowLegacyWatermark();
    }
}

void CDefView::_SetThemeWatermark()
{
    UINT idThemeWatermark = 0;

    if (_pDUIView)
    {
        const WVTHEME* pwvTheme = _pDUIView->GetThemeInfo();
        if (pwvTheme && pwvTheme->idListviewWatermark)
        {
            HINSTANCE hinstTheme = _pDUIView->_GetThemeHinst();
            if (HINST_THISDLL != hinstTheme)
            {
                // Only add the watermark if the machine is fast enough...
                if (SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewWatermark"),
                        FALSE, // Don't ignore HKCU
                        FALSE)) // Assume not fast enough
                {
                    idThemeWatermark = pwvTheme->idListviewWatermark;
                }
            }
        }
    }

    if (idThemeWatermark != _idThemeWatermark)
    {
        _idThemeWatermark = idThemeWatermark;

        // Since DUI Document view isn't themed, legacy watermarks have precedence there.
        // Might as well have them take precedence for My Pictures too...
        if (!_pszLegacyWatermark)
        {
            _ShowThemeWatermark();
        }
    }
}

void CDefView::_SetLegacyWatermark(LPCTSTR pszLegacyWatermark)
{
    Str_SetPtr(&_pszLegacyWatermark, pszLegacyWatermark);

    _ShowLegacyWatermark();
}

HRESULT CDefView::_TryShowWebView(UINT fvmNew, UINT fvmOld)
{
    SFVM_WEBVIEW_LAYOUT_DATA sfvmwvld = {0};

    HRESULT hr = E_FAIL;
    BOOL fShowDUI = FALSE;

    // The desktop IShellFolder doesn't know if it's in-frame or in the real desktop,
    // so only ask it for new DUIView if we're not the actual desktop.
    if (!_IsDesktop())
    {
        // Supporting SFVM_GETWEBVIEWLAYOUT means the folder wants our new
        // DUI View and they support SFVM_GETWEBVIEWCONTENT
        //
        hr = CallCB(SFVM_GETWEBVIEWLAYOUT, (WPARAM)fvmNew, (LPARAM)&sfvmwvld);

        fShowDUI = SUCCEEDED(hr);
    }

    // This folder doesn't specify the new DUIView, try the old WebView stuff
    if (!fShowDUI)
    {
        WCHAR wszMoniker[MAX_PATH];
        hr = _GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker));
        if (SUCCEEDED(hr))
        {
            if(_pDUIView)  //Hide it only if we are switching from DUI
                _TryHideWebView(); // just in case we're switching from DUI to Web View (can happen when customizing)

            if (wszMoniker[0])
            {
                hr = _SwitchToWebView(TRUE);
            }
        }

        // Okay, we don't have Web View, use the default DUI View
        if (FAILED(hr))
        {
            sfvmwvld.dwLayout = SFVMWVL_NORMAL;
            fShowDUI = TRUE;
        }
    }

    if (fShowDUI)
    {
        hr = S_OK;

        _cFrame.HideWebView(); // just in case we're switching from Web View to DUI View (can happen when customizing)

        if (sfvmwvld.dwLayout != _wvLayout.dwLayout)
        {
            if (!_fQueryWebViewData) // instead of this we could allow per-layout tasks...
            {
                CallCB(SFVM_GETWEBVIEWTHEME, 0, (LPARAM)&_wvTheme);

                // _FreeWebViewContentData(); if we have per-layout tasks...
                if (FAILED(CallCB(SFVM_GETWEBVIEWCONTENT, 0, (LPARAM)&_wvContent)))
                {
                    ZeroMemory(&_wvContent, sizeof(_wvContent));
                }

                if (0 == (SFVMWVF_ENUMTASKS & _wvContent.dwFlags))
                {
                    //
                    // View wants standard task sections.
                    // Non-standard task sections are enumerated in duiview.
                    //
                    if (FAILED(CallCB(SFVM_GETWEBVIEWTASKS, 0, (LPARAM)&_wvTasks)))
                    {
                        ZeroMemory(&_wvTasks, sizeof(_wvTasks));
                    }
                    _GetDefaultWebviewContent(sfvmwvld.dwLayout & SFVMWVL_FILES);
                }

                _fQueryWebViewData = TRUE;
            }

            CopyMemory(&_wvLayout, &sfvmwvld, sizeof(_wvLayout));
            _wvLayout.punkPreview = NULL;

            if (_pDUIView)
            {
                _pDUIView->EnablePreview(sfvmwvld.punkPreview);
            }
            else
            {
                _pDUIView = Create_CDUIView(this);
                if (_pDUIView)
                {
                    _fBarrierDisplayed = _QueryBarricadeState();

                    if (SUCCEEDED(_pDUIView->Initialize(_fBarrierDisplayed, 
                                                        sfvmwvld.punkPreview)))
                    {
                        if (((SFVMWVF_ENUMTASKS | SFVMWVF_CONTENTSCHANGE) & _wvContent.dwFlags) &&
                             _fRcvdContentsChangeBeforeDuiViewCreated)
                        {
                            //
                            // If the webview provider dynamically enumerates
                            // tasks or wants to be refreshed when contents change,
                            // (i.e. Control Panel), AND we received a 'contents change'
                            // before DUI View was created, initiate a 'contents change' now.
                            // Otherwise, such providers will not receive a 'contents change'
                            // and thus will not display their dynamic webview content.
                            //
                            _OnContentsChanged();
                        }
                    }
                    else
                    {
                        _pDUIView->Release();
                        _pDUIView = NULL;
                    }
                }
            }
        }
        else
        {
            // except potentially refresh if we need to add/remove our DUI Details minipreview
            if (_pDUIView && (_IsImageMode(fvmNew) != _IsImageMode(fvmOld)))
                _pDUIView->OnSelectionChange(_pSelectionShellItemArray);
        }

        ATOMICRELEASE(sfvmwvld.punkPreview);
    }

    _SetThemeWatermark();

    return hr;
}

HRESULT CDefView::_TryHideWebView()
{
    if (_pDUIView)
    {
        _pDUIView->DetachListview(); // so we detach and re-parent the listview synchronously
        //
        // Ensure DUser has shut down and handled all DUser messages
        // before we release our ref on CDUIView.
        //
        _pDUIView->UnInitializeDirectUI();
        _pDUIView->Release();
        _pDUIView = NULL;        // * necessary * because this is used internally as a state (must be BEFORE WndSize() below)
        _wvLayout.dwLayout = -1; // an invalid value
        _fListViewShown = FALSE; // CDUIView::DetachListview() does a SW_HIDE on the listview
        WndSize(_hwndView);      // resize _hwndView to account for DUI disappearing (otherwise
                                 // it will still be the smaller size expecting DUI to be drawn
                                 // next to it)
        ShowHideListView();
    }
    else
    {
        _SwitchToWebView(FALSE);
    }

    return S_OK;
}

// we are switching the listview view mode in this function, not dorking with web view content.
//
HRESULT CDefView::_SwitchToViewFVM(UINT fvmNew, UINT uiType)
{
    HRESULT hr = S_OK;
    UINT fvmOld = _fs.ViewMode;

    ASSERT(_hwndListview);

    HWND hwndCurrentFocus = GetFocus();
    BOOL bSetFocusRequired = HasCurrentViewWindowFocus();

    if (SWITCHTOVIEW_WEBVIEWONLY != uiType)
    {
        // if we haven't loaded the columns yet, do that now
        // Don't pre-load the columns for TileView, we are delaying the load on purpose for perf reasons.
        if (fvmNew == FVM_DETAILS)
        {
            AddColumns();
            _SetSortFeedback();
        }
        else if (fvmNew == FVM_THUMBSTRIP)
        {
            // Thumbstrip makes no sense in non-webview, fall back to thumbnail
            if (!_ShouldShowWebView())
            {
                fvmNew = FVM_THUMBNAIL;
            }
        }

        // Combined view only applies to large icon view
        if (_fCombinedView && fvmNew != FVM_ICON)
        {
            _fCombinedView = FALSE;
            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, 0);
            _SetFolderColors();
        }

        // First we turn OFF view specific stuff that is no longer needed
        switch (fvmOld)
        {
        case FVM_THUMBSTRIP:
            if (FVM_THUMBSTRIP != fvmNew)
            {
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SINGLEROW, 0);

                // we may have forced thumbstrip to auto-arrange, undo that if so
                if (!(_fs.fFlags & FWF_AUTOARRANGE))
                {
                    SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, 0);
                }
            }
            // fall through
        case FVM_THUMBNAIL:
            if (!_IsImageMode(fvmNew))
            {
                _ResetThumbview();

                // Since we are switching from thumbnail view, remove any thumbnail extraction tasks
                _RemoveThumbviewTasks();

                if (_fs.fFlags & FWF_OWNERDATA)
                {
                    InvalidateRect(_hwndListview, NULL, TRUE);
                }
                else
                {
                    ListView_InvalidateImageIndexes(_hwndListview);
                }
            }
            break;

        case FVM_TILE:
            if (!_IsTileMode(fvmNew))
            {
                if (_pScheduler)
                    _pScheduler->RemoveTasks(TOID_DVFileTypeProperties, ITSAT_DEFAULT_LPARAM, TRUE);

                // Remove the columns that
                // were pulled in because of tileview.
                _RemoveTileColumns();
            }
            break;
        }

        _SetView(fvmNew);   // we can now switch the listview around

        // Now that'we no longer in tileview, we can reset the tileinfo. If we were to do it
        // prior to changing the view, then listview would start asking us for the tileinformation
        // for each item again, and we'd pull in the tile columns again.
        if (fvmOld == FVM_TILE)
        {
            _RemoveTileInfo();
        }

        // Third, turn ON view specific stuff
        //
        switch (fvmNew)
        {
        case FVM_THUMBSTRIP:
            if (FVM_THUMBSTRIP!=fvmOld)
            {
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SINGLEROW, LVS_EX_SINGLEROW);

                // thumbstrip can not be in group view
                if (_fGroupView)
                    _ToggleGrouping();

                // thumbstrip is always in auto-arrange
                if (!(_fs.fFlags & FWF_AUTOARRANGE))
                {
                    _ClearItemPositions();
                    SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, LVS_AUTOARRANGE);
                }
            }
            // fall through
        case FVM_THUMBNAIL:
            if (!_IsImageMode(fvmOld))
            {
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    _fs.fFlags ^= FWF_HIDEFILENAMES;    // toggle
                }
                _SetThumbview();
                _DoThumbnailReadAhead();

                RECT rc = {1, 3, 4, 4};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;

        case FVM_TILE:
            if (!_IsTileMode(fvmOld))
            {
                _SetTileview();

                RECT rc = {3, 4, 4, 1};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;

        default:
            _SetSysImageList();

            {
                RECT rc = {1, 3, 4, 0};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;
        }
    }

    if (SWITCHTOVIEW_NOWEBVIEW != uiType)
    {
        // New to Whistler: a view mode transition may also entail a web view template change
        if (_ShouldShowWebView())
        {
            _TryShowWebView(fvmNew, fvmOld);
            _AutoAutoArrange(0);

            hr = S_OK; // we don't care about failure since we still get icons
        }
        else
        {
            _TryHideWebView();
        }
    }

    if (SWITCHTOVIEW_WEBVIEWONLY != uiType)
    {
        ShowHideListView();
        _AutoAutoArrange(0);
        if (bSetFocusRequired)
        {
            // _hwndListview is the current view window. Let's set focus to it.
            CallCB(SFVM_SETFOCUS, 0, 0);
            ViewWindowSetFocus();

            // notify image preview control to update its image
            if (fvmNew == FVM_THUMBSTRIP)
                _ThumbstripSendImagePreviewFocusChangeEvent();
        }
        else
        {
            SetFocus(hwndCurrentFocus);
        }
        CheckToolbar();
        // update menus, i.e. add Choose Columns to the view menu if Details view is selected
        // or remove it otherwise
        RecreateMenus();
        _EnableDisableTBButtons();
    }
    return hr;
}

// Description:
//  Notify image preview control to update its image.  The image preview
//  control uses focus change events to track when it should update the image
//  it is displaying.  When it receives a focus change event, it queries the
//  listview to see which item has focus, then displays that item in the
//  image preview window.  When nothing in the listview has focus (such as
//  when it has no items), the image preview window displays as empty.
//
//  This method fires the "focus changed" event which is picked up by the
//  image preview control, and causes it to update the image it's displaying.
//
void CDefView::_ThumbstripSendImagePreviewFocusChangeEvent()
{
    ASSERT(_fs.ViewMode == FVM_THUMBSTRIP);
    _FireEvent(DISPID_FOCUSCHANGED);
}

int CDefView::CheckCurrentViewMenuItem(HMENU hmenu)
{
    int iCurViewMenuItem = _GetMenuIDFromViewMode(_fs.ViewMode);

    CheckMenuRadioItem(hmenu, SFVIDM_VIEW_FIRSTVIEW, SFVIDM_VIEW_LASTVIEW,
                       iCurViewMenuItem, MF_BYCOMMAND | MF_CHECKED);

    return iCurViewMenuItem;
}

const UINT c_aiNonCustomizableFolders[] = {
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_SYSTEMX86,
    CSIDL_PROGRAM_FILES,
    CSIDL_PROGRAM_FILESX86,
    CSIDL_PERSONAL,
    CSIDL_MYDOCUMENTS,
    CSIDL_MYMUSIC,
    CSIDL_MYPICTURES,
    CSIDL_MYVIDEO,
    CSIDL_COMMON_DOCUMENTS,
    CSIDL_COMMON_MUSIC,
    CSIDL_COMMON_PICTURES,
    CSIDL_COMMON_VIDEO
};

// since we moved to the property bag this check is fast; we don't probe to see if we can create desktop.ini
// or anything.
BOOL IsCustomizable(LPCITEMIDLIST pidlFolder)
{
    BOOL fCustomizable = FALSE;

    if (!SHRestricted(REST_NOCUSTOMIZETHISFOLDER) && !SHRestricted(REST_CLASSICSHELL))
    {
        // Check if this is a file system folder.
        // customization requires the folder being a regular file system
        // folder. FILESYSTEMANCESTOR is the key bit here

        #define SFGAO_CUST_BITS (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_FILESYSANCESTOR)
        ULONG rgfFolderAttr = SFGAO_CUST_BITS;
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &rgfFolderAttr)) &&
            (SFGAO_CUST_BITS == (rgfFolderAttr & SFGAO_CUST_BITS)))
        {
            if (!PathIsOneOf(szPath, c_aiNonCustomizableFolders, ARRAYSIZE(c_aiNonCustomizableFolders)) &&
                (!PathIsRoot(szPath) || PathIsUNCServerShare(szPath)) &&
                !SHRestricted(REST_NOCUSTOMIZEWEBVIEW))
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHGetViewStatePropertyBag(pidlFolder, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    fCustomizable = TRUE;
                    ppb->Release();
                }
            }
        }
    }

    return fCustomizable;
}

// wrapper around IsCustomizable to save some state, plus some defview-specific logic.
BOOL CDefView::_CachedIsCustomizable()
{
    if (_IsDesktop() || _IsViewDesktop() || _IsCommonDialog())
    {
        _iCustomizable = NOT_CUSTOMIZABLE;
    }

    if (_iCustomizable == DONTKNOW_IF_CUSTOMIZABLE)
    {
        LPITEMIDLIST pidl = _GetViewPidl();
        if (pidl)
        {
            _iCustomizable = IsCustomizable(pidl) ? YES_CUSTOMIZABLE : NOT_CUSTOMIZABLE;
            ILFree(pidl);
        }
    }

    return (_iCustomizable != NOT_CUSTOMIZABLE);
}

BOOL CDefView::_InvokeCustomization()
{
    BOOL fRet = FALSE;

    if (!_CachedIsCustomizable())
    {
        //If not customizable, put up this error message!
        ShellMessageBox(HINST_THISDLL, _hwndMain, MAKEINTRESOURCE(IDS_NOTCUSTOMIZABLE), NULL,
                       MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        return FALSE;  // ...and bail out!
    }

    //Save the view state first.
    SaveViewState();

    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        TCHAR szSheetName[25];
        LoadString(HINST_THISDLL, IDS_CUSTOMIZE, szSheetName, ARRAYSIZE(szSheetName));
        SHELLEXECUTEINFO sei =
        {
            SIZEOF(sei),
            SEE_MASK_INVOKEIDLIST,      // fMask
            _hwndMain,                  // hwnd
            c_szProperties,             // lpVerb
            NULL,                       // lpFile
            szSheetName,                // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            pidl,                       // lpIDList
            NULL,                       // lpClass
            0,                          // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        fRet = ShellExecuteEx(&sei);

        ILFree(pidl);
    }
    return fRet;
}

struct {
    UINT uiSfvidm;
    DWORD dwOlecmdid;
} const c_CmdTable[] = {
    { SFVIDM_EDIT_CUT,          OLECMDID_CUT        },
    { SFVIDM_EDIT_COPY,         OLECMDID_COPY       },
    { SFVIDM_EDIT_PASTE,        OLECMDID_PASTE      },
    { SFVIDM_FILE_DELETE,       OLECMDID_DELETE     },
    { SFVIDM_FILE_PROPERTIES,   OLECMDID_PROPERTIES },
};

DWORD OlecmdidFromSfvidm(UINT uiSfvidm)
{
    DWORD dwOlecmdid = 0;

    for (int i = 0; i < ARRAYSIZE(c_CmdTable); i++)
    {
        if (c_CmdTable[i].uiSfvidm == uiSfvidm)
        {
            dwOlecmdid = c_CmdTable[i].dwOlecmdid;
            break;
        }
    }

    return dwOlecmdid;
}

void HideIE4DesktopChannelBar()
{
    HWND hwndChannelBar;
    //Check if the channel bar is currently running. If so, turn it off!
    if ((hwndChannelBar = FindWindowEx(GetShellWindow(), NULL, TEXT("BaseBar"), TEXT("ChanApp"))) ||
        (hwndChannelBar = FindWindowEx(NULL, NULL, TEXT("BaseBar"), TEXT("ChanApp")))) // can be a toplevel window
    {
        //Close the channel bar.
        PostMessage(hwndChannelBar, WM_CLOSE, 0, 0);
    }
 }

// Wrapper around _SwitchToWebView to do desktop-specific stuff
LRESULT CDefView::_SwitchDesktopHTML(BOOL fShow)
{
    LRESULT lRes;

    if (fShow)
    {
        // Do this early to give the desktop a chance to regenerate it's webview template
        _CallRefresh(TRUE);

        lRes = SUCCEEDED(_SwitchToWebView(TRUE));

        if (lRes)
        {
            HideIE4DesktopChannelBar();
        }
    }
    else
    {
        _SwitchToWebView(FALSE);
        CoFreeUnusedLibraries();
        lRes = TRUE;
    }

    return lRes;
}
void CDefView::_DoColumnsMenu(int x, int y) // X and Y are screen coordinates
{
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        AddColumnsToMenu(hmenu, SFVIDM_COLUMN_FIRST);

        int item = TrackPopupMenu(hmenu, TPM_TOPALIGN | TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                                  x, y, 0, _hwndListview, NULL);
        DestroyMenu(hmenu);

        // validate item first
        if (item == SFVIDM_VIEW_COLSETTINGS)
        {
            CColumnDlg ccd(this);

            AddColumns();

            ccd.ShowDialog(_hwndMain);
        }
        else if (item > SFVIDM_COLUMN_FIRST)
        {
            _HandleColumnToggle(item - SFVIDM_COLUMN_FIRST, TRUE);
        }
    }
}

BOOL CDefView::_ArrangeBy(UINT idCmd)
{
    int iColumn = idCmd - SFVIDM_GROUPSFIRST;
    BOOL fAllowToggle = TRUE;

    // We want to enter group by if We already have a group, or if this is an extended grouping
    if ((_fGroupView || InRange(idCmd, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST)) &&
        !(_fs.ViewMode == FVM_LIST))
    {
        _GroupBy(idCmd);
        iColumn = 0;        // Arrange by name, when grouping
        fAllowToggle = FALSE; // Always arrange in ascending order
    }
    return S_OK == _OnRearrange(iColumn, fAllowToggle);
}

BOOL CDefView::_InitArrangeMenu(HMENU hmInit)
{
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    GetMenuItemInfo(hmInit, SFVIDM_MENU_ARRANGE, MF_BYCOMMAND, &mii);
    HMENU hmenuCtx = mii.hSubMenu;

    if (hmenuCtx)
    {
        int idToCheck = -1;
        AddColumns();
        UINT cVisible = _RealToVisibleCol(-1) + 1;   // count
        ICategoryProvider* pcp = NULL;
        _pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp));

        while (1)
        {
            MENUITEMINFO miiSep = {0};
            miiSep.cbSize = sizeof(mii);
            miiSep.fMask = MIIM_ID | MIIM_TYPE;
            miiSep.wID = -1;

            if (!GetMenuItemInfo(hmenuCtx, 0, MF_BYPOSITION, &miiSep) ||
                miiSep.wID == SFVIDM_GROUPSEP)
            {
                break;
            }

            DeleteMenu(hmenuCtx, 0, MF_BYPOSITION);
        }

        UINT iInsert = 0;
        for (UINT i = 0; i < cVisible; i++)
        {
            BOOL fAddItem = TRUE;
            UINT iReal = _VisibleToRealCol(i);
            if (_IsDetailsColumn(iReal))
            {

                // See if the category Provider wants to exclude this column when groupview is enabled
                if (pcp && _fGroupView)
                {
                    SHCOLUMNID scid;
                    if (SUCCEEDED(_pshf2->MapColumnToSCID(iReal, &scid)))
                    {
                        // returns S_FALSE to remove.
                        fAddItem = (S_OK == pcp->CanCategorizeOnSCID(&scid));
                    }
                }

                if (fAddItem)
                {
                    WCHAR wszName[MAX_COLUMN_NAME_LEN];
                    BOOL bpuiName = FALSE;
                    IPropertyUI *ppui;

                    // Attempt to retrieve mnemonic name from IPropertyUI interface.
                    if (_pshf2 && SUCCEEDED(_GetPropertyUI(&ppui)))
                    {
                        SHCOLUMNID scid;

                        if (SUCCEEDED(_pshf2->MapColumnToSCID(iReal, &scid)))
                        {
                            bpuiName = SUCCEEDED(ppui->GetDisplayName(scid.fmtid, scid.pid, PUIFNF_MNEMONIC, wszName, ARRAYSIZE(wszName)));
                        }

                        ppui->Release();
                    }

                    MENUITEMINFO miiItem = {0};
                    miiItem.cbSize = sizeof(mii);
                    miiItem.fMask = MIIM_ID | MIIM_TYPE;
                    miiItem.fType = MFT_STRING;
                    miiItem.wID = iReal + SFVIDM_GROUPSFIRST;
                    miiItem.dwTypeData = bpuiName ? wszName : _vs.GetColumnName(iReal);
                    InsertMenuItem(hmenuCtx, iInsert++, TRUE, &miiItem);
                }
            }
        }

        _InitExtendedGroups(pcp, hmenuCtx, iInsert, &idToCheck);

        // Only do the Bullets if we're in auto arrange mode or if we are in details.
        if (_IsAutoArrange() || _fGroupView || _fs.ViewMode == FVM_DETAILS)
        {
            if (idToCheck == -1)
            {
                // Since we're not going to have more than 4million columns, this case should suffice
                idToCheck = (int)_vs._lParamSort + SFVIDM_GROUPSFIRST;
                if (_fGroupView &&
                    !(_fs.ViewMode == FVM_LIST))
                {
                    idToCheck = MapSCIDToColumn(_pshf2, &_vs._scidDetails) + SFVIDM_GROUPSFIRST;
                }
            }

            CheckMenuRadioItem(hmenuCtx, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSEXTENDEDLAST, idToCheck, MF_BYCOMMAND | MF_CHECKED);
        }

        if (pcp)
            pcp->Release();
    }

    DWORD dwGroupEnableFlags = MF_GRAYED;
    if (_pshf2 &&                           // Needs to implement IShellFolder2
        !_IsViewDesktop() &&                // Doesn't work on the desktop
        !(_fs.ViewMode == FVM_LIST) &&      // Doesn't work in 'List' View
        !(_fs.ViewMode == FVM_THUMBSTRIP) &&// Doesn't work in 'ThumbStrip' View
        !(_fs.fFlags & FWF_OWNERDATA))      // Doesn't work for ownerdata lists (search)
    {
        dwGroupEnableFlags = MF_ENABLED;
        CheckMenuItem(hmenuCtx, SFVIDM_GROUPBY, MF_BYCOMMAND | (_fGroupView?MF_CHECKED:0));
    }

    EnableMenuItem(hmenuCtx, SFVIDM_GROUPBY, MF_BYCOMMAND | dwGroupEnableFlags);

    _SHPrettyMenu(hmenuCtx);

    return TRUE;
}

BOOL CDefView::_InitExtendedGroups(ICategoryProvider* pcp, HMENU hmenuCtx, int iIndex, int* piIdToCheck)
{
    if (!pcp)
        return FALSE;

    *piIdToCheck = -1;
    if (_hdaCategories == NULL)
    {
        _hdaCategories = DSA_Create(sizeof(GUID), 5);
        if (_hdaCategories)
        {
            IEnumGUID* penum;
            if (SUCCEEDED(pcp->EnumCategories(&penum)))
            {
                GUID guidCat;
                while (S_OK == penum->Next(1, &guidCat, NULL))
                {
                    DSA_AppendItem(_hdaCategories, (void*)&guidCat);
                }

                penum->Release();
            }
        }
    }

    if (_hdaCategories)
    {
        int id = SFVIDM_GROUPSEXTENDEDFIRST;
        TCHAR szName[MAX_PATH];
        TCHAR szCurrentName[MAX_PATH];
        WCHAR wszName[MAX_PATH];
        GUID* pguidCat;

        szCurrentName[0] = 0;

        if (_pcat)
        {
            _pcat->GetDescription(szCurrentName, ARRAYSIZE(szCurrentName));
        }

        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.wID = -1;

        InsertMenuItem(hmenuCtx, iIndex, TRUE, &mii);

        iIndex++;

        int cCategories = DSA_GetItemCount(_hdaCategories);
        for (int i = 0; i < cCategories; i++)
        {
            pguidCat = (GUID*)DSA_GetItemPtr(_hdaCategories, i);

            if (SUCCEEDED(pcp->GetCategoryName(pguidCat, wszName, ARRAYSIZE(wszName))))
            {
                SHUnicodeToTChar(wszName, szName, ARRAYSIZE(szName));

                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;
                mii.fType = MFT_STRING;
                mii.dwItemData = (DWORD_PTR)pguidCat;
                mii.wID = id;
                mii.dwTypeData = szName;
                mii.cch = ARRAYSIZE(szName);

                InsertMenuItem(hmenuCtx, iIndex, TRUE, &mii);

                if (lstrcmpi(szCurrentName, szName) == 0)
                {
                    *piIdToCheck = id;
                }

                id++;
                iIndex++;
            }
        }
    }

    return TRUE;
}

BOOL CDefView::_CategorizeOnSCID(const SHCOLUMNID* pscid)
{
    BOOL fRet = FALSE;

    _fSlowGroup = FALSE;
    if (IsEqualSCID(*pscid, SCID_NAME))
    {
        if (SUCCEEDED(CAlphaCategorizer_Create(_pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_AlphabeticalCategorizer;
            fRet = TRUE;
        }
    }
    else if (IsEqualSCID(*pscid, SCID_SIZE))
    {
        if (SUCCEEDED(CSizeCategorizer_Create(_pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_SizeCategorizer;
            fRet = TRUE;
        }
    }
    else if (IsEqualSCID(*pscid, SCID_WRITETIME) ||
             IsEqualSCID(*pscid, SCID_CREATETIME) ||
             IsEqualSCID(*pscid, SCID_ACCESSTIME) ||
             IsEqualSCID(*pscid, SCID_DATEDELETED))
    {
        if (SUCCEEDED(CTimeCategorizer_Create(_pshf2, pscid, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_TimeCategorizer;
            fRet = TRUE;
        }
    }
    else
    {
        _fSlowGroup = TRUE;
        if (SUCCEEDED(CDetailCategorizer_Create(*pscid, _pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_DetailCategorizer;
            fRet = TRUE;
        }
    }

    if (fRet)
    {
        _vs._scidDetails = *pscid;
    }

    return fRet;
}

// slow groups have an architecture problem, after 5000 items in the view
// the message queue overflows from groupdone messages and its all bad.
// this ends up hanging the static flashlight window around because of resulting
// refcount issues.
// the only view that both defaults to a slow group and could have 5000 items is the
// cd burning folder.  lou says its too late to change the interface now to let the
// categorizer decide if its slow or not, so just special case it here.
// everything works if its a fast group (and its actually fast anyway).
BOOL CDefView::_IsSlowGroup(const GUID *pguid)
{
    BOOL fSlow = TRUE;
    if (IsEqualGUID(*pguid, CLSID_MergedCategorizer))
    {
        fSlow = FALSE;
    }
    // room to grow if we need to special case others
    return fSlow;
}

BOOL CDefView::_CategorizeOnGUID(const GUID* pguid, const SHCOLUMNID* pscid)
{
    BOOL fRet = FALSE;
    if (_pshf2)
    {
        _fGroupView = FALSE;    // Just in case the create fails
        if (_pScheduler)
            _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);

        ATOMICRELEASE(_pcat);

        ListView_RemoveAllGroups(_hwndListview);

        ICategoryProvider* pcp;
        if (SUCCEEDED(_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
        {
            GUID guidGroup = *pguid;
            if (pscid && S_OK != pcp->GetCategoryForSCID(const_cast<SHCOLUMNID*>(pscid), &guidGroup))
            {
                fRet = _CategorizeOnSCID(pscid);
            }
            else
            {
                _fSlowGroup = _IsSlowGroup(&guidGroup);
                if (SUCCEEDED(pcp->CreateCategory(&guidGroup, IID_PPV_ARG(ICategorizer, &_pcat))))
                {
                    _vs._guidGroupID = guidGroup;
                    if (pscid)
                    {
                        _vs._scidDetails = *pscid;
                    }
                    else
                    {
                        ZeroMemory(&_vs._scidDetails, sizeof(SHCOLUMNID));
                    }

                    fRet = TRUE;
                }
            }
            pcp->Release();
        }
        else
        {
            if (pscid)
                fRet = _CategorizeOnSCID(pscid);
        }
    }

    if (fRet)
    {
        _ClearItemPositions();
        _fGroupView = TRUE;
        SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, LVS_AUTOARRANGE);

        // We're enabling groupview, so turn off the selected column
        // (this will make it so tiles do not show the selected column as their first column)
        ListView_SetSelectedColumn(_hwndListview, -1);

        if (_fSlowGroup)
            _fAllowSearchingWindow = TRUE;

        ListView_EnableGroupView(_hwndListview, TRUE);
    }

    return fRet;
}

void CDefView::_GroupBy(int iColumn)
{
    _fGroupView = FALSE;    // Just in case the create fails

    if (_pshf2)
    {
        if (InRange(iColumn, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST))
        {
            int iIndex = iColumn - SFVIDM_GROUPSEXTENDEDFIRST;
            GUID* pguid = (GUID*)DSA_GetItemPtr(_hdaCategories, iIndex);
            if (pguid)
            {
                _CategorizeOnGUID(pguid, NULL);
            }
        }
        else
        {
            SHCOLUMNID scid;
            iColumn -= SFVIDM_GROUPSFIRST;

            if (SUCCEEDED(_pshf2->MapColumnToSCID(iColumn, &scid)))
            {
                _CategorizeOnGUID(&CLSID_DetailCategorizer, &scid);
            }
        }

        // Make sure the arrows on details view look right...
        _SetSortFeedback();
    }
}

void CDefView::_ToggleGrouping()
{
    if (_fGroupView)
    {
        _fGroupView = FALSE;
        if (_pScheduler)
            _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);

        ListView_EnableGroupView(_hwndListview, FALSE);
        ListView_RemoveAllGroups(_hwndListview);
        ListView_SetSelectedColumn(_hwndListview, _vs._lParamSort);
        _SetSortFeedback();
        _OnRearrange(_vs._lParamSort, FALSE);
    }
    else if (FVM_THUMBSTRIP != _fs.ViewMode) // Thumbstrip can never go into groupby mode
    {
        // If we have a categorizer, then we can just reenable grouping.
        if (_pcat)
        {
            _fGroupView = TRUE;

            ListView_EnableGroupView(_hwndListview, TRUE);
            ListView_SetSelectedColumn(_hwndListview, -1);
            _SetSortFeedback();
        }
        else
        {
            // If we don't, then we need to go get one.
            _GroupBy((int)_vs._lParamSort + SFVIDM_GROUPSFIRST);
        }
    }
}

LRESULT CDefView::_OnDefviewEditCommand(UINT uID)
{
    // if we are in label edit mode, don't allowany of the buttons......
    if (_fInLabelEdit)
    {
        MessageBeep(0);
        return 1;
    }

    if (_AllowCommand(uID))
    {
        HRESULT hr = _ExplorerCommand(uID);
        if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        {
            MessageBeep(0);
        }
        return 1;
    }
    else
    {
        return 0;
    }
}

HRESULT CDefView::_DoMoveOrCopyTo(REFCLSID clsid, IShellItemArray *psiItemArray)
{

    IDataObject *pdo = NULL;
    IContextMenu *pcm;
    HRESULT hr = E_FAIL;

    if (!psiItemArray)
    {
        psiItemArray = _GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {

        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(pcm, SAFECAST(this, IDropTarget *)); // Needed to go modal during UI

            IShellExtInit* psei;
            hr = pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlFolder = _GetViewPidl();
                if (pidlFolder)
                {
                    psei->Initialize(pidlFolder, pdo, NULL);
                    ILFree(pidlFolder);
                }

                CMINVOKECOMMANDINFO ici = {0};

                ici.hwnd = _hwndMain;
                hr = pcm->InvokeCommand(&ici);

                psei->Release();
            }

            IUnknown_SetSite(pcm, NULL);
            pcm->Release();
        }

        pdo->Release();
    }

    return hr;
}

void CDefView::_OnSetWebView(BOOL fOn)
{
    if (fOn)
    {
        _TryShowWebView(_fs.ViewMode, _fs.ViewMode);
    }
    else
    {
        _TryHideWebView();
    }
}

LRESULT CDefView::_OnCommand(IContextMenu *pcmToInvoke, WPARAM wParam, LPARAM lParam)
{
    UINT uID = GET_WM_COMMAND_ID(wParam, lParam);

    if (InRange(uID, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSEXTENDEDLAST))
    {
        _ArrangeBy(uID);
        return 1;
    }
    else if (InRange(uID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
    {
        UINT uCMBias = SFVIDM_CONTEXT_FIRST;

        if (_pcmFile)
        {
            IContextMenu* pcmToInvoke = _pcmFile;
            pcmToInvoke->AddRef();

            // We need to special case the rename command
            TCHAR szCommandString[64];
            ContextMenu_GetCommandStringVerb(pcmToInvoke, uID - SFVIDM_CONTEXT_FIRST, szCommandString, ARRAYSIZE(szCommandString));
            if (lstrcmpi(szCommandString, c_szRename) == 0)
            {
                DoRename();
            }
            else
            {
                CMINVOKECOMMANDINFOEX ici = { 0 };

                ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
                ici.hwnd = _hwndMain;
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(uID - SFVIDM_CONTEXT_FIRST);
                ici.nShow = SW_NORMAL;
                ici.fMask = CMIC_MASK_FLAG_LOG_USAGE;

                int iItemSelect = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
                if (iItemSelect != -1)
                {
                    RECT rcItem;
                    ListView_GetItemRect(_hwndListview, iItemSelect, &rcItem, LVIR_BOUNDS);
                    MapWindowPoints(_hwndListview, HWND_DESKTOP, (POINT *)&rcItem, 2);
                    ici.ptInvoke.x = (rcItem.left + rcItem.right) / 2;
                    ici.ptInvoke.y = (rcItem.top + rcItem.bottom) / 2;
                    ici.fMask |= CMIC_MASK_PTINVOKE;
                }

                // record if shift or control was being held down
                SetICIKeyModifiers(&ici.fMask);

                _InvokeContextMenu(pcmToInvoke, &ici);
            }

            //Since we are releaseing our only hold on the context menu, release the site.
            IUnknown_SetSite(pcmToInvoke, NULL);

            pcmToInvoke->Release();  // undo our gaurd ref
            ATOMICRELEASE(_pcmFile); // once used, it can't be used again
        }

        return 0;
    }
#ifdef DEBUG
    else if (InRange(uID, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
    {
        RIPMSG(FALSE, "_OnCommand should not get this context menu invoke...");
    }
#endif
    else if (InRange(uID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        // view callback range
        CallCB(SFVM_INVOKECOMMAND, uID - SFVIDM_CLIENT_FIRST, 0);
        return 0;
    }

    // First check for commands that always go to this defview
    switch (uID)
    {
    case SFVIDM_GROUPBY:
        _ToggleGrouping();
        break;

    case SFVIDM_EDIT_UNDO:
        // if we are in label edit mode, don't allowany of the buttons......
        if (_fInLabelEdit)
        {
            MessageBeep(0);
            return 0;
        }

        Undo(_hwndMain);
        break;

    case SFVIDM_VIEW_COLSETTINGS:
        {
            CColumnDlg ccd(this);

            AddColumns();

            ccd.ShowDialog(_hwndMain);
            break;
        }

    case SFVIDM_VIEW_VIEWMENU:
        {
            // if we are in label edit mode, don't allow any of the buttons......
            if (_fInLabelEdit)
            {
                MessageBeep(0);
                return 0;
            }

            LPCDFVCMDDATA pcd = (LPCDFVCMDDATA)lParam;
            if (pcd && pcd->pva && pcd->pva->byref)
            {
                LPRECT prect = (LPRECT)pcd->pva->byref;

                IContextMenu* pcm;
                if (SUCCEEDED(_Create_BackgrndHMENU(TRUE, IID_PPV_ARG(IContextMenu, &pcm))))
                {
                    POINT pt = { prect->left, prect->bottom};

                    DoContextMenuPopup(pcm, 0, pt);

                    pcm->Release();
                }
            }
        }
        break;

    case SFVIDM_VIEW_TILE:
        //
        // AppCompat:  Pre WinXP 0x702E used to be SFVIDM_VIEW_VIEWMENU, now it's SFVIDM_VIEW_TILE.
        // Corel apps send 0x702E to get the ViewMenu on the SaveAs dialogs.  Of course that no
        // longer works since 0x702E switches them to TileMode.  Luckily SFVIDM_VIEW_VIEWMENU has
        // a non-NULL lParam while SFVIDM_VIEW_TILE always has a NULL lParam so we can tell the
        // two apart.  So when Corel sends a 0x702E with a non-NULL lParam they mean SFVIDM_VIEW_VIEWMENU
        // and when they send a 0x702E with a NULL lParam they mean SFVIDM_VIEW_TILE.
        //
        COMPILETIME_ASSERT(SFVIDM_VIEW_TILE == 0x702E);  //see above app compat comments.
        if (lParam && (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW))
        {
            return _OnCommand(pcmToInvoke, SFVIDM_VIEW_VIEWMENU, lParam);  // change this into a SFVIDM_VIEW_VIEWMENU
        }
        // Fall through ...
    case SFVIDM_VIEW_ICON:
    case SFVIDM_VIEW_SMALLICON:
    case SFVIDM_VIEW_THUMBNAIL:
    case SFVIDM_VIEW_THUMBSTRIP:
    case SFVIDM_VIEW_LIST:
    case SFVIDM_VIEW_DETAILS:
        COMPILETIME_ASSERT(FVM_ICON == (SFVIDM_VIEW_ICON-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_SMALLICON == (SFVIDM_VIEW_SMALLICON-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_THUMBNAIL == (SFVIDM_VIEW_THUMBNAIL-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_THUMBSTRIP == (SFVIDM_VIEW_THUMBSTRIP-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_LIST == (SFVIDM_VIEW_LIST-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_TILE == (SFVIDM_VIEW_TILE-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_DETAILS == (SFVIDM_VIEW_DETAILS-SFVIDM_VIEW_FIRST));

        SetCurrentViewMode(uID - SFVIDM_VIEW_FIRST);
        break;

    case SFVIDM_DESKTOPHTML_WEBCONTENT:
        {
            // we have removed this button, but we need to keep this for message for other things
            BOOL bHasVisibleNonLocalPicture = FALSE;
            SHELLSTATE ss;

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
            ss.fDesktopHTML  = !ss.fDesktopHTML;           // Toggle the state
            if (ss.fDesktopHTML && !IsICWCompleted())
            {
                IActiveDesktop *pIAD;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktop, &pIAD))))
                {
                    bHasVisibleNonLocalPicture = (DisableUndisplayableComponents(pIAD) != 0);
                    pIAD->Release();
                }
            }
            if (!bHasVisibleNonLocalPicture)
            {
                SHELLSTATE ss2;

                SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new

                // Now read back the current setting - only call _SwitchDesktopHTML if the current
                // setting and the one we just set agree.  If they don't that means someone changed
                // the setting during the above call and we shouldn't do any more work or our state
                // will get messed up.
                SHGetSetSettings(&ss2, SSF_DESKTOPHTML, FALSE);
                if (ss.fDesktopHTML == ss2.fDesktopHTML)
                {
                    _SwitchDesktopHTML(BOOLIFY(ss.fDesktopHTML));
                }
            }
        }
        break;


    case SFVIDM_DESKTOPHTML_ICONS:
    case SFVIDM_ARRANGE_DISPLAYICONS:   // (buzzr) I'm leaving SFVIDM_ARRANGE_DISPLAYICONS
        {                               //         for backwards compat.  It used to be a
            SHELLSTATE ss;              //         menu entry on POPUP_SFV_BACKGROUND.
            DWORD dwValue;

            // Toggle the cached state
            _fs.fFlags ^= FWF_NOICONS;

            ss.fHideIcons = ((_fs.fFlags & FWF_NOICONS) != 0);
            dwValue = ss.fHideIcons ? 1 : 0;

            // Since this value is currrently stored under the "advanced" reg tree we need
            // to explicitly write to the registry or the value won't persist properly via
            // SHGetSetSettings.
            SHSetValue(HKEY_CURRENT_USER,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                    TEXT("HideIcons"), REG_DWORD, &dwValue, sizeof(dwValue));

            // Finally set the ShellState and perform the action!
            SHGetSetSettings(&ss, SSF_HIDEICONS, TRUE);
            // Since this SFVIDM_ comes from the menu, we better already be active (or
            // this SW_SHOW could make us visible before we want to be seen).
            ASSERT(_uState != SVUIA_DEACTIVATE);
            ActiveDesktop_ApplyChanges();
            ShowHideListView();
        }
        break;

    case SFVIDM_DESKTOPHTML_LOCK:
        {
            DWORD dwFlags = GetDesktopFlags();
            dwFlags ^= COMPONENTS_LOCKED;
            SetDesktopFlags(COMPONENTS_LOCKED, dwFlags);
            ActiveDesktop_ApplyChanges();
        }
        break;

    case SFVIDM_DESKTOPHTML_WIZARD:
        {
            // launch desktop cleanup wizard
            SHRunDLLThread(NULL, TEXT("fldrclnr.dll,Wizard_RunDLL all"), SW_SHOWNORMAL);
        }
        break;

    case SFVIDM_EDIT_COPYTO:
    case SFVIDM_EDIT_MOVETO:
        {
            // if we are in label edit mode, don't allowany of the buttons......
            if (_fInLabelEdit)
            {
                MessageBeep(0);
                return 0;
            }

            if (_pSelectionShellItemArray)
            {
                _DoMoveOrCopyTo(((uID == SFVIDM_EDIT_COPYTO) ? CLSID_CopyToMenu : CLSID_MoveToMenu), _pSelectionShellItemArray);
            }
        }
        break;

    case SFVIDM_FILE_PROPERTIES:

        if (SHRestricted(REST_NOVIEWCONTEXTMENU))
            break;

         // else fall through...

    case SFVIDM_EDIT_PASTE:
    case SFVIDM_EDIT_PASTELINK:
    case SFVIDM_EDIT_COPY:
    case SFVIDM_EDIT_CUT:
    case SFVIDM_FILE_LINK:
    case SFVIDM_FILE_DELETE:
        if (!_OnDefviewEditCommand(uID))
        {
            // REVIEW: this looks like a hack.
            // there's got to be a cleaner way of doing this...
            //
            LPDFVCMDDATA pcd = (LPDFVCMDDATA)lParam;
            // Try translating the SFVIDM value into a standard
            // OLECMDID value, so that the caller can try applying
            // it to a different object.
            if (!IsBadWritePtr(pcd, sizeof(*pcd)))
            {
                pcd->nCmdIDTranslated = OlecmdidFromSfvidm(uID);
            }
        }
        break;

    case SFVIDM_TOOL_OPTIONS:
        if (!SHRestricted(REST_NOFOLDEROPTIONS))
        {
            IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_OPTIONS, 0, NULL, NULL);
        }
        break;

#ifdef DEBUG
    case SFVIDM_DEBUG_WEBVIEW:
        _cFrame._ShowWebViewContent();
        break;
#endif // DEBUG

    case SFVIDM_HELP_TOPIC:
        // Don't call WinHelp when we are in the common dialog.
        if (!_IsCommonDialog())
        {
            // Use a callback to see if the namespace has requested a different help file name and/or topic
            SFVM_HELPTOPIC_DATA htd;
            HWND hwndDesktop = GetDesktopWindow();
            SHTCharToUnicode(c_szHtmlWindowsHlp, htd.wszHelpFile, ARRAYSIZE(htd.wszHelpFile));
            htd.wszHelpTopic[0] = 0;
            if (SUCCEEDED(CallCB(SFVM_GETHELPTOPIC, 0, (LPARAM)&htd)))
            {
                if (URL_SCHEME_MSHELP == GetUrlSchemeW(htd.wszHelpTopic))
                {
                    //
                    // Callback specified an HSS help URL.
                    //
                    SHELLEXECUTEINFOW sei = {0};
                    sei.cbSize = sizeof(sei);
                    sei.lpFile = htd.wszHelpTopic;
                    sei.hwnd   = hwndDesktop;
                    sei.nShow  = SW_NORMAL;
                    ShellExecuteExW(&sei);
                }
                else
                {
                    HtmlHelp(hwndDesktop, htd.wszHelpFile, HH_HELP_FINDER, htd.wszHelpTopic[0] ? (DWORD_PTR)htd.wszHelpTopic : 0);
                }
            }
            else
            {
                // ask the shell dispatch object to display Help for us
                IShellDispatch *psd;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_Shell, NULL, IID_PPV_ARG(IShellDispatch, &psd))))
                {
                    psd->Help();
                    psd->Release();
                }
            }
        }
        break;

    case SFVIDM_VIEW_CUSTOMWIZARD:
        _InvokeCustomization();
        break;

    case SFVIDM_MISC_HARDREFRESH:
        _fAllowSearchingWindow = TRUE;
        _FreeWebViewContentData();

        _ReloadContent(TRUE); // have to enumerate before _GetDefaultViewMode() will be accurate
        SetCurrentViewMode(_GetDefaultViewMode()); // even if fvm is the same, it will update webview if it changed
        Refresh();
        break;

    case SFVIDM_MISC_SETWEBVIEW:
        SetCurrentViewMode(_fs.ViewMode); // re-setting the fvm updates everything (turning web view off can switch from Thumbstrip to Thumbnail!)
        Refresh(); // we want to refresh when we switch turn webview on/off, since some icons appear/disappear on the transition
        break;

    case SFVIDM_MISC_REFRESH:
        _fAllowSearchingWindow = TRUE;
        Refresh();
        break;

    default:
        // check for commands that need to be sent to the active object
        switch (uID)
        {
        case SFVIDM_ARRANGE_AUTO:
            _fs.fFlags ^= FWF_AUTOARRANGE;      // toggle
            _ClearItemPositions();
            SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, _IsAutoArrange() ? LVS_AUTOARRANGE : 0);
            break;

        case SFVIDM_ARRANGE_GRID:
            ListView_Arrange(_hwndListview, LVA_SNAPTOGRID);
            break;

        case SFVIDM_ARRANGE_AUTOGRID:
            {
                _fs.fFlags ^= FWF_SNAPTOGRID;
                DWORD dwLVFlags = ListView_GetExtendedListViewStyle(_hwndListview);
                dwLVFlags ^= LVS_EX_SNAPTOGRID;
                ListView_SetExtendedListViewStyle(_hwndListview, dwLVFlags);

                //if this is desktop, we need to change the icon spacing.
                UpdateGridSizes(_IsDesktop(), _hwndListview, 0, NULL, BOOLIFY(dwLVFlags & LVS_EX_SNAPTOGRID));

                // if ActiveDesktop on, need to refresh, otherwise, can just arrange
                SHELLSTATE ss = {0};
                SHGetSetSettings( &ss, SSF_DESKTOPHTML, FALSE);
                if (ss.fDesktopHTML)
                {
                    Refresh();
                }
                else
                {
                    if ((dwLVFlags & LVS_EX_SNAPTOGRID))
                    {
                        ListView_Arrange(_hwndListview, LVA_SNAPTOGRID);
                    }
                }
            }
            break;

        default:
            // Normal view, we know what to do
            switch (uID)
            {
            case SFVIDM_SELECT_ALL:
            {
                DECLAREWAITCURSOR;

                if (CallCB(SFVM_SELECTALL, 0, 0) != S_FALSE)
                {
                    SetWaitCursor();
                    SetFocus(_hwndListview);
                    ListView_SetItemState(_hwndListview, -1, LVIS_SELECTED, LVIS_SELECTED);
                    // make the first item in the view the focused guy
                    ListView_SetItemState(_hwndListview, 0, LVIS_FOCUSED, LVIS_FOCUSED);
                    ResetWaitCursor();
                }
                break;
            }

            case SFVIDM_DESELECT_ALL:
                ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
                break;

            case SFVIDM_SELECT_INVERT:
            {
                DECLAREWAITCURSOR;
                SetWaitCursor();
                SetFocus(_hwndListview);
                int iItem = -1;
                while ((iItem = ListView_GetNextItem(_hwndListview, iItem, 0)) != -1)
                {
                    // flip the selection bit on each item
                    UINT flag = ListView_GetItemState(_hwndListview, iItem, LVIS_SELECTED);
                    flag ^= LVNI_SELECTED;
                    ListView_SetItemState(_hwndListview, iItem, flag, LVIS_SELECTED);
                }
                ResetWaitCursor();
                break;
            }

            case SFVIDM_FILE_RENAME:
                DoRename();
                break;

            default:
                return 1;
            }
        }
    }

    return 0;
}

LPITEMIDLIST CDefView::_ObjectExists(LPCITEMIDLIST pidl, BOOL fGlobal)
{
    LPITEMIDLIST pidlReal = NULL;
    //  365069 - global events also come through here - ZekeL - 16-APR-2001
    //  this means that that the pidl may not be one level.  if its deeper
    //  then for us this item doesnt exist.  this enforces our assert
    if (pidl && !ILIsEmpty(pidl) && (!fGlobal || ILIsEmpty(_ILNext(pidl))))
    {
        ASSERTMSG(ILFindLastID(pidl) == pidl, "defview doesnt expect recursive notification");
        SHGetRealIDL(_pshf, pidl, &pidlReal);
    }
    return pidlReal;
}

void CDefView::_OnRename(LPCITEMIDLIST* ppidl)
{
    if (_pidlMonitor)
    {
        if (!ILIsParent(_pidlMonitor, ppidl[0], TRUE))
        {
            // move to this folder
            _OnFSNotify(SHCNE_CREATE, &ppidl[1]);
        }
        else if (!ILIsParent(_pidlMonitor, ppidl[1], TRUE))
        {
            // move from this folder
            _OnFSNotify(SHCNE_DELETE, &ppidl[0]);
        }
        else
        {
            // rename within this folder
            // _pidlMonitor is guaranteed to be immediate parent of both pidls so ILFindLastID is okay.
            LPCITEMIDLIST pidlOld = ILFindLastID(ppidl[0]);
            LPITEMIDLIST pidlNew = _ObjectExists(ILFindLastID(ppidl[1]), FALSE);
            if (pidlNew)
            {
                _UpdateObject(pidlOld, pidlNew);
                ILFree(pidlNew);
            }
        }
    }
}

//
//  SFVM_UPDATESTATUSBAR return values:
//
//  failure code = Callback did not do anything, we must do it all
//
//  Otherwise, the GetScode(hr) is a bitmask describing what the app
//  wants us to do.
//
//  0 - App wants us to do nothing (S_OK) - message handled completely
//  1 - App wants us to set the default text (but not initialize)
//
//  <other bits reserved for future use>

void CDefView::_UpdateStatusBar(BOOL fInitialize)
{
    HRESULT hr;

    // We have to clear the contents here since some clients (like the ftp client) return S_OK from
    // the callback but do not set the text of the bar
    HWND hwndStatus;
    if (_psb && SUCCEEDED(_psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
    {
        _fBackgroundStatusTextValid = FALSE;
        SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)_TEXT(""));
    }

    if (_bBkFilling || FAILED(hr = CallCB(SFVM_UPDATESTATUSBAR, fInitialize, 0)))
    {
        // Client wants us to do everything
        _DoStatusBar(fInitialize);
    }
    else if (hr & SFVUSB_INITED)
    {
        // Client wants us to do text but not initialize
        _DoStatusBar(FALSE);
    }
}


// Returns TRUE iff we are supposed to show Web View content on this view.
// For the most part it follows SSF_WEBVIEW for normal folders and SSF_DESKTOPHTML for the desktop
//
BOOL CDefView::_ShouldShowWebView()
{
    // No webview for common dialogs
    if (_IsCommonDialog())
    {
        return FALSE;
    }

    // No webview in cleanboot mode
    if (GetSystemMetrics(SM_CLEANBOOT))
        return FALSE;

    BOOL bForceWebViewOn;
    if (SUCCEEDED(CallCB(SFVM_FORCEWEBVIEW, (WPARAM)&bForceWebViewOn, 0)))
    {
        return bForceWebViewOn;
    }

    // Quattro Pro (QPW) doesn't know how SHChangeNotify works,
    // so when they want to refresh My Computer, they create an IShellView,
    // invoke its CreateViewWindow(), invoke its Refresh(), then DestroyWindow
    // the window and release the view.  The IShellBrowser they pass
    // to CreateViewWindow is allocated on the stack (!), and they expect
    // that their Release() be the last one.  Creating an async view keeps
    // the object alive, so when the view is complete, we try to talk to the
    // IShellBrowser and fault because it's already gone.
    //
    // The Zip Archives (from Aeco Systems) is another messed up App.
    // They neither implement IPersistFolder2 (so we can't get their pidl) nor
    // set the pidl to the shellfolderviewcb object. They don't implement
    // IShellFolder2 either. Webview is practically useless for them.
    //
    // Adaptec Easy CD Creator 3.5 is in the same boat.
    //
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DESKTOPHTML | SSF_WEBVIEW, FALSE);

    // If the "no web view" flag is set (potential WebOC case) then return false;
    if (_fs.fFlags & FWF_NOWEBVIEW)
        return FALSE;

    if (_IsDesktop())
    {
        return ss.fDesktopHTML;
    }
    else
    {
        return ss.fWebView &&
               !(SHGetAppCompatFlags(ACF_OLDCREATEVIEWWND) & ACF_OLDCREATEVIEWWND) &&
               !(SHGetObjectCompatFlags(_pshf, NULL) & OBJCOMPATF_NO_WEBVIEW);
    }
}

// takes ownership of pidlNew since _AddObject takes ownership.
void CDefView::_AddOrUpdateItem(LPCITEMIDLIST pidlOld, LPITEMIDLIST pidlNew)
{
    if (_FindItem(pidlOld, NULL, FALSE) != -1)
    {
        _UpdateObject(pidlOld, pidlNew);
        ILFree(pidlNew);
    }
    else
    {
        // check if the shellfolder says this new guy shouldn't be enumerated.
        if (!_Attributes(pidlNew, SFGAO_NONENUMERATED))
        {
            _AddObject(pidlNew);  // takes pidl ownership.
        }
        else
        {
            ILFree(pidlNew);
        }
    }
}

#define FSNDEBUG

// WM_DSV_FSNOTIFY message

LRESULT CDefView::_OnFSNotify(LONG lNotification, LPCITEMIDLIST* ppidl)
{
    LPITEMIDLIST pidl;
    LPCITEMIDLIST pidlItem;

    //
    //  Note that renames between directories are changed to
    //  create/delete pairs by SHChangeNotify.
    //
#ifdef DEBUG
#ifdef FSNDEBUG
    TCHAR szPath[MAX_PATH];
    TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify, hwnd = %d  lEvent = %d", _hwndView, lNotification);

    switch (lNotification)
    {
    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        // two pidls
        SHGetPathFromIDList(ppidl[0], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        SHGetPathFromIDList(ppidl[1], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        break;

    case SHCNE_CREATE:
    case SHCNE_DELETE:
    case SHCNE_MKDIR:
    case SHCNE_RMDIR:
    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_DRIVEREMOVED:
    case SHCNE_DRIVEADD:
    case SHCNE_NETSHARE:
    case SHCNE_NETUNSHARE:
    case SHCNE_ATTRIBUTES:
    case SHCNE_UPDATEDIR:
    case SHCNE_UPDATEITEM:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_DRIVEADDGUI:
    case SHCNE_EXTENDED_EVENT:
        // one pidl
        SHGetPathFromIDList(ppidl[0], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        break;

    case SHCNE_UPDATEIMAGE:
        // DWORD wrapped inside a pidl
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %08x", _hwndView,
            ((LPSHChangeDWORDAsIDList)ppidl[0])->dwItem1);
        break;

    case SHCNE_ASSOCCHANGED:
        // No parameters
        break;
    }
#endif
#endif

    // we may be registered for notifications on pidls that are different from
    // the one returned by _GetViewPidl (ftp folder).
    switch (lNotification)
    {
    case SHCNE_DRIVEADD:
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        pidlItem = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
        pidl = _ObjectExists(pidlItem, FALSE);
        if (pidl)
        {
            _AddOrUpdateItem(pidlItem, pidl);
        }
        break;

    case SHCNE_DRIVEREMOVED:
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        pidlItem = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
        if (pidlItem)
        {
            ASSERTMSG(ILFindLastID(pidlItem) == pidlItem, "defview doesnt expect recursive notification");
            _RemoveObject((LPITEMIDLIST)pidlItem, FALSE);
        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        _OnRename(ppidl);
        break;

    case SHCNE_UPDATEIMAGE:
        // the system image cache is changing
        // ppidl[0] is a IDLIST of image indexs that have changed

        if (ppidl && ppidl[1])
        {
            // this event is generated instead of a normal UPDATEIMAGE so that we can handle the
            // cross process case....
            // handle the notification
            int iImage = SHHandleUpdateImage(ppidl[1]);
            if (iImage != -1)
            {
                _UpdateImage(iImage);
            }
        }
        else if (ppidl && ppidl[0])
        {
            int iImage = *(int UNALIGNED *)((BYTE *)ppidl[0] + 2);
            _UpdateImage(iImage);
        }
        break;

    case SHCNE_ASSOCCHANGED:
        // For this one we will call refresh as we may need to reextract
        // the icons and the like.  Later we can optimize this somewhat if
        // we can detect which ones changed and only update those.
        _ReloadContent();
        break;

    case SHCNE_ATTRIBUTES:      // these all mean the same thing
    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_NETUNSHARE:
    case SHCNE_NETSHARE:
    case SHCNE_UPDATEITEM:
        if (ppidl)
        {
            LPCITEMIDLIST pidlOld = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
            LPITEMIDLIST pidlNew = _ObjectExists(pidlOld, SHCNE_GLOBALEVENTS & lNotification);
            if (pidlNew)
            {
                _AddOrUpdateItem(pidlOld, pidlNew);
            }
            else
            {
                // If we do not have any subobjects and the passed in pidl is the same as
                // this views pidl then refresh all the items.
                LPITEMIDLIST pidlView = _GetViewPidl();
                if (pidlView)
                {
                    if (ILIsEqual(ppidl[0], pidlView))
                    {
                        _FullViewUpdate(SHCNE_UPDATEITEM == lNotification);
                    }
                    ILFree(pidlView); 
                }
            }
        }
        else    // ppidl == NULL means update all items (re-enum them)
        {
            _FullViewUpdate(SHCNE_UPDATEITEM == lNotification);
        }
        break;


    case SHCNE_FREESPACE:
        TCHAR szPath[MAX_PATH];
        if (_GetPath(szPath))
        {
            int idDrive = PathGetDriveNumber(szPath);
            if (idDrive != -1)
            {
                DWORD dwChangedDrives = *(DWORD UNALIGNED *)((BYTE *)ppidl[0] + 2);
                if (((1 << idDrive) & dwChangedDrives))
                {
                    _UpdateStatusBar(TRUE);
                }
            }
        }
        break;

    default:
        TraceMsg(TF_DEFVIEW, "DefView: unknown FSNotify %08lX, doing full update", lNotification);
        _FullViewUpdate(FALSE);
        break;
    }

    _UpdateStatusBar(FALSE);
    return 0;
}

// called when some of our objects get put on the clipboard
LRESULT CDefView::_OnSetClipboard(BOOL bMove)
{
    if (bMove)  // move
    {
        //  mark all selected items as being "cut"
        int i = -1;
        while ((i = ListView_GetNextItem(_hwndListview, i, LVIS_SELECTED)) != -1)
        {
            ListView_SetItemState(_hwndListview, i, LVIS_CUT, LVIS_CUT);
            _bHaveCutStuff = TRUE;
        }

        // join the clipboard viewer chain so we will know when to
        // "uncut" our selected items.
        if (_bHaveCutStuff)
        {
            ASSERT(!_bClipViewer);
            ASSERT(_hwndNextViewer == NULL);

            _hwndNextViewer = SetClipboardViewer(_hwndView);
            _bClipViewer = TRUE;
        }
    }
    return 0;
}

// called when the clipboard get changed, clear any items in the "cut" state
//
LRESULT CDefView::_OnClipboardChange()
{
    //
    //  if we dont have any cut stuff we dont care.
    //
    if (!_bHaveCutStuff)
        return 0;

    ASSERT(_bClipViewer);

    _RestoreAllGhostedFileView();
    _bHaveCutStuff = FALSE;

    //
    // unhook from the clipboard viewer chain.
    //
    ChangeClipboardChain(_hwndView, _hwndNextViewer);
    _bClipViewer = FALSE;
    _hwndNextViewer = NULL;

    return 0;
}

//
// Note: this function returns the point in Listview Coordinate
// space.  So any hit testing done with this needs to be converted
// back to Client coordinate space...
BOOL CDefView::_GetDropPoint(POINT *ppt)
{
    // Check whether we already have gotten the drop anchor (before any
    // menu processing)
    if (_bDropAnchor)
    {
        // We'll use the insert mark rect (if available) to determine a drop point
        if (!_GetInsertPoint(ppt))
        {
            *ppt = _ptDrop; // Otherwise use _ptDrop
            LVUtil_ClientToLV(_hwndListview, ppt);
        }
    }
    else if (_bMouseMenu)
    {
        *ppt = _ptDragAnchor;
        return TRUE;
    }
    else
    {
        // We need the most up-to-date cursor information, since this
        // may be called during a drop, and the last time the current
        // thread called GetMessage was about 10 minutes ago
        GetCursorPos(ppt);
        LVUtil_ScreenToLV(_hwndListview, ppt);
    }

    return _bDropAnchor;
}


// This uses the listview's insertmark to determinie an insert point
// Returns FALSE if a point could not be determined, TRUE otherwise
// The coordinates returned are in listview coordinate space.
BOOL CDefView::_GetInsertPoint(POINT *ppt)
{
    if (_IsAutoArrange() || (_fs.fFlags & FWF_SNAPTOGRID))
    {
        RECT rcInsert;
        if (ListView_GetInsertMarkRect(_hwndListview, &rcInsert))
        {
            LONG dwStyle = GetWindowLong(_hwndListview, GWL_STYLE);
            BOOL fHorizontal = (_fs.fFlags & FWF_ALIGNLEFT);
            if (fHorizontal)
            {
                ppt->x = (rcInsert.right + rcInsert.left) / 2; // Drop in middle of insertmark rect
                ppt->y = rcInsert.top;
            }
            else
            {
                ppt->x = rcInsert.left;
                ppt->y = (rcInsert.bottom + rcInsert.top) / 2; // Drop in middle of insertmark rect
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL CDefView::_GetDragPoint(POINT *ppt)
{
    BOOL fSource = _bDragSource || _bMouseMenu;
    if (fSource)
    {
        // if anchor from mouse activity
        *ppt = _ptDragAnchor;
    }
    else
    {
        // if anchor from keyboard activity...  use the focused item
        int i = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
        if (i != -1)
        {
            ListView_GetItemPosition(_hwndListview, i, ppt);
        }
        else
        {
            ppt->x = ppt->y = 0;
        }
    }
    return fSource;
}

void CDefView::_PaintErrMsg(HWND hWnd)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    // if we're in an error state, make sure we're not in webview
    if (_cFrame.IsWebView())
    {
        _SwitchToWebView(FALSE);
    }

    RECT rc;
    GetClientRect(hWnd, &rc);

    DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_SOFT | BF_ADJUST | BF_MIDDLE);

    EndPaint(hWnd, &ps);
}

//
//  The default status bar looks like this:
//
//  No items selected:  "nn object(s)"              nn = total objects in folder
//  One item selected:  <InfoTip for selected item> if item supports InfoTip
//  Else:               "nn object(s) selected"     nn = num selected objects
//
//
void CDefView::_DoStatusBar(BOOL fInitialize)
{
    HWND hwndStatus;
    if (_psb && SUCCEEDED(_psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
    {
        // Some of the failure cases do not null hwnd...
        UINT uMsg = IDS_FSSTATUSSELECTED;

        if (fInitialize)
        {
            int ciParts[] = {-1};
            SendMessage(hwndStatus, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts);
        }

        if (_bBkFilling && ListView_GetSelectedCount(_hwndListview) == 0)
        {
            _fBackgroundStatusTextValid = FALSE;
            LPWSTR pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FSSTATUSSEARCHING));
            // We are not checking if the alloc succeeded in ShellConstructMessageString since both
            // SendMessage and LocalFree can take NULL as inputs.
            SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)pszStatus);
            LocalFree((void *)pszStatus);
        }
        else
        {

            LPCITEMIDLIST *apidl = NULL;

            int nMsgParam = ListView_GetSelectedCount(_hwndListview);
            switch (nMsgParam)
            {
            case 0:
                // No objects selected; show total item count
                nMsgParam = ListView_GetItemCount(_hwndListview);
                uMsg = IDS_FSSTATUSBASE;
                break;

            case 1:
                UINT cItems;
                GetSelectedObjects(&apidl, &cItems);
                break;
            }

            LPITEMIDLIST pidlFolder = _GetViewPidl();
            if (pidlFolder)
            {
                CStatusBarAndInfoTipTask *pTask;
                if (SUCCEEDED(CStatusBarAndInfoTipTask_CreateInstance(pidlFolder, apidl ? *apidl : NULL, uMsg, nMsgParam, NULL, _hwndView, _pScheduler, &pTask)))
                {
                    if (_pScheduler)
                    {
                        // make sure there are no other status bar background tasks going on...
                        _pScheduler->RemoveTasks(TOID_DVBackgroundStatusBar, ITSAT_DEFAULT_LPARAM, FALSE);
                    }

                    _fBackgroundStatusTextValid = TRUE;
                    _AddTask(pTask, TOID_DVBackgroundStatusBar, 0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                    pTask->Release();
                }

                ILFree(pidlFolder);
            }

            if (apidl)
                LocalFree(apidl);
        }
    }
}

void CDefView::_OnWinIniChangeDesktop(WPARAM wParam, LPCTSTR pszSection)
{
    if (pszSection)
    {
        if (!lstrcmpi(pszSection, TEXT("ToggleDesktop")))
        {
            _OnCommand(NULL, SFVIDM_DESKTOPHTML_WEBCONTENT, 0);
        }
        else if (!lstrcmpi(pszSection, TEXT("RefreshDesktop")))
        {
            if (FAILED(Refresh()))
            {
                SHELLSTATE ss;

                //Refresh failed because the new template didn't exist
                //Toggle the Registry settings back to Icons-only mode!
                ss.fDesktopHTML = FALSE;
                SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new
            }
        }
        else if (!lstrcmpi(pszSection, TEXT("BufferedRefresh")))
        {
            //See if we have already started a timer to refresh
            if (!_fRefreshBuffered)
            {
                TraceMsg(TF_DEFVIEW, "A Buffered refresh starts the timer");
                SetTimer(_hwndView, DV_IDTIMER_BUFFERED_REFRESH, 5000, NULL);   // 5 sec
                _fRefreshBuffered = TRUE;
            }
            else //If refresh is already buffered, don't do anything!
            {
                TraceMsg(TF_DEFVIEW, "A buffered refresh occured while another is pending");
            }
        }
        else
        {
            if (wParam == SPI_SETDESKWALLPAPER || wParam == SPI_SETDESKPATTERN)
            {
                _SetFolderColors();
            }
        }
    }
    else
    {
        switch(wParam)
        {
            case SPI_SETDESKWALLPAPER:
            case SPI_SETDESKPATTERN:

                _SetFolderColors();
                break;

            case SPI_ICONHORIZONTALSPACING:
            case SPI_ICONVERTICALSPACING:

                if (_IsDesktop())
                {
                    DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(_hwndListview);
                    UpdateGridSizes(TRUE, _hwndListview, 0, NULL, BOOLIFY(dwLVExStyle & LVS_EX_SNAPTOGRID));
                }
                break;
        }
    }
}

void CDefView::_OnWinIniChange(WPARAM wParam, LPCTSTR pszSection)
{
    if ((wParam == SPI_GETICONTITLELOGFONT) ||
        ((wParam == 0) && pszSection && !lstrcmpi(pszSection, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\IconUnderline"))))
    {
        _UpdateUnderlines();
    }

    if (pszSection && !lstrcmpi(pszSection, TEXT("VisualEffects")))
    {
        Refresh();
    }

    // Why all this code? It's a rare event -- just kick off a refresh...
    if (!wParam || (pszSection && !lstrcmpi(pszSection, TEXT("intl"))))
    {
        // has the time format changed while we're in details mode?
        if (ViewRequiresColumns(_fs.ViewMode) && !_IsOwnerData())
        {
            InvalidateRect(_hwndListview, NULL, TRUE);

            // 99/04/13 #320903 vtan: If the date format has changed then iterate
            // the entire list looking for extended columns of type date and
            // resetting them to LPSTR_TEXTCALLBACK effectively dumping the cache.

            // For performance improvement it's possible to collect an array of
            // visible columns and reset that array. It will still involve TWO
            // for loops.

            int iItemCount = ListView_GetItemCount(_hwndListview);
            for (int iItem = 0; iItem < iItemCount; ++iItem)
            {
                for (UINT uiRealColumn = 0; uiRealColumn < _vs.GetColumnCount(); ++uiRealColumn)
                {
                    DWORD dwFlags = _vs.GetColumnState(uiRealColumn);
                    if (((dwFlags & SHCOLSTATE_EXTENDED) != 0) &&
                        ((dwFlags & SHCOLSTATE_TYPEMASK) == SHCOLSTATE_TYPE_DATE))
                    {
                        UINT uiVisibleColumn = _RealToVisibleCol(uiRealColumn);

                        ListView_SetItemText(_hwndListview, iItem, uiVisibleColumn, LPSTR_TEXTCALLBACK);
                    }
                }
            }
        }
    }

    //
    // we may need to rebuild the icon cache.
    //
    if (wParam == SPI_SETICONMETRICS ||
        wParam == SPI_SETNONCLIENTMETRICS)
    {
        if (_IsImageMode())
        {
            _SetThumbview();
        }
        else if (_IsTileMode())
        {
            _SetTileview();
        }
        else
        {
            _SetSysImageList();
        }
    }

    //
    // we need to invalidate the cursor cache
    //
    if (wParam == SPI_SETCURSORS)
    {
        DAD_InvalidateCursors();
    }

    if ((wParam == SPI_SETMENUANIMATION) && _pDUIView)
    {
        _pDUIView->ManageAnimations(FALSE);
    }

    if (!wParam && !pszSection && _pDUIView)
    {
        if (_fBarrierDisplayed != _QueryBarricadeState())
        {
            _fBarrierDisplayed = !_fBarrierDisplayed;
            _pDUIView->EnableBarrier (_fBarrierDisplayed);
        }
    }

    if (_IsDesktop())
    {
        _OnWinIniChangeDesktop(wParam, pszSection);
    }
}

void CDefView::_SetDefaultViewSettings()
{
    // only do this if we've actually shown the view...
    // (ie, there's no _hwndStatic)
    // and we're not the desktop
    // and we're not an exstended view
    // and we are not in an explorer (tree pane on)
    if (!_hwndStatic && !_IsDesktop() && !IsExplorerBrowser(_psb))
    {
        SHELLSTATE ss;

        ss.lParamSort = (LONG)_vs._lParamSort;
        ss.iSortDirection = _vs._iDirection;
        SHGetSetSettings(&ss, SSF_SORTCOLUMNS, TRUE);
    }
}

HWND CDefView::GetChildViewWindow()
{
    if (_cFrame.IsWebView())
        return _cFrame.GetExtendedViewWindow();

    return _hwndListview;
}

void CDefView::_SetFocus()
{
    // if it's a combined view then we need to give focus to listview
    if (!_fCombinedView && _cFrame.IsWebView() && !_fActivateLV)
    {
        _OnViewWindowActive();

        if (_cFrame._pOleObj)
        {
            MSG msg = {_hwndView, WM_KEYDOWN, VK_TAB, 0xf0001};

            // HACKHACK!!! MUST set state here! idealy shbrowse should call
            // UIActivate on the view but that breaks dochost stuff.
            // if we did not set the state here, trident would call
            // CSFVSite::ActivateMe that would not forward the call to obj::UIActivate
            // and therefore nothing would get focus (actually trident would have it
            // but it would not be visible). Note that this behavior happens only
            // second time around, i.e. on init UIActivate is called and everything
            // works fine, but if we tab from address bar onto the view, that's when
            // the stuff gets broken.
            OnActivate(SVUIA_ACTIVATE_FOCUS);
            _cFrame._UIActivateIO(TRUE, &msg);
        }
    }
    else
    {
        CallCB(SFVM_SETFOCUS, 0, 0);
        if (_hwndListview)
            SetFocus(_hwndListview);
        if (!_IsDesktop())
        {
            _cFrame._uState = SVUIA_ACTIVATE_FOCUS;
        }
    }
}

LRESULT CALLBACK CDefView::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    CDefView * pThis;
    ULONG_PTR cookie = 0;

    if (WM_NCCREATE == uMsg)
    {
        pThis = (CDefView*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if (pThis)
        {
            pThis->AddRef();
            SetWindowLongPtr(hWnd, 0, (LONG_PTR)pThis);
        }
    }
    else
    {
        pThis = (CDefView*)GetWindowLongPtr(hWnd, 0);
    }

    // FUSION: When defview calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    ActivateActCtx(NULL, &cookie);

    if (pThis)
        lres = pThis->WndProc(hWnd, uMsg, wParam, lParam);
    else
        lres = DefWindowProc(hWnd, uMsg, wParam, lParam);

    if (cookie != 0)
        DeactivateActCtx(0, cookie);

    return lres;
}

BOOL CDefView::_OnAppCommand(UINT cmd, UINT uDevice, DWORD dwKeys)
{
    BOOL bHandled = FALSE;
    switch (cmd)
    {
    case APPCOMMAND_MEDIA_PLAY_PAUSE:
        if (S_OK == _InvokeContextMenuVerbOnSelection("play", 0, 0))
            bHandled = TRUE;
        break;

    }
    return bHandled;
}

HRESULT CDefView::_ForwardMenuMessages(DWORD dwID, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL* pfHandled)
{
    if (InRange(dwID, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
    {
        if (pfHandled)
            *pfHandled = TRUE;

        return SHForwardContextMenuMsg(_pcmContextMenuPopup, uMsg, wParam, lParam, plResult, TRUE);
    }
    else if (InRange(dwID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
    {
        if (pfHandled)
            *pfHandled = TRUE;

        return SHForwardContextMenuMsg(_pcmFile, uMsg, wParam, lParam, plResult, TRUE);
    }

    if (pfHandled)
        *pfHandled = FALSE;

    return E_FAIL;
}

LRESULT CDefView::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT l;
    DWORD dwID;

    switch (uMsg)
    {
    // IShellBrowser forwards these to the IShellView.
    // Dochost also forwards them down to the IOleObject, so we should do it too...
    case WM_SYSCOLORCHANGE:
        {
            HDITEM hdi = {HDI_FORMAT, 0, NULL, NULL, 0, 0, 0, 0, 0};
            HWND hwndHead = ListView_GetHeader(_hwndListview);

            // We only want to update the sort arrows if they are already present.
            if (hwndHead)
            {
                Header_GetItem(hwndHead, _vs._lParamSort, &hdi);
                if (hdi.fmt & HDF_BITMAP)
                    _SetSortFeedback();
            }

            // fall through
        }

    case WM_WININICHANGE:
        _sizeThumbnail.cx = -1;

        // fall through

    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    case WM_FONTCHANGE:
        if (_cFrame.IsWebView())
        {
            HWND hwndExt = _cFrame.GetExtendedViewWindow();
            if (hwndExt)
            {
                SendMessage(hwndExt, uMsg, wParam, lParam);
            }
        }
        break;
    }

    switch (uMsg)
    {
        case WM_DESTROY:
        if (GetKeyState(VK_CONTROL) < 0)
            _SetDefaultViewSettings();

        // Dont need our web view data any more
        _FreeWebViewContentData();

        // We don't flush these on WM_EXITMENULOOP any more, so do it here
        IUnknown_SetSite(_pcmFile, NULL);
        ATOMICRELEASE(_pcmFile);

        EmptyBkgrndThread(_pScheduler);
        ATOMICRELEASE(_pScheduler);

        // do this after our task scheduler is gone, since one of it's
        // items may be on the background task scheduler (or DUI may be
        // talking to it on the background) and it may need it's site chain.
        IUnknown_SetSite(_cCallback.GetSFVCB(), NULL);

        if (_pDiskCache)
        {
            // at this point we assume that we have no lock,
            _pDiskCache->Close(NULL);
            ATOMICRELEASE(_pDiskCache);
        }

        // Depending on when it is closed we may have an outstanding post
        // to us about the rest of the fill data which we should try to
        // process in order to keep from leaking stuff...

        // logically hWnd == _hwndView, but we already zeroed
        // _hwndView so use hWnd

        _ClearPostedMsgs(hWnd);

        //
        //  remove ourself as a clipboard viewer
        //
        if (_bClipViewer)
        {
            ChangeClipboardChain(hWnd, _hwndNextViewer);
            _bClipViewer = FALSE;
            _hwndNextViewer = NULL;
        }

        if (_uRegister)
        {
            ULONG uRegister = _uRegister;
            _uRegister = 0;
            SHChangeNotifyDeregister(uRegister);
        }

        ATOMICRELEASE(_psd);
        ATOMICRELEASE(_pdtgtBack);

        if (_hwndListview)
        {
            if (_IsDesktop()) // only the desktop can have a combined view (e.g. Active Desktop)
            {
                EnableCombinedView(this, FALSE);
            }

            if (_bRegisteredDragDrop)
                RevokeDragDrop(_hwndListview);
        }

        SetAutomationObject(NULL);    // cleanup refs we may be holding

        if (IsWindow(_hwndInfotip))
        {
            DestroyWindow(_hwndInfotip);
            _hwndInfotip = NULL;
        }

        break;

    case WM_CREATE:
        return _OnCreate(hWnd);

    case WM_DSV_DELAYED_DESTROYWND:
        DestroyWindow(hWnd);
        break;

    case WM_NCDESTROY:
        _hwndView = NULL;

        SetWindowLongPtr(hWnd, 0, 0);

        // get rid of extra junk in the icon cache
        IconCacheFlush(FALSE);

        if (_pDUIView)
        {
            //
            // We must uninitialize DUser prior to releasing
            // _pDUIView so that all DUser gadgets are properly destroyed.
            // We used to call DirectUI::UnInitThread() in the CDUIView dtor.  
            // However, since both CDefView and the various 'task' DUI 
            // elements maintain a ref to CDUIView, we got into scenarios where 
            // one of the 'task' elements held the final ref to CDUIView.  That 
            // resulted in the destruction of that 'task' element causing 
            // uninitialization of DUser in the middle of a DUser call stack.  
            // That's bad.
            // Uninitializing DUser here causes DUser to handle all pending
            // messages and destroy all it's gadgets on it's own terms.
            //
            _pDUIView->UnInitializeDirectUI();
            _pDUIView->Release();
            _pDUIView = NULL;
        }

        // release our reference generated during WM_NCCREATE in static wndproc
        Release();

        break;

    case WM_ENABLE:
        _fDisabled = !wParam;
        break;

    case WM_ERASEBKGND:
        {
            COLORREF cr = ListView_GetBkColor(_hwndListview);
            if (cr == CLR_NONE)
                return SendMessage(_hwndMain, uMsg, wParam, lParam);

            //Turning On EraseBkgnd. This is required so as to avoid the
            //painting issue - when the listview is not visible and
            //invalidation occurs.

            HBRUSH hbr = CreateSolidBrush(cr);
            RECT rc;
            GetClientRect(hWnd, &rc);
            FillRect((HDC)wParam, &rc, hbr);
            DeleteObject(hbr);
        }
        // We want to reduce flash
        return 1;

    case WM_PAINT:
        if (_fEnumFailed)
            _PaintErrMsg(hWnd);
        else
            goto DoDefWndProc;
        break;

    case WM_LBUTTONUP:
        if (_fEnumFailed)
            PostMessage(hWnd, WM_KEYDOWN, (WPARAM)VK_F5, 0);
        else
            goto DoDefWndProc;
        break;

    case WM_SETFOCUS:
        if (!_fDestroying)    // Ignore if we are destroying _hwndView.
        {
            _SetFocus();
        }
        break;

    case WM_MOUSEACTIVATE:
        //
        // this keeps our window from coming to the front on button down
        // instead, we activate the window on the up click
        //
        if (LOWORD(lParam) != HTCLIENT)
            goto DoDefWndProc;
        LV_HITTESTINFO lvhti;

        GetCursorPos(&lvhti.pt);
        ScreenToClient(_hwndListview, &lvhti.pt);
        ListView_HitTest(_hwndListview, &lvhti);
        if (lvhti.iItem != -1 && lvhti.flags & LVHT_ONITEM)
            return MA_NOACTIVATE;
        else
            return MA_ACTIVATE;

    case WM_ACTIVATE:
        // force update on inactive to not ruin save bits
        if (wParam == WA_INACTIVE)
            UpdateWindow(_hwndListview);
        // if active view created, call active object to allow it to visualize activation.
        if (_cFrame._pActive)
            _cFrame._pActive->OnFrameWindowActivate((BOOL)wParam);
        break;

    case WM_SIZE:
        return WndSize(hWnd);

    case WM_NOTIFY:
    {
#ifdef DEBUG
        // DefView_OnNotify sometimes destroys the pnm, so we need to save
        // the code while we can.  (E.g., common dialog single-click activate.
        // LVN_ITEMACTIVATE causes us to dismiss the common dialog, which
        // does a DestroyViewWindow, which destroys the ListView
        // which destroys the NMHDR!)
        UINT code = ((NMHDR *)lParam)->code;
#endif
        AddRef();             // just in case
        l = _OnNotify((NMHDR *)lParam);
        Release();            // release
        return l;
    }

    case WM_CONTEXTMENU:
        if (!_fDisabled)
        {
            if (lParam != (LPARAM) -1)
            {
                _bMouseMenu = TRUE;
                _ptDragAnchor.x = GET_X_LPARAM(lParam);
                _ptDragAnchor.y = GET_Y_LPARAM(lParam);
                LVUtil_ScreenToLV(_hwndListview, &_ptDragAnchor);
            }
            // Note: in deview inside a defview we can have problems of the
            // parent destroying us when we change views, so we better addref/release
            // around this...
            AddRef();
            _bContextMenuMode = TRUE;

            ContextMenu((DWORD) lParam);

            _bContextMenuMode = FALSE;
            _bMouseMenu = FALSE;
            Release();
        }
        break;

    case WM_COMMAND:
        return _OnCommand(NULL, wParam, lParam);

    case WM_APPCOMMAND:
        if (!_OnAppCommand(GET_APPCOMMAND_LPARAM(lParam), GET_DEVICE_LPARAM(lParam), GET_KEYSTATE_LPARAM(lParam)))
            goto DoDefWndProc;
        break;

    case WM_DSV_DISABLEACTIVEDESKTOP:
        DisableActiveDesktop();
        break;

    case WM_DSV_DELAYWINDOWCREATE:
        CallCB(SFVM_DELAYWINDOWCREATE, (WPARAM)_hwndView, 0);
        break;

    case WM_DSV_BACKGROUNDENUMDONE:
        // Make sure this notify is from our enumeration task (it could be from a previous one)
        if ((CDefviewEnumTask *)lParam == _pEnumTask)
            _OnBackgroundEnumDone();
        break;

    case WM_DSV_GROUPINGDONE:
        _OnCategoryTaskDone();
        break;

    case WM_DSV_FILELISTENUMDONE:
        _OnEnumDoneMessage();
        break;

    case WM_DSV_FILELISTFILLDONE:
        _ShowSearchUI(FALSE);
        break;

    case WM_DSV_UPDATETHUMBNAIL:
        {
            DSV_UPDATETHUMBNAIL* putn = (DSV_UPDATETHUMBNAIL*)lParam;
            if (_IsImageMode())  // some messages may come in after the view mode is changed.
            {
                _UpdateThumbnail(putn->iItem, putn->iImage, putn->pidl);
            }
            _CleanupUpdateThumbnail(putn);
        }
        break;
    case WM_DSV_POSTCREATEINFOTIP:
        _OnPostCreateInfotip((TOOLINFO *)wParam, lParam);
        break;

    case WM_DSV_FSNOTIFY:
        {
            LPITEMIDLIST *ppidl;
            LONG lEvent;

            LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
            if (pshcnl)
            {
                if (_fDisabled ||
                    (CallCB(SFVM_FSNOTIFY, (WPARAM)ppidl, (LPARAM)lEvent) == S_FALSE))
                {
                    lParam = 0;
                }
                else
                {
                    lParam = _OnFSNotify(lEvent, (LPCITEMIDLIST*)ppidl);
                }
                SHChangeNotification_Unlock(pshcnl);
            }
        }
        return lParam;

    //  the background thread's callback will post this message to us
    //  when it has finished extracting a icon in the background.
    //
    //      wParam is PIDL
    //      lParam is iIconIndex

    case WM_DSV_UPDATEICON:
        _UpdateIcon((LPITEMIDLIST)wParam, (UINT)lParam);
        break;

    case WM_DSV_SETITEMGROUP:
        _UpdateGroup((CBackgroundGroupInfo*)lParam);
        break;

    case WM_DSV_UPDATECOLDATA:
        _UpdateColData((CBackgroundColInfo*)lParam);
        break;

    case WM_DSV_UPDATEOVERLAY:
        _UpdateOverlay((int)wParam, (int)lParam);
        break;

    case WM_DSV_SETIMPORTANTCOLUMNS:
        _SetImportantColumns((CBackgroundTileInfo*)lParam);
        break;

    case WM_DSV_SHOWDRAGIMAGE:
        return DAD_ShowDragImage((BOOL)lParam);

    case WM_DSV_DELAYSTATUSBARUPDATE:
        {
            HWND hwndStatus;
            LPWSTR pszStatus = (LPWSTR)lParam;
            if (_fBackgroundStatusTextValid)
            {
                _fBackgroundStatusTextValid = FALSE;
                // Now prepare the text and post it to the status bar window.
                _psb->GetControlWindow(FCW_STATUS, &hwndStatus);
                if (hwndStatus)
                {
                    SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)pszStatus);
                }
            }
            LocalFree((void *)pszStatus);
        }
        break;

    case WM_DSV_DELAYINFOTIP:
        if ((CBackgroundInfoTip *)wParam == _pBackgroundInfoTip && _pBackgroundInfoTip->_fReady)
        {
            LRESULT lRet = SendMessage(_hwndListview, LVM_SETINFOTIP, NULL, (LPARAM)&_pBackgroundInfoTip->_lvSetInfoTip);
            ATOMICRELEASE(_pBackgroundInfoTip);
            return lRet;
        }
        break;

    case WM_DSV_ENSURE_COLUMNS_LOADED:
        if (!_fDestroying)
        {
            AddColumns();
            return 1;
        }
        break;

    case GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC):
        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                GetSysColor(COLOR_WINDOW));
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_DRAWCLIPBOARD:
        if (_hwndNextViewer != NULL)
            SendMessage(_hwndNextViewer, uMsg, wParam, lParam);

        if (_bClipViewer)
            return _OnClipboardChange();

        break;

    case WM_CHANGECBCHAIN:
        if ((HWND)wParam == _hwndNextViewer)
        {
            _hwndNextViewer = (HWND)lParam;
            return TRUE;
        }

        if (_hwndNextViewer != NULL)
            return SendMessage(_hwndNextViewer, uMsg, wParam, lParam);
        break;

    case WM_WININICHANGE:
        _OnWinIniChange(wParam, (LPCTSTR)lParam);
        SendMessage(_hwndListview, uMsg, wParam, lParam);
        break;

    case WM_THEMECHANGED:
        PostMessage(_hwndView, WM_COMMAND, (WPARAM)SFVIDM_MISC_REFRESH, 0);
        break;

    case WM_SHELLNOTIFY:
#define SHELLNOTIFY_SETDESKWALLPAPER 0x0004
        if (wParam == SHELLNOTIFY_SETDESKWALLPAPER)
        {
            if (_IsDesktop())
            {
                _fHasDeskWallPaper = (lParam != 0);
                _SetFolderColors();
            }
        }
        break;


    // What we would like out of these menu messages:
    //   WM_ENTERMENULOOP
    //   WM_INITMENUPOPUP
    //      for File.Edit.View...: handle ourselves (merge in _pcmFile etc) and forward to IShellFolderViewCB for init
    //      for submenus or context menus: forward to whatever IContextMenu owns the popup
    //   WM_INITMENUPOPUP for next menu, etc
    //   WM_EXITMENULOOP
    //      PostMessage(WM_DSV_MENUTERM)
    //   WM_COMMAND comes in, if a menu item was selected
    //      Forward to the correct object to handle
    //   WM_DSV_MENUTERM
    //      clean up File.Edit.View... (release _pcmFile etc), and forward to IShellFolderViewCB for cleanup
    //
    // From previous comments here, it sounds like we don't get proper WM_ENTERMENULOOP / WM_EXITMENULOOP.
    // I suspect this is a behavior change since Win95.  (This probably happened when we changed
    // the browser's HMENU to our own custom menu bar implementation way back in IE4...)
    //
    // Previous code also posted WM_DSV_MENUTERM *twice* -- another relic from the Edit menu days...
    //
    // If we try to clean up on WM_EXITMENULOOP, then we'll free _pcmFile etc when
    // the File menu closes. This caused us problems when we tried to merge _pcmFile
    // into the Edit menu.  (We should have used _pcmEdit and cleaned up on WM_UNINITMENUPOPUP.)
    // This is no longer a problem for defview, but it is a problem for the IShellFolderViewCB
    // which can merge into any of File.Edit.View... menus.  (In fact, no code in the source tree
    // does anything on SFVM_EXITMENULOOP.)
    //
    // We could free up _pcmFile early (when the File menu goes away) if we want,
    // but there doesn't seem to be any harm in letting it sit around.
    // So rip out this unused WM_EXITMENULOOP/WM_DSVMENUTERM/_OnMenuTermination code.
    //
    case WM_INITMENU:
        _OnInitMenu();
        break;

    case WM_INITMENUPOPUP:
        _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_TIMER:
        KillTimer(hWnd, (UINT) wParam);

        // Ignore if we're in the middle of destroying the window
        if (_fDestroying)
            break;

        if (DV_IDTIMER_START_ANI == wParam)
        {
            if (_hwndStatic)
            {
                WCHAR szName[128];
                HINSTANCE hinst;

                if (S_OK != CallCB(SFVM_GETANIMATION, (WPARAM)&hinst, (LPARAM)szName))
                {
                    hinst = g_hinst;
                    StrCpyW(szName, L"#150");
                }

                HWND hAnimate = ::GetWindow (_hwndStatic, GW_CHILD);

                if (hAnimate)
                {
                    // Animate_OpenEx() except we want the W version always
                    SendMessage(hAnimate, ACM_OPENW, (WPARAM)hinst, (LPARAM)szName);
                }
            }
        }
        else if (DV_IDTIMER_BUFFERED_REFRESH == wParam)
        {
            if (_fRefreshBuffered)
            {
                _fRefreshBuffered = FALSE;
                PostMessage(_hwndView, WM_KEYDOWN, (WPARAM)VK_F5, 0);
                TraceMsg(TF_DEFVIEW, "Buffered Refresh timer causes actual refresh");
            }
        }
        else if (DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE == wParam)
        {
            _OnDelayedSelectionChange();
        }
        else if (DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED == wParam)
        {
            _OnDelayedContentsChanged();
        }
        else if (DV_IDTIMER_DISKCACHE == wParam)
        {
            DWORD dwMode;
            if (_pDiskCache->GetMode(&dwMode) == S_OK && _pDiskCache->IsLocked() == S_FALSE)
            {
                // two seconds since last access, close the cache.
                _pDiskCache->Close(NULL);
            }

            if (_GetBackgroundTaskCount(TOID_NULL) == 0)
            {
                // there is nothing in the queue pending, so quit listening...
                KillTimer(hWnd, DV_IDTIMER_DISKCACHE);
            }
            break;

        }
        else if (DV_IDTIMER_SCROLL_TIMEOUT == wParam)
        {
            // Scroll timer expired.
            TraceMsg(TF_DEFVIEW, "SCROLL TIMEOUT");

            _fScrolling = FALSE;

            // Now we send a paint to listview, so it will send us more requests for tileinformation
            // that we ignored during scrolling.
            if (_fRequestedTileDuringScroll)
            {
                InvalidateRect(_hwndListview, NULL, FALSE);
            }
        }
        else
        {
            ASSERT(FALSE); // nobody is handling this timer id!
        }
        break;

    case WM_SETCURSOR:
        if (_hwndStatic)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            return TRUE;
        }
        goto DoDefWndProc;

    case WM_DRAWITEM:
        #define lpdis ((LPDRAWITEMSTRUCT)lParam)
        dwID = lpdis->itemID;

        if (lpdis->CtlType != ODT_MENU)
            return 0;
        if (InRange(lpdis->itemID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
        {
            CallCB(SFVM_DRAWITEM, SFVIDM_CLIENT_FIRST, lParam);
            return 1;
        }
        else
        {
            LRESULT lResult = 0;
            _ForwardMenuMessages(dwID, uMsg, wParam, lParam, &lResult, NULL);
            return lResult;
        }
        #undef lpdis

    case WM_MEASUREITEM:
        #define lpmis ((LPMEASUREITEMSTRUCT)lParam)
        dwID = lpmis->itemID;

        if (lpmis->CtlType != ODT_MENU)
            return 0;

        if (InRange(lpmis->itemID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
        {
            CallCB(SFVM_MEASUREITEM, SFVIDM_CLIENT_FIRST, lParam);
            return 1;
        }
        else
        {
            LRESULT lResult = 0;
            _ForwardMenuMessages(dwID, uMsg, wParam, lParam, &lResult, NULL);
            return lResult;
        }

    case WM_MENUCHAR:

        if (_pcmFile)
        {
            LRESULT lResult;
            HRESULT hr = SHForwardContextMenuMsg(_pcmFile, uMsg, wParam, lParam, &lResult, FALSE);
            if (hr == S_OK)
                return lResult;
        }

        if (_pcmContextMenuPopup)
        {
            LRESULT lResult;
            HRESULT hr = SHForwardContextMenuMsg(_pcmContextMenuPopup, uMsg, wParam, lParam, &lResult, FALSE);
            if (hr == S_OK)
                return lResult;
        }

        return MAKELONG(0, MNC_IGNORE);

    // there are two possible ways to put help texts in the
    // status bar, (1) processing WM_MENUSELECT or (2) handling MenuHelp
    // messages. (1) is compatible with OLE, but (2) is required anyway
    // for tooltips.
    //
    case WM_MENUSELECT:
        _OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam), GET_WM_MENUSELECT_FLAGS(wParam, lParam), GET_WM_MENUSELECT_HMENU(wParam, lParam));
        break;

    case WM_SYSCOLORCHANGE:
        _SetFolderColors();
        SendMessage(_hwndListview, uMsg, wParam, lParam);
        _rgbBackColor = CLR_INVALID;
        break;

    case SVM_SELECTITEM:
        SelectItem((LPCITEMIDLIST)lParam, (int) wParam);
        break;

    case SVM_SELECTANDPOSITIONITEM:
    {
        SFM_SAP * psap = (SFM_SAP*)lParam;
        for (UINT i = 0; i < wParam; psap++, i++)
            SelectAndPositionItem(psap->pidl, psap->uSelectFlags, psap->fMove ? &psap->pt : NULL);
        break;
    }

    case WM_PALETTECHANGED:
        if (_IsImageMode())
        {
            InvalidateRect(_hwndListview, NULL, FALSE);
            return TRUE;
        }
        // else Fall Through
    case WM_QUERYNEWPALETTE:
        if (_IsImageMode())
        {
            return FALSE; // Let Browser handle palette management
        }
        else
        {
            HWND hwndT = GetChildViewWindow();
            if (!hwndT)
                goto DoDefWndProc;

            return SendMessage(hwndT, uMsg, wParam, lParam);
        }

    case WM_DSV_REARRANGELISTVIEW:
        _ShowAndActivate();
        break;

    case WM_DSV_SENDSELECTIONCHANGED:
        _OnSelectionChanged();
        break;

    case WM_DSV_SENDNOITEMSTATECHANGED:
        _OnNoItemStateChanged();
        break;

    case WM_DSV_DESKHTML_CHANGES:
        if (_IsDesktop())
        {
            IADesktopP2 *piadp2;
            if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IADesktopP2, &piadp2))))
            {
                IActiveDesktopP *piadpp;

                //  98/11/23 #254482 vtan: When making changes using dynamic
                //  HTML don't forget to update the "desktop.htt" file so
                //  that it's in sync with the registry BEFORE using DHTML.
                if (SUCCEEDED(piadp2->QueryInterface(IID_PPV_ARG(IActiveDesktopP, &piadpp))))
                {
                    piadpp->EnsureUpdateHTML();     // ignore result
                    piadpp->Release();
                }
                piadp2->MakeDynamicChanges(_cFrame._pOleObj);
                piadp2->Release();
            }
        }
        break;

    // Toggling the New Start Menu on/off causes My Computer, etc.
    // desktop icons to dynamically hide/show themselves.
    case WM_DSV_STARTPAGE_TURNONOFF:
        _ReloadContent(FALSE);
        break;

    case WM_DSV_ADJUSTRECYCLEBINPOSITION:
        {
            // We need to move the recycle bin to it's default position.
            POINT ptRecycleBin;
            int iIndexRecycleBin = _FreezeRecycleBin(&ptRecycleBin);
            if (iIndexRecycleBin != LV_NOFROZENITEM)
                _SetRecycleBinInDefaultPosition(&ptRecycleBin);
        }
        break;

    default:
DoDefWndProc:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

// don't test the result as this will fail on the second call
void CDefView::_RegisterWindow(void)
{
    WNDCLASS wc = {0};

    // don't want vredraw and hredraw because that causes horrible
    // flicker expecially with full drag
    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = CDefView::s_WndProc;
    wc.cbWndExtra    = sizeof(CDefView *);
    wc.hInstance     = HINST_THISDLL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = TEXT("SHELLDLL_DefView");

    RegisterClass(&wc);
}

CDefView::~CDefView()
{
    _uState = SVUIA_DEACTIVATE;

    // Sanity check.
    ASSERT(_tlistPendingInfotips.GetHeadPosition() == NULL);

    DebugMsg(TF_LIFE, TEXT("dtor CDefView %x"), this);

    //
    // Just in case, there is a left over.
    //
    _dvdt.LeaveAndReleaseData();

    //
    // We need to give it a chance to clean up.
    //
    CallCB(SFVM_PRERELEASE, 0, 0);

    DestroyViewWindow();

    ATOMICRELEASE(_pSelectionShellItemArray);
    ATOMICRELEASE(_pFolderShellItemArray);

    ATOMICRELEASE(_pScheduler);
    //
    // We should release _psb after _pshf (for docfindx)
    //
    ATOMICRELEASE(_pshf);
    ATOMICRELEASE(_pshf2);
    ATOMICRELEASE(_pshfParent);
    ATOMICRELEASE(_pshf2Parent);
    ILFree(_pidlRelative);
    ATOMICRELEASE(_psi);
    ATOMICRELEASE(_psio);
    ATOMICRELEASE(_pcdb);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_psd);

    IUnknown_SetSite(_pcmFile, NULL);
    ATOMICRELEASE(_pcmFile);

    ATOMICRELEASE(_pcat);
    ATOMICRELEASE(_pImageCache);
    ATOMICRELEASE(_pDiskCache);

    DSA_Destroy(_hdaCategories);
    DSA_Destroy(_hdsaSCIDCache);

    //  NOTE we dont release psvOuter
    //  it has a ref on us

    if (_pbtn)
        LocalFree(_pbtn);

    //
    // Cleanup _dvdt
    //
    _dvdt.ReleaseDataObject();
    _dvdt.ReleaseCurrentDropTarget();

    _ClearPendingSelectedItems();

    ATOMICRELEASE(_pauto);
    ATOMICRELEASE(_padvise);

    if (_hmenuCur)
    {
        DestroyMenu(_hmenuCur);
    }

    ATOMICRELEASE(_pBackgroundInfoTip);
    ATOMICRELEASE(_ppui);

    if (_pidlSelectAndPosition)
        ILFree(_pidlSelectAndPosition);

    Str_SetPtr(&_pszLegacyWatermark, NULL);
}




HRESULT CDefView::_AddTask(IRunnableTask *pTask, REFTASKOWNERID rTID, DWORD_PTR lParam, DWORD dwPriority, DWORD grfFlags)
{
    HRESULT hr = E_FAIL;

    if (_pScheduler)
    {
        if (grfFlags & ADDTASK_ONLYONCE)
        {
            hr = _pScheduler->MoveTask(rTID, lParam, dwPriority, (grfFlags & ADDTASK_ATFRONT ? ITSSFLAG_TASK_PLACEINFRONT : ITSSFLAG_TASK_PLACEINBACK));
        }

        if (hr != S_OK)  // If we didn't move it, add it
        {
            hr = _pScheduler->AddTask2(pTask, rTID, lParam, dwPriority, (grfFlags & ADDTASK_ATFRONT ? ITSSFLAG_TASK_PLACEINFRONT : ITSSFLAG_TASK_PLACEINBACK));
        }
    }

    return hr;
}

//  Get the number of running tasks of the indicated task ID.
UINT CDefView::_GetBackgroundTaskCount(REFTASKOWNERID rtid)
{
    return _pScheduler ? _pScheduler->CountTasks(rtid) : 0;
}


const TBBUTTON c_tbDefView[] = {
    { VIEW_MOVETO | IN_VIEW_BMP,    SFVIDM_EDIT_MOVETO,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_COPYTO | IN_VIEW_BMP,    SFVIDM_EDIT_COPYTO,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { VIEW_VIEWMENU | IN_VIEW_BMP,  SFVIDM_VIEW_VIEWMENU,   TBSTATE_ENABLED,    BTNS_WHOLEDROPDOWN, {0,0}, 0, -1},
    // hidden buttons (off by default, available only via customize dialog)
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_OPTIONS | IN_VIEW_BMP,   SFVIDM_TOOL_OPTIONS,    TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
};

const TBBUTTON c_tbDefViewWebView[] = {
    //{ 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { VIEW_VIEWMENU | IN_VIEW_BMP,  SFVIDM_VIEW_VIEWMENU,   TBSTATE_ENABLED,    BTNS_WHOLEDROPDOWN, {0,0}, 0, -1},
    // hidden buttons (off by default, available only via customize dialog)
    { VIEW_MOVETO | IN_VIEW_BMP,    SFVIDM_EDIT_MOVETO,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_COPYTO | IN_VIEW_BMP,    SFVIDM_EDIT_COPYTO,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_OPTIONS | IN_VIEW_BMP,   SFVIDM_TOOL_OPTIONS,    TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
};

// win95 defview toolbar, used for corel apphack
const TBBUTTON c_tbDefView95[] = {
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    // the bitmap indexes here are relative to the view bitmap
    { VIEW_LARGEICONS | IN_VIEW_BMP, SFVIDM_VIEW_ICON,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_SMALLICONS | IN_VIEW_BMP, SFVIDM_VIEW_SMALLICON, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_LIST       | IN_VIEW_BMP, SFVIDM_VIEW_LIST,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_DETAILS    | IN_VIEW_BMP, SFVIDM_VIEW_DETAILS,   TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
};


LRESULT CDefView::_TBNotify(NMHDR *pnm)
{
    LPTBNOTIFY ptbn = (LPTBNOTIFY)pnm;

    switch (pnm->code)
    {
    case TBN_BEGINDRAG:
        _OnMenuSelect(ptbn->iItem, 0, 0);
        break;
    }
    return 0;
}

BOOL CDefView::_MergeIExplorerToolbar(UINT cExtButtons)
{
    BOOL fRet = FALSE;
    IExplorerToolbar *piet;
    if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        BOOL fGotClsid = TRUE;

        DWORD dwFlags = 0;

        if (cExtButtons == 0)
        {
            // This shf has no buttons to merge in; use the standard defview
            // clsid so that the shf shares standard toolbar customization.
            _clsid = CGID_DefViewFrame;

        }
        else if (SUCCEEDED(IUnknown_GetClassID(_pshf, &_clsid)))
        {
            // This shf has buttons to merge in; use its clsid
            // so that this shf gets separate customization persistence.

            // The shf might expect us to provide room for two lines of
            // text (since that was the default in IE4).
            dwFlags |= VBF_TWOLINESTEXT;
        }
        else
        {
            // This shf has buttons to merge in but doesn't implement
            // IPersist::GetClassID; so we can't use IExplorerToolbar mechanism.
            fGotClsid = FALSE;
        }

        if (fGotClsid)
        {
            HRESULT hr = piet->SetCommandTarget((IUnknown *)SAFECAST(this, IOleCommandTarget *), &_clsid, dwFlags);
            if (SUCCEEDED(hr))
            {
                // If hr == S_FALSE, another defview merged in its buttons under the
                // same clsid, and they're still there.  So no need to call AddButtons.

                if (hr != S_FALSE)
                    hr = piet->AddButtons(&_clsid, _cButtons, _pbtn);

                if (SUCCEEDED(hr))
                {
                    fRet = TRUE;
                }
            }
        }
        piet->Release();
    }
    return fRet;
}

int _FirstHiddenButton(TBBUTTON* ptbn, int cButtons)
{
    for (int i = 0; i < cButtons; i++)
    {
        if (ptbn[i].fsState & TBSTATE_HIDDEN)
            break;
    }

    return i;
}

void CDefView::_CopyDefViewButton(PTBBUTTON ptbbDest, PTBBUTTON ptbbSrc)
{
    *ptbbDest = *ptbbSrc;

    if (!(ptbbDest->fsStyle & BTNS_SEP))
    {
        // Fix up bitmap offset depending on whether this is a "view" bitmap or a "standard" bitmap
        if (ptbbDest->iBitmap & IN_VIEW_BMP)
            ptbbDest->iBitmap = (int)((ptbbDest->iBitmap & ~PRIVATE_TB_FLAGS) + _iViewBMOffset);
        else
            ptbbDest->iBitmap = (int)(ptbbDest->iBitmap + _iStdBMOffset);
    }
}

//
// Here's the deal with _GetButtons
//
// DefView has some buttons, and its callback client may have some buttons.
//
// Some of defview's buttons are visible on the toolbar by default, and some only show
// up if you customize the toolbar.
//
// We specify which buttons are hidden by default by marking them with TBSTATE_HIDDEN in
// the declaration of c_tbDefView.  We assume all such buttons are in a continuous block at
// the end of c_tbDefView.
//
// We return in ppbtn a pointer to an array of all the buttons, including those not shown
// by default.  We put the buttons not shown by default at the end of this array.  We pass
// back in pcButtons the count of visible buttons, and in pcTotalButtons the count of visible
// and hidden buttons.
//
// The int return value is the number of client buttons in the array.
//
int CDefView::_GetButtons(PTBBUTTON* ppbtn, LPINT pcButtons, LPINT pcTotalButtons)
{
    int cVisibleBtns = 0;   // count of visible defview + client buttons

    TBINFO tbinfo;
    tbinfo.uFlags = TBIF_APPEND;
    tbinfo.cbuttons = 0;

    // Does the client want to prepend/append a toolbar?
    CallCB(SFVM_GETBUTTONINFO, 0, (LPARAM)&tbinfo);

    _uDefToolbar = HIWORD(tbinfo.uFlags);
    tbinfo.uFlags &= 0xffff;


    // tbDefView needs to be big enough to hold either c_tbDefView or c_tbDefView95
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbDefView95) >= ARRAYSIZE(c_tbDefView));

    TBBUTTON tbDefView[ARRAYSIZE(c_tbDefView95)];
    int cDefViewBtns;   // total count of defview buttons

    if (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)
    {
        memcpy(tbDefView, c_tbDefView95, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefView95));
        cDefViewBtns = ARRAYSIZE(c_tbDefView95);
    }
    else if (_cFrame.IsWebView() || _pDUIView)
    {
        memcpy(tbDefView, c_tbDefViewWebView, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefViewWebView));
        cDefViewBtns = ARRAYSIZE(c_tbDefViewWebView);
    }
    else
    {
        memcpy(tbDefView, c_tbDefView, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefView));
        cDefViewBtns = ARRAYSIZE(c_tbDefView);
    }

    int cVisibleDefViewBtns = _FirstHiddenButton(tbDefView, cDefViewBtns);  // count of visible defview buttons

    TBBUTTON *pbtn = (TBBUTTON *)LocalAlloc(LPTR, (cDefViewBtns + tbinfo.cbuttons) * sizeof(*pbtn));
    if (pbtn)
    {
        int iStart = 0;
        cVisibleBtns = tbinfo.cbuttons + cVisibleDefViewBtns;

        // Have the client fill in its buttons
        switch (tbinfo.uFlags)
        {
        case TBIF_PREPEND:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)pbtn);
            iStart = tbinfo.cbuttons;
            break;

        case TBIF_APPEND:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)&pbtn[cVisibleDefViewBtns]);
            iStart = 0;
            break;

        case TBIF_REPLACE:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)pbtn);

            cVisibleBtns = tbinfo.cbuttons;
            cVisibleDefViewBtns = 0;
            break;

        default:
            RIPMSG(0, "View callback passed an invalid TBINFO flag");
            break;
        }

        // Fill in visible defview buttons
        for (int i = 0; i < cVisibleDefViewBtns; i++)
        {
            // Visible defview button block gets added at iStart
            _CopyDefViewButton(&pbtn[i + iStart], &tbDefView[i]);
        }

        // Fill in hidden defview buttons
        for (i = cVisibleDefViewBtns; i < cDefViewBtns; i++)
        {
            // Hidden defview button block gets added after visible & client buttons
            _CopyDefViewButton(&pbtn[i + tbinfo.cbuttons], &tbDefView[i]);

            // If this rips a visible button got mixed in with the hidden block
            ASSERT(pbtn[i + tbinfo.cbuttons].fsState & TBSTATE_HIDDEN);

            // Rip off the hidden bit
            pbtn[i + tbinfo.cbuttons].fsState &= ~TBSTATE_HIDDEN;
        }
    }

    ASSERT(ppbtn);
    ASSERT(pcButtons);
    ASSERT(pcTotalButtons);

    *ppbtn = pbtn;
    *pcButtons = cVisibleBtns;
    *pcTotalButtons = tbinfo.cbuttons + cDefViewBtns;

    return tbinfo.cbuttons;
}


void CDefView::MergeToolBar(BOOL bCanRestore)
{
    TBADDBITMAP ab;

    ab.hInst = HINST_COMMCTRL;          // hinstCommctrl
    ab.nID   = IDB_STD_SMALL_COLOR;     // std bitmaps
    _psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&ab, &_iStdBMOffset);

    ab.nID   = IDB_VIEW_SMALL_COLOR;    // std view bitmaps
    _psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&ab, &_iViewBMOffset);

    if (_pbtn)
        LocalFree(_pbtn);

    int cExtButtons = _GetButtons(&_pbtn, &_cButtons, &_cTotalButtons);

    if (_pbtn && !_MergeIExplorerToolbar(cExtButtons))
    {
        // if we're able to do the new IExplorerToolbar merge method, great...
        // if not, we use the old style
        _psb->SetToolbarItems(_pbtn, _cButtons, FCT_MERGE);
        CDefView::CheckToolbar();
    }
}

STDMETHODIMP CDefView::GetWindow(HWND *phwnd)
{
    *phwnd = _hwndView;
    return S_OK;
}

STDMETHODIMP CDefView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDefView::EnableModeless(BOOL fEnable)
{
    // We have no modeless window to be enabled/disabled
    return S_OK;
}

HRESULT CDefView::_ReloadListviewContent()
{
    // HACK: We always call IsShared with fUpdateCache=FALSE for performance.
    //  However, we need to update the cache when the user explicitly tell
    //  us to "Refresh". This is not the ideal place to put this code, but
    //  we have no other choice.

    TCHAR szPathAny[MAX_PATH];

    _UpdateSelectionMode();

    // finish any pending edits
    SendMessage(_hwndListview, LVM_EDITLABEL, (WPARAM)-1, 0);

    GetWindowsDirectory(szPathAny, ARRAYSIZE(szPathAny));
    IsShared(szPathAny, TRUE);

    // HACK: strange way to notify folder that we're refreshing
    ULONG rgf = SFGAO_VALIDATE;
    _pshf->GetAttributesOf(0, NULL, &rgf);

    //
    // if a item is selected, make sure it gets nuked from the icon
    // cache, this is a last resort type thing, select a item and
    // hit F5 to fix all your problems.
    //
    int iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
    if (iItem != -1)
        CFSFolder_UpdateIcon(_pshf, _GetPIDL(iItem));

    // We should not save the selection if doing refresh.
    _ClearPendingSelectedItems();

    // 01/05/21 #399284: Don't save/restore the state and nuke objects if there's a background process using them
    if(!_bBkFilling)
    {
        // First we have to save all the icon positions, so they will be restored
        // properly during the FillObjectsShowHide
        SaveViewState();

        // 99/04/07 #309965 vtan: Persist the view state (above). Make sure
        // our internal representation is the same as the one on the disk
        // by dumping our cache and reloading the information.
        GetViewState();

        // To make it look like the refesh is doing something, clear
        // all the icons from the view before we start enumerating.
        _RemoveObject(NULL, FALSE);
        _fSyncOnFillDone = TRUE; // apply the just-saved view state when we finish enumeration

    }

    return FillObjectsShowHide(TRUE);
}

HRESULT CDefView::_ReloadContent(BOOL fForce)
{
    if (_bReEntrantReload)
    {
        return S_FALSE;
    }
    _bReEntrantReload = TRUE;

    HRESULT hrExtView = S_OK;
    HRESULT hrNormalView = S_OK;
    SHELLSTATE ss;

    // Tell the defview client that this window is about to be refreshed
    _CallRefresh(TRUE);

    // make sure that the CommandIds and the Uids match by recreating the menus
    RecreateMenus();

    // If the global SSF_WIN95CLASSIC state changed, we need to muck with the UI.
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);
    // Show webview and pane again if we are forced OR the view has changed.
    if (fForce || (BOOLIFY(ss.fWin95Classic) != BOOLIFY(_fClassic)))
    {
        _fClassic = ss.fWin95Classic;
        _UpdateListviewColors();
    }

    if (_ShouldShowWebView())
    {
        // We need to save the icon positions before we refresh the view.
        SaveViewState();

        if (_pDUIView)
        {
            hrExtView = _pDUIView->Refresh();
        }
        else
        {
            _TryShowWebView(_fs.ViewMode, _fs.ViewMode);
        }
    }
    else
    {
        _TryHideWebView(); // make sure it's off
    }

    // We want to preserve the earlier error if any
    hrNormalView = _ReloadListviewContent();

    _bReEntrantReload = FALSE;
    return FAILED(hrExtView) ? hrExtView : hrNormalView;
}

STDMETHODIMP CDefView::Refresh()
{
    // See if some refreshes were buffered
    if (_fRefreshBuffered)
    {
        //Since we are refreshing it right now. Kill the timer.
        TraceMsg(TF_DEFVIEW, "Buffered Refresh Timer Killed by regular Refresh");
        KillTimer(_hwndView, DV_IDTIMER_BUFFERED_REFRESH);
        _fRefreshBuffered = FALSE;
    }

    // If desktop is in modal state, do not attempt to refresh.
    // If we do, we endup destroying Trident object when it is in modal state.
    if (_IsDesktop() && _fDesktopModal)
    {
        // Remember that we could not refresh the desktop because it was in
        // a modal state.
        _fDesktopRefreshPending = TRUE;
        return S_OK;
    }

    // make sure we have the latest
    SHRefreshSettings();

    _UpdateRegFlags();

    if (_IsDesktop())
    {
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);

        // The following code is not needed because _ReloadContent() takes care of switching to 
        // web-view.
        // _SwitchDesktopHTML(BOOLIFY(ss.fDesktopHTML));
        
        if (ss.fDesktopHTML)
        {
            // For backward compatibility, hide the desktop channel bar.
            HideIE4DesktopChannelBar();
            
            // ActiveDesktop is not part of shdocvw's browser session count
            // so when we refresh, we must tell wininet to reset the session
            // count otherwise we will not hit the net.
            MyInternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);
        }
    }

    return _ReloadContent(TRUE);
}

STDMETHODIMP CDefView::CreateViewWindow(IShellView *psvPrevious,
        LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prc, HWND *phWnd)
{
    SV2CVW2_PARAMS cParams = {0};

    cParams.cbSize   = sizeof(SV2CVW2_PARAMS);
    cParams.psvPrev  = psvPrevious;
    cParams.pfs      = pfs;
    cParams.psbOwner = psb;
    cParams.prcView  = prc;

    HRESULT hr = CreateViewWindow2(&cParams);

    *phWnd = cParams.hwndView;

    if (SUCCEEDED(hr) &&
        (SHGetAppCompatFlags(ACF_OLDCREATEVIEWWND) & ACF_OLDCREATEVIEWWND))
    {
        //
        //  CreateViewWindow was documented as returning S_OK on success,
        //  but IE4 changed the function to return S_FALSE if the defview
        //  was created async.
        //
        //  PowerDesk relies on the old behavior.
        //  So does Quattro Pro.
        //
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CDefView::HandleRename(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    // Gross, but if no PIDL passed in use the GetObject(-2) hack to get the selected object...
    // Don't need to free as it wsa not cloned...
    if (!pidl)
    {
        GetObject((LPITEMIDLIST*)&pidl, (UINT)-2);
    }
    else
    {
        RIP(ILFindLastID(pidl) == pidl);
        if (ILFindLastID(pidl) != pidl)
        {
            return E_INVALIDARG;
        }
    }

    hr = SelectAndPositionItem(pidl, SVSI_SELECT, NULL);
    if (SUCCEEDED(hr))
        hr = SelectAndPositionItem(pidl, SVSI_EDIT, NULL);

    return hr;
}



// IViewObject
HRESULT CDefView::GetColorSet(DWORD dwAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, LOGPALETTE **ppColorSet)
{
    if (_cFrame.IsWebView() && _cFrame._pvoActive)
    {
        return _cFrame._pvoActive->GetColorSet(dwAspect, lindex, pvAspect,
            ptd, hicTargetDev, ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return E_FAIL;
}

HRESULT CDefView::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CDefView::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDefView::SetAdvise(DWORD dwAspect, DWORD advf, IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            PropagateOnViewChange(dwAspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDefView::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

HRESULT CDefView::Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
    const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR)
{
    return E_NOTIMPL;
}

void CDefView::PropagateOnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        ATOMICRELEASE(punkRelease);
    }
}

void CDefView::PropagateOnClose()
{
    //
    // we aren't closing ourselves, just somebody under us...
    // ...reflect this up the chain as a view change.
    //
    if (_padvise)
        PropagateOnViewChange(_advise_aspect, -1);
}

UINT CDefView::_ValidateViewMode(UINT uViewMode)
{
    UINT uViewModeDefault = FVM_ICON;

    if (uViewMode >= FVM_FIRST && uViewMode <= FVM_LAST)
    {
        uViewModeDefault = uViewMode;
#ifdef DEBUG
        if (!_ViewSupported(uViewMode))
        {
            // Whoa! the default is excluded?  Ignore it.
            TraceMsg(TF_WARNING, "Bug in IShellFolderViewCB client: returned a default viewmode that is excluded");
        }
#endif
    }
    else
    {
        TraceMsg(TF_WARNING, "Bug in IShellFolderViewCB client: returned invalid viewmode");
    }

    return uViewModeDefault;
}


UINT CDefView::_GetDefaultViewMode()
{
    UINT uViewMode = FVM_ICON;
    CallCB(SFVM_DEFVIEWMODE, 0, (LPARAM)&uViewMode);

    return _ValidateViewMode(uViewMode);
}

void CDefView::_GetDeferredViewSettings(UINT* puViewMode)
{
    SFVM_DEFERRED_VIEW_SETTINGS sdvsSettings;

    ZeroMemory(&sdvsSettings, sizeof(sdvsSettings));

    if (SUCCEEDED(CallCB(SFVM_GETDEFERREDVIEWSETTINGS, 0, (LPARAM)&sdvsSettings)))
    {
        _vs._lParamSort = sdvsSettings.uSortCol;
        _vs._iDirection = sdvsSettings.iSortDirection >= 0 ? 1 : -1;
        *puViewMode     = _ValidateViewMode(sdvsSettings.fvm);

        _fs.fFlags = (_fs.fFlags & ~FWF_AUTOARRANGE) | (sdvsSettings.fFlags & FWF_AUTOARRANGE);
        SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, _IsAutoArrange() ? LVS_AUTOARRANGE : 0);

        if (sdvsSettings.fGroupView && (*puViewMode != FVM_THUMBSTRIP))
        {
            SHCOLUMNID scid;
            if SUCCEEDED(_pshf2->MapColumnToSCID(sdvsSettings.uSortCol, &scid))
            {
                _CategorizeOnGUID(&CLSID_DetailCategorizer, &scid);
            }
        }
    }
    else
    {
        *puViewMode = _GetDefaultViewMode();
    }
}

BOOL CDefView::_ViewSupported(UINT uView)
{
    SFVM_VIEW_DATA vi;
    _GetSFVMViewState(uView, &vi);

    BOOL fIncludeView;
    if (vi.dwOptions == SFVMQVI_INCLUDE)
        fIncludeView = TRUE;
    else if (vi.dwOptions == SFVMQVI_EXCLUDE)
        fIncludeView = FALSE;
    else
        fIncludeView = uView != FVM_THUMBSTRIP; // by default, everything is included except FVM_THUMBSTRIP

    return fIncludeView;
}

STDMETHODIMP CDefView::GetView(SHELLVIEWID* pvid, ULONG uView)
{
    HRESULT hr;

    if ((int)uView >= 0)
    {
        // start with the first supported view
        UINT fvm = FVM_FIRST;
        while (fvm <= FVM_LAST && !_ViewSupported(fvm))
            fvm++;

        // find fvm associated with index uView
        for (ULONG i = 0; fvm <= FVM_LAST && i < uView; fvm++, i++)
        {
            // skip unsupported views
            while (fvm <= FVM_LAST && !_ViewSupported(fvm))
                fvm++;
        }

        if (fvm <= FVM_LAST)
        {
            hr = SVIDFromViewMode((FOLDERVIEWMODE)fvm, pvid);
        }
        else if (i == uView)
        {
            // enumerate the "default view" so the browser doesn't throw it out later
            *pvid = VID_DefaultView;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // We're being asked about specific view info:

        switch (uView)
        {
        case SV2GV_CURRENTVIEW:
            hr = SVIDFromViewMode((FOLDERVIEWMODE)_fs.ViewMode, pvid);
            break;

        case SV2GV_DEFAULTVIEW:
            // tell the browser "default" so we can pick the right one later on
            *pvid = VID_DefaultView;
            hr = S_OK;
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }
    }

    return hr;
}

// For Folder Advanced Options flags that we check often, it's better
// to cache the values as flags. Update them here.
void CDefView::_UpdateRegFlags()
{
    DWORD dwValue, cbSize = sizeof(dwValue);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize)
        && dwValue)
    {
        _fWin95ViewState = TRUE;
    }
    else
    {
        _fWin95ViewState = FALSE;
    }
}

BOOL CDefView::_SetupNotifyData()
{
    if (!_pidlMonitor && !_lFSEvents)
    {
        LPCITEMIDLIST pidl = NULL;
        LONG lEvents = 0;

        if (SUCCEEDED(CallCB(SFVM_GETNOTIFY, (WPARAM)&pidl, (LPARAM)&lEvents)))
        {
            _pidlMonitor = pidl;
            _lFSEvents = lEvents;
        }
    }
    return _pidlMonitor || _lFSEvents;
}

void CDefView::_ShowViewEarly()
{
    // Show the window early (what old code did)
    SetWindowPos(_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
    _OnMoveWindowToTop(_hwndView);
    UpdateWindow(_hwndView);
}

BOOL LV_FindWorkArea(RECT rcWorkAreas[], int nWorkAreas, POINT *ppt, int *piWorkArea)
{
    for (int iWork = 0; iWork < nWorkAreas; iWork++)
    {
        if (PtInRect(&rcWorkAreas[iWork], *ppt))
        {
            *piWorkArea = iWork;
            return TRUE;
        }
    }

    *piWorkArea = 0;    // default case is the primary work area
    return FALSE;
}

void CDefView::_ClearItemPositions()
{
    _fUserPositionedItems = FALSE;
    _vs.ClearPositionData();
}

//
// This function finds the Recycle bin icon and freezes it. It also freezes the bottom right corner
// slot sothat no icon can occupy it.
//

int CDefView::_FreezeRecycleBin(POINT *ppt)
{
    int iIndexRecycleBin = -1;

    if (_IsDesktop())
    {
        LPITEMIDLIST pidlRecycleBin;
        if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &pidlRecycleBin)))
        {
            //Find the index of the recycle bin in the listview.
            iIndexRecycleBin = _FindItem(pidlRecycleBin, NULL, FALSE);
            if (iIndexRecycleBin >= 0) //If we don't find recycle bin, we don't have anything to do!
            {
                //Freeze the recycle item (prevent it from moving)
                ListView_SetFrozenItem(_hwndListview, TRUE, iIndexRecycleBin);

                RECT rcItem;
                ListView_GetItemRect(_hwndListview, iIndexRecycleBin, &rcItem, LVIR_SELECTBOUNDS);

                //Get the ViewRect.
                RECT    rcViewRect;
                int     nWorkAreas = 0;
                //Get the number of work-areas
                ListView_GetNumberOfWorkAreas(_hwndListview, &nWorkAreas);
                if (nWorkAreas > 1)
                {
                    ASSERT(nWorkAreas <= LV_MAX_WORKAREAS);
                    RECT rcWorkAreas[LV_MAX_WORKAREAS];
                    int iCurWorkArea = 0;
                    //Get all the work areas!
                    ListView_GetWorkAreas(_hwndListview, nWorkAreas, &rcWorkAreas[0]);
                    //Find which work area the Recycle-bin currently lies.
                    LV_FindWorkArea(rcWorkAreas, nWorkAreas, (LPPOINT)(&rcItem.left), &iCurWorkArea);
                    CopyRect(&rcViewRect, &rcWorkAreas[iCurWorkArea]);
                }
                else
                {
                    ListView_GetViewRect(_hwndListview, &rcViewRect);
                }

                //Calculate the bottom-right corner of this slot
                POINT ptRecycleBin;
                ptRecycleBin.x = rcViewRect.right;
                ptRecycleBin.y = rcViewRect.bottom;

                //Freeze this slot sothat no other icon can occupy this.
                ListView_SetFrozenSlot(_hwndListview, TRUE, &ptRecycleBin);

                RECT rcIcon;
                ListView_GetItemRect(_hwndListview, iIndexRecycleBin, &rcIcon, LVIR_ICON);

                ppt->x = rcViewRect.right  - RECTWIDTH(rcIcon)  - (RECTWIDTH(rcItem)  - RECTWIDTH(rcIcon))/2;
                ppt->y = rcViewRect.bottom - RECTHEIGHT(rcItem);
            }
            ILFree(pidlRecycleBin);
        }
    }

    return iIndexRecycleBin;
}

//
// This function moves the RecycleBin item to the given location and then unfreezes the item and
// the frozen slot.
//
void CDefView::_SetRecycleBinInDefaultPosition(POINT *ppt)
{
    // If a sorting has happened since an item was frozen, the index of that item would have changed.
    // So, get the index of the recycle bin here.
    int iIndexRecycleBin = ListView_GetFrozenItem(_hwndListview);

    if (iIndexRecycleBin != LV_NOFROZENITEM)
    {
        //Move the recycle-bin icon to it's default position
        _SetItemPosition(iIndexRecycleBin, ppt->x, ppt->y);
        //Unfreeze the slot
        ListView_SetFrozenSlot(_hwndListview, FALSE, NULL); //FALSE ==> Unfreeze!
        //Unfreeze the recycle bin
        ListView_SetFrozenItem(_hwndListview, FALSE, 0); //FALSE ==> Unfreeze!
        //Since we repositioned recyclebin earlier, we need to save it in the registry.
        //Do we need this?
        // SaveViewState();
    }
}

STDMETHODIMP CDefView::CreateViewWindow2(LPSV2CVW2_PARAMS pParams)
{
    if (g_dwProfileCAP & 0x00000001)
        StopCAP();

    if (pParams->cbSize < sizeof(SV2CVW2_PARAMS))
        return E_INVALIDARG;

    pParams->hwndView = NULL;

    _RegisterWindow();

    if (_hwndView || !pParams->psbOwner)
        return E_UNEXPECTED;

    DECLAREWAITCURSOR;
    SetWaitCursor();

    // Need to leave this code as is. Previously, we had changed it to
    // pParams->psbOwner->QueryInterface(IID_PPV_ARG(IShellBrowser, &_psb));
    // However, this breaks Corel Quattro Pro 8 in their filesave dialog.
    // They pass in some sort of dummy "stub" IShellBrowser. QI'ing it for IShellBrowser
    // will do nothing, and thus _psb will remain null, and we crash. Restoring it to
    // the old way, _psb will be their "stub", but still valid, IShellBrowser.
    // Look for other comments for "Quattro Pro" in this file to see why they pass
    // in this stub.
    // (do this before doing the GetWindowRect)
    _psb = pParams->psbOwner;
    _psb->AddRef();
    ASSERT(_psb); // much of our code assumes this to be valid w/o checking

#ifdef _X86_
    // Verify that the CHijaakObjectWithSite is properly laid out
    COMPILETIME_ASSERT(FIELD_OFFSET(CDefView, _psfHijaak) + sizeof(_psfHijaak) ==
                       FIELD_OFFSET(CDefView, _psb));
#endif

    _fGlobeCanSpin = TRUE;
    _GlobeAnimation(TRUE);

    HRESULT hr;

    SHELLSTATE ss; // we will need these bits later on
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DESKTOPHTML | SSF_WEBVIEW | SSF_STARTPANELON, FALSE);

    _pshf->QueryInterface(IID_PPV_ARG(IShellIcon, &_psi));
    _pshf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &_psio));

    pParams->psbOwner->QueryInterface(IID_PPV_ARG(ICommDlgBrowser, &_pcdb));

    // listview starts out in large icon mode, we will switch to the proper view shortly
    _fs.ViewMode = FVM_ICON;

    // refetch FWF_ after browser supplied versions stomped our copy
    _fs.fFlags = pParams->pfs->fFlags & ~FWF_OWNERDATA;
    CallCB(SFVM_FOLDERSETTINGSFLAGS, 0, (LPARAM)&_fs.fFlags);

    // pvid takes precedence over pfs->ViewMode
    UINT fvm = pParams->pfs->ViewMode;
    if (pParams->pvid)
    {
        if (IsEqualIID(*pParams->pvid, VID_DefaultView))
            fvm = FVM_LAST + 1; // not a real view -- we will pick after enumeration
        else
            ViewModeFromSVID(pParams->pvid, (FOLDERVIEWMODE *)&fvm);
    }

    // This should never fail
    _psb->GetWindow(&_hwndMain);
    ASSERT(IsWindow(_hwndMain));
    CallCB(SFVM_HWNDMAIN, 0, (LPARAM)_hwndMain);

    // We need to restore the column widths and icon positions before showing the window
    if (!GetViewState())
    {
        // Icon positions are not available; Therefore, it is a clean install
        // and we need to position recycle bin if this is Desktop.
        _fPositionRecycleBin = BOOLIFY(_IsDesktop());
    }
    _fSyncOnFillDone = TRUE; // apply the just-loaded view state when we finish enumeration

    // if there was a previous view that we know about, update our column state
    if (_fWin95ViewState && pParams->psvPrev)
    {
        _vs.InitFromPreviousView(pParams->psvPrev);
    }

    _pEnumTask = new CDefviewEnumTask(this);
    if (_pEnumTask &&
        CreateWindowEx(IS_WINDOW_RTL_MIRRORED(_hwndMain) ? dwExStyleRTLMirrorWnd : 0, 
            TEXT("SHELLDLL_DefView"), NULL,
            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP,
            pParams->prcView->left, pParams->prcView->top, 
            pParams->prcView->right - pParams->prcView->left, 
            pParams->prcView->bottom - pParams->prcView->top,
            _hwndMain, NULL, HINST_THISDLL, this))
    {
        // See if they want to overwrite the selection object
        if (_fs.fFlags & FWF_OWNERDATA)
        {
            // Only used in owner data.
            ILVRange *plvr = NULL;
            CallCB(SFVM_GETODRANGEOBJECT, LVSR_SELECTION, (LPARAM)&plvr);
            if (plvr)
            {
                ListView_SetLVRangeObject(_hwndListview, LVSR_SELECTION, plvr);
                plvr->Release();    // We assume the lv will hold onto it...
            }

            plvr = NULL;
            CallCB(SFVM_GETODRANGEOBJECT, LVSR_CUT, (LPARAM)&plvr);
            if (plvr)
            {
                ListView_SetLVRangeObject(_hwndListview, LVSR_CUT, plvr);
                plvr->Release();    // We assume the lv will hold onto it...
            }
        }

        // This needs to be done before calling _BestFit (used to be in _FillObjects)
        // so that the parent can handle size changes effectively.
        pParams->hwndView = _hwndView;

        // Since ::FillObjects can take a while we force a paint now
        // before any items are added so we don't see the gray background of
        // the explorer window for a long time.
        //
        // We used to do this after determining "async-ness" of the view, which
        // required us to pick the webview template.  We want to postpone that
        // decision so force the repaint in the same scenarios that we otherwise
        // would have (non-webview or desktop).
        //
        // Make an educated guess here, if we get it wrong, we fix it up below.
        //
        if (!_ShouldShowWebView() || _IsDesktop())
        {
            _ShowViewEarly();
        }

        // Try and fill the listview synchronously with view creation.
        //
        _fAllowSearchingWindow = TRUE;
        hr = _pEnumTask->FillObjectsToDPA(TRUE);
        if (SUCCEEDED(hr))
        {
            // Setting the view mode has to happen after SFVM_ENUMERATEDITEMS
            // NOTE: this also AddColumns() if the new view requires them
            if (FVM_LAST + 1 == fvm)
                _GetDeferredViewSettings(&fvm);

            // Don't call SetCurrentViewMode since it clears position data and we may have read in
            // position data via GetViewState but haven't used it yet.  Call _SwitchToViewFVM directly.
            hr = _SwitchToViewFVM(fvm, SWITCHTOVIEW_NOWEBVIEW);


            // The following bits depend on the result of _SwitchToViewFVM.
            // It returns the value from turning on web view,
            // this is used to determine async defview behavior (so we have
            // an answer to the SHDVID_CANACTIVATENOW question the browser
            // will soon ask us).
            //
            // Note: Desktop synchronous, even for web view
            //
            if (SUCCEEDED(hr) && _IsDesktop())
                hr = S_OK;
            _fCanActivateNow = (S_OK == hr); // S_FALSE implies async waiting for ReadyStateInteractive
            _fIsAsyncDefView = !BOOLIFY(_fCanActivateNow); // needed in a separate bit since _fCanActivateNow changes

            // This has to happen after _SwitchToViewFVM so it can calculate
            // the correct size of the window
            _BestFit();

            // Tell the defview client that this windows has been initialized
            // Note that this must come before _pEnumTask->FillObjectsDPAToDone() so that the status bar displays
            // (Disk Free space xxGB) correctly in explorer view.
            CallCB(SFVM_WINDOWCREATED, (WPARAM)_hwndView, 0);

            //
            // If this is desktop, we need to calc and upgrade the grid sizes.
            // (This is needed because the SnapToGrid may be ON and the default grid size
            // will result in large gutter space on the edges).
            //
            if (_IsDesktop())
            {
                DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(_hwndListview);
                //
                //Since the work areas are NOT yet set for the desktop's listview (because this is too early
                //in it's creation, we pass just one work area and the view rect as work area here.)
                //
                UpdateGridSizes(TRUE, _hwndListview, 1, pParams->prcView, BOOLIFY(dwLVExStyle & LVS_EX_SNAPTOGRID));
            }
            
            // Doing this after _BestFit means we dont need to auto-auto arrange
            _pEnumTask->FillObjectsDPAToDone();

            // splitting this function call in half means that we won't call WebView with contents changed for initial population
            _SwitchToViewFVM(fvm, SWITCHTOVIEW_WEBVIEWONLY);

            // If we're activating now, make sure we did the synchronous thing up above...
            // (If not, do it now -- otherwise defview may never be shown)
            if (_fCanActivateNow && !(!_ShouldShowWebView() || _IsDesktop()))
            {
                _ShowViewEarly();
            }
        
            if (_IsDesktop())
            {
                HideIE4DesktopChannelBar();
            }

            // turn on proper background and colors
            _fClassic = ss.fWin95Classic;
            _UpdateListviewColors();

            // this needs to be done after the enumeration
            if (_SetupNotifyData())
            {
                SHChangeNotifyEntry fsne = {0};

                if (FAILED(CallCB(SFVM_QUERYFSNOTIFY, 0, (LPARAM)&fsne)))
                {
                    // Reset entry
                    fsne.pidl = _pidlMonitor;
                    fsne.fRecursive = FALSE;
                }

                int iSources = (_lFSEvents & SHCNE_DISKEVENTS) ? SHCNRF_ShellLevel | SHCNRF_InterruptLevel : SHCNRF_ShellLevel;
                LONG lEvents = _lFSEvents | SHCNE_UPDATEIMAGE | SHCNE_UPDATEDIR;
                _uRegister = SHChangeNotifyRegister(_hwndView, SHCNRF_NewDelivery | iSources,
                    lEvents, WM_DSV_FSNOTIFY, 1, &fsne);
            }

            // We do the toolbar before the menu bar to avoid flash
            if (!_IsDesktop())
                MergeToolBar(TRUE);

            // Note: it's okay for the CreateViewObject(&_pdtgtBack) to fail
            ASSERT(_pdtgtBack == NULL);
            _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IDropTarget, &_pdtgtBack));

            // we don't really need to register drag drop when in the shell because
            // our frame does it for us.   we still need it here for comdlg and other
            // hosts.. but for the desktop, let the desktpo frame take care of this
            // so that they can do webbar d/d creation
            if (!_IsDesktop())
            {
                THR(RegisterDragDrop(_hwndListview, SAFECAST(this, IDropTarget*)));
                _bRegisteredDragDrop = TRUE;
            }

            ASSERT(SUCCEEDED(hr))

            PostMessage(_hwndView, WM_DSV_DELAYWINDOWCREATE, 0, 0);

            if (SUCCEEDED(CallCB(SFVM_QUERYCOPYHOOK, 0, 0)))
                AddCopyHook();

            if (SUCCEEDED(_GetIPersistHistoryObject(NULL)))
            {
                IBrowserService *pbs;
                if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
                {
                    IOleObject *pole;
                    IStream *pstm;
                    IBindCtx *pbc;
                    pbs->GetHistoryObject(&pole, &pstm, &pbc);
                    if (pole)
                    {
                        IUnknown_SetSite(pole, SAFECAST(this, IShellView2*));      // Set the back pointer.
                        if (pstm)
                        {
                            IPersistHistory *pph;
                            if (SUCCEEDED(pole->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph))))
                            {
                                pph->LoadHistory(pstm, pbc);
                                pph->Release();
                            }
                            pstm->Release();
                        }
                        IUnknown_SetSite(pole, NULL);  // just to be safe...
                        if (pbc)
                            pbc->Release();
                        pole->Release();
                    }
                    pbs->Release();
                }
            }

            if (_psb && !_dwProffered)
            {
                // Proffer DVGetEnum service: this connects CDefView with the tree control for
                // optimized navigation.
                IUnknown_ProfferService(_psb, SID_SFolderView, SAFECAST(this, IServiceProvider *), &_dwProffered);
                // Failure here does not require special handling
            }
        }
        else
        {
            // Cleanup - enum failed.
            DestroyViewWindow();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    _GlobeAnimation(FALSE);

    ResetWaitCursor();

    return hr;
}

struct SCHEDULER_AND_HWND {
    IShellTaskScheduler *pScheduler;
    HWND hwnd;
};

STDMETHODIMP CDefView::DestroyViewWindow()
{
    if (_fDestroying)
        return S_OK;

    if (_psb && _dwProffered)
    {
        // Revoke DVGetEnum service
        IUnknown_ProfferService(_psb, SID_SFolderView, NULL, &_dwProffered);
        // Failure here does not require special handling
    }

    // Make sure that we stop the spinning globe before going away.
    _GlobeAnimation(FALSE, TRUE);

    _fDestroying = TRUE;

    // 99/04/16 #326158 vtan: Loop thru the headers looking for
    // stray HBITMAPs which need to be DeleteObject'd. Don't bother
    // setting it back the header is about to be dumped.
    // NOTE: Make sure this gets executed BEFORE the view gets
    // dumped below in DestoryViewWindow().
    if (IsWindow(_hwndListview))
    {
        HWND hwndHeader = ListView_GetHeader(_hwndListview);
        if (IsWindow(hwndHeader))
        {
            int iHeaderCount = Header_GetItemCount(hwndHeader);
            for (int i = 0; i < iHeaderCount; ++i)
            {
                HDITEM hdi = {0};
                hdi.mask = HDI_BITMAP;
                Header_GetItem(hwndHeader, i, &hdi);
                if (hdi.hbm != NULL)
                    TBOOL(DeleteObject(hdi.hbm));
            }
        }
    }

    _cFrame.HideWebView();

    //
    // Just in case...
    //
    OnDeactivate();

    if (IsWindow(_hwndView))
    {
        //
        // This is a bit lazy implementation, but minimum code.
        //
        RemoveCopyHook();

        // Tell the defview client that this window will be destroyed
        CallCB(SFVM_WINDOWDESTROY, (WPARAM)_hwndView, 0);
    }

    if (IsWindow(_hwndView))
    {
        if (_pScheduler)
        {
            // empty the queue but do NOT wait until it is empty.....
            _pScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE);

            // If there is still a task going, then kill our window later, as to not
            // block the UI thread.
#ifdef DEBUG
            // Stress the feature in debug mode
            if (1)
#else
            if (_GetBackgroundTaskCount(TOID_NULL) > 0)
#endif
            {
                ShowWindow(_hwndView, SW_HIDE);

                // We are NOT passing 'this' defview pointer to the background thread
                // because we do not want the destructor of defview to be called on any
                // thread other than the one it was created on.
                SCHEDULER_AND_HWND *pData = (SCHEDULER_AND_HWND *)LocalAlloc(LPTR, sizeof(*pData));
                if (pData)
                {
                    _pScheduler->AddRef();
                    pData->pScheduler = _pScheduler;
                    pData->hwnd = _hwndView;
                    // We need to keep Browseui loaded because we depend on the CShellTaskScheduler
                    // to be still around when our background task executes. Browseui can be unloaded by COM when
                    // we CoUninit from this thread.
                    if (SHQueueUserWorkItem(CDefView::BackgroundDestroyWindow, pData, 0, NULL, NULL, "browseui.dll", 0))
                        goto exit;
                    else
                    {
                        LocalFree(pData);
                        _pScheduler->Release();
                    }
                }
            }
        }
        DestroyWindow(_hwndView);
    }

exit:
    return S_OK;
}

DWORD CDefView::BackgroundDestroyWindow(void *pvData)
{
    SCHEDULER_AND_HWND *pData = (SCHEDULER_AND_HWND *)pvData;

    // Note: the window coud have been already destroyed before we get here
    // in the case where the frame gets closed down.
    if (IsWindow(pData->hwnd))
    {
        // Remove all tasks
        EmptyBkgrndThread(pData->pScheduler);

        // We need to release before we post to ensure that browseui doesn't get unloaded from under us (pScheduler is
        // in browseui.dll). Browseui can get unloaded when we uninitialize OLE's MTA, even if there are still refs on the DLL.
        pData->pScheduler->Release();
        PostMessage(pData->hwnd, WM_DSV_DELAYED_DESTROYWND, 0, 0);
    }
    else
    {
        pData->pScheduler->Release();
    }

    LocalFree(pData);
    return 0;
}

void CDefView::_MergeViewMenu(HMENU hmenuViewParent, HMENU hmenuMerge)
{
    HMENU hmenuView = _GetMenuFromID(hmenuViewParent, FCIDM_MENU_VIEW);
    if (hmenuView)
    {
#ifdef DEBUG
        DWORD dwValue;
        DWORD cbSize = sizeof(dwValue);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                TEXT("DebugWebView"), NULL, &dwValue, &cbSize)
            && dwValue)
        {
            MENUITEMINFO mi = {0};
            mi.cbSize       = sizeof(mi);
            mi.fMask        = MIIM_TYPE|MIIM_ID;
            mi.fType        = MFT_STRING;
            mi.dwTypeData   = TEXT("Show WebView Content");
            mi.wID          = SFVIDM_DEBUG_WEBVIEW;
            InsertMenuItem(hmenuMerge, -1, MF_BYPOSITION, &mi);
        }
#endif

        //
        // Find the "options" separator in the view menu.
        //
        int index = MenuIndexFromID(hmenuView, FCIDM_MENU_VIEW_SEP_OPTIONS);

        //
        // Here, index is the index of he "optoins" separator if it has;
        // otherwise, it is -1.
        //

        // Add the separator above (in addition to existing one if any).
        InsertMenu(hmenuView, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

        // Then merge our menu between two separators (or right below if only one).
        if (index != -1)
        {
            index++;
        }

        Shell_MergeMenus(hmenuView, hmenuMerge, (UINT)index, 0, (UINT)-1, MM_SUBMENUSHAVEIDS);
    }
}

void CDefView::_SetUpMenus(UINT uState)
{
    //
    // If this is desktop, don't bother creating menu
    //
    if (!_IsDesktop())
    {
        OnDeactivate();

        ASSERT(_hmenuCur == NULL);

        HMENU hMenu = CreateMenu();
        if (hMenu)
        {
            HMENU hMergeMenu;
            OLEMENUGROUPWIDTHS mwidth = { { 0, 0, 0, 0, 0, 0 } };

            _hmenuCur = hMenu;
            _psb->InsertMenusSB(hMenu, &mwidth);

            if (uState == SVUIA_ACTIVATE_FOCUS)
            {
                hMergeMenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_SFV_MAINMERGE));
                if (hMergeMenu)
                {
                    // NOTE: hard coded references to offsets in this menu

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_FILE),
                            GetSubMenu(hMergeMenu, 0), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 1), (UINT)-1, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);

                    _MergeViewMenu(hMenu, GetSubMenu(hMergeMenu, 2));

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_HELP),
                            GetSubMenu(hMergeMenu, 3), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    DestroyMenu(hMergeMenu);
                }

            }
            else
            {
                hMergeMenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_SFV_MAINMERGENF));
                if (hMergeMenu)
                {
                    // NOTE: hard coded references to offsets in this menu

                    // top half of edit menu
                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 0), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    // bottom half of edit menu
                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 1), (UINT)-1, 0, (UINT)-1,
                            MM_SUBMENUSHAVEIDS);

                    // view menu
                    _MergeViewMenu(hMenu, GetSubMenu(hMergeMenu, 2));

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_HELP),
                            GetSubMenu(hMergeMenu, 3), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    DestroyMenu(hMergeMenu);
                }
            }

            // Allow the client to merge its own menus
            UINT indexClient = GetMenuItemCount(hMenu)-1;
            QCMINFO info = { hMenu, indexClient, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST };
            CallCB(SFVM_MERGEMENU, 0, (LPARAM)&info);

            _psb->SetMenuSB(hMenu, NULL, _hwndView);
        }
    }
}

// set up the menus based on our activation state
//
BOOL CDefView::OnActivate(UINT uState)
{
    if (_uState != uState)
    {
        _SetUpMenus(uState);
        _uState = uState;
    }

    return TRUE;
}

BOOL CDefView::OnDeactivate()
{
    if (_hmenuCur || (_uState != SVUIA_DEACTIVATE))
    {
        if (!_IsDesktop())
        {
            ASSERT(_hmenuCur);

            CallCB(SFVM_UNMERGEMENU, 0, (LPARAM)_hmenuCur);

            _psb->SetMenuSB(NULL, NULL, NULL);
            _psb->RemoveMenusSB(_hmenuCur);
            DestroyMenu(_hmenuCur);
            _hmenuCur = NULL;
        }
        _uState = SVUIA_DEACTIVATE;
    }
    return TRUE;
}

void CDefView::_OnMoveWindowToTop(HWND hwnd)
{
    //
    // Let the browser know that this has happened
    //
    VARIANT var;
    var.vt = VT_INT_PTR;
    var.byref = hwnd;

    IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_ONVIEWMOVETOTOP, 0, &var, NULL);
}

//
// This function activates the view window. Note that activating it
// will not change the focus (while setting the focus will activate it).
//
STDMETHODIMP CDefView::UIActivate(UINT uState)
{
    if (SVUIA_DEACTIVATE == uState)
    {
        OnDeactivate();
        ASSERT(_hmenuCur==NULL);
    }
    else
    {
        if (_fIsAsyncDefView)
        {
            // Need to show the defview window for the Async Case only. Showing
            // it earlier causes repaint problems(Bug 275266). Showing the window
            // here for the Sync case also causes problems - when the client
            // creates a Synchronous Defview and then hides it later which gets
            // lost with this SetWindowPos (Bug 355392).

           SetWindowPos(_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
           UpdateWindow(_hwndView);
           _OnMoveWindowToTop(_hwndView);
        }

        if (uState == SVUIA_ACTIVATE_NOFOCUS)
        {
            // we lost focus
            // if in web view and we have valid ole obj (just being paranoid)
            if (!_fCombinedView && _cFrame.IsWebView() && _cFrame._pOleObj)
            {
                _cFrame._UIActivateIO(FALSE, NULL);
            }
        }

        // We may be waiting for ReadyState_Interactive. If requested,
        // we should activate before then...
        //
        // When we boot, the desktop paints ugly white screen for several
        // seconds before it shows the HTML content. This is because: the
        // following code switches the oleobj even before it reaches readystate
        // interactive. For desktop, we skip this here. When the new object
        // reaches readystate interactive, we will show it!
        if (!_IsDesktop())
        {
            _cFrame._SwitchToNewOleObj();

            // NOTE: The browser IP/UI-activates us when we become the
            // current active view!  We want to resize and show windows
            // at that time.  But if we're still waiting for _fCanActivateNow
            // (ie, ReadyStateInteractive), then we need to cache this request
            // and do it later.  NOTE: if Trident caches the focus (done w/ TAB)
            // then we don't need to do anything here...
            //
            if (uState == SVUIA_ACTIVATE_FOCUS)
            {
                _SetFocus();
                // _SetFocus can set _uState without causing our menu to
                // get created and merged.  Clear it here so that OnActivate does the
                // right thing.
                if (!_hmenuCur)
                    _uState = SVUIA_DEACTIVATE;
            }

        }
        // else we are the desktop; do we also need to steal focus?
        else if (uState == SVUIA_ACTIVATE_FOCUS)
        {
            HWND hwnd = GetFocus();
            if (SHIsChildOrSelf(_hwndView, hwnd) != S_OK)
                _SetFocus();
        }

        // OnActivate must follow _SetFocus
        OnActivate(uState);

        ShowHideListView();

        ASSERT(_IsDesktop() || _hmenuCur);

        _cFrame._UpdateZonesStatusPane(NULL);
    }

    return S_OK;
}

STDMETHODIMP CDefView::GetCurrentInfo(LPFOLDERSETTINGS pfs)
{
    *pfs = _fs;
    return S_OK;
}

BOOL IsBackSpace(const MSG *pMsg)
{
    return pMsg && (pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_BACK);
}

extern int IsVK_TABCycler(MSG *pMsg);

//***
// NOTES
//  try ListView->TA first
//  then if that fails try WebView->TA iff it has focus.
//  then if that fails and it's a TAB we do WebView->UIAct
STDMETHODIMP CDefView::TranslateAccelerator(LPMSG pmsg)
{
    // 1st, try ListView
    if (_fInLabelEdit)
    {
        // the second clause stops us passing mouse key clicks to the toolbar if we are in label edit mode...
        if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
        {
            // process this msg so the exploer does not get to translate
            TranslateMessage(pmsg);
            DispatchMessage(pmsg);
            return S_OK;            // we handled it
        }
        else
            return S_FALSE;
    }
    // If we are in classic mode and if it's a tab and the listview doesn't have focus already, receive the tab.
    else if (IsVK_TABCycler(pmsg) && !(_cFrame.IsWebView() || _pDUIView) && (GetFocus() != _hwndListview))
    {
        _SetFocus();
        return S_OK;
    }

    if (GetFocus() == _hwndListview)
    {
        if (::TranslateAccelerator(_hwndView, _hAccel, pmsg))
        {
            // we know we have a normal view, therefore this is
            // the right translate accelerator to use, otherwise the
            // common dialogs will fail to get any accelerated keys.
            return S_OK;
        }
        else if (WM_KEYDOWN == pmsg->message || WM_SYSKEYDOWN == pmsg->message)
        {
            // MSHTML eats these keys for frameset scrolling, but we
            // want to get them to our wndproc . . . translate 'em ourself
            //
            switch (pmsg->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
                // only go through here if alt is not down.
                // don't intercept all alt combinations because
                // alt-enter means something
                // this is for alt-left/right compat with IE
                if (GetAsyncKeyState(VK_MENU) < 0)
                    break;
                // fall through

            case VK_UP:
            case VK_DOWN:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_RETURN:
            case VK_F10:
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
                return S_OK;
            }
        }
    }

    // 1.5th, before we pass it down, see whether shell browser handles it.
    // we do this to make sure that webview has the same accelerator semantics
    // no matter what view(s) are active.
    // note that this is arguably inconsistent w/ the 'pass it to whoever has
    // focus'.
    //
    // however *don't* do this if:
    //   - we're in a dialog (in which case the buttons should come 1st)
    //   (comdlg's shellbrowser xxx::TA impl is broken it always does S_OK)
    //   - it's a TAB (which is always checked last)
    //   - it's a BACKSPACE (we should give the currently active object the first chance).
    //    However, in this case, we should call TranslateAcceleratorSB() AFTER we've tried
    //    calling TranslateAccelerator() on the currently active control (_pActive) in
    //    _cFrame->OnTranslateAccelerator().
    //
    // note: if you muck w/ this code careful not to regress the following:
    //  - ie41:62140: mnemonics broken after folder selected in organize favs
    //  - ie41:62419: TAB activates addr and menu if folder selected in explorer
    if (!_IsCommonDialog() && !IsVK_TABCycler(pmsg) && !IsBackSpace(pmsg))
        if (S_OK == _psb->TranslateAcceleratorSB(pmsg, 0))
            return S_OK;

    BOOL bTabOffLastTridentStop = FALSE;
    BOOL bHadIOFocus = (_cFrame._HasFocusIO() == S_OK);  // Cache this here before the _cFrame.OnTA() call below
    // 2nd, try WebView if it's active
    if (IsVK_TABCycler(pmsg) && _pDUIView)
    {
        if (_pDUIView->Navigate(GetAsyncKeyState(VK_SHIFT) >= 0))
            return S_OK;
    }

    if (_cFrame.IsWebView() && (S_OK == _cFrame.OnTranslateAccelerator(pmsg, &bTabOffLastTridentStop)))
    {
        return S_OK;
    }

    // We've given _pActive->TranslateAccelerator() the first shot in
    // _cFrame.OnTranslateAccelerator, but it failed. Let's try the shell browser.
    if (IsBackSpace(pmsg) && (S_OK == _psb->TranslateAcceleratorSB(pmsg, 0)))
        return S_OK;

    // 3rd, ???
    if (::TranslateAccelerator(_hwndView, _hAccel, pmsg))
        return S_OK;

    // 4th, if it's a TAB, cycle to next guy
    // hack: we fake a bunch of the TAB-activation handshaking
    if (IsVK_TABCycler(pmsg) && _cFrame.IsWebView())
    {
        HRESULT hr;
        BOOL fBack = (GetAsyncKeyState(VK_SHIFT) < 0);

        if (!bHadIOFocus && bTabOffLastTridentStop)
        {
            // We were at the last tab stop in trident when the browser called defview->TA().
            // When we called TA() on trident above, it must've told us that we are tabbing
            // off the last tab stop (bTabOffLastTridentStop). This will leave us not setting focus
            // on anything. But, we have to set focus to something. We can do this by calling TA()
            // on trident again, which will set focus on the first tab stop again.
            return _cFrame.OnTranslateAccelerator(pmsg, &bTabOffLastTridentStop);
        }
        else if (_cFrame._HasFocusIO() == S_OK)
        {
            // ExtView has focus, and doesn't want the TAB.
            // this means we're TABing off of it.
            // no matter what, deactivate it (since we're TABing off).
            // if the view is next in the TAB order, (pseudo-)activate it,
            // and return S_OK since we've handled it.
            // o.w. return S_OK so our parent will activate whoever's next
            // in the TAB order.
            hr = _cFrame._UIActivateIO(FALSE, NULL);
            ASSERT(hr == S_OK);

            // in web view listview already has focus so don't give it again
            // that's not the case with desktop
            if (fBack && _IsDesktop())
            {
                SetFocus(_hwndListview);
                return S_OK;
            }

            return S_FALSE;
        }
        else
        {
            if (!fBack)
            {
                hr = _cFrame._UIActivateIO(TRUE, pmsg);
                ASSERT(hr == S_OK || hr == S_FALSE);
                return hr;
            }
        }
    }

    return S_FALSE;
}

// Description:
//  Regenerates the CDefView's menus.  Used for regaining any menu items
//  which may have been stripped via DeleteMenu(), as occurs for various
//  particular view states.
//
//  Example:  Transitioning to a barricaded view automatically strips out
//  a number of commands from the "View" menu which are not appropriate
//  for the barricaded view.  Thus, on the transition back out of the
//  barricaded view, the menus must be recreated in order to regain
//  any/all the menu items stripped (this is not to say a number of
//  them may not be stripped again if we're just transitioning to
//  another view which doesn't want them in there!).
//
void CDefView::RecreateMenus()
{
    UINT uState = _uState;
    _SetUpMenus(uState);    // Note _SetupMenus() calls OnDeactivate()
    _uState = uState;       // which sets _uState to SVUIA_DEACTIVATE.
}

void CDefView::InitViewMenu(HMENU hmInit)
{
    // Initialize view menu accordingly...
    if (_fBarrierDisplayed)
        _InitViewMenuWhenBarrierDisplayed(hmInit);
    else
        _InitViewMenuWhenBarrierNotDisplayed(hmInit);

    // Remove any extraneous menu separators arising from initialization.
    _SHPrettyMenu(hmInit);
}


// Description:
//  Used to initialize the entries of the "View" menu and its associated
//  submenus whenever a soft barrier is being displayed.
//
// Note:
//  This method is also employed when "Category View" is being used in
//  browsing the Control Panel.
//
void CDefView::_InitViewMenuWhenBarrierDisplayed(HMENU hmenuView)
{
    // If "list view" is not visible (i.e. we're in Category View in the
    // Control Panel, or we're looking at a barricaded folder), we strip
    // out the following stuff from the View menu:
    //
    // Filmstrip
    // Thumbnails
    // Tiles
    // Icons
    // List
    // Details
    // -------------------
    // Arrange Icons By ->
    // -------------------
    // Choose Details...
    // Customize This Folder...

    // Remove menu entries.
    DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBSTRIP,   MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBNAIL,    MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_TILE,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_ICON,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_LIST,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_DETAILS,      MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_MENU_ARRANGE,      MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_COLSETTINGS,  MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_CUSTOMWIZARD, MF_BYCOMMAND);
}

// Description:
//  Used to initialize the entries of the "View" menu and its associated
//  submenus whenever a soft barrier is not being displayed.
//
void CDefView::_InitViewMenuWhenBarrierNotDisplayed(HMENU hmenuView)
{
    DWORD dwListViewFlags = ListView_GetExtendedListViewStyle(_hwndListview);

    UINT uEnabled   = (MF_ENABLED | MF_BYCOMMAND);
    UINT uDisabled  = (MF_GRAYED | MF_BYCOMMAND);
    UINT uChecked   = (MF_CHECKED | MF_BYCOMMAND);
    UINT uUnchecked = (MF_UNCHECKED | MF_BYCOMMAND);

    UINT uAAEnable;     // Auto Arrange
    UINT uAACheck;
    UINT uAGrEnable;    // Align to Grid
    UINT uAGrCheck;

    // Initialize "view" menu entries.
    _InitViewMenuViewsWhenBarrierNotDisplayed(hmenuView);

    // Initialize "Arrange Icons By ->" submenu.
    _InitArrangeMenu(hmenuView);

    // Determine and set appropriate enable state for "Auto Arrange" and "Align to Grid".
    if (_IsPositionedView() && _IsListviewVisible() && !(_fs.ViewMode == FVM_THUMBSTRIP))
        uAAEnable = uAGrEnable = uEnabled;
    else
        uAAEnable = uAGrEnable = uDisabled;
    EnableMenuItem(hmenuView, SFVIDM_ARRANGE_AUTO,      uAAEnable);
    EnableMenuItem(hmenuView, SFVIDM_ARRANGE_AUTOGRID,  uAGrEnable);

    // Determine and set appropriate check state for "Auto Arrange" and "Align to Grid".
    uAACheck = (((uAAEnable == uEnabled) || _fGroupView || (_fs.ViewMode == FVM_THUMBSTRIP)) && _IsAutoArrange())
        ? uChecked
        : uUnchecked;
    uAGrCheck = (((uAGrEnable == uEnabled) || _fGroupView) && (dwListViewFlags & LVS_EX_SNAPTOGRID))
        ? uChecked
        : uUnchecked;
    CheckMenuItem(hmenuView, SFVIDM_ARRANGE_AUTO,       uAACheck);
    CheckMenuItem(hmenuView, SFVIDM_ARRANGE_AUTOGRID,   uAGrCheck);

    // If icons are not being shown (such as can be set on the
    // desktop), disable ALL icon-arrangement related commands.
    if (!_IsListviewVisible())
    {
        HMENU hArrangeSubMenu;
        UINT uID;
        int i = 0;

        // Retrieve "Arrange Icons By ->" submenu.
        hArrangeSubMenu = GetSubMenu(hmenuView, 2);

        // Iterate and disable until we get to "Show Icons".
        while (1)
        {
            uID = GetMenuItemID(hArrangeSubMenu, i);

            if ((uID == SFVIDM_DESKTOPHTML_ICONS) || (uID == (UINT)-1))
                break;
            else
                EnableMenuItem(hArrangeSubMenu, i, MF_GRAYED | MF_BYPOSITION);

            i++;
        }
    }
    else if (!_ShouldShowWebView())
    {
        // If Web View is off, then thumbstrip will never work...
        DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBSTRIP, MF_BYCOMMAND);
    }

    // Remove "Customize This Folder..." if folder is not customizable.
    if (!_CachedIsCustomizable())
    {
        // The Folder Option "Classic style" and the shell restriction WIN95CLASSIC
        // should be the same. (Per ChristoB, otherwise admin's never understand what
        // the restriction means.) Since we want this to change DEFAULTs, and still
        // allow the user to turn on Web View, we don't remove the customize wizard here.
        int iIndex = MenuIndexFromID(hmenuView, SFVIDM_VIEW_CUSTOMWIZARD);
        if (iIndex != -1)
        {
            DeleteMenu(hmenuView, iIndex + 1, MF_BYPOSITION); // Remove Menu seperator
            DeleteMenu(hmenuView, iIndex,     MF_BYPOSITION); // Remove Customize
        }
    }
}

// Description:
//  Initializes the "view" entries on a view menu.  This involves stripping
//  out any "view" entries for unsupported views, and additionally checking
//  of the appropriate "view" entry for the current view.
//
// Note:
//  This method should not be called if a soft barrier is being displayed.
//  Remember that in this case there is no concept of a view, so why
//  would someone be attempting to initialize "view" menu entries.
//
void CDefView::_InitViewMenuViewsWhenBarrierNotDisplayed(HMENU hmenuView)
{
    ASSERT(!_fBarrierDisplayed);

    // Remove menu entries for unsupported views.
    for (UINT fvm = FVM_FIRST; fvm <= FVM_LAST; fvm++)
        if (!_ViewSupported(fvm))
            DeleteMenu(hmenuView, SFVIDM_VIEW_FIRSTVIEW + fvm - FVM_FIRST, MF_BYCOMMAND);

    // "Check" menu entry for current view.
    CheckCurrentViewMenuItem(hmenuView);
}

void CDefView::_GetCBText(UINT_PTR id, UINT uMsgT, UINT uMsgA, UINT uMsgW, LPTSTR psz, UINT cch)
{
    *psz = 0;

    WCHAR szW[MAX_PATH];
    if (SUCCEEDED(CallCB(uMsgW, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, ARRAYSIZE(szW)), (LPARAM)szW)))
        SHUnicodeToTChar(szW, psz, cch);
    else
    {
        char szA[MAX_PATH];
        if (SUCCEEDED(CallCB(uMsgA, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, ARRAYSIZE(szA)), (LPARAM)szA)))
            SHAnsiToTChar(szA, psz, cch);
        else
            CallCB(uMsgT, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, cch), (LPARAM)psz);
    }
}

void CDefView::_GetMenuHelpText(UINT_PTR id, LPTSTR pszText, UINT cchText)
{
    *pszText = 0;

    if ((InRange(id, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST) && _pcmFile) ||
        (InRange(id, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST) && _pcmContextMenuPopup))
    {
        UINT uCMBias = SFVIDM_CONTEXT_FIRST;
        IContextMenu *pcmSel = NULL;

        if (InRange(id, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
        {
            pcmSel = _pcmFile;
            uCMBias = SFVIDM_CONTEXT_FIRST;
        }
        else if (InRange(id, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
        {
            pcmSel = _pcmContextMenuPopup;
            uCMBias = SFVIDM_BACK_CONTEXT_FIRST;
        }

        // First try to get the stardard help string
        pcmSel->GetCommandString(id - uCMBias, GCS_HELPTEXT, NULL,
                        (LPSTR)pszText, cchText);
        if (*pszText == 0)
        {
            // If we didn't get anything, try to grab the ansi version
            CHAR szText[MAX_PATH];
            szText[0] = 0;   // Don't start with garbage in case of failure...
            pcmSel->GetCommandString(id - uCMBias, GCS_HELPTEXTA, NULL,
                        szText, ARRAYSIZE(szText));
            SHAnsiToUnicode(szText, pszText, cchText);
        }
    }
    else if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        _GetCBText(id, SFVM_GETHELPTEXT, SFVM_GETHELPTEXTA, SFVM_GETHELPTEXTW, pszText, cchText);
    }
    else if (InRange(id, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSLAST))
    {
        TCHAR sz[MAX_PATH];
        int idHelp = _fGroupView?IDS_GROUPBY_HELPTEXT:IDS_ARRANGEBY_HELPTEXT;

        LoadString(HINST_THISDLL, idHelp, sz, ARRAYSIZE(sz));
        wsprintf(pszText, sz, _vs.GetColumnName((UINT)id - SFVIDM_GROUPSFIRST));
    }
    else if (InRange(id, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST))
    {
        // Can't think of anything descriptive
    }
    else if (InRange(id, SFVIDM_FIRST, SFVIDM_LAST))
    {
        if ((id == SFVIDM_EDIT_UNDO) && IsUndoAvailable())
        {
            GetUndoText(pszText, cchText, UNDO_STATUSTEXT);
        }
        else
        {
            UINT idHelp = (UINT)id + SFVIDS_MH_FIRST;
            // Unfortunatly, this starts to hit other ranges, so I'm just hard coding this one instead of
            // using the table. If you add more, we need another table method of associating ids and help strings
            if (id == SFVIDM_GROUPBY)
                idHelp = IDS_GROUPBYITEM_HELPTEXT;
            LoadString(HINST_THISDLL, idHelp, pszText, cchText);
        }
    }
}

void CDefView::_GetToolTipText(UINT_PTR id, LPTSTR pszText, UINT cchText)
{
    VDATEINPUTBUF(pszText, TCHAR, cchText);
    *pszText = 0;

    if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        _GetCBText(id, SFVM_GETTOOLTIPTEXT, SFVM_GETTOOLTIPTEXTA, SFVM_GETTOOLTIPTEXTW, pszText, cchText);
    }
    else if (InRange(id, SFVIDM_FIRST, SFVIDM_LAST))
    {
        if (id == SFVIDM_EDIT_UNDO)
        {
            if (IsUndoAvailable())
            {
                GetUndoText(pszText, cchText, UNDO_MENUTEXT);
                return;
            }
        }
        LoadString(HINST_THISDLL, (UINT)(IDS_TT_SFVIDM_FIRST + id), pszText, cchText);
    }
    else
    {
        // REVIEW: This might be an assert situation: missing tooltip info...
        TraceMsg(TF_WARNING, "_GetToolTipText: tip request for unknown object");
    }
}

LRESULT CDefView::_OnMenuSelect(UINT id, UINT mf, HMENU hmenu)
{
    TCHAR szHelpText[80 + 2*MAX_PATH];   // Lots of stack!

    // If we dismissed the edit restore our status bar...
    if (!hmenu && LOWORD(mf)==0xffff)
    {
        _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);
        return 0;
    }

    if (mf & (MF_SYSMENU | MF_SEPARATOR))
        return 0;

    szHelpText[0] = 0;   // in case of failures below

    if (mf & MF_POPUP)
    {
        MENUITEMINFO miiSubMenu;

        miiSubMenu.cbSize = sizeof(MENUITEMINFO);
        miiSubMenu.fMask = MIIM_ID;
        miiSubMenu.cch = 0;     // just in case

        if (!GetMenuItemInfo(hmenu, id, TRUE, &miiSubMenu))
            return 0;

        // Change the parameters to simulate a "normal" menu item
        id = miiSubMenu.wID;
        mf &= ~MF_POPUP;
    }

    _GetMenuHelpText(id, szHelpText, ARRAYSIZE(szHelpText));
    _fBackgroundStatusTextValid = FALSE;
    _psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM)szHelpText, NULL);
    _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 1, 0, NULL);

    return 0;
}

//
// This function dismisses the name edit mode if there is any.
//
// REVIEW: Moving the focus away from the edit window will
//  dismiss the name edit mode. Should we introduce
//  a LV_DISMISSEDIT instead?
//
void CDefView::_DismissEdit()
{
    if (_uState == SVUIA_ACTIVATE_FOCUS)
    {
        ListView_CancelEditLabel(_hwndListview);
    }
}

void CDefView::_OnInitMenu()
{
    // We need to dismiss the edit mode if it is any.
    _DismissEdit();
}

void _RemoveContextMenuItems(HMENU hmInit)
{
    int i;

    for (i = GetMenuItemCount(hmInit) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_ID;
        mii.cch = 0;     // just in case

        if (GetMenuItemInfo(hmInit, i, TRUE, &mii))
        {
            if (InRange(mii.wID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
            {
                TraceMsg(TF_DEFVIEW, "_RemoveContextMenuItems: setting bDeleteItems at %d, %d", i, mii.wID);
                //bDeleteItems = TRUE;
                DeleteMenu(hmInit, i, MF_BYPOSITION);
            }
        }
    }
}

BOOL HasClientItems(HMENU hmenu)
{
    int cItems = GetMenuItemCount(hmenu);
    for (int i = 0; i < cItems; i++)
    {
        UINT id = GetMenuItemID(hmenu, i);

        if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST))
            return TRUE;
    }
    return FALSE;
}

LRESULT CDefView::_OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu)
{
    if (_hmenuCur)
    {
        // This old code makes sure we only switch on the wID for one of our top-level windows
        // The id shouldn't be re-used, so this probably isn't needed.  But it doesn't hurt...
        //
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_SUBMENU | MIIM_ID;
        if (GetMenuItemInfo(_hmenuCur, nIndex, TRUE, &mii) &&  mii.hSubMenu == hmInit)
        {
            switch (mii.wID)
            {
            case FCIDM_MENU_FILE:
                // PERF note: we could avoid the rip-down-and-re-build our File menu
                // if we have a _pcmFile and the _uState is the same as last
                // time and the selection is identical to last time.

                // First of all, clean up our last _pcmFile usage:
                //  remove all the menu items we've added
                //  remove the named separators for defcm
                _RemoveContextMenuItems(hmInit);
                SHUnprepareMenuForDefcm(hmInit, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST);
                IUnknown_SetSite(_pcmFile, NULL);
                ATOMICRELEASE(_pcmFile);

                // Second, handle the focus/nofocus menus
                if (_uState == SVUIA_ACTIVATE_FOCUS)
                {
                    // Enable/disable our menuitems in the "File" pulldown.
                    Def_InitFileCommands(_AttributesFromSel(SFGAO_CANRENAME | SFGAO_CANDELETE | SFGAO_CANLINK | SFGAO_HASPROPSHEET),
                        hmInit, SFVIDM_FIRST, FALSE);

                    // Collect our new _pcmFile context menu
                    IContextMenu* pcmSel = NULL;
                    _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcmSel));

                    IContextMenu* pcmBack = NULL;
                    _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcmBack));

                    IContextMenu* rgpcm[] = { pcmSel, pcmBack };
                    Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), IID_PPV_ARG(IContextMenu, &_pcmFile));

                    if (pcmSel)
                        pcmSel->Release();

                    if (pcmBack)
                        pcmBack->Release();
                }
                else if (_uState == SVUIA_ACTIVATE_NOFOCUS)
                {
                    _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &_pcmFile));
                }

                // Third, merge in the context menu items
                {
                    HRESULT hrPrepare = SHPrepareMenuForDefcm(hmInit, 0, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST);
                    if (_pcmFile)
                    {
                        IUnknown_SetSite(_pcmFile, SAFECAST(this, IShellView2*));
                        _pcmFile->QueryContextMenu(hmInit, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST, CMF_DVFILE | CMF_NODEFAULT);
                    }
                    SHPrettyMenuForDefcm(hmInit, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST, hrPrepare);
                }
                break;

            case FCIDM_MENU_EDIT:
                // Enable/disable menuitems in the "Edit" pulldown.
                Def_InitEditCommands(_AttributesFromSel(SFGAO_CANCOPY | SFGAO_CANMOVE), hmInit, SFVIDM_FIRST, _pdtgtBack, 0);
                _SHPrettyMenu(hmInit);
                break;

            case FCIDM_MENU_VIEW:
                InitViewMenu(hmInit);
                break;
            }
        }
    }

    // Check for a context menu's popup:
    //   assume the first item in the menu identifies the range
    BOOL fHandled;
    _ForwardMenuMessages(GetMenuItemID(hmInit, 0), WM_INITMENUPOPUP, (WPARAM)hmInit, MAKELPARAM(nIndex, fSystemMenu), NULL, &fHandled);

    // Maybe this is the callback's menu then?
    if (!fHandled && _hmenuCur && HasCB() && HasClientItems(hmInit))
    {
        CallCB(SFVM_INITMENUPOPUP, MAKEWPARAM(SFVIDM_CLIENT_FIRST, nIndex), (LPARAM)hmInit);
    }

    return 0;
}

// IShellView::AddPropertySheetPages
STDMETHODIMP CDefView::AddPropertySheetPages(DWORD dwRes, LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    SFVM_PROPPAGE_DATA data;

    ASSERT(IS_VALID_CODE_PTR(lpfn, FNADDPROPSHEETPAGE));

    data.dwReserved = dwRes;
    data.pfn        = lpfn;
    data.lParam     = lParam;

    // Call the callback to add pages
    CallCB(SFVM_ADDPROPERTYPAGES, 0, (LPARAM)&data);

    return S_OK;
}

STDMETHODIMP CDefView::SaveViewState()
{
    HRESULT hr;

    IPropertyBag* ppb;
    hr = IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb));

    if (SUCCEEDED(hr))
    {
        hr = _vs.SaveToPropertyBag(this, ppb);
        ppb->Release();
    }
    else
    {
        IStream *pstm;
        hr = _psb->GetViewStateStream(STGM_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = _vs.SaveToStream(this, pstm);
            pstm->Release();
        }
        else
        {
            // There are cases where we may not save out the complete view state
            // but we do want to save out the column information (like Docfind...)
            if (SUCCEEDED(CallCB(SFVM_GETCOLSAVESTREAM, STGM_READ, (LPARAM)&pstm)))
            {
                hr = _vs.SaveColumns(this, pstm);
                pstm->Release();
            }
        }
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function used to get the storage
//  stream for the default view state of the current DefView.
//  Typically this will be CLSID_ShellFSFolder but can be
//  others.
HRESULT CDefView::_GetStorageStream (DWORD grfMode, IStream* *ppIStream)
{
    *ppIStream = NULL;

    CLSID clsid;
    HRESULT hr = IUnknown_GetClassID(_pshf, &clsid);
    if (SUCCEEDED(hr))
    {
        TCHAR szCLSID[64];      // enough for the CLSID

        if (IsEqualGUID(CLSID_MyDocuments, clsid))
            clsid = CLSID_ShellFSFolder;

        TINT(SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID)));
        *ppIStream = OpenRegStream(HKEY_CURRENT_USER,
                                   REGSTR_PATH_EXPLORER TEXT("\\Streams\\Defaults"), szCLSID, grfMode);
        if (*ppIStream == NULL)
            hr = E_FAIL;
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function called from DefView's
//  implementation of IOleCommandTarget::Exec() which is
//  invoked from CShellBrowser2::SetAsDefFolderSettings().
HRESULT CDefView::_SaveGlobalViewState(void)
{
    IStream *pstm;
    HRESULT hr = _GetStorageStream(STGM_WRITE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = _vs.SaveToStream(this, pstm);
        if (SUCCEEDED(hr))
        {
            hr = (ERROR_SUCCESS == SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\Bags"))) ? S_OK : E_FAIL;
        }
        pstm->Release();
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function called from
//  GetViewState to get the default view state
//  for this class.
HRESULT CDefView::_LoadGlobalViewState(IStream* *ppIStream)
{
    return _GetStorageStream(STGM_READ, ppIStream);
}

//  99/02/09 #226140 vtan: Function used to reset the
//  global view states stored by deleting the key
//  that stores all of them.
HRESULT CDefView::_ResetGlobalViewState(void)
{
    SHDeleteKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams\\Defaults"));

    LONG lRetVal = SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\Bags"));
    return (ERROR_SUCCESS == lRetVal) ? S_OK : E_FAIL;
}

void CDefView::_RestoreAllGhostedFileView()
{
   ListView_SetItemState(_hwndListview, -1, 0, LVIS_CUT);

   UINT c = ListView_GetItemCount(_hwndListview);
   for (UINT i = 0; i < c; i++)
   {
       if (_Attributes(_GetPIDL(i), SFGAO_GHOSTED))
           ListView_SetItemState(_hwndListview, i, LVIS_CUT, LVIS_CUT);
   }
}

HRESULT CDefView::SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt)
{
    HRESULT hr;

    if (NULL == pidlItem)
        hr = _SelectAndPosition(-1, uFlags, ppt);
    else if (ILFindLastID(pidlItem) == pidlItem)
    {
        if (_fInBackgroundGrouping)
        {
            Pidl_Set(&_pidlSelectAndPosition, pidlItem);
            _uSelectAndPositionFlags = uFlags;
            hr = S_OK;
        }
        else
        {
            int iItem = _FindItem(pidlItem, NULL, FALSE);
            if (iItem != -1)
                hr = _SelectAndPosition(iItem, uFlags, ppt);
            else
                hr = S_OK;
        }
    }
    else
    {
        RIP(ILFindLastID(pidlItem) == pidlItem);
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CDefView::_SelectAndPosition(int iItem, UINT uFlags, POINT *ppt)
{
    HRESULT hr = S_OK;  // assume all is good

    // See if we should first deselect everything else
    if (-1 == iItem)
    {
        if (uFlags == SVSI_DESELECTOTHERS)
        {
            ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
            _RestoreAllGhostedFileView();
        }
        else
        {
            hr = E_INVALIDARG;  // I only know how to deselect everything
        }
    }
    else
    {
        if (_pDUIView)
        {
            _fBarrierDisplayed = FALSE;
            _pDUIView->EnableBarrier(FALSE);
        }

        if (uFlags & SVSI_TRANSLATEPT)
        {
            //The caller is asking us to take this point and convert it from screen Coords
            // to the Client of the Listview.

            LVUtil_ScreenToLV(_hwndListview, ppt);
        }

        // set the position first so that the ensure visible scrolls to
        // the new position
        if (ppt)
        {
            _SetItemPosition(iItem, ppt->x, ppt->y);
        }
        else if ((SVSI_POSITIONITEM & uFlags) && _bMouseMenu && _IsPositionedView())
        {
            _SetItemPosition(iItem, _ptDragAnchor.x, _ptDragAnchor.y);
        }

        if ((uFlags & SVSI_EDIT) == SVSI_EDIT)
        {
            // Grab focus if the listview (or any of it's children) don't already have focus
            HWND hwndFocus = GetFocus();
            if (SHIsChildOrSelf(_hwndListview, hwndFocus) != S_OK)
                SetFocus(_hwndListview);

            ListView_EditLabel(_hwndListview, iItem);
        }
        else
        {
            // change the item state
            if (!(uFlags & SVSI_NOSTATECHANGE))
            {
                UINT stateMask = LVIS_SELECTED;
                UINT state = (uFlags & SVSI_SELECT) ? LVIS_SELECTED : 0;
                if (uFlags & SVSI_FOCUSED)
                {
                    state |= LVIS_FOCUSED;
                    stateMask |= LVIS_FOCUSED;
                }

                // See if we should first deselect everything else
                if (uFlags & SVSI_DESELECTOTHERS)
                {
                    ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
                    _RestoreAllGhostedFileView();
                }

                ListView_SetItemState(_hwndListview, iItem, state, stateMask);
            }

            if (uFlags & SVSI_ENSUREVISIBLE)
                ListView_EnsureVisible(_hwndListview, iItem, FALSE);

            // we should only set focus when SVUIA_ACTIVATE_FOCUS
            // bug fixing that might break find target code
            if (uFlags & SVSI_FOCUSED)
                SetFocus(_hwndListview);

            if (uFlags & SVSI_SELECTIONMARK)
                ListView_SetSelectionMark(_hwndListview, iItem);

            // if this is a check select view then set the state of that item accordingly
            if (_fs.fFlags & FWF_CHECKSELECT)
                ListView_SetCheckState(_hwndListview, iItem, (uFlags & SVSI_CHECK));
        }
    }
    return hr;
}

STDMETHODIMP CDefView::SelectItem(int iItem, DWORD uFlags)
{
    return _SelectAndPosition(iItem, uFlags, NULL);
}

typedef struct {
    LPITEMIDLIST    pidl;
    UINT            uFlagsSelect;
} DELAY_SEL_ITEM;

STDMETHODIMP CDefView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
    // if the listview isn't shown, there's nothing to select yet.
    // Likewise if we are in the process of being created we should defer.
    if (!_IsListviewVisible())
    {
        if (!_hdsaSelect)
        {
            _hdsaSelect = DSA_Create(sizeof(DELAY_SEL_ITEM), 4);
            if (!_hdsaSelect)
                return E_OUTOFMEMORY;
        }

        HRESULT hr = E_OUTOFMEMORY;
        DELAY_SEL_ITEM dvdsi;
        dvdsi.pidl = ILClone(pidlItem);
        if (dvdsi.pidl)
        {
            dvdsi.uFlagsSelect = uFlags;
            if (DSA_AppendItem(_hdsaSelect, &dvdsi) == DSA_ERR)
                ILFree(dvdsi.pidl);
            else
                hr = S_OK;
        }
        return hr;
    }

    return SelectAndPositionItem(pidlItem, uFlags, NULL);
}

// IFolderView

STDMETHODIMP CDefView::GetCurrentViewMode(UINT *pViewMode)
{
    *pViewMode = _fs.ViewMode;
    return S_OK;
}

STDMETHODIMP CDefView::SetCurrentViewMode(UINT uViewMode)
{
    ASSERT(FVM_FIRST <= uViewMode && uViewMode <= FVM_LAST);

    if (uViewMode != _vs._ViewMode)
        _ClearItemPositions();

    return _SwitchToViewFVM(uViewMode);
}

STDMETHODIMP CDefView::GetFolder(REFIID riid, void **ppv)
{
    if (_pshf)
        return _pshf->QueryInterface(riid, ppv);

    *ppv = NULL;
    return  E_NOINTERFACE;
}

STDMETHODIMP CDefView::Item(int iItemIndex, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidl = _GetPIDL(iItemIndex);
    if (pidl)
    {
        hr = SHILClone(pidl, ppidl);
    }
    return hr;
}

STDMETHODIMP CDefView::ItemCount(UINT uFlags, int *pcItems)
{
    *pcItems = _GetItemArray(NULL, NULL, uFlags);
    return S_OK;
}

HRESULT CDefView::_EnumThings(UINT uWhat, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = _GetItemObjects(&apidl, uWhat, &cItems);
    if (SUCCEEDED(hr))
    {
        hr = CreateIEnumIDListOnIDLists(apidl, cItems, ppenum);
        LocalFree(apidl);
    }
    return hr;
}

STDMETHODIMP CDefView::Items(UINT uWhat, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (IID_IEnumIDList == riid)
    {
        hr = _EnumThings(uWhat, (IEnumIDList**)ppv); 
    }
    else if (IID_IDataObject == riid)
    {
        if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_SELECTION)
        {
            if (_pSelectionShellItemArray)
            {
                hr = _pSelectionShellItemArray->BindToHandler(NULL, BHID_DataObject, riid, ppv);
            }
        }
        else
        {
            hr = _GetUIObjectFromItem(riid, ppv, uWhat, FALSE);
        }
    }
    return hr;        
}


// inverse of ::SelectItem(..., SVSI_SELECTIONMARK)

STDMETHODIMP CDefView::GetSelectionMarkedItem(int *piItem)
{
    *piItem = ListView_GetSelectionMark(_hwndListview);
    return (-1 == *piItem) ? S_FALSE : S_OK;
}

STDMETHODIMP CDefView::GetFocusedItem(int *piItem)
{
    *piItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
    return (-1 == *piItem) ? S_FALSE : S_OK;
}

BOOL CDefView::_GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt)
{
    int i = _FindItem(pidl, NULL, FALSE);
    if (i != -1)
        return ListView_GetItemPosition(_hwndListview, i, ppt);
    return FALSE;
}

STDMETHODIMP CDefView::GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt)
{
    return _GetItemPosition(pidl, ppt) ? S_OK : E_FAIL;
}

STDMETHODIMP CDefView::GetSpacing(POINT* ppt)
{
    if (ppt)
    {
        if (_fs.ViewMode != FVM_TILE)
        {
            BOOL fSmall;

            switch (_fs.ViewMode)
            {
            case FVM_SMALLICON:
            case FVM_LIST:
            case FVM_DETAILS:
                fSmall = TRUE;
                break;

            case FVM_ICON:
            case FVM_THUMBNAIL:
            case FVM_THUMBSTRIP:
            default:
                fSmall = FALSE;
                break;
            }

            DWORD dwSize = ListView_GetItemSpacing(_hwndListview, fSmall);
            ppt->x = GET_X_LPARAM(dwSize);
            ppt->y = GET_Y_LPARAM(dwSize);
        }
        else
        {
            LVTILEVIEWINFO tvi;
            tvi.cbSize = sizeof(tvi);
            tvi.dwMask = LVTVIM_TILESIZE;

            if (ListView_GetTileViewInfo(_hwndListview, &tvi))
            {
                ppt->x = tvi.sizeTile.cx;
                ppt->y = tvi.sizeTile.cy;
            }
            else
            {
                // guess.
                ppt->x = 216;
                ppt->y = 56;
            }
        }
    }

    return _IsPositionedView() ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::GetDefaultSpacing(POINT* ppt)
{
    ASSERT(ppt);

    if (_fs.ViewMode != FVM_THUMBNAIL && _fs.ViewMode != FVM_THUMBSTRIP && _fs.ViewMode != FVM_TILE)
    {
        DWORD dwSize = ListView_GetItemSpacing(_hwndListview, FALSE);
        ppt->x = GET_X_LPARAM(dwSize);
        ppt->y = GET_Y_LPARAM(dwSize);
    }
    else
    {
        // Bug #163528 (edwardp 8/15/00) Should get this data from comctl.
        ppt->x = GetSystemMetrics(SM_CXICONSPACING);
        ppt->y = GetSystemMetrics(SM_CYICONSPACING);
    }

    return S_OK;
}

// IShellFolderView
STDMETHODIMP CDefView::GetAutoArrange()
{
    return _IsAutoArrange() ? S_OK : S_FALSE;
}

void CDefView::_ClearPendingSelectedItems()
{
    if (_hdsaSelect)
    {
        HDSA hdsa = _hdsaSelect;
        _hdsaSelect = NULL;
        int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            DELAY_SEL_ITEM *pdvdsi = (DELAY_SEL_ITEM*)DSA_GetItemPtr(hdsa, i);
            if (pdvdsi)
                ILFree(pdvdsi->pidl);
        }
        DSA_Destroy(hdsa);
    }
}

// Call this whenever the state changes such that SelectItem (above)
void CDefView::SelectPendingSelectedItems()
{
    ASSERT(_IsListviewVisible());
    if (_hdsaSelect)
    {

        //
        //  Listview quirk:  If the following conditions are met..
        //
        //      1. WM_SETREDRAW(FALSE) or ShowWindow(SW_HIDE)
        //      2. Listview has never painted yet
        //      3. LVS_LIST
        //
        //  then ListView_LGetRects doesn't work.  And consequently,
        //  everything that relies on known item rectangles (e.g.,
        //  LVM_ENSUREVISIBLE, sent by below SelectItem call) doesn't work.
        //
        //  (1) ShowHideListView did a ShowWindow(SW_SHOW), but
        //  FillDone does a WM_SETREDRAW(FALSE).
        //  check _fListviewRedraw to see if condition (1) is met
        //
        //  (2) We just showed the listview, if it's the first time,
        //  then Condition (2) has been met
        //
        //  But wait, there's also a listview bug where SetWindowPos
        //  doesn't trigger it into thinking that the window is visible.
        //  So you have to send a manual WM_SHOWWINDOW, too.
        //
        //  So if we detect that condition (3) is also met, we temporarily
        //  enable redraw (thereby cancelling condition 1), tell listview
        //  "No really, you're visible" -- this tickles it into computing
        //  column stuff -- then turn redraw back off.
        //

        if (_fListviewRedraw &&
            (GetWindowStyle(_hwndListview) & LVS_TYPEMASK) == LVS_LIST)
        {
            // Evil hack (fix comctl32.dll v6.0 someday NTRAID#182448)
            SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)TRUE, 0);
            SendMessage(_hwndListview, WM_SHOWWINDOW, TRUE, 0);
            SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)FALSE, 0);
        }

        // End of listview hack workaround


        HDSA hdsa = _hdsaSelect;
        _hdsaSelect = NULL;
        int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            DELAY_SEL_ITEM *pdvdsi = (DELAY_SEL_ITEM*)DSA_GetItemPtr(hdsa, i);
            if (pdvdsi)
            {
                SelectItem(pdvdsi->pidl, pdvdsi->uFlagsSelect);
                ILFree(pdvdsi->pidl);
            }
        }
        DSA_Destroy(hdsa);
    }
}

HRESULT CDefView::_GetIPersistHistoryObject(IPersistHistory **ppph)
{
    // See to see if specific folder wants to handle it...
    HRESULT hr = CallCB(SFVM_GETIPERSISTHISTORY, 0, (LPARAM)ppph);
    if (FAILED(hr))
    {
        // Here we can decide if we want to default should be to always save
        // the default defview stuff or not.  For now we will assume that we do
        if (ppph)
        {
            CDefViewPersistHistory *pdvph = new CDefViewPersistHistory();
            if (pdvph)
            {
                hr = pdvph->QueryInterface(IID_PPV_ARG(IPersistHistory, ppph));
                pdvph->Release();
            }
            else
            {
                *ppph = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
            hr = S_FALSE;   // still succeeds but can detect on other side if desired...
    }
    return hr;
}

STDMETHODIMP CDefView::GetItemObject(UINT uWhat, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    switch (uWhat & SVGIO_TYPE_MASK)
    {
    case SVGIO_BACKGROUND:
        if (IsEqualIID(riid, IID_IContextMenu) ||
            IsEqualIID(riid, IID_IContextMenu2) ||
            IsEqualIID(riid, IID_IContextMenu3))
        {
            hr = _CBackgrndMenu_CreateInstance(riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IDispatch) ||
                 IsEqualIID(riid, IID_IDefViewScript))
        {
            if (!_pauto)
            {
                // try to create an Instance of the Shell disipatch for folder views...
                IDispatch *pdisp;
                if (SUCCEEDED(SHExtCoCreateInstance(NULL, &CLSID_ShellFolderView, NULL,
                                                  IID_PPV_ARG(IDispatch, &pdisp))))
                {
                    SetAutomationObject(pdisp); // we hold a ref here
                    ASSERT(_pauto);    // the above grabbed this
                    pdisp->Release();
                }
            }

            // return the IDispath interface.
            if (_pauto)
                hr = _pauto->QueryInterface(riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IPersistHistory))
        {
            // See if the folder wants a chance at this.  The main
            // case for this is the search results windows.
            hr = _GetIPersistHistoryObject((IPersistHistory**)ppv);
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite((IUnknown*)*ppv, SAFECAST(this, IShellView2*));
            }
        }
        else if (_cFrame.IsWebView() && _cFrame._pOleObj)
        {
            hr = _cFrame._pOleObj->QueryInterface(riid, ppv);
        }
        break;

    case SVGIO_ALLVIEW:
        if (_hwndStatic)
        {
            DECLAREWAITCURSOR;

            SetWaitCursor();

            do
            {
                // If _hwndStatic is around, we must be filling the
                // view in a background thread, so we will peek for
                // messages to it (so SendMessages will get through)
                // and dispatch only _hwndStatic messages so we get the
                // animation effect.
                // Note there is no timeout, so this could take
                // a while on a slow link, but there really isn't
                // much else I can do

                MSG msg;

                // Since _hwndStatic can only be destroyed on a WM_DSV_BACKGROUNDENUMDONE
                // message, we should never get a RIP
                // We also need to allow WM_DSV_FILELISTFILLDONE since it can destroy _hwndStatic
                if (PeekMessage(&msg, _hwndView, WM_DSV_BACKGROUNDENUMDONE,
                                WM_DSV_BACKGROUNDENUMDONE, PM_REMOVE) ||
                    PeekMessage(&msg, _hwndView, WM_DSV_FILELISTFILLDONE,
                                WM_DSV_FILELISTFILLDONE, PM_REMOVE)   ||
                    PeekMessage(&msg, _hwndView, WM_DSV_GROUPINGDONE,
                                WM_DSV_GROUPINGDONE, PM_REMOVE)       ||
                    PeekMessage(&msg, _hwndStatic, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } while (_hwndStatic);

            ResetWaitCursor();
        }

        // Fall through

    case SVGIO_SELECTION:
        hr = _GetUIObjectFromItem(riid, ppv, uWhat, TRUE);
        break;
    }

    return hr;
}

HRESULT CDefView::PreCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool)
{
    ASSERT(hwndContaining != NULL);
    ASSERT(_FindPendingInfotip(hwndContaining, uToolID, NULL, FALSE) == S_FALSE);

    PENDING_INFOTIP *ppi = new PENDING_INFOTIP;
    HRESULT hr;
    if (ppi)
    {
        ppi->hwndContaining = hwndContaining;
        ppi->uToolID = uToolID;
        ppi->rectTool = *prectTool;

        if (_tlistPendingInfotips.AddTail(ppi))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            delete ppi;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDefView::PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam)
{
    ASSERT(hwndContaining != NULL);

    TOOLINFO *pti = new TOOLINFO;
    HRESULT hr;
    if (pti)
    {
        pti->cbSize = sizeof(TOOLINFO);
        pti->uFlags = 0;
        pti->hwnd = hwndContaining;
        pti->uId = uToolID;
      //pti->rect = initialized in _OnPostCreateInfotip()
        pti->hinst = hinst;
        pti->lpszText = (LPWSTR)uInfotipID;
        pti->lParam = lParam;

        hr = PostMessage(_hwndView, WM_DSV_POSTCREATEINFOTIP, (WPARAM)pti, lParam) ? S_OK : E_FAIL;

        if (FAILED(hr))
        {
            delete pti;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDefView::PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPCWSTR pwszInfotip, LPARAM lParam)
{
    HRESULT hr = SHStrDup(pwszInfotip, (LPWSTR *)&pwszInfotip);
    if (SUCCEEDED(hr))
    {
        hr = PostCreateInfotip(hwndContaining, uToolID, NULL, (UINT_PTR)pwszInfotip, lParam);
        if (FAILED(hr))
        {
            CoTaskMemFree((LPVOID)pwszInfotip);
        }
    }
    return hr;
}

HRESULT CDefView::_OnPostCreateInfotip(TOOLINFO *pti, LPARAM lParam)
{
    HRESULT hr = _FindPendingInfotip(pti->hwnd, pti->uId, &pti->rect, TRUE);
    if (hr == S_OK)
    {
        hr = SendMessage(_hwndInfotip, TTM_ADDTOOL, 0, (LPARAM)pti) ? S_OK : E_FAIL;
    }
    _OnPostCreateInfotipCleanup(pti);
    return hr;
}

HRESULT CDefView::_OnPostCreateInfotipCleanup(TOOLINFO *pti)
{
    if (!pti->hinst)
        CoTaskMemFree(pti->lpszText);
    delete pti;
    return S_OK;
}

HRESULT CDefView::_FindPendingInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, BOOL bRemoveAndDestroy)
{
    CLISTPOS posNext = _tlistPendingInfotips.GetHeadPosition();
    CLISTPOS posCurrent;
    PENDING_INFOTIP *ppi;
    HRESULT hr = S_FALSE;

    while (posNext)
    {
        posCurrent = posNext;
        ppi = _tlistPendingInfotips.GetNext(posNext);
    
        if (ppi->hwndContaining == hwndContaining && ppi->uToolID == uToolID)
        {
            if (bRemoveAndDestroy)
            {
                if (prectTool)
                {
                    // Use prectTool as out param.
                    *prectTool = ppi->rectTool;
                }
                _tlistPendingInfotips.RemoveAt(posCurrent);
                delete ppi;
            }
            else
            {
                if (prectTool)
                {
                    // Use prectTool as in param.
                    ppi->rectTool = *prectTool;
                }
            }
            hr = S_OK;
            break;
        }
    }

    // Post Contition -- callers expect only S_OK or S_FALSE.
    ASSERT(hr == S_OK || hr == S_FALSE);

    return hr;
}

HRESULT CDefView::CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam)
{
    ASSERT(hwndContaining != NULL);

    // CreateInfotip() is not for use with PreCreateInfotip()/PostCreateInfotip().
    ASSERT(_FindPendingInfotip(hwndContaining, uToolID, NULL, FALSE) == S_FALSE);

    TOOLINFO ti;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = 0;
    ti.hwnd = hwndContaining;
    ti.uId = uToolID;
    ti.rect = *prectTool;
    ti.hinst = hinst;
    ti.lpszText = (LPWSTR)uInfotipID;
    ti.lParam = lParam;

    return SendMessage(_hwndInfotip, TTM_ADDTOOL, 0, (LPARAM)&ti) ? S_OK : E_FAIL;
}

HRESULT CDefView::CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, LPCWSTR pwszInfotip, LPARAM lParam)
{
    return CreateInfotip(hwndContaining, uToolID, prectTool, NULL, (UINT_PTR)pwszInfotip, lParam);
}

HRESULT CDefView::DestroyInfotip(HWND hwndContaining, UINT_PTR uToolID)
{
    ASSERT(hwndContaining != NULL);

    if (_FindPendingInfotip(hwndContaining, uToolID, NULL, TRUE) == S_FALSE)
    {
        TOOLINFO ti;

        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = hwndContaining;
        ti.uId = uToolID;

        SendMessage(_hwndInfotip, TTM_DELTOOL, 0, (LPARAM)&ti);
    }

    return S_OK;
}

// Note:
//  Coordinates in prectTool must be relative to the hwnd in hwndContaining.
//
HRESULT CDefView::RepositionInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool)
{
    if (_FindPendingInfotip(hwndContaining, uToolID, prectTool, FALSE) == S_FALSE)
    {
        TOOLINFO ti;

        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = hwndContaining;
        ti.uId = uToolID;
        ti.rect = *prectTool;

        SendMessage(_hwndInfotip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
    }

    return S_OK;
}

HRESULT CDefView::RelayInfotipMessage(HWND hwndFrom, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;

    if (_hwndInfotip)
    {
        MSG msg;
        msg.hwnd    = hwndFrom;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;
        SendMessage(_hwndInfotip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CDefView::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefView, IShellView2),                    // IID_IShellView2
        QITABENTMULTI(CDefView, IShellView, IShellView2),   // IID_IShellView
        QITABENT(CDefView, IViewObject),                    // IID_IViewObject
        QITABENT(CDefView, IDropTarget),                    // IID_IDropTarget
        QITABENT(CDefView, IShellFolderView),               // IID_IShellFolderView
        QITABENT(CDefView, IFolderView),                    // IID_IFolderView
        QITABENT(CDefView, IOleCommandTarget),              // IID_IOleCommandTarget
        QITABENT(CDefView, IServiceProvider),               // IID_IServiceProvider
        QITABENT(CDefView, IDefViewFrame3),                 // IID_IDefViewFrame
        QITABENT(CDefView, IDefViewFrame),                  // IID_IDefViewFrame
        QITABENT(CDefView, IDocViewSite),                   // IID_IDocViewSite
        QITABENT(CDefView, IInternetSecurityMgrSite),       // IID_IInternetSecurityMgrSite
        QITABENT(CDefView, IObjectWithSite),                // IID_IObjectWithSite
        QITABENT(CDefView, IPersistIDList),                 // IID_IPersistIDList
        QITABENT(CDefView, IDVGetEnum),                     // IID_IDVGetEnum
        QITABENT(CDefView, IContextMenuSite),               // IID_IContextMenuSite
        QITABENT(CDefView, IDefViewSafety),                 // IID_IDefViewSafety
        QITABENT(CDefView, IUICommandTarget),               // IID_IUICommandTarget
        { 0 }
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        // special case this one as it simply casts this...
        if (IsEqualIID(riid, IID_CDefView))
        {
            *ppvObj = (void *)this;
            AddRef();
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP_(ULONG) CDefView::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDefView::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

//===========================================================================
// Constructor of CDefView class
//===========================================================================

CDefView::CDefView(IShellFolder *psf, IShellFolderViewCB *psfvcb,
                   IShellView *psvOuter) : _cRef(1), _cCallback(psfvcb)
{
    psf->QueryInterface(IID_PPV_ARG(IShellFolder, &_pshf));
    psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_pshf2));

    LPITEMIDLIST pidlFull = _GetViewPidl();
    if (pidlFull)
    {
        LPCITEMIDLIST pidlRelative;
        if (SUCCEEDED(SHBindToFolderIDListParent(NULL, pidlFull, IID_PPV_ARG(IShellFolder, &_pshfParent), &pidlRelative)))
        {
            _pidlRelative = ILClone(pidlRelative);
            _pshfParent->QueryInterface(IID_PPV_ARG(IShellFolder2, &_pshf2Parent));
        }
        ILFree(pidlFull);
    }

    CallCB(SFVM_FOLDERSETTINGSFLAGS, 0, (LPARAM)&_fs.fFlags);

    _vs.InitWithDefaults(this);

    _rgbBackColor = CLR_INVALID;

    _sizeThumbnail.cx = -1; // non init state

    _iIncrementCat = 1;

    _wvLayout.dwLayout = -1; // an invalid value

    //  NOTE we dont AddRef() psvOuter
    //  it has a ref on us
    _psvOuter = psvOuter;

    // the client needs this info to be able to do anything with us,
    // so set it REALLY early on in the creation process
    IUnknown_SetSite(_cCallback.GetSFVCB(), SAFECAST(this, IShellFolderView*));

    for (int i = 0; i < ARRAYSIZE(_crCustomColors); i++)
        _crCustomColors[i] = CLR_MYINVALID;

    _UpdateRegFlags();

    IDLData_InitializeClipboardFormats();

    if (SUCCEEDED(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellTaskScheduler2, &_pScheduler))))
    {
        // init a set a 60 second timeout
        _pScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, DEFVIEW_THREAD_IDLE_TIMEOUT);
    }

    // Catch unexpected STACK allocations which would break us.
    ASSERT(_hwndInfotip == NULL);
}

STDAPI SHCreateShellFolderView(const SFV_CREATE* pcsfv, IShellView ** ppsv)
{
    *ppsv = NULL;
    HRESULT hr = E_INVALIDARG;

    if (pcsfv && sizeof(*pcsfv) == pcsfv->cbSize)
    {
        CDefView *pdsv = new CDefView(pcsfv->pshf, pcsfv->psfvcb, pcsfv->psvOuter);
        if (pdsv)
        {
            *ppsv = pdsv;
            hr = S_OK;
        }
    }
    return hr;
}

void CDVDropTarget::LeaveAndReleaseData()
{
    DragLeave();
}

void CDVDropTarget::ReleaseDataObject()
{
    ATOMICRELEASE(_pdtobj);
}

void CDVDropTarget::ReleaseCurrentDropTarget()
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);
    if (_pdtgtCur)
    {
        _pdtgtCur->DragLeave();
        ATOMICRELEASE(_pdtgtCur);
    }
    pdv->_itemCur = -2;
    // WARNING: Never touch pdv->itemOver in this function.
}

HRESULT CDVDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    // Don't allow a drop from our webview content to ourself!
    _fIgnoreSource = FALSE;
    IOleCommandTarget* pct;
    if (pdv->_cFrame.IsWebView() && SUCCEEDED(pdv->_cFrame.GetCommandTarget(&pct)))
    {
        VARIANTARG v = {0};

        if (SUCCEEDED(pct->Exec(&CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &v)))
        {
            pct->Release();
            if (v.lVal)
            {
                *pdwEffect = DROPEFFECT_NONE;
                _fIgnoreSource = TRUE;
                return S_OK;
            }
        }
    }

    g_fDraggingOverSource = FALSE;

    _grfKeyState = grfKeyState;

    ASSERT(_pdtgtCur == NULL);
    // don't really need to do this, but this sets the target state
    ReleaseCurrentDropTarget();
    _itemOver = -2;

    //
    // In case of Desktop, we should not lock the enter screen.
    //
    HWND hwndLock = pdv->_IsDesktop() ? pdv->_hwndView : pdv->_hwndMain;
    GetWindowRect(hwndLock, &_rcLockWindow);

    DAD_DragEnterEx3(hwndLock, ptl, pdtobj);

    DAD_InitScrollData(&_asd);

    _ptLast.x = _ptLast.y = 0x7fffffff; // put bogus value to force redraw

    return S_OK;
}

#define DVAE_BEFORE 0x01
#define DVAE_AFTER  0x02

// this MUST set pdwEffect to 0 or DROPEFFECT_MOVE if it's a default drag drop
// in the same window

void CDefView::_AlterEffect(DWORD grfKeyState, DWORD *pdwEffect, UINT uFlags)
{
    g_fDraggingOverSource = FALSE;

    if (_IsDropOnSource(NULL))
    {
        if (_IsPositionedView())
        {
            // If this is default drag & drop, enable move.
            if (uFlags & DVAE_AFTER)
            {
                if ((grfKeyState & (MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_ALT)) == MK_LBUTTON)
                {
                    *pdwEffect = DROPEFFECT_MOVE;
                    g_fDraggingOverSource = TRUE;
                }
                else if (grfKeyState & MK_RBUTTON)
                {
                    *pdwEffect |= DROPEFFECT_MOVE;
                }
            }
        }
        else
        {
            if (uFlags & DVAE_BEFORE)
            {
                // No. Disable move.
                *pdwEffect &= ~DROPEFFECT_MOVE;

                // default drag & drop, disable all.
                if ((grfKeyState & (MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_ALT)) == MK_LBUTTON)
                {
                    *pdwEffect = 0;
                }
            }
        }
    }
}

HRESULT CDVDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);
    HRESULT hr = S_OK;
    DWORD dwEffectScroll = 0;
    DWORD dwEffectOut = 0;
    DWORD dwEffectOutToCache;
    BOOL fSameImage = FALSE;

    if (_fIgnoreSource)
    {
        // for parity with win2k behavior, we need to bail out from DragOver
        // if we hit the SHDVID_ISDRAGSOURCE in DragEnter.
        // this is so when you have a stretched background in active desktop and
        // show desktop icons is off, when you drag the background image around
        // you'll get DROPEFFECT_NONE instead of a bad DROPEFFECT_COPY.
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    POINT pt = {ptl.x, ptl.y};       // in screen coords

    RECT rc;
    GetWindowRect(pdv->_hwndListview, &rc);
    BOOL fInRect = PtInRect(&rc, pt);

    ScreenToClient(pdv->_hwndListview, &pt);    // now in client

    // assume coords of our window match listview
    if (DAD_AutoScroll(pdv->_hwndListview, &_asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    // hilight an item, or unhilight all items (DropTarget returns -1)
    int itemNew = fInRect ? pdv->_HitTest(&pt, TRUE) : -1;

    // If we are dragging over on a different item, get its IDropTarget
    // interface or adjust itemNew to -1.
    if (_itemOver != itemNew)
    {
        IDropTarget *pdtgtNew = NULL;

        _dwLastTime = GetTickCount();     // keep track for auto-expanding the tree

        _itemOver = itemNew;

        // Avoid dropping onto drag source objects.
        if ((itemNew != -1) && pdv->_bDragSource)
        {
            UINT uState = ListView_GetItemState(pdv->_hwndListview, itemNew, LVIS_SELECTED);
            if (uState & LVIS_SELECTED)
                itemNew = -1;
        }

        // If we are dragging over an item, try to get its IDropTarget.
        if (itemNew != -1)
        {
            // We are dragging over an item.
            LPCITEMIDLIST apidl[1] = { pdv->_GetPIDL(itemNew) };
            if (apidl[0])
            {
                pdv->_pshf->GetUIObjectOf(pdv->_hwndMain, 1, apidl, IID_PPV_ARG_NULL(IDropTarget, &pdtgtNew));
                ASSERT(itemNew != pdv->_itemCur);    // MUST not be the same
            }

            if (pdtgtNew == NULL)
            {
                // If the item is not a drop target, don't hightlight it
                // treat it as transparent.
                itemNew = -1;
            }
        }

        // If the new target is different from the current one, switch it.
        if (pdv->_itemCur != itemNew)
        {
            // Release previous drop target, if any.
            ReleaseCurrentDropTarget();
            ASSERT(_pdtgtCur==NULL);

            // Update pdv->_itemCur which indicates the current target.
            //  (Note that it might be different from _itemOver).
            pdv->_itemCur = itemNew;

            // If we are dragging over the background or over non-sink item,
            // get the drop target for the folder.
            if (itemNew == -1)
            {
                // We are dragging over the background, this can be NULL
                ASSERT(pdtgtNew == NULL);
                _pdtgtCur = pdv->_pdtgtBack;
                if (_pdtgtCur)
                    _pdtgtCur->AddRef();
            }
            else
            {
                ASSERT(pdtgtNew);
                _pdtgtCur = pdtgtNew;
            }

            // Hilight the sink item (itemNew != -1) or unhilight all (-1).
            LVUtil_DragSelectItem(pdv->_hwndListview, itemNew);

            // Call IDropTarget::DragEnter of the target object.
            if (_pdtgtCur)
            {
                // pdwEffect is in/out parameter.
                dwEffectOut = *pdwEffect;       // pdwEffect in

                // Special case if we are dragging within a source window
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE);
                hr = _pdtgtCur->DragEnter(_pdtobj, grfKeyState, ptl, &dwEffectOut);
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_AFTER);
            }
            else
            {
                ASSERT(dwEffectOut==0);
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE | DVAE_AFTER);
            }

            TraceMsg(TF_DEFVIEW, "CDV::DragOver dwEIn=%x, dwEOut=%x", *pdwEffect, dwEffectOut);
        }
        else
        {
            ASSERT(pdtgtNew == NULL);   // It must be NULL
            goto NoChange;
        }

        // Every time we're over a new item, record this information so we can handle the insertmark.
        _fItemOverNotADropTarget = (itemNew == -1);
    }
    else
    {
NoChange:
        if (_itemOver != -1)
        {
            DWORD dwNow = GetTickCount();

            if ((dwNow - _dwLastTime) >= 1000)
            {
                _dwLastTime = dwNow;
                // DAD_ShowDragImage(FALSE);
                // OpenItem(pdv, _itemOver);
                // DAD_ShowDragImage(TRUE);
            }
        }

        //
        // No change in the selection. We assume that *pdwEffect stays
        // the same during the same drag-loop as long as the key state doesn't change.
        //
        if ((_grfKeyState != grfKeyState) && _pdtgtCur)
        {
            // Note that pdwEffect is in/out parameter.
            dwEffectOut = *pdwEffect;   // pdwEffect in
            // Special case if we are dragging within a source window
            pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE);
            hr = _pdtgtCur->DragOver(grfKeyState, ptl, &dwEffectOut);
            pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_AFTER);
        }
        else
        {
            // Same item and same key state. Use the previous dwEffectOut.
            dwEffectOut = _dwEffectOut;
            fSameImage = TRUE;
            hr = S_OK;
        }
    }

    // Cache the calculated dwEffectOut (BEFORE making local modifications below).
    dwEffectOutToCache = dwEffectOut;

    // Activate/deactivate insertmark, if appropriate.
    LVINSERTMARK lvim = { sizeof(LVINSERTMARK), 0, -1, 0 };
    if (_fItemOverNotADropTarget)
    {
        // Only do the insertion mark stuff if we're in a view mode that makes sense for these:
        if (pdv->_IsAutoArrange() || (pdv->_fs.fFlags & FWF_SNAPTOGRID))
        {
            ListView_InsertMarkHitTest(pdv->_hwndListview, &pt, &lvim);

            if (pdv->_bDragSource && pdv->_IsAutoArrange() && (lvim.iItem == -1))
            {
                // a "move" drop here won't do anything so set the effect appropriately
                if (dwEffectOut & DROPEFFECT_MOVE)
                {
                    // fall back to "copy" drop effect (if supported)
                    if (*pdwEffect & DROPEFFECT_COPY)
                    {
                        dwEffectOut |= DROPEFFECT_COPY;
                    }
                    // fall back to "link" drop effect (if supported)
                    else if (*pdwEffect & DROPEFFECT_LINK)
                    {
                        dwEffectOut |= DROPEFFECT_LINK;
                    }
                    // fall back to no drop effect

                    dwEffectOut &= ~DROPEFFECT_MOVE;
                }

                // NOTE: a DROPEFFECT_MOVE still comes through the ::Drop for a left-drop...
                // we might want to remember that we're exclududing move (_bDragSourceDropOnDragItem)
            }
        }
    }
    ListView_SetInsertMark(pdv->_hwndListview, &lvim);

    _grfKeyState = grfKeyState;         // store these for the next Drop
    _dwEffectOut = dwEffectOutToCache;  // and DragOver

    //  OLE does not call IDropTarget::Drop if we return something
    //  valid. We force OLE call it by returning DROPEFFECT_SCROLL.
    if (g_fDraggingOverSource)
        dwEffectScroll = DROPEFFECT_SCROLL;

    *pdwEffect = dwEffectOut | dwEffectScroll;  // pdwEffect out

    if (!(fSameImage && pt.x == _ptLast.x && pt.y == _ptLast.y))
    {
        HWND hwndLock = pdv->_IsDesktop() ? pdv->_hwndView : pdv->_hwndMain;
        DAD_DragMoveEx(hwndLock, ptl);
        _ptLast.x = ptl.x;
        _ptLast.y = ptl.y;
    }

    return hr;
}

HRESULT CDVDropTarget::DragLeave()
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    //
    // Make it possible to call it more than necessary.
    //
    if (_pdtobj)
    {
        TraceMsg(TF_DEFVIEW, "CDVDropTarget::DragLeave");

        ReleaseCurrentDropTarget();
        _itemOver = -2;
        ReleaseDataObject();

        DAD_DragLeave();
        LVUtil_DragSelectItem(pdv->_hwndListview, -1);
    }

    g_fDraggingOverSource = FALSE;

    ASSERT(_pdtgtCur == NULL);
    ASSERT(_pdtobj == NULL);

    LVINSERTMARK lvim = { sizeof(LVINSERTMARK), 0, -1, 0 }; // clear insert mark (-1)
    ListView_SetInsertMark(pdv->_hwndListview, &lvim);

    return S_OK;
}

HRESULT CDVDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    pdv->_ptDrop.x = pt.x;
    pdv->_ptDrop.y = pt.y;

    ScreenToClient(pdv->_hwndListview, &pdv->_ptDrop);

    //
    // handle moves within the same window here.
    // depend on _AlterEffect forcing in DROPEFFECT_MOVE and only
    // dropeffect move when drag in same window
    //
    // Notes: We need to use _grfKeyState instead of grfKeyState
    //  to see if the left mouse was used or not during dragging.
    //
    pdv->_AlterEffect(_grfKeyState, pdwEffect, DVAE_BEFORE | DVAE_AFTER);

    if ((_grfKeyState & MK_LBUTTON) && (*pdwEffect == DROPEFFECT_MOVE) &&
        (pdv->_IsDropOnSource(NULL)))
    {
        // This means we are left-dropping on ourselves, so we just move
        // the icons.
        DAD_DragLeave();

        pdv->_SameViewMoveIcons();

        SetForegroundWindow(pdv->_hwndMain);

        ASSERT(pdv->_bDropAnchor == FALSE);

        *pdwEffect = 0;  // the underlying objects didn't 'move' anywhere

        ReleaseCurrentDropTarget();
    }
    else if (_pdtgtCur)
    {
        // use this local because if pdtgtCur::Drop does a UnlockWindow
        // then hits an error and needs to put up a dialog,
        // we could get re-entered and clobber the defview's pdtgtCur
        IDropTarget *pdtgtCur = _pdtgtCur;
        _pdtgtCur = NULL;

        //
        // HACK ALERT!!!!
        //
        //  If we don't call LVUtil_DragEnd here, we'll be able to leave
        // dragged icons visible when the menu is displayed. However, because
        // we are calling IDropTarget::Drop() which may create some modeless
        // dialog box or something, we can not ensure the locked state of
        // the list view -- LockWindowUpdate() can lock only one window at
        // a time. Therefore, we skip this call only if the pdtgtCur
        // is a subclass of CIDLDropTarget, assuming its Drop calls
        // CDefView::DragEnd (or CIDLDropTarget_DragDropMenu) appropriately.
        //
        pdv->_bDropAnchor = TRUE;

        if (!DoesDropTargetSupportDAD(pdtgtCur))
        {
            // This will hide the dragged image.
            DAD_DragLeave();

            // reset the drag image list so that the user
            // can start another drag&drop while we are in this
            // Drop() member function call.
            DAD_SetDragImage(NULL, NULL);
        }

        // Special case if we are dragging within a source window
        pdv->_AlterEffect(grfKeyState, pdwEffect, DVAE_BEFORE | DVAE_AFTER);

        IUnknown_SetSite(pdtgtCur, SAFECAST(pdv, IShellView2*));

        pdtgtCur->Drop(pdtobj, grfKeyState, pt, pdwEffect);

        IUnknown_SetSite(pdtgtCur, NULL);

        pdtgtCur->Release();

        DAD_DragLeave();

        pdv->_bDropAnchor = FALSE;
    }
    else
    {
        // We come here if Drop is called without DragMove (with DragEnter).
        *pdwEffect = 0;
    }

    DragLeave();    // DoDragDrop does not call DragLeave() after Drop()

    return S_OK;
}

//
// HACK ALERT!!! (see CDVDropTarget::Drop as well)
//
//  All the subclasses of CIDLDropTarget MUST call this function from
// within its Drop() member function. Calling CIDLDropTarget_DragDropMenu()
// is sufficient because it calls CDefView::UnlockWindow.
//

// lego... make this a #define in defview.h
#ifndef DefView_UnlockWindow
void DefView_UnlockWindow()
{
    DAD_DragLeave();
}
#endif

BOOL CDefView::_IsBkDropTarget(IDropTarget *pdtg)
{
    BOOL fRet = FALSE;

    if (_bContextMenuMode)
    {
        if (ListView_GetSelectedCount(_hwndListview) == 0)
        {
            fRet = TRUE;
        }
    }

    POINT pt;
    if (!fRet)
    {
        if (_GetInsertPoint(&pt)) // If there is an insert point, then the background is the drop target.
            return TRUE;

        if (_GetDropPoint(&pt))
        {
            // The Drop point is returned in internal listview coordinates
            // space, so we need to convert it back to client space
            // before we call this function...

            LVUtil_LVToClient(_hwndListview, &pt);
            if (_HitTest(&pt) == -1)
            {
                fRet = TRUE;
            }
        }
    }
    return fRet;
}

// IShellFolderView::Rearrange

STDMETHODIMP CDefView::Rearrange(LPARAM lParamSort)
{
    return _OnRearrange(lParamSort, TRUE);
}

// end user initiated arrange (click on col header, etc)

HRESULT CDefView::_OnRearrange(LPARAM lParamSort, BOOL fAllowToggle)
{
    DECLAREWAITCURSOR;

    _vs._iLastColumnClick = (int) _vs._lParamSort;
    _vs._lParamSort = lParamSort;

    // toggle the direction of the sort if on the same column
    if (fAllowToggle && !_IsPositionedView() && _vs._iLastColumnClick == (int) lParamSort)
        _vs._iDirection = -_vs._iDirection;
    else
        _vs._iDirection = 1;

    SetWaitCursor();

    HRESULT hr = _Sort();

    // reset to the state that no items have been moved if currently in a positioned mode
    // so auto-arraning works.

    if (_IsPositionedView())
    {
        _ClearItemPositions();
    }

    ResetWaitCursor();

    return hr;
}

STDMETHODIMP CDefView::ArrangeGrid()
{
    _OnCommand(NULL, GET_WM_COMMAND_MPS(SFVIDM_ARRANGE_GRID, 0, 0));
    return S_OK;
}

STDMETHODIMP CDefView::AutoArrange()
{
    _OnCommand(NULL, GET_WM_COMMAND_MPS(SFVIDM_ARRANGE_AUTO, 0, 0));
    return S_OK;
}

STDMETHODIMP CDefView::GetArrangeParam(LPARAM *plParamSort)
{
    *plParamSort = _vs._lParamSort;
    return S_OK;
}

STDMETHODIMP CDefView::AddObject(LPITEMIDLIST pidl, UINT *puItem)
{
    LPITEMIDLIST pidlCopy = ILClone(pidl);

    if (pidlCopy)
    {
        *puItem = _AddObject(pidlCopy);  // takes pidl ownership.
    }
    else
    {
        *puItem = (UINT)-1;
    }
    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CDefView::GetObjectCount(UINT *puCount)
{
    *puCount = ListView_GetItemCount(_hwndListview);
    return S_OK;
}

STDMETHODIMP CDefView::SetObjectCount(UINT uCount, UINT dwFlags)
{
    // Mask over to the flags that map directly accross
    DWORD dw = dwFlags & SFVSOC_NOSCROLL;
    UINT uCountOld = 0;

    GetObjectCount(&uCountOld);

    if ((dwFlags & SFVSOC_INVALIDATE_ALL) == 0)
        dw |= LVSICF_NOINVALIDATEALL; // gross transform

    HRESULT hr = (HRESULT)SendMessage(_hwndListview, LVM_SETITEMCOUNT, (WPARAM)uCount, (LPARAM)dw);

    // Notify automation if we're going from 0 to 1 or more items
    if (!uCountOld && uCount)
    {
        _PostNoItemStateChangedMessage();
    }

    return hr;
}

STDMETHODIMP CDefView::GetObject(LPITEMIDLIST *ppidl, UINT uItem)
{
    // Worse hack, if -42 then return our own pidl...
    if (uItem == (UINT)-42)
    {
        *ppidl = (LPITEMIDLIST)_pidlMonitor;
        return *ppidl ? S_OK : E_UNEXPECTED;
    }

    // Hack, if item is -2, this implies return the focused item
    if (uItem == (UINT)-2)
        uItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);

    *ppidl = (LPITEMIDLIST)_GetPIDL(uItem); // cast due to bad interface def
    return *ppidl ? S_OK : E_UNEXPECTED;
}

STDMETHODIMP CDefView::RemoveObject(LPITEMIDLIST pidl, UINT *puItem)
{
    *puItem = _RemoveObject(pidl, FALSE);

    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::UpdateObject(LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem)
{
    *puItem = _UpdateObject(pidlOld, pidlNew);
    return (int)(*puItem) >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::RefreshObject(LPITEMIDLIST pidl, UINT *puItem)
{
    *puItem = _RefreshObject(&pidl);
    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::SetRedraw(BOOL bRedraw)
{
    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)bRedraw, 0);
    return S_OK;
}

STDMETHODIMP CDefView::GetSelectedObjects(LPCITEMIDLIST **pppidl, UINT *puItems)
{
    return _GetItemObjects(pppidl, SVGIO_SELECTION, puItems);
}

STDMETHODIMP CDefView::GetSelectedCount(UINT *puSelected)
{
    *puSelected = ListView_GetSelectedCount(_hwndListview);
    return S_OK;
}

BOOL CDefView::_IsDropOnSource(IDropTarget *pdtgt)
{
    // context menu paste (_bMouseMenu shows context menu, cut stuff shows source)
    if (_bMouseMenu && _bHaveCutStuff)
    {
        int iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
        if (iItem == -1)
            return TRUE;
    }

    if (_itemCur != -1 || !_bDragSource)
    {
        // We did not drag onto the background of the source
        return FALSE;
    }

    return TRUE;
}

STDMETHODIMP CDefView::IsDropOnSource(IDropTarget *pDropTarget)
{
    return _IsDropOnSource(pDropTarget) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::MoveIcons(IDataObject *pdtobj)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDefView::GetDropPoint(POINT *ppt)
{
    return _GetDropPoint(ppt) ? S_OK : S_FALSE;
}


STDMETHODIMP CDefView::GetDragPoint(POINT *ppt)
{
    return _GetDragPoint(ppt) ? S_OK : S_FALSE;
}


STDMETHODIMP CDefView::SetItemPos(LPCITEMIDLIST pidl, POINT *ppt)
{
    SFV_SETITEMPOS sip;
    sip.pidl = pidl;
    sip.pt = *ppt;

    _SetItemPos(&sip);
    return S_OK;
}

STDMETHODIMP CDefView::IsBkDropTarget(IDropTarget *pDropTarget)
{
    return _IsBkDropTarget(pDropTarget) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::SetClipboard(BOOL bMove)
{
    _OnSetClipboard(bMove);   // do this always, even if not current active view

    return S_OK;
}

// defcm.cpp asks us to setup the points of the currently selected objects
// into the data object on Copy/Cut commands
STDMETHODIMP CDefView::SetPoints(IDataObject *pdtobj)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = GetSelectedObjects(&apidl, &cItems);
    if (SUCCEEDED(hr) && cItems)
    {
        _SetPoints(cItems, apidl, pdtobj);
        LocalFree((HLOCAL)apidl);
    }
    return hr;
}

STDMETHODIMP CDefView::GetItemSpacing(ITEMSPACING *pSpacing)
{
    return _GetItemSpacing(pSpacing) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB)
{
    *ppOldCB = NULL;

    return _cCallback.SetCallback(pNewCB, ppOldCB);
}

const UINT c_rgiSelectFlags[][2] =
{
    { SFVS_SELECT_ALLITEMS, SFVIDM_SELECT_ALL },
    { SFVS_SELECT_NONE,     SFVIDM_DESELECT_ALL },
    { SFVS_SELECT_INVERT,   SFVIDM_SELECT_INVERT }
};

STDMETHODIMP CDefView::Select(UINT dwFlags)
{
    // translate the flag into the menu ID
    for (int i = 0; i < ARRAYSIZE(c_rgiSelectFlags); i++)
    {
        if (c_rgiSelectFlags[i][0] == dwFlags)
        {
            return (HRESULT)_OnCommand(NULL, c_rgiSelectFlags[i][1], 0);
        }
    }

    return E_INVALIDARG;
}

STDMETHODIMP CDefView::QuerySupport(UINT * pdwSupport)
{
    // *pdwSupport is an in/out param, we leave the out == in
    return S_OK;    // DefView supports all the operations...
}

STDMETHODIMP CDefView::SetAutomationObject(IDispatch *pdisp)
{
    // release back pointers
    IUnknown_SetOwner(_pauto, NULL);
    IUnknown_SetSite(_pauto, NULL);

    IUnknown_Set((IUnknown **)&_pauto, pdisp); // hold or free _pauto

    // this connects the automation object to our view, so it can implement
    // stuff like "SelectedItems"
    IUnknown_SetOwner(_pauto, SAFECAST(this, IShellFolderView *));

    // use the browser as the site so OM related QueryService calls will find
    // the browser above us as the place to do security checks instead of defivew
    // this is stuff that depends on the zone of the caller as the security check
    IUnknown_SetSite(_pauto, _psb);

    return S_OK;
}

STDMETHODIMP CDefView::SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags)
{
    for (UINT i = 0; i < cidl; i++)
        SelectAndPositionItem(apidl[i], dwFlags, apt ? &apt[i] : NULL);

    return S_OK;
}



// -------------- auto scroll stuff --------------

BOOL _AddTimeSample(AUTO_SCROLL_DATA *pad, const POINT *ppt, DWORD dwTime)
{
    pad->pts[pad->iNextSample] = *ppt;
    pad->dwTimes[pad->iNextSample] = dwTime;

    pad->iNextSample++;

    if (pad->iNextSample == ARRAYSIZE(pad->pts))
        pad->bFull = TRUE;

    pad->iNextSample = pad->iNextSample % ARRAYSIZE(pad->pts);

    return pad->bFull;
}

#ifdef DEBUG
// for debugging, verify we have good averages
DWORD g_time = 0;
int g_distance = 0;
#endif

int _CurrentVelocity(AUTO_SCROLL_DATA *pad)
{
    int i, iStart, iNext;
    int dx, dy, distance;
    DWORD time;

    ASSERT(pad->bFull);

    distance = 0;
    time = 1;   // avoid div by zero

    i = iStart = pad->iNextSample % ARRAYSIZE(pad->pts);

    do {
        iNext = (i + 1) % ARRAYSIZE(pad->pts);

        dx = abs(pad->pts[i].x - pad->pts[iNext].x);
        dy = abs(pad->pts[i].y - pad->pts[iNext].y);
        distance += (dx + dy);
        time += abs(pad->dwTimes[i] - pad->dwTimes[iNext]);

        i = iNext;

    } while (i != iStart);

#ifdef DEBUG
    g_time = time;
    g_distance = distance;
#endif

    // scale this so we don't loose accuracy
    return (distance * 1024) / time;
}



// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right

BOOL CanScroll(HWND hwnd, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(si);
    si.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    GetScrollInfo(hwnd, code, &si);

    if (bDown)
    {
        if (si.nPage)
            si.nMax -= si.nPage - 1;
        return si.nPos < si.nMax;
    }
    else
    {
        return si.nPos > si.nMin;
    }
}

#define DSD_NONE                0x0000
#define DSD_UP                  0x0001
#define DSD_DOWN                0x0002
#define DSD_LEFT                0x0004
#define DSD_RIGHT               0x0008

DWORD DAD_DragScrollDirection(HWND hwnd, const POINT *ppt)
{
    RECT rcOuter, rc;
    DWORD dwDSD = DSD_NONE;
    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);

#define g_cxVScroll GetSystemMetrics(SM_CXVSCROLL)
#define g_cyHScroll GetSystemMetrics(SM_CYHSCROLL)

    GetClientRect(hwnd, &rc);

    if (dwStyle & WS_HSCROLL)
        rc.bottom -= g_cyHScroll;

    if (dwStyle & WS_VSCROLL)
        rc.right -= g_cxVScroll;

    // the explorer forwards us drag/drop things outside of our client area
    // so we need to explictly test for that before we do things
    //
    rcOuter = rc;
    InflateRect(&rcOuter, g_cxSmIcon, g_cySmIcon);

    InflateRect(&rc, -g_cxIcon, -g_cyIcon);

    if (!PtInRect(&rc, *ppt) && PtInRect(&rcOuter, *ppt))
    {
        // Yep - can we scroll?
        if (dwStyle & WS_HSCROLL)
        {
            if (ppt->x < rc.left)
            {
                if (CanScroll(hwnd, SB_HORZ, FALSE))
                    dwDSD |= DSD_LEFT;
            }
            else if (ppt->x > rc.right)
            {
                if (CanScroll(hwnd, SB_HORZ, TRUE))
                    dwDSD |= DSD_RIGHT;
            }
        }
        if (dwStyle & WS_VSCROLL)
        {
            if (ppt->y < rc.top)
            {
                if (CanScroll(hwnd, SB_VERT, FALSE))
                    dwDSD |= DSD_UP;
            }
            else if (ppt->y > rc.bottom)
            {
                if (CanScroll(hwnd, SB_VERT, TRUE))
                    dwDSD |= DSD_DOWN;
            }
        }
    }
    return dwDSD;
}


#define SCROLL_FREQUENCY        (GetDoubleClickTime()/2)        // 1 line scroll every 1/4 second
#define MIN_SCROLL_VELOCITY     20      // scaled mouse velocity

BOOL WINAPI DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow)
{
    // first time we've been called, init our state
    int v;
    DWORD dwTimeNow = GetTickCount();
    DWORD dwDSD = DAD_DragScrollDirection(hwnd, pptNow);

    if (!_AddTimeSample(pad, pptNow, dwTimeNow))
        return dwDSD;

    v = _CurrentVelocity(pad);

    if (v <= MIN_SCROLL_VELOCITY)
    {
        // Nope, do some scrolling.
        if ((dwTimeNow - pad->dwLastScroll) < SCROLL_FREQUENCY)
            dwDSD = 0;

        if (dwDSD & DSD_UP)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_DOWN)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }
        if (dwDSD & DSD_LEFT)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_RIGHT)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }

        DAD_ShowDragImage(TRUE);

        if (dwDSD)
        {
            TraceMsg(TF_DEFVIEW, "v=%d", v);
            pad->dwLastScroll = dwTimeNow;
        }
    }
    return dwDSD;       // bits set if in scroll region
}

// warning: global data holding COM objects that may span apartment boundaries
// be very careful

HDSA g_hdsaDefViewCopyHook = NULL;

typedef struct {
    HWND hwndView;
    CDefView *pdv;
} DVCOPYHOOK;

void CDefView::AddCopyHook()
{
    ENTERCRITICAL;
    if (!g_hdsaDefViewCopyHook)
    {
        g_hdsaDefViewCopyHook = DSA_Create(sizeof(DVCOPYHOOK), 4);
        TraceMsg(TF_DEFVIEW, "AddCopyHook creating the dsa");
    }

    if (g_hdsaDefViewCopyHook)
    {
        DVCOPYHOOK dvch = { _hwndView, this };
        ASSERT(dvch.hwndView);
        if (DSA_AppendItem(g_hdsaDefViewCopyHook, &dvch)!=-1)
        {
            AddRef();
            TraceMsg(TF_DEFVIEW, "AddCopyHook successfully added (total=%d)",
                     DSA_GetItemCount(g_hdsaDefViewCopyHook));
        }
    }
    LEAVECRITICAL;
}

int CDefView::FindCopyHook(BOOL fRemoveInvalid)
{
    ASSERTCRITICAL;

    if (g_hdsaDefViewCopyHook)
    {
        int item = DSA_GetItemCount(g_hdsaDefViewCopyHook);
        while (--item >= 0)
        {
            const DVCOPYHOOK *pdvch = (const DVCOPYHOOK *)DSA_GetItemPtr(g_hdsaDefViewCopyHook, item);
            if (pdvch)
            {
                if (fRemoveInvalid)
                {
                    if (!IsWindow(pdvch->hwndView))
                    {
                        TraceMsg(TF_WARNING, "FindCopyHook: found a invalid element, removing...");
                        DSA_DeleteItem(g_hdsaDefViewCopyHook, item);
                        continue;
                    }
                }

                if ((pdvch->hwndView == _hwndView) && (pdvch->pdv == this))
                {
                    return item;
                }
            }
            else
            {
                ASSERT(0);
            }
        }

    }
    return -1;  // not found
}

void CDefView::RemoveCopyHook()
{
    IShellView *psv = NULL;
    ENTERCRITICAL;
    if (g_hdsaDefViewCopyHook)
    {
        int item = FindCopyHook(TRUE);
        if (item != -1)
        {
            DVCOPYHOOK *pdvch = (DVCOPYHOOK *)DSA_GetItemPtr(g_hdsaDefViewCopyHook, item);
            psv = pdvch->pdv;
            TraceMsg(TF_DEFVIEW, "RemoveCopyHook removing an element");
            DSA_DeleteItem(g_hdsaDefViewCopyHook, item);

            //
            // If this is the last guy, destroy it.
            //
            if (DSA_GetItemCount(g_hdsaDefViewCopyHook) == 0)
            {
                TraceMsg(TF_DEFVIEW, "RemoveCopyHook destroying hdsa (no element)");
                DSA_Destroy(g_hdsaDefViewCopyHook);
                g_hdsaDefViewCopyHook = NULL;
            }
        }
    }
    LEAVECRITICAL;

    //
    // Release it outside the critical section.
    //
    ATOMICRELEASE(psv);
}

STDAPI_(UINT) DefView_CopyHook(const COPYHOOKINFO *pchi)
{
    UINT idRet = IDYES;

    if (g_hdsaDefViewCopyHook==NULL)
    {
        return idRet;
    }

    for (int item = 0; ; item++)
    {
        DVCOPYHOOK dvch = { NULL, NULL };

        // We should minimize this critical section (and must not
        // call pfnCallBack which may popup UI!).

        ENTERCRITICAL;
        if (g_hdsaDefViewCopyHook && DSA_GetItem(g_hdsaDefViewCopyHook, item, &dvch))
        {
            dvch.pdv->AddRef();
        }
        LEAVECRITICAL;

        if (dvch.pdv)
        {
            if (IsWindow(dvch.hwndView))
            {
                HRESULT hr = dvch.pdv->CallCB(SFVM_NOTIFYCOPYHOOK, 0, (LPARAM)pchi);

                ATOMICRELEASE(dvch.pdv);
                if (SUCCEEDED(hr) && (hr != S_OK))
                {
                    idRet = HRESULT_CODE(hr);
                    ASSERT(idRet==IDYES || idRet==IDCANCEL || idRet==IDNO);
                    break;
                }
                item++;
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "DefView_CopyHook list has an invalid element");
                ATOMICRELEASE(dvch.pdv);
            }
        }
        else
        {
            break;      // no more item.
        }
    }

    return idRet;
}

// IOleCommandTarget stuff - just forward to the webview
STDMETHODIMP CDefView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    BOOL fQSCalled = FALSE;

    if (_cFrame.IsWebView())
    {
        IOleCommandTarget* pct;

        if (SUCCEEDED(_cFrame.GetCommandTarget(&pct)))
        {
            hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
            fQSCalled = SUCCEEDED(hr);
            pct->Release();
        }
    }

    if (pguidCmdGroup == NULL)
    {
        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (UINT i = 0; i < cCmds; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_REFRESH:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                // don't disable if the webview has already answered
                if (!fQSCalled)
                {
                    rgCmds[i].cmdf = 0;
                }
                break;
            }
        }
    }
    else if (IsEqualGUID(_clsid, *pguidCmdGroup))
    {
        if (pcmdtext)
        {
            switch (pcmdtext->cmdtextf)
            {
            case OLECMDTEXTF_NAME:
                // It's a query for the button tooltip text.
                ASSERT(cCmds == 1);
                _GetToolTipText(rgCmds[0].cmdID, pcmdtext->rgwz, pcmdtext->cwBuf);

                // ensure NULL termination
                pcmdtext->rgwz[pcmdtext->cwBuf - 1] = 0;
                pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz);

                hr = S_OK;
                break;

            default:
                hr = E_FAIL;
                break;
            }
        }
        else
        {
            DWORD dwAttr = _AttributesFromSel(SFGAO_RELEVANT);

            for (UINT i = 0; i < cCmds; i++)
            {
                if (_ShouldEnableToolbarButton(rgCmds[i].cmdID, dwAttr, -1))
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                else
                    rgCmds[i].cmdf = 0;
            }

            hr = S_OK;
        }
    }

    return hr;
}
STDMETHODIMP CDefView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr; 

    //  Hold a ref to ourselves on Exec.  In the camera name space if the view context menu is up when the camera
    //  is unplugged, explorer faults because the view is torn down and the context menu exec tries to unwind
    //  after defview is gone.  This holds a ref on defview while in exec so defview doesn't dissappear.
    //
    AddRef();
    hr = _Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    Release();

    return hr;
}

HRESULT CDefView::_Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _fAllowSearchingWindow = TRUE; // this exec typically comes from a user action (F5, Refresh)
            if (FAILED(_ReloadContent()))
            {
               //This invalidation deletes the WebView and also avoid
               //unpainted areas in ListView  areas whose paint messages
               //are eaten by the visible WebView
               InvalidateRect(_hwndView, NULL, TRUE);
            }
            hr = S_OK;
            break;
        }
    }
    else if (IsEqualGUID(CGID_DefView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case DVID_SETASDEFAULT:

//  99/02/05 #226140 vtan: Exec command issued from
//  CShellBrowser2::_SaveDefViewDefaultFolderSettings()
//  when user clicks "Like Current Folder" in folder
//  options "View" tab.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                hr = _SaveGlobalViewState();
                break;
            case DVID_RESETDEFAULT:

//  99/02/05 #226140 vtan: Exec command issued from
//  CShellBrowser2::_ResetDefViewDefaultFolderSettings()
//  when user clicks "Reset All Folders" in folder
//  options "View" tab.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                hr = _ResetGlobalViewState();
                break;
            default:
                break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_CANACTIVATENOW:
            return _fCanActivateNow ? S_OK : S_FALSE;

        // NOTE: for a long time IOleCommandTarget was implemented
        // BUT it wasn't in the QI! At this late stage of the game
        // I'll be paranoid and not forward everything down to the
        // webview. We'll just pick off CANACTIVATENOW...
        //
        default:
            return OLECMDERR_E_UNKNOWNGROUP;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBCMDID_GETPANE:
            V_I4(pvarargOut) = PANE_NONE;
            CallCB(SFVM_GETPANE, nCmdexecopt, (LPARAM)&V_I4(pvarargOut));
            return S_OK;

        case SBCMDID_MIXEDZONE:
            if (pvarargOut)
                return _cFrame._GetCurrentZone(NULL, pvarargOut);
            break;

        default:
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        // handle the ones coming FROM itbar:
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            pvarargOut->vt = VT_BYREF;
            pvarargOut->byref = (void *)_pbtn;
            *pvarargIn->plVal = _cTotalButtons;
            return S_OK;

        case ETCMDID_RELOADBUTTONS:
            MergeToolBar(TRUE);
            return S_OK;
        }
    }
    else if (IsEqualGUID(_clsid, *pguidCmdGroup))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_OTHER, nCmdID);

        DFVCMDDATA cd;
        cd.pva = pvarargIn;
        cd.hwnd = _hwndMain;
        cd.nCmdIDTranslated = 0;
        _OnCommand(NULL, nCmdID, (LPARAM)&cd);
    }

    // no need to pass OLECMDID_REFRESH on to the webview, as we
    // just nuked and replaced the webview above -- a super refresh of sorts.

    if (_cFrame.IsWebView() && hr != S_OK)
    {
        //  Do not pass IDM_PARSECOMPLETE back to MSHTML.  This will cause them to load mshtmled.dll
        //  unecessarily for webview which is a significant performance hit.
        if (!(pguidCmdGroup && IsEqualGUID(CGID_MSHTML, *pguidCmdGroup) && (nCmdID == IDM_PARSECOMPLETE)))
        {
            IOleCommandTarget* pct;
            if (SUCCEEDED(_cFrame.GetCommandTarget(&pct)))
            {
                hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                pct->Release();
            }
        }
    }

    return hr;
}


void CDefView::_ShowAndActivate()
{
    // Can't call SetFocus because it rips focus away from such nice
    // UI elements like the TREE pane...
    // UIActivate will steal focus only if _uState is SVUIA_ACTIVATE_FOCUS
    UIActivate(_uState);
}

// IDefViewFrame (available only through QueryService from sfvext!)
//
HRESULT CDefView::GetShellFolder(IShellFolder **ppsf)
{
    *ppsf = _pshf;
    if (*ppsf)
        _pshf->AddRef();

    return *ppsf ? S_OK : E_FAIL;
}


// IDefViewFrame3
//
HRESULT CDefView::GetWindowLV(HWND * phwnd)
{
    if (!_IsDesktop())
    {
        if (!_fGetWindowLV)
        {
            _fGetWindowLV = TRUE;
            // Caller will call ShowHideListView for us

            *phwnd = _hwndListview;
        }
        TraceMsg(TF_DEFVIEW, "GetWindowLV - TAKEN");
        return S_OK;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}

HRESULT CDefView::OnResizeListView()
{
    _AutoAutoArrange(0);
    return S_OK;
}

HRESULT CDefView::ReleaseWindowLV()
{
    _fGetWindowLV = FALSE;
    WndSize(_hwndView);             // Make sure we resize _hwndListview
    ShowHideListView();
    return S_OK;
}

HRESULT CDefView::DoRename()
{
    return HandleRename(NULL);
}

// IServiceProvider

STDMETHODIMP CDefView::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    if (guidService == SID_DefView) // private service ID
    {
        // DefViewOCs request this interface
        if (riid != IID_IDefViewFrame || !_IsDesktop())
            hr = QueryInterface(riid, ppv);
    }
    else if (guidService == SID_ShellTaskScheduler)
    {
        if (_pScheduler)
        {
            hr = _pScheduler->QueryInterface(riid, ppv);
        }
    }
    else if ((guidService == SID_SContextMenuSite) ||
             (guidService == SID_SFolderView))      // documented service ID
    {
       hr = QueryInterface(riid, ppv);
    }
    else if (guidService == SID_ShellFolderViewCB)  // access to the view callback object
    {
        IShellFolderViewCB * psfvcb = _cCallback.GetSFVCB();
        if (psfvcb)
            hr = psfvcb->QueryInterface(riid, ppv);
    }
    else if (guidService == SID_WebViewObject)
    {
        if (_cFrame.IsWebView())
        {
            if (_cFrame._pOleObj)
            {
                //
                // We hit this codepath while navigating away (while saving history),
                // so there should not be any pending _cFrame._pOleObjNew as this
                // view is going to be destroyed.
                //
                ASSERTMSG(!_cFrame._pOleObjNew, "Ambiguous Oleobj while peristing trident history in webview");
                hr = _cFrame._pOleObj->QueryInterface(riid, ppv);
            }
            else if (_cFrame._pOleObjNew)
            {
                //
                // We hit this codepath if we are navigating to the view (while loading history),
                // we have not yet called _cFrame._SwitchToNewOleObj(), so we'll use
                // the pending oleobj as CDefViewPersistHistory::LoadHistory()
                // expects to get the right IPersistHistory interface from it.
                //
                hr = _cFrame._pOleObjNew->QueryInterface(riid, ppv);
            }
        }
    }
    else if (guidService == SID_SProgressUI)
    {
        // return a new instance of the progress dialog to the caller
        hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, riid, ppv);
    }
    else if (_psb)
    {
        hr = IUnknown_QueryService(_psb, guidService, riid, ppv);   // send up the to the browser
    }
    else
    {
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);  // or our site
    }
    return hr;
}

STDMETHODIMP CDefView::OnSetTitle(VARIANTARG *pvTitle)
{
    return E_NOTIMPL;
}

BOOL CDefView::_LoadCategory(GUID *pguidGroupID)
{
    BOOL fRet = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        IPropertyBag *ppb;
        if (SUCCEEDED(IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            fRet = SUCCEEDED(SHPropertyBag_ReadGUID(ppb, TEXT("Categorize"), pguidGroupID));
            ppb->Release();
        }
        ILFree(pidl);
    }
    return fRet;
}

void SHGetThumbnailSize(SIZE *psize)
{
    psize->cx = psize->cy = 96;

    DWORD dw = 0, cb = sizeof(dw);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("ThumbnailSize"), NULL, &dw, &cb, FALSE, NULL, 0);

    if (dw >= 32 && dw <= 256)    // constrain to reason
    {
        psize->cx = psize->cy = (int)dw;
    }
}

void SHGetThumbnailSizeForThumbsDB(SIZE *psize)
{
    SHGetThumbnailSize(psize);

    // Due to tnail.cpp restriction buffer sizes, we can only go to 120 (since that's all we've tested at)
    if (psize->cx > 120)
        psize->cx = psize->cy = 120;
}

void CDefView::_GetThumbnailSize(SIZE *psize)
{
    if (-1 == _sizeThumbnail.cx)
    {
        SHGetThumbnailSize(&_sizeThumbnail);
    }
    *psize = _sizeThumbnail;
}

#ifdef _X86_
//************
//
//  More of the Hijaak Hack
//

//  We return no attributes (specifically, Hijaak looks for
//  SFGAO_FILESYSTEM) and Hijaak will say, "Whoa, I don't know
//  how to patch this guy; I'll leave it alone."

STDAPI FakeHijaak_GetAttributesOf(void *_this, UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    *rgfInOut = 0; // Move along, nothing to see here
    return S_OK;
}

const struct FakeHijaakFolderVtbl
{
    FARPROC Dummy[9];
    FARPROC GetAttributesOf;
} c_FakeHijaakFolderVtbl = { { 0 }, (FARPROC)FakeHijaak_GetAttributesOf };

const LPVOID c_FakeHijaakFolder = (const LPVOID)&c_FakeHijaakFolderVtbl;

//
//  End of the Hijaak Hack
//
//************

#endif // _X86_

CBackgroundDefviewInfo::CBackgroundDefviewInfo(LPCITEMIDLIST pidl, UINT uId) :
    _pidl(pidl), _uId(uId)
{

}
CBackgroundDefviewInfo::~CBackgroundDefviewInfo (void)
{
    ILFree(const_cast<LPITEMIDLIST>(_pidl));
}

CBackgroundColInfo::CBackgroundColInfo(LPCITEMIDLIST pidl, UINT uId, UINT uiCol, STRRET& strRet) :
    CBackgroundDefviewInfo(pidl, uId),
    _uiCol(uiCol)
{
    StrRetToBuf(&strRet, NULL, const_cast<TCHAR*>(_szText), ARRAYSIZE(_szText));
}

CBackgroundColInfo::~CBackgroundColInfo(void)
{
}

// Takes ownership of pidl, copies rguColumns.
CBackgroundTileInfo::CBackgroundTileInfo(LPCITEMIDLIST pidl, UINT uId, UINT rguColumns[], UINT cColumns) :
    CBackgroundDefviewInfo(pidl, uId),
    _cColumns(cColumns)
{
    ASSERT(cColumns <= (UINT)TILEVIEWLINES);

    for (UINT i = 0; i < cColumns; i++)
        _rguColumns[i] = rguColumns[i];
}

CBackgroundTileInfo::~CBackgroundTileInfo(void)
{
}

// Helper function that scales the given size by some percentage where the percentage
// is defined in the resources for the localizers to adjust as approp.  Range is 0 to 30% larger
INT ScaleSizeBasedUponLocalization (INT iSize)
{
    TCHAR szPercentageIncrease [3];
    INT iReturnValue = iSize;
    INT iPercentageIncrease;


    if (iSize > 0)
    {
        if (LoadString(HINST_THISDLL, IDS_SIZE_INCREASE_PERCENTAGE, szPercentageIncrease, ARRAYSIZE(szPercentageIncrease)))
        {
            iPercentageIncrease = StrToInt(szPercentageIncrease);

            if (iPercentageIncrease > 0)
            {
                if (iPercentageIncrease > 30)
                {
                    iPercentageIncrease = 30;
                }

                iReturnValue += ((iPercentageIncrease * iSize) / 100);
            }
        }
    }

    return iReturnValue;
}

CBackgroundGroupInfo::CBackgroundGroupInfo (LPCITEMIDLIST pidl, UINT uId, DWORD dwGroupId):
    CBackgroundDefviewInfo(pidl, uId), _dwGroupId(dwGroupId)
{

}

BOOL CBackgroundGroupInfo::VerifyGroupExists(HWND hwnd, ICategorizer* pcat)
{
    if (!pcat)
        return FALSE;

    if (!ListView_HasGroup(hwnd, _dwGroupId))
    {
        CATEGORY_INFO ci;
        pcat->GetCategoryInfo(_dwGroupId, &ci);

        LVINSERTGROUPSORTED igrp;
        igrp.pfnGroupCompare = GroupCompare;
        igrp.pvData = (void *)pcat;
        igrp.lvGroup.cbSize = sizeof(LVGROUP);
        igrp.lvGroup.mask = LVGF_HEADER | LVGF_GROUPID;
        igrp.lvGroup.pszHeader= ci.wszName;
        igrp.lvGroup.iGroupId = (int)_dwGroupId;

        ListView_InsertGroupSorted(hwnd, &igrp);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defview.h ===
#ifndef _DEFVIEW_H
#define _DEFVIEW_H


// Private window messages
#define WM_DSV_FSNOTIFY                 (WM_USER+0xA0)
#define WM_DSV_BACKGROUNDENUMDONE       (WM_USER+0xA2)
#define WM_DSV_UPDATEICON               (WM_USER+0xA3)
#define WM_DSV_SHOWDRAGIMAGE            (WM_USER+0xA4)
#define WM_DSV_DISABLEACTIVEDESKTOP     (WM_USER+0xA6)
#define WM_DSV_REARRANGELISTVIEW        (WM_USER+0xA7)
#define WM_DSV_SENDSELECTIONCHANGED     (WM_USER+0xA8)
#define WM_DSV_UPDATECOLDATA            (WM_USER+0xA9)
#define WM_DSV_UPDATEOVERLAY            (WM_USER+0xAB)
#define WM_DSV_DESKHTML_CHANGES         (WM_USER+0xAC)
#define WM_DSV_FILELISTENUMDONE         (WM_USER+0xAD)
#define WM_DSV_DELAYWINDOWCREATE        (WM_USER+0xAE)
#define WM_DSV_DELAYSTATUSBARUPDATE     (WM_USER+0xAF)
#define WM_DSV_STARTPAGE_TURNONOFF      (WM_USER+0xB0)
#define WM_DSV_UPDATETHUMBNAIL          (WM_USER+0xB1)
#define WM_DSV_DELAYED_DESTROYWND       (WM_USER+0xB2)
#define WM_DSV_DELAYINFOTIP             (WM_USER+0xB3)
#define WM_DSV_GROUPINGDONE             (WM_USER+0xB4)
#define WM_DSV_SENDNOITEMSTATECHANGED   (WM_USER+0xB5)
#define WM_DSV_ADJUSTRECYCLEBINPOSITION (WM_USER+0xB6)
#define WM_DSV_ENSURE_COLUMNS_LOADED    (WM_USER+0xB7)
#define WM_DSV_SETIMPORTANTCOLUMNS      (WM_USER+0xB8)
// reuse                                (WM_USER+0xB9)
#define WM_DSV_SETITEMGROUP             (WM_USER+0xBA)
#define WM_DSV_FILELISTFILLDONE         (WM_USER+0xBB)
#define WM_DSV_POSTCREATEINFOTIP        (WM_USER+0xBC)

typedef struct
{
    int          iImage;
    int          iItem;
    LPITEMIDLIST pidl;
}DSV_UPDATETHUMBNAIL; 

#define MAX_EXT_VIEWS                   (SFVIDM_VIEW_EXTLAST - SFVIDM_VIEW_EXTFIRST + 1)



///// help string ids

#define SFVIDS_MH_FIRST                 (IDS_MH_SFVIDM_FIRST - SFVIDM_FIRST)

#define SFVIDS_MH_FILE_LINK             (SFVIDS_MH_FIRST + SFVIDM_FILE_LINK)
#define SFVIDS_MH_FILE_DELETE           (SFVIDS_MH_FIRST + SFVIDM_FILE_DELETE)
#define SFVIDS_MH_FILE_RENAME           (SFVIDS_MH_FIRST + SFVIDM_FILE_RENAME)
#define SFVIDS_MH_FILE_PROPERTIES       (SFVIDS_MH_FIRST + SFVIDM_FILE_PROPERTIES)

#define SFVIDS_MH_EDIT_UNDO             (SFVIDS_MH_FIRST + SFVIDM_EDIT_UNDO)
#define SFVIDS_MH_EDIT_CUT              (SFVIDS_MH_FIRST + SFVIDM_EDIT_CUT)
#define SFVIDS_MH_EDIT_COPY             (SFVIDS_MH_FIRST + SFVIDM_EDIT_COPY)
#define SFVIDS_MH_EDIT_PASTE            (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTE)
#define SFVIDS_MH_EDIT_PASTELINK        (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTELINK)
#define SFVIDS_MH_EDIT_PASTESPECIAL     (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTESPECIAL)
#define SFVIDS_MH_EDIT_COPYTO           (SFVIDS_MH_FIRST + SFVIDM_EDIT_COPYTO)
#define SFVIDS_MH_EDIT_MOVETO           (SFVIDS_MH_FIRST + SFVIDM_EDIT_MOVETO)

#define SFVIDS_MH_MENU_SELECT           (SFVIDS_MH_FIRST + SFVIDM_MENU_SELECT)
#define SFVIDS_MH_SELECT_ALL            (SFVIDS_MH_FIRST + SFVIDM_SELECT_ALL)
#define SFVIDS_MH_SELECT_INVERT         (SFVIDS_MH_FIRST + SFVIDM_SELECT_INVERT)

#define SFVIDS_MH_MENU_VIEW             (SFVIDS_MH_FIRST + SFVIDM_MENU_VIEW)
#define SFVIDS_MH_VIEW_ICON             (SFVIDS_MH_FIRST + SFVIDM_VIEW_ICON)
#define SFVIDS_MH_VIEW_TILE             (SFVIDS_MH_FIRST + SFVIDM_VIEW_TILE)
#define SFVIDS_MH_VIEW_THUMBNAILS       (SFVIDS_MH_FIRST + SFVIDM_VIEW_THUMBNAIL)
#define SFVIDS_MH_VIEW_THUMBSTRIP       (SFVIDS_MH_FIRST + SFVIDM_VIEW_THUMBSTRIP)
#define SFVIDS_MH_VIEW_SMALLICON        (SFVIDS_MH_FIRST + SFVIDM_VIEW_SMALLICON)
#define SFVIDS_MH_VIEW_LIST             (SFVIDS_MH_FIRST + SFVIDM_VIEW_LIST)
#define SFVIDS_MH_VIEW_DETAILS          (SFVIDS_MH_FIRST + SFVIDM_VIEW_DETAILS)
#define SFVIDS_MH_VIEW_PAGE             (SFVIDS_MH_FIRST + SFVIDM_VIEW_PAGE)
#define SFVIDS_MH_VIEW_OPTIONS          (SFVIDS_MH_FIRST + SFVIDM_VIEW_OPTIONS)
#define SFVIDS_MH_VIEW_CUSTOMWIZARD     (SFVIDS_MH_FIRST + SFVIDM_VIEW_CUSTOMWIZARD)
#define SFVIDS_MH_VIEW_COLUMNSETTINGS   (SFVIDS_MH_FIRST + SFVIDM_VIEW_COLSETTINGS)

#define SFVIDS_MH_MENU_ARRANGE          (SFVIDS_MH_FIRST + SFVIDM_MENU_ARRANGE)
#define SFVIDS_MH_ARRANGE_AUTO          (SFVIDS_MH_FIRST + SFVIDM_ARRANGE_AUTO)
#define SFVIDS_MH_ARRANGE_AUTOGRID      (SFVIDS_MH_FIRST + SFVIDM_ARRANGE_AUTOGRID)

#define SFVIDS_MH_TOOL_CONNECT          (SFVIDS_MH_FIRST + SFVIDM_TOOL_CONNECT)
#define SFVIDS_MH_TOOL_DISCONNECT       (SFVIDS_MH_FIRST + SFVIDM_TOOL_DISCONNECT)
#define SFVIDS_MH_HELP_TOPIC            (SFVIDS_MH_FIRST + SFVIDM_HELP_TOPIC)
#define SFVIDS_MH_GROUPBY               (SFVIDS_MH_FIRST + SFVIDM_GROUPBY)


//tool tips
#define IDS_TT_VIEW_ICON                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_ICON)
#define IDS_TT_VIEW_SMALLICON           (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_SMALLICON)
#define IDS_TT_VIEW_LIST                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_LIST)
#define IDS_TT_VIEW_DETAILS             (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_DETAILS)
#define IDS_TT_VIEW_PAGE                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_PAGE)
#define IDS_TT_VIEW_VIEWMENU            (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_VIEWMENU)

#define IDS_TT_TOOL_CONNECT             (IDS_TT_SFVIDM_FIRST + SFVIDM_TOOL_CONNECT)
#define IDS_TT_TOOL_DISCONNECT          (IDS_TT_SFVIDM_FIRST + SFVIDM_TOOL_DISCONNECT)

#define IDS_TT_EDIT_CUT                 (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_CUT)
#define IDS_TT_EDIT_COPY                (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_COPY)
#define IDS_TT_EDIT_PASTE               (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_PASTE)
#define IDS_TT_EDIT_UNDO                (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_UNDO)
#define IDS_TT_FILE_DELETE              (IDS_TT_SFVIDM_FIRST + SFVIDM_FILE_DELETE)
#define IDS_TT_FILE_PROPERTIES          (IDS_TT_SFVIDM_FIRST + SFVIDM_FILE_PROPERTIES)


#define DIEC_BACKGROUNDCONTEXT   1
#define DIEC_SELECTIONCONTEXT    2

#endif // _DEFVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defviewlegacy.cpp ===
#include "shellprv.h"
#include <sfview.h>
#include "defviewp.h"

int CGenList::Add(LPVOID pv, int nInsert)
{
    if (!_hList)
    {
        _hList = DSA_Create(_cbItem, 8);
        if (!_hList)
        {
            return -1;
        }
    }
    return DSA_InsertItem(_hList, nInsert, pv);
}


int CViewsList::Add(const SFVVIEWSDATA*pView, int nInsert, BOOL bCopy)
{
    if (bCopy)
    {
        pView = CopyData(pView);
        if (!pView)
        {
            return -1;
        }
    }

    int iIndex = CGenList::Add((LPVOID)(&pView), nInsert);

    if (bCopy && iIndex<0)
    {
        SHFree((LPVOID)pView);
    }

    return iIndex;
}


TCHAR const c_szExtViews[] = TEXT("ExtShellFolderViews");

void CViewsList::AddReg(HKEY hkParent, LPCTSTR pszSubKey)
{
    CSHRegKey ckClass(hkParent, pszSubKey);
    if (!ckClass)
    {
        return;
    }

    CSHRegKey ckShellEx(ckClass, TEXT("shellex"));
    if (!ckShellEx)
    {
        return;
    }

    CSHRegKey ckViews(ckShellEx, c_szExtViews);
    if (!ckViews)
    {
        return;
    }

    TCHAR szKey[40];
    DWORD dwLen = sizeof(szKey);
    SHELLVIEWID vid;

    if (ERROR_SUCCESS==SHRegQueryValue(ckViews, NULL, szKey, (LONG*)&dwLen)
        && SUCCEEDED(SHCLSIDFromString(szKey, &vid)))
    {
        _vidDef = vid;
        _bGotDef = TRUE;
    }


    for (int i=0; ; ++i)
    {
        LONG lRet = RegEnumKey(ckViews, i, szKey, ARRAYSIZE(szKey));
        if (lRet == ERROR_MORE_DATA)
        {
            continue;
        }
        else if (lRet != ERROR_SUCCESS)
        {
            // I assume this is ERROR_NO_MORE_ITEMS
            break;
        }

        SFVVIEWSDATA sView;
        ZeroMemory(&sView, sizeof(sView));

        if (FAILED(SHCLSIDFromString(szKey, &sView.idView)))
        {
            continue;
        }

        CSHRegKey ckView(ckViews, szKey);
        if (ckView)
        {
            TCHAR szFile[ARRAYSIZE(sView.wszMoniker)];
            DWORD dwType;

            // NOTE: This app "Nuts&Bolts" munges the registry and remove the last NULL byte
            // from the PersistMoniker string. When we read that string into un-initialized 
            // local buffer, we do not get a properly null terminated string and we fail to 
            // create the moniker. So, I zero Init the mem here.
            ZeroMemory(szFile, sizeof(szFile));
            
            // Attributes affect all extended views
            dwLen = sizeof(sView.dwFlags);
            if ((ERROR_SUCCESS != SHQueryValueEx(ckView, TEXT("Attributes"),
                    NULL, &dwType, &sView.dwFlags, &dwLen))
                || dwLen != sizeof(sView.dwFlags)
                || !(REG_DWORD==dwType || REG_BINARY==dwType))
            {
                sView.dwFlags = 0;
            }

            // We either have a PersistMoniker (docobj) extended view
            // or we have an IShellView extended view
            //
            dwLen = sizeof(szFile);
            if (ERROR_SUCCESS == SHQueryValueEx(ckView, TEXT("PersistMoniker"),
                    NULL, &dwType, szFile, &dwLen) && REG_SZ == dwType)
            {
                //if the %UserAppData% exists, expand it!
                ExpandOtherVariables(szFile, ARRAYSIZE(szFile));
                SHTCharToUnicode(szFile, sView.wszMoniker, ARRAYSIZE(sView.wszMoniker));
            }
            else
            {
                dwLen = sizeof(szKey);
                if (ERROR_SUCCESS == SHQueryValueEx(ckView, TEXT("ISV"),
                    NULL, &dwType, szKey, &dwLen) && REG_SZ == dwType
                    && SUCCEEDED(SHCLSIDFromString(szKey, &vid)))
                {
                    sView.idExtShellView = vid;

                    // Only IShellView extended vies use LParams
                    dwLen = sizeof(sView.lParam);
                    if ((ERROR_SUCCESS != SHQueryValueEx(ckView, TEXT("LParam"),
                            NULL, &dwType, &sView.lParam, &dwLen))
                        || dwLen != sizeof(sView.lParam)
                        || !(REG_DWORD==dwType || REG_BINARY==dwType))
                    {
                        sView.lParam = 0;
                    }
        
                }
                else
                {
                    if (VID_FolderState != sView.idView)
                    {
                        // No moniker, no IShellView extension, this must be a VID_FolderState
                        // kinda thing. (Otherwise it's a bad desktop.ini.)
                        //
                        RIPMSG(0, "Extended view is registered incorrectly.");
                        continue;
                    }
                }
            }

            // It has been requested (by OEMs) to allow specifying background
            // bitmap and text colors for the regular views. That way they could
            // brand the Control Panel page by putting their logo recessed on
            // the background. We'd do that here by pulling the stuff out of
            // the registry and putting it in the LPCUSTOMVIEWSDATA section...
        }

        // if docobjextended view that is not webview, DO NOT ADD IT, UNSUPPORTED.
        if (!(sView.dwFlags & SFVF_NOWEBVIEWFOLDERCONTENTS)
                && !IsEqualGUID(sView.idView, VID_WebView))
            continue;
        Add(&sView);
    }
}


void CViewsList::AddCLSID(CLSID const* pclsid)
{
    CSHRegKey ckCLSID(HKEY_CLASSES_ROOT, TEXT("CLSID"));
    if (!ckCLSID)
    {
        return;
    }

    TCHAR szCLSID[40];
    SHStringFromGUID(*pclsid, szCLSID, ARRAYSIZE(szCLSID));

    AddReg(ckCLSID, szCLSID);
}

#ifdef DEBUG
//In debug, I want to see if all the realloc code-path works fine!
//So, I deliberately alloc very small amounts.
#define CUSTOM_INITIAL_ALLOC      16
#define CUSTOM_REALLOC_INCREMENT  16
#else
#define CUSTOM_INITIAL_ALLOC      20*64
#define CUSTOM_REALLOC_INCREMENT  512
#endif //DEBUG

//Returns the offset of the string read into the block of memory (in chars)
// NOTE: the index (piCurOffset) and the sizes *piTotalSize, *piSizeRemaining are 
// NOTE: in WCHARs, not BYTES
int GetCustomStrData(LPWSTR *pDataBegin, int *piSizeRemaining, int *piTotalSize, 
                       int *piCurOffset, LPCTSTR szSectionName, LPCTSTR szKeyName, 
                       LPCTSTR szIniFile, LPCTSTR lpszPath)
{
    TCHAR szStrData[INFOTIPSIZE], szTemp[INFOTIPSIZE];
#ifndef UNICODE
    WCHAR wszStrData[MAX_PATH];
#endif
    LPWSTR pszStrData;
    int iLen, iOffsetBegin = *piCurOffset;

    //See if the data is present.
    if (!SHGetIniString(szSectionName, szKeyName, szTemp, ARRAYSIZE(szTemp), szIniFile))
    {
        return -1;  //The given data is not present.
    }

    SHExpandEnvironmentStrings(szTemp, szStrData, ARRAYSIZE(szStrData));   // Expand the env vars if any
    
    //Get the full pathname if required.
    if (lpszPath)
        PathCombine(szStrData, lpszPath, szStrData);

#ifdef UNICODE
    iLen = lstrlen(szStrData);
    pszStrData = szStrData;
#else
    iLen = MultiByteToWideChar(CP_ACP, 0, szStrData, -1, wszStrData, ARRAYSIZE(wszStrData));
    pszStrData = wszStrData;
#endif
    iLen++;   //Include the NULL character.

    while(*piSizeRemaining < iLen)
    {
        LPWSTR lpNew;
        //We need to realloc the block of memory
        if (NULL == (lpNew = (LPWSTR)SHRealloc(*pDataBegin, ( *piTotalSize + CUSTOM_REALLOC_INCREMENT) * sizeof(WCHAR))))
            return -1;  //Unable to realloc; out of mem.
        
        //Note: The begining address of the block could have changed.
        *pDataBegin = lpNew;
        *piTotalSize += CUSTOM_REALLOC_INCREMENT;
        *piSizeRemaining += CUSTOM_REALLOC_INCREMENT;
    }

    //Add the current directory if required.
    StrCpyW((*pDataBegin)+(*piCurOffset), pszStrData);

    *piSizeRemaining -= iLen;
    *piCurOffset += iLen;

    return iOffsetBegin;
}

HRESULT ReadWebViewTemplate(LPCTSTR pszPath, LPTSTR pszWebViewTemplate, int cchWebViewTemplate)
{
    SHFOLDERCUSTOMSETTINGS fcs = {sizeof(fcs), FCSM_WEBVIEWTEMPLATE, 0};
    fcs.pszWebViewTemplate = pszWebViewTemplate;   // template path
    fcs.cchWebViewTemplate = cchWebViewTemplate;
    return SHGetSetFolderCustomSettings(&fcs, pszPath, FCS_READ);
}

#define ID_EXTVIEWICONAREAIMAGE 3
#define ID_EXTVIEWCOLORSFIRST   4
#define ID_EXTVIEWSTRLAST       5
#define ID_EXTVIEWUICOUNT       6

const LPCTSTR c_szExtViewUIRegKeys[ID_EXTVIEWUICOUNT] =
{
    TEXT("MenuName"),
    TEXT("HelpText"),
    TEXT("TooltipText"),
    TEXT("IconArea_Image"),
    TEXT("IconArea_TextBackground"),
    TEXT("IconArea_Text")
};

void CViewsList::AddIni(LPCTSTR szIniFile, LPCTSTR szPath)
{
    TCHAR szViewIDs[12*45];  // Room for about 12 GUIDs including Default=
    SHELLVIEWID vid;

    //
    //First check if the INI file exists before trying to get data from it.
    //
    if (!PathFileExistsAndAttributes(szIniFile, NULL))
        return;

    if (GetPrivateProfileString(c_szExtViews, TEXT("Default"), c_szNULL,
        szViewIDs, ARRAYSIZE(szViewIDs), szIniFile)
        && SUCCEEDED(SHCLSIDFromString(szViewIDs, &vid)))
    {
        _vidDef = vid;
        _bGotDef = TRUE;
    }

    GetPrivateProfileString(c_szExtViews, NULL, c_szNULL,
        szViewIDs, ARRAYSIZE(szViewIDs), szIniFile);

    for (LPCTSTR pNextID=szViewIDs; *pNextID; pNextID+=lstrlen(pNextID)+1)
    {
        SFVVIEWSDATA sViewData;
        CUSTOMVIEWSDATA sCustomData;
        LPWSTR         pszDataBegin = NULL;
        int            iSizeRemaining = CUSTOM_INITIAL_ALLOC; //Let's begin with 12 strings.
        int            iTotalSize;
        int            iCurOffset;

        ZeroMemory(&sViewData, sizeof(sViewData));

        ZeroMemory(&sCustomData, sizeof(sCustomData));

        // there must be a view id
        if (FAILED(SHCLSIDFromString(pNextID, &sViewData.idView)))
        {
            continue;
        }

        // we blow off IE4b2 customized views. This forces them to run
        // the wizard again which will clean this junk up
        if (IsEqualIID(sViewData.idView, VID_DefaultCustomWebView))
        {
            continue;
        }

        // get the IShellView extended view, if any
        BOOL fExtShellView = FALSE;
        TCHAR szPreProcName[45];
        if (GetPrivateProfileString(c_szExtViews, pNextID, c_szNULL,
            szPreProcName, ARRAYSIZE(szPreProcName), szIniFile))
        {
            fExtShellView = SUCCEEDED(SHCLSIDFromString(szPreProcName, &sViewData.idExtShellView));
        }

        // All extended views use Attributes
        sViewData.dwFlags = GetPrivateProfileInt(pNextID, TEXT("Attributes"), 0, szIniFile) | SFVF_CUSTOMIZEDVIEW;

        // For some reason this code uses a much larger buffer
        // than seems necessary. I don't know why... [mikesh 29jul97]
        TCHAR szViewData[MAX_PATH+MAX_PATH];
        szViewData[0] = TEXT('\0'); // For the non-webview case

        if (IsEqualGUID(sViewData.idView, VID_WebView) && SUCCEEDED(ReadWebViewTemplate(szPath, szViewData, MAX_PATH)))
        {
            LPTSTR pszPath = szViewData;
            // We want to allow relative paths for the file: protocol
            //
            if (0 == StrCmpNI(TEXT("file://"), szViewData, 7)) // ARRAYSIZE(TEXT("file://"))
            {
                pszPath += 7;   // ARRAYSIZE(TEXT("file://"))
            }
            // for webview:// compatibility, keep this working:
            else if (0 == StrCmpNI(TEXT("webview://file://"), szViewData, 17)) // ARRAYSIZE(TEXT("file://"))
            {
                pszPath += 17;  // ARRAYSIZE(TEXT("webview://file://"))
            }
            // handle relative references...
            PathCombine(pszPath, szPath, pszPath);

            // Avoid overwriting buffers
            szViewData[MAX_PATH-1] = NULL;
        }
        else
        {
            // only IShellView extensions use LParams
            sViewData.lParam = GetPrivateProfileInt( pNextID, TEXT("LParam"), 0, szIniFile );

            if (!fExtShellView && VID_FolderState != sViewData.idView)
            {
                // No moniker, no IShellView extension, this must be a VID_FolderState
                // kinda thing. (Otherwise it's a bad desktop.ini.)
                //
                RIPMSG(0, "Extended view is registered incorrectly.");
                continue;
            }
        }
        SHTCharToUnicode(szViewData, sViewData.wszMoniker, ARRAYSIZE(sViewData.wszMoniker));

        // NOTE: the size is in WCHARs not in BYTES
        pszDataBegin = (LPWSTR)SHAlloc(iSizeRemaining * sizeof(WCHAR));
        if (NULL == pszDataBegin)
            continue;

        iTotalSize = iSizeRemaining;
        iCurOffset = 0;

        // Read the custom colors
        for (int i = 0; i < CRID_COLORCOUNT; i++)
            sCustomData.crCustomColors[i] = GetPrivateProfileInt(pNextID, c_szExtViewUIRegKeys[ID_EXTVIEWCOLORSFIRST + i], CLR_MYINVALID, szIniFile);
        
        // Read the extended view strings
        for (i = 0; i <= ID_EXTVIEWSTRLAST; i++)
        {
            sCustomData.acchOffExtViewUIstr[i] = GetCustomStrData(&pszDataBegin,
                       &iSizeRemaining, &iTotalSize, &iCurOffset,
                       pNextID, c_szExtViewUIRegKeys[i], szIniFile,
                       (i == ID_EXTVIEWICONAREAIMAGE ? szPath : NULL));
        }

        sCustomData.cchSizeOfBlock = (iTotalSize - iSizeRemaining);
        sCustomData.lpDataBlock = pszDataBegin;
        sViewData.pCustomData = &sCustomData;

        // if docobjextended view that is not webview, DO NOT ADD IT, UNSUPPORTED.
        if (!(sViewData.dwFlags & SFVF_NOWEBVIEWFOLDERCONTENTS)
                && !IsEqualGUID(sViewData.idView, VID_WebView)
                && !IsEqualGUID(sViewData.idView, VID_FolderState))
            continue;
        Add(&sViewData);

        //We already copied the data. So, we can free it!
        SHFree(pszDataBegin);
    }
}


void CViewsList::Empty()
{
    _bGotDef = FALSE;

    for (int i=GetItemCount()-1; i>=0; --i)
    {
        SFVVIEWSDATA  *sfvData = GetPtr(i);
        
        ASSERT(sfvData);
        if (sfvData->dwFlags & SFVF_CUSTOMIZEDVIEW)
        {
            CUSTOMVIEWSDATA  *pCustomPtr = sfvData->pCustomData;
            if (pCustomPtr)
            {
                if (pCustomPtr->lpDataBlock)
                    SHFree(pCustomPtr->lpDataBlock);
                SHFree(pCustomPtr);
            }
        }
        SHFree(sfvData);
    }

    CGenList::Empty();
}


SFVVIEWSDATA* CViewsList::CopyData(const SFVVIEWSDATA* pData)
{
    SFVVIEWSDATA* pCopy = (SFVVIEWSDATA*)SHAlloc(sizeof(SFVVIEWSDATA));
    if (pCopy)
    {
        memcpy(pCopy, pData, sizeof(SFVVIEWSDATA));
        if ((pData->dwFlags & SFVF_CUSTOMIZEDVIEW) && pData->pCustomData)
        {
            CUSTOMVIEWSDATA *pCustomData = (CUSTOMVIEWSDATA *)SHAlloc(sizeof(CUSTOMVIEWSDATA));
            if (pCustomData)
            {
                memcpy(pCustomData, pData->pCustomData, sizeof(CUSTOMVIEWSDATA));
                pCopy->pCustomData = pCustomData;

                if (pCustomData->lpDataBlock)
                {
                    // NOTE: DataBlock size is in WCHARs
                    LPWSTR lpDataBlock = (LPWSTR)SHAlloc(pCustomData->cchSizeOfBlock * sizeof(WCHAR));
                    if (lpDataBlock)
                    {
                        // NOTE: DataBlock size is in WCHARs
                        memcpy(lpDataBlock, pCustomData->lpDataBlock, pCustomData->cchSizeOfBlock * sizeof(WCHAR));
                        pCustomData->lpDataBlock = lpDataBlock;
                    }
                    else
                    {
                        SHFree(pCustomData);
                        goto Failed;
                    }
                }
            }
            else
            {
Failed:
                SHFree(pCopy);
                pCopy = NULL;
            }
        }
    }

    return pCopy;
}


int CViewsList::NextUnique(int nLast)
{
    for (int nNext = nLast + 1; ; ++nNext)
    {
        SFVVIEWSDATA* pItem = GetPtr(nNext);
        if (!pItem)
        {
            break;
        }

        for (int nPrev=nNext-1; nPrev>=0; --nPrev)
        {
            SFVVIEWSDATA*pPrev = GetPtr(nPrev);
            if (pItem->idView == pPrev->idView)
            {
                break;
            }
        }

        if (nPrev < 0)
        {
            return nNext;
        }
    }

    return -1;
}


// Note this is 1-based
int CViewsList::NthUnique(int nUnique)
{
    for (int nNext = -1; nUnique > 0; --nUnique)
    {
        nNext = NextUnique(nNext);
        if (nNext < 0)
        {
            return -1;
        }
    }

    return nNext;
}


void CCallback::_GetExtViews(BOOL bForce)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    IEnumSFVViews *pev = NULL;

    if (bForce)
    {
        _bGotViews = FALSE;
    }

    if (_bGotViews)
    {
        return;
    }

    _lViews.Empty();

    SHELLVIEWID vid = VID_LargeIcons;
    if (FAILED(pView->CallCB(SFVM_GETVIEWS, (WPARAM)&vid, (LPARAM)&pev)) ||
        !pev)
    {
        return;
    }

    _lViews.SetDef(&vid);

    SFVVIEWSDATA *pData;
    ULONG uFetched;

    while ((pev->Next(1, &pData, &uFetched) == S_OK) && (uFetched == 1))
    {
        // The list comes to us in general to specific order, but we want
        // to search it in specific->general order. Inverting the list
        // is easiest here, even though it causes a bunch of memcpy calls.
        //
        _lViews.Prepend(pData, FALSE);
    }

    ATOMICRELEASE(pev);

    _bGotViews = TRUE;
}


HRESULT CCallback::TryLegacyGetViews(SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);
    HRESULT hr = E_FAIL;

    CLSID clsid;
    HRESULT hr2 = IUnknown_GetClassID(pView->_pshf, &clsid);
    if (FAILED(hr2) || !(SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_NOLEGACYWEBVIEW))
    {
        _GetExtViews(FALSE);
        if (_bGotViews)
        {
            SFVVIEWSDATA* pItem;
            GetViewIdFromGUID(&VID_WebView, &pItem);
            if (pItem)
            {
                StrCpyNW(pvit->szWebView, pItem->wszMoniker, ARRAYSIZE(pvit->szWebView));
                hr = S_OK;
            }
        }
        else if (SUCCEEDED(hr2))
        {
            // check for PersistMoniker under isf's coclass (Web Folders used this in W2K to get .htt Web View)
            WCHAR szCLSID[GUIDSTR_MAX];
            SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

            WCHAR szkey[MAX_PATH];
            wnsprintf(szkey, ARRAYSIZE(szkey), L"CLSID\\%s\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}", szCLSID);

            DWORD cbSize = sizeof(pvit->szWebView);
            if (ERROR_SUCCESS == SHGetValueW(HKEY_CLASSES_ROOT, szkey, L"PersistMoniker", NULL, pvit->szWebView, &cbSize))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CCallback::OnRefreshLegacy(void* pv, BOOL fPrePost)
{
    // If we're using the SFVM_GETVIEWS layer, invalidate it
    if (_bGotViews)
    {
        _lViews.Empty();
        _bGotViews = FALSE;
    }

    return S_OK;
}

int CCallback::GetViewIdFromGUID(SHELLVIEWID const *pvid, SFVVIEWSDATA** ppItem)
{
    int iView = -1;
    for (UINT uView=0; uView<MAX_EXT_VIEWS; ++uView)
    {
        iView = _lViews.NextUnique(iView);

        SFVVIEWSDATA* pItem = _lViews.GetPtr(iView);
        if (!pItem)
        {
            break;
        }

        if (*pvid == pItem->idView)
        {
            if (ppItem)
                *ppItem = pItem;

            return (int)uView;
        }
    }

    if (ppItem)
        *ppItem = NULL;
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defviewlegacy.h ===
class CGenList
{
public:
    CGenList(UINT cbItem) : _hList(NULL), _cbItem(cbItem) {}
    ~CGenList() {Empty();}

    void *GetPtr(UINT i)
        {return(i<GetItemCount() ? DSA_GetItemPtr(_hList, i) : NULL);}

    UINT GetItemCount() {return(_hList ? DSA_GetItemCount(_hList) : 0);}

    int Add(void *pv, int nInsert);

    void Empty() {if (_hList) DSA_Destroy(_hList); _hList=NULL;}

protected:
    void Steal(CGenList* pList)
    {
        Empty();
        _cbItem = pList->_cbItem;
        _hList = pList->_hList;
        pList->_hList = NULL;
    }

private:
    UINT _cbItem;
    HDSA _hList;
} ;

class CViewsList : public CGenList
{
public:
    CViewsList() : CGenList(SIZEOF(SFVVIEWSDATA*)), _bGotDef(FALSE) {}
    ~CViewsList() {Empty();}

    SFVVIEWSDATA* GetPtr(UINT i)
    {
        SFVVIEWSDATA** ppViewsData = (SFVVIEWSDATA**)CGenList::GetPtr(i);
        return(ppViewsData ? *ppViewsData : NULL);
    }


    int Add(const SFVVIEWSDATA*pView, int nInsert, BOOL bCopy);
    int Add(const SFVVIEWSDATA*pView, BOOL bCopy=TRUE) {return Add(pView, DA_LAST, bCopy);}
    int Prepend(const SFVVIEWSDATA*pView, BOOL bCopy=TRUE) {return Add(pView, 0, bCopy);}
    void AddReg(HKEY hkParent, LPCTSTR pszSubKey);
    void AddCLSID(CLSID const* pclsid);
    void AddIni(LPCTSTR szIniFile, LPCTSTR szPath);

    void SetDef(SHELLVIEWID const *pvid) { _bGotDef=TRUE; _vidDef=*pvid; }
    BOOL GetDef(SHELLVIEWID *pvid) { if (_bGotDef) *pvid=_vidDef; return(_bGotDef); }

    void Empty();

    static SFVVIEWSDATA* CopyData(const SFVVIEWSDATA* pData);

    int NextUnique(int nLast);
    int NthUnique(int nUnique);

private:
    BOOL _bGotDef;
    SHELLVIEWID _vidDef;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defviewp.h ===
#ifndef _DEFVIEWP_H_
#define _DEFVIEWP_H_

#include "defview.h"
#include <mshtmhst.h>
#include "urlmon.h"
#include <perhist.h>
#include "inetsmgr.h"
#include <cowsite.h>
#include "ViewState.h"
#include "webvw.h"
#include "runtask.h"
#include "enumuicommand.h"
#include "tlist.h"

// not used in any of our ISF implementations, but needed for legacy ISF implementations
#include "defviewlegacy.h"

class CBackgroundInfoTip;   // Used for the background processing of InfoTips
class CDefview;

class CDVDropTarget // dvdt
{        
public:
    HRESULT DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    HRESULT DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    HRESULT DragLeave();
    HRESULT Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    void LeaveAndReleaseData();
    void ReleaseDataObject();
    void ReleaseCurrentDropTarget();

    IDataObject *       _pdtobj;         // from DragEnter()/Drop()
    RECT                _rcLockWindow;   // WindowRect of hwnd for DAD_ENTER
    int                 _itemOver;       // item we are visually dragging over
    BOOL                _fItemOverNotADropTarget; // the item we are currently dragging over was found not to be a drop target
    BOOL                _fIgnoreSource;  // drag is coming from webview / active desktop
    IDropTarget *       _pdtgtCur;       // current drop target, derived from hit testing
    DWORD               _dwEffectOut;    // last *pdwEffect out
    DWORD               _grfKeyState;    // cached key state
    POINT               _ptLast;         // last dragged position
    AUTO_SCROLL_DATA    _asd;            // for auto scrolling
    DWORD               _dwLastTime;     // for auto-opening folders
};

//
//  This is a proxy IDropTarget object, which wraps Trident's droptarget.
//
class CHostDropTarget : public IDropTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    IDropTarget* _pdtFrame; // Drop target of the frame
};


class CSFVSite : public IOleInPlaceSite,
                 public IOleClientSite,
                 public IOleDocumentSite,
                 public IServiceProvider,
                 public IOleCommandTarget,
                 public IDocHostUIHandler,
                 public IOleControlSite,
                 public IInternetSecurityManager,
                 public IDispatch       //For ambient properties.
{
    friend CHostDropTarget;
public:
    CSFVSite()  { ASSERT(_peds == NULL); }
    ~CSFVSite() {
                    if (_peds) {
                        _peds->Release();
                        _peds = NULL;
                    }
                }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceSite
    STDMETHODIMP CanInPlaceActivate(void);
    STDMETHODIMP OnInPlaceActivate(void);
    STDMETHODIMP OnUIActivate(void);
    STDMETHODIMP GetWindowContext(
        IOleInPlaceFrame **ppFrame,
        IOleInPlaceUIWindow **ppDoc,
        LPRECT lprcPosRect,
        LPRECT lprcClipRect,
        LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll(SIZE scrollExtant);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate(void);
    STDMETHODIMP DiscardUndoState(void);
    STDMETHODIMP DeactivateAndUndo(void);
    STDMETHODIMP OnPosRectChange(LPCRECT lprcPosRect);

    // IOleClientSite
    STDMETHODIMP SaveObject(void);

    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);

    STDMETHODIMP GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IOleDocumentSite
    STDMETHODIMP ActivateMe(IOleDocumentView *pviewToActivate);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IOleControlSite
    STDMETHODIMP OnControlInfoChanged() { return E_NOTIMPL; };
    STDMETHODIMP LockInPlaceActive(BOOL fLock) { return E_NOTIMPL; };
    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp) { *ppDisp = NULL; return E_NOTIMPL; };
    STDMETHODIMP TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags) { return E_NOTIMPL; };
    STDMETHODIMP TranslateAccelerator(MSG *pMsg,DWORD grfModifiers);

    STDMETHODIMP OnFocus(BOOL fGotFocus) { return E_NOTIMPL; };
    STDMETHODIMP ShowPropertyFrame(void) { return E_NOTIMPL; };

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    STDMETHODIMP ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    STDMETHODIMP HideUI(void);
    STDMETHODIMP UpdateUI(void);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP ResizeBorder(
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    STDMETHODIMP TranslateAccelerator(
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    STDMETHODIMP GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    STDMETHODIMP GetDropTarget(
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    STDMETHODIMP GetExternal(IDispatch **ppDisp);
    STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHODIMP FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IInternetSecurityManager
    STDMETHODIMP SetSecuritySite(IInternetSecurityMgrSite *pSite) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetSecuritySite(IInternetSecurityMgrSite **ppSite) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP MapUrlToZone(LPCWSTR pwszUrl, DWORD * pdwZone, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetSecurityId(LPCWSTR pwszUrl, BYTE * pbSecurityId, DWORD * pcbSecurityId, DWORD_PTR dwReserved) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE * pPolicy, DWORD cbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE ** ppPolicy, DWORD * pcbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwReserved) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP SetZoneMapping(DWORD dwZone, LPCWSTR pszPattern, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetZoneMappings(DWORD dwZone, IEnumString ** ppenumString, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, unsigned int cNames, LCID lcid, DISPID *rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pvarResult, EXCEPINFO *pexcepinfo,UINT *puArgErr);

    CHostDropTarget _dt;
    IExpDispSupport * _peds;
};

class CSFVFrame : public IOleInPlaceFrame, 
                  public IAdviseSink, 
                  public IPropertyNotifySink  //for READYSTATE
{
public:
    enum
    {
        UNDEFINEDVIEW = -3,
        NOEXTVIEW = -2,
        HIDEEXTVIEW = -1,
    } ;

    CSFVFrame() : _fReadyStateComplete(TRUE), _pOleObj(NULL), _bgColor(CLR_INVALID)
    {
    }
    ~CSFVFrame();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceUIWindow
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleInPlaceFrame
    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus(HMENU hmenuShared);
    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IPropertyNotifySink
    STDMETHODIMP OnChanged(DISPID dispid);
    STDMETHODIMP OnRequestEdit(DISPID dispid);

private:
    friend class CSFVSite;
    CSFVSite _cSite;

    friend class CDefView;

    class CBindStatusCallback : public IBindStatusCallback
                              , public IServiceProvider
    {
        friend CSFVFrame;
    protected:
        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);
    
        // IServiceProvider
        STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);
    
        // IBindStatusCallback
        STDMETHODIMP OnStartBinding(
            DWORD grfBSCOption,
            IBinding *pib);
        STDMETHODIMP GetPriority(
            LONG *pnPriority);
        STDMETHODIMP OnLowResource(
            DWORD reserved);
        STDMETHODIMP OnProgress(
            ULONG ulProgress,
            ULONG ulProgressMax,
            ULONG ulStatusCode,
            LPCWSTR szStatusText);
        STDMETHODIMP OnStopBinding(
            HRESULT hresult,
            LPCWSTR szError);
        STDMETHODIMP GetBindInfo(
            DWORD *grfBINDINFOF,
            BINDINFO *pbindinfo);
        STDMETHODIMP OnDataAvailable(
            DWORD grfBSCF,
            DWORD dwSize,
            FORMATETC *pformatetc,
            STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(
            REFIID riid,
            IUnknown *punk);
    };
    
    friend class CBindStatusCallback;
    CBindStatusCallback _bsc;


//
// External views stuff
//
// We have DocObject extensions and IShellView extensions
// A (DocObject) extension can
public:
    HRESULT InitObj(IUnknown* pObj, LPCITEMIDLIST pidlHere, int iView);

    // If we have a moniker, then we are either currently showing it or we are trying to show it.
    // (Old code explicitly checked current view and pending view -- this is easier.)
    BOOL IsWebView(void) { return _szCurrentWebViewMoniker[0]!=L'\0'; }
    HRESULT _HasFocusIO();
    HRESULT _UIActivateIO(BOOL fActivate, MSG *pMsg);

    HWND GetExtendedViewWindow();

    HRESULT SetRect(LPRECT prc);

    HRESULT GetCommandTarget(IOleCommandTarget** ppct);

    // allow the frame to handle the choice on delegation on translate accelerator...
    HRESULT OnTranslateAccelerator(LPMSG pmsg, BOOL* pbTabOffLastTridentStop);

    HRESULT _GetHTMLBackgroundColor(COLORREF *pclr);    // used in defview.cpp
#ifdef DEBUG
    void _ShowWebViewContent();
#endif

private:

    COLORREF _bgColor;  //Icon text background color for active desktop

    UINT _uState:2;                // SVUIA_* for _pOleObj (extended view)
    IOleObject* _pOleObj;
    IOleDocumentView* _pDocView;
    IOleInPlaceActiveObject* _pActive;
    IViewObject *_pvoActive;

    void _CleanUpOleObj(IOleObject* pOleObj);
    void _CleanUpOleObjAndDt(IOleObject* pOleObj);
    void _CleanupNewOleObj();
    void _CleanupOldDocObject(void);

    WCHAR _szCurrentWebViewMoniker[MAX_PATH];
    HRESULT _GetCurrentWebViewMoniker(LPWSTR wszCurrentMoniker, DWORD cchCurrentMoniker);
    HRESULT ShowWebView(LPCWSTR pszMoniker);
    HRESULT HideWebView();
    HRESULT _CreateNewOleObjFromMoniker(LPCWSTR wszMoniker, IOleObject **ppOleObj);
    HRESULT _ShowExtView_Helper(IOleObject* pOleObj);
    HRESULT _SwitchToNewOleObj();
    HRESULT _GetCurrentZone(IOleObject *pOleObj, VARIANT *pvar);
    HRESULT _UpdateZonesStatusPane(IOleObject *pOleObj);

    //Fields that store details about the new OLE object while we wait for
    //it to reach a READYSTATE_INTERACTIVE.
    IOleObject* _pOleObjNew;
    BOOL _fSwitchedToNewOleObj;

    BOOL _SetupReadyStateNotifyCapability();
    BOOL _RemoveReadyStateNotifyCapability();

    DWORD    _dwConnectionCookie;
    BOOL     _fReadyStateInteractiveProcessed;
    BOOL     _fReadyStateComplete;
    IOleObject* _pOleObjReadyState;
};

class CCallback
{
public:
    CCallback(IShellFolderViewCB* psfvcb) : _psfvcb(psfvcb)
    {
        if (_psfvcb)
        {
            _psfvcb->AddRef();
            _psfvcb->QueryInterface(IID_PPV_ARG(IFolderFilter, &_psff));
        }
    }

    ~CCallback()
    {
        ATOMICRELEASE(_psfvcb);
        ATOMICRELEASE(_psff);
    }

    IShellFolderViewCB *GetSFVCB() 
    { 
        return _psfvcb; 
    }

    IFolderFilter *GetISFF()
    {
        return _psff;
    }

    HRESULT SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB)
    {
        // We Release the callback for us, and then AddRef it for the caller who now
        // owns the object, which does nothing
        *ppOldCB = _psfvcb;
        ATOMICRELEASE(_psff);
        
        _psfvcb = pNewCB;
        if (pNewCB)
        {
            pNewCB->AddRef();
            pNewCB->QueryInterface(IID_PPV_ARG(IFolderFilter, &_psff));
        }
        return S_OK;
    }

    // Default implementation of SFVM_GETVIEWS replacement SFVM_GETVIEWINFOTEMPLATE
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);

    // For legacy SFVM_GETVIEWS implementation:
    HRESULT TryLegacyGetViews(SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnRefreshLegacy(void* pv, BOOL fPrePost);
    void _GetExtViews(BOOL bForce);
    int GetViewIdFromGUID(SHELLVIEWID const *pvid, SFVVIEWSDATA** ppItem);
    CViewsList _lViews;
    BOOL _bGotViews;

    HRESULT CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        HRESULT hr;
        
        if (_psfvcb)
        {
            hr = _psfvcb->MessageSFVCB(uMsg, wParam, lParam);

            // NOTE: if SFVM_GETVIEWDATA is no longer needed, we can nuke this
            switch (uMsg)
            {
                HANDLE_MSG(0, SFVM_REFRESH, OnRefreshLegacy);
            }
            if (FAILED(hr))
            {
                switch (uMsg)
                {
                    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
                }
            }
        }
        else
        {
            hr = E_NOTIMPL;
        }

        return hr;
    }

    BOOL HasCB() 
    {
        return _psfvcb != NULL; 
    }

private:
    IShellFolderViewCB* _psfvcb;
    IFolderFilter* _psff;
};

// Variable Column stuff

typedef struct
{
    TCHAR szName[MAX_COLUMN_NAME_LEN];
    DWORD cChars;   // number of characters wide for default
    DWORD fmt;
    DWORD csFlags;  // SHCOLSTATE flags
    DWORD tsFlags;  // SHTRANSCOLSTATE flags
} COL_INFO;

#define SHTRANSCOLSTATE_TILEVIEWCOLUMN      0x00000001

//Possible values for _iCustomizable
#define YES_CUSTOMIZABLE                1
#define DONTKNOW_IF_CUSTOMIZABLE        0
#define NOT_CUSTOMIZABLE               -2

// For communicating with the background property extractor

class CBackgroundDefviewInfo
{
public:
        CBackgroundDefviewInfo (LPCITEMIDLIST pidl, UINT uId);
        virtual ~CBackgroundDefviewInfo (void);

        LPCITEMIDLIST   GetPIDL (void)      const   {   return(_pidl);          }
        UINT            GetId()             const   {   return(_uId);           }    

private:
        const LPCITEMIDLIST     _pidl;
              UINT              _uId;
};

class CBackgroundColInfo : public CBackgroundDefviewInfo
{
private:
    CBackgroundColInfo (void);
public:
    CBackgroundColInfo (LPCITEMIDLIST pidl, UINT uId, UINT uiCol, STRRET& strRet);
    ~CBackgroundColInfo (void);

    UINT            GetColumn (void)    const   {   return(_uiCol);         }
    LPCTSTR         GetText (void)      const   {   return(&_szText[0]);    }
private:
    const UINT              _uiCol;
          TCHAR             _szText[MAX_COLUMN_NAME_LEN];
};

// The number of "columns" shown in tileview.
// FEATURE:
// We may want to allow this as a registry setting. Or perhaps
// in the desktop.ini. Or perhaps pesisted as per-folder view state?
// Currently, we'll set this two 2 subitems, per spec.
#define TILEVIEWLINES 2

// For communicating with the background file type properties task (for tileview)
class CBackgroundTileInfo : public CBackgroundDefviewInfo
{
private:
    CBackgroundTileInfo (void);
public:
    CBackgroundTileInfo (LPCITEMIDLIST pidl, UINT uId, UINT rguColumns[], UINT cColumns);
    ~CBackgroundTileInfo (void);

    UINT*           GetColumns (void)            {   return(_rguColumns); }
    UINT            GetColumnCount (void)const   {   return(_cColumns);   }
private:
          UINT              _rguColumns[TILEVIEWLINES];
    const UINT              _cColumns;
};

class CBackgroundGroupInfo : public CBackgroundDefviewInfo
{
public:
    CBackgroundGroupInfo (LPCITEMIDLIST pidl, UINT uId, DWORD dwGroupId);

    BOOL        VerifyGroupExists(HWND hwnd, ICategorizer* pcat);
    DWORD       GetGroupId()                  {   return(_dwGroupId);  }
private:
          DWORD             _dwGroupId;
};



// CDefviewEnumTask is defview's IEnumIDList manager.
// This object is used on the UI thread from defview
// and on the task scheduler when it is doing background work.
// All the UI-thread functions are called out as public methods
// during which this object often calls back into CDefView.
//
class CDefviewEnumTask : public CRunnableTask
{
public:
    CDefviewEnumTask(CDefView *pdsv);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    STDMETHODIMP InternalResumeRT(void);

    // Called from defview from UI thread:
    HRESULT FillObjectsToDPA(BOOL fInteractive);
    HRESULT FillObjectsDPAToDone();
    HRESULT FillObjectsDoneToView();

    UINT DPACount() { return _hdpaEnum ? DPA_GetPtrCount(_hdpaEnum) : 0; }
    LPCITEMIDLIST* DPAArray() { return _hdpaEnum ? (LPCITEMIDLIST*)DPA_GetPtrPtr(_hdpaEnum) : NULL; }

    BOOL _DeleteFromPending(LPCITEMIDLIST pidl);
    void _AddToPending(LPCITEMIDLIST pidl);

private:
    ~CDefviewEnumTask();

    static int CALLBACK _CompareExactCanonical(void *p1, void *p2, LPARAM lParam);
    PFNDPACOMPARE _GetCanonicalCompareFunction(void);
    LPARAM _GetCanonicalCompareBits();

    void _SortForFilter(HDPA hdpa);
    void _FilterDPAs(HDPA hdpa, HDPA hdpaOld);

    CDefView *_pdsv;

    IEnumIDList *_peunk;
    HDPA _hdpaEnum;
    BOOL _fEnumSorted;
    BOOL _fBackground;
    HRESULT _hrRet;
    HDPA _hdpaPending; // list of refs to SHCNE_CREATEd items while we were enumerating
};


class CDUIView;

#ifdef _X86_
//
//  App compat bug 90885.
//
//  Hijaak 5.0 grovels through the CDefView class looking for the
//  IShellBrowser (whose value it learned from CWM_GETISHELLBROWSER).
//  It then assumes that the field right in front of the IShellBrowser
//  is the IShellFolder.  Unfortunately, since we derive from
//  CObjectWithSite and the browser is our site, they accidentally
//  find the copy inside CObjectWithSite and then treat CObjectWithSite's
//  vtbl as if were an IShellFolder.  They then crash, taking the process
//  with it.  Said process anybody who instantiates a DefView, like Explorer.
//  Or anybody who uses a common dialog, which is pretty much everybody.
//
//  Here's the dummy IShellFolder-like object we give them.
//
extern const LPVOID c_FakeHijaakFolder;

//
//  And here's the class that ensures that the dummy IShellFolder
//  comes right before the IShellBrowser.  This replaces the
//  problematic CObjectWithSite.
//
class CHijaakObjectWithSite : public IObjectWithSite {
public:
    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite) {
        IUnknown_Set(&_punkSite, punkSite);
        return S_OK;
    }
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite) {
        if (_punkSite)
            return _punkSite->QueryInterface(riid, ppvSite);
        *ppvSite = NULL;
        return E_FAIL;
    }

    CHijaakObjectWithSite() : _psfHijaak(&c_FakeHijaakFolder) { }
    ~CHijaakObjectWithSite() {ATOMICRELEASE(_punkSite);}

    const LPVOID *_psfHijaak;
    IShellBrowser *_psb;
    IUnknown *_punkSite;
};

#endif

#define SWITCHTOVIEW_BOTH        0x0
#define SWITCHTOVIEW_NOWEBVIEW   0x1
#define SWITCHTOVIEW_WEBVIEWONLY 0x2

//
// Class definition of CDefView
//
class CDefView : // dsv
    public IShellView2,
    public IFolderView,
    public IShellFolderView,
    public IOleCommandTarget, // so psb can talk to extended views
    public IDropTarget,
    public IViewObject,
    public IDefViewFrame,   // TODO: remove - currently only used by shell\ext\ftp
    public IDefViewFrame3,
    public IServiceProvider,
    public IDocViewSite,
    public IInternetSecurityMgrSite,
    public IPersistIDList,
    public IDVGetEnum,
#ifdef _X86_
    public CHijaakObjectWithSite,
#else
    public CObjectWithSite,
#endif
    public IContextMenuSite,
    public IDefViewSafety,
    public IUICommandTarget,
    public CWVTASKITEM // webview implementation helper class
{
public:
    CDefView(IShellFolder *pshf, IShellFolderViewCB* psfvcb, IShellView* psvOuter);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellView
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP Refresh();
    STDMETHODIMP CreateViewWindow(IShellView *pPrev, LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prc, HWND *phWnd);
    STDMETHODIMP DestroyViewWindow();
    STDMETHODIMP UIActivate(UINT uState);
    STDMETHODIMP GetCurrentInfo(LPFOLDERSETTINGS lpfs);
    STDMETHODIMP TranslateAccelerator(LPMSG pmsg);
    STDMETHODIMP AddPropertySheetPages(DWORD dwReserved, LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam);
    STDMETHODIMP SaveViewState();
    STDMETHODIMP SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags);
    STDMETHODIMP GetItemObject(UINT uItem, REFIID riid, void **ppv);

    // IShellView2
    STDMETHODIMP GetView(SHELLVIEWID* pvid, ULONG uView);
    STDMETHODIMP CreateViewWindow2(LPSV2CVW2_PARAMS pParams);
    STDMETHODIMP HandleRename(LPCITEMIDLIST pidl);
    STDMETHODIMP SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt);

    // IFolderView
    STDMETHODIMP GetCurrentViewMode(UINT *pViewMode);
    STDMETHODIMP SetCurrentViewMode(UINT ViewMode);
    STDMETHODIMP GetFolder(REFIID ridd, void **ppv);
    STDMETHODIMP Item(int iItemIndex, LPITEMIDLIST *ppidl);
    STDMETHODIMP ItemCount(UINT uFlags, int *pcItems);
    STDMETHODIMP Items(UINT uFlags, REFIID riid, void **ppv);
    STDMETHODIMP GetSelectionMarkedItem(int *piItem);
    STDMETHODIMP GetFocusedItem(int *piItem);
    STDMETHODIMP GetItemPosition(LPCITEMIDLIST pidl, POINT* ppt);
    STDMETHODIMP GetSpacing(POINT* ppt);
    STDMETHODIMP GetDefaultSpacing(POINT* ppt);
    STDMETHODIMP GetAutoArrange();
    STDMETHODIMP SelectItem(int iItem, DWORD dwFlags);
    STDMETHODIMP SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags);

    // IShellFolderView
    STDMETHODIMP Rearrange(LPARAM lParamSort);
    STDMETHODIMP GetArrangeParam(LPARAM *plParamSort);
    STDMETHODIMP ArrangeGrid();
    STDMETHODIMP AutoArrange();
    STDMETHODIMP AddObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP GetObject(LPITEMIDLIST *ppidl, UINT uItem);
    STDMETHODIMP RemoveObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP GetObjectCount(UINT *puCount);
    STDMETHODIMP SetObjectCount(UINT uCount, UINT dwFlags);
    STDMETHODIMP UpdateObject(LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem);
    STDMETHODIMP RefreshObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP SetRedraw(BOOL bRedraw);
    STDMETHODIMP GetSelectedCount(UINT *puSelected);
    STDMETHODIMP GetSelectedObjects(LPCITEMIDLIST **pppidl, UINT *puItems);
    STDMETHODIMP IsDropOnSource(IDropTarget *pDropTarget);
    STDMETHODIMP GetDragPoint(POINT *ppt);
    STDMETHODIMP GetDropPoint(POINT *ppt);
    STDMETHODIMP MoveIcons(IDataObject *pDataObject);
    STDMETHODIMP SetItemPos(LPCITEMIDLIST pidl, POINT *ppt);
    STDMETHODIMP IsBkDropTarget(IDropTarget *pDropTarget);
    STDMETHODIMP SetClipboard(BOOL bMove);
    STDMETHODIMP SetPoints(IDataObject *pDataObject);
    STDMETHODIMP GetItemSpacing(ITEMSPACING *pSpacing);
    STDMETHODIMP SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB);
    STDMETHODIMP Select(UINT dwFlags);
    STDMETHODIMP QuerySupport(UINT * pdwSupport);
    STDMETHODIMP SetAutomationObject(IDispatch *pdisp);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
        { return _dvdt.DragEnter(pdtobj, grfKeyState, ptl, pdwEffect); }
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
        { return _dvdt.DragOver(grfKeyState, ptl, pdwEffect); }
    STDMETHODIMP DragLeave()
        { return _dvdt.DragLeave(); }
    STDMETHODIMP Drop(IDataObject *pdtobj,
                    DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { return _dvdt.Drop(pdtobj, grfKeyState, pt, pdwEffect); }

    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, int (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *, HDC,
        LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IDefViewFrame
    STDMETHODIMP GetShellFolder(IShellFolder **ppsf);

    // IDefViewFrame3
    STDMETHODIMP GetWindowLV(HWND * phwnd);
    STDMETHODIMP OnResizeListView();
    STDMETHODIMP ShowHideListView();
    STDMETHODIMP ReleaseWindowLV(void);
    STDMETHODIMP DoRename();

    // IContextMenuSite
    STDMETHODIMP DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID) {return E_NOTIMPL;}

    // IPersistIDList
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl) {return E_NOTIMPL;}
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl) { *ppidl = _GetViewPidl(); return *ppidl ? S_OK : E_FAIL;}
    
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IDocViewSite
    STDMETHODIMP OnSetTitle(VARIANTARG *pvTitle);

    // IDVGetEnum
    STDMETHODIMP SetEnumReadyCallback(PFDVENUMREADYBALLBACK pfn, void *pvData);
    STDMETHODIMP CreateEnumIDListFromContents(LPCITEMIDLIST pidlFolder, DWORD dwEnumFlags, IEnumIDList **ppenum);

    // IDefViewSafety
    STDMETHODIMP IsSafePage();

    // IUICommandTarget
    STDMETHODIMP get_Name(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszName);
    STDMETHODIMP get_Icon(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
    STDMETHODIMP get_Tooltip(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
    STDMETHODIMP get_State(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, UISTATE* puisState);
    STDMETHODIMP Invoke(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, IBindCtx *pbc);

    // Helper functions for IUICommandTarget implementation:
    IShellItemArray *_CreateSelectionShellItemArray(void);
    IShellItemArray* _GetFolderAsShellItemArray();
    HRESULT _CheckAttribs(IShellItemArray *psiItemArray, DWORD dwAttribMask, DWORD dwAttribValue, UISTATE* puisState);
    HRESULT _GetFullPathNameAt(IShellItemArray *psiItemArray,DWORD dwIndex,LPOLESTR *pszPath);
    static HRESULT _CanWrite(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanRename(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanMove(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanCopy(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPublish(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanShare(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanEmail(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static BOOL    _DoesStaticMenuHaveVerb(IShellItemArray *psiItemArray, LPCWSTR pszVerb);
    static HRESULT _CanPrint(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _HasPrintVerb(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanDelete(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    BOOL _IsSystemDrive(void);
    static HRESULT _CanViewDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanHideDrives(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanViewFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanHideFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    HRESULT _DoVerb(IShellItemArray *psiItemArray, LPCSTR pszVerbA);
    HRESULT _DoDropOnClsid(REFCLSID clsidDrop,IDataObject* pdo);
    static HRESULT _OnNewFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnRename(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnMove(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCopy(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPublish(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShare(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnEmail(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPrint(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnDelete(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    HRESULT RemoveBarricade (void);
    static HRESULT _OnView(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnHide(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSearchFiles(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    const WVTASKITEM* _FindTaskItem(REFGUID guidCanonicalName);

    DWORD _DefaultColumnState(UINT iCol);
    BOOL _IsColumnHidden(UINT iCol);
    BOOL _IsColumnInListView(UINT iCol);
    BOOL _IsDetailsColumn(UINT iCol);
    BOOL _IsTileViewColumn(UINT iCol);
    HRESULT AddColumnsToMenu(HMENU hm, DWORD dwBase);
    UINT _RealToVisibleCol(UINT uRealCol);
    UINT _VisibleToRealCol(UINT uVisCol);

    // handle messages
    LRESULT _OnCreate(HWND hWnd);
    LRESULT _OnNotify(NMHDR *pnm);
    LRESULT _TBNotify(NMHDR *pnm);
    LRESULT _OnLVNotify(NM_LISTVIEW *plvn);
    LRESULT _OnBeginDrag(NM_LISTVIEW *pnm);

    int _FindItem(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFound, BOOL fSamePtr, BOOL fForwards = TRUE);
    int _FindItemHint(LPCITEMIDLIST pidl, int iItem);
    int _FindGroupItem(LPITEMIDLIST pidl);
    int _UpdateObject(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew);
    void _AddOrUpdateItem(LPCITEMIDLIST pidlOld, LPITEMIDLIST pidlNew);
    int _RefreshObject(LPITEMIDLIST *ppidl);
    int _RemoveObject(LPCITEMIDLIST pidl, BOOL fSamePtr);
    BOOL _GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt);
    BOOL _IsPositionedView();

    void _OnGetInfoTip(NMLVGETINFOTIP *plvn);

    void _OnRename(LPCITEMIDLIST* ppidl);
    LPITEMIDLIST _ObjectExists(LPCITEMIDLIST pidl, BOOL fGlobal);
    UINT _GetExplorerFlag();

    // private stuff
    void PropagateOnViewChange(DWORD dwAspect, LONG lindex);
    void PropagateOnClose();
    BOOL OnActivate(UINT uState);
    BOOL OnDeactivate();
    BOOL HasCurrentViewWindowFocus();
    HWND ViewWindowSetFocus();
    void _OnWinIniChange(WPARAM wParam, LPCTSTR pszSection);
    void _OnWinIniChangeDesktop(WPARAM wParam, LPCTSTR pszSection);
    void _SetFolderColors();
    DWORD _LVStyleFromView();
    DWORD _LVExStyleFromView();
    UINT _UxGetView();
    BOOL _IsReportView();
    BOOL _GetColorsFromHTMLdoc(COLORREF *clrTextBk, COLORREF *clrHotlight);
    void _SetFocus();
    void _UpdateUnderlines();
    void _SetSysImageList();
    void _SetTileview();
    void _BestFit();
    UINT _ValidateViewMode(UINT uViewMode);
    UINT _GetDefaultViewMode();
    void _GetDeferredViewSettings(UINT* puViewMode);
    HRESULT _SelectAndPosition(int iItem, UINT uFlags, POINT *ppt);
    HRESULT _Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    inline BOOL _IsOwnerData();
    BOOL _IsDesktop();
    inline BOOL _IsCommonDialog();
    BOOL _IsListviewVisible();
    HRESULT _IncludeObject(LPCITEMIDLIST pidl);
    HRESULT _OnDefaultCommand();
    HRESULT _OnStateChange(UINT code);

    int _AddObject(LPITEMIDLIST pidl);
    void _UpdateImage(int iImage);
    void _DismissEdit();
    void _OnInitMenu();
    HRESULT _ForwardMenuMessages(DWORD dwID, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL* pfHandled);
    void _RemoveThumbviewTasks();
    HRESULT _AddTask(IRunnableTask *pTask, REFTASKOWNERID rTID, DWORD_PTR lParam, DWORD dwPriority, DWORD grfFlags);
    HRESULT _ExplorerCommand(UINT idFCIDM);
    LRESULT _OnMenuSelect(UINT id, UINT mf, HMENU hmenu);
    HRESULT _AutoAutoArrange(DWORD dwReserved);


    // Infotip Methods (public)
    //
    HRESULT PreCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool);                                          // ui thread
    HRESULT PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam);      // bg thread
    HRESULT PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPCWSTR pwszInfotip, LPARAM lParam);                       // bg thread
    HRESULT CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam);// ui thread
    HRESULT CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, LPCWSTR pwszInfotip, LPARAM lParam);         // ui thread
    HRESULT DestroyInfotip(HWND hwndContaining, UINT_PTR uToolID);                                                              // ui thread
    HRESULT RepositionInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool);                                         // ui thread
    HRESULT RelayInfotipMessage(HWND hwndFrom, UINT uMsg, WPARAM wParam, LPARAM lParam);                                        // ui thread

    // Menu Methods (public)
    //
    void RecreateMenus();
    void InitViewMenu(HMENU hmInit);

    // Toolbar Methods (public)
    //
    void EnableToolbarButton(UINT uiCmd, BOOL bEnable);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);

    int CheckCurrentViewMenuItem(HMENU hmenu);
    void CheckToolbar();
    void OnListViewDelete(int iItem, LPITEMIDLIST pidl, BOOL fCallCB);
    void HandleKeyDown(LV_KEYDOWN *lpnmhdr);
    void AddColumns();
    void _ShowControl(UINT uControl, int idCmd);
    LRESULT _OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu);
    void _SetUpMenus(UINT uState);
    void SelectPendingSelectedItems();
    inline BOOL _ItemsDeferred();
    void _ClearPendingSelectedItems();
    void AddCopyHook();
    int FindCopyHook(BOOL fRemoveInvalid);
    void RemoveCopyHook();
private:
    HRESULT _DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt, BOOL fListviewItem);
public:
    void ContextMenu(DWORD dwPos);
    LPITEMIDLIST _GetViewPidl(); // return copy of pidl of folder we're viewing
    BOOL _IsViewDesktop();
    BOOL _GetPath(LPTSTR pszPath);
    HRESULT _GetNameAndFlags(UINT gdnFlags, LPTSTR psz, UINT cch, DWORD *pdwFlags);
    BOOL _CachedIsCustomizable();

    LRESULT _OnDefviewEditCommand(UINT uID);
    HRESULT _DoMoveOrCopyTo(REFCLSID clsid,IShellItemArray *psiItemArray);
    void _OnSetWebView(BOOL fOn);
    LRESULT _OnCommand(IContextMenu *pcmSel, WPARAM wParam, LPARAM lParam);
    BOOL _OnAppCommand(UINT cmd, UINT uDevice, DWORD dwKeys);
    LRESULT WndSize(HWND hWnd);
    void FillDone();
    void OnLVSelectionChange(NM_LISTVIEW *plvn);
    void _OnLVSelectionChange(int iItem, UINT uOldState, UINT uNewState, LPARAM lParam);
    void RegisterSFVEvents(IUnknown * pTarget, BOOL fConnect);

    HRESULT FillObjectsShowHide(BOOL fInteractive);

    HRESULT _GetDetailsHelper(int i, DETAILSINFO *pdi);
    HRESULT CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL HasCB() 
    {
        return _cCallback.HasCB(); 
    }
    HRESULT _FireEvent(DISPID dispid);
    void _CallRefresh(BOOL fPreRefresh);

    void _PostSelectionChangedMessage(UINT);
    void _OnSelectionChanged();
    void _OnDelayedSelectionChange();
    
    void _PostNoItemStateChangedMessage();
    void _OnNoItemStateChanged();

    void _PostEnumDoneMessage();
    void _PostFillDoneMessage();
    void _OnEnumDoneMessage();

    void _OnContentsChanged();
    void _OnDelayedContentsChanged();

    void _FixupColumnsForTileview(UINT *rguColumns, UINT cColumns);
    HRESULT _PeekColumnsCache(PTSTR pszPath, LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns);
    HRESULT _GetImportantColumns(LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns);
    void _SetImportantColumns(CBackgroundTileInfo *pDVTileInfo);
    
    void _SetView(UINT fvm);
    
    HRESULT _ReloadListviewContent();
    HRESULT _ReloadContent(BOOL fForce = FALSE);

    BOOL _IsImageMode(UINT fvm)
        {return (fvm == FVM_THUMBNAIL) || (fvm == FVM_THUMBSTRIP); }
    BOOL _IsImageMode()
        {return (_fs.ViewMode == FVM_THUMBNAIL) || (_fs.ViewMode == FVM_THUMBSTRIP); }
    BOOL _IsTileMode(UINT fvm)
        { return (fvm == FVM_TILE); }
    inline BOOL _IsTileMode()
        { return (_fs.ViewMode == FVM_TILE); }
    BOOL _IsAutoArrange()
        { return ((_fs.fFlags & FWF_AUTOARRANGE) || (_fs.ViewMode == FVM_THUMBSTRIP)); }

    HRESULT _GetWebViewMoniker(LPWSTR pszMoniker, DWORD cchMoniker);
    HRESULT _SwitchToWebView(BOOL bShow);
    HRESULT _GetDefaultWebviewContent(BOOL bForFileFolderTasks);
    void _FreeWebViewContentData();
    BOOL _QueryBarricadeState();
    HRESULT _TryShowWebView(UINT fvmNew, UINT fvmOld);
    HRESULT _TryHideWebView();
    HRESULT _SwitchToViewFVM(UINT fvmNew, UINT uiType = SWITCHTOVIEW_BOTH);
    void _ShowThemeWatermark();
    void _ShowLegacyWatermark();
    void _SetThemeWatermark();
    void _SetLegacyWatermark(LPCTSTR pszLegacyWatermark);
    void _UpdateListviewColors();
    LRESULT _SwitchDesktopHTML(BOOL fShow);
    void InitSelectionMode();
    void _UpdateSelectionMode();

    void _OnMoveWindowToTop(HWND hwnd);

    HWND GetChildViewWindow();
    BOOL _InvokeCustomization();

    HRESULT _OnViewWindowActive();
    void _UpdateRegFlags();

    void _DoColumnsMenu(int x, int y);
    BOOL _HandleColumnToggle(UINT uCol, BOOL bRefresh);
    void _AddColumnToListView(UINT uCol, UINT uColVis);

    void _SameViewMoveIcons();
    void _MoveSelectedItems(int dx, int dy, BOOL fAbsolute);

    void _AddTileColumn(UINT uCol);
    void _RemoveTileColumns();
    void _ResetTileInfo(UINT uColVis, BOOL bAdded);
    void _RemoveTileInfo();

    HRESULT _GetIPersistHistoryObject(IPersistHistory **ppph);

    HRESULT _GetStorageStream(DWORD grfMode, IStream* *ppIStream);
    HRESULT _SaveGlobalViewState(void);
    HRESULT _LoadGlobalViewState(IStream* *ppIStream);
    HRESULT _ResetGlobalViewState(void);
    LPCITEMIDLIST _GetPIDL(int i);
    LPCITEMIDLIST _GetPIDLParam(LPARAM lParam, int i);
    int _HitTest(const POINT *ppt, BOOL fIgnoreEdge = FALSE);
    void _AlterEffect(DWORD grfKeyState, DWORD *pdwEffect, UINT uFlags);
    BOOL _IsDropOnSource(IDropTarget *pdtgt);
    BOOL _IsBkDropTarget(IDropTarget *pdtgt);
    BOOL _GetDropPoint(POINT *ppt);
    BOOL _GetInsertPoint(POINT *ppt);
    BOOL _GetDragPoint(POINT *ppt);
    void _GetToolTipText(UINT_PTR id, LPTSTR pszText, UINT cchText);
    void _GetCBText(UINT_PTR id, UINT uMsgT, UINT uMsgA, UINT uMsgW, LPTSTR psz, UINT cch);
    void _GetMenuHelpText(UINT_PTR id, LPTSTR pszText, UINT cchText);
    void _SetItemPos(LPSFV_SETITEMPOS psip);
    void _FullViewUpdate(BOOL fUpdateItem);
    void _UpdateEnumerationFlags();
    void _SetItemPosition(int i, int x, int y);


    void _GlobeAnimation(BOOL fStartSpinning, BOOL fForceStop = FALSE);

    void _PaintErrMsg(HWND hWnd);
    void _SetPoints(UINT cidl, LPCITEMIDLIST *apidl, IDataObject *pdtobj);
    BOOL _GetItemSpacing(ITEMSPACING *pis);
    LRESULT _OnSetClipboard(BOOL bMove);
    LRESULT _OnClipboardChange();

    void _RestoreAllGhostedFileView();
    BOOL _ShouldShowWebView();
    void _ShowViewEarly();
    BOOL _SetupNotifyData();

    DWORD _GetEnumFlags();

    // Arrange
    BOOL _InitArrangeMenu(HMENU hmenuCtx);
    BOOL _ArrangeBy(UINT idCmd);
    BOOL _InitExtendedGroups(ICategoryProvider* pcp, HMENU hmenuCtx, int iIndex, int* piIdToCheck);

    // Grouping
    void _ToggleGrouping();
    void _GroupBy(int iColumn);
    BOOL _IsSlowGroup(const GUID *pguid);
    BOOL _CategorizeOnGUID(const GUID* pguid, const SHCOLUMNID* pscid);
    BOOL _CategorizeOnSCID(const SHCOLUMNID* pscid);
    void _OnCategoryTaskAdd();
    void _OnCategoryTaskDone();
    DWORD _GetGroupForItem(int iItem, LPCITEMIDLIST pidl);
    BOOL _LoadCategory(GUID *pguidGroupID);

    HRESULT _OnRearrange(LPARAM lParamSort, BOOL fAllowToggle);

    // Thumbnail Support
    HRESULT ExtractItem(UINT *puIndex, int iItem, LPCITEMIDLIST pidl, BOOL fBackground, BOOL fForce, DWORD dwMaxPriority);
    DWORD _GetOverlayMask(LPCITEMIDLIST pidl);
    HRESULT UpdateImageForItem(DWORD dwTaskID, HBITMAP hImage, int iItem, LPCITEMIDLIST pidl,
                               LPCWSTR pszPath, FILETIME ftDateStamp, BOOL fCache, DWORD dwPriority);
    HRESULT _SafeAddImage(BOOL fQuick, IMAGECACHEINFO* prgInfo, UINT* piImageIndex, int iListID);
    HRESULT TaskUpdateItem(LPCITEMIDLIST pidl, int iItem, DWORD dwMask, LPCWSTR pszPath,
                           FILETIME ftDateStamp, int iThumbnail, HBITMAP hBmp, DWORD dwItemID);

    void _UpdateThumbnail(int iItem, int iImage, LPCITEMIDLIST pidl);
    void _CleanupUpdateThumbnail(DSV_UPDATETHUMBNAIL* putn);
    COLORREF _GetBackColor();
    void _CacheDefaultThumbnail(LPCITEMIDLIST pidl, int* piIcon);
    HRESULT _CreateOverlayThumbnail(int iIndex, HBITMAP* phbmOverlay, HBITMAP* phbmMask);
    int _MapIndexPIDLToID(int iIndex, LPCITEMIDLIST pidl);
    int _MapIDToIndex(int iID);
    void _ThumbnailMapInit();
    void _ThumbnailMapClear();

    void _SetThumbview();
    void _ResetThumbview();
    void _GetThumbnailSize(SIZE *psize);

    BOOL _IsUsingFullIconSelection();

    int _IncrementWriteTaskCount();
    int _DecrementWriteTaskCount();
    HRESULT CreateDefaultThumbnail(int iIndex, HBITMAP * phBmpThumbnail, BOOL fCorner);
    int ViewGetIconIndex(LPCITEMIDLIST pidl);
    ULONG _ApproxItemsPerView();
    void _DoThumbnailReadAhead();
    HRESULT _GetDefaultTypeExtractor(LPCITEMIDLIST pidl, IExtractImage **ppExt);
    DWORD _Attributes(LPCITEMIDLIST pidl, DWORD dwAttribs);
    HRESULT _EnumThings(UINT uWhat, IEnumIDList **ppenum);
    void _ClearPostedMsgs(HWND hwnd);

    HDPA _dpaThumbnailMap;
    IShellImageStore* _pDiskCache;
    IImageCache3* _pImageCache;
    DWORD _dwRecClrDepth;
    int _iMaxCacheSize;
    int _iWriteTaskCount;
    SIZE _sizeThumbnail;
    HPALETTE _hpalOld;
    COLORREF _rgbBackColor;
    ULONG_PTR _tokenGdiplus;
    
    HRESULT _GetBrowserPalette(HPALETTE* phpal);
    
    LONG _cRef;
    CDVDropTarget           _dvdt;
    CViewState              _vs;
    IShellView              *_psvOuter;          // May be NULL
    IShellFolder            *_pshf;
    IShellFolder2           *_pshf2;
    IShellFolder            *_pshfParent;
    IShellFolder2           *_pshf2Parent;
    LPITEMIDLIST            _pidlRelative;
    LPITEMIDLIST            _pidlSelectAndPosition;
    UINT                    _uSelectAndPositionFlags;
#ifndef _X86_
    // In the _X86_ case, the _psb is inside the CHijaakObjectWithSite
    IShellBrowser           *_psb;
#endif
    ICommDlgBrowser         *_pcdb;             // extended ICommDlgBrowser
    FOLDERSETTINGS          _fs;
    IContextMenu            *_pcmSel;           // pcm for selected objects.
    IContextMenu            *_pcmFile;          // this is for the File menu only (you can't re-use a contextmenu once QueryContextMenu has been called)
    IContextMenu            *_pcmContextMenuPopup; // pcm for TrackPopupMenu usage
    IShellItemArray         *_pSelectionShellItemArray;        // selection object for the current selection
    IShellItemArray         *_pFolderShellItemArray;       // shellItemArray for this folder.
    IShellIcon              *_psi;               // for getting icon fast
    IShellIconOverlay       *_psio;              // For getting iconOverlay fast
    CLSID                   _clsid;             // the clsid of this pshf;

    ICategorizer*           _pcat;
    HDSA                    _hdaCategories;
    int                     _iLastFoundCat;
    int                     _iIncrementCat;

    HWND                    _hwndMain;
    HWND                    _hwndView;
    HWND                    _hwndListview;
    HWND                    _hwndInfotip;    // infotip control
    HWND                    _hwndStatic;
    HACCEL                  _hAccel;
    int                     _fmt;

    UINT                    _uState;         // SVUIA_*
    HMENU                   _hmenuCur;

    ULONG                   _uRegister;

    POINT                   _ptDrop;

    POINT                   _ptDragAnchor;   // start of the drag
    int                     _itemCur;        // The current item in the drop target

    IDropTarget             *_pdtgtBack;     // of the background (shell folder)

    IShellDetails           *_psd;
    UINT                    _cxChar;

    LPCITEMIDLIST           _pidlMonitor;
    LONG                    _lFSEvents;

    TBBUTTON*               _pbtn;
    int                     _cButtons;          // count of buttons that are showing by default
    int                     _cTotalButtons;     // count of buttons including those hidden by default

    IShellTaskScheduler2    *_pScheduler;

    CDUIView                *_pDUIView;

    BITBOOL     _fSlowGroup:1;
    BITBOOL     _fInBackgroundGrouping: 1;
    
    BITBOOL     _bDragSource:1;
    BITBOOL     _bDropAnchor:1;

    BITBOOL     _fUserPositionedItems:1;

    BITBOOL     _bHaveCutStuff:1;
    BITBOOL     _bClipViewer:1;

    BITBOOL     _fShowAllObjects:1;
    BITBOOL     _fInLabelEdit:1;
    BITBOOL     _fDisabled:1;

    BITBOOL     _bBkFilling:1;

    BITBOOL     _bContextMenuMode:1;
    BITBOOL     _bMouseMenu:1;
    BITBOOL     _fHasDeskWallPaper:1;

    BITBOOL     _fShowCompColor:1;

    BITBOOL     _bRegisteredDragDrop:1;

    BITBOOL     _fEnumFailed:1;    // TRUE if enum failed.

    BITBOOL     _fGetWindowLV:1;    // DVOC has grabbed the listview (it set the owner, repositioned it)

    BITBOOL     _fClassic:1; // SSF_WIN95CLASSIC setting/restriction

    BITBOOL     _fCombinedView:1;   // Implies a regional listview layered on top of an extended view (the desktop with AD on)
    BITBOOL     _fCycleFocus:1;     // 1=got callback to do CycleFocus

    BITBOOL     _fSelectionChangePending:1;
    BITBOOL     _fNoItemStateChangePending:1;
    BITBOOL     _fCanActivateNow:1; // FALSE from creation until we can be activated, TRUE implies we can SHDVID_CANACTIVATENOW
    BITBOOL     _fWin95ViewState:1;         // TRUE iff Advanced option set to Win95 behavior
    BITBOOL     _fDesktopModal:1;           // TRUE iff desktop is in modal state.
    BITBOOL     _fDesktopRefreshPending:1;  // TRUE iff a refresh of desktop was prevented because of modal state.
    BITBOOL     _fRefreshBuffered:1;        // TRUE iff a buffered refresh is pending!
    BITBOOL     _fHasListViewFocus:1;
    BITBOOL     _bLoadedColumns:1;          // TRUE after we've loaded cols from the savestream. (after we're switched to details)
    BITBOOL     _fIsAsyncDefView:1;         // TRUE if Defview is Asynchronous
    // Combined view colors that can be specified via registry or desktop.ini

    BITBOOL     _bAutoSelChangeTimerSet:1;  // indicates if the timer to send the sel change notification to the automation obj is set

    BITBOOL     _fDestroying:1; // DestroyViewWindow was called
    BITBOOL     _fIgnoreItemChanged: 1;
    BITBOOL     _fReadAhead: 1;
    BITBOOL     _fGroupView: 1;
    BITBOOL     _fActivateLV: 1;    // Indicates that we have to activate the
                                    // listview rather than defview (the webview case)
    BITBOOL     _fAllowSearchingWindow: 1;   // use "searching" window, used for user-initiated enum (and first enum)
    BITBOOL     _fSyncOnFillDone: 1;    // set when _vs is valid for us to re-sync position information
    BITBOOL     _fListViewShown: 1; // TRUE iff _hwndListview is shown
    BITBOOL     _fListviewRedraw: 1; // TRUE iff WM_REDRAW(FALSE) on _hwndListview, for listview hack work-around
    BITBOOL     _fQueryWebViewData: 1; // TRUE iff SFVM_WEBVIEW_CONTENT_DATA has been queried

    BITBOOL     _fGlobeCanSpin:1; // Spinning globe implies navigation, only allow it to spin when the view is first created
    BITBOOL     _fPositionRecycleBin:1; // TRUE iff desktop AND clean install.

    BITBOOL     _fScrolling:1;  // We are currently scrolling
    BITBOOL     _fRequestedTileDuringScroll:1; // Indicates we request tile column information while scrolling
    BITBOOL     _fSetTileViewSortedCol:1; // Indicates we have set the tileview sorted column
    BITBOOL     _fBackgroundStatusTextValid:1;  // Is the background statusbar text still valid.
    BITBOOL     _fUserRejectedWebViewTemplate:1;

    DWORD       _crefGlobeSpin; // so the different components that want to keep the globe spinning can reference count it
    DWORD       _crefSearchWindow; // so the different components that want to keep the "searching" window up can reference count it

    COLORREF    _crCustomColors[CRID_COLORCOUNT];
    UINT        _idThemeWatermark;
    LPTSTR      _pszLegacyWatermark;

    // for single click activation
    DWORD       _dwSelectionMode;

    HWND        _hwndNextViewer;

    LRESULT     _iStdBMOffset;
    LRESULT     _iViewBMOffset;

    CCallback   _cCallback;    // Optional client callback

    HDSA        _hdsaSelect;    // List of items that are selected.

    HDSA        _hdsaSCIDCache; // Cache the SCIDs so we can map SCID to column# (tileview)

    int         _iLastFind;

    UINT        _uDefToolbar;
    CSFVFrame   _cFrame;

    ULONG       _uCachedSelAttrs;
    UINT        _uCachedSelCount;

    UINT        _uSelectionStateChanged; // selection/focus change bits for _fSelectionChangePending
    UINT        _uAutoSelChangeState;    // selection/focus change bits for _bAutoSelChangeTimerSet

    DWORD       _dwConnectionCookie;

    CBackgroundInfoTip *  _pBackgroundInfoTip;          // Used for the background InfoTip
    CDefviewEnumTask *    _pEnumTask;

    DWORD                   _dwProffered;               // Cookie for the SID_SFolderView service proffered
    PFDVENUMREADYBALLBACK   _pfnEnumReadyCallback;      // Callback indicating that our enum is done and that the client
                                                        // can now get the IEnumIDList
    void *                  _pvEnumCallbackData;

    IUIElement*                   _pOtherPlacesHeader;
    IUIElement*                   _pDetailsHeader;
    SFVM_WEBVIEW_LAYOUT_DATA      _wvLayout;  // layout can change on view mode changes
    SFVM_WEBVIEW_CONTENT_DATA     _wvContent; // content that is static per folder
    SFVM_WEBVIEW_TASKSECTION_DATA _wvTasks;   // content that can change when selection changes
    SFVM_WEBVIEW_THEME_DATA       _wvTheme;   // HACK: theme info
    BOOL                          _fBarrierDisplayed; // TRUE if the soft barrier is currently being displayed
    BOOL                          _fRcvdContentsChangeBeforeDuiViewCreated;


#ifdef DEBUG
    TIMEVAR(_Update);
    TIMEVAR(_Fill);
    TIMEVAR(_GetIcon);
    TIMEVAR(_GetName);
    TIMEVAR(_FSNotify);
    TIMEVAR(_AddObject);
    TIMEVAR(_EnumNext);
    TIMEVAR(_RestoreState);
    TIMEVAR(_WMNotify);
    TIMEVAR(_LVChanging);
    TIMEVAR(_LVChanged);
    TIMEVAR(_LVDelete);
    TIMEVAR(_LVGetDispInfo);
#endif

public:     // TODO: Make this protected after we have finished converting the entire file.
    BOOL IsSafeToDefaultVerb(void);
    HRESULT _InvokeContextMenuVerb(IContextMenu* pcm, LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask);
    HRESULT _InvokeContextMenuVerbOnSelection(LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask);
    HRESULT _InvokeContextMenu(IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici);
    void _LogDesktopLinksAndRegitems();
    void _FocusOnSomething(void);
    void _UpdateIcon(LPITEMIDLIST pidl, UINT iIcon);
    void _UpdateGroup(CBackgroundGroupInfo* pbggi);
    void _UpdateColData(CBackgroundColInfo *pbgci);
    void _UpdateOverlay(int iList, int iOverlay);
    HRESULT _GetIconAsync(LPCITEMIDLIST pidl, int *piIcon, BOOL fCanWait);
    HRESULT _GetOverlayIndexAsync(LPCITEMIDLIST pidl, int iList);
    DWORD _GetNeededSecurityAction(void);
    HRESULT _ZoneCheck(DWORD dwFlags, DWORD dwAllowAction);
    void _ShowAndActivate();
    void _RegisterWindow();
    static LRESULT CALLBACK s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI BackgroundDestroyWindow(void *pvData);

private:
    ~CDefView();

    // View Mode Methods (private)
    //
    BOOL _ViewSupported(UINT uView);
    void _ThumbstripSendImagePreviewFocusChangeEvent();

    // Infotip Methods (private)
    //
    typedef struct {
        HWND hwndContaining;
        UINT_PTR uToolID;
        RECT rectTool;
    } PENDING_INFOTIP;
    CList<PENDING_INFOTIP> _tlistPendingInfotips;
    HRESULT _FindPendingInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, BOOL bRemoveAndDestroy); // ui thread
    HRESULT _OnPostCreateInfotip(TOOLINFO *pti, LPARAM lParam);                                                   // ui thread
    HRESULT _OnPostCreateInfotipCleanup(TOOLINFO *pti);                                                           // ui thread or bg thread
    HWND    _CreateInfotipControl(HWND hwndParent);
    void    _InitInfotipControl(HWND hwndInfotip);

    // Menu Methods (private)
    //
    void _InitViewMenuWhenBarrierDisplayed(HMENU hmenuView);        // Initializes entire view menu (for barricaded view).
    void _InitViewMenuWhenBarrierNotDisplayed(HMENU hmenuView);     // Initializes entire view menu (for non-barricaded view).
    void _InitViewMenuViewsWhenBarrierNotDisplayed(HMENU hmenuView);// Initializes "view" subsection of view menu (for non-barricated view).
    void _MergeViewMenu(HMENU hmenuViewParent, HMENU hmenuMerge);   // Merges hmenuMerge into the view menu @ FCIDM_MENU_VIEW_SEP_OPTIONS

    // Toolbar Methods (private)
    //
    BOOL _ShouldEnableToolbarButton(UINT uiCmd, DWORD dwAttr, int iIndex);
    void _EnableToolbarButton(IExplorerToolbar *piet, UINT uiCmd, BOOL bEnable);
    void _EnableDisableTBButtons();

    void MergeToolBar(BOOL bCanRestore);
    BOOL _MergeIExplorerToolbar(UINT cExtButtons);
    void _CopyDefViewButton(PTBBUTTON ptbbDest, PTBBUTTON ptbbSrc);
    int _GetButtons(PTBBUTTON* ppbtn, LPINT pcButtons, LPINT pcTotalButtons);

    void _SetCachedToolbarSelectionAttrs(ULONG dwAttrs);
    BOOL _GetCachedToolbarSelectionAttrs(ULONG *pdwAttr);

    LRESULT _OnFSNotify(LONG lNotification, LPCITEMIDLIST* ppidl);

    static int CALLBACK _Compare(void *p1, void *p2, LPARAM lParam);
    HRESULT _Sort(void);
    UINT _GetBackgroundTaskCount(REFTASKOWNERID rtid);
    void _SetSortFeedback();
    BOOL GetViewState();
    DWORD _AttributesFromSel(DWORD dwAttrMask);
    HRESULT _GetSelectionDataObject(IDataObject **pdobjSelect);
    HRESULT _GetUIObjectFromItem(REFIID riid, void **ppv, UINT uItem, BOOL fSetPoints);
    HRESULT _GetItemObjects(LPCITEMIDLIST **ppidl, UINT uItem, UINT *pcItems);
    UINT _GetItemArray(LPCITEMIDLIST apidl[], UINT capidl, UINT uWhat);

    BOOL _AllowCommand(UINT uID);
    void _DoStatusBar(BOOL fInitialize);
    void _UpdateStatusBar(BOOL fInitialize);
    void _ShowSearchUI(BOOL fStartSearchWindow);
    HRESULT _OnStartBackgroundEnum();
    HRESULT _OnStopBackgroundEnum();
    HRESULT _OnBackgroundEnumDone();
    LRESULT _GetDisplayInfo(LV_DISPINFO *plvdi);
    UINT _GetHeaderCount();

    BOOL _EnsureSCIDCache();

    BOOL _MapSCIDToColumn(const SHCOLUMNID *pscid, UINT *pnColumn);

    HRESULT _GetSFVMViewState(UINT uViewMode, SFVM_VIEW_DATA* pvi);
    HRESULT _GetSFVMViewInfoTemplate(UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);

    int _CompareIDsDirection(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2);
    HRESULT _CompareIDsFallback(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2);
    int     _FreezeRecycleBin(LPPOINT ppt);
    void    _SetRecycleBinInDefaultPosition(POINT *ppt);
    void    _ClearItemPositions();

    static void CALLBACK _AsyncIconTaskCallback(LPCITEMIDLIST pidl, void *pvData, void *pvHint, INT iIconIndex, INT iOpenIconIndex);
    void _SetDefaultViewSettings();

    HRESULT _Create_BackgrndHMENU(BOOL fViewMenuOnly, REFIID riid, void **ppv);
    HRESULT _CBackgrndMenu_CreateInstance(REFIID riid, void **ppv);
    
    friend class CSFVSite;
    friend class CSFVFrame;
    friend class CBkgrndEnumTask;
    friend class CViewState;
    friend class CDefviewEnumTask;
    
    IDispatch *_pauto;                  // folder view automation object
    IAdviseSink *_padvise;              // advisory connection
    DWORD _advise_aspect;
    DWORD _advise_advf;

    // Is this folder customizable using a desktop.ini?
    // In other words, is this folder in a write-able media AND either it 
    // not have a desktop.ini OR if it is there, it is writeable!
    int   _iCustomizable;

    HRESULT _CreateSelectionContextMenu(REFIID riid, void** ppv);
    HRESULT _DoBulkRename(LPCITEMIDLIST pidlNewName);

    BOOL                    _bReEntrantReload;

    IPropertyUI *_ppui;
};

int CALLBACK GroupCompare(int iGroup1, int iGroup2, void *pvData);

// Called CSHRegKey because ATL already has a class called CRegKey.

class CSHRegKey
{
public:
    CSHRegKey(HKEY hkParent, LPCTSTR pszSubKey, BOOL bCreate=FALSE)
    {
        DebugMsg(TF_LIFE, TEXT("ctor CSHRegKey(%s) %x"), pszSubKey, this);
        if ((bCreate ? RegCreateKey(hkParent, pszSubKey, &_hk)
            : RegOpenKeyEx(hkParent, pszSubKey, 0, KEY_READ, &_hk))!=ERROR_SUCCESS)
        {
            _hk = NULL;
        }
    }
    CSHRegKey(HKEY hk) { DebugMsg(TF_LIFE, TEXT("ctor CSHRegKey %x"), this); _hk=hk; }
    ~CSHRegKey()
    {
        DebugMsg(TF_LIFE, TEXT("dtor CSHRegKey %x"), this);
        if (_hk) RegCloseKey(_hk);
    }

    operator HKEY() const { return(_hk); }
    operator !() const { return(_hk==NULL); }

    HRESULT QueryValue(LPCTSTR szSub, LPTSTR pszVal, LONG cb)
        { return(SHRegQueryValue(_hk, szSub, pszVal, &cb)); }

    HRESULT QueryValueEx(LPCTSTR szSub, LPBYTE pszVal, LONG cb)
        { return(SHQueryValueEx(_hk, szSub, 0, NULL, pszVal, (LPDWORD)&cb)); }

private:
    HKEY _hk;
};

class CColumnDlg
{
public:
    CColumnDlg(CDefView *pdsv);
    ~CColumnDlg();

    HRESULT ShowDialog(HWND hwnd);

private:
    void _OnInitDlg();
    BOOL _SaveState();
    void _MoveItem(int iDelta);
    void _UpdateDlgButtons(NMLISTVIEW *pnmlv);
    UINT _HelpIDForItem(int iItem, LPTSTR pszHelpFile, UINT cch);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);

    CDefView *_pdsv;

    IPropertyUI *_ppui;

    HWND _hdlg;
    HWND _hwndLVAll;
    UINT _cColumns;
    UINT *_pdwOrder;
    int *_pWidths;
    BOOL _bChanged;
    BOOL _bLoaded;
    BOOL _bUpdating;    // used to block notification processing while we're updating

    static BOOL_PTR CALLBACK s_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
};


// Thumbnail helpers
void ListView_InvalidateImageIndexes(HWND hwndList);

#define DEFVIEW_LISTCALLBACK_FLAGS (LVIF_TEXT | LVIF_IMAGE | LVIF_GROUPID | LVIF_COLUMNS)

#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define PRIORITY_M5         (PRIORITY_NORMAL - 5 * 0x1000)
#define PRIORITY_M4         (PRIORITY_NORMAL - 4 * 0x1000)
#define PRIORITY_M3         (PRIORITY_NORMAL - 3 * 0x1000)
#define PRIORITY_M2         (PRIORITY_NORMAL - 2 * 0x1000)
#define PRIORITY_M1         (PRIORITY_NORMAL - 1 * 0x1000)
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define PRIORITY_P1         (PRIORITY_NORMAL + 1 * 0x1000)
#define PRIORITY_P2         (PRIORITY_NORMAL + 2 * 0x1000)
#define PRIORITY_P3         (PRIORITY_NORMAL + 3 * 0x1000)
#define PRIORITY_P4         (PRIORITY_NORMAL + 4 * 0x1000)
#define PRIORITY_P5         (PRIORITY_NORMAL + 5 * 0x1000)

// The following should be used as returns from GetLocation
#define PRIORITY_EXTRACT_FAST       PRIORITY_P1
#define PRIORITY_EXTRACT_NORMAL     PRIORITY_NORMAL
#define PRIORITY_EXTRACT_SLOW       PRIORITY_M1

// The following are some basis for background tasks
#define PRIORITY_IMAGEEXTRACT       PRIORITY_EXTRACT_NORMAL
#define PRIORITY_READAHEAD_EXTRACT  PRIORITY_M2
#define PRIORITY_READAHEAD          PRIORITY_M3
#define PRIORITY_UPDATEDIR          PRIORITY_M3
#define PRIORITY_CACHETIDY          PRIORITY_M4

// The following are some increments used for subtasks in image extraction
// They are used to alter the priorities above as in these examples, such that
// disk cache hits are faster than extracts which are faster than cache writes:
//     A fast image extract (3 tasks):
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_DISKCACHE == 0x10000010
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_EXTRACT   == 0x0FFFFF10
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_WRITE     == 0x0FFFFED0
//     A slow folder extract (2 tasks):
//         PRIORITY_IMAGEEXTRACT - PRIORITY_DELTA_SLOW - PRIORITY_DELTA_DISKCACHE == 0x0FFFFFB0
//         PRIORITY_IMAGEEXTRACT - PRIORITY_DELTA_SLOW - PRIORITY_DELTA_EXTRACT   == 0x0FFFFEB0
//     Notice that tasks are done in correct priority order
#define PRIORITY_DELTA_DISKCACHE    0x00000000  // This has to be the fastest task...
#define PRIORITY_DELTA_EXTRACT      0x00000100  // We want Extract to be second for most cases
#define PRIORITY_DELTA_WRITE        0x00000140  // Write tasks should be after all but the slowest extract tasks
#define PRIORITY_DELTA_FAST         0x00000010
#define PRIORITY_DELTA_SLOW         0x00000050

// Flags for _AddTask
#define ADDTASK_ATFRONT             0x00000001
#define ADDTASK_ATEND               0x00000002
#define ADDTASK_ONLYONCE            0x00000004

//
// define MAX_ICON_WAIT to be the most (in ms) we will ever wait for a
// icon to be extracted.

// define MIN_ICON_WAIT to be amount of time that has to go by
// before we start waiting again.

#define MAX_ICON_WAIT       500
#define MIN_ICON_WAIT       2500
// PRIORITIES for tasks added to the DefView background task scheduler
#define TASK_PRIORITY_BKGRND_FILL   ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_GET_ICON      ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_FILE_PROPS    PRIORITY_M3             // This is for TileView columns, we don't want to hold icon extraction for this.
#define TASK_PRIORITY_INFOTIP       ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_GETSTATE      PRIORITY_M5             // This is not hi-pri: figuring out the task list.
#define TASK_PRIORITY_GROUP         PRIORITY_P1             // Needs to be higher than icon extraction. Happens after background fill

#define DEFVIEW_THREAD_IDLE_TIMEOUT     (1000 * 60 * 2)

#define DV_IDTIMER_START_ANI                     1   // start the animation (after we started bk enum)
#define DV_IDTIMER_BUFFERED_REFRESH              3
#define DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE   4
#define DV_IDTIMER_NOTIFY_AUTOMATION_NOSELCHANGE 5
#define DV_IDTIMER_DISKCACHE                     6
#define DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED 7
#define DV_IDTIMER_SCROLL_TIMEOUT                8

#define DEFSIZE_BORDER          10
#define DEFSIZE_VERTBDR         30
#define MAX_WRITECACHE_TASKS    256

#define WM_USER_DELAY_NAVIGATION    (WM_USER + 0x1BA)   // random - can be moved - used by DUI and CPL

INT ScaleSizeBasedUponLocalization (INT iSize);

#endif // _DEFVIEWP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defviewcoldlg.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "ids.h"

CColumnDlg::CColumnDlg(CDefView *pdsv) : 
    _pdsv(pdsv), _bChanged(FALSE), _pdwOrder(NULL), _pWidths(NULL), _bLoaded(FALSE), _bUpdating(FALSE), _ppui(NULL)
{
    _cColumns = _pdsv->_vs.GetColumnCount();
}

CColumnDlg::~CColumnDlg()
{
    if (_pdwOrder)
        LocalFree(_pdwOrder);
    if (_pWidths)
        LocalFree(_pWidths);

    if (_ppui)
        _ppui->Release();
}

HRESULT CColumnDlg::ShowDialog(HWND hwnd)
{
    _bChanged = FALSE;      // We are on the stack, so no zero allocator

    _pdwOrder = (UINT *) LocalAlloc(LPTR, sizeof(*_pdwOrder) * _cColumns);   // total columns
    _pWidths = (int *) LocalAlloc(LPTR, sizeof(*_pWidths) * _cColumns);      // total columns
    if (_pdwOrder && _pWidths)
    {
        DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_COLUMN_SETTINGS), hwnd, s_DlgProc, (LPARAM)this);
        return S_OK;
    } 
    return E_OUTOFMEMORY;
}

// Remember, each column is identified in 3 ways...
//   1. A 'real' column number, the ordinal out of all possible columns
//   2. A 'visible' column number, the index to this column in the listview
//   3. A 'column order #', the position in the header's columnorderarray

void CColumnDlg::_OnInitDlg()
{
    // Fill in order array with visible columns, and set up inverse table
    UINT cVisible = _pdsv->_RealToVisibleCol(-1) + 1;  // count

    ListView_GetColumnOrderArray(_pdsv->_hwndListview, cVisible, _pdwOrder);
    UINT *pOrderInverse = (UINT *)LocalAlloc(LPTR, sizeof(*pOrderInverse) * cVisible);
    if (pOrderInverse)
    {
        for (UINT i = 0; i < cVisible; i++)
            pOrderInverse[_pdwOrder[i]] = i;

        _hwndLVAll = GetDlgItem(_hdlg, IDC_COL_LVALL);
   
        ListView_SetExtendedListViewStyle(_hwndLVAll, LVS_EX_CHECKBOXES);

        LV_COLUMN lvc = {0};
        lvc.mask = (LVCF_FMT | LVCF_SUBITEM);
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(_hwndLVAll, 0, &lvc);

        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT;
    
        // Add entry for each column (except non-UI columns)
        for (i = 0; i < (int)_cColumns; i++)
        {
            if (!_pdsv->_IsColumnHidden(i))  // Don't put in entries for hidden columns
            {
                lvi.iItem = i;
                lvi.pszText = LPSTR_TEXTCALLBACK;
                ListView_InsertItem(_hwndLVAll, &lvi);
            }        
        }

        lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        // set the visible columns
        for (i = 0; i < (int) cVisible; i++)
        {
            UINT iReal = _pdsv->_VisibleToRealCol(i);

            lvi.pszText = _pdsv->_vs.GetColumnName(iReal);
            lvi.state = INDEXTOSTATEIMAGEMASK(_pdsv->_IsDetailsColumn(iReal) ? 2 : 1);  // on check mark (or off for tileview columns)
            lvi.stateMask = LVIS_STATEIMAGEMASK;
            lvi.lParam = iReal;                         // store the real col index in the lParam
            lvi.iItem = pOrderInverse[i];
            ListView_SetItem(_hwndLVAll, &lvi);

            // Get the column width from the view's listview
            _pWidths[iReal] = ListView_GetColumnWidth(_pdsv->_hwndListview, i);
        }

        UINT iItem = cVisible;
        for (i = 0; i < (int)_cColumns; i++)
        {
            if (!_pdsv->_IsColumnInListView(i) && !_pdsv->_IsColumnHidden(i))
            {
                lvi.pszText = _pdsv->_vs.GetColumnName(i);
                lvi.state = INDEXTOSTATEIMAGEMASK(1);   // off check mark
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                lvi.lParam = i;
                lvi.iItem = iItem;
                ListView_SetItem(_hwndLVAll, &lvi);

                iItem++;

                // get the default width we've got saved away
                _pWidths[i] = _pdsv->_vs.GetColumnCharCount(i) * _pdsv->_cxChar;
            }
        }

        // set the size properly
        ListView_SetColumnWidth(_hwndLVAll, 0, LVSCW_AUTOSIZE);

        ListView_SetItemState(_hwndLVAll, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        LocalFree(pOrderInverse);

        _bLoaded = TRUE;
    }
    SendDlgItemMessage(_hdlg, IDC_COL_WIDTH, EM_LIMITTEXT, 3, 0); // 3 digits
}

#define SWAP(x,y) {(x) ^= (y); (y) ^= (x); (x) ^= (y);}

void CColumnDlg::_MoveItem(int iDelta)
{
    int i = ListView_GetSelectionMark(_hwndLVAll);
    if (i != -1)
    {
        int iNew = i + iDelta;
        if (iNew >= 0  && iNew <= (ListView_GetItemCount(_hwndLVAll) - 1))
        {
            LV_ITEM lvi = {0}, lvi2 = {0};
            TCHAR szTmp1[MAX_COLUMN_NAME_LEN], szTmp2[MAX_COLUMN_NAME_LEN];

            _bChanged = TRUE;
            _bUpdating = TRUE;

            lvi.iItem = i;
            lvi.pszText = szTmp1;
            lvi.cchTextMax = ARRAYSIZE(szTmp1);
            lvi.stateMask = LVIS_STATEIMAGEMASK;
            lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            
            lvi2.iItem = iNew;
            lvi2.pszText = szTmp2;
            lvi2.cchTextMax = ARRAYSIZE(szTmp2);
            lvi2.stateMask = LVIS_STATEIMAGEMASK;
            lvi2.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;

            ListView_GetItem(_hwndLVAll, &lvi);
            ListView_GetItem(_hwndLVAll, &lvi2);

            SWAP(lvi.iItem, lvi2.iItem);

            ListView_SetItem(_hwndLVAll, &lvi);
            ListView_SetItem(_hwndLVAll, &lvi2);

            _bUpdating = FALSE;

            // update selection
            ListView_SetSelectionMark(_hwndLVAll, iNew);
            ListView_SetItemState(_hwndLVAll, iNew , LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
            // HACK: SetItemState sends notifications for i, iNew, then i again.
            // we need to call it twice in a row, so _UpdateDlgButtons will get the right item
            ListView_SetItemState(_hwndLVAll, iNew , LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);

            return;
        }
    }
    TraceMsg(TF_WARNING, "ccd.mi couldn't move %d to %d",i, i+iDelta);
    MessageBeep(MB_ICONEXCLAMATION);
}

BOOL CColumnDlg::_SaveState()
{
    // Check order
    if (_bChanged)
    {
        int iOrderIndex = 0;
        LV_ITEM lvi = {0};
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        lvi.mask = LVIF_PARAM | LVIF_STATE;

        int cItems = ListView_GetItemCount(_hwndLVAll); 
        for (int i = 0; i < cItems; i++)
        {
            lvi.iItem = i;
            ListView_GetItem(_hwndLVAll, &lvi);
        
            // toggle it, if the state in the dialog doesn't match the listview state
            if (BOOLIFY(ListView_GetCheckState(_hwndLVAll, i)) != BOOLIFY(_pdsv->_IsDetailsColumn((UINT)lvi.lParam)))
            {
                _pdsv->_HandleColumnToggle((UINT)lvi.lParam, FALSE);
            }
        
            if (_pdsv->_IsColumnInListView((UINT)lvi.lParam))
                _pdwOrder[iOrderIndex++] = (UINT)lvi.lParam; // incorrectly store real (not vis) col #, fix up below
        }
    
        // must be in a separate loop. (can't map real to visible, if we aren't done setting visible)
        for (i = 0; i < iOrderIndex; i++)
        {
            UINT iReal = _pdwOrder[i];
            _pdwOrder[i] = _pdsv->_RealToVisibleCol(iReal);
        
            if (_pWidths[iReal] < 0) // negative width means they edited it
                ListView_SetColumnWidth(_pdsv->_hwndListview, _pdwOrder[i], -_pWidths[iReal]);
        }

        ListView_SetColumnOrderArray(_pdsv->_hwndListview, iOrderIndex, _pdwOrder);

        // kick the listview into repainting everything
        InvalidateRect(_pdsv->_hwndListview, NULL, TRUE);

        _bChanged = FALSE;
    }
    return !_bChanged;
}

BOOL EnableDlgItem(HWND hdlg, UINT idc, BOOL f)
{
    return EnableWindow(GetDlgItem(hdlg, idc), f);
}

void CColumnDlg::_UpdateDlgButtons(NMLISTVIEW *pnmlv)
{
    BOOL bChecked, bOldUpdateState = _bUpdating;
    int iItem = ListView_GetSelectionMark(_hwndLVAll);

    // to disable checking
    _bUpdating = TRUE;
    if (pnmlv->uNewState & LVIS_STATEIMAGEMASK)
        bChecked = (pnmlv->uNewState & LVIS_STATEIMAGEMASK) == (UINT)INDEXTOSTATEIMAGEMASK(2);
    else 
        bChecked = ListView_GetCheckState(_hwndLVAll, pnmlv->iItem);

    EnableDlgItem(_hdlg, IDC_COL_UP, pnmlv->iItem > 0);
    EnableDlgItem(_hdlg, IDC_COL_DOWN, pnmlv->iItem < (int)_cColumns - 1);
    EnableDlgItem(_hdlg, IDC_COL_SHOW, !bChecked && (pnmlv->lParam != 0));
    EnableDlgItem(_hdlg, IDC_COL_HIDE, bChecked && (pnmlv->lParam != 0));

    // update the width edit box
    int iWidth = _pWidths[pnmlv->lParam];
    if (iWidth < 0) 
        iWidth = -iWidth;   // we store negative values to track if it changed or not
    SetDlgItemInt(_hdlg, IDC_COL_WIDTH, iWidth, TRUE);

    _bUpdating = bOldUpdateState;
}

BOOL_PTR CALLBACK CColumnDlg::s_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CColumnDlg *pcd = (CColumnDlg*) GetWindowLongPtr(hdlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pcd = (CColumnDlg *) lParam;
        pcd->_hdlg = hdlg;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR) pcd);
    }

    return pcd ? pcd->DlgProc(uMsg, wParam, lParam) : FALSE;
}

HRESULT CColumnDlg::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

UINT CColumnDlg::_HelpIDForItem(int iItem, LPTSTR pszHelpFile, UINT cch)
{
    UINT uHelpID = 0;
    *pszHelpFile = 0;

    LV_ITEM lvi = {0};
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;
    if (ListView_GetItem(_hwndLVAll, &lvi))
    {
        IShellFolder2 *psf;
        if (SUCCEEDED(_pdsv->GetFolder(IID_PPV_ARG(IShellFolder2, &psf))))
        {
            SHCOLUMNID scid;
            if (SUCCEEDED(psf->MapColumnToSCID(lvi.lParam, &scid)))
            {
                IPropertyUI *ppui;
                if (SUCCEEDED(_GetPropertyUI(&ppui)))
                {
                    ppui->GetHelpInfo(scid.fmtid, scid.pid, pszHelpFile, cch, &uHelpID);
                    ppui->Release();
                }
            }
            psf->Release();
        }
    }
    return uHelpID;  // IDH_ values
}

 
const static DWORD c_rgColumnDlgHelpIDs[] = 
{
    IDC_COL_UP,         1,
    IDC_COL_DOWN,       1,
    IDC_COL_SHOW,       1,
    IDC_COL_HIDE,       1,
    IDC_COL_WIDTH,      10055,
    IDC_COL_WIDTH_TEXT, 10055,
    0, 0
};
       
BOOL_PTR CColumnDlg::DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDlg();
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_COL_UP:
            _MoveItem(- 1);
            SetFocus(_hwndLVAll);
            break;

        case IDC_COL_DOWN:
            _MoveItem(+ 1);
            SetFocus(_hwndLVAll);
            break;

        case IDC_COL_SHOW:
        case IDC_COL_HIDE:
        {
            UINT iItem = ListView_GetSelectionMark(_hwndLVAll);
            ListView_SetCheckState(_hwndLVAll, iItem, LOWORD(wParam) == IDC_COL_SHOW);
            SetFocus(_hwndLVAll);
            break;
        }

        case IDC_COL_WIDTH:
            if (HIWORD(wParam) == EN_CHANGE && !_bUpdating)
            {
                LV_ITEM lvi = {0};
                lvi.iItem = ListView_GetSelectionMark(_hwndLVAll);
                lvi.mask = LVIF_PARAM;
                ListView_GetItem(_hwndLVAll, &lvi);

                _pWidths[lvi.lParam] = - (int)GetDlgItemInt(_hdlg, IDC_COL_WIDTH, NULL, FALSE);
                _bChanged = TRUE;
            }
            break;

        case IDOK:
            _SaveState(); 

            // fall through

        case IDCANCEL:
            return EndDialog(_hdlg, TRUE);
        }
        break;

    case WM_NOTIFY:
        if (_bLoaded && !_bUpdating)
        {
            NMLISTVIEW * pnmlv = (NMLISTVIEW *)lParam;
            switch (((NMHDR *)lParam)->code)
            {
            case LVN_ITEMCHANGING:

                // fix up the buttons & such here
                if (pnmlv->uChanged & LVIF_STATE)
                    _UpdateDlgButtons(pnmlv);

                // We want to reject turning off the name column
                // it both doesn't make sense to have no name column, and defview assumes there will be one
                if (pnmlv->lParam == 0 &&
                    (pnmlv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(1))
                {
                    MessageBeep(MB_ICONEXCLAMATION);
                    SetWindowLongPtr(_hdlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                else
                {
                    // if something besides focus changed
                    if ((pnmlv->uChanged & ~LVIF_STATE) ||
                        ((pnmlv->uNewState & LVIS_STATEIMAGEMASK) != (pnmlv->uOldState & LVIS_STATEIMAGEMASK)))
                    _bChanged = TRUE;
                }
                break;

            case NM_DBLCLK:
                {
                    BOOL bCheck = ListView_GetCheckState(_hwndLVAll, pnmlv->iItem);
                    ListView_SetCheckState(_hwndLVAll, pnmlv->iItem, !bCheck);
                }
                break;
            }
        }
        break;

    case WM_SYSCOLORCHANGE:
        SendMessage(_hwndLVAll, uMsg, wParam, lParam);
        break;

    case WM_HELP:                   // F1
        {
            HELPINFO *phi = (HELPINFO *)lParam;

            //if the help is for one of the command buttons then call winhelp 
            if (phi->iCtrlId == IDC_COL_LVALL)
            {
                //Help is for the tree item so we need to do some special processing
                
                int iItem;

                // Is this help invoked throught F1 key
                if (GetAsyncKeyState(VK_F1) < 0)                
                {
                    iItem = ListView_GetSelectionMark(_hwndLVAll);
                }
                else 
                {
                    LV_HITTESTINFO info;
                    info.pt = phi->MousePos;
                    ScreenToClient(_hwndLVAll, &info.pt);
                    iItem = ListView_HitTest(_hwndLVAll, &info);
                }

                if (iItem >= 0)
                {
                    DWORD mapIDCToIDH[4] = {0};
                    TCHAR szFile[MAX_PATH];
        
                    mapIDCToIDH[0] = phi->iCtrlId;
                    mapIDCToIDH[1] = _HelpIDForItem(iItem, szFile, ARRAYSIZE(szFile));

                    WinHelp((HWND)((HELPINFO *)lParam)->hItemHandle, szFile[0] ? szFile : NULL,
                                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCToIDH);
                }
            }
            else
            {
                WinHelp((HWND)((HELPINFO *)lParam)->hItemHandle, TEXT(SHELL_HLP),
                             HELP_WM_HELP, (DWORD_PTR)(LPSTR)c_rgColumnDlgHelpIDs);
            }
            break; 
        }

    case WM_CONTEXTMENU:
        {
            int iItem;

            if ((LPARAM)-1 == lParam)
            {
                iItem = ListView_GetSelectionMark(_hwndLVAll);
            }
            else
            {
                LV_HITTESTINFO info;
                info.pt.x = GET_X_LPARAM(lParam);
                info.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(_hwndLVAll, &info.pt);
                iItem = ListView_HitTest(_hwndLVAll, &info);
            }

            if (iItem >= 0)
            {
                DWORD mapIDCToIDH[4] = {0};
    
                TCHAR szFile[MAX_PATH];
                mapIDCToIDH[0] = IDC_COL_LVALL;
                mapIDCToIDH[1] = _HelpIDForItem(iItem, szFile, ARRAYSIZE(szFile)); // IDH_ values

                WinHelp((HWND)wParam, szFile[0] ? szFile : NULL, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCToIDH);
            }
            break; 
        }

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defvphst.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include <perhist.h>
#include "defvphst.h"

// Docfind Persistent history implemention.
STDMETHODIMP CDefViewPersistHistory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefViewPersistHistory, IPersistHistory),             //IID_IPersistHistory
        QITABENTMULTI(CDefViewPersistHistory, IPersist, IPersistHistory), //IID_IPersist
        QITABENT(CDefViewPersistHistory, IObjectWithSite),              //IID_IOBjectWithSite
        QITABENT(CDefViewPersistHistory, IOleObject),                  // IID_IOleObject
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefViewPersistHistory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDefViewPersistHistory::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


CDefViewPersistHistory::CDefViewPersistHistory() :
        m_cRef(1)       
{
}

CDefViewPersistHistory::~CDefViewPersistHistory()
{   
}


STDAPI CDefViewPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT   hr;

    CDefViewPersistHistory *pdfph = new CDefViewPersistHistory();
    if (!pdfph)
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    hr = pdfph->QueryInterface(riid, ppv);
    pdfph->Release();
    return hr;    
}


// Functions to support persisting the document into the history stream...
STDMETHODIMP CDefViewPersistHistory::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DefViewPersistHistory;
    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    IShellView *psv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
    {           
        UINT cItems = 0;
        LPITEMIDLIST pidl = NULL;    // don't free previous one
        UINT uFlags = SVSI_FOCUSED | SVSI_SELECT | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE;

        // read how many pidls we stored
        pstm->Read(&cItems, sizeof(cItems), NULL);

        // now read the pidls
        for (UINT i=0; i < cItems ; i++)
        {
            if (FAILED(ILLoadFromStream(pstm, &pidl)) || (pidl == NULL))
                break;
            if (SUCCEEDED(psv->SelectItem(pidl, uFlags)))
                uFlags = SVSI_SELECT;
        }
        if (pidl)
            ILFree(pidl);       // Free the last one read in

        //
        // If we are in webview mode, we need to load the Trident persist history too
        // 
        IPersistHistory * piph;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_WebViewObject, IID_PPV_ARG(IPersistHistory, &piph))))
        {
            piph->LoadHistory(pstm, pbc);
            piph->Release();
        }                 
        psv->Release();
    }

    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::SaveHistory(IStream *pstm)
{
    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        LPCITEMIDLIST *apidl;
        UINT cItems;
      
        // FEATURE: Currently this assumes the first item is focused. There are cases
        // where we may have unslected the focused item and we are not saving this out here.
        //
        // Need to add GetFocusedObject() to IShellFolderView interface to query this
        //
        //
        if (SUCCEEDED(psfv->GetSelectedObjects(&apidl, &cItems)) && cItems)
        {

            // write out how many pidls we have
            pstm->Write(&cItems, sizeof(cItems), NULL);

            // now write the pidls
            for (UINT i = 0; i < cItems; i++)
            {
                if (apidl[i])
                    ILSaveToStream(pstm, apidl[i]);
            }
            LocalFree((HLOCAL)apidl);
        }
        else
        {   
            cItems = 0;
            pstm->Write(&cItems, sizeof(cItems), NULL);
        }
        
        //
        // If we are in webview mode, we need to save the Trident persist history too
        // 
        IPersistHistory * piph;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_WebViewObject, IID_PPV_ARG(IPersistHistory, &piph))))
        {
            piph->SaveHistory(pstm);
            piph->Release();
        }               
                
        psfv->Release();
    }
    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::SetPositionCookie(DWORD dwPositioncookie)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetPositionCookie - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetPositionCookie(DWORD *pdwPositioncookie)
{
    *pdwPositioncookie = 0;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetPositionCookie - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetClientSite(IOleClientSite *pClientSite)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetClientSite - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetClientSite(IOleClientSite **ppClientSite)
{
    *ppClientSite = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetClientSite - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetHostNames - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Close(DWORD dwSaveOption)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Close - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetMoniker - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    *ppmk = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetMoniker - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::InitFromData - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetClipboardData - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::DoVerb - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    *ppEnumOleVerb = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::EnumVerbs - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Update(void)
{
    // Always up to date.
    return S_OK;
}

STDMETHODIMP CDefViewPersistHistory::IsUpToDate(void)
{
    return S_OK;    // say we are alwayes up to date.
}

STDMETHODIMP CDefViewPersistHistory::GetUserClassID(CLSID *pClsid)
{
    return GetClassID(pClsid);
}

STDMETHODIMP CDefViewPersistHistory::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    *pszUserType = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetUserType - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetExtent - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetExtent - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    *pdwConnection = 0;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Advise - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Unadvise(DWORD dwConnection)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Unadvise - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    *ppenumAdvise = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::EnumAdvises - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = 0;
    if (dwAspect == DVASPECT_CONTENT)
        *pdwStatus = OLEMISC_SETCLIENTSITEFIRST;
    return S_OK;
}

STDMETHODIMP CDefViewPersistHistory::SetColorScheme(LOGPALETTE *pLogpal)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetColorScheme - not implemented"));
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defvphst.h ===
#include <perhist.h>
#include "cowsite.h"

//----------------------------------------------------------------------
// Class to save and restore find state on the travel log 
class CDefViewPersistHistory : public IPersistHistory,
                               public CObjectWithSite, 
                               public IOleObject

{
public:
    CDefViewPersistHistory();
    ~CDefViewPersistHistory();

    // *** IUnknown Methhods ***
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // Support added to allow search results to serialize 
    // *** IPersist methods ***
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // *** IPersistHistory methods ***
    STDMETHOD(LoadHistory)(IStream *pStream, IBindCtx *pbc);
    STDMETHOD(SaveHistory)(IStream *pStream);
    STDMETHOD(SetPositionCookie)(DWORD dwPositioncookie);
    STDMETHOD(GetPositionCookie)(DWORD *pdwPositioncookie);

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHOD(InitFromData)(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved,IDataObject **ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE *pLogpal);

protected:

    LONG                m_cRef;                   // reference count
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dlglogic.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "dlglogic.h"

extern DWORD _DbgLocalAllocCount = 0;

CDataImpl::CDataImpl()
{}

CDataImpl::~CDataImpl()
{}

void CDataImpl::_SetDirty(BOOL fDirty)
{
    _fDirty = fDirty;
}

BOOL CDataImpl::IsDirty()
{
    return _fDirty;
}

void CDataImpl::SetDeleted(BOOL fDeleted)
{
    _fDeleted = fDeleted;
} 

BOOL CDataImpl::IsDeleted()
{
    return _fDeleted;
}

void CDataImpl::SetNew(BOOL fNew)
{
    _fNew = fNew;
}

BOOL CDataImpl::IsNew()
{
    return _fNew;
}

HRESULT CDataImpl::CommitChangesToStorage()
{
    return S_FALSE;
}

HRESULT CDataImpl::AddToStorage()
{
    return S_FALSE;
}

HRESULT CDataImpl::DeleteFromStorage()
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\deskfldr.h ===
//
// the lowest sort order number goes at the top left of the desktop
//
#include "views.h"

// array indexes into g_asDesktopReqItems

#define CDESKTOP_REGITEM_DRIVES         0
#define CDESKTOP_REGITEM_NETWORK        1
#define CDESKTOP_REGITEM_INTERNET       2

EXTERN_C REQREGITEM g_asDesktopReqItems[];

//
// CAUTION: _CompareIDsOriginal() function in RegFldr.cpp has code that assumes that all 
// the "old" sort order values were <= 0x40. So, when it comes across a bOrder <= 0x40,
// it calls _GetOrder() function to get the "new" bOrder value. The following values have
// been bumped up to be above 0x40 sothat for all "new" values, we don't have to make that call. 
//
#define SORT_ORDER_MYDOCS       0x48    // coded in shell\ext\mydocs2\selfreg.inf
#define SORT_ORDER_DRIVES       0x50
#define SORT_ORDER_NETWORK      0x58
#define SORT_ORDER_RECYCLEBIN   0x60    // coded in shell32\selfreg.inx
#define SORT_ORDER_INETROOT     0x68



enum enumTSPerfFlag
{
    TSPerFlag_NoADWallpaper = 0,
    TSPerFlag_NoWallpaper,
    TSPerFlag_NoVisualStyles,
    TSPerFlag_NoWindowDrag,
    TSPerFlag_NoAnimation,
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\deskfldr.cpp ===
#include "shellprv.h"
#include "deskfldr.h"
#include "fstreex.h"
#include "datautil.h"
#include "views.h"
#include "ids.h"
#include "caggunk.h"
#include "shitemid.h"
#include "basefvcb.h"
#include "filefldr.h"
#include "drives.h"
#include "infotip.h"
#include "prop.h"
#include <idhidden.h>
#include "cowsite.h"
#include "unicpp\deskhtm.h"
#include "sfstorage.h"
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN

#include "defcm.h"

#define  EXCLUDE_COMPPROPSHEET
#include "unicpp\dcomp.h"
#undef   EXCLUDE_COMPPROPSHEET

//  TODO - maybe we should add rooted folders to the AnyAlias's - ZekeL - 27-JAN-2000
class CDesktopRootedStub : public IShellFolder2, public IContextMenuCB
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return ILRootedBindToObject(pidl, riid, ppv);}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->BindToStorage(pidlChild, pbc, riid, ppv);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {
            if (ILIsEqualRoot(pidl1, pidl2))
            {
                return ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, lParam);
            }
            else
            {
                UINT cb1 = ILGetSize(pidl1);
                UINT cb2 = ILGetSize(pidl2); 
                short i = (short) memcmp(pidl1, pidl2, min(cb1, cb2));

                if (i == 0)
                    i = cb1 - cb2;
                return ResultFromShort(i);
            }
            return ResultFromShort(-1);
        }
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {
            HRESULT hr = E_INVALIDARG;
            if (cidl == 1)
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder *psf;
                hr = ILRootedBindToParentFolder(apidl[0], IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
                if (SUCCEEDED(hr))
                {
                    hr = psf->GetAttributesOf(1, &pidlChild, rgfInOut);
                    psf->Release();
                }
            }
            return hr;
        }
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDisplayNameOf(pidlChild, uFlags, lpName);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}

    // IShellFolder2 methods
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid)
        {return E_NOTIMPL;}
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder2 *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsEx(pidlChild, pscid, pv);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder2 *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsOf(pidlChild, iColumn, pDetails);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
        {return E_NOTIMPL;}

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                     UINT uMsg, WPARAM wParam, LPARAM lParam)
        {return (uMsg == DFM_MERGECONTEXTMENU) ? S_OK : E_NOTIMPL;}
                     
};


class CShellUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CIDListUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CFileUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CHttpUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CDesktopFolderEnum;
class CDesktopViewCallBack;
class CDesktopFolderDropTarget;

class CDesktopFolder : CObjectWithSite
                     , CSFStorage
                     , public IPersistFolder2
                     , public IShellIcon
                     , public IShellIconOverlay
                     , public IContextMenuCB
                     , public ITranslateShellChangeNotify
                     , public IItemNameLimits
                     , public IOleCommandTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; };
    STDMETHODIMP_(ULONG) Release(void) { return 2; };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut);

    // IShellFolder2 methods
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IShellIcon methods
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay methods
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);
  
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // ITranslateShellChangeNotify
    STDMETHODIMP TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2);
    STDMETHODIMP IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate) { return E_NOTIMPL; }
    STDMETHODIMP IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { return E_NOTIMPL; }
    STDMETHODIMP Register(HWND hwnd, UINT uMsg, long lEvents) { return E_NOTIMPL; }
    STDMETHODIMP Unregister() { return E_NOTIMPL; }

    // IItemNameLimits
    STDMETHODIMP GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHODIMP GetMaxLength(LPCWSTR pszName, int *piMaxNameLen);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CDesktopFolder(IUnknown *punkOuter);
    HRESULT _Init();
    HRESULT _Init2();
    void _Destroy();

private:
    ~CDesktopFolder();

    friend CDesktopFolderEnum;
    friend CDesktopViewCallBack;

    // IStorage virtuals
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);                

    HRESULT _BGCommand(HWND hwnd, WPARAM wparam, BOOL bExecute);
    IShellFolder2 *_GetItemFolder(LPCITEMIDLIST pidl);
    HRESULT _GetItemUIObject(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgfInOut, void **ppv);
    HRESULT _QueryInterfaceItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _ChildParseDisplayName(IShellFolder *psfRight, LPCITEMIDLIST pidlLeft, HWND hwnd, IBindCtx *pbc, 
                LPWSTR pwzDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, DWORD *pdwAttributes);
    BOOL _TryUrlJunctions(LPCTSTR pszName, IBindCtx *pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft);
    BOOL _GetFolderForParsing(LPCTSTR pszName, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft);
    HRESULT _SelfAssocCreate(REFIID riid, void **ppv);
    HRESULT _SelfCreateContextMenu(HWND hwnd, void **ppv);

    IShellFolder2 *_psfDesktop;         // "Desktop" shell folder (real files live here)
    IShellFolder2 *_psfAltDesktop;      // "Common Desktop" shell folder
    IUnknown *_punkReg;                 // regitem inner folder (agregate)
    CDesktopRootedStub _sfRooted;       // rooted folder stub object
    CShellUrlStub _sfShellUrl;          // handles parsing shell: Urls
    CIDListUrlStub _sfIDListUrl;        // handles parsing ms-shell-idlist: Urls
    CFileUrlStub _sfFileUrl;            // handles parsing file: Urls
    CHttpUrlStub _sfHttpUrl;            // handles parsing http: and https: Urls
};

class CDesktopFolderEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv); 
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CDesktopFolderEnum(CDesktopFolder *pdf, HWND hwnd, DWORD grfFlags);

private:
    ~CDesktopFolderEnum();

    LONG _cRef;
    BOOL _bUseAltEnum;
    IEnumIDList *_penumFolder;
    IEnumIDList *_penumAltFolder;
};

class CDesktopViewCallBack : public CBaseShellFolderViewCB, public IFolderFilter
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return CBaseShellFolderViewCB::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CBaseShellFolderViewCB::Release(); };

    // IFolderFilter
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);
    
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    CDesktopViewCallBack(CDesktopFolder* pdf);
    friend HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv);

    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnGETCCHMAX(DWORD pv, LPCITEMIDLIST pidlItem, UINT *lP);
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR pszDir);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);

    CDesktopFolder* _pdf;
    BOOL    _fCheckedIfRealDesktop;
    BOOL    _fRealDesktop;

};
HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv);

class CDesktopFolderDropTarget : public IDropTarget, CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragLeave(void);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CDesktopFolderDropTarget(IDropTarget* pdt);
private:
    ~CDesktopFolderDropTarget();
    STDMETHODIMP_(BOOL) _IsSpecialCaseDrop(IDataObject* pDataObject, DWORD grfKeyState, BOOL* pfIsPIDA, UINT* pcItems);
    STDMETHODIMP        _ShowIEIcon();

    IDropTarget* _pdt;
    LONG _cRef;
};


// some fields are modified so this can't be const
REQREGITEM g_asDesktopReqItems[] =
{
    { 
        &CLSID_MyComputer,  IDS_DRIVEROOT,  
        TEXT("explorer.exe"), 0, SORT_ORDER_DRIVES, 
        SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_CANRENAME | SFGAO_CANDELETE,
        TEXT("SYSDM.CPL")
    },
    { 
        &CLSID_NetworkPlaces, IDS_NETWORKROOT, 
        TEXT("shell32.dll"), -IDI_MYNETWORK, SORT_ORDER_NETWORK, 
        SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_CANRENAME | SFGAO_CANDELETE,
        TEXT("NCPA.CPL"),
    },
    { 
        &CLSID_Internet, IDS_INETROOT, 
        TEXT("mshtml.dll"),   0, SORT_ORDER_INETROOT, 
        SFGAO_BROWSABLE  | SFGAO_HASPROPSHEET | SFGAO_CANRENAME, 
        TEXT("INETCPL.CPL")
    },
};

const ITEMIDLIST c_idlDesktop = { { 0, 0 } };

#define DESKTOP_PIDL  ((LPITEMIDLIST)&c_idlDesktop)

// single global instance of this CDesktopFolder object
CDesktopFolder *g_pDesktopFolder = NULL;

REGITEMSINFO g_riiDesktop =
{
    REGSTR_PATH_EXPLORER TEXT("\\Desktop\\NameSpace"),
    NULL,
    TEXT(':'),
    SHID_ROOT_REGITEM,
    1,
    SFGAO_CANLINK,
    ARRAYSIZE(g_asDesktopReqItems),
    g_asDesktopReqItems,
    RIISA_ORIGINAL,
    NULL,
    0,
    0,
};


void Desktop_InitRequiredItems(void)
{
    //  "NoNetHood" restriction -> always hide the hood.
    //  Otherwise, show the hood if either MPR says so or we have RNA.
    if (SHRestricted(REST_NONETHOOD))
    {
        // Don't enumerate the "Net Hood" thing.
        g_asDesktopReqItems[CDESKTOP_REGITEM_NETWORK].dwAttributes |= SFGAO_NONENUMERATED;
    }
    else
    {
        // Do enumerate the "My Network" thing.
        g_asDesktopReqItems[CDESKTOP_REGITEM_NETWORK].dwAttributes &= ~SFGAO_NONENUMERATED;
    }
    
    //  "MyComp_NoProp" restriction -> hide Properties context menu entry on My Computer 
    if (SHRestricted(REST_MYCOMPNOPROP))
    {
        g_asDesktopReqItems[CDESKTOP_REGITEM_DRIVES].dwAttributes &= ~SFGAO_HASPROPSHEET;
    }

    //
    // "NoInternetIcon" restriction or AppCompat -> hide The Internet on the desktop
    //
    //  Word Perfect 7 faults when it enumerates the Internet item
    // in their background thread.  For now App hack specific to this app
    // later may need to extend...  Note: This app does not install on
    // NT so only do for W95...
    // it repros with Word Perfect Suite 8, too, this time on both NT and 95
    // so removing the #ifndef... -- reljai 11/20/97, bug#842 in ie5 db
    //
    //  we used to remove the SFGAO_BROWSABLE flag for both of these cases - ZekeL - 19-Dec-2000
    //  but ShellExec() needs SFGAO_BROWSABLE so that parsing URLs succeeds
    //  if it turns out that we need to exclude the BROWSABLE, then we should
    //  change regfldr to look at a value like "WantsToParseDisplayName" under
    //  the CLSID.  or we could add routing code in deskfldr (like we have for
    //  MyComputer and NetHood) to pass it to the internet folder directly
    //
    if (SHRestricted(REST_NOINTERNETICON) || (SHGetAppCompatFlags(ACF_CORELINTERNETENUM) & ACF_CORELINTERNETENUM))
    {
        //  g_asDesktopReqItems[CDESKTOP_REGITEM_INTERNET].dwAttributes &=  ~(SFGAO_BROWSABLE);
        g_asDesktopReqItems[CDESKTOP_REGITEM_INTERNET].dwAttributes |= SFGAO_NONENUMERATED;
    }
}

CDesktopFolder::CDesktopFolder(IUnknown *punkOuter)
{
    DllAddRef();
}

CDesktopFolder::~CDesktopFolder()
{
    DllRelease();
}

// first phase of init (does not need to be seralized)

HRESULT CDesktopFolder::_Init()
{
    Desktop_InitRequiredItems();
    return CRegFolder_CreateInstance(&g_riiDesktop, SAFECAST(this, IShellFolder2 *), IID_PPV_ARG(IUnknown, &_punkReg));
}

// second phase of init (needs to be seralized)

HRESULT CDesktopFolder::_Init2()
{
    HRESULT hr = SHCacheTrackingFolder(DESKTOP_PIDL, CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_CREATE, &_psfDesktop);
    if (FAILED(hr))
    {
        DebugMsg(DM_TRACE, TEXT("Failed to create desktop IShellFolder!"));
        return hr;
    }

    if (!SHRestricted(REST_NOCOMMONGROUPS))
    {
        hr = SHCacheTrackingFolder(DESKTOP_PIDL, CSIDL_COMMON_DESKTOPDIRECTORY, &_psfAltDesktop);
    }

    return hr;
}

// CLSID_ShellDesktop constructor

STDAPI CDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (g_pDesktopFolder)
    {
        hr = g_pDesktopFolder->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;

        // WARNING: the order of init of the desktop folder state is very important.
        // the creation of the sub folders, in particular _psfAltDesktop will
        // recurse on this function. we protect ourself from that here. the creation
        // of that also requires the above members to be inited.

        CDesktopFolder *pdf = new CDesktopFolder(punkOuter);
        if (pdf)
        {
            hr = pdf->_Init();
            if (SUCCEEDED(hr))
            {
                // NOTE: there is a race condition here where we have stored g_pDesktopFolder but
                // not initialized _psfDesktop & _psfAltDesktop. the main line code deals with
                // this by testing for NULL on these members.
                if (SHInterlockedCompareExchange((void **)&g_pDesktopFolder, pdf, 0))
                {
                    // Someone else beat us to creating the object.
                    // get rid of our copy, global already set (the race case)
                    pdf->_Destroy();    
                }
                else
                {
                    g_pDesktopFolder->_Init2();
                }
                hr = g_pDesktopFolder->QueryInterface(riid, ppv);
            }
            else
                pdf->_Destroy();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


STDAPI SHGetDesktopFolder(IShellFolder **ppshf)
{
    return CDesktop_CreateInstance(NULL, IID_PPV_ARG(IShellFolder, ppshf));
}

IShellFolder2 *CDesktopFolder::_GetItemFolder(LPCITEMIDLIST pidl)
{
    IShellFolder2 *psf = NULL;
    if (ILIsRooted(pidl))
        psf = SAFECAST(&_sfRooted, IShellFolder2 *);
    else if (_psfAltDesktop && CFSFolder_IsCommonItem(pidl))
        psf = _psfAltDesktop;
    else 
        psf = _psfDesktop;

    return psf;
}

HRESULT CDesktopFolder::_QueryInterfaceItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        hr = psf->QueryInterface(riid, ppv);
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDAPI_(BOOL) RegGetsFirstShot(REFIID riid)
{
    return (IsEqualIID(riid, IID_IShellFolder) ||
            IsEqualIID(riid, IID_IShellFolder2) ||
            IsEqualIID(riid, IID_IShellIconOverlay));
}

HRESULT CDesktopFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolder, IShellFolder2),                      
        QITABENTMULTI(CDesktopFolder, IShellFolder, IShellFolder2),   
        QITABENT(CDesktopFolder, IShellIcon),                         
        QITABENT(CDesktopFolder, IPersistFolder2),                    
        QITABENTMULTI(CDesktopFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CDesktopFolder, IPersist, IPersistFolder2),     
        QITABENT(CDesktopFolder, IShellIconOverlay),                  
        QITABENT(CDesktopFolder, IStorage),
        QITABENT(CDesktopFolder, IContextMenuCB),
        QITABENT(CDesktopFolder, IObjectWithSite),
        QITABENT(CDesktopFolder, ITranslateShellChangeNotify),
        QITABENT(CDesktopFolder, IItemNameLimits),
        QITABENT(CDesktopFolder, IOleCommandTarget),
        { 0 },
    };

    if (IsEqualIID(riid, CLSID_ShellDesktop))
    {
        *ppv = this;     // class pointer (unrefed!)
        return S_OK;
    }

    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}


// During shell32.dll process detach, we will call here to do the final
// release of the IShellFolder ptrs which used to be left around for the
// life of the process.  This quiets things such as OLE's debug allocator,
// which detected the leak.


void CDesktopFolder::_Destroy()
{
    ATOMICRELEASE(_psfDesktop);
    ATOMICRELEASE(_psfAltDesktop);
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    delete this;
}

LPITEMIDLIST CreateMyComputerIDList()
{
    return ILCreateFromPath(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}")); // CLSID_MyComputer
}

LPITEMIDLIST CreateWebFoldersIDList()
{
    return ILCreateFromPath(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{BDEADF00-C265-11D0-BCED-00A0C90AB50F}")); // CLSID_MyComputer\CLSID_WebFolders
}

LPITEMIDLIST CreateMyNetPlacesIDList()
{
    return ILCreateFromPath(TEXT("::{208D2C60-3AEA-1069-A2D7-08002B30309D}")); // CLSID_NetworkPlaces
}

HRESULT CDesktopFolder::_ChildParseDisplayName(IShellFolder *psfRight, LPCITEMIDLIST pidlLeft, HWND hwnd, IBindCtx *pbc, 
                LPWSTR pwzDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    LPITEMIDLIST pidlRight;
    HRESULT hr = psfRight->ParseDisplayName(hwnd, pbc, 
        pwzDisplayName, pchEaten, &pidlRight, pdwAttributes);
    if (SUCCEEDED(hr))
    {
        if (pidlLeft)
        {
            hr = SHILCombine(pidlLeft, pidlRight, ppidl);
            ILFree(pidlRight);
        }
        else 
            *ppidl = pidlRight;
    }

    return hr;
}

STDMETHODIMP CDesktopRootedStub::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                               REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (cidl == 1)
    {
        if (IsEqualIID(riid, IID_IDataObject))
        {
            hr = CIDLData_CreateFromIDArray(&c_idlDesktop, cidl, apidl, (IDataObject **)ppv);
        }
        else if (IsEqualIID(riid, IID_IContextMenu))
        {
            IQueryAssociations *pqa;
            if (SUCCEEDED(SHGetAssociations(apidl[0], (void **)&pqa)))
            {
                HKEY keys[5];
                DWORD cKeys = SHGetAssocKeys(pqa, keys, ARRAYSIZE(keys));

                hr = CDefFolderMenu_Create2Ex(&c_idlDesktop, hwnd,
                                              cidl, apidl, this, this,
                                              cKeys, keys,  (IContextMenu **)ppv);

                SHRegCloseKeys(keys, cKeys);
            }
        }
        else
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            hr = ILRootedBindToParentFolder(apidl[0], IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetUIObjectOf(hwnd, 1, &pidlChild, riid, prgfInOut, ppv);
                psf->Release();
            }
        }
    }
    return hr;
}

// Check the registry for a shell root under this CLSID.
BOOL GetRootFromRootClass(CLSID *pclsid, LPWSTR pszPath, int cchPath)
{
    WCHAR szClsid[GUIDSTR_MAX];
    WCHAR szClass[MAX_PATH];

    SHStringFromGUIDW(*pclsid, szClsid, ARRAYSIZE(szClsid));
    wnsprintfW(szClass, ARRAYSIZE(szClass), L"CLSID\\%s\\ShellExplorerRoot", szClsid);

    DWORD cbPath = cchPath * sizeof(WCHAR);

    return SHGetValueGoodBootW(HKEY_CLASSES_ROOT, szClass, NULL, NULL, (BYTE *)pszPath, &cbPath) == ERROR_SUCCESS;
}

//
//  General form for Rooted URLs:
//      ms-shell-root:{clsid}?URL
//          {CLSID} is not required, defaults to CLSID_ShellDesktop
//          URL is also not required.  if there is a CLSID defaults to 
//              what is specified under "CLSID\{CLSID}\ShellExplorerRoot
//              or default to CSIDL_DESKTOP
//          but one of them at least must be specified
//  rooted:{clsid}?idlist
//

STDMETHODIMP CDesktopRootedStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    //  Need to keep the internet SF from getting a chance to parse
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
    ASSERT(pu.nScheme == URL_SCHEME_MSSHELLROOTED);

    LPCWSTR pszUrl = StrChrW(pu.pszSuffix, L':');

    if (pszUrl++)
    {
        WCHAR szField[MAX_PATH];
        CLSID clsid;
        CLSID *pclsidRoot = GUIDFromStringW(pu.pszSuffix, &clsid) ? &clsid : NULL;

        // path might come from the registry
        // if nothing was passed in.
        if (!*pszUrl && GetRootFromRootClass(pclsidRoot, szField, ARRAYSIZE(szField)))
        {
            pszUrl = szField;

        }

        if (pclsidRoot || *pszUrl)
        {
            LPITEMIDLIST pidlRoot = ILCreateFromPathW(pszUrl);

            // fix up bad cmd line "explorer.exe /root," case
            if (!pidlRoot)
                SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pidlRoot);

            if (pidlRoot)
            {
                *ppidl = ILRootedCreateIDList(pclsidRoot, pidlRoot);
                if (*ppidl)
                    hr = S_OK;

                ILFree(pidlRoot);
            }
        }
    }

    return hr;
}

STDMETHODIMP CIDListUrlStub::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR *pwzDisplayName, 
                                        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    //  Need to keep the internet SF from getting a chance to parse
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
    ASSERT(pu.nScheme == URL_SCHEME_MSSHELLIDLIST);

    LPCWSTR psz = pu.pszSuffix;

    if (psz)
    {
        HANDLE hMem = LongToHandle(StrToIntW(psz));
        psz = StrChrW(psz, TEXT(':'));
        if (psz++)
        {
            DWORD dwProcId = (DWORD)StrToIntW(psz);
            LPITEMIDLIST pidlGlobal = (LPITEMIDLIST) SHLockShared(hMem, dwProcId);
            if (pidlGlobal)
            {
                if (!IsBadReadPtr(pidlGlobal, 1))
                    hr = SHILClone(pidlGlobal, ppidl);

                SHUnlockShared(pidlGlobal);
                SHFreeShared(hMem, dwProcId);
            }
        }
    }
    return hr;
}

STDMETHODIMP CFileUrlStub::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR *pwzDisplayName, 
                                        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    LPCWSTR pszFragment = UrlGetLocationW(pwzDisplayName);
    WCHAR szPath[MAX_URL_STRING];
    DWORD cchPath = ARRAYSIZE(szPath);
    WCHAR szQuery[MAX_URL_STRING];
    DWORD cchQuery = ARRAYSIZE(szQuery) - 1;

    //  We want to remove QUERY and FRAGMENT sections of
    //  FILE URLs because they need to be added in "Hidden" pidls.
    //  Also, URLs need to be escaped all the time except for paths
    //  to facility parsing and because we already removed all other
    //  parts of the URL (Query and Fragment).
    ASSERT(UrlIsW(pwzDisplayName, URLIS_FILEURL));
    
    if (SUCCEEDED(UrlGetPartW(pwzDisplayName, szQuery+1, &cchQuery, URL_PART_QUERY, 0)) && cchQuery)
        szQuery[0] = TEXT('?');
    else
        szQuery[0] = 0;

    if (SUCCEEDED(PathCreateFromUrlW(pwzDisplayName, szPath, &cchPath, 0))) 
    {
        //  WARNING - we skip supporting simple ids here
        ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_NORMAL, ppidl, pdwAttributes);
        
        if (*ppidl && pszFragment)
        {
            *ppidl = ILAppendHiddenStringW(*ppidl, IDLHID_URLFRAGMENT, pszFragment);
        }

        if (*ppidl && szQuery[0] == TEXT('?'))
        {
            *ppidl = ILAppendHiddenStringW(*ppidl, IDLHID_URLQUERY, szQuery);
        }

        E_OUTOFMEMORY;
    }

    //  Need to keep the internet SF from getting a chance to parse
    return *ppidl ? S_OK : HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
}

STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName);

//
//  Given a string of the form
//
//      programs\My Pictures\Vacation
//
//
//  return CSIDL_PROGRAMS and set ppwszUnparsed to "My Pictures\Vacation".
//
//  If there is no backslash, then ppwszUnparsed = NULL.
//
//  This function is broken out of CShellUrlStub::ParseDisplayName() to conserve stack space,
//  since ParseDisplayName is used by 16-bit ShellExecute.

STDAPI_(int) _ParseSpecialFolder(LPCWSTR pszName, LPWSTR *ppwszUnparsed, ULONG *pcchEaten)
{
    LPCWSTR pwszKey;
    WCHAR wszKey[MAX_PATH];

    LPWSTR pwszBS = StrChrW(pszName, L'\\');
    if (pwszBS)
    {
        *ppwszUnparsed = pwszBS + 1;
        *pcchEaten = (ULONG)(pwszBS + 1 - pszName);
        StrCpyNW(wszKey, pszName, min(*pcchEaten, MAX_PATH));
        pwszKey = wszKey;
    }
    else
    {
        *ppwszUnparsed = NULL;
        pwszKey = pszName;
        *pcchEaten = lstrlenW(pwszKey);
    }
    return SHGetSpecialFolderID(pwszKey);
}

        
STDMETHODIMP CShellUrlStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    EVAL(SUCCEEDED(ParseURLW(pwzDisplayName, &pu)));
    //  Need to keep the internet SF from getting a chance to parse
    //  the shell: URLs even if we fail to parse it
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

    ASSERT(pu.nScheme == URL_SCHEME_SHELL);

    // shell:::{guid}
    if (pu.pszSuffix[0] == L':' && pu.pszSuffix[1] == L':')
    {
        IShellFolder *psfDesktop;

        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IBindCtx *pbcCreate=NULL;
        
            hr = CreateBindCtx(0, &pbcCreate);
            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
                bo.grfMode = STGM_CREATE;
                pbcCreate->SetBindOptions(&bo);

                hr = psfDesktop->ParseDisplayName(hwnd, pbcCreate, (LPWSTR)pu.pszSuffix, pchEaten, ppidl, pdwAttributes);
                pbcCreate->Release();
            }
            psfDesktop->Release();
        }
    }
    else
    {   // shell:personal\My Pictures
        LPWSTR pwszUnparsed = NULL;
        ULONG cchEaten;

        int csidl = _ParseSpecialFolder(pu.pszSuffix, &pwszUnparsed, &cchEaten);

        if (-1 != csidl)
        {
            LPITEMIDLIST pidlCSIDL;
            hr = SHGetFolderLocation(hwnd, csidl | CSIDL_FLAG_CREATE, NULL, 0, &pidlCSIDL);
            if (SUCCEEDED(hr))
            {
                if (pwszUnparsed && *pwszUnparsed)
                {
                    IShellFolder *psf;
                    hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlCSIDL, &psf));
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlChild;
                        hr = psf->ParseDisplayName(hwnd, pbc, pwszUnparsed, pchEaten,
                                                   &pidlChild, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILCombine(pidlCSIDL, pidlChild, ppidl);
                            ILFree(pidlChild);
                            if (pchEaten) *pchEaten += cchEaten;
                        }
                        psf->Release();
                    }
                    ILFree(pidlCSIDL);
                }
                else
                {
                    if (pdwAttributes && *pdwAttributes)
                    {
                        hr = SHGetNameAndFlags(pidlCSIDL, 0, NULL, 0, pdwAttributes);
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (pchEaten) *pchEaten = cchEaten;
                        *ppidl = pidlCSIDL;
                    }
                    else
                        ILFree(pidlCSIDL);
                }

            }
        }
    }
    return hr;
}

// key for the DAVRDR so that we can read the localised provider name.
#define DAVRDR_KEY TEXT("SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider")

STDMETHODIMP CHttpUrlStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
 
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
 
    //  we cant handle anything but simple URLs here, and only HTTP (not HTTPS).
    
    if (!UrlGetLocationW(pwzDisplayName) 
            && !StrChrW(pu.pszSuffix, L'?')
            && (lstrlen(pu.pszSuffix) < MAX_PATH)
            && (pu.nScheme == URL_SCHEME_HTTP))
    {
        // convert from wacky http: to something that the RDR will pick up as a UNC,
        // given that this is being forwarded directly to the DAV RDR.
        //
        //  http://server/share -> \\server\share

        WCHAR sz[MAX_PATH];
        StrCpyN(sz, pu.pszSuffix, ARRAYSIZE(sz));

        for (LPWSTR psz = sz; *psz; psz++)
        {
            if (*psz == L'/')
            {
                *psz = L'\\';
            }
        }

        //  this forces the use of the DavRedir as the provider
        //  thus avoiding any confusion...
        IPropertyBag *ppb;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            TCHAR szProvider[MAX_PATH];
            DWORD cbProvider = sizeof (szProvider);

            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, DAVRDR_KEY, TEXT("Name"), NULL, szProvider, &cbProvider))
            {
                hr = SHPropertyBag_WriteStr(ppb, STR_PARSE_NETFOLDER_PROVIDERNAME, szProvider);
                if (SUCCEEDED(hr))
                {
                    hr = pbc->RegisterObjectParam(STR_PARSE_NETFOLDER_INFO, ppb);
                    if (SUCCEEDED(hr))
                    {
                        //  add a UI bindctx if necessary
                        IBindCtx *pbcRelease = NULL;
                        if (hwnd && !BindCtx_GetUIWindow(pbc))
                        {
                            //  returns a reference to our pbc in pbcRelease
                            BindCtx_RegisterUIWindow(pbc, hwnd, &pbcRelease);
                        }

                        hr = SHParseDisplayName(sz, pbc, ppidl, pdwAttributes ? *pdwAttributes : 0, pdwAttributes);

                        if (pbcRelease)
                            pbc->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            ppb->Release();
        }

    }

    if (FAILED(hr) && !BindCtx_ContainsObject(pbc, L"BUT NOT WEBFOLDERS"))
    {
        //  fall back to webfolders
        LPITEMIDLIST pidlParent = CreateWebFoldersIDList();
        if (pidlParent)
        {
            IShellFolder *psf;
            hr = SHBindToObjectEx(NULL, pidlParent, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlRight;
                //  always pass NULL for the HWND.  webfolders shows really bad UI
                hr = psf->ParseDisplayName(NULL, pbc, pwzDisplayName, pchEaten, &pidlRight, pdwAttributes);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlParent, pidlRight, ppidl);
                    ILFree(pidlRight);
                }
                psf->Release();
            }
            ILFree(pidlParent);
        }
    }
    
    return hr;
}
    
HKEY _RegOpenSchemeJunctionKey(LPCTSTR pszScheme)
{
    HKEY hk = NULL;
    TCHAR sz[MAX_PATH];
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("%s\\ShellEx\\Junction"), pszScheme);
    RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, KEY_READ, &hk);

    return hk;
}

BOOL _TryRegisteredUrlJunction(LPCTSTR pszName, DWORD cchName, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft)
{
    TCHAR sz[MAX_PATH];
    StrCpyN(sz, pszName, (int)min(ARRAYSIZE(sz), cchName + 1));
    HKEY hk = _RegOpenSchemeJunctionKey(sz);

    if (hk)
    {
        DWORD cbSize;
        // try for IDList
        if (S_OK == SHGetValue(hk, NULL, TEXT("IDList"), NULL, NULL, &cbSize))
        {
            LPITEMIDLIST pidl= (LPITEMIDLIST) SHAlloc(cbSize);

            if (pidl)
            {
                if (S_OK == SHGetValue(hk, NULL, TEXT("IDList"), NULL, pidl, &cbSize))
                {
                    *ppidlLeft = pidl;
                }
                else
                    SHFree(pidl);
            }
        }
        else
        {
            cbSize = sizeof(sz);
            if (S_OK == SHGetValue(hk, NULL, TEXT("Path"), NULL, sz, &cbSize))
            {
                //  maybe we should ILCFP_FLAG_SKIPJUNCTIONS?
                ILCreateFromPathEx(sz, NULL, ILCFP_FLAG_NORMAL, ppidlLeft, NULL);
            }
            else 
            {
                CLSID clsid;
                cbSize = sizeof(sz);
                if (S_OK == SHGetValue(hk, NULL, TEXT("CLSID"), NULL, sz, &cbSize)
                && GUIDFromString(sz, &clsid))
                {
                    SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IShellFolder, ppsf));
                }
            }
        }

        RegCloseKey(hk);
        return (*ppsf || *ppidlLeft);
    }
    return FALSE;

}

BOOL CDesktopFolder::_TryUrlJunctions(LPCTSTR pszName, IBindCtx *pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft)
{
    PARSEDURL pu = {0};
    pu.cbSize = sizeof(pu);
    EVAL(SUCCEEDED(ParseURL(pszName, &pu)));

    ASSERT(!*ppsf);
    ASSERT(!*ppidlLeft);
    switch (pu.nScheme)
    {
    case URL_SCHEME_SHELL:
        *ppsf = SAFECAST(&_sfShellUrl, IShellFolder *);
        break;
        
    case URL_SCHEME_FILE:
        *ppsf = SAFECAST(&_sfFileUrl, IShellFolder *);
        break;

    case URL_SCHEME_MSSHELLROOTED:
        *ppsf = SAFECAST(&_sfRooted, IShellFolder *);
        break;

    case URL_SCHEME_MSSHELLIDLIST:
        *ppsf = SAFECAST(&_sfIDListUrl, IShellFolder *);
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
        if (BindCtx_ContainsObject(pbc, STR_PARSE_PREFER_FOLDER_BROWSING))
            *ppsf = SAFECAST(&_sfHttpUrl, IShellFolder *);
        break;
    
    default:
        // _TryRegisteredUrlJunction(pu.pszProtocol, pu.cchProtocol, ppsf, ppidlLeft)
        break;
    }
    
    return (*ppsf || *ppidlLeft);
}

BOOL _FailForceReturn(HRESULT hr);

BOOL CDesktopFolder::_GetFolderForParsing(LPCTSTR pszName, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft)
{
    ASSERT(!*ppidlLeft);
    ASSERT(!*ppsf);
    
    if ((InRange(pszName[0], TEXT('A'), TEXT('Z')) || 
         InRange(pszName[0], TEXT('a'), TEXT('z'))) && 
        pszName[1] == TEXT(':'))
    {
        // The string contains a path, let "My Computer" figire it out.
        *ppidlLeft = CreateMyComputerIDList();
    }
    else if (PathIsUNC(pszName))
    {
        // The path is UNC, let "World" figure it out.
        *ppidlLeft = CreateMyNetPlacesIDList();
    }
    else if (UrlIs(pszName, URLIS_URL) && !SHSkipJunctionBinding(pbc, NULL))
    {
        _TryUrlJunctions(pszName, pbc, ppsf, ppidlLeft);
    }

    if (!*ppsf && *ppidlLeft)
        SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, *ppidlLeft, ppsf));
        
    return (*ppsf != NULL);
}    

STDMETHODIMP CDesktopFolder::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;      // assume error

        if (pwzDisplayName && *pwzDisplayName)
        {
            LPITEMIDLIST pidlLeft = NULL;
            IShellFolder *psfRight = NULL;

            ASSERT(hr == E_INVALIDARG);

            if (_GetFolderForParsing(pwzDisplayName, pbc, &psfRight, &pidlLeft))
            {
                if (pchEaten)
                    *pchEaten = 0;
                hr = _ChildParseDisplayName(psfRight, pidlLeft, hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                ILFree(pidlLeft);
                psfRight->Release();
            }

            if (SUCCEEDED(hr))
            {
                //  translate aliases here for goodness sake
                if (BindCtx_ContainsObject(pbc, STR_PARSE_TRANSLATE_ALIASES))
                {
                    LPITEMIDLIST pidlAlias;
                    if (SUCCEEDED(SHILAliasTranslate(*ppidl, &pidlAlias, XLATEALIAS_ALL)))
                    {
                        ILFree(*ppidl);
                        *ppidl = pidlAlias;
                    }
                }
            }
            else if (FAILED(hr) && !_FailForceReturn(hr))
            {
                //
                //  MIL 131297 - desktop did not support relative simple parses - ZekeL - 3-FEB-2000
                //  it was only the roots (drives/net) that would create simple IDs
                //  so for some apps we need to still not do it.
                //
                if (BindCtx_ContainsObject(pbc, STR_DONT_PARSE_RELATIVE))
                {
                    // we're told not to parse relative paths and _GetFolderForParsing failed
                    // so act like we don't think the path exists.
                    hr = E_INVALIDARG;
                }
                else if (S_OK != SHIsFileSysBindCtx(pbc, NULL))
                {
                    //  when we request that something be created, we need to
                    //  check both folders and make sure that it doesnt exist in 
                    //  either one.  and then try and create it in the user folder
                    BIND_OPTS bo = {sizeof(bo)};
                    BOOL fCreate = FALSE;

                    if (pbc && SUCCEEDED(pbc->GetBindOptions(&bo)) && 
                        (bo.grfMode & STGM_CREATE))
                    {
                        fCreate = TRUE;
                        bo.grfMode &= ~STGM_CREATE;
                        pbc->SetBindOptions(&bo);
                    }

                    //  give the users desktop first shot.
                    // This must be a desktop item, _psfDesktop may not be inited in
                    // the case where we are called from ILCreateFromPath()
                    if (_psfDesktop)
                        hr = _psfDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);

                    //  if the normal desktop folder didnt pick it off, 
                    //  it could be in the allusers folder.  give psfAlt a chance.
                    if (FAILED(hr) && _psfAltDesktop)
                    {
                        hr = _psfAltDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                    }

                    //  neither of the folders can identify an existing item
                    //  so we should pass the create flag to the real desktop
                    if (FAILED(hr) && fCreate && _psfDesktop)
                    {
                        bo.grfMode |= STGM_CREATE;
                        pbc->SetBindOptions(&bo);
                        hr = _psfDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                        //  when this succeeds, we know we got a magical ghost pidl...
                    }
                }
            }

        } 
        else if (pwzDisplayName)
        {
            // we used to return this pidl when passed an empty string
            // some apps (such as Wright Design) depend on this behavior
            hr = SHILClone((LPCITEMIDLIST)&c_idlDrives, ppidl);
        }
    }

    return hr;
}

STDAPI_(void) UltRoot_Term()
{
    if (g_pDesktopFolder)
    {
        g_pDesktopFolder->_Destroy();
        g_pDesktopFolder = NULL;
    }
}

HRESULT CDesktopFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = new CDesktopFolderEnum(this, hwnd, grfFlags);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}


STDMETHODIMP CDesktopFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    // note: using IsSelf() here will cause a problem with WinZip. they expect
    // failure when they pass an empty pidl. SHBindToOjbect() has the special
    // case for the desktop, so it is not needed here.

    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->BindToObject(pidl, pbc, riid, ppv);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CDesktopFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (pidl1 == NULL || pidl2 == NULL)
        return E_INVALIDARG;

    if (pidl1->mkid.cb == 0 && pidl2->mkid.cb == 0)
        return ResultFromShort(0);      // 2 empty IDLists, they are the same

    if (ILIsRooted(pidl1) || ILIsRooted(pidl2))
    {
        return _sfRooted.CompareIDs(lParam, pidl1, pidl2);
    }
    // If both objects aren't from the same directory, they won't match.
    else if (_psfAltDesktop) 
    {
        if (CFSFolder_IsCommonItem(pidl1)) 
        {
            if (CFSFolder_IsCommonItem(pidl2)) 
                return _psfAltDesktop->CompareIDs(lParam, pidl1, pidl2);
            else 
                return ResultFromShort(-1);
        } 
        else 
        {
            if (CFSFolder_IsCommonItem(pidl2)) 
                return ResultFromShort(1);
            else if (_psfDesktop)
                return _psfDesktop->CompareIDs(lParam, pidl1, pidl2);
        }
    } 
    else if (_psfDesktop)
    {
        return _psfDesktop->CompareIDs(lParam, pidl1, pidl2);
    }

    // If we have no _psfDesktop, we get here...
    return ResultFromShort(-1);
}

HRESULT CDesktopFolder::_BGCommand(HWND hwnd, WPARAM wparam, BOOL bExecute)
{
    HRESULT hr = S_OK;

    switch (wparam) 
    {
    case DFM_CMD_PROPERTIES:
    case FSIDM_PROPERTIESBG:
        if (bExecute)
        {
            // run the default applet in desk.cpl
            if (SHRunControlPanel( TEXT("desk.cpl"), hwnd ))
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
        break;

    case DFM_CMD_MOVE:
    case DFM_CMD_COPY:
        hr = E_FAIL;
        break;

    default:
        // This is common menu items, use the default code.
        hr = S_FALSE;
        break;
    }

    return hr;
}


// IContextMenuCB::CallBack for the background context menu
//
// Returns:
//      S_OK, if successfully processed.
//      S_FALSE, if default code should be used.

STDMETHODIMP CDesktopFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            // Only add the desktop background Properties iff we're the real desktop browser
            // (i.e., we don't want it when in explorer)
            //
            if (IsDesktopBrowser(_punkSite))
            {
                LPQCMINFO pqcm = (LPQCMINFO)lParam;
                UINT idCmdFirst = pqcm->idCmdFirst;

                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, pqcm);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMAND:
    case DFM_VALIDATECMD:
        hr = _BGCommand(hwnd, wParam, uMsg == DFM_INVOKECOMMAND);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

// IItemNameLimits

STDMETHODIMP CDesktopFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    IItemNameLimits *pinl;
    HRESULT hr = _QueryInterfaceItem(NULL, IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        hr = pinl->GetValidCharacters(ppwszValidChars, ppwszInvalidChars);
        pinl->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    // delegate to per user or common based on which name space
    // pszName is from (we have to search for that)
    IItemNameLimits *pinl;
    HRESULT hr = _QueryInterfaceItem(NULL, IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        hr = pinl->GetMaxLength(pszName, piMaxNameLen);
        pinl->Release();
    }
    return hr;
}

// IOleCommandTarget stuff 
STDMETHODIMP CDesktopFolder::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return IUnknown_QueryStatus(_psfDesktop, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

STDMETHODIMP CDesktopFolder::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //  invalidate our cache
    //  which we dont really have right now.
    //  but CFSFolder does
    IUnknown_Exec(_psfAltDesktop, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    return IUnknown_Exec(_psfDesktop, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

STDMETHODIMP CDesktopFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        if (SUCCEEDED(Create_CDesktopViewCallback(this, &psfvcb)))
        {
            SFV_CREATE sfvc = {0};
            sfvc.cbSize = sizeof(sfvc);
            sfvc.psfvcb = psfvcb;

            hr = QueryInterface(IID_PPV_ARG(IShellFolder, &sfvc.pshf));   // in case we are agregated
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellFolderView(&sfvc, (IShellView**)ppv);
                sfvc.pshf->Release();
            }

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDropTarget) && _psfDesktop)
    {
        IDropTarget* pdt;
        if (SUCCEEDED(_psfDesktop->CreateViewObject(hwnd, riid, (void**)&pdt)))
        {
            CDesktopFolderDropTarget* pdfdt = new CDesktopFolderDropTarget(pdt);
            if (pdfdt)
            {
                hr = pdfdt->QueryInterface(IID_PPV_ARG(IDropTarget, (IDropTarget**)ppv));
                pdfdt->Release();
            }
            pdt->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IShellFolder *psfTemp;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfTemp));
        if (SUCCEEDED(hr))
        {
            HKEY hkNoFiles = NULL;

            RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), &hkNoFiles);

            hr = CDefFolderMenu_Create2Ex(&c_idlDesktop, hwnd, 0, NULL,
                    psfTemp, this, 1, &hkNoFiles, (IContextMenu **)ppv);

            psfTemp->Release();
            RegCloseKey(hkNoFiles);
        }
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfOut)
{
    if (IsSelf(cidl, apidl))
    {
        *rgfOut &= SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE;
        return S_OK;
    }

    IShellFolder2 *psf = _GetItemFolder(apidl[0]);
    if (psf)
        return psf->GetAttributesOf(cidl, apidl, rgfOut);
    return E_UNEXPECTED;
}

HRESULT CDesktopFolder::_SelfAssocCreate(REFIID riid, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(ASSOCF_INIT_DEFAULTTOFOLDER, L"{00021400-0000-0000-C000-000000000046}", // CLSID_ShellDesktop
                       NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pqa->QueryInterface(riid, ppv);
        }
        pqa->Release();
    }

    return hr;
}

STDAPI _DeskContextMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // The "safe" thing to return is usually E_NOTIMPL, but some messages
    // have special return values.

    HRESULT hr;

    switch (uMsg) 
    {
    case DFM_VALIDATECMD:
        hr = S_FALSE;
        break;

    case DFM_INVOKECOMMAND:
        if (wParam == DFM_CMD_PROPERTIES)
        {
            // Properties should act like Properties on the background
            SHRunControlPanel(TEXT("desk.cpl"), hwnd);
            hr = S_OK;
        }
        else
            hr = S_FALSE;
        break;

    case DFM_MERGECONTEXTMENU:
        hr = S_OK;
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

HRESULT CDesktopFolder::_SelfCreateContextMenu(HWND hwnd, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = _SelfAssocCreate(IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        HKEY ahkeys[2] = { NULL, NULL };
        DWORD cKeys = SHGetAssocKeys(pqa, ahkeys, ARRAYSIZE(ahkeys));
        pqa->Release();

        // We must pass cidl=1 apidl=&pidlDesktop to ensure that an
        // IDataObject is created,
        // or Symantec Internet FastFind ALERTEX.DLL will fault.

        LPCITEMIDLIST pidlDesktop = DESKTOP_PIDL;
        hr = CDefFolderMenu_Create2(&c_idlDesktop, hwnd, 1, &pidlDesktop, this, _DeskContextMenuCB,
                ARRAYSIZE(ahkeys), ahkeys, (IContextMenu **)ppv);

        SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
    }

    return hr;
}

HRESULT CDesktopFolder::_GetItemUIObject(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                         REFIID riid, UINT *prgfInOut, void **ppv)
{
    IShellFolder2 *psf = _GetItemFolder(apidl[0]);
    if (psf)
        return psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                           REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    
    *ppv = NULL;

    if (IsSelf(cidl, apidl))
    {
        // for the desktop itself
        if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)) 
        {
            hr = SHCreateDefExtIcon(NULL, II_DESKTOP, II_DESKTOP, GIL_PERCLASS, II_DESKTOP, riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IQueryInfo))
        {
            hr = CreateInfoTipFromText(MAKEINTRESOURCE(IDS_FOLDER_DESKTOP_TT), riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IContextMenu))
        {
            hr = _SelfCreateContextMenu(hwnd, ppv);
        }
        else if (IsEqualIID(riid, IID_IDropTarget))
        {
            hr = _psfDesktop->CreateViewObject(hwnd, riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            // Must create with 1 pidl inside that maps to the desktop.
            // Otherwise, CShellExecMenu::InvokeCommand will punt.
            LPCITEMIDLIST pidlDesktop = DESKTOP_PIDL;
            hr = SHCreateFileDataObject(&c_idlDesktop, 1, &pidlDesktop, NULL, (IDataObject **)ppv);
        }
        // Nobody seems to mind if we don't provide this
        // so don't give one out because AssocCreate is slow.
        // else if (IsEqualIID(riid, IID_IQueryAssociations))
        // {
        //     hr = _SelfAssocCreate(riid, ppv);
        // }
    }
    else
    {
        hr = _GetItemUIObject(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr;

    if (IsSelf(1, &pidl))
    {
        if ((dwFlags & (SHGDN_FORPARSING | SHGDN_INFOLDER | SHGDN_FORADDRESSBAR)) == SHGDN_FORPARSING)
        {
            // note some ISV apps puke if we return a full name here but the
            // rest of the shell depends on this...
            TCHAR szPath[MAX_PATH];
            SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, szPath);
            hr = StringToStrRet(szPath, pStrRet);
        }
        else
            hr = ResToStrRet(IDS_DESKTOP, pStrRet);   // display name, "Desktop"
    }
    else
    {
        IShellFolder2 *psf = _GetItemFolder(pidl);
        if (psf)
            hr = psf->GetDisplayNameOf(pidl, dwFlags, pStrRet);
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                                       LPCOLESTR pszName, DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->SetNameOf(hwnd, pidl, pszName, dwRes, ppidlOut);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return E_NOTIMPL;
}   

STDMETHODIMP CDesktopFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (_psfDesktop)
        return _psfDesktop->GetDefaultColumn(dwRes, pSort, pDisplay);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    if (_psfDesktop)
        return _psfDesktop->GetDefaultColumnState(iColumn, pdwState);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_UNEXPECTED;
    if (IsSelf(1, &pidl))
    {
        if (IsEqualSCID(*pscid, SCID_NAME))
        {
            STRRET strRet;
            hr = GetDisplayNameOf(pidl, SHGDN_NORMAL, &strRet);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStrRet(&strRet, pidl, pv);
            }
        }
    }
    else
    {
        IShellFolder2 *psf = _GetItemFolder(pidl);
        if (psf)
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
        }
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->GetDetailsOf(pidl, iColumn, pDetails);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    if (_psfDesktop)
        return _psfDesktop->MapColumnToSCID(iColumn, pscid);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetClassID(CLSID *pCLSID)
{
    *pCLSID = CLSID_ShellDesktop;
    return S_OK;
}

STDMETHODIMP CDesktopFolder::Initialize(LPCITEMIDLIST pidl)
{
    return ILIsEmpty(pidl) ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDesktopFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(&c_idlDesktop, ppidl);
}

STDMETHODIMP CDesktopFolder::TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2)
{
    *ppidlOut1 = NULL;
    *ppidlOut2 = NULL;
    *plEvent2 = -1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;

    if (pidl1)
        SHILAliasTranslate(pidl1, ppidlOut1, XLATEALIAS_DESKTOP);
    if (pidl2)
        SHILAliasTranslate(pidl2, ppidlOut2, XLATEALIAS_DESKTOP);

    if (*ppidlOut1 || *ppidlOut2)
    {
        if (!*ppidlOut1)
            *ppidlOut1 = ILClone(pidl1);

        if (!*ppidlOut2)
            *ppidlOut2 = ILClone(pidl2);

        if (*ppidlOut1 || *ppidlOut2)
        {
            return S_OK;
        }
        ILFree(*ppidlOut1);
        ILFree(*ppidlOut2);
        *ppidlOut1 = NULL;
        *ppidlOut2 = NULL;
    }
    
    return E_FAIL;
}

STDMETHODIMP CDesktopFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    IShellIcon *psi;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIcon, &psi));
    if (SUCCEEDED(hr))
    {
        hr = psi->GetIconOf(pidl, flags, piIndex);
        psi->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    IShellIconOverlay *psio;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIconOverlay, &psio));
    if (SUCCEEDED(hr))
    {
        hr = psio->GetOverlayIndex(pidl, pIndex);
        psio->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    IShellIconOverlay *psio;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIconOverlay, &psio));
    if (SUCCEEDED(hr))
    {
        hr = psio->GetOverlayIconIndex(pidl, pIconIndex);
        psio->Release();
    }
    return hr;
}

// IStorage

STDMETHODIMP CDesktopFolder::_DeleteItemByIDList(LPCITEMIDLIST pidl)
{
    IStorage *pstg;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf(this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            hr = pstg->DestroyElement(szName);
        }
        pstg->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::_StgCreate(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    IStorage *pstg;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf(this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (IsEqualIID(riid, IID_IStorage))
            {
                hr = pstg->CreateStorage(szName, grfMode, 0, 0, (IStorage **) ppv);
            }
            else if (IsEqualIID(riid, IID_IStream))
            {
                hr = pstg->CreateStream(szName, grfMode, 0, 0, (IStream **) ppv);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        pstg->Release();
    }
    return hr;
}

#define DESKTOP_EVENTS \
    SHCNE_DISKEVENTS | \
    SHCNE_ASSOCCHANGED | \
    SHCNE_NETSHARE | \
    SHCNE_NETUNSHARE

HRESULT CDesktopViewCallBack::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = CBaseShellFolderViewCB::QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        static const QITAB qit[] = {
            QITABENT(CDesktopViewCallBack, IFolderFilter),
            { 0 },
        };
        hr = QISearch(this, qit, riid, ppv);
    }
    return hr;
}

//
// Copied to shell\applets\cleanup\fldrclnr\cleanupwiz.cpp :CCleanupWiz::_ShouldShow
// If you modify this, modify that as well
//
STDMETHODIMP CDesktopViewCallBack::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr = S_OK;  //Assume that this item should be shown!
    
    if (!_fCheckedIfRealDesktop)  //Have we done this check before?
    {
        _fRealDesktop = IsDesktopBrowser(_punkSite);
        _fCheckedIfRealDesktop = TRUE;  //Remember this fact!
    }

    if (!_fRealDesktop)
        return S_OK;    //Not a real desktop! So, let's show everything!
    
    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        // Get the GUID in the pidl, which requires IShellFolder2.
        CLSID guidItem;
        if (SUCCEEDED(GetItemCLSID(psf2, pidlItem, &guidItem)))
        {
            SHELLSTATE  ss = {0};
            SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!
            
            TCHAR szRegPath[MAX_PATH];
            //Get the proper registry path based on if StartPanel is ON/OFF
            wsprintf(szRegPath, REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (ss.fStartPanelOn ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU));

            //Convert the guid to a string
            TCHAR szGuidValue[MAX_GUID_STRING_LEN];
            
            SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));

            //See if this item is turned off in the registry.
            if (SHRegGetBoolUSValue(szRegPath, szGuidValue, FALSE, /* default */FALSE))
                hr = S_FALSE; //They want to hide it; So, return S_FALSE.
        }
        psf2->Release();
    }
    
    return hr;
}

STDMETHODIMP CDesktopViewCallBack::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    return E_NOTIMPL;
}


CDesktopViewCallBack::CDesktopViewCallBack(CDesktopFolder* pdf) : 
    CBaseShellFolderViewCB((LPCITEMIDLIST)&c_idlDesktop, DESKTOP_EVENTS),
    _pdf(pdf)
{
    ASSERT(_fCheckedIfRealDesktop == FALSE);
    ASSERT(_fRealDesktop == FALSE);
}

HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv)
{
    HRESULT hr;

    CDesktopViewCallBack* p = new CDesktopViewCallBack(pdf);
    if (p)
    {
        *ppv = SAFECAST(p, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDesktopViewCallBack::OnGETCCHMAX(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcch)
{
    HRESULT hr = S_OK;
    if (SIL_GetType(pidlItem) == SHID_ROOT_REGITEM) 
    {
        // evil, we should not have to know this
        // make regfldr implement IItemNameLimits and this code won't be needed
        *pcch = MAX_REGITEMCCH;
    }
    else
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(_pdf, pidlItem, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
        {
            hr = _pdf->GetMaxLength(szName, (int *)pcch);
        }
    }
    return hr;
}

HRESULT CDesktopViewCallBack::OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR pszDir)
{
    return SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszDir);
}

HRESULT CDesktopViewCallBack::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvi)
{
    HRESULT hr = E_FAIL;
    if (IsDesktopBrowser(_punkSite))
    {
        // It's the actual desktop, use desstop.htt (from the desktop CLSID)
        //
        hr = DefaultGetWebViewTemplateFromClsid(CLSID_ShellDesktop, pvi);
    }
    return hr;
}

HRESULT CDesktopViewCallBack::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

STDMETHODIMP CDesktopViewCallBack::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGETCCHMAX);
    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);

    default:
        return E_FAIL;
    }

    return S_OK;
}

CDesktopFolderDropTarget::CDesktopFolderDropTarget(IDropTarget* pdt) : _cRef(1)
{
    pdt->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdt));
}

CDesktopFolderDropTarget::~CDesktopFolderDropTarget()
{
    _pdt->Release();
}

STDMETHODIMP CDesktopFolderDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolderDropTarget, IDropTarget),
        QITABENT(CDesktopFolderDropTarget, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDesktopFolderDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDesktopFolderDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IDropTarget
HRESULT CDesktopFolderDropTarget::DragEnter(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    return _pdt->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
}

HRESULT CDesktopFolderDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    return _pdt->DragOver(grfKeyState, pt, pdwEffect);
}

HRESULT CDesktopFolderDropTarget::DragLeave(void)
{
    return _pdt->DragLeave();
}
        
HRESULT CDesktopFolderDropTarget::SetSite(IN IUnknown * punkSite)
{
    IUnknown_SetSite(_pdt, punkSite);
    return S_OK;
}


BOOL CDesktopFolderDropTarget::_IsSpecialCaseDrop(IDataObject* pDataObject, DWORD dwEffect, BOOL* pfIsPIDA, UINT* pcItems)
{
    BOOL fIEDropped = FALSE;
    *pfIsPIDA = FALSE;

    // when we drag a fake IE item (filename.CLSID_Internet) back to the desktop, we delete it and unhide the real IE icon
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pDataObject, &medium);
    if (pida)
    {
        for (UINT i = 0; (i < pida->cidl); i++)
        {
            LPITEMIDLIST pidlFull = HIDA_ILClone(pida, i);
            if (pidlFull)
            {
                LPCITEMIDLIST pidlRelative;
                IShellFolder2* psf2;
                if (SUCCEEDED(SHBindToParent(pidlFull, IID_PPV_ARG(IShellFolder2, &psf2), &pidlRelative)))
                {
                    CLSID guidItem;
                    if (SUCCEEDED(GetItemCLSID(psf2, pidlRelative, &guidItem)) &&
                        IsEqualCLSID(CLSID_Internet, guidItem))
                    {
                        fIEDropped = TRUE;
                        TCHAR szFakeIEItem[MAX_PATH];
                        if (SHGetPathFromIDList(pidlFull, szFakeIEItem))
                        {
                            TCHAR szFakeIEItemDesktop[MAX_PATH];
                            if (SHGetSpecialFolderPath(NULL, szFakeIEItemDesktop, CSIDL_DESKTOP, 0))
                            {
                                // delete the original if this is a move or if we're on the same volume and we're neither explicitly copying nor linking
                                if (((dwEffect & DROPEFFECT_MOVE) == DROPEFFECT_MOVE) ||
                                    (((dwEffect & DROPEFFECT_COPY) != DROPEFFECT_COPY) &&
                                     ((dwEffect & DROPEFFECT_LINK) != DROPEFFECT_LINK) &&
                                      (PathIsSameRoot(szFakeIEItemDesktop, szFakeIEItem))))
                                {
                                    DeleteFile(szFakeIEItem);
                                }
                            }
                        }
                        pida->cidl--;
                        pida->aoffset[i] = pida->aoffset[pida->cidl];
                        i--; // stall the for loop
                    }
                    psf2->Release();
                }
                ILFree(pidlFull);
            }                    
        }
        *pfIsPIDA = TRUE;
        *pcItems = pida->cidl;

        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return fIEDropped;
}

HRESULT CDesktopFolderDropTarget::_ShowIEIcon()
{
    // reset desktop cleanup wizard's legacy location of "don't show IE" information
    HKEY hkey;            
    if(SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), FALSE, TRUE, &hkey)))
    {
        DWORD dwAttr, dwType = 0;
        DWORD cbSize = sizeof(dwAttr);
    
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("Attributes"), NULL, &dwType, (BYTE *) &dwAttr, &cbSize))
        {
            dwAttr &= ~SFGAO_NONENUMERATED;
            RegSetValueEx(hkey, TEXT("Attributes"), NULL, dwType, (BYTE *) &dwAttr, cbSize);
        }
        RegCloseKey(hkey);
    }

    // reset start menu's location of "don't show IE" information
    DWORD dwData = 0;
    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(SHStringFromGUID(CLSID_Internet, szCLSID, ARRAYSIZE(szCLSID))))
    {
        for (int i = 0; i < 2; i ++)
        {
            wsprintf(szBuffer, REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (i == 0) ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU);
            SHRegSetUSValue(szBuffer, szCLSID, REG_DWORD, &dwData, sizeof(DWORD), SHREGSET_FORCE_HKCU);
        }
    }

    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, DESKTOP_PIDL, NULL);

    return S_OK;
}

HRESULT CDesktopFolderDropTarget::Drop(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    BOOL fIsPIDA;
    UINT cidl;
    if (_IsSpecialCaseDrop(pDataObject, *pdwEffect, &fIsPIDA, &cidl))
    {
        _ShowIEIcon();
    }

    HRESULT hr;
    if (fIsPIDA && 0 == cidl)
    {
        hr = _pdt->DragLeave();
    }
    else
    {
        hr = _pdt->Drop(pDataObject, grfKeyState, pt, pdwEffect);        
    }

    return hr;        
}



CDesktopFolderEnum::CDesktopFolderEnum(CDesktopFolder *pdf, HWND hwnd, DWORD grfFlags) : 
    _cRef(1), _bUseAltEnum(FALSE)
{
    if (pdf->_psfDesktop)
        pdf->_psfDesktop->EnumObjects(hwnd, grfFlags, &_penumFolder);

    if (pdf->_psfAltDesktop) 
        pdf->_psfAltDesktop->EnumObjects(NULL, grfFlags, &_penumAltFolder);
}

CDesktopFolderEnum::~CDesktopFolderEnum()
{
    if (_penumFolder)
        _penumFolder->Release();

    if (_penumAltFolder)
        _penumAltFolder->Release();
}

STDMETHODIMP CDesktopFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolderEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDesktopFolderEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDesktopFolderEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDesktopFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    if (_bUseAltEnum)
    {
       if (_penumAltFolder) 
       {
           hr = _penumAltFolder->Next(celt, ppidl, pceltFetched);
       }
       else
           hr = S_FALSE;
    } 
    else if (_penumFolder)
    {
       hr = _penumFolder->Next(celt, ppidl, pceltFetched);
       if (S_OK != hr) 
       {
           _bUseAltEnum = TRUE;
           hr = Next(celt, ppidl, pceltFetched);  // recurse
       }
    }
    else
    {
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        *ppidl = NULL;
        if (pceltFetched)
            *pceltFetched = 0;
    }

    return hr;
}


STDMETHODIMP CDesktopFolderEnum::Skip(ULONG celt) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopFolderEnum::Reset() 
{
    if (_penumFolder)
        _penumFolder->Reset();

    if (_penumAltFolder)
        _penumAltFolder->Reset();

    _bUseAltEnum = FALSE;
    return S_OK;
}

STDMETHODIMP CDesktopFolderEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dragdrop.cpp ===
#include "shellprv.h"
#include "defview.h"
#include "lvutil.h"
#include "ids.h"
#include "idlcomm.h"
#pragma hdrstop

#include "datautil.h"
#include "apithk.h"

BOOL DAD_IsDraggingImage(void);
void DAD_SetDragCursor(int idCursor);
BOOL DAD_IsDragging();

#define MONITORS_MAX    16  // Is this really the max?

#define DCID_NULL       0
#define DCID_NO         1
#define DCID_MOVE       2
#define DCID_COPY       3
#define DCID_LINK       4
#define DCID_MAX        5

#define TF_DRAGIMAGES       0x02000000
#define DRAGDROP_ALPHA      120
#define MAX_WIDTH_ALPHA     200
#define MAX_HEIGHT_ALPHA    200

#define CIRCULAR_ALPHA   // Circular Alpha Blending Centered on Center of image

class CDragImages : public IDragSourceHelper, IDropTargetHelper
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() { return 2; };      // One global Com object per process
    STDMETHODIMP_(ULONG) Release() { return 1; };     // One global Com object per process

    // IDragSourceHelper methods
    STDMETHODIMP InitializeFromBitmap(LPSHDRAGIMAGE pshdi, IDataObject* pdtobj);
    STDMETHODIMP InitializeFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj);

    // IDropTargetHelper methods
    STDMETHODIMP DragEnter(HWND hwndTarget, IDataObject* pdtobj, POINT* ppt, DWORD dwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP DragOver(POINT* ppt, DWORD dwEffect);
    STDMETHODIMP Drop(IDataObject* pdtobj, POINT* ppt, DWORD dwEffect);
    STDMETHODIMP Show(BOOL fShow);

    // These are public so the DAD_* routines can access.
    BOOL IsDragging()           { return (Initialized() && _Single.bDragging);              };
    BOOL IsDraggingImage()      { return (Initialized() && _fImage && _Single.bDragging);   };
    BOOL IsDraggingLayeredWindow() { return _shdi.hbmpDragImage != NULL; };
    BOOL SetDragImage(HIMAGELIST himl, int index, POINT * pptOffset);
    void SetDragCursor(int idCursor);
    HWND GetTarget() { return _hwndTarget; }
    BOOL Initialized();
    DWORD GetThread() { return _idThread; };
    void FreeDragData();

    void ThreadDetach();
    void ProcessDetach();

    // for drag source feedback communication
    void SetDropEffectCursor(int idCur);

    CDragImages() {};

private:
    ~CDragImages();

    void _InitDragData();
    BOOL _IsLayeredSupported();

    HRESULT _SaveToDataObject(IDataObject* pdtobj);
    HRESULT _LoadFromDataObject(IDataObject* pdtobj);

    HRESULT _LoadLayerdBitmapBits(HGLOBAL hGlobal);
    HRESULT _SaveLayerdBitmapBits(HGLOBAL* phGlobal);

    BOOL _ShowDragImageInterThread(HWND hwndLock, BOOL * pfShow);

    // MultiRectDragging
    void _MultipleDragShow(BOOL bShow);
    void _MultipleDragStart(HWND hwndLock, LPRECT aRect, int nRects, POINT ptStart, POINT ptOffset);
    void _MultipleDragMove(POINT ptNew);
    HRESULT _SetLayerdDragging(LPSHDRAGIMAGE pshdi);
    HRESULT _SetMultiItemDragging(HWND hwndLV, int cItems, POINT *pptOffset);
    HRESULT _SetMultiRectDragging(int cItems, LPRECT prect, POINT *pptOffset);

    // Merged Cursors
    HBITMAP CreateColorBitmap(int cx, int cy);
    void _DestroyCachedCursors();
    HRESULT _GetCursorLowerRight(HCURSOR hcursor, int * px, int * py, POINT *pptHotSpot);
    int _MapCursorIDToImageListIndex(int idCur);
    int _AddCursorToImageList(HCURSOR hcur, LPCTSTR idMerge, POINT *pptHotSpot);
    BOOL _MergeIcons(HCURSOR hcursor, LPCTSTR idMerge, HBITMAP *phbmImage, HBITMAP *phbmMask, POINT* pptHotSpot);
    HCURSOR _SetCursorHotspot(HCURSOR hcur, POINT *ptHot);

    // Helper Routines
    BOOL _CreateDragWindow();
    BOOL _PreProcessDragBitmap(void** ppvBits);
    BOOL _IsTooBigForAlpha();

    // Member Variables
    SHDRAGIMAGE  _shdi;
    HWND         _hwndTarget;
    HWND         _hwnd;          // The HWND of the Layered Window
    HDC          _hdcDragImage;
    HBITMAP      _hbmpOld;

    BOOL         _fLayeredSupported;
    BOOL         _fCursorDataInited;

    POINT       _ptDebounce;

    // Legacy drag support
    BOOL        _fImage;
    POINT       _ptOffset;
    DWORD       _idThread;
    HIMAGELIST  _himlCursors;
    UINT        _cRev;
    int         _aindex[DCID_MAX]; // will be initialized.
    HCURSOR     _ahcur[DCID_MAX];
    POINT       _aptHotSpot[DCID_MAX];
    int         _idCursor;

    // _Single struct is used between DAD_Enter and DAD_Leave
    struct
    {
        // Common part
        BOOL    bDragging;
        BOOL    bLocked;
        HWND    hwndLock;
        BOOL    bSingle;    // Single imagelist dragging.
        DWORD   idThreadEntered;

        // Multi-rect dragging specific part
        struct 
        {
            BOOL bShown;
            LPRECT pRect;
            int nRects;
            POINT ptOffset;
            POINT ptNow;
        } _Multi;
    } _Single;

    // following fields are used only when fImage==FALSE
    RECT*       _parc;         // cItems
    UINT        _cItems;         // This is a sentinal. Needs to be the last item.
};

CDragImages::~CDragImages()
{
    FreeDragData();
}
//
// Read 'Notes' in CDropSource_GiveFeedback for detail about this
// g_fDraggingOverSource flag, which is TRUE only if we are dragging
// over the source window itself with left mouse button
// (background and large/small icon mode only).
//
UINT g_cRev = 0;
CDragImages* g_pdiDragImages = NULL;
BOOL g_fDraggingOverSource = FALSE;

STDAPI CDragImages_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut)
{
    ASSERT(pUnkOuter == NULL);  //Who's trying to aggregate us?
    if (!g_pdiDragImages)
        g_pdiDragImages = new CDragImages();

    if (g_pdiDragImages && ppvOut)  // ppvOut test for internal create usage
        return g_pdiDragImages->QueryInterface(riid, ppvOut);

    return E_OUTOFMEMORY;
}

STDMETHODIMP CDragImages::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDragImages, IDragSourceHelper),
        QITABENT(CDragImages, IDropTargetHelper),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

#define UM_KILLYOURSELF WM_USER

LRESULT CALLBACK DragWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == UM_KILLYOURSELF)
    {
        DestroyWindow(hwnd);

        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


BOOL CDragImages::_CreateDragWindow()
{
    if (_hwnd == NULL)
    {
        WNDCLASS wc = {0};

        wc.hInstance       = g_hinst;
        wc.lpfnWndProc     = DragWndProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName   = TEXT("SysDragImage");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
        SHRegisterClass(&wc);

        _hwnd = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW, 
            TEXT("SysDragImage"), TEXT("Drag"), WS_POPUPWINDOW,
            0, 0, 50, 50, NULL, NULL, g_hinst, NULL);

        if (!_hwnd)
            return FALSE;

        //
        // This window should not be mirrored so that the image contents won't be flipped. [samera]
        //
        SetWindowBits(_hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
    }

    return TRUE;
}

BOOL CDragImages::Initialized()
{ 
    return _fCursorDataInited; 
}

void CDragImages::FreeDragData()
{

    if (_hwnd)
    {
        SendMessage(_hwnd, UM_KILLYOURSELF, 0, 0);
        _hwnd = NULL;
    }

    _fCursorDataInited = FALSE;

    // Make sure we destroy the cursors on an invalidate.
    if (_himlCursors)
        _DestroyCachedCursors();

    // Do we have an array?
    if (_parc)
    {
        delete _parc;
        _parc = NULL;
    }

    if (_fImage)
        ImageList_EndDrag();

    if (_hbmpOld)
    {
        SelectObject(_hdcDragImage, _hbmpOld);
        _hbmpOld = NULL;
    }

    if (_hdcDragImage)
    {
        DeleteDC(_hdcDragImage);
        _hdcDragImage = NULL;
    }

    if (_shdi.hbmpDragImage)
        DeleteObject(_shdi.hbmpDragImage);

    ZeroMemory(&_Single, sizeof(_Single));
    ZeroMemory(&_shdi, sizeof(_shdi));

    _ptOffset.x = 0;
    _ptOffset.y = 0;

    _ptDebounce.x = 0;
    _ptDebounce.y = 0;

    _hwndTarget = _hwnd = NULL;
    _fCursorDataInited = _fLayeredSupported = FALSE;
    _fImage = FALSE;
    _idThread = 0;
    _himlCursors = NULL;
    _cRev = 0;
    _idCursor = 0;
}

void CDragImages::_InitDragData()
{
    _idThread = GetCurrentThreadId();

    if (_himlCursors && _cRev != g_cRev)
        _DestroyCachedCursors();

    if (_himlCursors == NULL)
    {
        UINT uFlags = ILC_MASK | ILC_SHARED;
        if (IS_BIDI_LOCALIZED_SYSTEM())
            uFlags |= ILC_MIRROR;

        //
        // if this is not a palette device, use a DDB for the imagelist
        // this is important when displaying high-color cursors
        //
        HDC hdc = GetDC(NULL);
        if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
        {
            uFlags |= ILC_COLORDDB;
        }
        ReleaseDC(NULL, hdc);

        _himlCursors = ImageList_Create(GetSystemMetrics(SM_CXCURSOR),
                                        GetSystemMetrics(SM_CYCURSOR),
                                        uFlags, 1, 0);

        _cRev = g_cRev;

        // We need to initialize s_cursors._aindex[*]
        _MapCursorIDToImageListIndex(-1);
    }
    _fCursorDataInited = TRUE;
}

BOOL AreAllMonitorsAtLeast(int iBpp)
{
    DISPLAY_DEVICE DisplayDevice;
    BOOL fAreAllMonitorsAtLeast = TRUE;

    for (int iEnum = 0; fAreAllMonitorsAtLeast && iEnum < MONITORS_MAX; iEnum++)
    {
        ZeroMemory(&DisplayDevice, sizeof(DISPLAY_DEVICE));
        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

        if (EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0) &&
            (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
        {

            HDC hdc = CreateDC(NULL, (LPTSTR)DisplayDevice.DeviceName, NULL, NULL);
            if (hdc)
            {
                int iBits = GetDeviceCaps(hdc, BITSPIXEL);

                if (iBits < iBpp)
                    fAreAllMonitorsAtLeast = FALSE;

                DeleteDC(hdc);
            }
        }
    }

    return fAreAllMonitorsAtLeast;
}

BOOL CDragImages::_IsLayeredSupported()
{
    // For the first rev, we will only support Layered drag images
    // when the Color depth is greater than 65k colors.

    // We should ask everytime....
    _fLayeredSupported = AreAllMonitorsAtLeast(16);
    
    if (_fLayeredSupported)
    {
        BOOL bDrag;
        if (SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &bDrag, 0))
        {
            _fLayeredSupported = BOOLIFY(bDrag);
        }

        if (_fLayeredSupported)
            _fLayeredSupported = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("NewDragImages"), FALSE, TRUE);
    }
    return _fLayeredSupported;
}

//
// initialize the static drag image manager from a structure
// this is implemented for WindowLess controls that can act as a
// drag source.
//
HRESULT CDragImages::_SetLayerdDragging(LPSHDRAGIMAGE pshdi)
{
    // We don't support being initialized from a bitmap when Layered Windows are not supported
    HRESULT hr;
    if (_IsLayeredSupported())
    {
        RIP(IsValidHANDLE(pshdi->hbmpDragImage));

        _shdi = *pshdi;     // Keep a copy of this.

        _idCursor = -1;     // Initialize this... This is an arbitraty place and can be put 
                            // anywhere before the first Setcursor call
        _InitDragData();
        hr = S_OK;
    }
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CDragImages::InitializeFromBitmap(LPSHDRAGIMAGE pshdi, IDataObject* pdtobj)
{
    FreeDragData();

    HRESULT hr = _SetLayerdDragging(pshdi);
    if (SUCCEEDED(hr))
    {
        hr = _SaveToDataObject(pdtobj);
        if (FAILED(hr))
            FreeDragData();
    }
    return hr;
}

BOOL ListView_HasMask(HWND hwnd)
{
    HIMAGELIST himl = ListView_GetImageList(hwnd, LVSIL_NORMAL);
    return himl && (ImageList_GetFlags(himl) & ILC_MASK);
}

//
// initialize the static drag image manager from an HWND that
// can process the RegisteredWindowMessage(DI_GETDRAGIMAGE)
//
STDMETHODIMP CDragImages::InitializeFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj)
{
    HRESULT hr = E_FAIL;

    FreeDragData();

    if (_IsLayeredSupported())
    {
        // Register the message that gets us the Bitmap from the control.
        static int g_msgGetDragImage = 0;
        if (g_msgGetDragImage == 0)
            g_msgGetDragImage = RegisterWindowMessage(DI_GETDRAGIMAGE);

        // Can this HWND generate a drag image for me?
        if (g_msgGetDragImage && SendMessage(hwnd, g_msgGetDragImage, 0, (LPARAM)&_shdi))
        {
            // Yes; Now we select that into the window 
            hr = _SetLayerdDragging(&_shdi);
        }
    }

    if (FAILED(hr))
    {
        TCHAR szClassName[50];

        if (GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName))) 
        {
            if (lstrcmpi(szClassName, WC_LISTVIEW) == 0)
            {
                POINT ptOffset = {0,0};

                if (ppt)
                    ptOffset = *ppt;

                int cItems = ListView_GetSelectedCount(hwnd);
                if (cItems >= 1)
                {
                    if ((cItems == 1) && ListView_HasMask(hwnd))
                    {
                        POINT ptTemp;
                        HIMAGELIST himl = ListView_CreateDragImage(hwnd, ListView_GetNextItem(hwnd, -1, LVNI_SELECTED), &ptTemp);
                        if (himl)
                        {
                            ClientToScreen(hwnd, &ptTemp);
                            ptOffset.x -= ptTemp.x;

                            // Since the listview is mirrored, then mirror the selected
                            // icon coord. This would result in negative offset so let's
                            // compensate. [samera]
                            if (IS_WINDOW_RTL_MIRRORED(hwnd))
                                ptOffset.x *= -1;

                            ptOffset.y -= ptTemp.y;
                            SetDragImage(himl, 0, &ptOffset);
                            ImageList_Destroy(himl);
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = _SetMultiItemDragging(hwnd, cItems, &ptOffset);
                    }
                }
            }
            else if (lstrcmpi(szClassName, WC_TREEVIEW) == 0)
            {
                HIMAGELIST himlDrag = TreeView_CreateDragImage(hwnd, NULL);
                if (himlDrag) 
                {
                    SetDragImage(himlDrag, 0, NULL);
                    ImageList_Destroy(himlDrag);
                    hr = S_OK;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // ignore failure here as this will still work in process due to the globals
        // fonts folder depends on this
        _SaveToDataObject(pdtobj);
    }

    return hr;
}

//
//  create the drag window in the layered window case, or to begin drawing the 
//  Multi Rect or icon drag images.
//
STDMETHODIMP CDragImages::DragEnter(HWND hwndTarget, IDataObject* pdtobj, POINT* ppt, DWORD dwEffect)
{
    HRESULT hr = _LoadFromDataObject(pdtobj);
    if (SUCCEEDED(hr))
    {
        _hwndTarget = hwndTarget ? hwndTarget : GetDesktopWindow();
        SetDragCursor(-1);
        _Single.bDragging = TRUE;
        _Single.bSingle = _fImage;
        _Single.hwndLock = _hwndTarget;
        _Single.bLocked = FALSE;
        _Single.idThreadEntered = GetCurrentThreadId();

        _ptDebounce.x = 0;
        _ptDebounce.y = 0;

        if (_shdi.hbmpDragImage)
        {
            TraceMsg(TF_DRAGIMAGES, "CDragImages::DragEnter : Creating Drag Window");
            // At this point the information has been read from the data object. 
            // Reconstruct the HWND if necessary
            if (_CreateDragWindow() && _hdcDragImage)
            {
                POINT ptSrc = {0, 0};
                POINT pt;

                SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | 
                    SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                GetMsgPos(&pt);

                pt.x -= _shdi.ptOffset.x;
                pt.y -= _shdi.ptOffset.y;

                BLENDFUNCTION blend;
                blend.BlendOp = AC_SRC_OVER;
                blend.BlendFlags = 0;
                blend.AlphaFormat = AC_SRC_ALPHA;
                blend.SourceConstantAlpha = 0xFF /*DRAGDROP_ALPHA*/;

                HDC hdc = GetDC(_hwnd);
                if (hdc)
                {
                    DWORD fULWType = ULW_ALPHA;

                    // Should have been preprocess already
                    UpdateLayeredWindow(_hwnd, hdc, &pt, &(_shdi.sizeDragImage), 
                                        _hdcDragImage, &ptSrc, _shdi.crColorKey,
                                        &blend, fULWType);

                    ReleaseDC(_hwnd, hdc);
                }
                hr = S_OK;
            }
        }
        else
        {
            // These are in Client Cordinates, not screen coords. Translate:
            POINT pt = *ppt;
            RECT rc;
            GetWindowRect(_hwndTarget, &rc);
            pt.x -= rc.left;
            pt.y -= rc.top;
            if (_fImage)
            {
                // Avoid the flicker by always pass even coords
                ImageList_DragEnter(hwndTarget, pt.x & ~1, pt.y & ~1);
                hr = S_OK;
            }
            else
            {
                _MultipleDragStart(hwndTarget, _parc, _cItems, pt, _ptOffset);
                hr = S_OK;
            }
        }

        //
        // We should always show the image whenever this function is called.
        //
        Show(TRUE);
    }
    return hr;
}

//
//  kill the Layered Window, or to stop painting the icon or rect drag images
//
STDMETHODIMP CDragImages::DragLeave()
{
    TraceMsg(TF_DRAGIMAGES, "CDragImages::DragLeave");
    if (Initialized())
    {
        if (_hwnd)
        {
            FreeDragData();
        }
        else if (_Single.bDragging &&
             _Single.idThreadEntered == GetCurrentThreadId())
        {
            Show(FALSE);

            if (_fImage)
            {
                ImageList_DragLeave(_Single.hwndLock);
            }

            _Single.bDragging = FALSE;

            DAD_SetDragImage((HIMAGELIST)-1, NULL);
        }

        _ptDebounce.x = 0;
        _ptDebounce.y = 0;
    }

    return S_OK;
}

//  move the Layered window or to rerender the icon or rect images within
//  the Window they are over.
//
STDMETHODIMP CDragImages::DragOver(POINT* ppt, DWORD dwEffect)
{
    if (Initialized())
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::DragOver pt {%d, %d}", ppt->x, ppt->y);
        // Avoid the flicker by always pass even coords
        ppt->x &= ~1;
        ppt->y &= ~1;

        if (_ptDebounce.x != ppt->x || _ptDebounce.y != ppt->y)
        {
            _ptDebounce.x = ppt->x;
            _ptDebounce.y = ppt->y;
            if (IsDraggingLayeredWindow())
            {
                POINT pt;
                GetCursorPos(&pt);
                pt.x -= _shdi.ptOffset.x;
                pt.y -= _shdi.ptOffset.y;

                SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | 
                    SWP_NOSIZE | SWP_SHOWWINDOW);

                UpdateLayeredWindow(_hwnd, NULL, &pt, NULL, NULL, NULL, 0,
                    NULL, 0);
            }
            else
            {
                // These are in Client Cordinates, not screen coords. Translate:
                POINT pt = *ppt;
                RECT rc;
                GetWindowRect(_hwndTarget, &rc);
                pt.x -= rc.left;
                pt.y -= rc.top;
                if (_fImage)
                {
                    ImageList_DragMove(pt.x, pt.y);
                }
                else
                {
                    _MultipleDragMove(pt);
                }
            }
        }
    }

    return S_OK;
}

//  do any cleanup after a drop (Currently calls DragLeave)
//
STDMETHODIMP CDragImages::Drop(IDataObject* pdtobj, POINT* ppt, DWORD dwEffect)
{
    return DragLeave();
}

//  initialize the static drag image manager from a structure
//  this is implemented for WindowLess controls that can act as a
//  drag source.
//
void CDragImages::SetDragCursor(int idCursor)
{
    //
    // Ignore if we are dragging over ourselves.
    //
    if (IsDraggingImage())
    {
        POINT ptHotSpot;

        if (_himlCursors && (idCursor != -1))
        {
            int iIndex = _MapCursorIDToImageListIndex(idCursor);
            if (iIndex != -1) 
            {
                ImageList_GetDragImage(NULL, &ptHotSpot);
                ptHotSpot.x -= _aptHotSpot[idCursor].x;
                ptHotSpot.y -= _aptHotSpot[idCursor].y;
                if (ptHotSpot.x < 0)
                {
                    ptHotSpot.x = 0;
                }

                if (ptHotSpot.y < 0)
                {
                    ptHotSpot.y = 0;
                }

                ImageList_SetDragCursorImage(_himlCursors, iIndex, ptHotSpot.x, ptHotSpot.y);
            } 
            else 
            {
                // You passed a bad Cursor ID.
                ASSERT(0);
            }
        }

        _idCursor = idCursor;
    }
}

// init our state from the hGlobal so we can draw 
HRESULT CDragImages::_LoadLayerdBitmapBits(HGLOBAL hGlobal)
{
    HRESULT hr = E_FAIL;

    if (!Initialized())
    {
        ASSERT(_shdi.hbmpDragImage == NULL);
        ASSERT(_hdcDragImage == NULL);

        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            void *pvDragStuff = (void*)GlobalLock(hGlobal);
            if (pvDragStuff)
            {
                CopyMemory(&_shdi, pvDragStuff, sizeof(SHDRAGIMAGE));

                BITMAPINFO bmi = {0};

                // Create a buffer to read the bits into
                bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
                bmi.bmiHeader.biWidth       = _shdi.sizeDragImage.cx;
                bmi.bmiHeader.biHeight      = _shdi.sizeDragImage.cy;
                bmi.bmiHeader.biPlanes      = 1;
                bmi.bmiHeader.biBitCount    = 32;
                bmi.bmiHeader.biCompression = BI_RGB;

                // Next create a DC and an HBITMAP.
                _hdcDragImage = CreateCompatibleDC(hdcScreen);
                if (_hdcDragImage)
                {
                    void *pvBits;
                    _shdi.hbmpDragImage = CreateDIBSection(_hdcDragImage, &bmi, DIB_RGB_COLORS, &pvBits, NULL, NULL);
                    if (_shdi.hbmpDragImage)
                    {
                        _hbmpOld = (HBITMAP)SelectObject(_hdcDragImage, _shdi.hbmpDragImage);

                        // then Set the bits into the Bitmap
                        RGBQUAD* pvStart = (RGBQUAD*)((BYTE*)pvDragStuff + sizeof(SHDRAGIMAGE));
                        DWORD dwCount = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
                        CopyMemory((RGBQUAD*)pvBits, (RGBQUAD*)pvStart, dwCount);

                        hr = S_OK;    // success!
                    }
                }
                GlobalUnlock(hGlobal);
            }
            ReleaseDC(NULL, hdcScreen);
        }
    }
    return hr;
}

// Writes the written information into phGlobal to recreate the drag image
HRESULT CDragImages::_SaveLayerdBitmapBits(HGLOBAL* phGlobal)
{
    HRESULT hr = E_FAIL;
    if (Initialized())
    {
        ASSERT(_shdi.hbmpDragImage);

        DWORD cbImageSize = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
        *phGlobal = GlobalAlloc(GPTR, cbImageSize + sizeof(SHDRAGIMAGE));
        if (*phGlobal)
        {
            void *pvDragStuff = GlobalLock(*phGlobal);
            CopyMemory(pvDragStuff, &_shdi, sizeof(SHDRAGIMAGE));

            void *pvBits;
            hr = _PreProcessDragBitmap(&pvBits) ? S_OK : E_FAIL;
            if (SUCCEEDED(hr))
            {
                RGBQUAD* pvStart = (RGBQUAD*)((BYTE*)pvDragStuff + sizeof(SHDRAGIMAGE));
                DWORD dwCount = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
                CopyMemory((RGBQUAD*)pvStart, (RGBQUAD*)pvBits, dwCount);
            }
            GlobalUnlock(*phGlobal);
        }
    }
    return hr;
}

BOOL CDragImages::_IsTooBigForAlpha()
{
    BOOL fTooBig = FALSE;
    int dSelectionArea = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy;

    // The number here is "It just feels right" or 
    // about 3 Thumbnail icons linned up next to each other.
    if ( dSelectionArea > 0x10000 )
        fTooBig = TRUE;

    return fTooBig;
}


BOOL IsColorKey(RGBQUAD rgbPixel, COLORREF crKey)
{
    // COLORREF is backwards to RGBQUAD
    return InRange( rgbPixel.rgbBlue,  ((crKey & 0xFF0000) >> 16) - 5, ((crKey & 0xFF0000) >> 16) + 5) &&
           InRange( rgbPixel.rgbGreen, ((crKey & 0x00FF00) >>  8) - 5, ((crKey & 0x00FF00) >>  8) + 5) &&
           InRange( rgbPixel.rgbRed,   ((crKey & 0x0000FF) >>  0) - 5, ((crKey & 0x0000FF) >>  0) + 5);
}

#ifdef RADIAL

int QuickRoot(int n, int iNum)
{

    int iRoot = iNum;
    for (int i=10; i > 0; i--)
    {
        int iOld = iRoot;
        iRoot = (iRoot + iNum/iRoot)/2;
        if (iRoot == iOld)
            break;
    }

    return iRoot;
}

#endif

BOOL CDragImages::_PreProcessDragBitmap(void** ppvBits)
{
    BOOL fRet = FALSE;

    ASSERT(_hdcDragImage == NULL);
    _hdcDragImage = CreateCompatibleDC(NULL);
    if (_hdcDragImage)
    {
        ULONG*          pul;
        HBITMAP         hbmpResult = NULL;
        HBITMAP         hbmpOld;
        HDC             hdcSource = NULL;
        BITMAPINFO      bmi = {0};
        HBITMAP         hbmp = _shdi.hbmpDragImage;

        bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth       = _shdi.sizeDragImage.cx;
        bmi.bmiHeader.biHeight      = _shdi.sizeDragImage.cy;
        bmi.bmiHeader.biPlanes      = 1;
        bmi.bmiHeader.biBitCount    = 32;
        bmi.bmiHeader.biCompression = BI_RGB;

        hdcSource = CreateCompatibleDC(_hdcDragImage);
        if (hdcSource)
        {
            hbmpResult = CreateDIBSection(_hdcDragImage,
                                       &bmi,
                                       DIB_RGB_COLORS,
                                       ppvBits,
                                       NULL,
                                       0);

            if (hbmpResult)
            {
                _hbmpOld = (HBITMAP)SelectObject(_hdcDragImage, hbmpResult);
                hbmpOld = (HBITMAP)SelectObject(hdcSource, hbmp);

                BitBlt(_hdcDragImage, 0, 0, _shdi.sizeDragImage.cx, _shdi.sizeDragImage.cy,
                       hdcSource, 0, 0, SRCCOPY);

                pul = (ULONG*)*ppvBits;

                int iOffsetX = _shdi.ptOffset.x;
                int iOffsetY = _shdi.ptOffset.y;
                int iDenomX = max(_shdi.sizeDragImage.cx - iOffsetX, iOffsetX);
                int iDenomY = max(_shdi.sizeDragImage.cy - iOffsetY, iOffsetY);
                BOOL fRadialFade = TRUE;
                // If both are less than the max, then no radial fade.
                if (_shdi.sizeDragImage.cy <= MAX_HEIGHT_ALPHA && _shdi.sizeDragImage.cx <= MAX_WIDTH_ALPHA)
                    fRadialFade = FALSE;

                for (int Y = 0; Y < _shdi.sizeDragImage.cy; Y++)
                {
                    int y = _shdi.sizeDragImage.cy - Y; // Bottom up DIB.
                    for (int x = 0; x < _shdi.sizeDragImage.cx; x++)
                    {
                        RGBQUAD* prgb = (RGBQUAD*)&pul[Y * _shdi.sizeDragImage.cx + x];

                        if (_shdi.crColorKey != CLR_NONE && 
                            IsColorKey(*prgb, _shdi.crColorKey))
                        {
                            // Write a pre-multiplied value of 0:

                            *((DWORD*)prgb) = 0;
                        }
                        else
                        {
                            int Alpha = prgb->rgbReserved;
                            if (_shdi.crColorKey != CLR_NONE)
                            {
                                Alpha = DRAGDROP_ALPHA;
                            }
                            else
                            {
                                Alpha -= (Alpha / 3);
                            }

                            if (fRadialFade && Alpha > 0)
                            {
                                // This does not generate a smooth curve, but this is just
                                // an effect, not trying to be accurate here.

                                // 3 devides per pixel
                                int ddx = (x < iOffsetX)? iOffsetX - x : x - iOffsetX;
                                int ddy = (y < iOffsetY)? iOffsetY - y : y - iOffsetY;

                                __int64 iAlphaX = (100000l - (((__int64)ddx * 100000l) / (iDenomX )));
                                __int64 iAlphaY = (100000l - (((__int64)ddy * 100000l) / (iDenomY )));

                                ASSERT (iAlphaX >= 0);
                                ASSERT (iAlphaY >= 0);

                                __int64 iDenom = 100000;
                                iDenom *= 100000;

                                Alpha = (int) ((Alpha * iAlphaX * iAlphaY * 100000) / (iDenom* 141428));
                            }

                            ASSERT(Alpha <= 0xFF);
                            prgb->rgbReserved = (BYTE)Alpha;
                            prgb->rgbRed      = ((prgb->rgbRed   * Alpha) + 128) / 255;
                            prgb->rgbGreen    = ((prgb->rgbGreen * Alpha) + 128) / 255;
                            prgb->rgbBlue     = ((prgb->rgbBlue  * Alpha) + 128) / 255;
                        }
                    }
                }

                DeleteObject(hbmp);
                _shdi.hbmpDragImage = hbmpResult;

                fRet = TRUE;

                if (hbmpOld)
                    SelectObject(hdcSource, hbmpOld);
            }

            DeleteObject(hdcSource);
        }
    }

    return fRet;
}

CLIPFORMAT _GetDragContentsCF()
{
    static UINT s_cfDragContents = 0;
    if (0 == s_cfDragContents)
        s_cfDragContents = RegisterClipboardFormat(CFSTR_DRAGCONTEXT);
    return (CLIPFORMAT) s_cfDragContents;
}

CLIPFORMAT _GetDragImageBitssCF()
{
    static UINT s_cfDragImageBitss = 0;
    if (0 == s_cfDragImageBitss)
        s_cfDragImageBitss = RegisterClipboardFormat(TEXT("DragImageBits"));
    return (CLIPFORMAT) s_cfDragImageBitss;
}


// persist our state into the data object. so on the target side they can grab this
// data out and render the thing being dragged

HRESULT CDragImages::_SaveToDataObject(IDataObject *pdtobj)
{
    HRESULT hr = E_FAIL;    // one form of the saves below must succeed
    if (Initialized())
    {
        STGMEDIUM medium = {0};
        medium.tymed = TYMED_ISTREAM;

        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &medium.pstm)))
        {
            // Set the header .
            DragContextHeader hdr = {0};
            hdr.fImage   = _fImage;
            hdr.fLayered = IsDraggingLayeredWindow();
            hdr.ptOffset = _ptOffset;
       
            //First Write the drag context header
            ULONG ulWritten;
            if (SUCCEEDED(medium.pstm->Write(&hdr, sizeof(hdr), &ulWritten)) &&
                (ulWritten == sizeof(hdr)))
            {
                if (hdr.fLayered)
                {
                    STGMEDIUM mediumBits = {0};
                    // Set the medium.
                    mediumBits.tymed = TYMED_HGLOBAL;

                    // Write out layered window information
                    hr = _SaveLayerdBitmapBits(&mediumBits.hGlobal);
                    if (SUCCEEDED(hr))
                    {
                        FORMATETC fmte = {_GetDragImageBitssCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

                        // Set the medium in the data.
                        hr = pdtobj->SetData(&fmte, &mediumBits, TRUE);
                        if (FAILED(hr))
                            ReleaseStgMedium(&mediumBits);  // cleanup
                    }
                }
                else if (hdr.fImage)
                {
                    // write an image
    
                    HIMAGELIST himl = ImageList_GetDragImage(NULL, NULL);
                    if (ImageList_Write(himl, medium.pstm))
                    {
                        hr = S_OK;  // success
                    }
                }
                else
                {
                    // multi rect
        
                    if (SUCCEEDED(medium.pstm->Write(&_cItems, sizeof(_cItems), &ulWritten)) &&
                        (ulWritten == sizeof(_cItems)))
                    {
                        // Write the  rects into the stream
                        if (SUCCEEDED(medium.pstm->Write(_parc, sizeof(_parc[0]) * _cItems, &ulWritten)) && 
                            (ulWritten == (sizeof(_parc[0]) * _cItems)))
                        {
                            hr = S_OK;  // success
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Set the seek pointer at the beginning.
                    medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                    // Set the Formatetc
                    FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};

                    // Set the medium in the data.
                    hr = pdtobj->SetData(&fmte, &medium, TRUE);
                }
            }

            if (FAILED(hr))
                ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

// Gets the information to rebuild the drag images from the data object
HRESULT CDragImages::_LoadFromDataObject(IDataObject *pdtobj)
{
    // Check if we have a drag context
    HRESULT hr;

    // NULL pdtobj is for the old DAD_DragEnterXXX() APIs...
    // we hope this in the same process
    if (Initialized() || !pdtobj)
    {
        hr = S_OK;    // already loaded
    }
    else
    {
        // Set the format we are interested in
        FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};

        //if the data object has the format we are interested in
        // then Get the data
        STGMEDIUM medium = {0};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))   // if no pstm, bag out.
        {
            // Set the seek pointer at the beginning. PARANOIA: This is for people
            // Who don't set the seek for me.
            medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

            //First Read the drag context header
            DragContextHeader hdr;
            if (SUCCEEDED(IStream_Read(medium.pstm, &hdr, sizeof(hdr))))
            {
                if (hdr.fLayered)
                {
                    STGMEDIUM mediumBits;
                    FORMATETC fmte = {_GetDragImageBitssCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

                    hr = pdtobj->GetData(&fmte, &mediumBits);
                    if (SUCCEEDED(hr))
                    {
                        hr = _LoadLayerdBitmapBits(mediumBits.hGlobal);
                        ReleaseStgMedium(&mediumBits);
                    }
                }
                else if (hdr.fImage)
                {
                    // single image
                    HIMAGELIST himl = ImageList_Read(medium.pstm);
                    if (himl)
                    {
                        DAD_SetDragImage(himl, &(hdr.ptOffset));
                        ImageList_Destroy(himl);
                        hr = S_OK;
                    }
                }
                else
                {
                    // multi rect
                    int cItems;
                    if (SUCCEEDED(IStream_Read(medium.pstm, &cItems, sizeof(cItems))))
                    {
                        RECT *prect = (RECT *)LocalAlloc(LPTR, sizeof(*prect) * cItems);
                        if (prect)
                        {
                            if (SUCCEEDED(IStream_Read(medium.pstm, prect, sizeof(*prect) * cItems)))
                            {
                                hr = _SetMultiRectDragging(cItems, prect, &hdr.ptOffset);
                            }
                            LocalFree(prect);
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
                _InitDragData();

            // Set the seek pointer at the beginning. Just cleaning up...
            medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

            // Release the stg medium.
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}


// Shows or hides the drag images. NOTE: Doesn't do anything in the layered window case.
// We don't need to because this function is specifically for drawing to a locked window.
STDMETHODIMP CDragImages::Show(BOOL bShow)
{
    BOOL fOld = bShow;
    TraceMsg(TF_DRAGIMAGES, "CDragImages::Show(%s)", bShow? TEXT("true") : TEXT("false"));

    if (!Initialized() || !_Single.bDragging)
    {
        return S_FALSE;
    }

    // No point in showing and hiding a Window. This causes unnecessary flicker.
    if (_hwnd)
    {
        return S_OK;
    }

    // If we're going across thread boundaries we have to try a context switch
    if (GetCurrentThreadId() != GetWindowThreadProcessId(_Single.hwndLock, NULL) &&
        _ShowDragImageInterThread(_Single.hwndLock, &fOld))
        return fOld;

    fOld = _Single.bLocked;

    //
    // If we are going to show the drag image, lock the target window.
    //
    if (bShow && !_Single.bLocked)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : Shown and not locked");
        UpdateWindow(_Single.hwndLock);
        LockWindowUpdate(_Single.hwndLock);
        _Single.bLocked = TRUE;
    }

    if (_Single.bSingle)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : Calling ImageList_DragShowNoLock");
        ImageList_DragShowNolock(bShow);
    }
    else
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : MultiDragShow");
        _MultipleDragShow(bShow);
    }

    //
    // If we have just hide the drag image, unlock the target window.
    //
    if (!bShow && _Single.bLocked)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : hiding image, unlocking");
        LockWindowUpdate(NULL);
        _Single.bLocked = FALSE;
    }

    return fOld ? S_OK : S_FALSE;
}

// tell the drag source to hide or unhide the drag image to allow
// the destination to do drawing (unlock the screen)
//
// in:
//      bShow   FALSE   - hide the drag image, allow drawing
//              TRUE    - show the drag image, no drawing allowed after this

// Helper function for DAD_ShowDragImage - handles the inter-thread case.
// We need to handle this case differently because LockWindowUpdate calls fail
// if they are on the wrong thread.

BOOL CDragImages::_ShowDragImageInterThread(HWND hwndLock, BOOL * pfShow)
{
    TCHAR szClassName[50];

    if (GetClassName(hwndLock, szClassName, ARRAYSIZE(szClassName))) 
    {
        UINT uMsg = 0;
        ULONG_PTR dw = 0;

        if (lstrcmpi(szClassName, TEXT("SHELLDLL_DefView")) == 0)
            uMsg = WM_DSV_SHOWDRAGIMAGE;
        if (lstrcmpi(szClassName, TEXT("CabinetWClass")) == 0)
            uMsg = CWM_SHOWDRAGIMAGE;

        if (uMsg) 
        {
            SendMessageTimeout(hwndLock, uMsg, 0, *pfShow, SMTO_ABORTIFHUNG, 1000, &dw);
            *pfShow = (dw != 0);
            return TRUE;
        }
    }

    return FALSE;
}

void CDragImages::ThreadDetach()
{
    if (_idThread == GetCurrentThreadId())
        FreeDragData();
}

void CDragImages::ProcessDetach()
{
    FreeDragData();
}

BOOL CDragImages::SetDragImage(HIMAGELIST himl, int index, POINT * pptOffset)
{
    if (himl)
    {
        // We are setting
        if (Initialized())
            return FALSE;

        _fImage = TRUE;
        if (pptOffset) 
        {
            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
        }

        ImageList_BeginDrag(himl, index, _ptOffset.x, _ptOffset.y);
        _InitDragData();
    }
    else
    {
        FreeDragData();
    }
    return TRUE;
}

//=====================================================================
// Multile Drag show
//=====================================================================

void CDragImages::_MultipleDragShow(BOOL bShow)
{
    HDC hDC;
    int nRect;
    RECT rc, rcClip;

    if ((bShow && _Single._Multi.bShown) || (!bShow && !_Single._Multi.bShown))
        return;

    _Single._Multi.bShown = bShow;

    // clip to window, NOT SM_CXSCREEN/SM_CYSCREEN (multiple monitors)
    GetWindowRect(_Single.hwndLock, &rcClip);
    rcClip.right -= rcClip.left;
    rcClip.bottom -= rcClip.top;

    hDC = GetDCEx(_Single.hwndLock, NULL, DCX_WINDOW | DCX_CACHE |
        DCX_LOCKWINDOWUPDATE | DCX_CLIPSIBLINGS);


    for (nRect = _Single._Multi.nRects - 1; nRect >= 0; --nRect)
    {
        rc = _Single._Multi.pRect[nRect];
        OffsetRect(&rc, _Single._Multi.ptNow.x - _Single._Multi.ptOffset.x,
            _Single._Multi.ptNow.y - _Single._Multi.ptOffset.y);

        if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
            (rc.left < rcClip.right) && (rc.right > 0))
        {
            DrawFocusRect(hDC, &rc);
        }
    }
    ReleaseDC(_Single.hwndLock, hDC);
}

void CDragImages::_MultipleDragStart(HWND hwndLock, LPRECT aRect, int nRects, POINT ptStart, POINT ptOffset)
{
    _Single._Multi.bShown = FALSE;
    _Single._Multi.pRect = aRect;
    _Single._Multi.nRects = nRects;
    _Single._Multi.ptOffset = ptOffset;
    _Single._Multi.ptNow = ptStart;
}

void CDragImages::_MultipleDragMove(POINT ptNew)
{
    if ((_Single._Multi.ptNow.x == ptNew.x) &&
        (_Single._Multi.ptNow.y == ptNew.y))
    {
        // nothing has changed.  bail
        return;
    }

    if (_Single._Multi.bShown)
    {
        HDC hDC;
        int nRect;
        RECT rc, rcClip;
        int dx1 = _Single._Multi.ptNow.x - _Single._Multi.ptOffset.x;
        int dy1 = _Single._Multi.ptNow.y - _Single._Multi.ptOffset.y;
        int dx2 = ptNew.x - _Single._Multi.ptNow.x;
        int dy2 = ptNew.y - _Single._Multi.ptNow.y;

        // clip to window, NOT SM_CXSCREEN/SM_CYSCREEN (multiple monitors)
        GetWindowRect(_Single.hwndLock, &rcClip);
        rcClip.right -= rcClip.left;
        rcClip.bottom -= rcClip.top;

        hDC = GetDCEx(_Single.hwndLock, NULL, DCX_WINDOW | DCX_CACHE |
            DCX_LOCKWINDOWUPDATE | DCX_CLIPSIBLINGS);

        for (nRect = _Single._Multi.nRects - 1; nRect >= 0; --nRect)
        {
            rc = _Single._Multi.pRect[nRect];
            // hide pass
            OffsetRect(&rc, dx1, dy1);
            if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
                (rc.left < rcClip.right) && (rc.right > 0))
            {

                DrawFocusRect(hDC, &rc);
            }
            // show pass
            OffsetRect(&rc, dx2, dy2);
            if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
                (rc.left < rcClip.right) && (rc.right > 0))
            {
                DrawFocusRect(hDC, &rc);
            }
        }
        ReleaseDC(_Single.hwndLock, hDC);
    }

    _Single._Multi.ptNow = ptNew;
}

HRESULT CDragImages::_SetMultiRectDragging(int cItems, LPRECT prect, POINT *pptOffset)
{
    if (!Initialized())
    {
        // Multiple item drag
        _cItems = cItems;
        _parc = new RECT[2 * _cItems];
        if (_parc)
        {
            for (int i = 0;  i < cItems; i++)
                _parc[i] = prect[i];

            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
            _InitDragData();
        }
    }
    return S_OK;
}

#define ListView_IsIconView(hwndLV)    ((GetWindowLong(hwndLV, GWL_STYLE) & (UINT)LVS_TYPEMASK) == (UINT)LVS_ICON)

HRESULT CDragImages::_SetMultiItemDragging(HWND hwndLV, int cItems, POINT *pptOffset)
{
    HRESULT hr = E_FAIL;

    if (!Initialized())
    {
        // Multiple item drag
        ASSERT(NULL == _parc);

        _parc = new RECT[2 * cItems];
        if (_parc)
        {
            POINT ptTemp;
            int iLast, iNext;
            int cxScreens, cyScreens;
            LPRECT prcNext;
            RECT rc;

            _cItems = 0;
            ASSERT(_fImage == FALSE);

            //
            // If this is a mirrored Window, then lead edge is going
            // to be the far end in screen coord. So let's compute
            // as the original code, and later in _MultipleDragMove
            // we will compensate.
            //
        
            GetWindowRect( hwndLV , &rc );
            ptTemp.x = rc.left;
            ptTemp.y = rc.top;

            //
            // Reflect the shift the if the window is RTL mirrored.
            //
            if (IS_WINDOW_RTL_MIRRORED(hwndLV))
            {
                ptTemp.x = -ptTemp.x;
                pptOffset->x = ((rc.right-rc.left)-pptOffset->x);
            }

            cxScreens = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            cyScreens = GetSystemMetrics(SM_CYVIRTUALSCREEN);

            // for pre-Nashville platforms
            if (!cxScreens || !cyScreens)
            {
                cxScreens = GetSystemMetrics(SM_CXSCREEN);
                cyScreens = GetSystemMetrics(SM_CYSCREEN);
            }

            for (iNext = cItems - 1, iLast = -1, prcNext = _parc; iNext >= 0; --iNext)
            {
                iLast = ListView_GetNextItem(hwndLV, iLast, LVNI_SELECTED);
                if (iLast != -1) 
                {
                    ListView_GetItemRect(hwndLV, iLast, &prcNext[0], LVIR_ICON);
                    OffsetRect(&prcNext[0], ptTemp.x, ptTemp.y);

                    if (((prcNext[0].left - pptOffset->x) < cxScreens) &&
                        ((pptOffset->x - prcNext[0].right) < cxScreens) &&
                        ((prcNext[0].top - pptOffset->y) < cyScreens)) 
                    {

                        ListView_GetItemRect(hwndLV, iLast, &prcNext[1], LVIR_LABEL);
                        OffsetRect(&prcNext[1], ptTemp.x, ptTemp.y);
                        if ((pptOffset->y - prcNext[1].bottom) < cxScreens) 
                        {
                            //
                            // Fix 24857: Ask JoeB why we are drawing a bar instead of
                            //  a text rectangle.
                            //
                            prcNext[1].top = (prcNext[1].top + prcNext[1].bottom)/2;
                            prcNext[1].bottom = prcNext[1].top + 2;
                            prcNext += 2;
                            _cItems += 2;
                        }
                    }
                }
            }

            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
            _InitDragData();
            hr = S_OK;
        }
    }
    return hr;
}

//=====================================================================
// Cursor Merging
//=====================================================================
void CDragImages::_DestroyCachedCursors()
{
    if (_himlCursors) 
    {
        ImageList_Destroy(_himlCursors);
        _himlCursors = NULL;
    }

    HCURSOR hcursor = GetCursor();
    for (int i = 0; i < ARRAYSIZE(_ahcur); i++) 
    {
        if (_ahcur[i])
        {
            if (_ahcur[i] == hcursor)
            {
                //
                // Stuff in some random cursor so that we don't try to
                // destroy the current cursor (and leak it too).
                //
                SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
            }
            DestroyCursor(_ahcur[i]);
            _ahcur[i] = NULL;
        }
    }
}

HBITMAP CDragImages::CreateColorBitmap(int cx, int cy)
{
    HDC hdc = GetDC(NULL);
    HBITMAP hbm = CreateCompatibleBitmap(hdc, cx, cy);
    ReleaseDC(NULL, hdc);
    return hbm;
}

#define CreateMonoBitmap( cx,  cy) CreateBitmap(cx, cy, 1, 1, NULL)
typedef WORD CURMASK;
#define _BitSizeOf(x) (sizeof(x)*8)

HRESULT CDragImages::_GetCursorLowerRight(HCURSOR hcursor, int * px, int * py, POINT *pptHotSpot)
{
    ICONINFO iconinfo;
    HRESULT hr = E_FAIL;
    if (GetIconInfo(hcursor, &iconinfo))
    {
        CURMASK CurMask[16*8];
        BITMAP bm;
        int i;
        int xFine = 16;

        GetObject(iconinfo.hbmMask, sizeof(bm), (LPTSTR)&bm);
        GetBitmapBits(iconinfo.hbmMask, sizeof(CurMask), CurMask);
        pptHotSpot->x = iconinfo.xHotspot;
        pptHotSpot->y = iconinfo.yHotspot;
        if (iconinfo.hbmColor) 
        {
            i = (int)(bm.bmWidth * bm.bmHeight / _BitSizeOf(CURMASK) - 1);
        } 
        else 
        {
            i = (int)(bm.bmWidth * (bm.bmHeight/2) / _BitSizeOf(CURMASK) - 1);
        }

        if ( i >= sizeof(CurMask)) 
        {
            i = sizeof(CurMask) -1;
        }

        // this assumes that the first pixel encountered on this bottom
        // up/right to left search will be reasonably close to the rightmost pixel
        // which for all of our cursors is correct, but it not necessarly correct.

        // also, it assumes the cursor has a good mask... not like the IBeam XOR only
        // cursor
        for (; i >= 0; i--)   
        {
            if (CurMask[i] != 0xFFFF) 
            {
                // this is only accurate to 16 pixels... which is a big gap..
                // so let's try to be a bit more accurate.
                int j;
                DWORD dwMask;

                for (j = 0; j < 16; j++, xFine--) 
                {
                    if (j < 8) 
                    {
                        dwMask = (1 << (8 + j));
                    } 
                    else 
                    {
                        dwMask = (1 << (j - 8));
                    }

                    if (!(CurMask[i] & dwMask))
                        break;
                }
                ASSERT(j < 16);
                break;
            }
        }

        if (iconinfo.hbmColor) 
        {
            DeleteObject(iconinfo.hbmColor);
        }

        if (iconinfo.hbmMask) 
        {
            DeleteObject(iconinfo.hbmMask);
        }

        // Compute the pointer height
        // use width in both directions because the cursor is square, but the
        // height might be doubleheight if it's mono
        *py = ((i + 1) * _BitSizeOf(CURMASK)) / (int)bm.bmWidth;
        *px = ((i * _BitSizeOf(CURMASK)) % (int)bm.bmWidth) + xFine + 2; // hang it off a little
        hr = S_OK;
    }
    return hr;
}

// this will draw iiMerge's image over iiMain on main's lower right.
BOOL CDragImages::_MergeIcons(HCURSOR hcursor, LPCTSTR idMerge, HBITMAP *phbmImage, HBITMAP *phbmMask, POINT* pptHotSpot)
{
    *phbmImage = NULL;
    *phbmMask = NULL;

    BOOL fRet = FALSE;

    int xDraw;
    int yDraw;
    // find the lower corner of the cursor and put it there.
    // do this whether or not we have an idMerge because it will set the hotspot
    if (SUCCEEDED(_GetCursorLowerRight(hcursor, &xDraw, &yDraw, pptHotSpot)))
    {
        int xBitmap;
        int yBitmap;
        int xCursor = GetSystemMetrics(SM_CXCURSOR);
        int yCursor = GetSystemMetrics(SM_CYCURSOR);
        HBITMAP hbmp;
        if (idMerge != (LPCTSTR)-1)
        {
            hbmp = (HBITMAP)LoadImage(HINST_THISDLL, idMerge, IMAGE_BITMAP, 0, 0, 0);
            if (hbmp) 
            {
                BITMAP bm;
                GetObject(hbmp, sizeof(bm), &bm);
                xBitmap = bm.bmWidth;
                yBitmap = bm.bmHeight/2;

                if (xDraw + xBitmap > xCursor)
                    xDraw = xCursor - xBitmap;
                if (yDraw + yBitmap > yCursor)
                    yDraw = yCursor - yBitmap;
            }
        }
        else
            hbmp = NULL;

        HDC hdcCursor = CreateCompatibleDC(NULL);

        HBITMAP hbmMask = CreateMonoBitmap(xCursor, yCursor);
        HBITMAP hbmImage = CreateColorBitmap(xCursor, yCursor);

        if (hdcCursor && hbmMask && hbmImage) 
        {
            HBITMAP hbmTemp = (HBITMAP)SelectObject(hdcCursor, hbmImage);
            DrawIconEx(hdcCursor, 0, 0, hcursor, 0, 0, 0, NULL, DI_NORMAL);

            HDC hdcBitmap;
            if (hbmp) 
            {
                hdcBitmap = CreateCompatibleDC(NULL);
                SelectObject(hdcBitmap, hbmp);

                //blt the two bitmaps onto the color and mask bitmaps for the cursor
                BitBlt(hdcCursor, xDraw, yDraw, xBitmap, yBitmap, hdcBitmap, 0, 0, SRCCOPY);
            }

            SelectObject(hdcCursor, hbmMask);

            DrawIconEx(hdcCursor, 0, 0, hcursor, 0, 0, 0, NULL, DI_MASK);

            if (hbmp) 
            {
                BitBlt(hdcCursor, xDraw, yDraw, xBitmap, yBitmap, hdcBitmap, 0, yBitmap, SRCCOPY);

                // select back in the old bitmaps
                SelectObject(hdcBitmap, hbmTemp);
                DeleteDC(hdcBitmap);
                DeleteObject(hbmp);
            }

            // select back in the old bitmaps
            SelectObject(hdcCursor, hbmTemp);
        }

        if (hdcCursor)
            DeleteDC(hdcCursor);

        *phbmImage = hbmImage;
        *phbmMask = hbmMask;
        fRet = (hbmImage && hbmMask);
    }
    return fRet;
}

// this will take a cursor index and load
int CDragImages::_AddCursorToImageList(HCURSOR hcur, LPCTSTR idMerge, POINT *pptHotSpot)
{
    int iIndex;
    HBITMAP hbmImage, hbmMask;

    // merge in the plus or link arrow if it's specified
    if (_MergeIcons(hcur, idMerge, &hbmImage, &hbmMask, pptHotSpot)) 
    {
        iIndex = ImageList_Add(_himlCursors, hbmImage, hbmMask);
    } 
    else 
    {
        iIndex = -1;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    if (hbmMask)
        DeleteObject(hbmMask);

    return iIndex;
}

int _MapEffectToId(DWORD dwEffect)
{
    int idCursor;

    // DebugMsg(DM_TRACE, "sh TR - DAD_GiveFeedBack dwEffect=%x", dwEffect);

    switch (dwEffect & (DROPEFFECT_COPY|DROPEFFECT_LINK|DROPEFFECT_MOVE))
    {
    case 0:
        idCursor = DCID_NO;
        break;

    case DROPEFFECT_COPY:
        idCursor = DCID_COPY;
        break;

    case DROPEFFECT_LINK:
        idCursor = DCID_LINK;
        break;

    case DROPEFFECT_MOVE:
        idCursor = DCID_MOVE;
        break;

    default:
        // if it's a right drag, we can have any effect... we'll
        // default to the arrow without merging in anything
        idCursor = DCID_MOVE;
        break;
    }

    return idCursor;
}

int CDragImages::_MapCursorIDToImageListIndex(int idCur)
{
    const static struct 
    {
        BOOL   fSystem;
        LPCTSTR idRes;
        LPCTSTR idMerge;
    } 
    c_acurmap[DCID_MAX] = 
    {
        { FALSE, MAKEINTRESOURCE(IDC_NULL), (LPCTSTR)-1},
        { TRUE, IDC_NO, (LPCTSTR)-1 },
        { TRUE, IDC_ARROW, (LPCTSTR)-1 },
        { TRUE, IDC_ARROW, MAKEINTRESOURCE(IDB_PLUS_MERGE) },
        { TRUE, IDC_ARROW, MAKEINTRESOURCE(IDB_LINK_MERGE) },
    };

    ASSERT(idCur >= -1 && idCur < (int)ARRAYSIZE(c_acurmap));

    // -1 means "Initialize the image list index array".
    if (idCur == -1)
    {
        for (int i = 0; i < ARRAYSIZE(c_acurmap); i++) 
        {
            _aindex[i] = -1;
        }
        idCur = 0;  // fall through to return -1
    }
    else
    {
        if (_aindex[idCur] == -1)
        {
            HINSTANCE hinst = c_acurmap[idCur].fSystem ? NULL : HINST_THISDLL;
            HCURSOR hcur = LoadCursor(hinst, c_acurmap[idCur].idRes);
            if (hcur)
            {
                _aindex[idCur] = _AddCursorToImageList(hcur, c_acurmap[idCur].idMerge, &_aptHotSpot[idCur]);
            }
        }
    }
    return _aindex[idCur];
}

HCURSOR CDragImages::_SetCursorHotspot(HCURSOR hcur, POINT *ptHot)
{
    ICONINFO iconinfo = { 0 };
    HCURSOR hcurHotspot;

    GetIconInfo(hcur, &iconinfo);
    iconinfo.xHotspot = ptHot->x;
    iconinfo.yHotspot = ptHot->y;
    iconinfo.fIcon = FALSE;
    hcurHotspot = (HCURSOR)CreateIconIndirect(&iconinfo);
    if (iconinfo.hbmColor) 
    {
        DeleteObject(iconinfo.hbmColor);
    }

    if (iconinfo.hbmMask) 
    {
        DeleteObject(iconinfo.hbmMask);
    }
    return hcurHotspot;
}

void CDragImages::SetDropEffectCursor(int idCur)
{
    if (_himlCursors && (idCur != -1))
    {
        if (!_ahcur[idCur])
        {
            int iIndex = _MapCursorIDToImageListIndex(idCur);
            if (iIndex != -1)
            {
                HCURSOR hcurColor = ImageList_GetIcon(_himlCursors, iIndex, 0);
                //
                // On non C1_COLORCURSOR displays, CopyImage() will enforce
                // monochrome.  So on color cursor displays, we'll get colored
                // dragdrop pix.
                //
                HCURSOR hcurScreen = (HCURSOR)CopyImage(hcurColor, IMAGE_CURSOR,
                    0, 0, LR_COPYRETURNORG | LR_DEFAULTSIZE);

                HCURSOR hcurFinal = _SetCursorHotspot(hcurScreen, &_aptHotSpot[idCur]);

                if ((hcurScreen != hcurColor) && hcurColor)
                {
                    DestroyCursor(hcurColor);
                }

                if (hcurFinal)
                {
                    if (hcurScreen)
                    {
                        DestroyCursor(hcurScreen);
                    }
                }
                else
                {
                    hcurFinal = hcurScreen;
                }

                _ahcur[idCur] = hcurFinal;
            }
        }

        if (_ahcur[idCur]) 
        {
            //
            // This code assumes that SetCursor is pretty quick if it is
            // already set.
            //
            SetCursor(_ahcur[idCur]);
        }
    }
}


//=====================================================================
// CDropSource
//=====================================================================

class CDropSource : public IDropSource
{
private:
    LONG            _cRef;
    DWORD           _grfInitialKeyState;
    IDataObject*    _pdtobj;

public:
    explicit CDropSource(IDataObject *pdtobj);
    virtual ~CDropSource();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropSource methods
    STDMETHODIMP GiveFeedback(DWORD dwEffect);
    STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
};


void DAD_ShowCursor(BOOL fShow)
{
    static BOOL s_fCursorHidden = FALSE;

    if (fShow) 
    {
        if (s_fCursorHidden)
        {
            ShowCursor(TRUE);
            s_fCursorHidden = FALSE;
        }
    } 
    else 
    {
        if (!s_fCursorHidden)
        {
            ShowCursor(FALSE);
            s_fCursorHidden = TRUE;
        }
    }
}

CDropSource::CDropSource(IDataObject *pdtobj) : _cRef(1), _pdtobj(pdtobj), _grfInitialKeyState(0)
{
    _pdtobj->AddRef();
    
    // Tell the data object that we're entering the drag loop.
    DataObj_SetDWORD(_pdtobj, g_cfInDragLoop, 1);
}

CDropSource::~CDropSource()
{
    DAD_ShowCursor(TRUE); // just in case
    _pdtobj->Release();
}

//
// Create an instance of CDropSource
//
STDMETHODIMP CDropSource_CreateInstance(IDropSource **ppdsrc, IDataObject *pdtobj)
{
    *ppdsrc = new CDropSource(pdtobj);
    return *ppdsrc ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropSource, IDropSource),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDropSource::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    HRESULT hr = S_OK;

    if (fEscapePressed)
    {
        hr = DRAGDROP_S_CANCEL;
    }
    else
    {
        // initialize ourself with the drag begin button
        if (_grfInitialKeyState == 0)
            _grfInitialKeyState = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

        // If the window is hung for a while, the drag operation can happen before
        // the first call to this function, so grfInitialKeyState will be 0. If this
        // happened, then we did a drop. No need to assert...
        //ASSERT(this->grfInitialKeyState);

        if (!(grfKeyState & _grfInitialKeyState))
        {
            //
            // A button is released.
            //
            hr = DRAGDROP_S_DROP;
        }
        else if (_grfInitialKeyState != (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)))
        {
            //
            //  If the button state is changed (except the drop case, which we handle
            // above, cancel the drag&drop.
            //
            hr = DRAGDROP_S_CANCEL;
        }
    }

    if (hr != S_OK)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        DAD_ShowCursor(TRUE);
        DAD_SetDragCursor(DCID_NULL);

        // Tell the data object that we're leaving the drag loop.
        if (_pdtobj)
           DataObj_SetDWORD(_pdtobj, g_cfInDragLoop, 0);
    }

    return hr;
}

STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    int idCursor = _MapEffectToId(dwEffect);

    //
    //  OLE does not give us DROPEFFECT_MOVE even though our IDT::DragOver
    // returns it, if we haven't set that bit when we have called DoDragDrop.
    // Instead of arguing whether or not this is a bug or by-design of OLE,
    // we work around it. It is important to note that this hack around
    // g_fDraggingOverSource is purely visual hack. It won't affect the
    // actual drag&drop operations at all (DV_AlterEffect does it all).
    //
    // - SatoNa
    //
    if (idCursor == DCID_NO && g_fDraggingOverSource)
    {
        idCursor = DCID_MOVE;
    }
    
    //
    //  No need to merge the cursor, if we are not dragging over to
    // one of shell windows.
    //
    if (DAD_IsDraggingImage())
    {
        // Feedback for single (image) dragging
        DAD_ShowCursor(FALSE);
        DAD_SetDragCursor(idCursor);
    }
    else if (DAD_IsDragging() && g_pdiDragImages)
    {
        // Feedback for multiple (rectangles) dragging
        g_pdiDragImages->SetDropEffectCursor(idCursor);
        DAD_ShowCursor(TRUE);
        return NOERROR;
    }
    else
    {
        DAD_ShowCursor(TRUE);
    }

    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//=====================================================================
// DAD
//=====================================================================

void FixupDragPoint(HWND hwnd, POINT* ppt)
{
    if (hwnd)
    {
        RECT rc = {0};
        GetWindowRect(hwnd, &rc);
        ppt->x += rc.left;
        ppt->y += rc.top;
    }
}

BOOL DAD_InitDragImages()
{
    if (!g_pdiDragImages)
        CDragImages_CreateInstance(NULL, IID_IDragSourceHelper, NULL);

    return g_pdiDragImages != NULL;
}


STDAPI_(BOOL) DAD_ShowDragImage(BOOL bShow)
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->Show(bShow) == S_OK ? TRUE : FALSE;
    return FALSE;
}

BOOL DAD_IsDragging()
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->IsDragging();
    return FALSE;
}

void DAD_SetDragCursor(int idCursor)
{
    if (DAD_InitDragImages())
        g_pdiDragImages->SetDragCursor(idCursor);
}

STDAPI_(BOOL) DAD_DragEnterEx3(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtobj)
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);

    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    POINT pt;
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    return DAD_DragEnterEx2(hwndTarget, pt, pdtobj);
}

STDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    if (DAD_InitDragImages())
    {
        POINT pt = ptStart;
        FixupDragPoint(hwndTarget, &pt);
        bRet = SUCCEEDED(g_pdiDragImages->DragEnter(hwndTarget, pdtobj, &pt, NULL));
    }
    return bRet;
}

STDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart)
{
    return DAD_DragEnterEx2(hwndTarget, ptStart, NULL);
}

STDAPI_(BOOL) DAD_DragEnter(HWND hwndTarget)
{
    POINT ptStart;

    GetCursorPos(&ptStart);
    if (hwndTarget) 
        ScreenToClient(hwndTarget, &ptStart);

    return DAD_DragEnterEx(hwndTarget, ptStart);
}

STDAPI_(BOOL) DAD_DragMoveEx(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);

    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    POINT pt;
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    return DAD_DragMove(pt);
}


STDAPI_(BOOL) DAD_DragMove(POINT pt)
{
    if (DAD_InitDragImages())
    {
        FixupDragPoint(g_pdiDragImages->GetTarget(), &pt);
        return g_pdiDragImages->DragOver(&pt, 0);
    }
    return FALSE;
}

STDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT *pptOffset)
{
    if (DAD_InitDragImages() && !g_pdiDragImages->IsDraggingLayeredWindow())
    {
        //
        // DAD_SetDragImage(-1, NULL) means "clear the drag image only
        //  if the image is set by this thread"
        //
        if (him == (HIMAGELIST)-1)
        {
            BOOL fThisThreadHasImage = FALSE;
            ENTERCRITICAL;
            if (g_pdiDragImages->Initialized() && g_pdiDragImages->GetThread() == GetCurrentThreadId())
            {
                fThisThreadHasImage = TRUE;
            }
            LEAVECRITICAL;

            if (fThisThreadHasImage)
            {
                g_pdiDragImages->FreeDragData();
                return TRUE;
            }
            return FALSE;
        }

        return g_pdiDragImages->SetDragImage(him, 0, pptOffset);
    }

    return TRUE;
}

//
//  This function returns TRUE, if we are dragging an image. It means
// you have called either DAD_SetDragImage (with him != NULL) or
// DAD_SetDragImageFromListview.
//
BOOL DAD_IsDraggingImage(void)
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->IsDraggingImage();
    return FALSE;
}


STDAPI_(BOOL) DAD_DragLeave()
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->DragLeave();
    return FALSE;
}

STDAPI_(void) DAD_ProcessDetach(void)
{
    if (g_pdiDragImages)
    {
        g_pdiDragImages->ProcessDetach();
        g_pdiDragImages->Release();
    }
}

STDAPI_(void) DAD_ThreadDetach(void)
{
    if (g_pdiDragImages)
        g_pdiDragImages->ThreadDetach();
}

// called from defview on SPI_SETCURSORS (user changed the system cursors)
STDAPI_(void) DAD_InvalidateCursors(void)
{
    g_cRev++;
}

STDAPI_(BOOL) DAD_SetDragImageFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj)
{
    if (DAD_InitDragImages())
        return S_OK == g_pdiDragImages->InitializeFromWindow(hwnd, ppt, pdtobj);
    return FALSE;
}

// shell32.dll export, but only used by print queue window code
//
STDAPI_(BOOL) DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset)
{
    // really a nop, as this does not have access to the data object
    return DAD_InitDragImages();
}

// wrapper around OLE DoDragDrop(), will create drag source on demand and supports
// drag images for you

STDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdtobj, IDropSource *pdsrc, DWORD dwEffect, DWORD *pdwEffect)
{
    IDropSource *pdsrcRelease = NULL;

    if (pdsrc == NULL)
    {
        CDropSource_CreateInstance(&pdsrcRelease, pdtobj);
        pdsrc = pdsrcRelease;
    }

    // if there is no drag contents clipboard format present, try to add it
    FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    if (S_OK != pdtobj->QueryGetData(&fmte))
    {
        if (DAD_InitDragImages())
            g_pdiDragImages->InitializeFromWindow(hwnd, NULL, pdtobj);
    }

    HRESULT hr = DoDragDrop(pdtobj, pdsrc, dwEffect, pdwEffect);

    if (pdsrcRelease)
        pdsrcRelease->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\defxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

class CExtractIcon : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
    HRESULT _Init(LPCWSTR pszModule, LPCWSTR pszModuleOpen);

    CExtractIcon(int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags);

private:
    ~CExtractIcon();

private:
    int    _iIcon;
    int    _iIconOpen;
    int    _iDefIcon;
    int    _iShortcutIcon;
    UINT   _uFlags; // GIL_SIMULATEDOC/PERINSTANCE/PERCLASS
    LPWSTR _pszModule;
    LPWSTR _pszModuleOpen;
};

CExtractIcon::CExtractIcon(int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags) :
    CExtractIconBase(), 
    _iIcon(iIcon), _iIconOpen(iIconOpen),_iDefIcon(iDefIcon), _iShortcutIcon(iShortcutIcon),
    _uFlags(uFlags), _pszModule(NULL), _pszModuleOpen(NULL)
{
}

CExtractIcon::~CExtractIcon()
{
    LocalFree((HLOCAL)_pszModule);      // accpets NULL
    if (_pszModuleOpen != _pszModule)
        LocalFree((HLOCAL)_pszModuleOpen);  // accpets NULL
}

HRESULT CExtractIcon::_Init(LPCWSTR pszModule, LPCWSTR pszModuleOpen)
{
    HRESULT hr = S_OK;

    _pszModule = StrDup(pszModule);
    if (_pszModule)
    {
        if (pszModuleOpen)
        {
            _pszModuleOpen = StrDup(pszModuleOpen);

            if (!_pszModuleOpen)
            {
                LocalFree((HLOCAL)_pszModule);
                _pszModule = NULL;

                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            _pszModuleOpen = _pszModule;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI SHCreateDefExtIcon(LPCWSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, int iDefIcon, REFIID riid, void** ppv)
{
    return SHCreateDefExtIconKey(NULL, pszModule, iIcon, iIconOpen, iDefIcon, iIcon, uFlags, riid, ppv);
}

// returns S_FALSE to mean "The hkey didn't have an icon so I created a default one"

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCWSTR pszModule, int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags, REFIID riid, void **ppv)
{
    WCHAR szModule[MAX_PATH];
    WCHAR szModuleOpen[MAX_PATH];
    HRESULT hr;

    HRESULT hrSuccess = S_OK;
    LPWSTR pszModuleOpen = NULL;

    if (hkey)
    {
        HKEY hkChild;

        if (RegOpenKeyEx(hkey, c_szDefaultIcon, 0, KEY_QUERY_VALUE,
            &hkChild) == ERROR_SUCCESS)
        {
            DWORD cb = sizeof(szModule);

            if (SHQueryValueEx(hkChild, NULL, NULL, NULL, szModule, &cb) ==
                ERROR_SUCCESS && szModule[0])
            {
                iIcon = PathParseIconLocation(szModule);
                iIconOpen = iIcon;
                pszModule = szModule;

                cb = sizeof(szModuleOpen);
                if (SHQueryValueEx(hkChild, TEXT("OpenIcon"), NULL, NULL,
                    szModuleOpen, &cb) == ERROR_SUCCESS && szModuleOpen[0])
                {
                    iIconOpen = PathParseIconLocation(szModuleOpen);
                    pszModuleOpen = szModuleOpen;
                }
            }
            else
            {
                hrSuccess = S_FALSE;
            }

            RegCloseKey(hkChild);
        }
        else
        {
            hrSuccess = S_FALSE;
        }
    }

    if ((NULL == pszModule) || (0 == *pszModule))
    {
        // REVIEW: We should be able to make it faster!
        GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));
        pszModule = szModule;
    }

    CExtractIcon* pdeib = new CExtractIcon(iIcon, iIconOpen, iDefIcon, iShortcutIcon, uFlags);
    if (pdeib)
    {
        hr = pdeib->_Init(pszModule, pszModuleOpen);
        if (SUCCEEDED(hr))
        {
            hr = pdeib->QueryInterface(riid, ppv);
        }
        pdeib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = hrSuccess;
    }

    return hr;
}

HRESULT CExtractIcon::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_FALSE;
    pszIconFile[0] = 0;


    if (uFlags & GIL_DEFAULTICON)
    {
        if (-1 != _iDefIcon)
        {
            lstrcpyn(pszIconFile, c_szShell32Dll, cchMax);

            *piIndex = _iDefIcon;
            *pwFlags = _uFlags;

            // Make sure our default icon makes it to the cache
            Shell_GetCachedImageIndex(pszIconFile, *piIndex, *pwFlags);

            hr = S_OK;
        }
    }
    else
    {
        int iIcon;

        if ((uFlags & GIL_FORSHORTCUT) && (-1 != _iShortcutIcon))
        {
            iIcon = _iShortcutIcon;
        }
        else if (uFlags & GIL_OPENICON)
        {
            iIcon = _iIconOpen;
        }
        else
        {
            iIcon = _iIcon;
        }

        if ((UINT)-1 != iIcon)
        {
            lstrcpyn(pszIconFile, (uFlags & GIL_OPENICON) ? _pszModuleOpen : _pszModule, cchMax);

            *piIndex = iIcon;
            *pwFlags = _uFlags;

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CExtractIcon::_ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_FALSE;

    if (_uFlags & GIL_NOTFILENAME)
    {
        //  "*" as the file name means iIndex is already a system
        //  icon index, we are done.
        //
        //  defview never calls us in this case, but external people will.
        if ((L'*' == pszFile[0]) && (0 == pszFile[1